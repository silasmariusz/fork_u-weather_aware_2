(function(){"use strict";const os={enabled:!0,weather_entity:"weather.openweathermap",development_mode:!1,test_effect:"Use Real Weather",sun_entity:"sun.sun",moon_phase_entity:null,uv_index_entity:null,moon_position_entity:null,moon_azimuth_entity:null,moon_altitude_entity:null,moon_distance_entity:null,gaming_mode_entity:null,pm25_entity:null,pm4_entity:null,pm10_entity:null,smog_threshold_pm25:35,smog_threshold_pm4:50,smog_threshold_pm10:50,cloud_coverage_entity:null,wind_speed_entity:null,wind_direction_entity:null,precipitation_entity:null,lightning_counter_entity:null,lightning_distance_entity:null,debug_precipitation:null,debug_wind_speed:null,debug_wind_direction:null,debug_lightning_distance:null,debug_lightning_counter:null,debug_cloud_coverage:null,cloud_speed_multiplier:1,rain_max_tilt_deg:30,rain_wind_min_kmh:3,theme_mode:null,drizzle_precipitation_max:2.5,speed_factor_rain:1,speed_factor_snow:1,speed_factor_clouds:1,speed_factor_fog:1,speed_factor_smog:1,speed_factor_hail:1,speed_factor_lightning:1,speed_factor_stars:1,speed_factor_matrix:1,wind_sway_factor:.7,spatial_mode:"foreground",enable_rain:!0,enable_snow:!0,enable_clouds:!0,enable_fog:!0,enable_smog_effect:!0,enable_sun_glow:!0,enable_moon_glow:!0,enable_stars:!0,enable_hail:!0,enable_lightning_effect:!0,enable_matrix:!0,enable_window_droplets:!0,stars_require_moon:!1,mobile_limit_dpr:!0,mobile_reduce_particles:!0,mobile_snowy2_light:!0,mobile_smog_simple:!1,mobile_30fps:!1,gaming_matrix_only:!1,snowy_variant:"snowy2",enable_aurora_effect:!0,aurora_variant:"bands",aurora_chance_entity:null,aurora_visibility_alert_entity:null,aurora_visibility_min:.15,k_index_entity:null,debug_aurora_score:null,opacity_moon:100,opacity_clouds:100,opacity_aurora:100,opacity_stars:100,opacity_droplets:100,opacity_sun:100,opacity_fog:100,opacity_smog:100};window.ForkUWeatherAwareConfig=Object.assign({},os,window.ForkUWeatherAwareConfig||{}),window.ForkUWeatherAwareDefaultConfig=os;try{console.log("%cFork U – Weather Aware%c Three.js overlay · spatial, theme & mobile aware","background:#ffcc00;color:#000;font-weight:bold;padding:2px 6px;border-radius:3px 0 0 3px;","background:#1e1e1e;color:#fff;padding:2px 6px;border-radius:0 3px 3px 0;")}catch{}/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const xi="170",yc=0,ms=1,Cc=2,Zs=1,Sc=2,Oe=3,ml=0,ye=1,qe=2,Zl=0,Pe=1,fe=2,hs=3,us=4,Ic=5,Sl=100,xc=101,Yc=102,Nc=103,fc=104,Fc=200,Lc=201,Mc=202,Uc=203,Yi=204,Ni=205,Tc=206,vc=207,Jc=208,kc=209,wc=210,zc=211,Hc=212,Kc=213,Bc=214,fi=0,Fi=1,Li=2,zl=3,Mi=4,Ui=5,Ti=6,vi=7,bs=0,Ec=1,Ac=2,hl=0,Pc=1,Qc=2,jc=3,_c=4,Dc=5,Oc=6,qc=7,rs=300,Hl=301,Kl=302,Ji=303,ki=304,Jn=306,wi=1e3,Il=1001,zi=1002,Je=1003,$c=1004,kn=1005,be=1006,Hi=1007,xl=1008,Qe=1009,ps=1010,Gs=1011,Gn=1012,Ki=1013,Yl=1014,$e=1015,Wn=1016,Bi=1017,Ei=1018,Bl=1020,Ws=35902,Vs=1021,Xs=1022,Fe=1023,gs=1024,Rs=1025,El=1026,Al=1027,ys=1028,Ai=1029,Cs=1030,Pi=1031,Qi=1033,wn=33776,zn=33777,Hn=33778,Kn=33779,ji=35840,_i=35841,Di=35842,Oi=35843,qi=36196,$i=37492,ta=37496,ea=37808,la=37809,na=37810,ia=37811,aa=37812,sa=37813,da=37814,ca=37815,oa=37816,ma=37817,Za=37818,ha=37819,ua=37820,ba=37821,Bn=36492,ra=36494,pa=36495,Ss=36283,Ga=36284,Wa=36285,Va=36286,to=3200,eo=3201,lo=0,no=1,ul="",Le="srgb",Pl="srgb-linear",En="linear",Pt="srgb",Ql=7680,Is=519,io=512,ao=513,so=514,xs=515,co=516,oo=517,mo=518,Zo=519,Ys=35044,Ns="300 es",tl=2e3,An=2001;class jl{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const i=this._listeners[t];if(i!==void 0){const s=i.indexOf(e);s!==-1&&i.splice(s,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const n=this._listeners[t.type];if(n!==void 0){t.target=this;const i=n.slice(0);for(let s=0,a=i.length;s<a;s++)i[s].call(this,t);t.target=null}}}const re=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let fs=1234567;const Vn=Math.PI/180,Xn=180/Math.PI;function _l(){const l=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(re[l&255]+re[l>>8&255]+re[l>>16&255]+re[l>>24&255]+"-"+re[t&255]+re[t>>8&255]+"-"+re[t>>16&15|64]+re[t>>24&255]+"-"+re[e&63|128]+re[e>>8&255]+"-"+re[e>>16&255]+re[e>>24&255]+re[n&255]+re[n>>8&255]+re[n>>16&255]+re[n>>24&255]).toLowerCase()}function Ve(l,t,e){return Math.max(t,Math.min(e,l))}function Xa(l,t){return(l%t+t)%t}function ho(l,t,e,n,i){return n+(l-t)*(i-n)/(e-t)}function uo(l,t,e){return l!==t?(e-l)/(t-l):0}function gn(l,t,e){return(1-e)*l+e*t}function bo(l,t,e,n){return gn(l,t,1-Math.exp(-e*n))}function ro(l,t=1){return t-Math.abs(Xa(l,t*2)-t)}function po(l,t,e){return l<=t?0:l>=e?1:(l=(l-t)/(e-t),l*l*(3-2*l))}function Go(l,t,e){return l<=t?0:l>=e?1:(l=(l-t)/(e-t),l*l*l*(l*(l*6-15)+10))}function Wo(l,t){return l+Math.floor(Math.random()*(t-l+1))}function Vo(l,t){return l+Math.random()*(t-l)}function Xo(l){return l*(.5-Math.random())}function go(l){l!==void 0&&(fs=l);let t=fs+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}function Ro(l){return l*Vn}function yo(l){return l*Xn}function Co(l){return(l&l-1)===0&&l!==0}function So(l){return Math.pow(2,Math.ceil(Math.log(l)/Math.LN2))}function Io(l){return Math.pow(2,Math.floor(Math.log(l)/Math.LN2))}function xo(l,t,e,n,i){const s=Math.cos,a=Math.sin,d=s(e/2),c=a(e/2),o=s((t+n)/2),Z=a((t+n)/2),m=s((t-n)/2),b=a((t-n)/2),h=s((n-t)/2),p=a((n-t)/2);switch(i){case"XYX":l.set(d*Z,c*m,c*b,d*o);break;case"YZY":l.set(c*b,d*Z,c*m,d*o);break;case"ZXZ":l.set(c*m,c*b,d*Z,d*o);break;case"XZX":l.set(d*Z,c*p,c*h,d*o);break;case"YXY":l.set(c*h,d*Z,c*p,d*o);break;case"ZYZ":l.set(c*p,c*h,d*Z,d*o);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function Dl(l,t){switch(t.constructor){case Float32Array:return l;case Uint32Array:return l/4294967295;case Uint16Array:return l/65535;case Uint8Array:return l/255;case Int32Array:return Math.max(l/2147483647,-1);case Int16Array:return Math.max(l/32767,-1);case Int8Array:return Math.max(l/127,-1);default:throw new Error("Invalid component type.")}}function Xe(l,t){switch(t.constructor){case Float32Array:return l;case Uint32Array:return Math.round(l*4294967295);case Uint16Array:return Math.round(l*65535);case Uint8Array:return Math.round(l*255);case Int32Array:return Math.round(l*2147483647);case Int16Array:return Math.round(l*32767);case Int8Array:return Math.round(l*127);default:throw new Error("Invalid component type.")}}const jt={DEG2RAD:Vn,RAD2DEG:Xn,generateUUID:_l,clamp:Ve,euclideanModulo:Xa,mapLinear:ho,inverseLerp:uo,lerp:gn,damp:bo,pingpong:ro,smoothstep:po,smootherstep:Go,randInt:Wo,randFloat:Vo,randFloatSpread:Xo,seededRandom:go,degToRad:Ro,radToDeg:yo,isPowerOfTwo:Co,ceilPowerOfTwo:So,floorPowerOfTwo:Io,setQuaternionFromProperEuler:xo,normalize:Xe,denormalize:Dl};class ft{constructor(t=0,e=0){ft.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Ve(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),s=this.x-t.x,a=this.y-t.y;return this.x=s*n-a*i+t.x,this.y=s*i+a*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class xt{constructor(t,e,n,i,s,a,d,c,o){xt.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],t!==void 0&&this.set(t,e,n,i,s,a,d,c,o)}set(t,e,n,i,s,a,d,c,o){const Z=this.elements;return Z[0]=t,Z[1]=i,Z[2]=d,Z[3]=e,Z[4]=s,Z[5]=c,Z[6]=n,Z[7]=a,Z[8]=o,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,s=this.elements,a=n[0],d=n[3],c=n[6],o=n[1],Z=n[4],m=n[7],b=n[2],h=n[5],p=n[8],V=i[0],r=i[3],u=i[6],C=i[1],y=i[4],G=i[7],N=i[2],I=i[5],x=i[8];return s[0]=a*V+d*C+c*N,s[3]=a*r+d*y+c*I,s[6]=a*u+d*G+c*x,s[1]=o*V+Z*C+m*N,s[4]=o*r+Z*y+m*I,s[7]=o*u+Z*G+m*x,s[2]=b*V+h*C+p*N,s[5]=b*r+h*y+p*I,s[8]=b*u+h*G+p*x,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],a=t[4],d=t[5],c=t[6],o=t[7],Z=t[8];return e*a*Z-e*d*o-n*s*Z+n*d*c+i*s*o-i*a*c}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],a=t[4],d=t[5],c=t[6],o=t[7],Z=t[8],m=Z*a-d*o,b=d*c-Z*s,h=o*s-a*c,p=e*m+n*b+i*h;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const V=1/p;return t[0]=m*V,t[1]=(i*o-Z*n)*V,t[2]=(d*n-i*a)*V,t[3]=b*V,t[4]=(Z*e-i*c)*V,t[5]=(i*s-d*e)*V,t[6]=h*V,t[7]=(n*c-o*e)*V,t[8]=(a*e-n*s)*V,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,s,a,d){const c=Math.cos(s),o=Math.sin(s);return this.set(n*c,n*o,-n*(c*a+o*d)+a+t,-i*o,i*c,-i*(-o*a+c*d)+d+e,0,0,1),this}scale(t,e){return this.premultiply(ga.makeScale(t,e)),this}rotate(t){return this.premultiply(ga.makeRotation(-t)),this}translate(t,e){return this.premultiply(ga.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,n,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<9;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}const ga=new xt;function Fs(l){for(let t=l.length-1;t>=0;--t)if(l[t]>=65535)return!0;return!1}function Pn(l){return document.createElementNS("http://www.w3.org/1999/xhtml",l)}function Yo(){const l=Pn("canvas");return l.style.display="block",l}const Ls={};function Rn(l){l in Ls||(Ls[l]=!0,console.warn(l))}function No(l,t,e){return new Promise(function(n,i){function s(){switch(l.clientWaitSync(t,l.SYNC_FLUSH_COMMANDS_BIT,0)){case l.WAIT_FAILED:i();break;case l.TIMEOUT_EXPIRED:setTimeout(s,e);break;default:n()}}setTimeout(s,e)})}function fo(l){const t=l.elements;t[2]=.5*t[2]+.5*t[3],t[6]=.5*t[6]+.5*t[7],t[10]=.5*t[10]+.5*t[11],t[14]=.5*t[14]+.5*t[15]}function Fo(l){const t=l.elements;t[11]===-1?(t[10]=-t[10]-1,t[14]=-t[14]):(t[10]=-t[10],t[14]=-t[14]+1)}const kt={enabled:!0,workingColorSpace:Pl,spaces:{},convert:function(l,t,e){return this.enabled===!1||t===e||!t||!e||(this.spaces[t].transfer===Pt&&(l.r=el(l.r),l.g=el(l.g),l.b=el(l.b)),this.spaces[t].primaries!==this.spaces[e].primaries&&(l.applyMatrix3(this.spaces[t].toXYZ),l.applyMatrix3(this.spaces[e].fromXYZ)),this.spaces[e].transfer===Pt&&(l.r=Ol(l.r),l.g=Ol(l.g),l.b=Ol(l.b))),l},fromWorkingColorSpace:function(l,t){return this.convert(l,this.workingColorSpace,t)},toWorkingColorSpace:function(l,t){return this.convert(l,t,this.workingColorSpace)},getPrimaries:function(l){return this.spaces[l].primaries},getTransfer:function(l){return l===ul?En:this.spaces[l].transfer},getLuminanceCoefficients:function(l,t=this.workingColorSpace){return l.fromArray(this.spaces[t].luminanceCoefficients)},define:function(l){Object.assign(this.spaces,l)},_getMatrix:function(l,t,e){return l.copy(this.spaces[t].toXYZ).multiply(this.spaces[e].fromXYZ)},_getDrawingBufferColorSpace:function(l){return this.spaces[l].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(l=this.workingColorSpace){return this.spaces[l].workingColorSpaceConfig.unpackColorSpace}};function el(l){return l<.04045?l*.0773993808:Math.pow(l*.9478672986+.0521327014,2.4)}function Ol(l){return l<.0031308?l*12.92:1.055*Math.pow(l,.41666)-.055}const Ms=[.64,.33,.3,.6,.15,.06],Us=[.2126,.7152,.0722],Ts=[.3127,.329],vs=new xt().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),Js=new xt().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);kt.define({[Pl]:{primaries:Ms,whitePoint:Ts,transfer:En,toXYZ:vs,fromXYZ:Js,luminanceCoefficients:Us,workingColorSpaceConfig:{unpackColorSpace:Le},outputColorSpaceConfig:{drawingBufferColorSpace:Le}},[Le]:{primaries:Ms,whitePoint:Ts,transfer:Pt,toXYZ:vs,fromXYZ:Js,luminanceCoefficients:Us,outputColorSpaceConfig:{drawingBufferColorSpace:Le}}});let ql;class Lo{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{ql===void 0&&(ql=Pn("canvas")),ql.width=t.width,ql.height=t.height;const n=ql.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=ql}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=Pn("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");n.drawImage(t,0,0,t.width,t.height);const i=n.getImageData(0,0,t.width,t.height),s=i.data;for(let a=0;a<s.length;a++)s[a]=el(s[a]/255)*255;return n.putImageData(i,0,0),e}else if(t.data){const e=t.data.slice(0);for(let n=0;n<e.length;n++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[n]=Math.floor(el(e[n]/255)*255):e[n]=el(e[n]);return{data:e,width:t.width,height:t.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let Mo=0;class ks{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:Mo++}),this.uuid=_l(),this.data=t,this.dataReady=!0,this.version=0}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(i!==null){let s;if(Array.isArray(i)){s=[];for(let a=0,d=i.length;a<d;a++)i[a].isDataTexture?s.push(Ra(i[a].image)):s.push(Ra(i[a]))}else s=Ra(i);n.url=s}return e||(t.images[this.uuid]=n),n}}function Ra(l){return typeof HTMLImageElement<"u"&&l instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&l instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&l instanceof ImageBitmap?Lo.getDataURL(l):l.data?{data:Array.from(l.data),width:l.width,height:l.height,type:l.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Uo=0;class ge extends jl{constructor(t=ge.DEFAULT_IMAGE,e=ge.DEFAULT_MAPPING,n=Il,i=Il,s=be,a=xl,d=Fe,c=Qe,o=ge.DEFAULT_ANISOTROPY,Z=ul){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Uo++}),this.uuid=_l(),this.name="",this.source=new ks(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=n,this.wrapT=i,this.magFilter=s,this.minFilter=a,this.anisotropy=o,this.format=d,this.internalFormat=null,this.type=c,this.offset=new ft(0,0),this.repeat=new ft(1,1),this.center=new ft(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new xt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=Z,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==rs)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case wi:t.x=t.x-Math.floor(t.x);break;case Il:t.x=t.x<0?0:1;break;case zi:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case wi:t.y=t.y-Math.floor(t.y);break;case Il:t.y=t.y<0?0:1;break;case zi:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){t===!0&&this.pmremVersion++}}ge.DEFAULT_IMAGE=null,ge.DEFAULT_MAPPING=rs,ge.DEFAULT_ANISOTROPY=1;class ie{constructor(t=0,e=0,n=0,i=1){ie.prototype.isVector4=!0,this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,s=this.w,a=t.elements;return this.x=a[0]*e+a[4]*n+a[8]*i+a[12]*s,this.y=a[1]*e+a[5]*n+a[9]*i+a[13]*s,this.z=a[2]*e+a[6]*n+a[10]*i+a[14]*s,this.w=a[3]*e+a[7]*n+a[11]*i+a[15]*s,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,s;const c=t.elements,o=c[0],Z=c[4],m=c[8],b=c[1],h=c[5],p=c[9],V=c[2],r=c[6],u=c[10];if(Math.abs(Z-b)<.01&&Math.abs(m-V)<.01&&Math.abs(p-r)<.01){if(Math.abs(Z+b)<.1&&Math.abs(m+V)<.1&&Math.abs(p+r)<.1&&Math.abs(o+h+u-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const y=(o+1)/2,G=(h+1)/2,N=(u+1)/2,I=(Z+b)/4,x=(m+V)/4,U=(p+r)/4;return y>G&&y>N?y<.01?(n=0,i=.707106781,s=.707106781):(n=Math.sqrt(y),i=I/n,s=x/n):G>N?G<.01?(n=.707106781,i=0,s=.707106781):(i=Math.sqrt(G),n=I/i,s=U/i):N<.01?(n=.707106781,i=.707106781,s=0):(s=Math.sqrt(N),n=x/s,i=U/s),this.set(n,i,s,e),this}let C=Math.sqrt((r-p)*(r-p)+(m-V)*(m-V)+(b-Z)*(b-Z));return Math.abs(C)<.001&&(C=1),this.x=(r-p)/C,this.y=(m-V)/C,this.z=(b-Z)/C,this.w=Math.acos((o+h+u-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class To extends jl{constructor(t=1,e=1,n={}){super(),this.isRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new ie(0,0,t,e),this.scissorTest=!1,this.viewport=new ie(0,0,t,e);const i={width:t,height:e,depth:1};n=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:be,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},n);const s=new ge(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace);s.flipY=!1,s.generateMipmaps=n.generateMipmaps,s.internalFormat=n.internalFormat,this.textures=[];const a=n.count;for(let d=0;d<a;d++)this.textures[d]=s.clone(),this.textures[d].isRenderTargetTexture=!0;this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,this.resolveDepthBuffer=n.resolveDepthBuffer,this.resolveStencilBuffer=n.resolveStencilBuffer,this.depthTexture=n.depthTexture,this.samples=n.samples}get texture(){return this.textures[0]}set texture(t){this.textures[0]=t}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let i=0,s=this.textures.length;i<s;i++)this.textures[i].image.width=t,this.textures[i].image.height=e,this.textures[i].image.depth=n;this.dispose()}this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.textures.length=0;for(let n=0,i=t.textures.length;n<i;n++)this.textures[n]=t.textures[n].clone(),this.textures[n].isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new ks(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.resolveDepthBuffer=t.resolveDepthBuffer,this.resolveStencilBuffer=t.resolveStencilBuffer,t.depthTexture!==null&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class bl extends To{constructor(t=1,e=1,n={}){super(t,e,n),this.isWebGLRenderTarget=!0}}class ws extends ge{constructor(t=null,e=1,n=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:n,depth:i},this.magFilter=Je,this.minFilter=Je,this.wrapR=Il,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class vo extends ge{constructor(t=null,e=1,n=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:e,height:n,depth:i},this.magFilter=Je,this.minFilter=Je,this.wrapR=Il,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class yn{constructor(t=0,e=0,n=0,i=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=n,this._w=i}static slerpFlat(t,e,n,i,s,a,d){let c=n[i+0],o=n[i+1],Z=n[i+2],m=n[i+3];const b=s[a+0],h=s[a+1],p=s[a+2],V=s[a+3];if(d===0){t[e+0]=c,t[e+1]=o,t[e+2]=Z,t[e+3]=m;return}if(d===1){t[e+0]=b,t[e+1]=h,t[e+2]=p,t[e+3]=V;return}if(m!==V||c!==b||o!==h||Z!==p){let r=1-d;const u=c*b+o*h+Z*p+m*V,C=u>=0?1:-1,y=1-u*u;if(y>Number.EPSILON){const N=Math.sqrt(y),I=Math.atan2(N,u*C);r=Math.sin(r*I)/N,d=Math.sin(d*I)/N}const G=d*C;if(c=c*r+b*G,o=o*r+h*G,Z=Z*r+p*G,m=m*r+V*G,r===1-d){const N=1/Math.sqrt(c*c+o*o+Z*Z+m*m);c*=N,o*=N,Z*=N,m*=N}}t[e]=c,t[e+1]=o,t[e+2]=Z,t[e+3]=m}static multiplyQuaternionsFlat(t,e,n,i,s,a){const d=n[i],c=n[i+1],o=n[i+2],Z=n[i+3],m=s[a],b=s[a+1],h=s[a+2],p=s[a+3];return t[e]=d*p+Z*m+c*h-o*b,t[e+1]=c*p+Z*b+o*m-d*h,t[e+2]=o*p+Z*h+d*b-c*m,t[e+3]=Z*p-d*m-c*b-o*h,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const n=t._x,i=t._y,s=t._z,a=t._order,d=Math.cos,c=Math.sin,o=d(n/2),Z=d(i/2),m=d(s/2),b=c(n/2),h=c(i/2),p=c(s/2);switch(a){case"XYZ":this._x=b*Z*m+o*h*p,this._y=o*h*m-b*Z*p,this._z=o*Z*p+b*h*m,this._w=o*Z*m-b*h*p;break;case"YXZ":this._x=b*Z*m+o*h*p,this._y=o*h*m-b*Z*p,this._z=o*Z*p-b*h*m,this._w=o*Z*m+b*h*p;break;case"ZXY":this._x=b*Z*m-o*h*p,this._y=o*h*m+b*Z*p,this._z=o*Z*p+b*h*m,this._w=o*Z*m-b*h*p;break;case"ZYX":this._x=b*Z*m-o*h*p,this._y=o*h*m+b*Z*p,this._z=o*Z*p-b*h*m,this._w=o*Z*m+b*h*p;break;case"YZX":this._x=b*Z*m+o*h*p,this._y=o*h*m+b*Z*p,this._z=o*Z*p-b*h*m,this._w=o*Z*m-b*h*p;break;case"XZY":this._x=b*Z*m-o*h*p,this._y=o*h*m-b*Z*p,this._z=o*Z*p+b*h*m,this._w=o*Z*m+b*h*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return e===!0&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],s=e[8],a=e[1],d=e[5],c=e[9],o=e[2],Z=e[6],m=e[10],b=n+d+m;if(b>0){const h=.5/Math.sqrt(b+1);this._w=.25/h,this._x=(Z-c)*h,this._y=(s-o)*h,this._z=(a-i)*h}else if(n>d&&n>m){const h=2*Math.sqrt(1+n-d-m);this._w=(Z-c)/h,this._x=.25*h,this._y=(i+a)/h,this._z=(s+o)/h}else if(d>m){const h=2*Math.sqrt(1+d-n-m);this._w=(s-o)/h,this._x=(i+a)/h,this._y=.25*h,this._z=(c+Z)/h}else{const h=2*Math.sqrt(1+m-n-d);this._w=(a-i)/h,this._x=(s+o)/h,this._y=(c+Z)/h,this._z=.25*h}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Ve(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,s=t._z,a=t._w,d=e._x,c=e._y,o=e._z,Z=e._w;return this._x=n*Z+a*d+i*o-s*c,this._y=i*Z+a*c+s*d-n*o,this._z=s*Z+a*o+n*c-i*d,this._w=a*Z-n*d-i*c-s*o,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,i=this._y,s=this._z,a=this._w;let d=a*t._w+n*t._x+i*t._y+s*t._z;if(d<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,d=-d):this.copy(t),d>=1)return this._w=a,this._x=n,this._y=i,this._z=s,this;const c=1-d*d;if(c<=Number.EPSILON){const h=1-e;return this._w=h*a+e*this._w,this._x=h*n+e*this._x,this._y=h*i+e*this._y,this._z=h*s+e*this._z,this.normalize(),this}const o=Math.sqrt(c),Z=Math.atan2(o,d),m=Math.sin((1-e)*Z)/o,b=Math.sin(e*Z)/o;return this._w=a*m+this._w*b,this._x=n*m+this._x*b,this._y=i*m+this._y*b,this._z=s*m+this._z*b,this._onChangeCallback(),this}slerpQuaternions(t,e,n){return this.copy(t).slerp(e,n)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),n=Math.random(),i=Math.sqrt(1-n),s=Math.sqrt(n);return this.set(i*Math.sin(t),i*Math.cos(t),s*Math.sin(e),s*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class J{constructor(t=0,e=0,n=0){J.prototype.isVector3=!0,this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(zs.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(zs.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,s=t.elements;return this.x=s[0]*e+s[3]*n+s[6]*i,this.y=s[1]*e+s[4]*n+s[7]*i,this.z=s[2]*e+s[5]*n+s[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,s=t.elements,a=1/(s[3]*e+s[7]*n+s[11]*i+s[15]);return this.x=(s[0]*e+s[4]*n+s[8]*i+s[12])*a,this.y=(s[1]*e+s[5]*n+s[9]*i+s[13])*a,this.z=(s[2]*e+s[6]*n+s[10]*i+s[14])*a,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,s=t.x,a=t.y,d=t.z,c=t.w,o=2*(a*i-d*n),Z=2*(d*e-s*i),m=2*(s*n-a*e);return this.x=e+c*o+a*m-d*Z,this.y=n+c*Z+d*o-s*m,this.z=i+c*m+s*Z-a*o,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*i,this.y=s[1]*e+s[5]*n+s[9]*i,this.z=s[2]*e+s[6]*n+s[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,s=t.z,a=e.x,d=e.y,c=e.z;return this.x=i*c-s*d,this.y=s*a-n*c,this.z=n*d-i*a,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return ya.copy(this).projectOnVector(t),this.sub(ya)}reflect(t){return this.sub(ya.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Ve(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=Math.random()*2-1,n=Math.sqrt(1-e*e);return this.x=n*Math.cos(t),this.y=e,this.z=n*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const ya=new J,zs=new yn;class Cn{constructor(t=new J(1/0,1/0,1/0),e=new J(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e+=3)this.expandByPoint(ke.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,n=t.count;e<n;e++)this.expandByPoint(ke.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=ke.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const n=t.geometry;if(n!==void 0){const s=n.getAttribute("position");if(e===!0&&s!==void 0&&t.isInstancedMesh!==!0)for(let a=0,d=s.count;a<d;a++)t.isMesh===!0?t.getVertexPosition(a,ke):ke.fromBufferAttribute(s,a),ke.applyMatrix4(t.matrixWorld),this.expandByPoint(ke);else t.boundingBox!==void 0?(t.boundingBox===null&&t.computeBoundingBox(),Qn.copy(t.boundingBox)):(n.boundingBox===null&&n.computeBoundingBox(),Qn.copy(n.boundingBox)),Qn.applyMatrix4(t.matrixWorld),this.union(Qn)}const i=t.children;for(let s=0,a=i.length;s<a;s++)this.expandByObject(i[s],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,ke),ke.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Sn),jn.subVectors(this.max,Sn),$l.subVectors(t.a,Sn),tn.subVectors(t.b,Sn),en.subVectors(t.c,Sn),rl.subVectors(tn,$l),pl.subVectors(en,tn),Nl.subVectors($l,en);let e=[0,-rl.z,rl.y,0,-pl.z,pl.y,0,-Nl.z,Nl.y,rl.z,0,-rl.x,pl.z,0,-pl.x,Nl.z,0,-Nl.x,-rl.y,rl.x,0,-pl.y,pl.x,0,-Nl.y,Nl.x,0];return!Ca(e,$l,tn,en,jn)||(e=[1,0,0,0,1,0,0,0,1],!Ca(e,$l,tn,en,jn))?!1:(_n.crossVectors(rl,pl),e=[_n.x,_n.y,_n.z],Ca(e,$l,tn,en,jn))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,ke).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=this.getSize(ke).length()*.5),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(ll[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),ll[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),ll[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),ll[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),ll[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),ll[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),ll[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),ll[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(ll),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const ll=[new J,new J,new J,new J,new J,new J,new J,new J],ke=new J,Qn=new Cn,$l=new J,tn=new J,en=new J,rl=new J,pl=new J,Nl=new J,Sn=new J,jn=new J,_n=new J,fl=new J;function Ca(l,t,e,n,i){for(let s=0,a=l.length-3;s<=a;s+=3){fl.fromArray(l,s);const d=i.x*Math.abs(fl.x)+i.y*Math.abs(fl.y)+i.z*Math.abs(fl.z),c=t.dot(fl),o=e.dot(fl),Z=n.dot(fl);if(Math.max(-Math.max(c,o,Z),Math.min(c,o,Z))>d)return!1}return!0}const Jo=new Cn,In=new J,Sa=new J;class Dn{constructor(t=new J,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):Jo.setFromPoints(t).getCenter(n);let i=0;for(let s=0,a=t.length;s<a;s++)i=Math.max(i,n.distanceToSquared(t[s]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;In.subVectors(t,this.center);const e=In.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),i=(n-this.radius)*.5;this.center.addScaledVector(In,i/n),this.radius+=i}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)===!0?this.radius=Math.max(this.radius,t.radius):(Sa.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(In.copy(t.center).add(Sa)),this.expandByPoint(In.copy(t.center).sub(Sa))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const nl=new J,Ia=new J,On=new J,Gl=new J,xa=new J,qn=new J,Ya=new J;class Hs{constructor(t=new J,e=new J(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,nl)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=nl.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(nl.copy(this.origin).addScaledVector(this.direction,e),nl.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){Ia.copy(t).add(e).multiplyScalar(.5),On.copy(e).sub(t).normalize(),Gl.copy(this.origin).sub(Ia);const s=t.distanceTo(e)*.5,a=-this.direction.dot(On),d=Gl.dot(this.direction),c=-Gl.dot(On),o=Gl.lengthSq(),Z=Math.abs(1-a*a);let m,b,h,p;if(Z>0)if(m=a*c-d,b=a*d-c,p=s*Z,m>=0)if(b>=-p)if(b<=p){const V=1/Z;m*=V,b*=V,h=m*(m+a*b+2*d)+b*(a*m+b+2*c)+o}else b=s,m=Math.max(0,-(a*b+d)),h=-m*m+b*(b+2*c)+o;else b=-s,m=Math.max(0,-(a*b+d)),h=-m*m+b*(b+2*c)+o;else b<=-p?(m=Math.max(0,-(-a*s+d)),b=m>0?-s:Math.min(Math.max(-s,-c),s),h=-m*m+b*(b+2*c)+o):b<=p?(m=0,b=Math.min(Math.max(-s,-c),s),h=b*(b+2*c)+o):(m=Math.max(0,-(a*s+d)),b=m>0?s:Math.min(Math.max(-s,-c),s),h=-m*m+b*(b+2*c)+o);else b=a>0?-s:s,m=Math.max(0,-(a*b+d)),h=-m*m+b*(b+2*c)+o;return n&&n.copy(this.origin).addScaledVector(this.direction,m),i&&i.copy(Ia).addScaledVector(On,b),h}intersectSphere(t,e){nl.subVectors(t.center,this.origin);const n=nl.dot(this.direction),i=nl.dot(nl)-n*n,s=t.radius*t.radius;if(i>s)return null;const a=Math.sqrt(s-i),d=n-a,c=n+a;return c<0?null:d<0?this.at(c,e):this.at(d,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,s,a,d,c;const o=1/this.direction.x,Z=1/this.direction.y,m=1/this.direction.z,b=this.origin;return o>=0?(n=(t.min.x-b.x)*o,i=(t.max.x-b.x)*o):(n=(t.max.x-b.x)*o,i=(t.min.x-b.x)*o),Z>=0?(s=(t.min.y-b.y)*Z,a=(t.max.y-b.y)*Z):(s=(t.max.y-b.y)*Z,a=(t.min.y-b.y)*Z),n>a||s>i||((s>n||isNaN(n))&&(n=s),(a<i||isNaN(i))&&(i=a),m>=0?(d=(t.min.z-b.z)*m,c=(t.max.z-b.z)*m):(d=(t.max.z-b.z)*m,c=(t.min.z-b.z)*m),n>c||d>i)||((d>n||n!==n)&&(n=d),(c<i||i!==i)&&(i=c),i<0)?null:this.at(n>=0?n:i,e)}intersectsBox(t){return this.intersectBox(t,nl)!==null}intersectTriangle(t,e,n,i,s){xa.subVectors(e,t),qn.subVectors(n,t),Ya.crossVectors(xa,qn);let a=this.direction.dot(Ya),d;if(a>0){if(i)return null;d=1}else if(a<0)d=-1,a=-a;else return null;Gl.subVectors(this.origin,t);const c=d*this.direction.dot(qn.crossVectors(Gl,qn));if(c<0)return null;const o=d*this.direction.dot(xa.cross(Gl));if(o<0||c+o>a)return null;const Z=-d*Gl.dot(Ya);return Z<0?null:this.at(Z/a,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class ae{constructor(t,e,n,i,s,a,d,c,o,Z,m,b,h,p,V,r){ae.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,e,n,i,s,a,d,c,o,Z,m,b,h,p,V,r)}set(t,e,n,i,s,a,d,c,o,Z,m,b,h,p,V,r){const u=this.elements;return u[0]=t,u[4]=e,u[8]=n,u[12]=i,u[1]=s,u[5]=a,u[9]=d,u[13]=c,u[2]=o,u[6]=Z,u[10]=m,u[14]=b,u[3]=h,u[7]=p,u[11]=V,u[15]=r,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new ae().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/ln.setFromMatrixColumn(t,0).length(),s=1/ln.setFromMatrixColumn(t,1).length(),a=1/ln.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*s,e[5]=n[5]*s,e[6]=n[6]*s,e[7]=0,e[8]=n[8]*a,e[9]=n[9]*a,e[10]=n[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,n=t.x,i=t.y,s=t.z,a=Math.cos(n),d=Math.sin(n),c=Math.cos(i),o=Math.sin(i),Z=Math.cos(s),m=Math.sin(s);if(t.order==="XYZ"){const b=a*Z,h=a*m,p=d*Z,V=d*m;e[0]=c*Z,e[4]=-c*m,e[8]=o,e[1]=h+p*o,e[5]=b-V*o,e[9]=-d*c,e[2]=V-b*o,e[6]=p+h*o,e[10]=a*c}else if(t.order==="YXZ"){const b=c*Z,h=c*m,p=o*Z,V=o*m;e[0]=b+V*d,e[4]=p*d-h,e[8]=a*o,e[1]=a*m,e[5]=a*Z,e[9]=-d,e[2]=h*d-p,e[6]=V+b*d,e[10]=a*c}else if(t.order==="ZXY"){const b=c*Z,h=c*m,p=o*Z,V=o*m;e[0]=b-V*d,e[4]=-a*m,e[8]=p+h*d,e[1]=h+p*d,e[5]=a*Z,e[9]=V-b*d,e[2]=-a*o,e[6]=d,e[10]=a*c}else if(t.order==="ZYX"){const b=a*Z,h=a*m,p=d*Z,V=d*m;e[0]=c*Z,e[4]=p*o-h,e[8]=b*o+V,e[1]=c*m,e[5]=V*o+b,e[9]=h*o-p,e[2]=-o,e[6]=d*c,e[10]=a*c}else if(t.order==="YZX"){const b=a*c,h=a*o,p=d*c,V=d*o;e[0]=c*Z,e[4]=V-b*m,e[8]=p*m+h,e[1]=m,e[5]=a*Z,e[9]=-d*Z,e[2]=-o*Z,e[6]=h*m+p,e[10]=b-V*m}else if(t.order==="XZY"){const b=a*c,h=a*o,p=d*c,V=d*o;e[0]=c*Z,e[4]=-m,e[8]=o*Z,e[1]=b*m+V,e[5]=a*Z,e[9]=h*m-p,e[2]=p*m-h,e[6]=d*Z,e[10]=V*m+b}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(ko,t,wo)}lookAt(t,e,n){const i=this.elements;return xe.subVectors(t,e),xe.lengthSq()===0&&(xe.z=1),xe.normalize(),Wl.crossVectors(n,xe),Wl.lengthSq()===0&&(Math.abs(n.z)===1?xe.x+=1e-4:xe.z+=1e-4,xe.normalize(),Wl.crossVectors(n,xe)),Wl.normalize(),$n.crossVectors(xe,Wl),i[0]=Wl.x,i[4]=$n.x,i[8]=xe.x,i[1]=Wl.y,i[5]=$n.y,i[9]=xe.y,i[2]=Wl.z,i[6]=$n.z,i[10]=xe.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,s=this.elements,a=n[0],d=n[4],c=n[8],o=n[12],Z=n[1],m=n[5],b=n[9],h=n[13],p=n[2],V=n[6],r=n[10],u=n[14],C=n[3],y=n[7],G=n[11],N=n[15],I=i[0],x=i[4],U=i[8],R=i[12],g=i[1],Y=i[5],P=i[9],w=i[13],E=i[2],D=i[6],K=i[10],$=i[14],H=i[3],nt=i[7],ot=i[11],Vt=i[15];return s[0]=a*I+d*g+c*E+o*H,s[4]=a*x+d*Y+c*D+o*nt,s[8]=a*U+d*P+c*K+o*ot,s[12]=a*R+d*w+c*$+o*Vt,s[1]=Z*I+m*g+b*E+h*H,s[5]=Z*x+m*Y+b*D+h*nt,s[9]=Z*U+m*P+b*K+h*ot,s[13]=Z*R+m*w+b*$+h*Vt,s[2]=p*I+V*g+r*E+u*H,s[6]=p*x+V*Y+r*D+u*nt,s[10]=p*U+V*P+r*K+u*ot,s[14]=p*R+V*w+r*$+u*Vt,s[3]=C*I+y*g+G*E+N*H,s[7]=C*x+y*Y+G*D+N*nt,s[11]=C*U+y*P+G*K+N*ot,s[15]=C*R+y*w+G*$+N*Vt,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],s=t[12],a=t[1],d=t[5],c=t[9],o=t[13],Z=t[2],m=t[6],b=t[10],h=t[14],p=t[3],V=t[7],r=t[11],u=t[15];return p*(+s*c*m-i*o*m-s*d*b+n*o*b+i*d*h-n*c*h)+V*(+e*c*h-e*o*b+s*a*b-i*a*h+i*o*Z-s*c*Z)+r*(+e*o*m-e*d*h-s*a*m+n*a*h+s*d*Z-n*o*Z)+u*(-i*d*Z-e*c*m+e*d*b+i*a*m-n*a*b+n*c*Z)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],a=t[4],d=t[5],c=t[6],o=t[7],Z=t[8],m=t[9],b=t[10],h=t[11],p=t[12],V=t[13],r=t[14],u=t[15],C=m*r*o-V*b*o+V*c*h-d*r*h-m*c*u+d*b*u,y=p*b*o-Z*r*o-p*c*h+a*r*h+Z*c*u-a*b*u,G=Z*V*o-p*m*o+p*d*h-a*V*h-Z*d*u+a*m*u,N=p*m*c-Z*V*c-p*d*b+a*V*b+Z*d*r-a*m*r,I=e*C+n*y+i*G+s*N;if(I===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const x=1/I;return t[0]=C*x,t[1]=(V*b*s-m*r*s-V*i*h+n*r*h+m*i*u-n*b*u)*x,t[2]=(d*r*s-V*c*s+V*i*o-n*r*o-d*i*u+n*c*u)*x,t[3]=(m*c*s-d*b*s-m*i*o+n*b*o+d*i*h-n*c*h)*x,t[4]=y*x,t[5]=(Z*r*s-p*b*s+p*i*h-e*r*h-Z*i*u+e*b*u)*x,t[6]=(p*c*s-a*r*s-p*i*o+e*r*o+a*i*u-e*c*u)*x,t[7]=(a*b*s-Z*c*s+Z*i*o-e*b*o-a*i*h+e*c*h)*x,t[8]=G*x,t[9]=(p*m*s-Z*V*s-p*n*h+e*V*h+Z*n*u-e*m*u)*x,t[10]=(a*V*s-p*d*s+p*n*o-e*V*o-a*n*u+e*d*u)*x,t[11]=(Z*d*s-a*m*s-Z*n*o+e*m*o+a*n*h-e*d*h)*x,t[12]=N*x,t[13]=(Z*V*i-p*m*i+p*n*b-e*V*b-Z*n*r+e*m*r)*x,t[14]=(p*d*i-a*V*i-p*n*c+e*V*c+a*n*r-e*d*r)*x,t[15]=(a*m*i-Z*d*i+Z*n*c-e*m*c-a*n*b+e*d*b)*x,this}scale(t){const e=this.elements,n=t.x,i=t.y,s=t.z;return e[0]*=n,e[4]*=i,e[8]*=s,e[1]*=n,e[5]*=i,e[9]*=s,e[2]*=n,e[6]*=i,e[10]*=s,e[3]*=n,e[7]*=i,e[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),s=1-n,a=t.x,d=t.y,c=t.z,o=s*a,Z=s*d;return this.set(o*a+n,o*d-i*c,o*c+i*d,0,o*d+i*c,Z*d+n,Z*c-i*a,0,o*c-i*d,Z*c+i*a,s*c*c+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,i,s,a){return this.set(1,n,s,0,t,1,a,0,e,i,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,s=e._x,a=e._y,d=e._z,c=e._w,o=s+s,Z=a+a,m=d+d,b=s*o,h=s*Z,p=s*m,V=a*Z,r=a*m,u=d*m,C=c*o,y=c*Z,G=c*m,N=n.x,I=n.y,x=n.z;return i[0]=(1-(V+u))*N,i[1]=(h+G)*N,i[2]=(p-y)*N,i[3]=0,i[4]=(h-G)*I,i[5]=(1-(b+u))*I,i[6]=(r+C)*I,i[7]=0,i[8]=(p+y)*x,i[9]=(r-C)*x,i[10]=(1-(b+V))*x,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let s=ln.set(i[0],i[1],i[2]).length();const a=ln.set(i[4],i[5],i[6]).length(),d=ln.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),t.x=i[12],t.y=i[13],t.z=i[14],we.copy(this);const o=1/s,Z=1/a,m=1/d;return we.elements[0]*=o,we.elements[1]*=o,we.elements[2]*=o,we.elements[4]*=Z,we.elements[5]*=Z,we.elements[6]*=Z,we.elements[8]*=m,we.elements[9]*=m,we.elements[10]*=m,e.setFromRotationMatrix(we),n.x=s,n.y=a,n.z=d,this}makePerspective(t,e,n,i,s,a,d=tl){const c=this.elements,o=2*s/(e-t),Z=2*s/(n-i),m=(e+t)/(e-t),b=(n+i)/(n-i);let h,p;if(d===tl)h=-(a+s)/(a-s),p=-2*a*s/(a-s);else if(d===An)h=-a/(a-s),p=-a*s/(a-s);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+d);return c[0]=o,c[4]=0,c[8]=m,c[12]=0,c[1]=0,c[5]=Z,c[9]=b,c[13]=0,c[2]=0,c[6]=0,c[10]=h,c[14]=p,c[3]=0,c[7]=0,c[11]=-1,c[15]=0,this}makeOrthographic(t,e,n,i,s,a,d=tl){const c=this.elements,o=1/(e-t),Z=1/(n-i),m=1/(a-s),b=(e+t)*o,h=(n+i)*Z;let p,V;if(d===tl)p=(a+s)*m,V=-2*m;else if(d===An)p=s*m,V=-1*m;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+d);return c[0]=2*o,c[4]=0,c[8]=0,c[12]=-b,c[1]=0,c[5]=2*Z,c[9]=0,c[13]=-h,c[2]=0,c[6]=0,c[10]=V,c[14]=-p,c[3]=0,c[7]=0,c[11]=0,c[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<16;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}const ln=new J,we=new ae,ko=new J(0,0,0),wo=new J(1,1,1),Wl=new J,$n=new J,xe=new J,Ks=new ae,Bs=new yn;class il{constructor(t=0,e=0,n=0,i=il.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i=this._order){return this._x=t,this._y=e,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const i=t.elements,s=i[0],a=i[4],d=i[8],c=i[1],o=i[5],Z=i[9],m=i[2],b=i[6],h=i[10];switch(e){case"XYZ":this._y=Math.asin(Ve(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(-Z,h),this._z=Math.atan2(-a,s)):(this._x=Math.atan2(b,o),this._z=0);break;case"YXZ":this._x=Math.asin(-Ve(Z,-1,1)),Math.abs(Z)<.9999999?(this._y=Math.atan2(d,h),this._z=Math.atan2(c,o)):(this._y=Math.atan2(-m,s),this._z=0);break;case"ZXY":this._x=Math.asin(Ve(b,-1,1)),Math.abs(b)<.9999999?(this._y=Math.atan2(-m,h),this._z=Math.atan2(-a,o)):(this._y=0,this._z=Math.atan2(c,s));break;case"ZYX":this._y=Math.asin(-Ve(m,-1,1)),Math.abs(m)<.9999999?(this._x=Math.atan2(b,h),this._z=Math.atan2(c,s)):(this._x=0,this._z=Math.atan2(-a,o));break;case"YZX":this._z=Math.asin(Ve(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-Z,o),this._y=Math.atan2(-m,s)):(this._x=0,this._y=Math.atan2(d,h));break;case"XZY":this._z=Math.asin(-Ve(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(b,o),this._y=Math.atan2(d,s)):(this._x=Math.atan2(-Z,h),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return Ks.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Ks,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Bs.setFromEuler(this),this.setFromQuaternion(Bs,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}il.DEFAULT_ORDER="XYZ";class Es{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let zo=0;const As=new J,nn=new yn,al=new ae,ti=new J,xn=new J,Ho=new J,Ko=new yn,Ps=new J(1,0,0),Qs=new J(0,1,0),js=new J(0,0,1),_s={type:"added"},Bo={type:"removed"},an={type:"childadded",child:null},Na={type:"childremoved",child:null};class Ce extends jl{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:zo++}),this.uuid=_l(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Ce.DEFAULT_UP.clone();const t=new J,e=new il,n=new yn,i=new J(1,1,1);function s(){n.setFromEuler(e,!1)}function a(){e.setFromQuaternion(n,void 0,!1)}e._onChange(s),n._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new ae},normalMatrix:{value:new xt}}),this.matrix=new ae,this.matrixWorld=new ae,this.matrixAutoUpdate=Ce.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Ce.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Es,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return nn.setFromAxisAngle(t,e),this.quaternion.multiply(nn),this}rotateOnWorldAxis(t,e){return nn.setFromAxisAngle(t,e),this.quaternion.premultiply(nn),this}rotateX(t){return this.rotateOnAxis(Ps,t)}rotateY(t){return this.rotateOnAxis(Qs,t)}rotateZ(t){return this.rotateOnAxis(js,t)}translateOnAxis(t,e){return As.copy(t).applyQuaternion(this.quaternion),this.position.add(As.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(Ps,t)}translateY(t){return this.translateOnAxis(Qs,t)}translateZ(t){return this.translateOnAxis(js,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(al.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?ti.copy(t):ti.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),xn.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?al.lookAt(xn,ti,this.up):al.lookAt(ti,xn,this.up),this.quaternion.setFromRotationMatrix(al),i&&(al.extractRotation(i.matrixWorld),nn.setFromRotationMatrix(al),this.quaternion.premultiply(nn.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(_s),an.child=t,this.dispatchEvent(an),an.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Bo),Na.child=t,this.dispatchEvent(Na),Na.child=null),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),al.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),al.multiply(t.parent.matrixWorld)),t.applyMatrix4(al),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(_s),an.child=t,this.dispatchEvent(an),an.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const a=this.children[n].getObjectByProperty(t,e);if(a!==void 0)return a}}getObjectsByProperty(t,e,n=[]){this[t]===e&&n.push(this);const i=this.children;for(let s=0,a=i.length;s<a;s++)i[s].getObjectsByProperty(t,e,n);return n}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(xn,t,Ho),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(xn,Ko,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(t===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),e===!0){const i=this.children;for(let s=0,a=i.length;s<a;s++)i[s].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.visibility=this._visibility,i.active=this._active,i.bounds=this._bounds.map(d=>({boxInitialized:d.boxInitialized,boxMin:d.box.min.toArray(),boxMax:d.box.max.toArray(),sphereInitialized:d.sphereInitialized,sphereRadius:d.sphere.radius,sphereCenter:d.sphere.center.toArray()})),i.maxInstanceCount=this._maxInstanceCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.geometryCount=this._geometryCount,i.matricesTexture=this._matricesTexture.toJSON(t),this._colorsTexture!==null&&(i.colorsTexture=this._colorsTexture.toJSON(t)),this.boundingSphere!==null&&(i.boundingSphere={center:i.boundingSphere.center.toArray(),radius:i.boundingSphere.radius}),this.boundingBox!==null&&(i.boundingBox={min:i.boundingBox.min.toArray(),max:i.boundingBox.max.toArray()}));function s(d,c){return d[c.uuid]===void 0&&(d[c.uuid]=c.toJSON(t)),c.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=s(t.geometries,this.geometry);const d=this.geometry.parameters;if(d!==void 0&&d.shapes!==void 0){const c=d.shapes;if(Array.isArray(c))for(let o=0,Z=c.length;o<Z;o++){const m=c[o];s(t.shapes,m)}else s(t.shapes,c)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const d=[];for(let c=0,o=this.material.length;c<o;c++)d.push(s(t.materials,this.material[c]));i.material=d}else i.material=s(t.materials,this.material);if(this.children.length>0){i.children=[];for(let d=0;d<this.children.length;d++)i.children.push(this.children[d].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let d=0;d<this.animations.length;d++){const c=this.animations[d];i.animations.push(s(t.animations,c))}}if(e){const d=a(t.geometries),c=a(t.materials),o=a(t.textures),Z=a(t.images),m=a(t.shapes),b=a(t.skeletons),h=a(t.animations),p=a(t.nodes);d.length>0&&(n.geometries=d),c.length>0&&(n.materials=c),o.length>0&&(n.textures=o),Z.length>0&&(n.images=Z),m.length>0&&(n.shapes=m),b.length>0&&(n.skeletons=b),h.length>0&&(n.animations=h),p.length>0&&(n.nodes=p)}return n.object=i,n;function a(d){const c=[];for(const o in d){const Z=d[o];delete Z.metadata,c.push(Z)}return c}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let n=0;n<t.children.length;n++){const i=t.children[n];this.add(i.clone())}return this}}Ce.DEFAULT_UP=new J(0,1,0),Ce.DEFAULT_MATRIX_AUTO_UPDATE=!0,Ce.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const ze=new J,sl=new J,fa=new J,dl=new J,sn=new J,dn=new J,Ds=new J,Fa=new J,La=new J,Ma=new J,Ua=new ie,Ta=new ie,va=new ie;class He{constructor(t=new J,e=new J,n=new J){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i.subVectors(n,e),ze.subVectors(t,e),i.cross(ze);const s=i.lengthSq();return s>0?i.multiplyScalar(1/Math.sqrt(s)):i.set(0,0,0)}static getBarycoord(t,e,n,i,s){ze.subVectors(i,e),sl.subVectors(n,e),fa.subVectors(t,e);const a=ze.dot(ze),d=ze.dot(sl),c=ze.dot(fa),o=sl.dot(sl),Z=sl.dot(fa),m=a*o-d*d;if(m===0)return s.set(0,0,0),null;const b=1/m,h=(o*c-d*Z)*b,p=(a*Z-d*c)*b;return s.set(1-h-p,p,h)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,dl)===null?!1:dl.x>=0&&dl.y>=0&&dl.x+dl.y<=1}static getInterpolation(t,e,n,i,s,a,d,c){return this.getBarycoord(t,e,n,i,dl)===null?(c.x=0,c.y=0,"z"in c&&(c.z=0),"w"in c&&(c.w=0),null):(c.setScalar(0),c.addScaledVector(s,dl.x),c.addScaledVector(a,dl.y),c.addScaledVector(d,dl.z),c)}static getInterpolatedAttribute(t,e,n,i,s,a){return Ua.setScalar(0),Ta.setScalar(0),va.setScalar(0),Ua.fromBufferAttribute(t,e),Ta.fromBufferAttribute(t,n),va.fromBufferAttribute(t,i),a.setScalar(0),a.addScaledVector(Ua,s.x),a.addScaledVector(Ta,s.y),a.addScaledVector(va,s.z),a}static isFrontFacing(t,e,n,i){return ze.subVectors(n,e),sl.subVectors(t,e),ze.cross(sl).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}setFromAttributeAndIndices(t,e,n,i){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,i),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return ze.subVectors(this.c,this.b),sl.subVectors(this.a,this.b),ze.cross(sl).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return He.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return He.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,n,i,s){return He.getInterpolation(t,this.a,this.b,this.c,e,n,i,s)}containsPoint(t){return He.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return He.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,i=this.b,s=this.c;let a,d;sn.subVectors(i,n),dn.subVectors(s,n),Fa.subVectors(t,n);const c=sn.dot(Fa),o=dn.dot(Fa);if(c<=0&&o<=0)return e.copy(n);La.subVectors(t,i);const Z=sn.dot(La),m=dn.dot(La);if(Z>=0&&m<=Z)return e.copy(i);const b=c*m-Z*o;if(b<=0&&c>=0&&Z<=0)return a=c/(c-Z),e.copy(n).addScaledVector(sn,a);Ma.subVectors(t,s);const h=sn.dot(Ma),p=dn.dot(Ma);if(p>=0&&h<=p)return e.copy(s);const V=h*o-c*p;if(V<=0&&o>=0&&p<=0)return d=o/(o-p),e.copy(n).addScaledVector(dn,d);const r=Z*p-h*m;if(r<=0&&m-Z>=0&&h-p>=0)return Ds.subVectors(s,i),d=(m-Z)/(m-Z+(h-p)),e.copy(i).addScaledVector(Ds,d);const u=1/(r+V+b);return a=V*u,d=b*u,e.copy(n).addScaledVector(sn,a).addScaledVector(dn,d)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const Os={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Vl={h:0,s:0,l:0},ei={h:0,s:0,l:0};function Ja(l,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?l+(t-l)*6*e:e<1/2?t:e<2/3?l+(t-l)*6*(2/3-e):l}class Kt{constructor(t,e,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,n)}set(t,e,n){if(e===void 0&&n===void 0){const i=t;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(t,e,n);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=Le){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,kt.toWorkingColorSpace(this,e),this}setRGB(t,e,n,i=kt.workingColorSpace){return this.r=t,this.g=e,this.b=n,kt.toWorkingColorSpace(this,i),this}setHSL(t,e,n,i=kt.workingColorSpace){if(t=Xa(t,1),e=Ve(e,0,1),n=Ve(n,0,1),e===0)this.r=this.g=this.b=n;else{const s=n<=.5?n*(1+e):n+e-n*e,a=2*n-s;this.r=Ja(a,s,t+1/3),this.g=Ja(a,s,t),this.b=Ja(a,s,t-1/3)}return kt.toWorkingColorSpace(this,i),this}setStyle(t,e=Le){function n(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(t)){let s;const a=i[1],d=i[2];switch(a){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))return n(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,e);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))return n(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,e);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))return n(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(t)){const s=i[1],a=s.length;if(a===3)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,e);if(a===6)return this.setHex(parseInt(s,16),e);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=Le){const n=Os[t.toLowerCase()];return n!==void 0?this.setHex(n,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=el(t.r),this.g=el(t.g),this.b=el(t.b),this}copyLinearToSRGB(t){return this.r=Ol(t.r),this.g=Ol(t.g),this.b=Ol(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=Le){return kt.fromWorkingColorSpace(pe.copy(this),t),Math.round(Ve(pe.r*255,0,255))*65536+Math.round(Ve(pe.g*255,0,255))*256+Math.round(Ve(pe.b*255,0,255))}getHexString(t=Le){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=kt.workingColorSpace){kt.fromWorkingColorSpace(pe.copy(this),e);const n=pe.r,i=pe.g,s=pe.b,a=Math.max(n,i,s),d=Math.min(n,i,s);let c,o;const Z=(d+a)/2;if(d===a)c=0,o=0;else{const m=a-d;switch(o=Z<=.5?m/(a+d):m/(2-a-d),a){case n:c=(i-s)/m+(i<s?6:0);break;case i:c=(s-n)/m+2;break;case s:c=(n-i)/m+4;break}c/=6}return t.h=c,t.s=o,t.l=Z,t}getRGB(t,e=kt.workingColorSpace){return kt.fromWorkingColorSpace(pe.copy(this),e),t.r=pe.r,t.g=pe.g,t.b=pe.b,t}getStyle(t=Le){kt.fromWorkingColorSpace(pe.copy(this),t);const e=pe.r,n=pe.g,i=pe.b;return t!==Le?`color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(e*255)},${Math.round(n*255)},${Math.round(i*255)})`}offsetHSL(t,e,n){return this.getHSL(Vl),this.setHSL(Vl.h+t,Vl.s+e,Vl.l+n)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Vl),t.getHSL(ei);const n=gn(Vl.h,ei.h,e),i=gn(Vl.s,ei.s,e),s=gn(Vl.l,ei.l,e);return this.setHSL(n,i,s),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,n=this.g,i=this.b,s=t.elements;return this.r=s[0]*e+s[3]*n+s[6]*i,this.g=s[1]*e+s[4]*n+s[7]*i,this.b=s[2]*e+s[5]*n+s[8]*i,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const pe=new Kt;Kt.NAMES=Os;let Eo=0;class Yn extends jl{static get type(){return"Material"}get type(){return this.constructor.type}set type(t){}constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Eo++}),this.uuid=_l(),this.name="",this.blending=Pe,this.side=ml,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=Yi,this.blendDst=Ni,this.blendEquation=Sl,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Kt(0,0,0),this.blendAlpha=0,this.depthFunc=zl,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Is,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Ql,this.stencilZFail=Ql,this.stencilZPass=Ql,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const n=t[e];if(n===void 0){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const i=this[e];if(i===void 0){console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const n={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(n.dispersion=this.dispersion),this.iridescence!==void 0&&(n.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(n.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.anisotropy!==void 0&&(n.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(n.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(n.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapRotation!==void 0&&(n.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Pe&&(n.blending=this.blending),this.side!==ml&&(n.side=this.side),this.vertexColors===!0&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=!0),this.blendSrc!==Yi&&(n.blendSrc=this.blendSrc),this.blendDst!==Ni&&(n.blendDst=this.blendDst),this.blendEquation!==Sl&&(n.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(n.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(n.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(n.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(n.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(n.blendAlpha=this.blendAlpha),this.depthFunc!==zl&&(n.depthFunc=this.depthFunc),this.depthTest===!1&&(n.depthTest=this.depthTest),this.depthWrite===!1&&(n.depthWrite=this.depthWrite),this.colorWrite===!1&&(n.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(n.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==Is&&(n.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(n.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(n.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Ql&&(n.stencilFail=this.stencilFail),this.stencilZFail!==Ql&&(n.stencilZFail=this.stencilZFail),this.stencilZPass!==Ql&&(n.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(n.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaHash===!0&&(n.alphaHash=!0),this.alphaToCoverage===!0&&(n.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=!0),this.forceSinglePass===!0&&(n.forceSinglePass=!0),this.wireframe===!0&&(n.wireframe=!0),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=!0),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData);function i(s){const a=[];for(const d in s){const c=s[d];delete c.metadata,a.push(c)}return a}if(e){const s=i(t.textures),a=i(t.images);s.length>0&&(n.textures=s),a.length>0&&(n.images=a)}return n}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(e!==null){const i=e.length;n=new Array(i);for(let s=0;s!==i;++s)n[s]=e[s].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class Nn extends Yn{static get type(){return"MeshBasicMaterial"}constructor(t){super(),this.isMeshBasicMaterial=!0,this.color=new Kt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new il,this.combine=bs,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const de=new J,li=new ft;class Se{constructor(t,e,n=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=n,this.usage=Ys,this.updateRanges=[],this.gpuType=$e,this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,s=this.itemSize;i<s;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,n=this.count;e<n;e++)li.fromBufferAttribute(this,e),li.applyMatrix3(t),this.setXY(e,li.x,li.y);else if(this.itemSize===3)for(let e=0,n=this.count;e<n;e++)de.fromBufferAttribute(this,e),de.applyMatrix3(t),this.setXYZ(e,de.x,de.y,de.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)de.fromBufferAttribute(this,e),de.applyMatrix4(t),this.setXYZ(e,de.x,de.y,de.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)de.fromBufferAttribute(this,e),de.applyNormalMatrix(t),this.setXYZ(e,de.x,de.y,de.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)de.fromBufferAttribute(this,e),de.transformDirection(t),this.setXYZ(e,de.x,de.y,de.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let n=this.array[t*this.itemSize+e];return this.normalized&&(n=Dl(n,this.array)),n}setComponent(t,e,n){return this.normalized&&(n=Xe(n,this.array)),this.array[t*this.itemSize+e]=n,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=Dl(e,this.array)),e}setX(t,e){return this.normalized&&(e=Xe(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=Dl(e,this.array)),e}setY(t,e){return this.normalized&&(e=Xe(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=Dl(e,this.array)),e}setZ(t,e){return this.normalized&&(e=Xe(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=Dl(e,this.array)),e}setW(t,e){return this.normalized&&(e=Xe(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.normalized&&(e=Xe(e,this.array),n=Xe(n,this.array)),this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.normalized&&(e=Xe(e,this.array),n=Xe(n,this.array),i=Xe(i,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,s){return t*=this.itemSize,this.normalized&&(e=Xe(e,this.array),n=Xe(n,this.array),i=Xe(i,this.array),s=Xe(s,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=s,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==Ys&&(t.usage=this.usage),t}}class qs extends Se{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class $s extends Se{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class Fl extends Se{constructor(t,e,n){super(new Float32Array(t),e,n)}}let Ao=0;const Me=new ae,ka=new Ce,cn=new J,Ye=new Cn,fn=new Cn,Ze=new J;class Ue extends jl{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Ao++}),this.uuid=_l(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Fs(t)?$s:qs)(t,1):this.index=t,this}setIndirect(t){return this.indirect=t,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const s=new xt().getNormalMatrix(t);n.applyNormalMatrix(s),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(t),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return Me.makeRotationFromQuaternion(t),this.applyMatrix4(Me),this}rotateX(t){return Me.makeRotationX(t),this.applyMatrix4(Me),this}rotateY(t){return Me.makeRotationY(t),this.applyMatrix4(Me),this}rotateZ(t){return Me.makeRotationZ(t),this.applyMatrix4(Me),this}translate(t,e,n){return Me.makeTranslation(t,e,n),this.applyMatrix4(Me),this}scale(t,e,n){return Me.makeScale(t,e,n),this.applyMatrix4(Me),this}lookAt(t){return ka.lookAt(t),ka.updateMatrix(),this.applyMatrix4(ka.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(cn).negate(),this.translate(cn.x,cn.y,cn.z),this}setFromPoints(t){const e=this.getAttribute("position");if(e===void 0){const n=[];for(let i=0,s=t.length;i<s;i++){const a=t[i];n.push(a.x,a.y,a.z||0)}this.setAttribute("position",new Fl(n,3))}else{for(let n=0,i=e.count;n<i;n++){const s=t[n];e.setXYZ(n,s.x,s.y,s.z||0)}t.length>e.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),e.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Cn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new J(-1/0,-1/0,-1/0),new J(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,i=e.length;n<i;n++){const s=e[n];Ye.setFromBufferAttribute(s),this.morphTargetsRelative?(Ze.addVectors(this.boundingBox.min,Ye.min),this.boundingBox.expandByPoint(Ze),Ze.addVectors(this.boundingBox.max,Ye.max),this.boundingBox.expandByPoint(Ze)):(this.boundingBox.expandByPoint(Ye.min),this.boundingBox.expandByPoint(Ye.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Dn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new J,1/0);return}if(t){const n=this.boundingSphere.center;if(Ye.setFromBufferAttribute(t),e)for(let s=0,a=e.length;s<a;s++){const d=e[s];fn.setFromBufferAttribute(d),this.morphTargetsRelative?(Ze.addVectors(Ye.min,fn.min),Ye.expandByPoint(Ze),Ze.addVectors(Ye.max,fn.max),Ye.expandByPoint(Ze)):(Ye.expandByPoint(fn.min),Ye.expandByPoint(fn.max))}Ye.getCenter(n);let i=0;for(let s=0,a=t.count;s<a;s++)Ze.fromBufferAttribute(t,s),i=Math.max(i,n.distanceToSquared(Ze));if(e)for(let s=0,a=e.length;s<a;s++){const d=e[s],c=this.morphTargetsRelative;for(let o=0,Z=d.count;o<Z;o++)Ze.fromBufferAttribute(d,o),c&&(cn.fromBufferAttribute(t,o),Ze.add(cn)),i=Math.max(i,n.distanceToSquared(Ze))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=e.position,i=e.normal,s=e.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Se(new Float32Array(4*n.count),4));const a=this.getAttribute("tangent"),d=[],c=[];for(let U=0;U<n.count;U++)d[U]=new J,c[U]=new J;const o=new J,Z=new J,m=new J,b=new ft,h=new ft,p=new ft,V=new J,r=new J;function u(U,R,g){o.fromBufferAttribute(n,U),Z.fromBufferAttribute(n,R),m.fromBufferAttribute(n,g),b.fromBufferAttribute(s,U),h.fromBufferAttribute(s,R),p.fromBufferAttribute(s,g),Z.sub(o),m.sub(o),h.sub(b),p.sub(b);const Y=1/(h.x*p.y-p.x*h.y);isFinite(Y)&&(V.copy(Z).multiplyScalar(p.y).addScaledVector(m,-h.y).multiplyScalar(Y),r.copy(m).multiplyScalar(h.x).addScaledVector(Z,-p.x).multiplyScalar(Y),d[U].add(V),d[R].add(V),d[g].add(V),c[U].add(r),c[R].add(r),c[g].add(r))}let C=this.groups;C.length===0&&(C=[{start:0,count:t.count}]);for(let U=0,R=C.length;U<R;++U){const g=C[U],Y=g.start,P=g.count;for(let w=Y,E=Y+P;w<E;w+=3)u(t.getX(w+0),t.getX(w+1),t.getX(w+2))}const y=new J,G=new J,N=new J,I=new J;function x(U){N.fromBufferAttribute(i,U),I.copy(N);const R=d[U];y.copy(R),y.sub(N.multiplyScalar(N.dot(R))).normalize(),G.crossVectors(I,R);const Y=G.dot(c[U])<0?-1:1;a.setXYZW(U,y.x,y.y,y.z,Y)}for(let U=0,R=C.length;U<R;++U){const g=C[U],Y=g.start,P=g.count;for(let w=Y,E=Y+P;w<E;w+=3)x(t.getX(w+0)),x(t.getX(w+1)),x(t.getX(w+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new Se(new Float32Array(e.count*3),3),this.setAttribute("normal",n);else for(let b=0,h=n.count;b<h;b++)n.setXYZ(b,0,0,0);const i=new J,s=new J,a=new J,d=new J,c=new J,o=new J,Z=new J,m=new J;if(t)for(let b=0,h=t.count;b<h;b+=3){const p=t.getX(b+0),V=t.getX(b+1),r=t.getX(b+2);i.fromBufferAttribute(e,p),s.fromBufferAttribute(e,V),a.fromBufferAttribute(e,r),Z.subVectors(a,s),m.subVectors(i,s),Z.cross(m),d.fromBufferAttribute(n,p),c.fromBufferAttribute(n,V),o.fromBufferAttribute(n,r),d.add(Z),c.add(Z),o.add(Z),n.setXYZ(p,d.x,d.y,d.z),n.setXYZ(V,c.x,c.y,c.z),n.setXYZ(r,o.x,o.y,o.z)}else for(let b=0,h=e.count;b<h;b+=3)i.fromBufferAttribute(e,b+0),s.fromBufferAttribute(e,b+1),a.fromBufferAttribute(e,b+2),Z.subVectors(a,s),m.subVectors(i,s),Z.cross(m),n.setXYZ(b+0,Z.x,Z.y,Z.z),n.setXYZ(b+1,Z.x,Z.y,Z.z),n.setXYZ(b+2,Z.x,Z.y,Z.z);this.normalizeNormals(),n.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)Ze.fromBufferAttribute(t,e),Ze.normalize(),t.setXYZ(e,Ze.x,Ze.y,Ze.z)}toNonIndexed(){function t(d,c){const o=d.array,Z=d.itemSize,m=d.normalized,b=new o.constructor(c.length*Z);let h=0,p=0;for(let V=0,r=c.length;V<r;V++){d.isInterleavedBufferAttribute?h=c[V]*d.data.stride+d.offset:h=c[V]*Z;for(let u=0;u<Z;u++)b[p++]=o[h++]}return new Se(b,Z,m)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Ue,n=this.index.array,i=this.attributes;for(const d in i){const c=i[d],o=t(c,n);e.setAttribute(d,o)}const s=this.morphAttributes;for(const d in s){const c=[],o=s[d];for(let Z=0,m=o.length;Z<m;Z++){const b=o[Z],h=t(b,n);c.push(h)}e.morphAttributes[d]=c}e.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let d=0,c=a.length;d<c;d++){const o=a[d];e.addGroup(o.start,o.count,o.materialIndex)}return e}toJSON(){const t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const c=this.parameters;for(const o in c)c[o]!==void 0&&(t[o]=c[o]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const c in n){const o=n[c];t.data.attributes[c]=o.toJSON(t.data)}const i={};let s=!1;for(const c in this.morphAttributes){const o=this.morphAttributes[c],Z=[];for(let m=0,b=o.length;m<b;m++){const h=o[m];Z.push(h.toJSON(t.data))}Z.length>0&&(i[c]=Z,s=!0)}s&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(t.data.groups=JSON.parse(JSON.stringify(a)));const d=this.boundingSphere;return d!==null&&(t.data.boundingSphere={center:d.center.toArray(),radius:d.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;n!==null&&this.setIndex(n.clone(e));const i=t.attributes;for(const o in i){const Z=i[o];this.setAttribute(o,Z.clone(e))}const s=t.morphAttributes;for(const o in s){const Z=[],m=s[o];for(let b=0,h=m.length;b<h;b++)Z.push(m[b].clone(e));this.morphAttributes[o]=Z}this.morphTargetsRelative=t.morphTargetsRelative;const a=t.groups;for(let o=0,Z=a.length;o<Z;o++){const m=a[o];this.addGroup(m.start,m.count,m.materialIndex)}const d=t.boundingBox;d!==null&&(this.boundingBox=d.clone());const c=t.boundingSphere;return c!==null&&(this.boundingSphere=c.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const td=new ae,Ll=new Hs,ni=new Dn,ed=new J,ii=new J,ai=new J,si=new J,wa=new J,di=new J,ld=new J,ci=new J;class ee extends Ce{constructor(t=new Ue,e=new Nn){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const d=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[d]=s}}}}getVertexPosition(t,e){const n=this.geometry,i=n.attributes.position,s=n.morphAttributes.position,a=n.morphTargetsRelative;e.fromBufferAttribute(i,t);const d=this.morphTargetInfluences;if(s&&d){di.set(0,0,0);for(let c=0,o=s.length;c<o;c++){const Z=d[c],m=s[c];Z!==0&&(wa.fromBufferAttribute(m,t),a?di.addScaledVector(wa,Z):di.addScaledVector(wa.sub(e),Z))}e.add(di)}return e}raycast(t,e){const n=this.geometry,i=this.material,s=this.matrixWorld;i!==void 0&&(n.boundingSphere===null&&n.computeBoundingSphere(),ni.copy(n.boundingSphere),ni.applyMatrix4(s),Ll.copy(t.ray).recast(t.near),!(ni.containsPoint(Ll.origin)===!1&&(Ll.intersectSphere(ni,ed)===null||Ll.origin.distanceToSquared(ed)>(t.far-t.near)**2))&&(td.copy(s).invert(),Ll.copy(t.ray).applyMatrix4(td),!(n.boundingBox!==null&&Ll.intersectsBox(n.boundingBox)===!1)&&this._computeIntersections(t,e,Ll)))}_computeIntersections(t,e,n){let i;const s=this.geometry,a=this.material,d=s.index,c=s.attributes.position,o=s.attributes.uv,Z=s.attributes.uv1,m=s.attributes.normal,b=s.groups,h=s.drawRange;if(d!==null)if(Array.isArray(a))for(let p=0,V=b.length;p<V;p++){const r=b[p],u=a[r.materialIndex],C=Math.max(r.start,h.start),y=Math.min(d.count,Math.min(r.start+r.count,h.start+h.count));for(let G=C,N=y;G<N;G+=3){const I=d.getX(G),x=d.getX(G+1),U=d.getX(G+2);i=oi(this,u,t,n,o,Z,m,I,x,U),i&&(i.faceIndex=Math.floor(G/3),i.face.materialIndex=r.materialIndex,e.push(i))}}else{const p=Math.max(0,h.start),V=Math.min(d.count,h.start+h.count);for(let r=p,u=V;r<u;r+=3){const C=d.getX(r),y=d.getX(r+1),G=d.getX(r+2);i=oi(this,a,t,n,o,Z,m,C,y,G),i&&(i.faceIndex=Math.floor(r/3),e.push(i))}}else if(c!==void 0)if(Array.isArray(a))for(let p=0,V=b.length;p<V;p++){const r=b[p],u=a[r.materialIndex],C=Math.max(r.start,h.start),y=Math.min(c.count,Math.min(r.start+r.count,h.start+h.count));for(let G=C,N=y;G<N;G+=3){const I=G,x=G+1,U=G+2;i=oi(this,u,t,n,o,Z,m,I,x,U),i&&(i.faceIndex=Math.floor(G/3),i.face.materialIndex=r.materialIndex,e.push(i))}}else{const p=Math.max(0,h.start),V=Math.min(c.count,h.start+h.count);for(let r=p,u=V;r<u;r+=3){const C=r,y=r+1,G=r+2;i=oi(this,a,t,n,o,Z,m,C,y,G),i&&(i.faceIndex=Math.floor(r/3),e.push(i))}}}}function Po(l,t,e,n,i,s,a,d){let c;if(t.side===ye?c=n.intersectTriangle(a,s,i,!0,d):c=n.intersectTriangle(i,s,a,t.side===ml,d),c===null)return null;ci.copy(d),ci.applyMatrix4(l.matrixWorld);const o=e.ray.origin.distanceTo(ci);return o<e.near||o>e.far?null:{distance:o,point:ci.clone(),object:l}}function oi(l,t,e,n,i,s,a,d,c,o){l.getVertexPosition(d,ii),l.getVertexPosition(c,ai),l.getVertexPosition(o,si);const Z=Po(l,t,e,n,ii,ai,si,ld);if(Z){const m=new J;He.getBarycoord(ld,ii,ai,si,m),i&&(Z.uv=He.getInterpolatedAttribute(i,d,c,o,m,new ft)),s&&(Z.uv1=He.getInterpolatedAttribute(s,d,c,o,m,new ft)),a&&(Z.normal=He.getInterpolatedAttribute(a,d,c,o,m,new J),Z.normal.dot(n.direction)>0&&Z.normal.multiplyScalar(-1));const b={a:d,b:c,c:o,normal:new J,materialIndex:0};He.getNormal(ii,ai,si,b.normal),Z.face=b,Z.barycoord=m}return Z}class Fn extends Ue{constructor(t=1,e=1,n=1,i=1,s=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:s,depthSegments:a};const d=this;i=Math.floor(i),s=Math.floor(s),a=Math.floor(a);const c=[],o=[],Z=[],m=[];let b=0,h=0;p("z","y","x",-1,-1,n,e,t,a,s,0),p("z","y","x",1,-1,n,e,-t,a,s,1),p("x","z","y",1,1,t,n,e,i,a,2),p("x","z","y",1,-1,t,n,-e,i,a,3),p("x","y","z",1,-1,t,e,n,i,s,4),p("x","y","z",-1,-1,t,e,-n,i,s,5),this.setIndex(c),this.setAttribute("position",new Fl(o,3)),this.setAttribute("normal",new Fl(Z,3)),this.setAttribute("uv",new Fl(m,2));function p(V,r,u,C,y,G,N,I,x,U,R){const g=G/x,Y=N/U,P=G/2,w=N/2,E=I/2,D=x+1,K=U+1;let $=0,H=0;const nt=new J;for(let ot=0;ot<K;ot++){const Vt=ot*Y-w;for(let Mt=0;Mt<D;Mt++){const Qt=Mt*g-P;nt[V]=Qt*C,nt[r]=Vt*y,nt[u]=E,o.push(nt.x,nt.y,nt.z),nt[V]=0,nt[r]=0,nt[u]=I>0?1:-1,Z.push(nt.x,nt.y,nt.z),m.push(Mt/x),m.push(1-ot/U),$+=1}}for(let ot=0;ot<U;ot++)for(let Vt=0;Vt<x;Vt++){const Mt=b+Vt+D*ot,Qt=b+Vt+D*(ot+1),A=b+(Vt+1)+D*(ot+1),tt=b+(Vt+1)+D*ot;c.push(Mt,Qt,tt),c.push(Qt,A,tt),H+=6}d.addGroup(h,H,R),h+=H,b+=$}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Fn(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function on(l){const t={};for(const e in l){t[e]={};for(const n in l[e]){const i=l[e][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),t[e][n]=null):t[e][n]=i.clone():Array.isArray(i)?t[e][n]=i.slice():t[e][n]=i}}return t}function Re(l){const t={};for(let e=0;e<l.length;e++){const n=on(l[e]);for(const i in n)t[i]=n[i]}return t}function Qo(l){const t=[];for(let e=0;e<l.length;e++)t.push(l[e].clone());return t}function nd(l){const t=l.getRenderTarget();return t===null?l.outputColorSpace:t.isXRRenderTarget===!0?t.texture.colorSpace:kt.workingColorSpace}const jo={clone:on,merge:Re};var _o=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,Do=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class ce extends Yn{static get type(){return"ShaderMaterial"}constructor(t){super(),this.isShaderMaterial=!0,this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=_o,this.fragmentShader=Do,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=on(t.uniforms),this.uniformsGroups=Qo(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const a=this.uniforms[i].value;a&&a.isTexture?e.uniforms[i]={type:"t",value:a.toJSON(t).uuid}:a&&a.isColor?e.uniforms[i]={type:"c",value:a.getHex()}:a&&a.isVector2?e.uniforms[i]={type:"v2",value:a.toArray()}:a&&a.isVector3?e.uniforms[i]={type:"v3",value:a.toArray()}:a&&a.isVector4?e.uniforms[i]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?e.uniforms[i]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?e.uniforms[i]={type:"m4",value:a.toArray()}:e.uniforms[i]={value:a}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}class id extends Ce{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new ae,this.projectionMatrix=new ae,this.projectionMatrixInverse=new ae,this.coordinateSystem=tl}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const Xl=new J,ad=new ft,sd=new ft;class Ke extends id{constructor(t=50,e=1,n=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=Xn*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(Vn*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return Xn*2*Math.atan(Math.tan(Vn*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,e,n){Xl.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(Xl.x,Xl.y).multiplyScalar(-t/Xl.z),Xl.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),n.set(Xl.x,Xl.y).multiplyScalar(-t/Xl.z)}getViewSize(t,e){return this.getViewBounds(t,ad,sd),e.subVectors(sd,ad)}setViewOffset(t,e,n,i,s,a){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(Vn*.5*this.fov)/this.zoom,n=2*e,i=this.aspect*n,s=-.5*i;const a=this.view;if(this.view!==null&&this.view.enabled){const c=a.fullWidth,o=a.fullHeight;s+=a.offsetX*i/c,e-=a.offsetY*n/o,i*=a.width/c,n*=a.height/o}const d=this.filmOffset;d!==0&&(s+=t*d/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+i,e,e-n,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const mn=-90,Zn=1;class Oo extends Ce{constructor(t,e,n){super(),this.type="CubeCamera",this.renderTarget=n,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new Ke(mn,Zn,t,e);i.layers=this.layers,this.add(i);const s=new Ke(mn,Zn,t,e);s.layers=this.layers,this.add(s);const a=new Ke(mn,Zn,t,e);a.layers=this.layers,this.add(a);const d=new Ke(mn,Zn,t,e);d.layers=this.layers,this.add(d);const c=new Ke(mn,Zn,t,e);c.layers=this.layers,this.add(c);const o=new Ke(mn,Zn,t,e);o.layers=this.layers,this.add(o)}updateCoordinateSystem(){const t=this.coordinateSystem,e=this.children.concat(),[n,i,s,a,d,c]=e;for(const o of e)this.remove(o);if(t===tl)n.up.set(0,1,0),n.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),a.up.set(0,0,1),a.lookAt(0,-1,0),d.up.set(0,1,0),d.lookAt(0,0,1),c.up.set(0,1,0),c.lookAt(0,0,-1);else if(t===An)n.up.set(0,-1,0),n.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),a.up.set(0,0,-1),a.lookAt(0,-1,0),d.up.set(0,-1,0),d.lookAt(0,0,1),c.up.set(0,-1,0),c.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+t);for(const o of e)this.add(o),o.updateMatrixWorld()}update(t,e){this.parent===null&&this.updateMatrixWorld();const{renderTarget:n,activeMipmapLevel:i}=this;this.coordinateSystem!==t.coordinateSystem&&(this.coordinateSystem=t.coordinateSystem,this.updateCoordinateSystem());const[s,a,d,c,o,Z]=this.children,m=t.getRenderTarget(),b=t.getActiveCubeFace(),h=t.getActiveMipmapLevel(),p=t.xr.enabled;t.xr.enabled=!1;const V=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0,i),t.render(e,s),t.setRenderTarget(n,1,i),t.render(e,a),t.setRenderTarget(n,2,i),t.render(e,d),t.setRenderTarget(n,3,i),t.render(e,c),t.setRenderTarget(n,4,i),t.render(e,o),n.texture.generateMipmaps=V,t.setRenderTarget(n,5,i),t.render(e,Z),t.setRenderTarget(m,b,h),t.xr.enabled=p,n.texture.needsPMREMUpdate=!0}}class dd extends ge{constructor(t,e,n,i,s,a,d,c,o,Z){t=t!==void 0?t:[],e=e!==void 0?e:Hl,super(t,e,n,i,s,a,d,c,o,Z),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class qo extends bl{constructor(t=1,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const n={width:t,height:t,depth:1},i=[n,n,n,n,n,n];this.texture=new dd(i,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:be}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new Fn(5,5,5),s=new ce({name:"CubemapFromEquirect",uniforms:on(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:ye,blending:Zl});s.uniforms.tEquirect.value=e;const a=new ee(i,s),d=e.minFilter;return e.minFilter===xl&&(e.minFilter=be),new Oo(1,10,this).update(t,a),e.minFilter=d,a.geometry.dispose(),a.material.dispose(),this}clear(t,e,n,i){const s=t.getRenderTarget();for(let a=0;a<6;a++)t.setRenderTarget(this,a),t.clear(e,n,i);t.setRenderTarget(s)}}const za=new J,$o=new J,tm=new xt;class Ml{constructor(t=new J(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=za.subVectors(n,e).cross($o.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const n=t.delta(za),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const s=-(t.start.dot(this.normal)+this.constant)/i;return s<0||s>1?null:e.copy(t.start).addScaledVector(n,s)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||tm.getNormalMatrix(t),i=this.coplanarPoint(za).applyMatrix4(t),s=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Ul=new Dn,mi=new J;class cd{constructor(t=new Ml,e=new Ml,n=new Ml,i=new Ml,s=new Ml,a=new Ml){this.planes=[t,e,n,i,s,a]}set(t,e,n,i,s,a){const d=this.planes;return d[0].copy(t),d[1].copy(e),d[2].copy(n),d[3].copy(i),d[4].copy(s),d[5].copy(a),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t,e=tl){const n=this.planes,i=t.elements,s=i[0],a=i[1],d=i[2],c=i[3],o=i[4],Z=i[5],m=i[6],b=i[7],h=i[8],p=i[9],V=i[10],r=i[11],u=i[12],C=i[13],y=i[14],G=i[15];if(n[0].setComponents(c-s,b-o,r-h,G-u).normalize(),n[1].setComponents(c+s,b+o,r+h,G+u).normalize(),n[2].setComponents(c+a,b+Z,r+p,G+C).normalize(),n[3].setComponents(c-a,b-Z,r-p,G-C).normalize(),n[4].setComponents(c-d,b-m,r-V,G-y).normalize(),e===tl)n[5].setComponents(c+d,b+m,r+V,G+y).normalize();else if(e===An)n[5].setComponents(d,m,V,y).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);return this}intersectsObject(t){if(t.boundingSphere!==void 0)t.boundingSphere===null&&t.computeBoundingSphere(),Ul.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;e.boundingSphere===null&&e.computeBoundingSphere(),Ul.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(Ul)}intersectsSprite(t){return Ul.center.set(0,0,0),Ul.radius=.7071067811865476,Ul.applyMatrix4(t.matrixWorld),this.intersectsSphere(Ul)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let s=0;s<6;s++)if(e[s].distanceToPoint(n)<i)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(mi.x=i.normal.x>0?t.max.x:t.min.x,mi.y=i.normal.y>0?t.max.y:t.min.y,mi.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(mi)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function od(){let l=null,t=!1,e=null,n=null;function i(s,a){e(s,a),n=l.requestAnimationFrame(i)}return{start:function(){t!==!0&&e!==null&&(n=l.requestAnimationFrame(i),t=!0)},stop:function(){l.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(s){e=s},setContext:function(s){l=s}}}function em(l){const t=new WeakMap;function e(d,c){const o=d.array,Z=d.usage,m=o.byteLength,b=l.createBuffer();l.bindBuffer(c,b),l.bufferData(c,o,Z),d.onUploadCallback();let h;if(o instanceof Float32Array)h=l.FLOAT;else if(o instanceof Uint16Array)d.isFloat16BufferAttribute?h=l.HALF_FLOAT:h=l.UNSIGNED_SHORT;else if(o instanceof Int16Array)h=l.SHORT;else if(o instanceof Uint32Array)h=l.UNSIGNED_INT;else if(o instanceof Int32Array)h=l.INT;else if(o instanceof Int8Array)h=l.BYTE;else if(o instanceof Uint8Array)h=l.UNSIGNED_BYTE;else if(o instanceof Uint8ClampedArray)h=l.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+o);return{buffer:b,type:h,bytesPerElement:o.BYTES_PER_ELEMENT,version:d.version,size:m}}function n(d,c,o){const Z=c.array,m=c.updateRanges;if(l.bindBuffer(o,d),m.length===0)l.bufferSubData(o,0,Z);else{m.sort((h,p)=>h.start-p.start);let b=0;for(let h=1;h<m.length;h++){const p=m[b],V=m[h];V.start<=p.start+p.count+1?p.count=Math.max(p.count,V.start+V.count-p.start):(++b,m[b]=V)}m.length=b+1;for(let h=0,p=m.length;h<p;h++){const V=m[h];l.bufferSubData(o,V.start*Z.BYTES_PER_ELEMENT,Z,V.start,V.count)}c.clearUpdateRanges()}c.onUploadCallback()}function i(d){return d.isInterleavedBufferAttribute&&(d=d.data),t.get(d)}function s(d){d.isInterleavedBufferAttribute&&(d=d.data);const c=t.get(d);c&&(l.deleteBuffer(c.buffer),t.delete(d))}function a(d,c){if(d.isInterleavedBufferAttribute&&(d=d.data),d.isGLBufferAttribute){const Z=t.get(d);(!Z||Z.version<d.version)&&t.set(d,{buffer:d.buffer,type:d.type,bytesPerElement:d.elementSize,version:d.version});return}const o=t.get(d);if(o===void 0)t.set(d,e(d,c));else if(o.version<d.version){if(o.size!==d.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");n(o.buffer,d,c),o.version=d.version}}return{get:i,remove:s,update:a}}class te extends Ue{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const s=t/2,a=e/2,d=Math.floor(n),c=Math.floor(i),o=d+1,Z=c+1,m=t/d,b=e/c,h=[],p=[],V=[],r=[];for(let u=0;u<Z;u++){const C=u*b-a;for(let y=0;y<o;y++){const G=y*m-s;p.push(G,-C,0),V.push(0,0,1),r.push(y/d),r.push(1-u/c)}}for(let u=0;u<c;u++)for(let C=0;C<d;C++){const y=C+o*u,G=C+o*(u+1),N=C+1+o*(u+1),I=C+1+o*u;h.push(y,G,I),h.push(G,N,I)}this.setIndex(h),this.setAttribute("position",new Fl(p,3)),this.setAttribute("normal",new Fl(V,3)),this.setAttribute("uv",new Fl(r,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new te(t.width,t.height,t.widthSegments,t.heightSegments)}}var lm=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,nm=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,im=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,am=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,sm=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,dm=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,cm=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,om=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,mm=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,Zm=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,hm=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,um=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,bm=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,rm=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,pm=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,Gm=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,Wm=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,Vm=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,Xm=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,gm=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,Rm=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,ym=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,Cm=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,Sm=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,Im=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,xm=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Ym=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Nm=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,fm=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Fm=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Lm="gl_FragColor = linearToOutputTexel( gl_FragColor );",Mm=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,Um=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Tm=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,vm=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Jm=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,km=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,wm=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,zm=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Hm=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Km=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Bm=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,Em=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Am=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,Pm=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,Qm=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,jm=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,_m=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,Dm=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,Om=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,qm=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,$m=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,tZ=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,eZ=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,lZ=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,nZ=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,iZ=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,aZ=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,sZ=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,dZ=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,cZ=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,oZ=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,mZ=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,ZZ=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,hZ=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,uZ=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,bZ=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,rZ=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,pZ=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,GZ=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,WZ=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,VZ=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,XZ=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,gZ=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,RZ=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,yZ=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,CZ=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,SZ=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,IZ=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,xZ=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,YZ=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,NZ=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,fZ=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,FZ=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,LZ=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,MZ=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,UZ=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,TZ=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,vZ=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,JZ=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,kZ=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,wZ=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,zZ=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,HZ=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,KZ=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,BZ=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,EZ=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,AZ=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,PZ=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,QZ=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,jZ=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,_Z=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,DZ=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,OZ=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,qZ=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,$Z=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,th=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const Ft={alphahash_fragment:lm,alphahash_pars_fragment:nm,alphamap_fragment:im,alphamap_pars_fragment:am,alphatest_fragment:sm,alphatest_pars_fragment:dm,aomap_fragment:cm,aomap_pars_fragment:om,batching_pars_vertex:mm,batching_vertex:Zm,begin_vertex:hm,beginnormal_vertex:um,bsdfs:bm,iridescence_fragment:rm,bumpmap_pars_fragment:pm,clipping_planes_fragment:Gm,clipping_planes_pars_fragment:Wm,clipping_planes_pars_vertex:Vm,clipping_planes_vertex:Xm,color_fragment:gm,color_pars_fragment:Rm,color_pars_vertex:ym,color_vertex:Cm,common:Sm,cube_uv_reflection_fragment:Im,defaultnormal_vertex:xm,displacementmap_pars_vertex:Ym,displacementmap_vertex:Nm,emissivemap_fragment:fm,emissivemap_pars_fragment:Fm,colorspace_fragment:Lm,colorspace_pars_fragment:Mm,envmap_fragment:Um,envmap_common_pars_fragment:Tm,envmap_pars_fragment:vm,envmap_pars_vertex:Jm,envmap_physical_pars_fragment:jm,envmap_vertex:km,fog_vertex:wm,fog_pars_vertex:zm,fog_fragment:Hm,fog_pars_fragment:Km,gradientmap_pars_fragment:Bm,lightmap_pars_fragment:Em,lights_lambert_fragment:Am,lights_lambert_pars_fragment:Pm,lights_pars_begin:Qm,lights_toon_fragment:_m,lights_toon_pars_fragment:Dm,lights_phong_fragment:Om,lights_phong_pars_fragment:qm,lights_physical_fragment:$m,lights_physical_pars_fragment:tZ,lights_fragment_begin:eZ,lights_fragment_maps:lZ,lights_fragment_end:nZ,logdepthbuf_fragment:iZ,logdepthbuf_pars_fragment:aZ,logdepthbuf_pars_vertex:sZ,logdepthbuf_vertex:dZ,map_fragment:cZ,map_pars_fragment:oZ,map_particle_fragment:mZ,map_particle_pars_fragment:ZZ,metalnessmap_fragment:hZ,metalnessmap_pars_fragment:uZ,morphinstance_vertex:bZ,morphcolor_vertex:rZ,morphnormal_vertex:pZ,morphtarget_pars_vertex:GZ,morphtarget_vertex:WZ,normal_fragment_begin:VZ,normal_fragment_maps:XZ,normal_pars_fragment:gZ,normal_pars_vertex:RZ,normal_vertex:yZ,normalmap_pars_fragment:CZ,clearcoat_normal_fragment_begin:SZ,clearcoat_normal_fragment_maps:IZ,clearcoat_pars_fragment:xZ,iridescence_pars_fragment:YZ,opaque_fragment:NZ,packing:fZ,premultiplied_alpha_fragment:FZ,project_vertex:LZ,dithering_fragment:MZ,dithering_pars_fragment:UZ,roughnessmap_fragment:TZ,roughnessmap_pars_fragment:vZ,shadowmap_pars_fragment:JZ,shadowmap_pars_vertex:kZ,shadowmap_vertex:wZ,shadowmask_pars_fragment:zZ,skinbase_vertex:HZ,skinning_pars_vertex:KZ,skinning_vertex:BZ,skinnormal_vertex:EZ,specularmap_fragment:AZ,specularmap_pars_fragment:PZ,tonemapping_fragment:QZ,tonemapping_pars_fragment:jZ,transmission_fragment:_Z,transmission_pars_fragment:DZ,uv_pars_fragment:OZ,uv_pars_vertex:qZ,uv_vertex:$Z,worldpos_vertex:th,background_vert:`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,background_frag:`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,backgroundCube_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,backgroundCube_frag:`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,cube_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,cube_frag:`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,depth_vert:`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,depth_frag:`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,distanceRGBA_vert:`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,distanceRGBA_frag:`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,equirect_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,equirect_frag:`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,linedashed_vert:`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,linedashed_frag:`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,meshbasic_vert:`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,meshbasic_frag:`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshlambert_vert:`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshlambert_frag:`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshmatcap_vert:`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,meshmatcap_frag:`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshnormal_vert:`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,meshnormal_frag:`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,meshphong_vert:`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshphong_frag:`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphysical_vert:`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,meshphysical_frag:`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshtoon_vert:`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshtoon_frag:`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,points_vert:`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,points_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,shadow_vert:`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,shadow_frag:`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,sprite_vert:`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,sprite_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`},et={common:{diffuse:{value:new Kt(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new xt},alphaMap:{value:null},alphaMapTransform:{value:new xt},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new xt}},envmap:{envMap:{value:null},envMapRotation:{value:new xt},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new xt}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new xt}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new xt},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new xt},normalScale:{value:new ft(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new xt},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new xt}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new xt}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new xt}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Kt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Kt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new xt},alphaTest:{value:0},uvTransform:{value:new xt}},sprite:{diffuse:{value:new Kt(16777215)},opacity:{value:1},center:{value:new ft(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new xt},alphaMap:{value:null},alphaMapTransform:{value:new xt},alphaTest:{value:0}}},je={basic:{uniforms:Re([et.common,et.specularmap,et.envmap,et.aomap,et.lightmap,et.fog]),vertexShader:Ft.meshbasic_vert,fragmentShader:Ft.meshbasic_frag},lambert:{uniforms:Re([et.common,et.specularmap,et.envmap,et.aomap,et.lightmap,et.emissivemap,et.bumpmap,et.normalmap,et.displacementmap,et.fog,et.lights,{emissive:{value:new Kt(0)}}]),vertexShader:Ft.meshlambert_vert,fragmentShader:Ft.meshlambert_frag},phong:{uniforms:Re([et.common,et.specularmap,et.envmap,et.aomap,et.lightmap,et.emissivemap,et.bumpmap,et.normalmap,et.displacementmap,et.fog,et.lights,{emissive:{value:new Kt(0)},specular:{value:new Kt(1118481)},shininess:{value:30}}]),vertexShader:Ft.meshphong_vert,fragmentShader:Ft.meshphong_frag},standard:{uniforms:Re([et.common,et.envmap,et.aomap,et.lightmap,et.emissivemap,et.bumpmap,et.normalmap,et.displacementmap,et.roughnessmap,et.metalnessmap,et.fog,et.lights,{emissive:{value:new Kt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Ft.meshphysical_vert,fragmentShader:Ft.meshphysical_frag},toon:{uniforms:Re([et.common,et.aomap,et.lightmap,et.emissivemap,et.bumpmap,et.normalmap,et.displacementmap,et.gradientmap,et.fog,et.lights,{emissive:{value:new Kt(0)}}]),vertexShader:Ft.meshtoon_vert,fragmentShader:Ft.meshtoon_frag},matcap:{uniforms:Re([et.common,et.bumpmap,et.normalmap,et.displacementmap,et.fog,{matcap:{value:null}}]),vertexShader:Ft.meshmatcap_vert,fragmentShader:Ft.meshmatcap_frag},points:{uniforms:Re([et.points,et.fog]),vertexShader:Ft.points_vert,fragmentShader:Ft.points_frag},dashed:{uniforms:Re([et.common,et.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Ft.linedashed_vert,fragmentShader:Ft.linedashed_frag},depth:{uniforms:Re([et.common,et.displacementmap]),vertexShader:Ft.depth_vert,fragmentShader:Ft.depth_frag},normal:{uniforms:Re([et.common,et.bumpmap,et.normalmap,et.displacementmap,{opacity:{value:1}}]),vertexShader:Ft.meshnormal_vert,fragmentShader:Ft.meshnormal_frag},sprite:{uniforms:Re([et.sprite,et.fog]),vertexShader:Ft.sprite_vert,fragmentShader:Ft.sprite_frag},background:{uniforms:{uvTransform:{value:new xt},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Ft.background_vert,fragmentShader:Ft.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new xt}},vertexShader:Ft.backgroundCube_vert,fragmentShader:Ft.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Ft.cube_vert,fragmentShader:Ft.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Ft.equirect_vert,fragmentShader:Ft.equirect_frag},distanceRGBA:{uniforms:Re([et.common,et.displacementmap,{referencePosition:{value:new J},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Ft.distanceRGBA_vert,fragmentShader:Ft.distanceRGBA_frag},shadow:{uniforms:Re([et.lights,et.fog,{color:{value:new Kt(0)},opacity:{value:1}}]),vertexShader:Ft.shadow_vert,fragmentShader:Ft.shadow_frag}};je.physical={uniforms:Re([je.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new xt},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new xt},clearcoatNormalScale:{value:new ft(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new xt},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new xt},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new xt},sheen:{value:0},sheenColor:{value:new Kt(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new xt},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new xt},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new xt},transmissionSamplerSize:{value:new ft},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new xt},attenuationDistance:{value:0},attenuationColor:{value:new Kt(0)},specularColor:{value:new Kt(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new xt},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new xt},anisotropyVector:{value:new ft},anisotropyMap:{value:null},anisotropyMapTransform:{value:new xt}}]),vertexShader:Ft.meshphysical_vert,fragmentShader:Ft.meshphysical_frag};const Zi={r:0,b:0,g:0},Tl=new il,eh=new ae;function lh(l,t,e,n,i,s,a){const d=new Kt(0);let c=s===!0?0:1,o,Z,m=null,b=0,h=null;function p(C){let y=C.isScene===!0?C.background:null;return y&&y.isTexture&&(y=(C.backgroundBlurriness>0?e:t).get(y)),y}function V(C){let y=!1;const G=p(C);G===null?u(d,c):G&&G.isColor&&(u(G,1),y=!0);const N=l.xr.getEnvironmentBlendMode();N==="additive"?n.buffers.color.setClear(0,0,0,1,a):N==="alpha-blend"&&n.buffers.color.setClear(0,0,0,0,a),(l.autoClear||y)&&(n.buffers.depth.setTest(!0),n.buffers.depth.setMask(!0),n.buffers.color.setMask(!0),l.clear(l.autoClearColor,l.autoClearDepth,l.autoClearStencil))}function r(C,y){const G=p(y);G&&(G.isCubeTexture||G.mapping===Jn)?(Z===void 0&&(Z=new ee(new Fn(1,1,1),new ce({name:"BackgroundCubeMaterial",uniforms:on(je.backgroundCube.uniforms),vertexShader:je.backgroundCube.vertexShader,fragmentShader:je.backgroundCube.fragmentShader,side:ye,depthTest:!1,depthWrite:!1,fog:!1})),Z.geometry.deleteAttribute("normal"),Z.geometry.deleteAttribute("uv"),Z.onBeforeRender=function(N,I,x){this.matrixWorld.copyPosition(x.matrixWorld)},Object.defineProperty(Z.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(Z)),Tl.copy(y.backgroundRotation),Tl.x*=-1,Tl.y*=-1,Tl.z*=-1,G.isCubeTexture&&G.isRenderTargetTexture===!1&&(Tl.y*=-1,Tl.z*=-1),Z.material.uniforms.envMap.value=G,Z.material.uniforms.flipEnvMap.value=G.isCubeTexture&&G.isRenderTargetTexture===!1?-1:1,Z.material.uniforms.backgroundBlurriness.value=y.backgroundBlurriness,Z.material.uniforms.backgroundIntensity.value=y.backgroundIntensity,Z.material.uniforms.backgroundRotation.value.setFromMatrix4(eh.makeRotationFromEuler(Tl)),Z.material.toneMapped=kt.getTransfer(G.colorSpace)!==Pt,(m!==G||b!==G.version||h!==l.toneMapping)&&(Z.material.needsUpdate=!0,m=G,b=G.version,h=l.toneMapping),Z.layers.enableAll(),C.unshift(Z,Z.geometry,Z.material,0,0,null)):G&&G.isTexture&&(o===void 0&&(o=new ee(new te(2,2),new ce({name:"BackgroundMaterial",uniforms:on(je.background.uniforms),vertexShader:je.background.vertexShader,fragmentShader:je.background.fragmentShader,side:ml,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(o)),o.material.uniforms.t2D.value=G,o.material.uniforms.backgroundIntensity.value=y.backgroundIntensity,o.material.toneMapped=kt.getTransfer(G.colorSpace)!==Pt,G.matrixAutoUpdate===!0&&G.updateMatrix(),o.material.uniforms.uvTransform.value.copy(G.matrix),(m!==G||b!==G.version||h!==l.toneMapping)&&(o.material.needsUpdate=!0,m=G,b=G.version,h=l.toneMapping),o.layers.enableAll(),C.unshift(o,o.geometry,o.material,0,0,null))}function u(C,y){C.getRGB(Zi,nd(l)),n.buffers.color.setClear(Zi.r,Zi.g,Zi.b,y,a)}return{getClearColor:function(){return d},setClearColor:function(C,y=1){d.set(C),c=y,u(d,c)},getClearAlpha:function(){return c},setClearAlpha:function(C){c=C,u(d,c)},render:V,addToRenderList:r}}function nh(l,t){const e=l.getParameter(l.MAX_VERTEX_ATTRIBS),n={},i=b(null);let s=i,a=!1;function d(g,Y,P,w,E){let D=!1;const K=m(w,P,Y);s!==K&&(s=K,o(s.object)),D=h(g,w,P,E),D&&p(g,w,P,E),E!==null&&t.update(E,l.ELEMENT_ARRAY_BUFFER),(D||a)&&(a=!1,G(g,Y,P,w),E!==null&&l.bindBuffer(l.ELEMENT_ARRAY_BUFFER,t.get(E).buffer))}function c(){return l.createVertexArray()}function o(g){return l.bindVertexArray(g)}function Z(g){return l.deleteVertexArray(g)}function m(g,Y,P){const w=P.wireframe===!0;let E=n[g.id];E===void 0&&(E={},n[g.id]=E);let D=E[Y.id];D===void 0&&(D={},E[Y.id]=D);let K=D[w];return K===void 0&&(K=b(c()),D[w]=K),K}function b(g){const Y=[],P=[],w=[];for(let E=0;E<e;E++)Y[E]=0,P[E]=0,w[E]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:Y,enabledAttributes:P,attributeDivisors:w,object:g,attributes:{},index:null}}function h(g,Y,P,w){const E=s.attributes,D=Y.attributes;let K=0;const $=P.getAttributes();for(const H in $)if($[H].location>=0){const ot=E[H];let Vt=D[H];if(Vt===void 0&&(H==="instanceMatrix"&&g.instanceMatrix&&(Vt=g.instanceMatrix),H==="instanceColor"&&g.instanceColor&&(Vt=g.instanceColor)),ot===void 0||ot.attribute!==Vt||Vt&&ot.data!==Vt.data)return!0;K++}return s.attributesNum!==K||s.index!==w}function p(g,Y,P,w){const E={},D=Y.attributes;let K=0;const $=P.getAttributes();for(const H in $)if($[H].location>=0){let ot=D[H];ot===void 0&&(H==="instanceMatrix"&&g.instanceMatrix&&(ot=g.instanceMatrix),H==="instanceColor"&&g.instanceColor&&(ot=g.instanceColor));const Vt={};Vt.attribute=ot,ot&&ot.data&&(Vt.data=ot.data),E[H]=Vt,K++}s.attributes=E,s.attributesNum=K,s.index=w}function V(){const g=s.newAttributes;for(let Y=0,P=g.length;Y<P;Y++)g[Y]=0}function r(g){u(g,0)}function u(g,Y){const P=s.newAttributes,w=s.enabledAttributes,E=s.attributeDivisors;P[g]=1,w[g]===0&&(l.enableVertexAttribArray(g),w[g]=1),E[g]!==Y&&(l.vertexAttribDivisor(g,Y),E[g]=Y)}function C(){const g=s.newAttributes,Y=s.enabledAttributes;for(let P=0,w=Y.length;P<w;P++)Y[P]!==g[P]&&(l.disableVertexAttribArray(P),Y[P]=0)}function y(g,Y,P,w,E,D,K){K===!0?l.vertexAttribIPointer(g,Y,P,E,D):l.vertexAttribPointer(g,Y,P,w,E,D)}function G(g,Y,P,w){V();const E=w.attributes,D=P.getAttributes(),K=Y.defaultAttributeValues;for(const $ in D){const H=D[$];if(H.location>=0){let nt=E[$];if(nt===void 0&&($==="instanceMatrix"&&g.instanceMatrix&&(nt=g.instanceMatrix),$==="instanceColor"&&g.instanceColor&&(nt=g.instanceColor)),nt!==void 0){const ot=nt.normalized,Vt=nt.itemSize,Mt=t.get(nt);if(Mt===void 0)continue;const Qt=Mt.buffer,A=Mt.type,tt=Mt.bytesPerElement,pt=A===l.INT||A===l.UNSIGNED_INT||nt.gpuType===Ki;if(nt.isInterleavedBufferAttribute){const it=nt.data,yt=it.stride,It=nt.offset;if(it.isInstancedInterleavedBuffer){for(let Ut=0;Ut<H.locationSize;Ut++)u(H.location+Ut,it.meshPerAttribute);g.isInstancedMesh!==!0&&w._maxInstanceCount===void 0&&(w._maxInstanceCount=it.meshPerAttribute*it.count)}else for(let Ut=0;Ut<H.locationSize;Ut++)r(H.location+Ut);l.bindBuffer(l.ARRAY_BUFFER,Qt);for(let Ut=0;Ut<H.locationSize;Ut++)y(H.location+Ut,Vt/H.locationSize,A,ot,yt*tt,(It+Vt/H.locationSize*Ut)*tt,pt)}else{if(nt.isInstancedBufferAttribute){for(let it=0;it<H.locationSize;it++)u(H.location+it,nt.meshPerAttribute);g.isInstancedMesh!==!0&&w._maxInstanceCount===void 0&&(w._maxInstanceCount=nt.meshPerAttribute*nt.count)}else for(let it=0;it<H.locationSize;it++)r(H.location+it);l.bindBuffer(l.ARRAY_BUFFER,Qt);for(let it=0;it<H.locationSize;it++)y(H.location+it,Vt/H.locationSize,A,ot,Vt*tt,Vt/H.locationSize*it*tt,pt)}}else if(K!==void 0){const ot=K[$];if(ot!==void 0)switch(ot.length){case 2:l.vertexAttrib2fv(H.location,ot);break;case 3:l.vertexAttrib3fv(H.location,ot);break;case 4:l.vertexAttrib4fv(H.location,ot);break;default:l.vertexAttrib1fv(H.location,ot)}}}}C()}function N(){U();for(const g in n){const Y=n[g];for(const P in Y){const w=Y[P];for(const E in w)Z(w[E].object),delete w[E];delete Y[P]}delete n[g]}}function I(g){if(n[g.id]===void 0)return;const Y=n[g.id];for(const P in Y){const w=Y[P];for(const E in w)Z(w[E].object),delete w[E];delete Y[P]}delete n[g.id]}function x(g){for(const Y in n){const P=n[Y];if(P[g.id]===void 0)continue;const w=P[g.id];for(const E in w)Z(w[E].object),delete w[E];delete P[g.id]}}function U(){R(),a=!0,s!==i&&(s=i,o(s.object))}function R(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:d,reset:U,resetDefaultState:R,dispose:N,releaseStatesOfGeometry:I,releaseStatesOfProgram:x,initAttributes:V,enableAttribute:r,disableUnusedAttributes:C}}function ih(l,t,e){let n;function i(o){n=o}function s(o,Z){l.drawArrays(n,o,Z),e.update(Z,n,1)}function a(o,Z,m){m!==0&&(l.drawArraysInstanced(n,o,Z,m),e.update(Z,n,m))}function d(o,Z,m){if(m===0)return;t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n,o,0,Z,0,m);let h=0;for(let p=0;p<m;p++)h+=Z[p];e.update(h,n,1)}function c(o,Z,m,b){if(m===0)return;const h=t.get("WEBGL_multi_draw");if(h===null)for(let p=0;p<o.length;p++)a(o[p],Z[p],b[p]);else{h.multiDrawArraysInstancedWEBGL(n,o,0,Z,0,b,0,m);let p=0;for(let V=0;V<m;V++)p+=Z[V]*b[V];e.update(p,n,1)}}this.setMode=i,this.render=s,this.renderInstances=a,this.renderMultiDraw=d,this.renderMultiDrawInstances=c}function ah(l,t,e,n){let i;function s(){if(i!==void 0)return i;if(t.has("EXT_texture_filter_anisotropic")===!0){const x=t.get("EXT_texture_filter_anisotropic");i=l.getParameter(x.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function a(x){return!(x!==Fe&&n.convert(x)!==l.getParameter(l.IMPLEMENTATION_COLOR_READ_FORMAT))}function d(x){const U=x===Wn&&(t.has("EXT_color_buffer_half_float")||t.has("EXT_color_buffer_float"));return!(x!==Qe&&n.convert(x)!==l.getParameter(l.IMPLEMENTATION_COLOR_READ_TYPE)&&x!==$e&&!U)}function c(x){if(x==="highp"){if(l.getShaderPrecisionFormat(l.VERTEX_SHADER,l.HIGH_FLOAT).precision>0&&l.getShaderPrecisionFormat(l.FRAGMENT_SHADER,l.HIGH_FLOAT).precision>0)return"highp";x="mediump"}return x==="mediump"&&l.getShaderPrecisionFormat(l.VERTEX_SHADER,l.MEDIUM_FLOAT).precision>0&&l.getShaderPrecisionFormat(l.FRAGMENT_SHADER,l.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let o=e.precision!==void 0?e.precision:"highp";const Z=c(o);Z!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",Z,"instead."),o=Z);const m=e.logarithmicDepthBuffer===!0,b=e.reverseDepthBuffer===!0&&t.has("EXT_clip_control"),h=l.getParameter(l.MAX_TEXTURE_IMAGE_UNITS),p=l.getParameter(l.MAX_VERTEX_TEXTURE_IMAGE_UNITS),V=l.getParameter(l.MAX_TEXTURE_SIZE),r=l.getParameter(l.MAX_CUBE_MAP_TEXTURE_SIZE),u=l.getParameter(l.MAX_VERTEX_ATTRIBS),C=l.getParameter(l.MAX_VERTEX_UNIFORM_VECTORS),y=l.getParameter(l.MAX_VARYING_VECTORS),G=l.getParameter(l.MAX_FRAGMENT_UNIFORM_VECTORS),N=p>0,I=l.getParameter(l.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:s,getMaxPrecision:c,textureFormatReadable:a,textureTypeReadable:d,precision:o,logarithmicDepthBuffer:m,reverseDepthBuffer:b,maxTextures:h,maxVertexTextures:p,maxTextureSize:V,maxCubemapSize:r,maxAttributes:u,maxVertexUniforms:C,maxVaryings:y,maxFragmentUniforms:G,vertexTextures:N,maxSamples:I}}function sh(l){const t=this;let e=null,n=0,i=!1,s=!1;const a=new Ml,d=new xt,c={value:null,needsUpdate:!1};this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(m,b){const h=m.length!==0||b||n!==0||i;return i=b,n=m.length,h},this.beginShadows=function(){s=!0,Z(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(m,b){e=Z(m,b,0)},this.setState=function(m,b,h){const p=m.clippingPlanes,V=m.clipIntersection,r=m.clipShadows,u=l.get(m);if(!i||p===null||p.length===0||s&&!r)s?Z(null):o();else{const C=s?0:n,y=C*4;let G=u.clippingState||null;c.value=G,G=Z(p,b,y,h);for(let N=0;N!==y;++N)G[N]=e[N];u.clippingState=G,this.numIntersection=V?this.numPlanes:0,this.numPlanes+=C}};function o(){c.value!==e&&(c.value=e,c.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function Z(m,b,h,p){const V=m!==null?m.length:0;let r=null;if(V!==0){if(r=c.value,p!==!0||r===null){const u=h+V*4,C=b.matrixWorldInverse;d.getNormalMatrix(C),(r===null||r.length<u)&&(r=new Float32Array(u));for(let y=0,G=h;y!==V;++y,G+=4)a.copy(m[y]).applyMatrix4(C,d),a.normal.toArray(r,G),r[G+3]=a.constant}c.value=r,c.needsUpdate=!0}return t.numPlanes=V,t.numIntersection=0,r}}function dh(l){let t=new WeakMap;function e(a,d){return d===Ji?a.mapping=Hl:d===ki&&(a.mapping=Kl),a}function n(a){if(a&&a.isTexture){const d=a.mapping;if(d===Ji||d===ki)if(t.has(a)){const c=t.get(a).texture;return e(c,a.mapping)}else{const c=a.image;if(c&&c.height>0){const o=new qo(c.height);return o.fromEquirectangularTexture(l,a),t.set(a,o),a.addEventListener("dispose",i),e(o.texture,a.mapping)}else return null}}return a}function i(a){const d=a.target;d.removeEventListener("dispose",i);const c=t.get(d);c!==void 0&&(t.delete(d),c.dispose())}function s(){t=new WeakMap}return{get:n,dispose:s}}class Ha extends id{constructor(t=-1,e=1,n=1,i=-1,s=.1,a=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=s,this.far=a,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,s,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let s=n-t,a=n+t,d=i+e,c=i-e;if(this.view!==null&&this.view.enabled){const o=(this.right-this.left)/this.view.fullWidth/this.zoom,Z=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=o*this.view.offsetX,a=s+o*this.view.width,d-=Z*this.view.offsetY,c=d-Z*this.view.height}this.projectionMatrix.makeOrthographic(s,a,d,c,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}const hn=4,md=[.125,.215,.35,.446,.526,.582],vl=20,Ka=new Ha,Zd=new Kt;let Ba=null,Ea=0,Aa=0,Pa=!1;const Jl=(1+Math.sqrt(5))/2,un=1/Jl,hd=[new J(-Jl,un,0),new J(Jl,un,0),new J(-un,0,Jl),new J(un,0,Jl),new J(0,Jl,-un),new J(0,Jl,un),new J(-1,1,-1),new J(1,1,-1),new J(-1,1,1),new J(1,1,1)];class ud{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,i=100){Ba=this._renderer.getRenderTarget(),Ea=this._renderer.getActiveCubeFace(),Aa=this._renderer.getActiveMipmapLevel(),Pa=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(t,n,i,s),e>0&&this._blur(s,0,0,e),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=pd(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=rd(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(Ba,Ea,Aa),this._renderer.xr.enabled=Pa,t.scissorTest=!1,hi(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===Hl||t.mapping===Kl?this._setSize(t.image.length===0?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),Ba=this._renderer.getRenderTarget(),Ea=this._renderer.getActiveCubeFace(),Aa=this._renderer.getActiveMipmapLevel(),Pa=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const n=e||this._allocateTargets();return this._textureToCubeUV(t,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,n={magFilter:be,minFilter:be,generateMipmaps:!1,type:Wn,format:Fe,colorSpace:Pl,depthBuffer:!1},i=bd(t,e,n);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==t||this._pingPongRenderTarget.height!==e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=bd(t,e,n);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=ch(s)),this._blurMaterial=oh(s,t,e)}return i}_compileMaterial(t){const e=new ee(this._lodPlanes[0],t);this._renderer.compile(e,Ka)}_sceneToCubeUV(t,e,n,i){const d=new Ke(90,1,e,n),c=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],Z=this._renderer,m=Z.autoClear,b=Z.toneMapping;Z.getClearColor(Zd),Z.toneMapping=hl,Z.autoClear=!1;const h=new Nn({name:"PMREM.Background",side:ye,depthWrite:!1,depthTest:!1}),p=new ee(new Fn,h);let V=!1;const r=t.background;r?r.isColor&&(h.color.copy(r),t.background=null,V=!0):(h.color.copy(Zd),V=!0);for(let u=0;u<6;u++){const C=u%3;C===0?(d.up.set(0,c[u],0),d.lookAt(o[u],0,0)):C===1?(d.up.set(0,0,c[u]),d.lookAt(0,o[u],0)):(d.up.set(0,c[u],0),d.lookAt(0,0,o[u]));const y=this._cubeSize;hi(i,C*y,u>2?y:0,y,y),Z.setRenderTarget(i),V&&Z.render(p,d),Z.render(t,d)}p.geometry.dispose(),p.material.dispose(),Z.toneMapping=b,Z.autoClear=m,t.background=r}_textureToCubeUV(t,e){const n=this._renderer,i=t.mapping===Hl||t.mapping===Kl;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=pd()),this._cubemapMaterial.uniforms.flipEnvMap.value=t.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=rd());const s=i?this._cubemapMaterial:this._equirectMaterial,a=new ee(this._lodPlanes[0],s),d=s.uniforms;d.envMap.value=t;const c=this._cubeSize;hi(e,0,0,3*c,2*c),n.setRenderTarget(e),n.render(a,Ka)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;const i=this._lodPlanes.length;for(let s=1;s<i;s++){const a=Math.sqrt(this._sigmas[s]*this._sigmas[s]-this._sigmas[s-1]*this._sigmas[s-1]),d=hd[(i-s-1)%hd.length];this._blur(t,s-1,s,a,d)}e.autoClear=n}_blur(t,e,n,i,s){const a=this._pingPongRenderTarget;this._halfBlur(t,a,e,n,i,"latitudinal",s),this._halfBlur(a,t,n,n,i,"longitudinal",s)}_halfBlur(t,e,n,i,s,a,d){const c=this._renderer,o=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const Z=3,m=new ee(this._lodPlanes[i],o),b=o.uniforms,h=this._sizeLods[n]-1,p=isFinite(s)?Math.PI/(2*h):2*Math.PI/(2*vl-1),V=s/p,r=isFinite(s)?1+Math.floor(Z*V):vl;r>vl&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${r} samples when the maximum is set to ${vl}`);const u=[];let C=0;for(let x=0;x<vl;++x){const U=x/V,R=Math.exp(-U*U/2);u.push(R),x===0?C+=R:x<r&&(C+=2*R)}for(let x=0;x<u.length;x++)u[x]=u[x]/C;b.envMap.value=t.texture,b.samples.value=r,b.weights.value=u,b.latitudinal.value=a==="latitudinal",d&&(b.poleAxis.value=d);const{_lodMax:y}=this;b.dTheta.value=p,b.mipInt.value=y-n;const G=this._sizeLods[i],N=3*G*(i>y-hn?i-y+hn:0),I=4*(this._cubeSize-G);hi(e,N,I,3*G,2*G),c.setRenderTarget(e),c.render(m,Ka)}}function ch(l){const t=[],e=[],n=[];let i=l;const s=l-hn+1+md.length;for(let a=0;a<s;a++){const d=Math.pow(2,i);e.push(d);let c=1/d;a>l-hn?c=md[a-l+hn-1]:a===0&&(c=0),n.push(c);const o=1/(d-2),Z=-o,m=1+o,b=[Z,Z,m,Z,m,m,Z,Z,m,m,Z,m],h=6,p=6,V=3,r=2,u=1,C=new Float32Array(V*p*h),y=new Float32Array(r*p*h),G=new Float32Array(u*p*h);for(let I=0;I<h;I++){const x=I%3*2/3-1,U=I>2?0:-1,R=[x,U,0,x+2/3,U,0,x+2/3,U+1,0,x,U,0,x+2/3,U+1,0,x,U+1,0];C.set(R,V*p*I),y.set(b,r*p*I);const g=[I,I,I,I,I,I];G.set(g,u*p*I)}const N=new Ue;N.setAttribute("position",new Se(C,V)),N.setAttribute("uv",new Se(y,r)),N.setAttribute("faceIndex",new Se(G,u)),t.push(N),i>hn&&i--}return{lodPlanes:t,sizeLods:e,sigmas:n}}function bd(l,t,e){const n=new bl(l,t,e);return n.texture.mapping=Jn,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function hi(l,t,e,n,i){l.viewport.set(t,e,n,i),l.scissor.set(t,e,n,i)}function oh(l,t,e){const n=new Float32Array(vl),i=new J(0,1,0);return new ce({name:"SphericalGaussianBlur",defines:{n:vl,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/e,CUBEUV_MAX_MIP:`${l}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:Qa(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Zl,depthTest:!1,depthWrite:!1})}function rd(){return new ce({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:Qa(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Zl,depthTest:!1,depthWrite:!1})}function pd(){return new ce({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:Qa(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Zl,depthTest:!1,depthWrite:!1})}function Qa(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function mh(l){let t=new WeakMap,e=null;function n(d){if(d&&d.isTexture){const c=d.mapping,o=c===Ji||c===ki,Z=c===Hl||c===Kl;if(o||Z){let m=t.get(d);const b=m!==void 0?m.texture.pmremVersion:0;if(d.isRenderTargetTexture&&d.pmremVersion!==b)return e===null&&(e=new ud(l)),m=o?e.fromEquirectangular(d,m):e.fromCubemap(d,m),m.texture.pmremVersion=d.pmremVersion,t.set(d,m),m.texture;if(m!==void 0)return m.texture;{const h=d.image;return o&&h&&h.height>0||Z&&h&&i(h)?(e===null&&(e=new ud(l)),m=o?e.fromEquirectangular(d):e.fromCubemap(d),m.texture.pmremVersion=d.pmremVersion,t.set(d,m),d.addEventListener("dispose",s),m.texture):null}}}return d}function i(d){let c=0;const o=6;for(let Z=0;Z<o;Z++)d[Z]!==void 0&&c++;return c===o}function s(d){const c=d.target;c.removeEventListener("dispose",s);const o=t.get(c);o!==void 0&&(t.delete(c),o.dispose())}function a(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:n,dispose:a}}function Zh(l){const t={};function e(n){if(t[n]!==void 0)return t[n];let i;switch(n){case"WEBGL_depth_texture":i=l.getExtension("WEBGL_depth_texture")||l.getExtension("MOZ_WEBGL_depth_texture")||l.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=l.getExtension("EXT_texture_filter_anisotropic")||l.getExtension("MOZ_EXT_texture_filter_anisotropic")||l.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=l.getExtension("WEBGL_compressed_texture_s3tc")||l.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||l.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=l.getExtension("WEBGL_compressed_texture_pvrtc")||l.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=l.getExtension(n)}return t[n]=i,i}return{has:function(n){return e(n)!==null},init:function(){e("EXT_color_buffer_float"),e("WEBGL_clip_cull_distance"),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("WEBGL_multisampled_render_to_texture"),e("WEBGL_render_shared_exponent")},get:function(n){const i=e(n);return i===null&&Rn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function hh(l,t,e,n){const i={},s=new WeakMap;function a(m){const b=m.target;b.index!==null&&t.remove(b.index);for(const p in b.attributes)t.remove(b.attributes[p]);for(const p in b.morphAttributes){const V=b.morphAttributes[p];for(let r=0,u=V.length;r<u;r++)t.remove(V[r])}b.removeEventListener("dispose",a),delete i[b.id];const h=s.get(b);h&&(t.remove(h),s.delete(b)),n.releaseStatesOfGeometry(b),b.isInstancedBufferGeometry===!0&&delete b._maxInstanceCount,e.memory.geometries--}function d(m,b){return i[b.id]===!0||(b.addEventListener("dispose",a),i[b.id]=!0,e.memory.geometries++),b}function c(m){const b=m.attributes;for(const p in b)t.update(b[p],l.ARRAY_BUFFER);const h=m.morphAttributes;for(const p in h){const V=h[p];for(let r=0,u=V.length;r<u;r++)t.update(V[r],l.ARRAY_BUFFER)}}function o(m){const b=[],h=m.index,p=m.attributes.position;let V=0;if(h!==null){const C=h.array;V=h.version;for(let y=0,G=C.length;y<G;y+=3){const N=C[y+0],I=C[y+1],x=C[y+2];b.push(N,I,I,x,x,N)}}else if(p!==void 0){const C=p.array;V=p.version;for(let y=0,G=C.length/3-1;y<G;y+=3){const N=y+0,I=y+1,x=y+2;b.push(N,I,I,x,x,N)}}else return;const r=new(Fs(b)?$s:qs)(b,1);r.version=V;const u=s.get(m);u&&t.remove(u),s.set(m,r)}function Z(m){const b=s.get(m);if(b){const h=m.index;h!==null&&b.version<h.version&&o(m)}else o(m);return s.get(m)}return{get:d,update:c,getWireframeAttribute:Z}}function uh(l,t,e){let n;function i(b){n=b}let s,a;function d(b){s=b.type,a=b.bytesPerElement}function c(b,h){l.drawElements(n,h,s,b*a),e.update(h,n,1)}function o(b,h,p){p!==0&&(l.drawElementsInstanced(n,h,s,b*a,p),e.update(h,n,p))}function Z(b,h,p){if(p===0)return;t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n,h,0,s,b,0,p);let r=0;for(let u=0;u<p;u++)r+=h[u];e.update(r,n,1)}function m(b,h,p,V){if(p===0)return;const r=t.get("WEBGL_multi_draw");if(r===null)for(let u=0;u<b.length;u++)o(b[u]/a,h[u],V[u]);else{r.multiDrawElementsInstancedWEBGL(n,h,0,s,b,0,V,0,p);let u=0;for(let C=0;C<p;C++)u+=h[C]*V[C];e.update(u,n,1)}}this.setMode=i,this.setIndex=d,this.render=c,this.renderInstances=o,this.renderMultiDraw=Z,this.renderMultiDrawInstances=m}function bh(l){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,a,d){switch(e.calls++,a){case l.TRIANGLES:e.triangles+=d*(s/3);break;case l.LINES:e.lines+=d*(s/2);break;case l.LINE_STRIP:e.lines+=d*(s-1);break;case l.LINE_LOOP:e.lines+=d*s;break;case l.POINTS:e.points+=d*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function i(){e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:i,update:n}}function rh(l,t,e){const n=new WeakMap,i=new ie;function s(a,d,c){const o=a.morphTargetInfluences,Z=d.morphAttributes.position||d.morphAttributes.normal||d.morphAttributes.color,m=Z!==void 0?Z.length:0;let b=n.get(d);if(b===void 0||b.count!==m){let R=function(){x.dispose(),n.delete(d),d.removeEventListener("dispose",R)};b!==void 0&&b.texture.dispose();const h=d.morphAttributes.position!==void 0,p=d.morphAttributes.normal!==void 0,V=d.morphAttributes.color!==void 0,r=d.morphAttributes.position||[],u=d.morphAttributes.normal||[],C=d.morphAttributes.color||[];let y=0;h===!0&&(y=1),p===!0&&(y=2),V===!0&&(y=3);let G=d.attributes.position.count*y,N=1;G>t.maxTextureSize&&(N=Math.ceil(G/t.maxTextureSize),G=t.maxTextureSize);const I=new Float32Array(G*N*4*m),x=new ws(I,G,N,m);x.type=$e,x.needsUpdate=!0;const U=y*4;for(let g=0;g<m;g++){const Y=r[g],P=u[g],w=C[g],E=G*N*4*g;for(let D=0;D<Y.count;D++){const K=D*U;h===!0&&(i.fromBufferAttribute(Y,D),I[E+K+0]=i.x,I[E+K+1]=i.y,I[E+K+2]=i.z,I[E+K+3]=0),p===!0&&(i.fromBufferAttribute(P,D),I[E+K+4]=i.x,I[E+K+5]=i.y,I[E+K+6]=i.z,I[E+K+7]=0),V===!0&&(i.fromBufferAttribute(w,D),I[E+K+8]=i.x,I[E+K+9]=i.y,I[E+K+10]=i.z,I[E+K+11]=w.itemSize===4?i.w:1)}}b={count:m,texture:x,size:new ft(G,N)},n.set(d,b),d.addEventListener("dispose",R)}if(a.isInstancedMesh===!0&&a.morphTexture!==null)c.getUniforms().setValue(l,"morphTexture",a.morphTexture,e);else{let h=0;for(let V=0;V<o.length;V++)h+=o[V];const p=d.morphTargetsRelative?1:1-h;c.getUniforms().setValue(l,"morphTargetBaseInfluence",p),c.getUniforms().setValue(l,"morphTargetInfluences",o)}c.getUniforms().setValue(l,"morphTargetsTexture",b.texture,e),c.getUniforms().setValue(l,"morphTargetsTextureSize",b.size)}return{update:s}}function ph(l,t,e,n){let i=new WeakMap;function s(c){const o=n.render.frame,Z=c.geometry,m=t.get(c,Z);if(i.get(m)!==o&&(t.update(m),i.set(m,o)),c.isInstancedMesh&&(c.hasEventListener("dispose",d)===!1&&c.addEventListener("dispose",d),i.get(c)!==o&&(e.update(c.instanceMatrix,l.ARRAY_BUFFER),c.instanceColor!==null&&e.update(c.instanceColor,l.ARRAY_BUFFER),i.set(c,o))),c.isSkinnedMesh){const b=c.skeleton;i.get(b)!==o&&(b.update(),i.set(b,o))}return m}function a(){i=new WeakMap}function d(c){const o=c.target;o.removeEventListener("dispose",d),e.remove(o.instanceMatrix),o.instanceColor!==null&&e.remove(o.instanceColor)}return{update:s,dispose:a}}class Gd extends ge{constructor(t,e,n,i,s,a,d,c,o,Z=El){if(Z!==El&&Z!==Al)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&Z===El&&(n=Yl),n===void 0&&Z===Al&&(n=Bl),super(null,i,s,a,d,c,Z,n,o),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=d!==void 0?d:Je,this.minFilter=c!==void 0?c:Je,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return this.compareFunction!==null&&(e.compareFunction=this.compareFunction),e}}const Wd=new ge,Vd=new Gd(1,1),Xd=new ws,gd=new vo,Rd=new dd,yd=[],Cd=[],Sd=new Float32Array(16),Id=new Float32Array(9),xd=new Float32Array(4);function bn(l,t,e){const n=l[0];if(n<=0||n>0)return l;const i=t*e;let s=yd[i];if(s===void 0&&(s=new Float32Array(i),yd[i]=s),t!==0){n.toArray(s,0);for(let a=1,d=0;a!==t;++a)d+=e,l[a].toArray(s,d)}return s}function oe(l,t){if(l.length!==t.length)return!1;for(let e=0,n=l.length;e<n;e++)if(l[e]!==t[e])return!1;return!0}function me(l,t){for(let e=0,n=t.length;e<n;e++)l[e]=t[e]}function ui(l,t){let e=Cd[t];e===void 0&&(e=new Int32Array(t),Cd[t]=e);for(let n=0;n!==t;++n)e[n]=l.allocateTextureUnit();return e}function Gh(l,t){const e=this.cache;e[0]!==t&&(l.uniform1f(this.addr,t),e[0]=t)}function Wh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(l.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(oe(e,t))return;l.uniform2fv(this.addr,t),me(e,t)}}function Vh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(l.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(l.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(oe(e,t))return;l.uniform3fv(this.addr,t),me(e,t)}}function Xh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(l.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(oe(e,t))return;l.uniform4fv(this.addr,t),me(e,t)}}function gh(l,t){const e=this.cache,n=t.elements;if(n===void 0){if(oe(e,t))return;l.uniformMatrix2fv(this.addr,!1,t),me(e,t)}else{if(oe(e,n))return;xd.set(n),l.uniformMatrix2fv(this.addr,!1,xd),me(e,n)}}function Rh(l,t){const e=this.cache,n=t.elements;if(n===void 0){if(oe(e,t))return;l.uniformMatrix3fv(this.addr,!1,t),me(e,t)}else{if(oe(e,n))return;Id.set(n),l.uniformMatrix3fv(this.addr,!1,Id),me(e,n)}}function yh(l,t){const e=this.cache,n=t.elements;if(n===void 0){if(oe(e,t))return;l.uniformMatrix4fv(this.addr,!1,t),me(e,t)}else{if(oe(e,n))return;Sd.set(n),l.uniformMatrix4fv(this.addr,!1,Sd),me(e,n)}}function Ch(l,t){const e=this.cache;e[0]!==t&&(l.uniform1i(this.addr,t),e[0]=t)}function Sh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(l.uniform2i(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(oe(e,t))return;l.uniform2iv(this.addr,t),me(e,t)}}function Ih(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(l.uniform3i(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else{if(oe(e,t))return;l.uniform3iv(this.addr,t),me(e,t)}}function xh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(l.uniform4i(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(oe(e,t))return;l.uniform4iv(this.addr,t),me(e,t)}}function Yh(l,t){const e=this.cache;e[0]!==t&&(l.uniform1ui(this.addr,t),e[0]=t)}function Nh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(l.uniform2ui(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(oe(e,t))return;l.uniform2uiv(this.addr,t),me(e,t)}}function fh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(l.uniform3ui(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else{if(oe(e,t))return;l.uniform3uiv(this.addr,t),me(e,t)}}function Fh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(l.uniform4ui(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(oe(e,t))return;l.uniform4uiv(this.addr,t),me(e,t)}}function Lh(l,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(l.uniform1i(this.addr,i),n[0]=i);let s;this.type===l.SAMPLER_2D_SHADOW?(Vd.compareFunction=xs,s=Vd):s=Wd,e.setTexture2D(t||s,i)}function Mh(l,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(l.uniform1i(this.addr,i),n[0]=i),e.setTexture3D(t||gd,i)}function Uh(l,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(l.uniform1i(this.addr,i),n[0]=i),e.setTextureCube(t||Rd,i)}function Th(l,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(l.uniform1i(this.addr,i),n[0]=i),e.setTexture2DArray(t||Xd,i)}function vh(l){switch(l){case 5126:return Gh;case 35664:return Wh;case 35665:return Vh;case 35666:return Xh;case 35674:return gh;case 35675:return Rh;case 35676:return yh;case 5124:case 35670:return Ch;case 35667:case 35671:return Sh;case 35668:case 35672:return Ih;case 35669:case 35673:return xh;case 5125:return Yh;case 36294:return Nh;case 36295:return fh;case 36296:return Fh;case 35678:case 36198:case 36298:case 36306:case 35682:return Lh;case 35679:case 36299:case 36307:return Mh;case 35680:case 36300:case 36308:case 36293:return Uh;case 36289:case 36303:case 36311:case 36292:return Th}}function Jh(l,t){l.uniform1fv(this.addr,t)}function kh(l,t){const e=bn(t,this.size,2);l.uniform2fv(this.addr,e)}function wh(l,t){const e=bn(t,this.size,3);l.uniform3fv(this.addr,e)}function zh(l,t){const e=bn(t,this.size,4);l.uniform4fv(this.addr,e)}function Hh(l,t){const e=bn(t,this.size,4);l.uniformMatrix2fv(this.addr,!1,e)}function Kh(l,t){const e=bn(t,this.size,9);l.uniformMatrix3fv(this.addr,!1,e)}function Bh(l,t){const e=bn(t,this.size,16);l.uniformMatrix4fv(this.addr,!1,e)}function Eh(l,t){l.uniform1iv(this.addr,t)}function Ah(l,t){l.uniform2iv(this.addr,t)}function Ph(l,t){l.uniform3iv(this.addr,t)}function Qh(l,t){l.uniform4iv(this.addr,t)}function jh(l,t){l.uniform1uiv(this.addr,t)}function _h(l,t){l.uniform2uiv(this.addr,t)}function Dh(l,t){l.uniform3uiv(this.addr,t)}function Oh(l,t){l.uniform4uiv(this.addr,t)}function qh(l,t,e){const n=this.cache,i=t.length,s=ui(e,i);oe(n,s)||(l.uniform1iv(this.addr,s),me(n,s));for(let a=0;a!==i;++a)e.setTexture2D(t[a]||Wd,s[a])}function $h(l,t,e){const n=this.cache,i=t.length,s=ui(e,i);oe(n,s)||(l.uniform1iv(this.addr,s),me(n,s));for(let a=0;a!==i;++a)e.setTexture3D(t[a]||gd,s[a])}function tu(l,t,e){const n=this.cache,i=t.length,s=ui(e,i);oe(n,s)||(l.uniform1iv(this.addr,s),me(n,s));for(let a=0;a!==i;++a)e.setTextureCube(t[a]||Rd,s[a])}function eu(l,t,e){const n=this.cache,i=t.length,s=ui(e,i);oe(n,s)||(l.uniform1iv(this.addr,s),me(n,s));for(let a=0;a!==i;++a)e.setTexture2DArray(t[a]||Xd,s[a])}function lu(l){switch(l){case 5126:return Jh;case 35664:return kh;case 35665:return wh;case 35666:return zh;case 35674:return Hh;case 35675:return Kh;case 35676:return Bh;case 5124:case 35670:return Eh;case 35667:case 35671:return Ah;case 35668:case 35672:return Ph;case 35669:case 35673:return Qh;case 5125:return jh;case 36294:return _h;case 36295:return Dh;case 36296:return Oh;case 35678:case 36198:case 36298:case 36306:case 35682:return qh;case 35679:case 36299:case 36307:return $h;case 35680:case 36300:case 36308:case 36293:return tu;case 36289:case 36303:case 36311:case 36292:return eu}}class nu{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.type=e.type,this.setValue=vh(e.type)}}class iu{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.type=e.type,this.size=e.size,this.setValue=lu(e.type)}}class au{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,n){const i=this.seq;for(let s=0,a=i.length;s!==a;++s){const d=i[s];d.setValue(t,e[d.id],n)}}}const ja=/(\w+)(\])?(\[|\.)?/g;function Yd(l,t){l.seq.push(t),l.map[t.id]=t}function su(l,t,e){const n=l.name,i=n.length;for(ja.lastIndex=0;;){const s=ja.exec(n),a=ja.lastIndex;let d=s[1];const c=s[2]==="]",o=s[3];if(c&&(d=d|0),o===void 0||o==="["&&a+2===i){Yd(e,o===void 0?new nu(d,l,t):new iu(d,l,t));break}else{let m=e.map[d];m===void 0&&(m=new au(d),Yd(e,m)),e=m}}}class bi{constructor(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){const s=t.getActiveUniform(e,i),a=t.getUniformLocation(e,s.name);su(s,a,this)}}setValue(t,e,n,i){const s=this.map[e];s!==void 0&&s.setValue(t,n,i)}setOptional(t,e,n){const i=e[n];i!==void 0&&this.setValue(t,n,i)}static upload(t,e,n,i){for(let s=0,a=e.length;s!==a;++s){const d=e[s],c=n[d.id];c.needsUpdate!==!1&&d.setValue(t,c.value,i)}}static seqWithValue(t,e){const n=[];for(let i=0,s=t.length;i!==s;++i){const a=t[i];a.id in e&&n.push(a)}return n}}function Nd(l,t,e){const n=l.createShader(t);return l.shaderSource(n,e),l.compileShader(n),n}const du=37297;let cu=0;function ou(l,t){const e=l.split(`
`),n=[],i=Math.max(t-6,0),s=Math.min(t+6,e.length);for(let a=i;a<s;a++){const d=a+1;n.push(`${d===t?">":" "} ${d}: ${e[a]}`)}return n.join(`
`)}const fd=new xt;function mu(l){kt._getMatrix(fd,kt.workingColorSpace,l);const t=`mat3( ${fd.elements.map(e=>e.toFixed(4))} )`;switch(kt.getTransfer(l)){case En:return[t,"LinearTransferOETF"];case Pt:return[t,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",l),[t,"LinearTransferOETF"]}}function Fd(l,t,e){const n=l.getShaderParameter(t,l.COMPILE_STATUS),i=l.getShaderInfoLog(t).trim();if(n&&i==="")return"";const s=/ERROR: 0:(\d+)/.exec(i);if(s){const a=parseInt(s[1]);return e.toUpperCase()+`

`+i+`

`+ou(l.getShaderSource(t),a)}else return i}function Zu(l,t){const e=mu(t);return[`vec4 ${l}( vec4 value ) {`,`	return ${e[1]}( vec4( value.rgb * ${e[0]}, value.a ) );`,"}"].join(`
`)}function hu(l,t){let e;switch(t){case Pc:e="Linear";break;case Qc:e="Reinhard";break;case jc:e="Cineon";break;case _c:e="ACESFilmic";break;case Oc:e="AgX";break;case qc:e="Neutral";break;case Dc:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+l+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}const ri=new J;function uu(){kt.getLuminanceCoefficients(ri);const l=ri.x.toFixed(4),t=ri.y.toFixed(4),e=ri.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${l}, ${t}, ${e} );`,"	return dot( weights, rgb );","}"].join(`
`)}function bu(l){return[l.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",l.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(Ln).join(`
`)}function ru(l){const t=[];for(const e in l){const n=l[e];n!==!1&&t.push("#define "+e+" "+n)}return t.join(`
`)}function pu(l,t){const e={},n=l.getProgramParameter(t,l.ACTIVE_ATTRIBUTES);for(let i=0;i<n;i++){const s=l.getActiveAttrib(t,i),a=s.name;let d=1;s.type===l.FLOAT_MAT2&&(d=2),s.type===l.FLOAT_MAT3&&(d=3),s.type===l.FLOAT_MAT4&&(d=4),e[a]={type:s.type,location:l.getAttribLocation(t,a),locationSize:d}}return e}function Ln(l){return l!==""}function Ld(l,t){const e=t.numSpotLightShadows+t.numSpotLightMaps-t.numSpotLightShadowsWithMaps;return l.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,e).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function Md(l,t){return l.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const Gu=/^[ \t]*#include +<([\w\d./]+)>/gm;function _a(l){return l.replace(Gu,Vu)}const Wu=new Map;function Vu(l,t){let e=Ft[t];if(e===void 0){const n=Wu.get(t);if(n!==void 0)e=Ft[n],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',t,n);else throw new Error("Can not resolve #include <"+t+">")}return _a(e)}const Xu=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Ud(l){return l.replace(Xu,gu)}function gu(l,t,e,n){let i="";for(let s=parseInt(t);s<parseInt(e);s++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function Td(l){let t=`precision ${l.precision} float;
	precision ${l.precision} int;
	precision ${l.precision} sampler2D;
	precision ${l.precision} samplerCube;
	precision ${l.precision} sampler3D;
	precision ${l.precision} sampler2DArray;
	precision ${l.precision} sampler2DShadow;
	precision ${l.precision} samplerCubeShadow;
	precision ${l.precision} sampler2DArrayShadow;
	precision ${l.precision} isampler2D;
	precision ${l.precision} isampler3D;
	precision ${l.precision} isamplerCube;
	precision ${l.precision} isampler2DArray;
	precision ${l.precision} usampler2D;
	precision ${l.precision} usampler3D;
	precision ${l.precision} usamplerCube;
	precision ${l.precision} usampler2DArray;
	`;return l.precision==="highp"?t+=`
#define HIGH_PRECISION`:l.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:l.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function Ru(l){let t="SHADOWMAP_TYPE_BASIC";return l.shadowMapType===Zs?t="SHADOWMAP_TYPE_PCF":l.shadowMapType===Sc?t="SHADOWMAP_TYPE_PCF_SOFT":l.shadowMapType===Oe&&(t="SHADOWMAP_TYPE_VSM"),t}function yu(l){let t="ENVMAP_TYPE_CUBE";if(l.envMap)switch(l.envMapMode){case Hl:case Kl:t="ENVMAP_TYPE_CUBE";break;case Jn:t="ENVMAP_TYPE_CUBE_UV";break}return t}function Cu(l){let t="ENVMAP_MODE_REFLECTION";if(l.envMap)switch(l.envMapMode){case Kl:t="ENVMAP_MODE_REFRACTION";break}return t}function Su(l){let t="ENVMAP_BLENDING_NONE";if(l.envMap)switch(l.combine){case bs:t="ENVMAP_BLENDING_MULTIPLY";break;case Ec:t="ENVMAP_BLENDING_MIX";break;case Ac:t="ENVMAP_BLENDING_ADD";break}return t}function Iu(l){const t=l.envMapCubeUVHeight;if(t===null)return null;const e=Math.log2(t)-2,n=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,e),7*16)),texelHeight:n,maxMip:e}}function xu(l,t,e,n){const i=l.getContext(),s=e.defines;let a=e.vertexShader,d=e.fragmentShader;const c=Ru(e),o=yu(e),Z=Cu(e),m=Su(e),b=Iu(e),h=bu(e),p=ru(s),V=i.createProgram();let r,u,C=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(r=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,p].filter(Ln).join(`
`),r.length>0&&(r+=`
`),u=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,p].filter(Ln).join(`
`),u.length>0&&(u+=`
`)):(r=[Td(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,p,e.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",e.batching?"#define USE_BATCHING":"",e.batchingColor?"#define USE_BATCHING_COLOR":"",e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.instancingMorph?"#define USE_INSTANCING_MORPH":"",e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+Z:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.displacementMap?"#define USE_DISPLACEMENTMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaHash?"#define USE_ALPHAHASH":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.mapUv?"#define MAP_UV "+e.mapUv:"",e.alphaMapUv?"#define ALPHAMAP_UV "+e.alphaMapUv:"",e.lightMapUv?"#define LIGHTMAP_UV "+e.lightMapUv:"",e.aoMapUv?"#define AOMAP_UV "+e.aoMapUv:"",e.emissiveMapUv?"#define EMISSIVEMAP_UV "+e.emissiveMapUv:"",e.bumpMapUv?"#define BUMPMAP_UV "+e.bumpMapUv:"",e.normalMapUv?"#define NORMALMAP_UV "+e.normalMapUv:"",e.displacementMapUv?"#define DISPLACEMENTMAP_UV "+e.displacementMapUv:"",e.metalnessMapUv?"#define METALNESSMAP_UV "+e.metalnessMapUv:"",e.roughnessMapUv?"#define ROUGHNESSMAP_UV "+e.roughnessMapUv:"",e.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+e.anisotropyMapUv:"",e.clearcoatMapUv?"#define CLEARCOATMAP_UV "+e.clearcoatMapUv:"",e.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+e.clearcoatNormalMapUv:"",e.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+e.clearcoatRoughnessMapUv:"",e.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+e.iridescenceMapUv:"",e.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+e.iridescenceThicknessMapUv:"",e.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+e.sheenColorMapUv:"",e.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+e.sheenRoughnessMapUv:"",e.specularMapUv?"#define SPECULARMAP_UV "+e.specularMapUv:"",e.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+e.specularColorMapUv:"",e.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+e.specularIntensityMapUv:"",e.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+e.transmissionMapUv:"",e.thicknessMapUv?"#define THICKNESSMAP_UV "+e.thicknessMapUv:"",e.vertexTangents&&e.flatShading===!1?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphColors?"#define USE_MORPHCOLORS":"",e.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+e.morphTextureStride:"",e.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+c:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Ln).join(`
`),u=[Td(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,p,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+o:"",e.envMap?"#define "+Z:"",e.envMap?"#define "+m:"",b?"#define CUBEUV_TEXEL_WIDTH "+b.texelWidth:"",b?"#define CUBEUV_TEXEL_HEIGHT "+b.texelHeight:"",b?"#define CUBEUV_MAX_MIP "+b.maxMip+".0":"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.dispersion?"#define USE_DISPERSION":"",e.iridescence?"#define USE_IRIDESCENCE":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.alphaHash?"#define USE_ALPHAHASH":"",e.sheen?"#define USE_SHEEN":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents&&e.flatShading===!1?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor||e.batchingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+c:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",e.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",e.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==hl?"#define TONE_MAPPING":"",e.toneMapping!==hl?Ft.tonemapping_pars_fragment:"",e.toneMapping!==hl?hu("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.opaque?"#define OPAQUE":"",Ft.colorspace_pars_fragment,Zu("linearToOutputTexel",e.outputColorSpace),uu(),e.useDepthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Ln).join(`
`)),a=_a(a),a=Ld(a,e),a=Md(a,e),d=_a(d),d=Ld(d,e),d=Md(d,e),a=Ud(a),d=Ud(d),e.isRawShaderMaterial!==!0&&(C=`#version 300 es
`,r=[h,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+r,u=["#define varying in",e.glslVersion===Ns?"":"layout(location = 0) out highp vec4 pc_fragColor;",e.glslVersion===Ns?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+u);const y=C+r+a,G=C+u+d,N=Nd(i,i.VERTEX_SHADER,y),I=Nd(i,i.FRAGMENT_SHADER,G);i.attachShader(V,N),i.attachShader(V,I),e.index0AttributeName!==void 0?i.bindAttribLocation(V,0,e.index0AttributeName):e.morphTargets===!0&&i.bindAttribLocation(V,0,"position"),i.linkProgram(V);function x(Y){if(l.debug.checkShaderErrors){const P=i.getProgramInfoLog(V).trim(),w=i.getShaderInfoLog(N).trim(),E=i.getShaderInfoLog(I).trim();let D=!0,K=!0;if(i.getProgramParameter(V,i.LINK_STATUS)===!1)if(D=!1,typeof l.debug.onShaderError=="function")l.debug.onShaderError(i,V,N,I);else{const $=Fd(i,N,"vertex"),H=Fd(i,I,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(V,i.VALIDATE_STATUS)+`

Material Name: `+Y.name+`
Material Type: `+Y.type+`

Program Info Log: `+P+`
`+$+`
`+H)}else P!==""?console.warn("THREE.WebGLProgram: Program Info Log:",P):(w===""||E==="")&&(K=!1);K&&(Y.diagnostics={runnable:D,programLog:P,vertexShader:{log:w,prefix:r},fragmentShader:{log:E,prefix:u}})}i.deleteShader(N),i.deleteShader(I),U=new bi(i,V),R=pu(i,V)}let U;this.getUniforms=function(){return U===void 0&&x(this),U};let R;this.getAttributes=function(){return R===void 0&&x(this),R};let g=e.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return g===!1&&(g=i.getProgramParameter(V,du)),g},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(V),this.program=void 0},this.type=e.shaderType,this.name=e.shaderName,this.id=cu++,this.cacheKey=t,this.usedTimes=1,this.program=V,this.vertexShader=N,this.fragmentShader=I,this}let Yu=0;class Nu{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,n=t.fragmentShader,i=this._getShaderStage(e),s=this._getShaderStage(n),a=this._getShaderCacheForMaterial(t);return a.has(i)===!1&&(a.add(i),i.usedTimes++),a.has(s)===!1&&(a.add(s),s.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const n of e)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;let n=e.get(t);return n===void 0&&(n=new Set,e.set(t,n)),n}_getShaderStage(t){const e=this.shaderCache;let n=e.get(t);return n===void 0&&(n=new fu(t),e.set(t,n)),n}}class fu{constructor(t){this.id=Yu++,this.code=t,this.usedTimes=0}}function Fu(l,t,e,n,i,s,a){const d=new Es,c=new Nu,o=new Set,Z=[],m=i.logarithmicDepthBuffer,b=i.vertexTextures;let h=i.precision;const p={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function V(R){return o.add(R),R===0?"uv":`uv${R}`}function r(R,g,Y,P,w){const E=P.fog,D=w.geometry,K=R.isMeshStandardMaterial?P.environment:null,$=(R.isMeshStandardMaterial?e:t).get(R.envMap||K),H=$&&$.mapping===Jn?$.image.height:null,nt=p[R.type];R.precision!==null&&(h=i.getMaxPrecision(R.precision),h!==R.precision&&console.warn("THREE.WebGLProgram.getParameters:",R.precision,"not supported, using",h,"instead."));const ot=D.morphAttributes.position||D.morphAttributes.normal||D.morphAttributes.color,Vt=ot!==void 0?ot.length:0;let Mt=0;D.morphAttributes.position!==void 0&&(Mt=1),D.morphAttributes.normal!==void 0&&(Mt=2),D.morphAttributes.color!==void 0&&(Mt=3);let Qt,A,tt,pt;if(nt){const At=je[nt];Qt=At.vertexShader,A=At.fragmentShader}else Qt=R.vertexShader,A=R.fragmentShader,c.update(R),tt=c.getVertexShaderID(R),pt=c.getFragmentShaderID(R);const it=l.getRenderTarget(),yt=l.state.buffers.depth.getReversed(),It=w.isInstancedMesh===!0,Ut=w.isBatchedMesh===!0,le=!!R.map,wt=!!R.matcap,se=!!$,M=!!R.aoMap,Te=!!R.lightMap,Tt=!!R.bumpMap,vt=!!R.normalMap,gt=!!R.displacementMap,Ot=!!R.emissiveMap,Xt=!!R.metalnessMap,S=!!R.roughnessMap,W=R.anisotropy>0,T=R.clearcoat>0,Q=R.dispersion>0,_=R.iridescence>0,B=R.sheen>0,Gt=R.transmission>0,at=W&&!!R.anisotropyMap,mt=T&&!!R.clearcoatMap,zt=T&&!!R.clearcoatNormalMap,O=T&&!!R.clearcoatRoughnessMap,Zt=_&&!!R.iridescenceMap,Rt=_&&!!R.iridescenceThicknessMap,Ct=B&&!!R.sheenColorMap,ht=B&&!!R.sheenRoughnessMap,Jt=!!R.specularMap,Lt=!!R.specularColorMap,_t=!!R.specularIntensityMap,f=Gt&&!!R.transmissionMap,lt=Gt&&!!R.thicknessMap,z=!!R.gradientMap,j=!!R.alphaMap,ct=R.alphaTest>0,st=!!R.alphaHash,Yt=!!R.extensions;let ne=hl;R.toneMapped&&(it===null||it.isXRRenderTarget===!0)&&(ne=l.toneMapping);const We={shaderID:nt,shaderType:R.type,shaderName:R.name,vertexShader:Qt,fragmentShader:A,defines:R.defines,customVertexShaderID:tt,customFragmentShaderID:pt,isRawShaderMaterial:R.isRawShaderMaterial===!0,glslVersion:R.glslVersion,precision:h,batching:Ut,batchingColor:Ut&&w._colorsTexture!==null,instancing:It,instancingColor:It&&w.instanceColor!==null,instancingMorph:It&&w.morphTexture!==null,supportsVertexTextures:b,outputColorSpace:it===null?l.outputColorSpace:it.isXRRenderTarget===!0?it.texture.colorSpace:Pl,alphaToCoverage:!!R.alphaToCoverage,map:le,matcap:wt,envMap:se,envMapMode:se&&$.mapping,envMapCubeUVHeight:H,aoMap:M,lightMap:Te,bumpMap:Tt,normalMap:vt,displacementMap:b&&gt,emissiveMap:Ot,normalMapObjectSpace:vt&&R.normalMapType===no,normalMapTangentSpace:vt&&R.normalMapType===lo,metalnessMap:Xt,roughnessMap:S,anisotropy:W,anisotropyMap:at,clearcoat:T,clearcoatMap:mt,clearcoatNormalMap:zt,clearcoatRoughnessMap:O,dispersion:Q,iridescence:_,iridescenceMap:Zt,iridescenceThicknessMap:Rt,sheen:B,sheenColorMap:Ct,sheenRoughnessMap:ht,specularMap:Jt,specularColorMap:Lt,specularIntensityMap:_t,transmission:Gt,transmissionMap:f,thicknessMap:lt,gradientMap:z,opaque:R.transparent===!1&&R.blending===Pe&&R.alphaToCoverage===!1,alphaMap:j,alphaTest:ct,alphaHash:st,combine:R.combine,mapUv:le&&V(R.map.channel),aoMapUv:M&&V(R.aoMap.channel),lightMapUv:Te&&V(R.lightMap.channel),bumpMapUv:Tt&&V(R.bumpMap.channel),normalMapUv:vt&&V(R.normalMap.channel),displacementMapUv:gt&&V(R.displacementMap.channel),emissiveMapUv:Ot&&V(R.emissiveMap.channel),metalnessMapUv:Xt&&V(R.metalnessMap.channel),roughnessMapUv:S&&V(R.roughnessMap.channel),anisotropyMapUv:at&&V(R.anisotropyMap.channel),clearcoatMapUv:mt&&V(R.clearcoatMap.channel),clearcoatNormalMapUv:zt&&V(R.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:O&&V(R.clearcoatRoughnessMap.channel),iridescenceMapUv:Zt&&V(R.iridescenceMap.channel),iridescenceThicknessMapUv:Rt&&V(R.iridescenceThicknessMap.channel),sheenColorMapUv:Ct&&V(R.sheenColorMap.channel),sheenRoughnessMapUv:ht&&V(R.sheenRoughnessMap.channel),specularMapUv:Jt&&V(R.specularMap.channel),specularColorMapUv:Lt&&V(R.specularColorMap.channel),specularIntensityMapUv:_t&&V(R.specularIntensityMap.channel),transmissionMapUv:f&&V(R.transmissionMap.channel),thicknessMapUv:lt&&V(R.thicknessMap.channel),alphaMapUv:j&&V(R.alphaMap.channel),vertexTangents:!!D.attributes.tangent&&(vt||W),vertexColors:R.vertexColors,vertexAlphas:R.vertexColors===!0&&!!D.attributes.color&&D.attributes.color.itemSize===4,pointsUvs:w.isPoints===!0&&!!D.attributes.uv&&(le||j),fog:!!E,useFog:R.fog===!0,fogExp2:!!E&&E.isFogExp2,flatShading:R.flatShading===!0,sizeAttenuation:R.sizeAttenuation===!0,logarithmicDepthBuffer:m,reverseDepthBuffer:yt,skinning:w.isSkinnedMesh===!0,morphTargets:D.morphAttributes.position!==void 0,morphNormals:D.morphAttributes.normal!==void 0,morphColors:D.morphAttributes.color!==void 0,morphTargetsCount:Vt,morphTextureStride:Mt,numDirLights:g.directional.length,numPointLights:g.point.length,numSpotLights:g.spot.length,numSpotLightMaps:g.spotLightMap.length,numRectAreaLights:g.rectArea.length,numHemiLights:g.hemi.length,numDirLightShadows:g.directionalShadowMap.length,numPointLightShadows:g.pointShadowMap.length,numSpotLightShadows:g.spotShadowMap.length,numSpotLightShadowsWithMaps:g.numSpotLightShadowsWithMaps,numLightProbes:g.numLightProbes,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:R.dithering,shadowMapEnabled:l.shadowMap.enabled&&Y.length>0,shadowMapType:l.shadowMap.type,toneMapping:ne,decodeVideoTexture:le&&R.map.isVideoTexture===!0&&kt.getTransfer(R.map.colorSpace)===Pt,decodeVideoTextureEmissive:Ot&&R.emissiveMap.isVideoTexture===!0&&kt.getTransfer(R.emissiveMap.colorSpace)===Pt,premultipliedAlpha:R.premultipliedAlpha,doubleSided:R.side===qe,flipSided:R.side===ye,useDepthPacking:R.depthPacking>=0,depthPacking:R.depthPacking||0,index0AttributeName:R.index0AttributeName,extensionClipCullDistance:Yt&&R.extensions.clipCullDistance===!0&&n.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(Yt&&R.extensions.multiDraw===!0||Ut)&&n.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:n.has("KHR_parallel_shader_compile"),customProgramCacheKey:R.customProgramCacheKey()};return We.vertexUv1s=o.has(1),We.vertexUv2s=o.has(2),We.vertexUv3s=o.has(3),o.clear(),We}function u(R){const g=[];if(R.shaderID?g.push(R.shaderID):(g.push(R.customVertexShaderID),g.push(R.customFragmentShaderID)),R.defines!==void 0)for(const Y in R.defines)g.push(Y),g.push(R.defines[Y]);return R.isRawShaderMaterial===!1&&(C(g,R),y(g,R),g.push(l.outputColorSpace)),g.push(R.customProgramCacheKey),g.join()}function C(R,g){R.push(g.precision),R.push(g.outputColorSpace),R.push(g.envMapMode),R.push(g.envMapCubeUVHeight),R.push(g.mapUv),R.push(g.alphaMapUv),R.push(g.lightMapUv),R.push(g.aoMapUv),R.push(g.bumpMapUv),R.push(g.normalMapUv),R.push(g.displacementMapUv),R.push(g.emissiveMapUv),R.push(g.metalnessMapUv),R.push(g.roughnessMapUv),R.push(g.anisotropyMapUv),R.push(g.clearcoatMapUv),R.push(g.clearcoatNormalMapUv),R.push(g.clearcoatRoughnessMapUv),R.push(g.iridescenceMapUv),R.push(g.iridescenceThicknessMapUv),R.push(g.sheenColorMapUv),R.push(g.sheenRoughnessMapUv),R.push(g.specularMapUv),R.push(g.specularColorMapUv),R.push(g.specularIntensityMapUv),R.push(g.transmissionMapUv),R.push(g.thicknessMapUv),R.push(g.combine),R.push(g.fogExp2),R.push(g.sizeAttenuation),R.push(g.morphTargetsCount),R.push(g.morphAttributeCount),R.push(g.numDirLights),R.push(g.numPointLights),R.push(g.numSpotLights),R.push(g.numSpotLightMaps),R.push(g.numHemiLights),R.push(g.numRectAreaLights),R.push(g.numDirLightShadows),R.push(g.numPointLightShadows),R.push(g.numSpotLightShadows),R.push(g.numSpotLightShadowsWithMaps),R.push(g.numLightProbes),R.push(g.shadowMapType),R.push(g.toneMapping),R.push(g.numClippingPlanes),R.push(g.numClipIntersection),R.push(g.depthPacking)}function y(R,g){d.disableAll(),g.supportsVertexTextures&&d.enable(0),g.instancing&&d.enable(1),g.instancingColor&&d.enable(2),g.instancingMorph&&d.enable(3),g.matcap&&d.enable(4),g.envMap&&d.enable(5),g.normalMapObjectSpace&&d.enable(6),g.normalMapTangentSpace&&d.enable(7),g.clearcoat&&d.enable(8),g.iridescence&&d.enable(9),g.alphaTest&&d.enable(10),g.vertexColors&&d.enable(11),g.vertexAlphas&&d.enable(12),g.vertexUv1s&&d.enable(13),g.vertexUv2s&&d.enable(14),g.vertexUv3s&&d.enable(15),g.vertexTangents&&d.enable(16),g.anisotropy&&d.enable(17),g.alphaHash&&d.enable(18),g.batching&&d.enable(19),g.dispersion&&d.enable(20),g.batchingColor&&d.enable(21),R.push(d.mask),d.disableAll(),g.fog&&d.enable(0),g.useFog&&d.enable(1),g.flatShading&&d.enable(2),g.logarithmicDepthBuffer&&d.enable(3),g.reverseDepthBuffer&&d.enable(4),g.skinning&&d.enable(5),g.morphTargets&&d.enable(6),g.morphNormals&&d.enable(7),g.morphColors&&d.enable(8),g.premultipliedAlpha&&d.enable(9),g.shadowMapEnabled&&d.enable(10),g.doubleSided&&d.enable(11),g.flipSided&&d.enable(12),g.useDepthPacking&&d.enable(13),g.dithering&&d.enable(14),g.transmission&&d.enable(15),g.sheen&&d.enable(16),g.opaque&&d.enable(17),g.pointsUvs&&d.enable(18),g.decodeVideoTexture&&d.enable(19),g.decodeVideoTextureEmissive&&d.enable(20),g.alphaToCoverage&&d.enable(21),R.push(d.mask)}function G(R){const g=p[R.type];let Y;if(g){const P=je[g];Y=jo.clone(P.uniforms)}else Y=R.uniforms;return Y}function N(R,g){let Y;for(let P=0,w=Z.length;P<w;P++){const E=Z[P];if(E.cacheKey===g){Y=E,++Y.usedTimes;break}}return Y===void 0&&(Y=new xu(l,g,R,s),Z.push(Y)),Y}function I(R){if(--R.usedTimes===0){const g=Z.indexOf(R);Z[g]=Z[Z.length-1],Z.pop(),R.destroy()}}function x(R){c.remove(R)}function U(){c.dispose()}return{getParameters:r,getProgramCacheKey:u,getUniforms:G,acquireProgram:N,releaseProgram:I,releaseShaderCache:x,programs:Z,dispose:U}}function Lu(){let l=new WeakMap;function t(a){return l.has(a)}function e(a){let d=l.get(a);return d===void 0&&(d={},l.set(a,d)),d}function n(a){l.delete(a)}function i(a,d,c){l.get(a)[d]=c}function s(){l=new WeakMap}return{has:t,get:e,remove:n,update:i,dispose:s}}function Mu(l,t){return l.groupOrder!==t.groupOrder?l.groupOrder-t.groupOrder:l.renderOrder!==t.renderOrder?l.renderOrder-t.renderOrder:l.material.id!==t.material.id?l.material.id-t.material.id:l.z!==t.z?l.z-t.z:l.id-t.id}function vd(l,t){return l.groupOrder!==t.groupOrder?l.groupOrder-t.groupOrder:l.renderOrder!==t.renderOrder?l.renderOrder-t.renderOrder:l.z!==t.z?t.z-l.z:l.id-t.id}function Jd(){const l=[];let t=0;const e=[],n=[],i=[];function s(){t=0,e.length=0,n.length=0,i.length=0}function a(m,b,h,p,V,r){let u=l[t];return u===void 0?(u={id:m.id,object:m,geometry:b,material:h,groupOrder:p,renderOrder:m.renderOrder,z:V,group:r},l[t]=u):(u.id=m.id,u.object=m,u.geometry=b,u.material=h,u.groupOrder=p,u.renderOrder=m.renderOrder,u.z=V,u.group=r),t++,u}function d(m,b,h,p,V,r){const u=a(m,b,h,p,V,r);h.transmission>0?n.push(u):h.transparent===!0?i.push(u):e.push(u)}function c(m,b,h,p,V,r){const u=a(m,b,h,p,V,r);h.transmission>0?n.unshift(u):h.transparent===!0?i.unshift(u):e.unshift(u)}function o(m,b){e.length>1&&e.sort(m||Mu),n.length>1&&n.sort(b||vd),i.length>1&&i.sort(b||vd)}function Z(){for(let m=t,b=l.length;m<b;m++){const h=l[m];if(h.id===null)break;h.id=null,h.object=null,h.geometry=null,h.material=null,h.group=null}}return{opaque:e,transmissive:n,transparent:i,init:s,push:d,unshift:c,finish:Z,sort:o}}function Uu(){let l=new WeakMap;function t(n,i){const s=l.get(n);let a;return s===void 0?(a=new Jd,l.set(n,[a])):i>=s.length?(a=new Jd,s.push(a)):a=s[i],a}function e(){l=new WeakMap}return{get:t,dispose:e}}function Tu(){const l={};return{get:function(t){if(l[t.id]!==void 0)return l[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new J,color:new Kt};break;case"SpotLight":e={position:new J,direction:new J,color:new Kt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new J,color:new Kt,distance:0,decay:0};break;case"HemisphereLight":e={direction:new J,skyColor:new Kt,groundColor:new Kt};break;case"RectAreaLight":e={color:new Kt,position:new J,halfWidth:new J,halfHeight:new J};break}return l[t.id]=e,e}}}function vu(){const l={};return{get:function(t){if(l[t.id]!==void 0)return l[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ft};break;case"SpotLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ft};break;case"PointLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ft,shadowCameraNear:1,shadowCameraFar:1e3};break}return l[t.id]=e,e}}}let Ju=0;function ku(l,t){return(t.castShadow?2:0)-(l.castShadow?2:0)+(t.map?1:0)-(l.map?1:0)}function wu(l){const t=new Tu,e=vu(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let o=0;o<9;o++)n.probe.push(new J);const i=new J,s=new ae,a=new ae;function d(o){let Z=0,m=0,b=0;for(let R=0;R<9;R++)n.probe[R].set(0,0,0);let h=0,p=0,V=0,r=0,u=0,C=0,y=0,G=0,N=0,I=0,x=0;o.sort(ku);for(let R=0,g=o.length;R<g;R++){const Y=o[R],P=Y.color,w=Y.intensity,E=Y.distance,D=Y.shadow&&Y.shadow.map?Y.shadow.map.texture:null;if(Y.isAmbientLight)Z+=P.r*w,m+=P.g*w,b+=P.b*w;else if(Y.isLightProbe){for(let K=0;K<9;K++)n.probe[K].addScaledVector(Y.sh.coefficients[K],w);x++}else if(Y.isDirectionalLight){const K=t.get(Y);if(K.color.copy(Y.color).multiplyScalar(Y.intensity),Y.castShadow){const $=Y.shadow,H=e.get(Y);H.shadowIntensity=$.intensity,H.shadowBias=$.bias,H.shadowNormalBias=$.normalBias,H.shadowRadius=$.radius,H.shadowMapSize=$.mapSize,n.directionalShadow[h]=H,n.directionalShadowMap[h]=D,n.directionalShadowMatrix[h]=Y.shadow.matrix,C++}n.directional[h]=K,h++}else if(Y.isSpotLight){const K=t.get(Y);K.position.setFromMatrixPosition(Y.matrixWorld),K.color.copy(P).multiplyScalar(w),K.distance=E,K.coneCos=Math.cos(Y.angle),K.penumbraCos=Math.cos(Y.angle*(1-Y.penumbra)),K.decay=Y.decay,n.spot[V]=K;const $=Y.shadow;if(Y.map&&(n.spotLightMap[N]=Y.map,N++,$.updateMatrices(Y),Y.castShadow&&I++),n.spotLightMatrix[V]=$.matrix,Y.castShadow){const H=e.get(Y);H.shadowIntensity=$.intensity,H.shadowBias=$.bias,H.shadowNormalBias=$.normalBias,H.shadowRadius=$.radius,H.shadowMapSize=$.mapSize,n.spotShadow[V]=H,n.spotShadowMap[V]=D,G++}V++}else if(Y.isRectAreaLight){const K=t.get(Y);K.color.copy(P).multiplyScalar(w),K.halfWidth.set(Y.width*.5,0,0),K.halfHeight.set(0,Y.height*.5,0),n.rectArea[r]=K,r++}else if(Y.isPointLight){const K=t.get(Y);if(K.color.copy(Y.color).multiplyScalar(Y.intensity),K.distance=Y.distance,K.decay=Y.decay,Y.castShadow){const $=Y.shadow,H=e.get(Y);H.shadowIntensity=$.intensity,H.shadowBias=$.bias,H.shadowNormalBias=$.normalBias,H.shadowRadius=$.radius,H.shadowMapSize=$.mapSize,H.shadowCameraNear=$.camera.near,H.shadowCameraFar=$.camera.far,n.pointShadow[p]=H,n.pointShadowMap[p]=D,n.pointShadowMatrix[p]=Y.shadow.matrix,y++}n.point[p]=K,p++}else if(Y.isHemisphereLight){const K=t.get(Y);K.skyColor.copy(Y.color).multiplyScalar(w),K.groundColor.copy(Y.groundColor).multiplyScalar(w),n.hemi[u]=K,u++}}r>0&&(l.has("OES_texture_float_linear")===!0?(n.rectAreaLTC1=et.LTC_FLOAT_1,n.rectAreaLTC2=et.LTC_FLOAT_2):(n.rectAreaLTC1=et.LTC_HALF_1,n.rectAreaLTC2=et.LTC_HALF_2)),n.ambient[0]=Z,n.ambient[1]=m,n.ambient[2]=b;const U=n.hash;(U.directionalLength!==h||U.pointLength!==p||U.spotLength!==V||U.rectAreaLength!==r||U.hemiLength!==u||U.numDirectionalShadows!==C||U.numPointShadows!==y||U.numSpotShadows!==G||U.numSpotMaps!==N||U.numLightProbes!==x)&&(n.directional.length=h,n.spot.length=V,n.rectArea.length=r,n.point.length=p,n.hemi.length=u,n.directionalShadow.length=C,n.directionalShadowMap.length=C,n.pointShadow.length=y,n.pointShadowMap.length=y,n.spotShadow.length=G,n.spotShadowMap.length=G,n.directionalShadowMatrix.length=C,n.pointShadowMatrix.length=y,n.spotLightMatrix.length=G+N-I,n.spotLightMap.length=N,n.numSpotLightShadowsWithMaps=I,n.numLightProbes=x,U.directionalLength=h,U.pointLength=p,U.spotLength=V,U.rectAreaLength=r,U.hemiLength=u,U.numDirectionalShadows=C,U.numPointShadows=y,U.numSpotShadows=G,U.numSpotMaps=N,U.numLightProbes=x,n.version=Ju++)}function c(o,Z){let m=0,b=0,h=0,p=0,V=0;const r=Z.matrixWorldInverse;for(let u=0,C=o.length;u<C;u++){const y=o[u];if(y.isDirectionalLight){const G=n.directional[m];G.direction.setFromMatrixPosition(y.matrixWorld),i.setFromMatrixPosition(y.target.matrixWorld),G.direction.sub(i),G.direction.transformDirection(r),m++}else if(y.isSpotLight){const G=n.spot[h];G.position.setFromMatrixPosition(y.matrixWorld),G.position.applyMatrix4(r),G.direction.setFromMatrixPosition(y.matrixWorld),i.setFromMatrixPosition(y.target.matrixWorld),G.direction.sub(i),G.direction.transformDirection(r),h++}else if(y.isRectAreaLight){const G=n.rectArea[p];G.position.setFromMatrixPosition(y.matrixWorld),G.position.applyMatrix4(r),a.identity(),s.copy(y.matrixWorld),s.premultiply(r),a.extractRotation(s),G.halfWidth.set(y.width*.5,0,0),G.halfHeight.set(0,y.height*.5,0),G.halfWidth.applyMatrix4(a),G.halfHeight.applyMatrix4(a),p++}else if(y.isPointLight){const G=n.point[b];G.position.setFromMatrixPosition(y.matrixWorld),G.position.applyMatrix4(r),b++}else if(y.isHemisphereLight){const G=n.hemi[V];G.direction.setFromMatrixPosition(y.matrixWorld),G.direction.transformDirection(r),V++}}}return{setup:d,setupView:c,state:n}}function kd(l){const t=new wu(l),e=[],n=[];function i(Z){o.camera=Z,e.length=0,n.length=0}function s(Z){e.push(Z)}function a(Z){n.push(Z)}function d(){t.setup(e)}function c(Z){t.setupView(e,Z)}const o={lightsArray:e,shadowsArray:n,camera:null,lights:t,transmissionRenderTarget:{}};return{init:i,state:o,setupLights:d,setupLightsView:c,pushLight:s,pushShadow:a}}function zu(l){let t=new WeakMap;function e(i,s=0){const a=t.get(i);let d;return a===void 0?(d=new kd(l),t.set(i,[d])):s>=a.length?(d=new kd(l),a.push(d)):d=a[s],d}function n(){t=new WeakMap}return{get:e,dispose:n}}class Hu extends Yn{static get type(){return"MeshDepthMaterial"}constructor(t){super(),this.isMeshDepthMaterial=!0,this.depthPacking=to,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class Ku extends Yn{static get type(){return"MeshDistanceMaterial"}constructor(t){super(),this.isMeshDistanceMaterial=!0,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}const Bu=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,Eu=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function Au(l,t,e){let n=new cd;const i=new ft,s=new ft,a=new ie,d=new Hu({depthPacking:eo}),c=new Ku,o={},Z=e.maxTextureSize,m={[ml]:ye,[ye]:ml,[qe]:qe},b=new ce({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new ft},radius:{value:4}},vertexShader:Bu,fragmentShader:Eu}),h=b.clone();h.defines.HORIZONTAL_PASS=1;const p=new Ue;p.setAttribute("position",new Se(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const V=new ee(p,b),r=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Zs;let u=this.type;this.render=function(I,x,U){if(r.enabled===!1||r.autoUpdate===!1&&r.needsUpdate===!1||I.length===0)return;const R=l.getRenderTarget(),g=l.getActiveCubeFace(),Y=l.getActiveMipmapLevel(),P=l.state;P.setBlending(Zl),P.buffers.color.setClear(1,1,1,1),P.buffers.depth.setTest(!0),P.setScissorTest(!1);const w=u!==Oe&&this.type===Oe,E=u===Oe&&this.type!==Oe;for(let D=0,K=I.length;D<K;D++){const $=I[D],H=$.shadow;if(H===void 0){console.warn("THREE.WebGLShadowMap:",$,"has no shadow.");continue}if(H.autoUpdate===!1&&H.needsUpdate===!1)continue;i.copy(H.mapSize);const nt=H.getFrameExtents();if(i.multiply(nt),s.copy(H.mapSize),(i.x>Z||i.y>Z)&&(i.x>Z&&(s.x=Math.floor(Z/nt.x),i.x=s.x*nt.x,H.mapSize.x=s.x),i.y>Z&&(s.y=Math.floor(Z/nt.y),i.y=s.y*nt.y,H.mapSize.y=s.y)),H.map===null||w===!0||E===!0){const Vt=this.type!==Oe?{minFilter:Je,magFilter:Je}:{};H.map!==null&&H.map.dispose(),H.map=new bl(i.x,i.y,Vt),H.map.texture.name=$.name+".shadowMap",H.camera.updateProjectionMatrix()}l.setRenderTarget(H.map),l.clear();const ot=H.getViewportCount();for(let Vt=0;Vt<ot;Vt++){const Mt=H.getViewport(Vt);a.set(s.x*Mt.x,s.y*Mt.y,s.x*Mt.z,s.y*Mt.w),P.viewport(a),H.updateMatrices($,Vt),n=H.getFrustum(),G(x,U,H.camera,$,this.type)}H.isPointLightShadow!==!0&&this.type===Oe&&C(H,U),H.needsUpdate=!1}u=this.type,r.needsUpdate=!1,l.setRenderTarget(R,g,Y)};function C(I,x){const U=t.update(V);b.defines.VSM_SAMPLES!==I.blurSamples&&(b.defines.VSM_SAMPLES=I.blurSamples,h.defines.VSM_SAMPLES=I.blurSamples,b.needsUpdate=!0,h.needsUpdate=!0),I.mapPass===null&&(I.mapPass=new bl(i.x,i.y)),b.uniforms.shadow_pass.value=I.map.texture,b.uniforms.resolution.value=I.mapSize,b.uniforms.radius.value=I.radius,l.setRenderTarget(I.mapPass),l.clear(),l.renderBufferDirect(x,null,U,b,V,null),h.uniforms.shadow_pass.value=I.mapPass.texture,h.uniforms.resolution.value=I.mapSize,h.uniforms.radius.value=I.radius,l.setRenderTarget(I.map),l.clear(),l.renderBufferDirect(x,null,U,h,V,null)}function y(I,x,U,R){let g=null;const Y=U.isPointLight===!0?I.customDistanceMaterial:I.customDepthMaterial;if(Y!==void 0)g=Y;else if(g=U.isPointLight===!0?c:d,l.localClippingEnabled&&x.clipShadows===!0&&Array.isArray(x.clippingPlanes)&&x.clippingPlanes.length!==0||x.displacementMap&&x.displacementScale!==0||x.alphaMap&&x.alphaTest>0||x.map&&x.alphaTest>0){const P=g.uuid,w=x.uuid;let E=o[P];E===void 0&&(E={},o[P]=E);let D=E[w];D===void 0&&(D=g.clone(),E[w]=D,x.addEventListener("dispose",N)),g=D}if(g.visible=x.visible,g.wireframe=x.wireframe,R===Oe?g.side=x.shadowSide!==null?x.shadowSide:x.side:g.side=x.shadowSide!==null?x.shadowSide:m[x.side],g.alphaMap=x.alphaMap,g.alphaTest=x.alphaTest,g.map=x.map,g.clipShadows=x.clipShadows,g.clippingPlanes=x.clippingPlanes,g.clipIntersection=x.clipIntersection,g.displacementMap=x.displacementMap,g.displacementScale=x.displacementScale,g.displacementBias=x.displacementBias,g.wireframeLinewidth=x.wireframeLinewidth,g.linewidth=x.linewidth,U.isPointLight===!0&&g.isMeshDistanceMaterial===!0){const P=l.properties.get(g);P.light=U}return g}function G(I,x,U,R,g){if(I.visible===!1)return;if(I.layers.test(x.layers)&&(I.isMesh||I.isLine||I.isPoints)&&(I.castShadow||I.receiveShadow&&g===Oe)&&(!I.frustumCulled||n.intersectsObject(I))){I.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse,I.matrixWorld);const w=t.update(I),E=I.material;if(Array.isArray(E)){const D=w.groups;for(let K=0,$=D.length;K<$;K++){const H=D[K],nt=E[H.materialIndex];if(nt&&nt.visible){const ot=y(I,nt,R,g);I.onBeforeShadow(l,I,x,U,w,ot,H),l.renderBufferDirect(U,null,w,ot,I,H),I.onAfterShadow(l,I,x,U,w,ot,H)}}}else if(E.visible){const D=y(I,E,R,g);I.onBeforeShadow(l,I,x,U,w,D,null),l.renderBufferDirect(U,null,w,D,I,null),I.onAfterShadow(l,I,x,U,w,D,null)}}const P=I.children;for(let w=0,E=P.length;w<E;w++)G(P[w],x,U,R,g)}function N(I){I.target.removeEventListener("dispose",N);for(const U in o){const R=o[U],g=I.target.uuid;g in R&&(R[g].dispose(),delete R[g])}}}const Pu={[fi]:Fi,[Li]:Ti,[Mi]:vi,[zl]:Ui,[Fi]:fi,[Ti]:Li,[vi]:Mi,[Ui]:zl};function Qu(l,t){function e(){let f=!1;const lt=new ie;let z=null;const j=new ie(0,0,0,0);return{setMask:function(ct){z!==ct&&!f&&(l.colorMask(ct,ct,ct,ct),z=ct)},setLocked:function(ct){f=ct},setClear:function(ct,st,Yt,ne,We){We===!0&&(ct*=ne,st*=ne,Yt*=ne),lt.set(ct,st,Yt,ne),j.equals(lt)===!1&&(l.clearColor(ct,st,Yt,ne),j.copy(lt))},reset:function(){f=!1,z=null,j.set(-1,0,0,0)}}}function n(){let f=!1,lt=!1,z=null,j=null,ct=null;return{setReversed:function(st){if(lt!==st){const Yt=t.get("EXT_clip_control");lt?Yt.clipControlEXT(Yt.LOWER_LEFT_EXT,Yt.ZERO_TO_ONE_EXT):Yt.clipControlEXT(Yt.LOWER_LEFT_EXT,Yt.NEGATIVE_ONE_TO_ONE_EXT);const ne=ct;ct=null,this.setClear(ne)}lt=st},getReversed:function(){return lt},setTest:function(st){st?it(l.DEPTH_TEST):yt(l.DEPTH_TEST)},setMask:function(st){z!==st&&!f&&(l.depthMask(st),z=st)},setFunc:function(st){if(lt&&(st=Pu[st]),j!==st){switch(st){case fi:l.depthFunc(l.NEVER);break;case Fi:l.depthFunc(l.ALWAYS);break;case Li:l.depthFunc(l.LESS);break;case zl:l.depthFunc(l.LEQUAL);break;case Mi:l.depthFunc(l.EQUAL);break;case Ui:l.depthFunc(l.GEQUAL);break;case Ti:l.depthFunc(l.GREATER);break;case vi:l.depthFunc(l.NOTEQUAL);break;default:l.depthFunc(l.LEQUAL)}j=st}},setLocked:function(st){f=st},setClear:function(st){ct!==st&&(lt&&(st=1-st),l.clearDepth(st),ct=st)},reset:function(){f=!1,z=null,j=null,ct=null,lt=!1}}}function i(){let f=!1,lt=null,z=null,j=null,ct=null,st=null,Yt=null,ne=null,We=null;return{setTest:function(At){f||(At?it(l.STENCIL_TEST):yt(l.STENCIL_TEST))},setMask:function(At){lt!==At&&!f&&(l.stencilMask(At),lt=At)},setFunc:function(At,Ee,cl){(z!==At||j!==Ee||ct!==cl)&&(l.stencilFunc(At,Ee,cl),z=At,j=Ee,ct=cl)},setOp:function(At,Ee,cl){(st!==At||Yt!==Ee||ne!==cl)&&(l.stencilOp(At,Ee,cl),st=At,Yt=Ee,ne=cl)},setLocked:function(At){f=At},setClear:function(At){We!==At&&(l.clearStencil(At),We=At)},reset:function(){f=!1,lt=null,z=null,j=null,ct=null,st=null,Yt=null,ne=null,We=null}}}const s=new e,a=new n,d=new i,c=new WeakMap,o=new WeakMap;let Z={},m={},b=new WeakMap,h=[],p=null,V=!1,r=null,u=null,C=null,y=null,G=null,N=null,I=null,x=new Kt(0,0,0),U=0,R=!1,g=null,Y=null,P=null,w=null,E=null;const D=l.getParameter(l.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let K=!1,$=0;const H=l.getParameter(l.VERSION);H.indexOf("WebGL")!==-1?($=parseFloat(/^WebGL (\d)/.exec(H)[1]),K=$>=1):H.indexOf("OpenGL ES")!==-1&&($=parseFloat(/^OpenGL ES (\d)/.exec(H)[1]),K=$>=2);let nt=null,ot={};const Vt=l.getParameter(l.SCISSOR_BOX),Mt=l.getParameter(l.VIEWPORT),Qt=new ie().fromArray(Vt),A=new ie().fromArray(Mt);function tt(f,lt,z,j){const ct=new Uint8Array(4),st=l.createTexture();l.bindTexture(f,st),l.texParameteri(f,l.TEXTURE_MIN_FILTER,l.NEAREST),l.texParameteri(f,l.TEXTURE_MAG_FILTER,l.NEAREST);for(let Yt=0;Yt<z;Yt++)f===l.TEXTURE_3D||f===l.TEXTURE_2D_ARRAY?l.texImage3D(lt,0,l.RGBA,1,1,j,0,l.RGBA,l.UNSIGNED_BYTE,ct):l.texImage2D(lt+Yt,0,l.RGBA,1,1,0,l.RGBA,l.UNSIGNED_BYTE,ct);return st}const pt={};pt[l.TEXTURE_2D]=tt(l.TEXTURE_2D,l.TEXTURE_2D,1),pt[l.TEXTURE_CUBE_MAP]=tt(l.TEXTURE_CUBE_MAP,l.TEXTURE_CUBE_MAP_POSITIVE_X,6),pt[l.TEXTURE_2D_ARRAY]=tt(l.TEXTURE_2D_ARRAY,l.TEXTURE_2D_ARRAY,1,1),pt[l.TEXTURE_3D]=tt(l.TEXTURE_3D,l.TEXTURE_3D,1,1),s.setClear(0,0,0,1),a.setClear(1),d.setClear(0),it(l.DEPTH_TEST),a.setFunc(zl),Tt(!1),vt(ms),it(l.CULL_FACE),M(Zl);function it(f){Z[f]!==!0&&(l.enable(f),Z[f]=!0)}function yt(f){Z[f]!==!1&&(l.disable(f),Z[f]=!1)}function It(f,lt){return m[f]!==lt?(l.bindFramebuffer(f,lt),m[f]=lt,f===l.DRAW_FRAMEBUFFER&&(m[l.FRAMEBUFFER]=lt),f===l.FRAMEBUFFER&&(m[l.DRAW_FRAMEBUFFER]=lt),!0):!1}function Ut(f,lt){let z=h,j=!1;if(f){z=b.get(lt),z===void 0&&(z=[],b.set(lt,z));const ct=f.textures;if(z.length!==ct.length||z[0]!==l.COLOR_ATTACHMENT0){for(let st=0,Yt=ct.length;st<Yt;st++)z[st]=l.COLOR_ATTACHMENT0+st;z.length=ct.length,j=!0}}else z[0]!==l.BACK&&(z[0]=l.BACK,j=!0);j&&l.drawBuffers(z)}function le(f){return p!==f?(l.useProgram(f),p=f,!0):!1}const wt={[Sl]:l.FUNC_ADD,[xc]:l.FUNC_SUBTRACT,[Yc]:l.FUNC_REVERSE_SUBTRACT};wt[Nc]=l.MIN,wt[fc]=l.MAX;const se={[Fc]:l.ZERO,[Lc]:l.ONE,[Mc]:l.SRC_COLOR,[Yi]:l.SRC_ALPHA,[wc]:l.SRC_ALPHA_SATURATE,[Jc]:l.DST_COLOR,[Tc]:l.DST_ALPHA,[Uc]:l.ONE_MINUS_SRC_COLOR,[Ni]:l.ONE_MINUS_SRC_ALPHA,[kc]:l.ONE_MINUS_DST_COLOR,[vc]:l.ONE_MINUS_DST_ALPHA,[zc]:l.CONSTANT_COLOR,[Hc]:l.ONE_MINUS_CONSTANT_COLOR,[Kc]:l.CONSTANT_ALPHA,[Bc]:l.ONE_MINUS_CONSTANT_ALPHA};function M(f,lt,z,j,ct,st,Yt,ne,We,At){if(f===Zl){V===!0&&(yt(l.BLEND),V=!1);return}if(V===!1&&(it(l.BLEND),V=!0),f!==Ic){if(f!==r||At!==R){if((u!==Sl||G!==Sl)&&(l.blendEquation(l.FUNC_ADD),u=Sl,G=Sl),At)switch(f){case Pe:l.blendFuncSeparate(l.ONE,l.ONE_MINUS_SRC_ALPHA,l.ONE,l.ONE_MINUS_SRC_ALPHA);break;case fe:l.blendFunc(l.ONE,l.ONE);break;case hs:l.blendFuncSeparate(l.ZERO,l.ONE_MINUS_SRC_COLOR,l.ZERO,l.ONE);break;case us:l.blendFuncSeparate(l.ZERO,l.SRC_COLOR,l.ZERO,l.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",f);break}else switch(f){case Pe:l.blendFuncSeparate(l.SRC_ALPHA,l.ONE_MINUS_SRC_ALPHA,l.ONE,l.ONE_MINUS_SRC_ALPHA);break;case fe:l.blendFunc(l.SRC_ALPHA,l.ONE);break;case hs:l.blendFuncSeparate(l.ZERO,l.ONE_MINUS_SRC_COLOR,l.ZERO,l.ONE);break;case us:l.blendFunc(l.ZERO,l.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",f);break}C=null,y=null,N=null,I=null,x.set(0,0,0),U=0,r=f,R=At}return}ct=ct||lt,st=st||z,Yt=Yt||j,(lt!==u||ct!==G)&&(l.blendEquationSeparate(wt[lt],wt[ct]),u=lt,G=ct),(z!==C||j!==y||st!==N||Yt!==I)&&(l.blendFuncSeparate(se[z],se[j],se[st],se[Yt]),C=z,y=j,N=st,I=Yt),(ne.equals(x)===!1||We!==U)&&(l.blendColor(ne.r,ne.g,ne.b,We),x.copy(ne),U=We),r=f,R=!1}function Te(f,lt){f.side===qe?yt(l.CULL_FACE):it(l.CULL_FACE);let z=f.side===ye;lt&&(z=!z),Tt(z),f.blending===Pe&&f.transparent===!1?M(Zl):M(f.blending,f.blendEquation,f.blendSrc,f.blendDst,f.blendEquationAlpha,f.blendSrcAlpha,f.blendDstAlpha,f.blendColor,f.blendAlpha,f.premultipliedAlpha),a.setFunc(f.depthFunc),a.setTest(f.depthTest),a.setMask(f.depthWrite),s.setMask(f.colorWrite);const j=f.stencilWrite;d.setTest(j),j&&(d.setMask(f.stencilWriteMask),d.setFunc(f.stencilFunc,f.stencilRef,f.stencilFuncMask),d.setOp(f.stencilFail,f.stencilZFail,f.stencilZPass)),Ot(f.polygonOffset,f.polygonOffsetFactor,f.polygonOffsetUnits),f.alphaToCoverage===!0?it(l.SAMPLE_ALPHA_TO_COVERAGE):yt(l.SAMPLE_ALPHA_TO_COVERAGE)}function Tt(f){g!==f&&(f?l.frontFace(l.CW):l.frontFace(l.CCW),g=f)}function vt(f){f!==yc?(it(l.CULL_FACE),f!==Y&&(f===ms?l.cullFace(l.BACK):f===Cc?l.cullFace(l.FRONT):l.cullFace(l.FRONT_AND_BACK))):yt(l.CULL_FACE),Y=f}function gt(f){f!==P&&(K&&l.lineWidth(f),P=f)}function Ot(f,lt,z){f?(it(l.POLYGON_OFFSET_FILL),(w!==lt||E!==z)&&(l.polygonOffset(lt,z),w=lt,E=z)):yt(l.POLYGON_OFFSET_FILL)}function Xt(f){f?it(l.SCISSOR_TEST):yt(l.SCISSOR_TEST)}function S(f){f===void 0&&(f=l.TEXTURE0+D-1),nt!==f&&(l.activeTexture(f),nt=f)}function W(f,lt,z){z===void 0&&(nt===null?z=l.TEXTURE0+D-1:z=nt);let j=ot[z];j===void 0&&(j={type:void 0,texture:void 0},ot[z]=j),(j.type!==f||j.texture!==lt)&&(nt!==z&&(l.activeTexture(z),nt=z),l.bindTexture(f,lt||pt[f]),j.type=f,j.texture=lt)}function T(){const f=ot[nt];f!==void 0&&f.type!==void 0&&(l.bindTexture(f.type,null),f.type=void 0,f.texture=void 0)}function Q(){try{l.compressedTexImage2D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function _(){try{l.compressedTexImage3D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function B(){try{l.texSubImage2D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function Gt(){try{l.texSubImage3D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function at(){try{l.compressedTexSubImage2D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function mt(){try{l.compressedTexSubImage3D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function zt(){try{l.texStorage2D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function O(){try{l.texStorage3D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function Zt(){try{l.texImage2D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function Rt(){try{l.texImage3D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function Ct(f){Qt.equals(f)===!1&&(l.scissor(f.x,f.y,f.z,f.w),Qt.copy(f))}function ht(f){A.equals(f)===!1&&(l.viewport(f.x,f.y,f.z,f.w),A.copy(f))}function Jt(f,lt){let z=o.get(lt);z===void 0&&(z=new WeakMap,o.set(lt,z));let j=z.get(f);j===void 0&&(j=l.getUniformBlockIndex(lt,f.name),z.set(f,j))}function Lt(f,lt){const j=o.get(lt).get(f);c.get(lt)!==j&&(l.uniformBlockBinding(lt,j,f.__bindingPointIndex),c.set(lt,j))}function _t(){l.disable(l.BLEND),l.disable(l.CULL_FACE),l.disable(l.DEPTH_TEST),l.disable(l.POLYGON_OFFSET_FILL),l.disable(l.SCISSOR_TEST),l.disable(l.STENCIL_TEST),l.disable(l.SAMPLE_ALPHA_TO_COVERAGE),l.blendEquation(l.FUNC_ADD),l.blendFunc(l.ONE,l.ZERO),l.blendFuncSeparate(l.ONE,l.ZERO,l.ONE,l.ZERO),l.blendColor(0,0,0,0),l.colorMask(!0,!0,!0,!0),l.clearColor(0,0,0,0),l.depthMask(!0),l.depthFunc(l.LESS),a.setReversed(!1),l.clearDepth(1),l.stencilMask(4294967295),l.stencilFunc(l.ALWAYS,0,4294967295),l.stencilOp(l.KEEP,l.KEEP,l.KEEP),l.clearStencil(0),l.cullFace(l.BACK),l.frontFace(l.CCW),l.polygonOffset(0,0),l.activeTexture(l.TEXTURE0),l.bindFramebuffer(l.FRAMEBUFFER,null),l.bindFramebuffer(l.DRAW_FRAMEBUFFER,null),l.bindFramebuffer(l.READ_FRAMEBUFFER,null),l.useProgram(null),l.lineWidth(1),l.scissor(0,0,l.canvas.width,l.canvas.height),l.viewport(0,0,l.canvas.width,l.canvas.height),Z={},nt=null,ot={},m={},b=new WeakMap,h=[],p=null,V=!1,r=null,u=null,C=null,y=null,G=null,N=null,I=null,x=new Kt(0,0,0),U=0,R=!1,g=null,Y=null,P=null,w=null,E=null,Qt.set(0,0,l.canvas.width,l.canvas.height),A.set(0,0,l.canvas.width,l.canvas.height),s.reset(),a.reset(),d.reset()}return{buffers:{color:s,depth:a,stencil:d},enable:it,disable:yt,bindFramebuffer:It,drawBuffers:Ut,useProgram:le,setBlending:M,setMaterial:Te,setFlipSided:Tt,setCullFace:vt,setLineWidth:gt,setPolygonOffset:Ot,setScissorTest:Xt,activeTexture:S,bindTexture:W,unbindTexture:T,compressedTexImage2D:Q,compressedTexImage3D:_,texImage2D:Zt,texImage3D:Rt,updateUBOMapping:Jt,uniformBlockBinding:Lt,texStorage2D:zt,texStorage3D:O,texSubImage2D:B,texSubImage3D:Gt,compressedTexSubImage2D:at,compressedTexSubImage3D:mt,scissor:Ct,viewport:ht,reset:_t}}function wd(l,t,e,n){const i=ju(n);switch(e){case Vs:return l*t;case gs:return l*t;case Rs:return l*t*2;case ys:return l*t/i.components*i.byteLength;case Ai:return l*t/i.components*i.byteLength;case Cs:return l*t*2/i.components*i.byteLength;case Pi:return l*t*2/i.components*i.byteLength;case Xs:return l*t*3/i.components*i.byteLength;case Fe:return l*t*4/i.components*i.byteLength;case Qi:return l*t*4/i.components*i.byteLength;case wn:case zn:return Math.floor((l+3)/4)*Math.floor((t+3)/4)*8;case Hn:case Kn:return Math.floor((l+3)/4)*Math.floor((t+3)/4)*16;case _i:case Oi:return Math.max(l,16)*Math.max(t,8)/4;case ji:case Di:return Math.max(l,8)*Math.max(t,8)/2;case qi:case $i:return Math.floor((l+3)/4)*Math.floor((t+3)/4)*8;case ta:return Math.floor((l+3)/4)*Math.floor((t+3)/4)*16;case ea:return Math.floor((l+3)/4)*Math.floor((t+3)/4)*16;case la:return Math.floor((l+4)/5)*Math.floor((t+3)/4)*16;case na:return Math.floor((l+4)/5)*Math.floor((t+4)/5)*16;case ia:return Math.floor((l+5)/6)*Math.floor((t+4)/5)*16;case aa:return Math.floor((l+5)/6)*Math.floor((t+5)/6)*16;case sa:return Math.floor((l+7)/8)*Math.floor((t+4)/5)*16;case da:return Math.floor((l+7)/8)*Math.floor((t+5)/6)*16;case ca:return Math.floor((l+7)/8)*Math.floor((t+7)/8)*16;case oa:return Math.floor((l+9)/10)*Math.floor((t+4)/5)*16;case ma:return Math.floor((l+9)/10)*Math.floor((t+5)/6)*16;case Za:return Math.floor((l+9)/10)*Math.floor((t+7)/8)*16;case ha:return Math.floor((l+9)/10)*Math.floor((t+9)/10)*16;case ua:return Math.floor((l+11)/12)*Math.floor((t+9)/10)*16;case ba:return Math.floor((l+11)/12)*Math.floor((t+11)/12)*16;case Bn:case ra:case pa:return Math.ceil(l/4)*Math.ceil(t/4)*16;case Ss:case Ga:return Math.ceil(l/4)*Math.ceil(t/4)*8;case Wa:case Va:return Math.ceil(l/4)*Math.ceil(t/4)*16}throw new Error(`Unable to determine texture byte length for ${e} format.`)}function ju(l){switch(l){case Qe:case ps:return{byteLength:1,components:1};case Gn:case Gs:case Wn:return{byteLength:2,components:1};case Bi:case Ei:return{byteLength:2,components:4};case Yl:case Ki:case $e:return{byteLength:4,components:1};case Ws:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${l}.`)}function _u(l,t,e,n,i,s,a){const d=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,c=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),o=new ft,Z=new WeakMap;let m;const b=new WeakMap;let h=!1;try{h=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function p(S,W){return h?new OffscreenCanvas(S,W):Pn("canvas")}function V(S,W,T){let Q=1;const _=Xt(S);if((_.width>T||_.height>T)&&(Q=T/Math.max(_.width,_.height)),Q<1)if(typeof HTMLImageElement<"u"&&S instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&S instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&S instanceof ImageBitmap||typeof VideoFrame<"u"&&S instanceof VideoFrame){const B=Math.floor(Q*_.width),Gt=Math.floor(Q*_.height);m===void 0&&(m=p(B,Gt));const at=W?p(B,Gt):m;return at.width=B,at.height=Gt,at.getContext("2d").drawImage(S,0,0,B,Gt),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+_.width+"x"+_.height+") to ("+B+"x"+Gt+")."),at}else return"data"in S&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+_.width+"x"+_.height+")."),S;return S}function r(S){return S.generateMipmaps}function u(S){l.generateMipmap(S)}function C(S){return S.isWebGLCubeRenderTarget?l.TEXTURE_CUBE_MAP:S.isWebGL3DRenderTarget?l.TEXTURE_3D:S.isWebGLArrayRenderTarget||S.isCompressedArrayTexture?l.TEXTURE_2D_ARRAY:l.TEXTURE_2D}function y(S,W,T,Q,_=!1){if(S!==null){if(l[S]!==void 0)return l[S];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+S+"'")}let B=W;if(W===l.RED&&(T===l.FLOAT&&(B=l.R32F),T===l.HALF_FLOAT&&(B=l.R16F),T===l.UNSIGNED_BYTE&&(B=l.R8)),W===l.RED_INTEGER&&(T===l.UNSIGNED_BYTE&&(B=l.R8UI),T===l.UNSIGNED_SHORT&&(B=l.R16UI),T===l.UNSIGNED_INT&&(B=l.R32UI),T===l.BYTE&&(B=l.R8I),T===l.SHORT&&(B=l.R16I),T===l.INT&&(B=l.R32I)),W===l.RG&&(T===l.FLOAT&&(B=l.RG32F),T===l.HALF_FLOAT&&(B=l.RG16F),T===l.UNSIGNED_BYTE&&(B=l.RG8)),W===l.RG_INTEGER&&(T===l.UNSIGNED_BYTE&&(B=l.RG8UI),T===l.UNSIGNED_SHORT&&(B=l.RG16UI),T===l.UNSIGNED_INT&&(B=l.RG32UI),T===l.BYTE&&(B=l.RG8I),T===l.SHORT&&(B=l.RG16I),T===l.INT&&(B=l.RG32I)),W===l.RGB_INTEGER&&(T===l.UNSIGNED_BYTE&&(B=l.RGB8UI),T===l.UNSIGNED_SHORT&&(B=l.RGB16UI),T===l.UNSIGNED_INT&&(B=l.RGB32UI),T===l.BYTE&&(B=l.RGB8I),T===l.SHORT&&(B=l.RGB16I),T===l.INT&&(B=l.RGB32I)),W===l.RGBA_INTEGER&&(T===l.UNSIGNED_BYTE&&(B=l.RGBA8UI),T===l.UNSIGNED_SHORT&&(B=l.RGBA16UI),T===l.UNSIGNED_INT&&(B=l.RGBA32UI),T===l.BYTE&&(B=l.RGBA8I),T===l.SHORT&&(B=l.RGBA16I),T===l.INT&&(B=l.RGBA32I)),W===l.RGB&&T===l.UNSIGNED_INT_5_9_9_9_REV&&(B=l.RGB9_E5),W===l.RGBA){const Gt=_?En:kt.getTransfer(Q);T===l.FLOAT&&(B=l.RGBA32F),T===l.HALF_FLOAT&&(B=l.RGBA16F),T===l.UNSIGNED_BYTE&&(B=Gt===Pt?l.SRGB8_ALPHA8:l.RGBA8),T===l.UNSIGNED_SHORT_4_4_4_4&&(B=l.RGBA4),T===l.UNSIGNED_SHORT_5_5_5_1&&(B=l.RGB5_A1)}return(B===l.R16F||B===l.R32F||B===l.RG16F||B===l.RG32F||B===l.RGBA16F||B===l.RGBA32F)&&t.get("EXT_color_buffer_float"),B}function G(S,W){let T;return S?W===null||W===Yl||W===Bl?T=l.DEPTH24_STENCIL8:W===$e?T=l.DEPTH32F_STENCIL8:W===Gn&&(T=l.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):W===null||W===Yl||W===Bl?T=l.DEPTH_COMPONENT24:W===$e?T=l.DEPTH_COMPONENT32F:W===Gn&&(T=l.DEPTH_COMPONENT16),T}function N(S,W){return r(S)===!0||S.isFramebufferTexture&&S.minFilter!==Je&&S.minFilter!==be?Math.log2(Math.max(W.width,W.height))+1:S.mipmaps!==void 0&&S.mipmaps.length>0?S.mipmaps.length:S.isCompressedTexture&&Array.isArray(S.image)?W.mipmaps.length:1}function I(S){const W=S.target;W.removeEventListener("dispose",I),U(W),W.isVideoTexture&&Z.delete(W)}function x(S){const W=S.target;W.removeEventListener("dispose",x),g(W)}function U(S){const W=n.get(S);if(W.__webglInit===void 0)return;const T=S.source,Q=b.get(T);if(Q){const _=Q[W.__cacheKey];_.usedTimes--,_.usedTimes===0&&R(S),Object.keys(Q).length===0&&b.delete(T)}n.remove(S)}function R(S){const W=n.get(S);l.deleteTexture(W.__webglTexture);const T=S.source,Q=b.get(T);delete Q[W.__cacheKey],a.memory.textures--}function g(S){const W=n.get(S);if(S.depthTexture&&(S.depthTexture.dispose(),n.remove(S.depthTexture)),S.isWebGLCubeRenderTarget)for(let Q=0;Q<6;Q++){if(Array.isArray(W.__webglFramebuffer[Q]))for(let _=0;_<W.__webglFramebuffer[Q].length;_++)l.deleteFramebuffer(W.__webglFramebuffer[Q][_]);else l.deleteFramebuffer(W.__webglFramebuffer[Q]);W.__webglDepthbuffer&&l.deleteRenderbuffer(W.__webglDepthbuffer[Q])}else{if(Array.isArray(W.__webglFramebuffer))for(let Q=0;Q<W.__webglFramebuffer.length;Q++)l.deleteFramebuffer(W.__webglFramebuffer[Q]);else l.deleteFramebuffer(W.__webglFramebuffer);if(W.__webglDepthbuffer&&l.deleteRenderbuffer(W.__webglDepthbuffer),W.__webglMultisampledFramebuffer&&l.deleteFramebuffer(W.__webglMultisampledFramebuffer),W.__webglColorRenderbuffer)for(let Q=0;Q<W.__webglColorRenderbuffer.length;Q++)W.__webglColorRenderbuffer[Q]&&l.deleteRenderbuffer(W.__webglColorRenderbuffer[Q]);W.__webglDepthRenderbuffer&&l.deleteRenderbuffer(W.__webglDepthRenderbuffer)}const T=S.textures;for(let Q=0,_=T.length;Q<_;Q++){const B=n.get(T[Q]);B.__webglTexture&&(l.deleteTexture(B.__webglTexture),a.memory.textures--),n.remove(T[Q])}n.remove(S)}let Y=0;function P(){Y=0}function w(){const S=Y;return S>=i.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+S+" texture units while this GPU supports only "+i.maxTextures),Y+=1,S}function E(S){const W=[];return W.push(S.wrapS),W.push(S.wrapT),W.push(S.wrapR||0),W.push(S.magFilter),W.push(S.minFilter),W.push(S.anisotropy),W.push(S.internalFormat),W.push(S.format),W.push(S.type),W.push(S.generateMipmaps),W.push(S.premultiplyAlpha),W.push(S.flipY),W.push(S.unpackAlignment),W.push(S.colorSpace),W.join()}function D(S,W){const T=n.get(S);if(S.isVideoTexture&&gt(S),S.isRenderTargetTexture===!1&&S.version>0&&T.__version!==S.version){const Q=S.image;if(Q===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Q.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{A(T,S,W);return}}e.bindTexture(l.TEXTURE_2D,T.__webglTexture,l.TEXTURE0+W)}function K(S,W){const T=n.get(S);if(S.version>0&&T.__version!==S.version){A(T,S,W);return}e.bindTexture(l.TEXTURE_2D_ARRAY,T.__webglTexture,l.TEXTURE0+W)}function $(S,W){const T=n.get(S);if(S.version>0&&T.__version!==S.version){A(T,S,W);return}e.bindTexture(l.TEXTURE_3D,T.__webglTexture,l.TEXTURE0+W)}function H(S,W){const T=n.get(S);if(S.version>0&&T.__version!==S.version){tt(T,S,W);return}e.bindTexture(l.TEXTURE_CUBE_MAP,T.__webglTexture,l.TEXTURE0+W)}const nt={[wi]:l.REPEAT,[Il]:l.CLAMP_TO_EDGE,[zi]:l.MIRRORED_REPEAT},ot={[Je]:l.NEAREST,[$c]:l.NEAREST_MIPMAP_NEAREST,[kn]:l.NEAREST_MIPMAP_LINEAR,[be]:l.LINEAR,[Hi]:l.LINEAR_MIPMAP_NEAREST,[xl]:l.LINEAR_MIPMAP_LINEAR},Vt={[io]:l.NEVER,[Zo]:l.ALWAYS,[ao]:l.LESS,[xs]:l.LEQUAL,[so]:l.EQUAL,[mo]:l.GEQUAL,[co]:l.GREATER,[oo]:l.NOTEQUAL};function Mt(S,W){if(W.type===$e&&t.has("OES_texture_float_linear")===!1&&(W.magFilter===be||W.magFilter===Hi||W.magFilter===kn||W.magFilter===xl||W.minFilter===be||W.minFilter===Hi||W.minFilter===kn||W.minFilter===xl)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),l.texParameteri(S,l.TEXTURE_WRAP_S,nt[W.wrapS]),l.texParameteri(S,l.TEXTURE_WRAP_T,nt[W.wrapT]),(S===l.TEXTURE_3D||S===l.TEXTURE_2D_ARRAY)&&l.texParameteri(S,l.TEXTURE_WRAP_R,nt[W.wrapR]),l.texParameteri(S,l.TEXTURE_MAG_FILTER,ot[W.magFilter]),l.texParameteri(S,l.TEXTURE_MIN_FILTER,ot[W.minFilter]),W.compareFunction&&(l.texParameteri(S,l.TEXTURE_COMPARE_MODE,l.COMPARE_REF_TO_TEXTURE),l.texParameteri(S,l.TEXTURE_COMPARE_FUNC,Vt[W.compareFunction])),t.has("EXT_texture_filter_anisotropic")===!0){if(W.magFilter===Je||W.minFilter!==kn&&W.minFilter!==xl||W.type===$e&&t.has("OES_texture_float_linear")===!1)return;if(W.anisotropy>1||n.get(W).__currentAnisotropy){const T=t.get("EXT_texture_filter_anisotropic");l.texParameterf(S,T.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(W.anisotropy,i.getMaxAnisotropy())),n.get(W).__currentAnisotropy=W.anisotropy}}}function Qt(S,W){let T=!1;S.__webglInit===void 0&&(S.__webglInit=!0,W.addEventListener("dispose",I));const Q=W.source;let _=b.get(Q);_===void 0&&(_={},b.set(Q,_));const B=E(W);if(B!==S.__cacheKey){_[B]===void 0&&(_[B]={texture:l.createTexture(),usedTimes:0},a.memory.textures++,T=!0),_[B].usedTimes++;const Gt=_[S.__cacheKey];Gt!==void 0&&(_[S.__cacheKey].usedTimes--,Gt.usedTimes===0&&R(W)),S.__cacheKey=B,S.__webglTexture=_[B].texture}return T}function A(S,W,T){let Q=l.TEXTURE_2D;(W.isDataArrayTexture||W.isCompressedArrayTexture)&&(Q=l.TEXTURE_2D_ARRAY),W.isData3DTexture&&(Q=l.TEXTURE_3D);const _=Qt(S,W),B=W.source;e.bindTexture(Q,S.__webglTexture,l.TEXTURE0+T);const Gt=n.get(B);if(B.version!==Gt.__version||_===!0){e.activeTexture(l.TEXTURE0+T);const at=kt.getPrimaries(kt.workingColorSpace),mt=W.colorSpace===ul?null:kt.getPrimaries(W.colorSpace),zt=W.colorSpace===ul||at===mt?l.NONE:l.BROWSER_DEFAULT_WEBGL;l.pixelStorei(l.UNPACK_FLIP_Y_WEBGL,W.flipY),l.pixelStorei(l.UNPACK_PREMULTIPLY_ALPHA_WEBGL,W.premultiplyAlpha),l.pixelStorei(l.UNPACK_ALIGNMENT,W.unpackAlignment),l.pixelStorei(l.UNPACK_COLORSPACE_CONVERSION_WEBGL,zt);let O=V(W.image,!1,i.maxTextureSize);O=Ot(W,O);const Zt=s.convert(W.format,W.colorSpace),Rt=s.convert(W.type);let Ct=y(W.internalFormat,Zt,Rt,W.colorSpace,W.isVideoTexture);Mt(Q,W);let ht;const Jt=W.mipmaps,Lt=W.isVideoTexture!==!0,_t=Gt.__version===void 0||_===!0,f=B.dataReady,lt=N(W,O);if(W.isDepthTexture)Ct=G(W.format===Al,W.type),_t&&(Lt?e.texStorage2D(l.TEXTURE_2D,1,Ct,O.width,O.height):e.texImage2D(l.TEXTURE_2D,0,Ct,O.width,O.height,0,Zt,Rt,null));else if(W.isDataTexture)if(Jt.length>0){Lt&&_t&&e.texStorage2D(l.TEXTURE_2D,lt,Ct,Jt[0].width,Jt[0].height);for(let z=0,j=Jt.length;z<j;z++)ht=Jt[z],Lt?f&&e.texSubImage2D(l.TEXTURE_2D,z,0,0,ht.width,ht.height,Zt,Rt,ht.data):e.texImage2D(l.TEXTURE_2D,z,Ct,ht.width,ht.height,0,Zt,Rt,ht.data);W.generateMipmaps=!1}else Lt?(_t&&e.texStorage2D(l.TEXTURE_2D,lt,Ct,O.width,O.height),f&&e.texSubImage2D(l.TEXTURE_2D,0,0,0,O.width,O.height,Zt,Rt,O.data)):e.texImage2D(l.TEXTURE_2D,0,Ct,O.width,O.height,0,Zt,Rt,O.data);else if(W.isCompressedTexture)if(W.isCompressedArrayTexture){Lt&&_t&&e.texStorage3D(l.TEXTURE_2D_ARRAY,lt,Ct,Jt[0].width,Jt[0].height,O.depth);for(let z=0,j=Jt.length;z<j;z++)if(ht=Jt[z],W.format!==Fe)if(Zt!==null)if(Lt){if(f)if(W.layerUpdates.size>0){const ct=wd(ht.width,ht.height,W.format,W.type);for(const st of W.layerUpdates){const Yt=ht.data.subarray(st*ct/ht.data.BYTES_PER_ELEMENT,(st+1)*ct/ht.data.BYTES_PER_ELEMENT);e.compressedTexSubImage3D(l.TEXTURE_2D_ARRAY,z,0,0,st,ht.width,ht.height,1,Zt,Yt)}W.clearLayerUpdates()}else e.compressedTexSubImage3D(l.TEXTURE_2D_ARRAY,z,0,0,0,ht.width,ht.height,O.depth,Zt,ht.data)}else e.compressedTexImage3D(l.TEXTURE_2D_ARRAY,z,Ct,ht.width,ht.height,O.depth,0,ht.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else Lt?f&&e.texSubImage3D(l.TEXTURE_2D_ARRAY,z,0,0,0,ht.width,ht.height,O.depth,Zt,Rt,ht.data):e.texImage3D(l.TEXTURE_2D_ARRAY,z,Ct,ht.width,ht.height,O.depth,0,Zt,Rt,ht.data)}else{Lt&&_t&&e.texStorage2D(l.TEXTURE_2D,lt,Ct,Jt[0].width,Jt[0].height);for(let z=0,j=Jt.length;z<j;z++)ht=Jt[z],W.format!==Fe?Zt!==null?Lt?f&&e.compressedTexSubImage2D(l.TEXTURE_2D,z,0,0,ht.width,ht.height,Zt,ht.data):e.compressedTexImage2D(l.TEXTURE_2D,z,Ct,ht.width,ht.height,0,ht.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Lt?f&&e.texSubImage2D(l.TEXTURE_2D,z,0,0,ht.width,ht.height,Zt,Rt,ht.data):e.texImage2D(l.TEXTURE_2D,z,Ct,ht.width,ht.height,0,Zt,Rt,ht.data)}else if(W.isDataArrayTexture)if(Lt){if(_t&&e.texStorage3D(l.TEXTURE_2D_ARRAY,lt,Ct,O.width,O.height,O.depth),f)if(W.layerUpdates.size>0){const z=wd(O.width,O.height,W.format,W.type);for(const j of W.layerUpdates){const ct=O.data.subarray(j*z/O.data.BYTES_PER_ELEMENT,(j+1)*z/O.data.BYTES_PER_ELEMENT);e.texSubImage3D(l.TEXTURE_2D_ARRAY,0,0,0,j,O.width,O.height,1,Zt,Rt,ct)}W.clearLayerUpdates()}else e.texSubImage3D(l.TEXTURE_2D_ARRAY,0,0,0,0,O.width,O.height,O.depth,Zt,Rt,O.data)}else e.texImage3D(l.TEXTURE_2D_ARRAY,0,Ct,O.width,O.height,O.depth,0,Zt,Rt,O.data);else if(W.isData3DTexture)Lt?(_t&&e.texStorage3D(l.TEXTURE_3D,lt,Ct,O.width,O.height,O.depth),f&&e.texSubImage3D(l.TEXTURE_3D,0,0,0,0,O.width,O.height,O.depth,Zt,Rt,O.data)):e.texImage3D(l.TEXTURE_3D,0,Ct,O.width,O.height,O.depth,0,Zt,Rt,O.data);else if(W.isFramebufferTexture){if(_t)if(Lt)e.texStorage2D(l.TEXTURE_2D,lt,Ct,O.width,O.height);else{let z=O.width,j=O.height;for(let ct=0;ct<lt;ct++)e.texImage2D(l.TEXTURE_2D,ct,Ct,z,j,0,Zt,Rt,null),z>>=1,j>>=1}}else if(Jt.length>0){if(Lt&&_t){const z=Xt(Jt[0]);e.texStorage2D(l.TEXTURE_2D,lt,Ct,z.width,z.height)}for(let z=0,j=Jt.length;z<j;z++)ht=Jt[z],Lt?f&&e.texSubImage2D(l.TEXTURE_2D,z,0,0,Zt,Rt,ht):e.texImage2D(l.TEXTURE_2D,z,Ct,Zt,Rt,ht);W.generateMipmaps=!1}else if(Lt){if(_t){const z=Xt(O);e.texStorage2D(l.TEXTURE_2D,lt,Ct,z.width,z.height)}f&&e.texSubImage2D(l.TEXTURE_2D,0,0,0,Zt,Rt,O)}else e.texImage2D(l.TEXTURE_2D,0,Ct,Zt,Rt,O);r(W)&&u(Q),Gt.__version=B.version,W.onUpdate&&W.onUpdate(W)}S.__version=W.version}function tt(S,W,T){if(W.image.length!==6)return;const Q=Qt(S,W),_=W.source;e.bindTexture(l.TEXTURE_CUBE_MAP,S.__webglTexture,l.TEXTURE0+T);const B=n.get(_);if(_.version!==B.__version||Q===!0){e.activeTexture(l.TEXTURE0+T);const Gt=kt.getPrimaries(kt.workingColorSpace),at=W.colorSpace===ul?null:kt.getPrimaries(W.colorSpace),mt=W.colorSpace===ul||Gt===at?l.NONE:l.BROWSER_DEFAULT_WEBGL;l.pixelStorei(l.UNPACK_FLIP_Y_WEBGL,W.flipY),l.pixelStorei(l.UNPACK_PREMULTIPLY_ALPHA_WEBGL,W.premultiplyAlpha),l.pixelStorei(l.UNPACK_ALIGNMENT,W.unpackAlignment),l.pixelStorei(l.UNPACK_COLORSPACE_CONVERSION_WEBGL,mt);const zt=W.isCompressedTexture||W.image[0].isCompressedTexture,O=W.image[0]&&W.image[0].isDataTexture,Zt=[];for(let j=0;j<6;j++)!zt&&!O?Zt[j]=V(W.image[j],!0,i.maxCubemapSize):Zt[j]=O?W.image[j].image:W.image[j],Zt[j]=Ot(W,Zt[j]);const Rt=Zt[0],Ct=s.convert(W.format,W.colorSpace),ht=s.convert(W.type),Jt=y(W.internalFormat,Ct,ht,W.colorSpace),Lt=W.isVideoTexture!==!0,_t=B.__version===void 0||Q===!0,f=_.dataReady;let lt=N(W,Rt);Mt(l.TEXTURE_CUBE_MAP,W);let z;if(zt){Lt&&_t&&e.texStorage2D(l.TEXTURE_CUBE_MAP,lt,Jt,Rt.width,Rt.height);for(let j=0;j<6;j++){z=Zt[j].mipmaps;for(let ct=0;ct<z.length;ct++){const st=z[ct];W.format!==Fe?Ct!==null?Lt?f&&e.compressedTexSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct,0,0,st.width,st.height,Ct,st.data):e.compressedTexImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct,Jt,st.width,st.height,0,st.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Lt?f&&e.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct,0,0,st.width,st.height,Ct,ht,st.data):e.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct,Jt,st.width,st.height,0,Ct,ht,st.data)}}}else{if(z=W.mipmaps,Lt&&_t){z.length>0&&lt++;const j=Xt(Zt[0]);e.texStorage2D(l.TEXTURE_CUBE_MAP,lt,Jt,j.width,j.height)}for(let j=0;j<6;j++)if(O){Lt?f&&e.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,0,0,0,Zt[j].width,Zt[j].height,Ct,ht,Zt[j].data):e.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,0,Jt,Zt[j].width,Zt[j].height,0,Ct,ht,Zt[j].data);for(let ct=0;ct<z.length;ct++){const Yt=z[ct].image[j].image;Lt?f&&e.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct+1,0,0,Yt.width,Yt.height,Ct,ht,Yt.data):e.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct+1,Jt,Yt.width,Yt.height,0,Ct,ht,Yt.data)}}else{Lt?f&&e.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,0,0,0,Ct,ht,Zt[j]):e.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,0,Jt,Ct,ht,Zt[j]);for(let ct=0;ct<z.length;ct++){const st=z[ct];Lt?f&&e.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct+1,0,0,Ct,ht,st.image[j]):e.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct+1,Jt,Ct,ht,st.image[j])}}}r(W)&&u(l.TEXTURE_CUBE_MAP),B.__version=_.version,W.onUpdate&&W.onUpdate(W)}S.__version=W.version}function pt(S,W,T,Q,_,B){const Gt=s.convert(T.format,T.colorSpace),at=s.convert(T.type),mt=y(T.internalFormat,Gt,at,T.colorSpace),zt=n.get(W),O=n.get(T);if(O.__renderTarget=W,!zt.__hasExternalTextures){const Zt=Math.max(1,W.width>>B),Rt=Math.max(1,W.height>>B);_===l.TEXTURE_3D||_===l.TEXTURE_2D_ARRAY?e.texImage3D(_,B,mt,Zt,Rt,W.depth,0,Gt,at,null):e.texImage2D(_,B,mt,Zt,Rt,0,Gt,at,null)}e.bindFramebuffer(l.FRAMEBUFFER,S),vt(W)?d.framebufferTexture2DMultisampleEXT(l.FRAMEBUFFER,Q,_,O.__webglTexture,0,Tt(W)):(_===l.TEXTURE_2D||_>=l.TEXTURE_CUBE_MAP_POSITIVE_X&&_<=l.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&l.framebufferTexture2D(l.FRAMEBUFFER,Q,_,O.__webglTexture,B),e.bindFramebuffer(l.FRAMEBUFFER,null)}function it(S,W,T){if(l.bindRenderbuffer(l.RENDERBUFFER,S),W.depthBuffer){const Q=W.depthTexture,_=Q&&Q.isDepthTexture?Q.type:null,B=G(W.stencilBuffer,_),Gt=W.stencilBuffer?l.DEPTH_STENCIL_ATTACHMENT:l.DEPTH_ATTACHMENT,at=Tt(W);vt(W)?d.renderbufferStorageMultisampleEXT(l.RENDERBUFFER,at,B,W.width,W.height):T?l.renderbufferStorageMultisample(l.RENDERBUFFER,at,B,W.width,W.height):l.renderbufferStorage(l.RENDERBUFFER,B,W.width,W.height),l.framebufferRenderbuffer(l.FRAMEBUFFER,Gt,l.RENDERBUFFER,S)}else{const Q=W.textures;for(let _=0;_<Q.length;_++){const B=Q[_],Gt=s.convert(B.format,B.colorSpace),at=s.convert(B.type),mt=y(B.internalFormat,Gt,at,B.colorSpace),zt=Tt(W);T&&vt(W)===!1?l.renderbufferStorageMultisample(l.RENDERBUFFER,zt,mt,W.width,W.height):vt(W)?d.renderbufferStorageMultisampleEXT(l.RENDERBUFFER,zt,mt,W.width,W.height):l.renderbufferStorage(l.RENDERBUFFER,mt,W.width,W.height)}}l.bindRenderbuffer(l.RENDERBUFFER,null)}function yt(S,W){if(W&&W.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(l.FRAMEBUFFER,S),!(W.depthTexture&&W.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const Q=n.get(W.depthTexture);Q.__renderTarget=W,(!Q.__webglTexture||W.depthTexture.image.width!==W.width||W.depthTexture.image.height!==W.height)&&(W.depthTexture.image.width=W.width,W.depthTexture.image.height=W.height,W.depthTexture.needsUpdate=!0),D(W.depthTexture,0);const _=Q.__webglTexture,B=Tt(W);if(W.depthTexture.format===El)vt(W)?d.framebufferTexture2DMultisampleEXT(l.FRAMEBUFFER,l.DEPTH_ATTACHMENT,l.TEXTURE_2D,_,0,B):l.framebufferTexture2D(l.FRAMEBUFFER,l.DEPTH_ATTACHMENT,l.TEXTURE_2D,_,0);else if(W.depthTexture.format===Al)vt(W)?d.framebufferTexture2DMultisampleEXT(l.FRAMEBUFFER,l.DEPTH_STENCIL_ATTACHMENT,l.TEXTURE_2D,_,0,B):l.framebufferTexture2D(l.FRAMEBUFFER,l.DEPTH_STENCIL_ATTACHMENT,l.TEXTURE_2D,_,0);else throw new Error("Unknown depthTexture format")}function It(S){const W=n.get(S),T=S.isWebGLCubeRenderTarget===!0;if(W.__boundDepthTexture!==S.depthTexture){const Q=S.depthTexture;if(W.__depthDisposeCallback&&W.__depthDisposeCallback(),Q){const _=()=>{delete W.__boundDepthTexture,delete W.__depthDisposeCallback,Q.removeEventListener("dispose",_)};Q.addEventListener("dispose",_),W.__depthDisposeCallback=_}W.__boundDepthTexture=Q}if(S.depthTexture&&!W.__autoAllocateDepthBuffer){if(T)throw new Error("target.depthTexture not supported in Cube render targets");yt(W.__webglFramebuffer,S)}else if(T){W.__webglDepthbuffer=[];for(let Q=0;Q<6;Q++)if(e.bindFramebuffer(l.FRAMEBUFFER,W.__webglFramebuffer[Q]),W.__webglDepthbuffer[Q]===void 0)W.__webglDepthbuffer[Q]=l.createRenderbuffer(),it(W.__webglDepthbuffer[Q],S,!1);else{const _=S.stencilBuffer?l.DEPTH_STENCIL_ATTACHMENT:l.DEPTH_ATTACHMENT,B=W.__webglDepthbuffer[Q];l.bindRenderbuffer(l.RENDERBUFFER,B),l.framebufferRenderbuffer(l.FRAMEBUFFER,_,l.RENDERBUFFER,B)}}else if(e.bindFramebuffer(l.FRAMEBUFFER,W.__webglFramebuffer),W.__webglDepthbuffer===void 0)W.__webglDepthbuffer=l.createRenderbuffer(),it(W.__webglDepthbuffer,S,!1);else{const Q=S.stencilBuffer?l.DEPTH_STENCIL_ATTACHMENT:l.DEPTH_ATTACHMENT,_=W.__webglDepthbuffer;l.bindRenderbuffer(l.RENDERBUFFER,_),l.framebufferRenderbuffer(l.FRAMEBUFFER,Q,l.RENDERBUFFER,_)}e.bindFramebuffer(l.FRAMEBUFFER,null)}function Ut(S,W,T){const Q=n.get(S);W!==void 0&&pt(Q.__webglFramebuffer,S,S.texture,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,0),T!==void 0&&It(S)}function le(S){const W=S.texture,T=n.get(S),Q=n.get(W);S.addEventListener("dispose",x);const _=S.textures,B=S.isWebGLCubeRenderTarget===!0,Gt=_.length>1;if(Gt||(Q.__webglTexture===void 0&&(Q.__webglTexture=l.createTexture()),Q.__version=W.version,a.memory.textures++),B){T.__webglFramebuffer=[];for(let at=0;at<6;at++)if(W.mipmaps&&W.mipmaps.length>0){T.__webglFramebuffer[at]=[];for(let mt=0;mt<W.mipmaps.length;mt++)T.__webglFramebuffer[at][mt]=l.createFramebuffer()}else T.__webglFramebuffer[at]=l.createFramebuffer()}else{if(W.mipmaps&&W.mipmaps.length>0){T.__webglFramebuffer=[];for(let at=0;at<W.mipmaps.length;at++)T.__webglFramebuffer[at]=l.createFramebuffer()}else T.__webglFramebuffer=l.createFramebuffer();if(Gt)for(let at=0,mt=_.length;at<mt;at++){const zt=n.get(_[at]);zt.__webglTexture===void 0&&(zt.__webglTexture=l.createTexture(),a.memory.textures++)}if(S.samples>0&&vt(S)===!1){T.__webglMultisampledFramebuffer=l.createFramebuffer(),T.__webglColorRenderbuffer=[],e.bindFramebuffer(l.FRAMEBUFFER,T.__webglMultisampledFramebuffer);for(let at=0;at<_.length;at++){const mt=_[at];T.__webglColorRenderbuffer[at]=l.createRenderbuffer(),l.bindRenderbuffer(l.RENDERBUFFER,T.__webglColorRenderbuffer[at]);const zt=s.convert(mt.format,mt.colorSpace),O=s.convert(mt.type),Zt=y(mt.internalFormat,zt,O,mt.colorSpace,S.isXRRenderTarget===!0),Rt=Tt(S);l.renderbufferStorageMultisample(l.RENDERBUFFER,Rt,Zt,S.width,S.height),l.framebufferRenderbuffer(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0+at,l.RENDERBUFFER,T.__webglColorRenderbuffer[at])}l.bindRenderbuffer(l.RENDERBUFFER,null),S.depthBuffer&&(T.__webglDepthRenderbuffer=l.createRenderbuffer(),it(T.__webglDepthRenderbuffer,S,!0)),e.bindFramebuffer(l.FRAMEBUFFER,null)}}if(B){e.bindTexture(l.TEXTURE_CUBE_MAP,Q.__webglTexture),Mt(l.TEXTURE_CUBE_MAP,W);for(let at=0;at<6;at++)if(W.mipmaps&&W.mipmaps.length>0)for(let mt=0;mt<W.mipmaps.length;mt++)pt(T.__webglFramebuffer[at][mt],S,W,l.COLOR_ATTACHMENT0,l.TEXTURE_CUBE_MAP_POSITIVE_X+at,mt);else pt(T.__webglFramebuffer[at],S,W,l.COLOR_ATTACHMENT0,l.TEXTURE_CUBE_MAP_POSITIVE_X+at,0);r(W)&&u(l.TEXTURE_CUBE_MAP),e.unbindTexture()}else if(Gt){for(let at=0,mt=_.length;at<mt;at++){const zt=_[at],O=n.get(zt);e.bindTexture(l.TEXTURE_2D,O.__webglTexture),Mt(l.TEXTURE_2D,zt),pt(T.__webglFramebuffer,S,zt,l.COLOR_ATTACHMENT0+at,l.TEXTURE_2D,0),r(zt)&&u(l.TEXTURE_2D)}e.unbindTexture()}else{let at=l.TEXTURE_2D;if((S.isWebGL3DRenderTarget||S.isWebGLArrayRenderTarget)&&(at=S.isWebGL3DRenderTarget?l.TEXTURE_3D:l.TEXTURE_2D_ARRAY),e.bindTexture(at,Q.__webglTexture),Mt(at,W),W.mipmaps&&W.mipmaps.length>0)for(let mt=0;mt<W.mipmaps.length;mt++)pt(T.__webglFramebuffer[mt],S,W,l.COLOR_ATTACHMENT0,at,mt);else pt(T.__webglFramebuffer,S,W,l.COLOR_ATTACHMENT0,at,0);r(W)&&u(at),e.unbindTexture()}S.depthBuffer&&It(S)}function wt(S){const W=S.textures;for(let T=0,Q=W.length;T<Q;T++){const _=W[T];if(r(_)){const B=C(S),Gt=n.get(_).__webglTexture;e.bindTexture(B,Gt),u(B),e.unbindTexture()}}}const se=[],M=[];function Te(S){if(S.samples>0){if(vt(S)===!1){const W=S.textures,T=S.width,Q=S.height;let _=l.COLOR_BUFFER_BIT;const B=S.stencilBuffer?l.DEPTH_STENCIL_ATTACHMENT:l.DEPTH_ATTACHMENT,Gt=n.get(S),at=W.length>1;if(at)for(let mt=0;mt<W.length;mt++)e.bindFramebuffer(l.FRAMEBUFFER,Gt.__webglMultisampledFramebuffer),l.framebufferRenderbuffer(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0+mt,l.RENDERBUFFER,null),e.bindFramebuffer(l.FRAMEBUFFER,Gt.__webglFramebuffer),l.framebufferTexture2D(l.DRAW_FRAMEBUFFER,l.COLOR_ATTACHMENT0+mt,l.TEXTURE_2D,null,0);e.bindFramebuffer(l.READ_FRAMEBUFFER,Gt.__webglMultisampledFramebuffer),e.bindFramebuffer(l.DRAW_FRAMEBUFFER,Gt.__webglFramebuffer);for(let mt=0;mt<W.length;mt++){if(S.resolveDepthBuffer&&(S.depthBuffer&&(_|=l.DEPTH_BUFFER_BIT),S.stencilBuffer&&S.resolveStencilBuffer&&(_|=l.STENCIL_BUFFER_BIT)),at){l.framebufferRenderbuffer(l.READ_FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.RENDERBUFFER,Gt.__webglColorRenderbuffer[mt]);const zt=n.get(W[mt]).__webglTexture;l.framebufferTexture2D(l.DRAW_FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,zt,0)}l.blitFramebuffer(0,0,T,Q,0,0,T,Q,_,l.NEAREST),c===!0&&(se.length=0,M.length=0,se.push(l.COLOR_ATTACHMENT0+mt),S.depthBuffer&&S.resolveDepthBuffer===!1&&(se.push(B),M.push(B),l.invalidateFramebuffer(l.DRAW_FRAMEBUFFER,M)),l.invalidateFramebuffer(l.READ_FRAMEBUFFER,se))}if(e.bindFramebuffer(l.READ_FRAMEBUFFER,null),e.bindFramebuffer(l.DRAW_FRAMEBUFFER,null),at)for(let mt=0;mt<W.length;mt++){e.bindFramebuffer(l.FRAMEBUFFER,Gt.__webglMultisampledFramebuffer),l.framebufferRenderbuffer(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0+mt,l.RENDERBUFFER,Gt.__webglColorRenderbuffer[mt]);const zt=n.get(W[mt]).__webglTexture;e.bindFramebuffer(l.FRAMEBUFFER,Gt.__webglFramebuffer),l.framebufferTexture2D(l.DRAW_FRAMEBUFFER,l.COLOR_ATTACHMENT0+mt,l.TEXTURE_2D,zt,0)}e.bindFramebuffer(l.DRAW_FRAMEBUFFER,Gt.__webglMultisampledFramebuffer)}else if(S.depthBuffer&&S.resolveDepthBuffer===!1&&c){const W=S.stencilBuffer?l.DEPTH_STENCIL_ATTACHMENT:l.DEPTH_ATTACHMENT;l.invalidateFramebuffer(l.DRAW_FRAMEBUFFER,[W])}}}function Tt(S){return Math.min(i.maxSamples,S.samples)}function vt(S){const W=n.get(S);return S.samples>0&&t.has("WEBGL_multisampled_render_to_texture")===!0&&W.__useRenderToTexture!==!1}function gt(S){const W=a.render.frame;Z.get(S)!==W&&(Z.set(S,W),S.update())}function Ot(S,W){const T=S.colorSpace,Q=S.format,_=S.type;return S.isCompressedTexture===!0||S.isVideoTexture===!0||T!==Pl&&T!==ul&&(kt.getTransfer(T)===Pt?(Q!==Fe||_!==Qe)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",T)),W}function Xt(S){return typeof HTMLImageElement<"u"&&S instanceof HTMLImageElement?(o.width=S.naturalWidth||S.width,o.height=S.naturalHeight||S.height):typeof VideoFrame<"u"&&S instanceof VideoFrame?(o.width=S.displayWidth,o.height=S.displayHeight):(o.width=S.width,o.height=S.height),o}this.allocateTextureUnit=w,this.resetTextureUnits=P,this.setTexture2D=D,this.setTexture2DArray=K,this.setTexture3D=$,this.setTextureCube=H,this.rebindTextures=Ut,this.setupRenderTarget=le,this.updateRenderTargetMipmap=wt,this.updateMultisampleRenderTarget=Te,this.setupDepthRenderbuffer=It,this.setupFrameBufferTexture=pt,this.useMultisampledRTT=vt}function Du(l,t){function e(n,i=ul){let s;const a=kt.getTransfer(i);if(n===Qe)return l.UNSIGNED_BYTE;if(n===Bi)return l.UNSIGNED_SHORT_4_4_4_4;if(n===Ei)return l.UNSIGNED_SHORT_5_5_5_1;if(n===Ws)return l.UNSIGNED_INT_5_9_9_9_REV;if(n===ps)return l.BYTE;if(n===Gs)return l.SHORT;if(n===Gn)return l.UNSIGNED_SHORT;if(n===Ki)return l.INT;if(n===Yl)return l.UNSIGNED_INT;if(n===$e)return l.FLOAT;if(n===Wn)return l.HALF_FLOAT;if(n===Vs)return l.ALPHA;if(n===Xs)return l.RGB;if(n===Fe)return l.RGBA;if(n===gs)return l.LUMINANCE;if(n===Rs)return l.LUMINANCE_ALPHA;if(n===El)return l.DEPTH_COMPONENT;if(n===Al)return l.DEPTH_STENCIL;if(n===ys)return l.RED;if(n===Ai)return l.RED_INTEGER;if(n===Cs)return l.RG;if(n===Pi)return l.RG_INTEGER;if(n===Qi)return l.RGBA_INTEGER;if(n===wn||n===zn||n===Hn||n===Kn)if(a===Pt)if(s=t.get("WEBGL_compressed_texture_s3tc_srgb"),s!==null){if(n===wn)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===zn)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===Hn)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===Kn)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(s=t.get("WEBGL_compressed_texture_s3tc"),s!==null){if(n===wn)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===zn)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===Hn)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===Kn)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(n===ji||n===_i||n===Di||n===Oi)if(s=t.get("WEBGL_compressed_texture_pvrtc"),s!==null){if(n===ji)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===_i)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===Di)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===Oi)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(n===qi||n===$i||n===ta)if(s=t.get("WEBGL_compressed_texture_etc"),s!==null){if(n===qi||n===$i)return a===Pt?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(n===ta)return a===Pt?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(n===ea||n===la||n===na||n===ia||n===aa||n===sa||n===da||n===ca||n===oa||n===ma||n===Za||n===ha||n===ua||n===ba)if(s=t.get("WEBGL_compressed_texture_astc"),s!==null){if(n===ea)return a===Pt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===la)return a===Pt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===na)return a===Pt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===ia)return a===Pt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===aa)return a===Pt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===sa)return a===Pt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===da)return a===Pt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===ca)return a===Pt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===oa)return a===Pt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===ma)return a===Pt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===Za)return a===Pt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===ha)return a===Pt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===ua)return a===Pt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===ba)return a===Pt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(n===Bn||n===ra||n===pa)if(s=t.get("EXT_texture_compression_bptc"),s!==null){if(n===Bn)return a===Pt?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(n===ra)return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(n===pa)return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(n===Ss||n===Ga||n===Wa||n===Va)if(s=t.get("EXT_texture_compression_rgtc"),s!==null){if(n===Bn)return s.COMPRESSED_RED_RGTC1_EXT;if(n===Ga)return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(n===Wa)return s.COMPRESSED_RED_GREEN_RGTC2_EXT;if(n===Va)return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return n===Bl?l.UNSIGNED_INT_24_8:l[n]!==void 0?l[n]:null}return{convert:e}}class Ou extends Ke{constructor(t=[]){super(),this.isArrayCamera=!0,this.cameras=t}}class he extends Ce{constructor(){super(),this.isGroup=!0,this.type="Group"}}const qu={type:"move"};class Da{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new he,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new he,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new J,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new J),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new he,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new J,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new J),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}connect(t){if(t&&t.hand){const e=this._hand;if(e)for(const n of t.hand.values())this._getHandJoint(e,n)}return this.dispatchEvent({type:"connected",data:t}),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,n){let i=null,s=null,a=null;const d=this._targetRay,c=this._grip,o=this._hand;if(t&&e.session.visibilityState!=="visible-blurred"){if(o&&t.hand){a=!0;for(const V of t.hand.values()){const r=e.getJointPose(V,n),u=this._getHandJoint(o,V);r!==null&&(u.matrix.fromArray(r.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale),u.matrixWorldNeedsUpdate=!0,u.jointRadius=r.radius),u.visible=r!==null}const Z=o.joints["index-finger-tip"],m=o.joints["thumb-tip"],b=Z.position.distanceTo(m.position),h=.02,p=.005;o.inputState.pinching&&b>h+p?(o.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!o.inputState.pinching&&b<=h-p&&(o.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else c!==null&&t.gripSpace&&(s=e.getPose(t.gripSpace,n),s!==null&&(c.matrix.fromArray(s.transform.matrix),c.matrix.decompose(c.position,c.rotation,c.scale),c.matrixWorldNeedsUpdate=!0,s.linearVelocity?(c.hasLinearVelocity=!0,c.linearVelocity.copy(s.linearVelocity)):c.hasLinearVelocity=!1,s.angularVelocity?(c.hasAngularVelocity=!0,c.angularVelocity.copy(s.angularVelocity)):c.hasAngularVelocity=!1));d!==null&&(i=e.getPose(t.targetRaySpace,n),i===null&&s!==null&&(i=s),i!==null&&(d.matrix.fromArray(i.transform.matrix),d.matrix.decompose(d.position,d.rotation,d.scale),d.matrixWorldNeedsUpdate=!0,i.linearVelocity?(d.hasLinearVelocity=!0,d.linearVelocity.copy(i.linearVelocity)):d.hasLinearVelocity=!1,i.angularVelocity?(d.hasAngularVelocity=!0,d.angularVelocity.copy(i.angularVelocity)):d.hasAngularVelocity=!1,this.dispatchEvent(qu)))}return d!==null&&(d.visible=i!==null),c!==null&&(c.visible=s!==null),o!==null&&(o.visible=a!==null),this}_getHandJoint(t,e){if(t.joints[e.jointName]===void 0){const n=new he;n.matrixAutoUpdate=!1,n.visible=!1,t.joints[e.jointName]=n,t.add(n)}return t.joints[e.jointName]}}const $u=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,tb=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class eb{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(t,e,n){if(this.texture===null){const i=new ge,s=t.properties.get(i);s.__webglTexture=e.texture,(e.depthNear!=n.depthNear||e.depthFar!=n.depthFar)&&(this.depthNear=e.depthNear,this.depthFar=e.depthFar),this.texture=i}}getMesh(t){if(this.texture!==null&&this.mesh===null){const e=t.cameras[0].viewport,n=new ce({vertexShader:$u,fragmentShader:tb,uniforms:{depthColor:{value:this.texture},depthWidth:{value:e.z},depthHeight:{value:e.w}}});this.mesh=new ee(new te(20,20),n)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class lb extends jl{constructor(t,e){super();const n=this;let i=null,s=1,a=null,d="local-floor",c=1,o=null,Z=null,m=null,b=null,h=null,p=null;const V=new eb,r=e.getContextAttributes();let u=null,C=null;const y=[],G=[],N=new ft;let I=null;const x=new Ke;x.viewport=new ie;const U=new Ke;U.viewport=new ie;const R=[x,U],g=new Ou;let Y=null,P=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(A){let tt=y[A];return tt===void 0&&(tt=new Da,y[A]=tt),tt.getTargetRaySpace()},this.getControllerGrip=function(A){let tt=y[A];return tt===void 0&&(tt=new Da,y[A]=tt),tt.getGripSpace()},this.getHand=function(A){let tt=y[A];return tt===void 0&&(tt=new Da,y[A]=tt),tt.getHandSpace()};function w(A){const tt=G.indexOf(A.inputSource);if(tt===-1)return;const pt=y[tt];pt!==void 0&&(pt.update(A.inputSource,A.frame,o||a),pt.dispatchEvent({type:A.type,data:A.inputSource}))}function E(){i.removeEventListener("select",w),i.removeEventListener("selectstart",w),i.removeEventListener("selectend",w),i.removeEventListener("squeeze",w),i.removeEventListener("squeezestart",w),i.removeEventListener("squeezeend",w),i.removeEventListener("end",E),i.removeEventListener("inputsourceschange",D);for(let A=0;A<y.length;A++){const tt=G[A];tt!==null&&(G[A]=null,y[A].disconnect(tt))}Y=null,P=null,V.reset(),t.setRenderTarget(u),h=null,b=null,m=null,i=null,C=null,Qt.stop(),n.isPresenting=!1,t.setPixelRatio(I),t.setSize(N.width,N.height,!1),n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(A){s=A,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(A){d=A,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o||a},this.setReferenceSpace=function(A){o=A},this.getBaseLayer=function(){return b!==null?b:h},this.getBinding=function(){return m},this.getFrame=function(){return p},this.getSession=function(){return i},this.setSession=async function(A){if(i=A,i!==null){if(u=t.getRenderTarget(),i.addEventListener("select",w),i.addEventListener("selectstart",w),i.addEventListener("selectend",w),i.addEventListener("squeeze",w),i.addEventListener("squeezestart",w),i.addEventListener("squeezeend",w),i.addEventListener("end",E),i.addEventListener("inputsourceschange",D),r.xrCompatible!==!0&&await e.makeXRCompatible(),I=t.getPixelRatio(),t.getSize(N),i.renderState.layers===void 0){const tt={antialias:r.antialias,alpha:!0,depth:r.depth,stencil:r.stencil,framebufferScaleFactor:s};h=new XRWebGLLayer(i,e,tt),i.updateRenderState({baseLayer:h}),t.setPixelRatio(1),t.setSize(h.framebufferWidth,h.framebufferHeight,!1),C=new bl(h.framebufferWidth,h.framebufferHeight,{format:Fe,type:Qe,colorSpace:t.outputColorSpace,stencilBuffer:r.stencil})}else{let tt=null,pt=null,it=null;r.depth&&(it=r.stencil?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT24,tt=r.stencil?Al:El,pt=r.stencil?Bl:Yl);const yt={colorFormat:e.RGBA8,depthFormat:it,scaleFactor:s};m=new XRWebGLBinding(i,e),b=m.createProjectionLayer(yt),i.updateRenderState({layers:[b]}),t.setPixelRatio(1),t.setSize(b.textureWidth,b.textureHeight,!1),C=new bl(b.textureWidth,b.textureHeight,{format:Fe,type:Qe,depthTexture:new Gd(b.textureWidth,b.textureHeight,pt,void 0,void 0,void 0,void 0,void 0,void 0,tt),stencilBuffer:r.stencil,colorSpace:t.outputColorSpace,samples:r.antialias?4:0,resolveDepthBuffer:b.ignoreDepthValues===!1})}C.isXRRenderTarget=!0,this.setFoveation(c),o=null,a=await i.requestReferenceSpace(d),Qt.setContext(i),Qt.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode},this.getDepthTexture=function(){return V.getDepthTexture()};function D(A){for(let tt=0;tt<A.removed.length;tt++){const pt=A.removed[tt],it=G.indexOf(pt);it>=0&&(G[it]=null,y[it].disconnect(pt))}for(let tt=0;tt<A.added.length;tt++){const pt=A.added[tt];let it=G.indexOf(pt);if(it===-1){for(let It=0;It<y.length;It++)if(It>=G.length){G.push(pt),it=It;break}else if(G[It]===null){G[It]=pt,it=It;break}if(it===-1)break}const yt=y[it];yt&&yt.connect(pt)}}const K=new J,$=new J;function H(A,tt,pt){K.setFromMatrixPosition(tt.matrixWorld),$.setFromMatrixPosition(pt.matrixWorld);const it=K.distanceTo($),yt=tt.projectionMatrix.elements,It=pt.projectionMatrix.elements,Ut=yt[14]/(yt[10]-1),le=yt[14]/(yt[10]+1),wt=(yt[9]+1)/yt[5],se=(yt[9]-1)/yt[5],M=(yt[8]-1)/yt[0],Te=(It[8]+1)/It[0],Tt=Ut*M,vt=Ut*Te,gt=it/(-M+Te),Ot=gt*-M;if(tt.matrixWorld.decompose(A.position,A.quaternion,A.scale),A.translateX(Ot),A.translateZ(gt),A.matrixWorld.compose(A.position,A.quaternion,A.scale),A.matrixWorldInverse.copy(A.matrixWorld).invert(),yt[10]===-1)A.projectionMatrix.copy(tt.projectionMatrix),A.projectionMatrixInverse.copy(tt.projectionMatrixInverse);else{const Xt=Ut+gt,S=le+gt,W=Tt-Ot,T=vt+(it-Ot),Q=wt*le/S*Xt,_=se*le/S*Xt;A.projectionMatrix.makePerspective(W,T,Q,_,Xt,S),A.projectionMatrixInverse.copy(A.projectionMatrix).invert()}}function nt(A,tt){tt===null?A.matrixWorld.copy(A.matrix):A.matrixWorld.multiplyMatrices(tt.matrixWorld,A.matrix),A.matrixWorldInverse.copy(A.matrixWorld).invert()}this.updateCamera=function(A){if(i===null)return;let tt=A.near,pt=A.far;V.texture!==null&&(V.depthNear>0&&(tt=V.depthNear),V.depthFar>0&&(pt=V.depthFar)),g.near=U.near=x.near=tt,g.far=U.far=x.far=pt,(Y!==g.near||P!==g.far)&&(i.updateRenderState({depthNear:g.near,depthFar:g.far}),Y=g.near,P=g.far),x.layers.mask=A.layers.mask|2,U.layers.mask=A.layers.mask|4,g.layers.mask=x.layers.mask|U.layers.mask;const it=A.parent,yt=g.cameras;nt(g,it);for(let It=0;It<yt.length;It++)nt(yt[It],it);yt.length===2?H(g,x,U):g.projectionMatrix.copy(x.projectionMatrix),ot(A,g,it)};function ot(A,tt,pt){pt===null?A.matrix.copy(tt.matrixWorld):(A.matrix.copy(pt.matrixWorld),A.matrix.invert(),A.matrix.multiply(tt.matrixWorld)),A.matrix.decompose(A.position,A.quaternion,A.scale),A.updateMatrixWorld(!0),A.projectionMatrix.copy(tt.projectionMatrix),A.projectionMatrixInverse.copy(tt.projectionMatrixInverse),A.isPerspectiveCamera&&(A.fov=Xn*2*Math.atan(1/A.projectionMatrix.elements[5]),A.zoom=1)}this.getCamera=function(){return g},this.getFoveation=function(){if(!(b===null&&h===null))return c},this.setFoveation=function(A){c=A,b!==null&&(b.fixedFoveation=A),h!==null&&h.fixedFoveation!==void 0&&(h.fixedFoveation=A)},this.hasDepthSensing=function(){return V.texture!==null},this.getDepthSensingMesh=function(){return V.getMesh(g)};let Vt=null;function Mt(A,tt){if(Z=tt.getViewerPose(o||a),p=tt,Z!==null){const pt=Z.views;h!==null&&(t.setRenderTargetFramebuffer(C,h.framebuffer),t.setRenderTarget(C));let it=!1;pt.length!==g.cameras.length&&(g.cameras.length=0,it=!0);for(let It=0;It<pt.length;It++){const Ut=pt[It];let le=null;if(h!==null)le=h.getViewport(Ut);else{const se=m.getViewSubImage(b,Ut);le=se.viewport,It===0&&(t.setRenderTargetTextures(C,se.colorTexture,b.ignoreDepthValues?void 0:se.depthStencilTexture),t.setRenderTarget(C))}let wt=R[It];wt===void 0&&(wt=new Ke,wt.layers.enable(It),wt.viewport=new ie,R[It]=wt),wt.matrix.fromArray(Ut.transform.matrix),wt.matrix.decompose(wt.position,wt.quaternion,wt.scale),wt.projectionMatrix.fromArray(Ut.projectionMatrix),wt.projectionMatrixInverse.copy(wt.projectionMatrix).invert(),wt.viewport.set(le.x,le.y,le.width,le.height),It===0&&(g.matrix.copy(wt.matrix),g.matrix.decompose(g.position,g.quaternion,g.scale)),it===!0&&g.cameras.push(wt)}const yt=i.enabledFeatures;if(yt&&yt.includes("depth-sensing")){const It=m.getDepthInformation(pt[0]);It&&It.isValid&&It.texture&&V.init(t,It,i.renderState)}}for(let pt=0;pt<y.length;pt++){const it=G[pt],yt=y[pt];it!==null&&yt!==void 0&&yt.update(it,tt,o||a)}Vt&&Vt(A,tt),tt.detectedPlanes&&n.dispatchEvent({type:"planesdetected",data:tt}),p=null}const Qt=new od;Qt.setAnimationLoop(Mt),this.setAnimationLoop=function(A){Vt=A},this.dispose=function(){}}}const kl=new il,nb=new ae;function ib(l,t){function e(r,u){r.matrixAutoUpdate===!0&&r.updateMatrix(),u.value.copy(r.matrix)}function n(r,u){u.color.getRGB(r.fogColor.value,nd(l)),u.isFog?(r.fogNear.value=u.near,r.fogFar.value=u.far):u.isFogExp2&&(r.fogDensity.value=u.density)}function i(r,u,C,y,G){u.isMeshBasicMaterial||u.isMeshLambertMaterial?s(r,u):u.isMeshToonMaterial?(s(r,u),m(r,u)):u.isMeshPhongMaterial?(s(r,u),Z(r,u)):u.isMeshStandardMaterial?(s(r,u),b(r,u),u.isMeshPhysicalMaterial&&h(r,u,G)):u.isMeshMatcapMaterial?(s(r,u),p(r,u)):u.isMeshDepthMaterial?s(r,u):u.isMeshDistanceMaterial?(s(r,u),V(r,u)):u.isMeshNormalMaterial?s(r,u):u.isLineBasicMaterial?(a(r,u),u.isLineDashedMaterial&&d(r,u)):u.isPointsMaterial?c(r,u,C,y):u.isSpriteMaterial?o(r,u):u.isShadowMaterial?(r.color.value.copy(u.color),r.opacity.value=u.opacity):u.isShaderMaterial&&(u.uniformsNeedUpdate=!1)}function s(r,u){r.opacity.value=u.opacity,u.color&&r.diffuse.value.copy(u.color),u.emissive&&r.emissive.value.copy(u.emissive).multiplyScalar(u.emissiveIntensity),u.map&&(r.map.value=u.map,e(u.map,r.mapTransform)),u.alphaMap&&(r.alphaMap.value=u.alphaMap,e(u.alphaMap,r.alphaMapTransform)),u.bumpMap&&(r.bumpMap.value=u.bumpMap,e(u.bumpMap,r.bumpMapTransform),r.bumpScale.value=u.bumpScale,u.side===ye&&(r.bumpScale.value*=-1)),u.normalMap&&(r.normalMap.value=u.normalMap,e(u.normalMap,r.normalMapTransform),r.normalScale.value.copy(u.normalScale),u.side===ye&&r.normalScale.value.negate()),u.displacementMap&&(r.displacementMap.value=u.displacementMap,e(u.displacementMap,r.displacementMapTransform),r.displacementScale.value=u.displacementScale,r.displacementBias.value=u.displacementBias),u.emissiveMap&&(r.emissiveMap.value=u.emissiveMap,e(u.emissiveMap,r.emissiveMapTransform)),u.specularMap&&(r.specularMap.value=u.specularMap,e(u.specularMap,r.specularMapTransform)),u.alphaTest>0&&(r.alphaTest.value=u.alphaTest);const C=t.get(u),y=C.envMap,G=C.envMapRotation;y&&(r.envMap.value=y,kl.copy(G),kl.x*=-1,kl.y*=-1,kl.z*=-1,y.isCubeTexture&&y.isRenderTargetTexture===!1&&(kl.y*=-1,kl.z*=-1),r.envMapRotation.value.setFromMatrix4(nb.makeRotationFromEuler(kl)),r.flipEnvMap.value=y.isCubeTexture&&y.isRenderTargetTexture===!1?-1:1,r.reflectivity.value=u.reflectivity,r.ior.value=u.ior,r.refractionRatio.value=u.refractionRatio),u.lightMap&&(r.lightMap.value=u.lightMap,r.lightMapIntensity.value=u.lightMapIntensity,e(u.lightMap,r.lightMapTransform)),u.aoMap&&(r.aoMap.value=u.aoMap,r.aoMapIntensity.value=u.aoMapIntensity,e(u.aoMap,r.aoMapTransform))}function a(r,u){r.diffuse.value.copy(u.color),r.opacity.value=u.opacity,u.map&&(r.map.value=u.map,e(u.map,r.mapTransform))}function d(r,u){r.dashSize.value=u.dashSize,r.totalSize.value=u.dashSize+u.gapSize,r.scale.value=u.scale}function c(r,u,C,y){r.diffuse.value.copy(u.color),r.opacity.value=u.opacity,r.size.value=u.size*C,r.scale.value=y*.5,u.map&&(r.map.value=u.map,e(u.map,r.uvTransform)),u.alphaMap&&(r.alphaMap.value=u.alphaMap,e(u.alphaMap,r.alphaMapTransform)),u.alphaTest>0&&(r.alphaTest.value=u.alphaTest)}function o(r,u){r.diffuse.value.copy(u.color),r.opacity.value=u.opacity,r.rotation.value=u.rotation,u.map&&(r.map.value=u.map,e(u.map,r.mapTransform)),u.alphaMap&&(r.alphaMap.value=u.alphaMap,e(u.alphaMap,r.alphaMapTransform)),u.alphaTest>0&&(r.alphaTest.value=u.alphaTest)}function Z(r,u){r.specular.value.copy(u.specular),r.shininess.value=Math.max(u.shininess,1e-4)}function m(r,u){u.gradientMap&&(r.gradientMap.value=u.gradientMap)}function b(r,u){r.metalness.value=u.metalness,u.metalnessMap&&(r.metalnessMap.value=u.metalnessMap,e(u.metalnessMap,r.metalnessMapTransform)),r.roughness.value=u.roughness,u.roughnessMap&&(r.roughnessMap.value=u.roughnessMap,e(u.roughnessMap,r.roughnessMapTransform)),u.envMap&&(r.envMapIntensity.value=u.envMapIntensity)}function h(r,u,C){r.ior.value=u.ior,u.sheen>0&&(r.sheenColor.value.copy(u.sheenColor).multiplyScalar(u.sheen),r.sheenRoughness.value=u.sheenRoughness,u.sheenColorMap&&(r.sheenColorMap.value=u.sheenColorMap,e(u.sheenColorMap,r.sheenColorMapTransform)),u.sheenRoughnessMap&&(r.sheenRoughnessMap.value=u.sheenRoughnessMap,e(u.sheenRoughnessMap,r.sheenRoughnessMapTransform))),u.clearcoat>0&&(r.clearcoat.value=u.clearcoat,r.clearcoatRoughness.value=u.clearcoatRoughness,u.clearcoatMap&&(r.clearcoatMap.value=u.clearcoatMap,e(u.clearcoatMap,r.clearcoatMapTransform)),u.clearcoatRoughnessMap&&(r.clearcoatRoughnessMap.value=u.clearcoatRoughnessMap,e(u.clearcoatRoughnessMap,r.clearcoatRoughnessMapTransform)),u.clearcoatNormalMap&&(r.clearcoatNormalMap.value=u.clearcoatNormalMap,e(u.clearcoatNormalMap,r.clearcoatNormalMapTransform),r.clearcoatNormalScale.value.copy(u.clearcoatNormalScale),u.side===ye&&r.clearcoatNormalScale.value.negate())),u.dispersion>0&&(r.dispersion.value=u.dispersion),u.iridescence>0&&(r.iridescence.value=u.iridescence,r.iridescenceIOR.value=u.iridescenceIOR,r.iridescenceThicknessMinimum.value=u.iridescenceThicknessRange[0],r.iridescenceThicknessMaximum.value=u.iridescenceThicknessRange[1],u.iridescenceMap&&(r.iridescenceMap.value=u.iridescenceMap,e(u.iridescenceMap,r.iridescenceMapTransform)),u.iridescenceThicknessMap&&(r.iridescenceThicknessMap.value=u.iridescenceThicknessMap,e(u.iridescenceThicknessMap,r.iridescenceThicknessMapTransform))),u.transmission>0&&(r.transmission.value=u.transmission,r.transmissionSamplerMap.value=C.texture,r.transmissionSamplerSize.value.set(C.width,C.height),u.transmissionMap&&(r.transmissionMap.value=u.transmissionMap,e(u.transmissionMap,r.transmissionMapTransform)),r.thickness.value=u.thickness,u.thicknessMap&&(r.thicknessMap.value=u.thicknessMap,e(u.thicknessMap,r.thicknessMapTransform)),r.attenuationDistance.value=u.attenuationDistance,r.attenuationColor.value.copy(u.attenuationColor)),u.anisotropy>0&&(r.anisotropyVector.value.set(u.anisotropy*Math.cos(u.anisotropyRotation),u.anisotropy*Math.sin(u.anisotropyRotation)),u.anisotropyMap&&(r.anisotropyMap.value=u.anisotropyMap,e(u.anisotropyMap,r.anisotropyMapTransform))),r.specularIntensity.value=u.specularIntensity,r.specularColor.value.copy(u.specularColor),u.specularColorMap&&(r.specularColorMap.value=u.specularColorMap,e(u.specularColorMap,r.specularColorMapTransform)),u.specularIntensityMap&&(r.specularIntensityMap.value=u.specularIntensityMap,e(u.specularIntensityMap,r.specularIntensityMapTransform))}function p(r,u){u.matcap&&(r.matcap.value=u.matcap)}function V(r,u){const C=t.get(u).light;r.referencePosition.value.setFromMatrixPosition(C.matrixWorld),r.nearDistance.value=C.shadow.camera.near,r.farDistance.value=C.shadow.camera.far}return{refreshFogUniforms:n,refreshMaterialUniforms:i}}function ab(l,t,e,n){let i={},s={},a=[];const d=l.getParameter(l.MAX_UNIFORM_BUFFER_BINDINGS);function c(C,y){const G=y.program;n.uniformBlockBinding(C,G)}function o(C,y){let G=i[C.id];G===void 0&&(p(C),G=Z(C),i[C.id]=G,C.addEventListener("dispose",r));const N=y.program;n.updateUBOMapping(C,N);const I=t.render.frame;s[C.id]!==I&&(b(C),s[C.id]=I)}function Z(C){const y=m();C.__bindingPointIndex=y;const G=l.createBuffer(),N=C.__size,I=C.usage;return l.bindBuffer(l.UNIFORM_BUFFER,G),l.bufferData(l.UNIFORM_BUFFER,N,I),l.bindBuffer(l.UNIFORM_BUFFER,null),l.bindBufferBase(l.UNIFORM_BUFFER,y,G),G}function m(){for(let C=0;C<d;C++)if(a.indexOf(C)===-1)return a.push(C),C;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function b(C){const y=i[C.id],G=C.uniforms,N=C.__cache;l.bindBuffer(l.UNIFORM_BUFFER,y);for(let I=0,x=G.length;I<x;I++){const U=Array.isArray(G[I])?G[I]:[G[I]];for(let R=0,g=U.length;R<g;R++){const Y=U[R];if(h(Y,I,R,N)===!0){const P=Y.__offset,w=Array.isArray(Y.value)?Y.value:[Y.value];let E=0;for(let D=0;D<w.length;D++){const K=w[D],$=V(K);typeof K=="number"||typeof K=="boolean"?(Y.__data[0]=K,l.bufferSubData(l.UNIFORM_BUFFER,P+E,Y.__data)):K.isMatrix3?(Y.__data[0]=K.elements[0],Y.__data[1]=K.elements[1],Y.__data[2]=K.elements[2],Y.__data[3]=0,Y.__data[4]=K.elements[3],Y.__data[5]=K.elements[4],Y.__data[6]=K.elements[5],Y.__data[7]=0,Y.__data[8]=K.elements[6],Y.__data[9]=K.elements[7],Y.__data[10]=K.elements[8],Y.__data[11]=0):(K.toArray(Y.__data,E),E+=$.storage/Float32Array.BYTES_PER_ELEMENT)}l.bufferSubData(l.UNIFORM_BUFFER,P,Y.__data)}}}l.bindBuffer(l.UNIFORM_BUFFER,null)}function h(C,y,G,N){const I=C.value,x=y+"_"+G;if(N[x]===void 0)return typeof I=="number"||typeof I=="boolean"?N[x]=I:N[x]=I.clone(),!0;{const U=N[x];if(typeof I=="number"||typeof I=="boolean"){if(U!==I)return N[x]=I,!0}else if(U.equals(I)===!1)return U.copy(I),!0}return!1}function p(C){const y=C.uniforms;let G=0;const N=16;for(let x=0,U=y.length;x<U;x++){const R=Array.isArray(y[x])?y[x]:[y[x]];for(let g=0,Y=R.length;g<Y;g++){const P=R[g],w=Array.isArray(P.value)?P.value:[P.value];for(let E=0,D=w.length;E<D;E++){const K=w[E],$=V(K),H=G%N,nt=H%$.boundary,ot=H+nt;G+=nt,ot!==0&&N-ot<$.storage&&(G+=N-ot),P.__data=new Float32Array($.storage/Float32Array.BYTES_PER_ELEMENT),P.__offset=G,G+=$.storage}}}const I=G%N;return I>0&&(G+=N-I),C.__size=G,C.__cache={},this}function V(C){const y={boundary:0,storage:0};return typeof C=="number"||typeof C=="boolean"?(y.boundary=4,y.storage=4):C.isVector2?(y.boundary=8,y.storage=8):C.isVector3||C.isColor?(y.boundary=16,y.storage=12):C.isVector4?(y.boundary=16,y.storage=16):C.isMatrix3?(y.boundary=48,y.storage=48):C.isMatrix4?(y.boundary=64,y.storage=64):C.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",C),y}function r(C){const y=C.target;y.removeEventListener("dispose",r);const G=a.indexOf(y.__bindingPointIndex);a.splice(G,1),l.deleteBuffer(i[y.id]),delete i[y.id],delete s[y.id]}function u(){for(const C in i)l.deleteBuffer(i[C]);a=[],i={},s={}}return{bind:c,update:o,dispose:u}}class sb{constructor(t={}){const{canvas:e=Yo(),context:n=null,depth:i=!0,stencil:s=!1,alpha:a=!1,antialias:d=!1,premultipliedAlpha:c=!0,preserveDrawingBuffer:o=!1,powerPreference:Z="default",failIfMajorPerformanceCaveat:m=!1,reverseDepthBuffer:b=!1}=t;this.isWebGLRenderer=!0;let h;if(n!==null){if(typeof WebGLRenderingContext<"u"&&n instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");h=n.getContextAttributes().alpha}else h=a;const p=new Uint32Array(4),V=new Int32Array(4);let r=null,u=null;const C=[],y=[];this.domElement=e,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=Le,this.toneMapping=hl,this.toneMappingExposure=1;const G=this;let N=!1,I=0,x=0,U=null,R=-1,g=null;const Y=new ie,P=new ie;let w=null;const E=new Kt(0);let D=0,K=e.width,$=e.height,H=1,nt=null,ot=null;const Vt=new ie(0,0,K,$),Mt=new ie(0,0,K,$);let Qt=!1;const A=new cd;let tt=!1,pt=!1;const it=new ae,yt=new ae,It=new J,Ut=new ie,le={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let wt=!1;function se(){return U===null?H:1}let M=n;function Te(X,F){return e.getContext(X,F)}try{const X={alpha:!0,depth:i,stencil:s,antialias:d,premultipliedAlpha:c,preserveDrawingBuffer:o,powerPreference:Z,failIfMajorPerformanceCaveat:m};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${xi}`),e.addEventListener("webglcontextlost",j,!1),e.addEventListener("webglcontextrestored",ct,!1),e.addEventListener("webglcontextcreationerror",st,!1),M===null){const F="webgl2";if(M=Te(F,X),M===null)throw Te(F)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(X){throw console.error("THREE.WebGLRenderer: "+X.message),X}let Tt,vt,gt,Ot,Xt,S,W,T,Q,_,B,Gt,at,mt,zt,O,Zt,Rt,Ct,ht,Jt,Lt,_t,f;function lt(){Tt=new Zh(M),Tt.init(),Lt=new Du(M,Tt),vt=new ah(M,Tt,t,Lt),gt=new Qu(M,Tt),vt.reverseDepthBuffer&&b&&gt.buffers.depth.setReversed(!0),Ot=new bh(M),Xt=new Lu,S=new _u(M,Tt,gt,Xt,vt,Lt,Ot),W=new dh(G),T=new mh(G),Q=new em(M),_t=new nh(M,Q),_=new hh(M,Q,Ot,_t),B=new ph(M,_,Q,Ot),Ct=new rh(M,vt,S),O=new sh(Xt),Gt=new Fu(G,W,T,Tt,vt,_t,O),at=new ib(G,Xt),mt=new Uu,zt=new zu(Tt),Rt=new lh(G,W,T,gt,B,h,c),Zt=new Au(G,B,vt),f=new ab(M,Ot,vt,gt),ht=new ih(M,Tt,Ot),Jt=new uh(M,Tt,Ot),Ot.programs=Gt.programs,G.capabilities=vt,G.extensions=Tt,G.properties=Xt,G.renderLists=mt,G.shadowMap=Zt,G.state=gt,G.info=Ot}lt();const z=new lb(G,M);this.xr=z,this.getContext=function(){return M},this.getContextAttributes=function(){return M.getContextAttributes()},this.forceContextLoss=function(){const X=Tt.get("WEBGL_lose_context");X&&X.loseContext()},this.forceContextRestore=function(){const X=Tt.get("WEBGL_lose_context");X&&X.restoreContext()},this.getPixelRatio=function(){return H},this.setPixelRatio=function(X){X!==void 0&&(H=X,this.setSize(K,$,!1))},this.getSize=function(X){return X.set(K,$)},this.setSize=function(X,F,v=!0){if(z.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}K=X,$=F,e.width=Math.floor(X*H),e.height=Math.floor(F*H),v===!0&&(e.style.width=X+"px",e.style.height=F+"px"),this.setViewport(0,0,X,F)},this.getDrawingBufferSize=function(X){return X.set(K*H,$*H).floor()},this.setDrawingBufferSize=function(X,F,v){K=X,$=F,H=v,e.width=Math.floor(X*v),e.height=Math.floor(F*v),this.setViewport(0,0,X,F)},this.getCurrentViewport=function(X){return X.copy(Y)},this.getViewport=function(X){return X.copy(Vt)},this.setViewport=function(X,F,v,k){X.isVector4?Vt.set(X.x,X.y,X.z,X.w):Vt.set(X,F,v,k),gt.viewport(Y.copy(Vt).multiplyScalar(H).round())},this.getScissor=function(X){return X.copy(Mt)},this.setScissor=function(X,F,v,k){X.isVector4?Mt.set(X.x,X.y,X.z,X.w):Mt.set(X,F,v,k),gt.scissor(P.copy(Mt).multiplyScalar(H).round())},this.getScissorTest=function(){return Qt},this.setScissorTest=function(X){gt.setScissorTest(Qt=X)},this.setOpaqueSort=function(X){nt=X},this.setTransparentSort=function(X){ot=X},this.getClearColor=function(X){return X.copy(Rt.getClearColor())},this.setClearColor=function(){Rt.setClearColor.apply(Rt,arguments)},this.getClearAlpha=function(){return Rt.getClearAlpha()},this.setClearAlpha=function(){Rt.setClearAlpha.apply(Rt,arguments)},this.clear=function(X=!0,F=!0,v=!0){let k=0;if(X){let L=!1;if(U!==null){const q=U.texture.format;L=q===Qi||q===Pi||q===Ai}if(L){const q=U.texture.type,dt=q===Qe||q===Yl||q===Gn||q===Bl||q===Bi||q===Ei,ut=Rt.getClearColor(),bt=Rt.getClearAlpha(),St=ut.r,Nt=ut.g,rt=ut.b;dt?(p[0]=St,p[1]=Nt,p[2]=rt,p[3]=bt,M.clearBufferuiv(M.COLOR,0,p)):(V[0]=St,V[1]=Nt,V[2]=rt,V[3]=bt,M.clearBufferiv(M.COLOR,0,V))}else k|=M.COLOR_BUFFER_BIT}F&&(k|=M.DEPTH_BUFFER_BIT),v&&(k|=M.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),M.clear(k)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",j,!1),e.removeEventListener("webglcontextrestored",ct,!1),e.removeEventListener("webglcontextcreationerror",st,!1),mt.dispose(),zt.dispose(),Xt.dispose(),W.dispose(),T.dispose(),B.dispose(),_t.dispose(),f.dispose(),Gt.dispose(),z.dispose(),z.removeEventListener("sessionstart",rc),z.removeEventListener("sessionend",pc),wl.stop()};function j(X){X.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),N=!0}function ct(){console.log("THREE.WebGLRenderer: Context Restored."),N=!1;const X=Ot.autoReset,F=Zt.enabled,v=Zt.autoUpdate,k=Zt.needsUpdate,L=Zt.type;lt(),Ot.autoReset=X,Zt.enabled=F,Zt.autoUpdate=v,Zt.needsUpdate=k,Zt.type=L}function st(X){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",X.statusMessage)}function Yt(X){const F=X.target;F.removeEventListener("dispose",Yt),ne(F)}function ne(X){We(X),Xt.remove(X)}function We(X){const F=Xt.get(X).programs;F!==void 0&&(F.forEach(function(v){Gt.releaseProgram(v)}),X.isShaderMaterial&&Gt.releaseShaderCache(X))}this.renderBufferDirect=function(X,F,v,k,L,q){F===null&&(F=le);const dt=L.isMesh&&L.matrixWorld.determinant()<0,ut=Db(X,F,v,k,L);gt.setMaterial(k,dt);let bt=v.index,St=1;if(k.wireframe===!0){if(bt=_.getWireframeAttribute(v),bt===void 0)return;St=2}const Nt=v.drawRange,rt=v.attributes.position;let Ht=Nt.start*St,Dt=(Nt.start+Nt.count)*St;q!==null&&(Ht=Math.max(Ht,q.start*St),Dt=Math.min(Dt,(q.start+q.count)*St)),bt!==null?(Ht=Math.max(Ht,0),Dt=Math.min(Dt,bt.count)):rt!=null&&(Ht=Math.max(Ht,0),Dt=Math.min(Dt,rt.count));const qt=Dt-Ht;if(qt<0||qt===1/0)return;_t.setup(L,k,ut,v,bt);let Ie,Bt=ht;if(bt!==null&&(Ie=Q.get(bt),Bt=Jt,Bt.setIndex(Ie)),L.isMesh)k.wireframe===!0?(gt.setLineWidth(k.wireframeLinewidth*se()),Bt.setMode(M.LINES)):Bt.setMode(M.TRIANGLES);else if(L.isLine){let Wt=k.linewidth;Wt===void 0&&(Wt=1),gt.setLineWidth(Wt*se()),L.isLineSegments?Bt.setMode(M.LINES):L.isLineLoop?Bt.setMode(M.LINE_LOOP):Bt.setMode(M.LINE_STRIP)}else L.isPoints?Bt.setMode(M.POINTS):L.isSprite&&Bt.setMode(M.TRIANGLES);if(L.isBatchedMesh)if(L._multiDrawInstances!==null)Bt.renderMultiDrawInstances(L._multiDrawStarts,L._multiDrawCounts,L._multiDrawCount,L._multiDrawInstances);else if(Tt.get("WEBGL_multi_draw"))Bt.renderMultiDraw(L._multiDrawStarts,L._multiDrawCounts,L._multiDrawCount);else{const Wt=L._multiDrawStarts,ol=L._multiDrawCounts,Et=L._multiDrawCount,Ae=bt?Q.get(bt).bytesPerElement:1,pn=Xt.get(k).currentProgram.getUniforms();for(let Ne=0;Ne<Et;Ne++)pn.setValue(M,"_gl_DrawID",Ne),Bt.render(Wt[Ne]/Ae,ol[Ne])}else if(L.isInstancedMesh)Bt.renderInstances(Ht,qt,L.count);else if(v.isInstancedBufferGeometry){const Wt=v._maxInstanceCount!==void 0?v._maxInstanceCount:1/0,ol=Math.min(v.instanceCount,Wt);Bt.renderInstances(Ht,qt,ol)}else Bt.render(Ht,qt)};function At(X,F,v){X.transparent===!0&&X.side===qe&&X.forceSinglePass===!1?(X.side=ye,X.needsUpdate=!0,Ii(X,F,v),X.side=ml,X.needsUpdate=!0,Ii(X,F,v),X.side=qe):Ii(X,F,v)}this.compile=function(X,F,v=null){v===null&&(v=X),u=zt.get(v),u.init(F),y.push(u),v.traverseVisible(function(L){L.isLight&&L.layers.test(F.layers)&&(u.pushLight(L),L.castShadow&&u.pushShadow(L))}),X!==v&&X.traverseVisible(function(L){L.isLight&&L.layers.test(F.layers)&&(u.pushLight(L),L.castShadow&&u.pushShadow(L))}),u.setupLights();const k=new Set;return X.traverse(function(L){if(!(L.isMesh||L.isPoints||L.isLine||L.isSprite))return;const q=L.material;if(q)if(Array.isArray(q))for(let dt=0;dt<q.length;dt++){const ut=q[dt];At(ut,v,L),k.add(ut)}else At(q,v,L),k.add(q)}),y.pop(),u=null,k},this.compileAsync=function(X,F,v=null){const k=this.compile(X,F,v);return new Promise(L=>{function q(){if(k.forEach(function(dt){Xt.get(dt).currentProgram.isReady()&&k.delete(dt)}),k.size===0){L(X);return}setTimeout(q,10)}Tt.get("KHR_parallel_shader_compile")!==null?q():setTimeout(q,10)})};let Ee=null;function cl(X){Ee&&Ee(X)}function rc(){wl.stop()}function pc(){wl.start()}const wl=new od;wl.setAnimationLoop(cl),typeof self<"u"&&wl.setContext(self),this.setAnimationLoop=function(X){Ee=X,z.setAnimationLoop(X),X===null?wl.stop():wl.start()},z.addEventListener("sessionstart",rc),z.addEventListener("sessionend",pc),this.render=function(X,F){if(F!==void 0&&F.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(N===!0)return;if(X.matrixWorldAutoUpdate===!0&&X.updateMatrixWorld(),F.parent===null&&F.matrixWorldAutoUpdate===!0&&F.updateMatrixWorld(),z.enabled===!0&&z.isPresenting===!0&&(z.cameraAutoUpdate===!0&&z.updateCamera(F),F=z.getCamera()),X.isScene===!0&&X.onBeforeRender(G,X,F,U),u=zt.get(X,y.length),u.init(F),y.push(u),yt.multiplyMatrices(F.projectionMatrix,F.matrixWorldInverse),A.setFromProjectionMatrix(yt),pt=this.localClippingEnabled,tt=O.init(this.clippingPlanes,pt),r=mt.get(X,C.length),r.init(),C.push(r),z.enabled===!0&&z.isPresenting===!0){const q=G.xr.getDepthSensingMesh();q!==null&&cs(q,F,-1/0,G.sortObjects)}cs(X,F,0,G.sortObjects),r.finish(),G.sortObjects===!0&&r.sort(nt,ot),wt=z.enabled===!1||z.isPresenting===!1||z.hasDepthSensing()===!1,wt&&Rt.addToRenderList(r,X),this.info.render.frame++,tt===!0&&O.beginShadows();const v=u.state.shadowsArray;Zt.render(v,X,F),tt===!0&&O.endShadows(),this.info.autoReset===!0&&this.info.reset();const k=r.opaque,L=r.transmissive;if(u.setupLights(),F.isArrayCamera){const q=F.cameras;if(L.length>0)for(let dt=0,ut=q.length;dt<ut;dt++){const bt=q[dt];Wc(k,L,X,bt)}wt&&Rt.render(X);for(let dt=0,ut=q.length;dt<ut;dt++){const bt=q[dt];Gc(r,X,bt,bt.viewport)}}else L.length>0&&Wc(k,L,X,F),wt&&Rt.render(X),Gc(r,X,F);U!==null&&(S.updateMultisampleRenderTarget(U),S.updateRenderTargetMipmap(U)),X.isScene===!0&&X.onAfterRender(G,X,F),_t.resetDefaultState(),R=-1,g=null,y.pop(),y.length>0?(u=y[y.length-1],tt===!0&&O.setGlobalState(G.clippingPlanes,u.state.camera)):u=null,C.pop(),C.length>0?r=C[C.length-1]:r=null};function cs(X,F,v,k){if(X.visible===!1)return;if(X.layers.test(F.layers)){if(X.isGroup)v=X.renderOrder;else if(X.isLOD)X.autoUpdate===!0&&X.update(F);else if(X.isLight)u.pushLight(X),X.castShadow&&u.pushShadow(X);else if(X.isSprite){if(!X.frustumCulled||A.intersectsSprite(X)){k&&Ut.setFromMatrixPosition(X.matrixWorld).applyMatrix4(yt);const dt=B.update(X),ut=X.material;ut.visible&&r.push(X,dt,ut,v,Ut.z,null)}}else if((X.isMesh||X.isLine||X.isPoints)&&(!X.frustumCulled||A.intersectsObject(X))){const dt=B.update(X),ut=X.material;if(k&&(X.boundingSphere!==void 0?(X.boundingSphere===null&&X.computeBoundingSphere(),Ut.copy(X.boundingSphere.center)):(dt.boundingSphere===null&&dt.computeBoundingSphere(),Ut.copy(dt.boundingSphere.center)),Ut.applyMatrix4(X.matrixWorld).applyMatrix4(yt)),Array.isArray(ut)){const bt=dt.groups;for(let St=0,Nt=bt.length;St<Nt;St++){const rt=bt[St],Ht=ut[rt.materialIndex];Ht&&Ht.visible&&r.push(X,dt,Ht,v,Ut.z,rt)}}else ut.visible&&r.push(X,dt,ut,v,Ut.z,null)}}const q=X.children;for(let dt=0,ut=q.length;dt<ut;dt++)cs(q[dt],F,v,k)}function Gc(X,F,v,k){const L=X.opaque,q=X.transmissive,dt=X.transparent;u.setupLightsView(v),tt===!0&&O.setGlobalState(G.clippingPlanes,v),k&&gt.viewport(Y.copy(k)),L.length>0&&Si(L,F,v),q.length>0&&Si(q,F,v),dt.length>0&&Si(dt,F,v),gt.buffers.depth.setTest(!0),gt.buffers.depth.setMask(!0),gt.buffers.color.setMask(!0),gt.setPolygonOffset(!1)}function Wc(X,F,v,k){if((v.isScene===!0?v.overrideMaterial:null)!==null)return;u.state.transmissionRenderTarget[k.id]===void 0&&(u.state.transmissionRenderTarget[k.id]=new bl(1,1,{generateMipmaps:!0,type:Tt.has("EXT_color_buffer_half_float")||Tt.has("EXT_color_buffer_float")?Wn:Qe,minFilter:xl,samples:4,stencilBuffer:s,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:kt.workingColorSpace}));const q=u.state.transmissionRenderTarget[k.id],dt=k.viewport||Y;q.setSize(dt.z,dt.w);const ut=G.getRenderTarget();G.setRenderTarget(q),G.getClearColor(E),D=G.getClearAlpha(),D<1&&G.setClearColor(16777215,.5),G.clear(),wt&&Rt.render(v);const bt=G.toneMapping;G.toneMapping=hl;const St=k.viewport;if(k.viewport!==void 0&&(k.viewport=void 0),u.setupLightsView(k),tt===!0&&O.setGlobalState(G.clippingPlanes,k),Si(X,v,k),S.updateMultisampleRenderTarget(q),S.updateRenderTargetMipmap(q),Tt.has("WEBGL_multisampled_render_to_texture")===!1){let Nt=!1;for(let rt=0,Ht=F.length;rt<Ht;rt++){const Dt=F[rt],qt=Dt.object,Ie=Dt.geometry,Bt=Dt.material,Wt=Dt.group;if(Bt.side===qe&&qt.layers.test(k.layers)){const ol=Bt.side;Bt.side=ye,Bt.needsUpdate=!0,Vc(qt,v,k,Ie,Bt,Wt),Bt.side=ol,Bt.needsUpdate=!0,Nt=!0}}Nt===!0&&(S.updateMultisampleRenderTarget(q),S.updateRenderTargetMipmap(q))}G.setRenderTarget(ut),G.setClearColor(E,D),St!==void 0&&(k.viewport=St),G.toneMapping=bt}function Si(X,F,v){const k=F.isScene===!0?F.overrideMaterial:null;for(let L=0,q=X.length;L<q;L++){const dt=X[L],ut=dt.object,bt=dt.geometry,St=k===null?dt.material:k,Nt=dt.group;ut.layers.test(v.layers)&&Vc(ut,F,v,bt,St,Nt)}}function Vc(X,F,v,k,L,q){X.onBeforeRender(G,F,v,k,L,q),X.modelViewMatrix.multiplyMatrices(v.matrixWorldInverse,X.matrixWorld),X.normalMatrix.getNormalMatrix(X.modelViewMatrix),L.onBeforeRender(G,F,v,k,X,q),L.transparent===!0&&L.side===qe&&L.forceSinglePass===!1?(L.side=ye,L.needsUpdate=!0,G.renderBufferDirect(v,F,k,L,X,q),L.side=ml,L.needsUpdate=!0,G.renderBufferDirect(v,F,k,L,X,q),L.side=qe):G.renderBufferDirect(v,F,k,L,X,q),X.onAfterRender(G,F,v,k,L,q)}function Ii(X,F,v){F.isScene!==!0&&(F=le);const k=Xt.get(X),L=u.state.lights,q=u.state.shadowsArray,dt=L.state.version,ut=Gt.getParameters(X,L.state,q,F,v),bt=Gt.getProgramCacheKey(ut);let St=k.programs;k.environment=X.isMeshStandardMaterial?F.environment:null,k.fog=F.fog,k.envMap=(X.isMeshStandardMaterial?T:W).get(X.envMap||k.environment),k.envMapRotation=k.environment!==null&&X.envMap===null?F.environmentRotation:X.envMapRotation,St===void 0&&(X.addEventListener("dispose",Yt),St=new Map,k.programs=St);let Nt=St.get(bt);if(Nt!==void 0){if(k.currentProgram===Nt&&k.lightsStateVersion===dt)return gc(X,ut),Nt}else ut.uniforms=Gt.getUniforms(X),X.onBeforeCompile(ut,G),Nt=Gt.acquireProgram(ut,bt),St.set(bt,Nt),k.uniforms=ut.uniforms;const rt=k.uniforms;return(!X.isShaderMaterial&&!X.isRawShaderMaterial||X.clipping===!0)&&(rt.clippingPlanes=O.uniform),gc(X,ut),k.needsLights=qb(X),k.lightsStateVersion=dt,k.needsLights&&(rt.ambientLightColor.value=L.state.ambient,rt.lightProbe.value=L.state.probe,rt.directionalLights.value=L.state.directional,rt.directionalLightShadows.value=L.state.directionalShadow,rt.spotLights.value=L.state.spot,rt.spotLightShadows.value=L.state.spotShadow,rt.rectAreaLights.value=L.state.rectArea,rt.ltc_1.value=L.state.rectAreaLTC1,rt.ltc_2.value=L.state.rectAreaLTC2,rt.pointLights.value=L.state.point,rt.pointLightShadows.value=L.state.pointShadow,rt.hemisphereLights.value=L.state.hemi,rt.directionalShadowMap.value=L.state.directionalShadowMap,rt.directionalShadowMatrix.value=L.state.directionalShadowMatrix,rt.spotShadowMap.value=L.state.spotShadowMap,rt.spotLightMatrix.value=L.state.spotLightMatrix,rt.spotLightMap.value=L.state.spotLightMap,rt.pointShadowMap.value=L.state.pointShadowMap,rt.pointShadowMatrix.value=L.state.pointShadowMatrix),k.currentProgram=Nt,k.uniformsList=null,Nt}function Xc(X){if(X.uniformsList===null){const F=X.currentProgram.getUniforms();X.uniformsList=bi.seqWithValue(F.seq,X.uniforms)}return X.uniformsList}function gc(X,F){const v=Xt.get(X);v.outputColorSpace=F.outputColorSpace,v.batching=F.batching,v.batchingColor=F.batchingColor,v.instancing=F.instancing,v.instancingColor=F.instancingColor,v.instancingMorph=F.instancingMorph,v.skinning=F.skinning,v.morphTargets=F.morphTargets,v.morphNormals=F.morphNormals,v.morphColors=F.morphColors,v.morphTargetsCount=F.morphTargetsCount,v.numClippingPlanes=F.numClippingPlanes,v.numIntersection=F.numClipIntersection,v.vertexAlphas=F.vertexAlphas,v.vertexTangents=F.vertexTangents,v.toneMapping=F.toneMapping}function Db(X,F,v,k,L){F.isScene!==!0&&(F=le),S.resetTextureUnits();const q=F.fog,dt=k.isMeshStandardMaterial?F.environment:null,ut=U===null?G.outputColorSpace:U.isXRRenderTarget===!0?U.texture.colorSpace:Pl,bt=(k.isMeshStandardMaterial?T:W).get(k.envMap||dt),St=k.vertexColors===!0&&!!v.attributes.color&&v.attributes.color.itemSize===4,Nt=!!v.attributes.tangent&&(!!k.normalMap||k.anisotropy>0),rt=!!v.morphAttributes.position,Ht=!!v.morphAttributes.normal,Dt=!!v.morphAttributes.color;let qt=hl;k.toneMapped&&(U===null||U.isXRRenderTarget===!0)&&(qt=G.toneMapping);const Ie=v.morphAttributes.position||v.morphAttributes.normal||v.morphAttributes.color,Bt=Ie!==void 0?Ie.length:0,Wt=Xt.get(k),ol=u.state.lights;if(tt===!0&&(pt===!0||X!==g)){const ve=X===g&&k.id===R;O.setState(k,X,ve)}let Et=!1;k.version===Wt.__version?(Wt.needsLights&&Wt.lightsStateVersion!==ol.state.version||Wt.outputColorSpace!==ut||L.isBatchedMesh&&Wt.batching===!1||!L.isBatchedMesh&&Wt.batching===!0||L.isBatchedMesh&&Wt.batchingColor===!0&&L.colorTexture===null||L.isBatchedMesh&&Wt.batchingColor===!1&&L.colorTexture!==null||L.isInstancedMesh&&Wt.instancing===!1||!L.isInstancedMesh&&Wt.instancing===!0||L.isSkinnedMesh&&Wt.skinning===!1||!L.isSkinnedMesh&&Wt.skinning===!0||L.isInstancedMesh&&Wt.instancingColor===!0&&L.instanceColor===null||L.isInstancedMesh&&Wt.instancingColor===!1&&L.instanceColor!==null||L.isInstancedMesh&&Wt.instancingMorph===!0&&L.morphTexture===null||L.isInstancedMesh&&Wt.instancingMorph===!1&&L.morphTexture!==null||Wt.envMap!==bt||k.fog===!0&&Wt.fog!==q||Wt.numClippingPlanes!==void 0&&(Wt.numClippingPlanes!==O.numPlanes||Wt.numIntersection!==O.numIntersection)||Wt.vertexAlphas!==St||Wt.vertexTangents!==Nt||Wt.morphTargets!==rt||Wt.morphNormals!==Ht||Wt.morphColors!==Dt||Wt.toneMapping!==qt||Wt.morphTargetsCount!==Bt)&&(Et=!0):(Et=!0,Wt.__version=k.version);let Ae=Wt.currentProgram;Et===!0&&(Ae=Ii(k,F,L));let pn=!1,Ne=!1,Tn=!1;const $t=Ae.getUniforms(),De=Wt.uniforms;if(gt.useProgram(Ae.program)&&(pn=!0,Ne=!0,Tn=!0),k.id!==R&&(R=k.id,Ne=!0),pn||g!==X){gt.buffers.depth.getReversed()?(it.copy(X.projectionMatrix),fo(it),Fo(it),$t.setValue(M,"projectionMatrix",it)):$t.setValue(M,"projectionMatrix",X.projectionMatrix),$t.setValue(M,"viewMatrix",X.matrixWorldInverse);const yl=$t.map.cameraPosition;yl!==void 0&&yl.setValue(M,It.setFromMatrixPosition(X.matrixWorld)),vt.logarithmicDepthBuffer&&$t.setValue(M,"logDepthBufFC",2/(Math.log(X.far+1)/Math.LN2)),(k.isMeshPhongMaterial||k.isMeshToonMaterial||k.isMeshLambertMaterial||k.isMeshBasicMaterial||k.isMeshStandardMaterial||k.isShaderMaterial)&&$t.setValue(M,"isOrthographic",X.isOrthographicCamera===!0),g!==X&&(g=X,Ne=!0,Tn=!0)}if(L.isSkinnedMesh){$t.setOptional(M,L,"bindMatrix"),$t.setOptional(M,L,"bindMatrixInverse");const ve=L.skeleton;ve&&(ve.boneTexture===null&&ve.computeBoneTexture(),$t.setValue(M,"boneTexture",ve.boneTexture,S))}L.isBatchedMesh&&($t.setOptional(M,L,"batchingTexture"),$t.setValue(M,"batchingTexture",L._matricesTexture,S),$t.setOptional(M,L,"batchingIdTexture"),$t.setValue(M,"batchingIdTexture",L._indirectTexture,S),$t.setOptional(M,L,"batchingColorTexture"),L._colorsTexture!==null&&$t.setValue(M,"batchingColorTexture",L._colorsTexture,S));const vn=v.morphAttributes;if((vn.position!==void 0||vn.normal!==void 0||vn.color!==void 0)&&Ct.update(L,v,Ae),(Ne||Wt.receiveShadow!==L.receiveShadow)&&(Wt.receiveShadow=L.receiveShadow,$t.setValue(M,"receiveShadow",L.receiveShadow)),k.isMeshGouraudMaterial&&k.envMap!==null&&(De.envMap.value=bt,De.flipEnvMap.value=bt.isCubeTexture&&bt.isRenderTargetTexture===!1?-1:1),k.isMeshStandardMaterial&&k.envMap===null&&F.environment!==null&&(De.envMapIntensity.value=F.environmentIntensity),Ne&&($t.setValue(M,"toneMappingExposure",G.toneMappingExposure),Wt.needsLights&&Ob(De,Tn),q&&k.fog===!0&&at.refreshFogUniforms(De,q),at.refreshMaterialUniforms(De,k,H,$,u.state.transmissionRenderTarget[X.id]),bi.upload(M,Xc(Wt),De,S)),k.isShaderMaterial&&k.uniformsNeedUpdate===!0&&(bi.upload(M,Xc(Wt),De,S),k.uniformsNeedUpdate=!1),k.isSpriteMaterial&&$t.setValue(M,"center",L.center),$t.setValue(M,"modelViewMatrix",L.modelViewMatrix),$t.setValue(M,"normalMatrix",L.normalMatrix),$t.setValue(M,"modelMatrix",L.matrixWorld),k.isShaderMaterial||k.isRawShaderMaterial){const ve=k.uniformsGroups;for(let yl=0,Cl=ve.length;yl<Cl;yl++){const Rc=ve[yl];f.update(Rc,Ae),f.bind(Rc,Ae)}}return Ae}function Ob(X,F){X.ambientLightColor.needsUpdate=F,X.lightProbe.needsUpdate=F,X.directionalLights.needsUpdate=F,X.directionalLightShadows.needsUpdate=F,X.pointLights.needsUpdate=F,X.pointLightShadows.needsUpdate=F,X.spotLights.needsUpdate=F,X.spotLightShadows.needsUpdate=F,X.rectAreaLights.needsUpdate=F,X.hemisphereLights.needsUpdate=F}function qb(X){return X.isMeshLambertMaterial||X.isMeshToonMaterial||X.isMeshPhongMaterial||X.isMeshStandardMaterial||X.isShadowMaterial||X.isShaderMaterial&&X.lights===!0}this.getActiveCubeFace=function(){return I},this.getActiveMipmapLevel=function(){return x},this.getRenderTarget=function(){return U},this.setRenderTargetTextures=function(X,F,v){Xt.get(X.texture).__webglTexture=F,Xt.get(X.depthTexture).__webglTexture=v;const k=Xt.get(X);k.__hasExternalTextures=!0,k.__autoAllocateDepthBuffer=v===void 0,k.__autoAllocateDepthBuffer||Tt.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),k.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(X,F){const v=Xt.get(X);v.__webglFramebuffer=F,v.__useDefaultFramebuffer=F===void 0},this.setRenderTarget=function(X,F=0,v=0){U=X,I=F,x=v;let k=!0,L=null,q=!1,dt=!1;if(X){const bt=Xt.get(X);if(bt.__useDefaultFramebuffer!==void 0)gt.bindFramebuffer(M.FRAMEBUFFER,null),k=!1;else if(bt.__webglFramebuffer===void 0)S.setupRenderTarget(X);else if(bt.__hasExternalTextures)S.rebindTextures(X,Xt.get(X.texture).__webglTexture,Xt.get(X.depthTexture).__webglTexture);else if(X.depthBuffer){const rt=X.depthTexture;if(bt.__boundDepthTexture!==rt){if(rt!==null&&Xt.has(rt)&&(X.width!==rt.image.width||X.height!==rt.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");S.setupDepthRenderbuffer(X)}}const St=X.texture;(St.isData3DTexture||St.isDataArrayTexture||St.isCompressedArrayTexture)&&(dt=!0);const Nt=Xt.get(X).__webglFramebuffer;X.isWebGLCubeRenderTarget?(Array.isArray(Nt[F])?L=Nt[F][v]:L=Nt[F],q=!0):X.samples>0&&S.useMultisampledRTT(X)===!1?L=Xt.get(X).__webglMultisampledFramebuffer:Array.isArray(Nt)?L=Nt[v]:L=Nt,Y.copy(X.viewport),P.copy(X.scissor),w=X.scissorTest}else Y.copy(Vt).multiplyScalar(H).floor(),P.copy(Mt).multiplyScalar(H).floor(),w=Qt;if(gt.bindFramebuffer(M.FRAMEBUFFER,L)&&k&&gt.drawBuffers(X,L),gt.viewport(Y),gt.scissor(P),gt.setScissorTest(w),q){const bt=Xt.get(X.texture);M.framebufferTexture2D(M.FRAMEBUFFER,M.COLOR_ATTACHMENT0,M.TEXTURE_CUBE_MAP_POSITIVE_X+F,bt.__webglTexture,v)}else if(dt){const bt=Xt.get(X.texture),St=F||0;M.framebufferTextureLayer(M.FRAMEBUFFER,M.COLOR_ATTACHMENT0,bt.__webglTexture,v||0,St)}R=-1},this.readRenderTargetPixels=function(X,F,v,k,L,q,dt){if(!(X&&X.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let ut=Xt.get(X).__webglFramebuffer;if(X.isWebGLCubeRenderTarget&&dt!==void 0&&(ut=ut[dt]),ut){gt.bindFramebuffer(M.FRAMEBUFFER,ut);try{const bt=X.texture,St=bt.format,Nt=bt.type;if(!vt.textureFormatReadable(St)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!vt.textureTypeReadable(Nt)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}F>=0&&F<=X.width-k&&v>=0&&v<=X.height-L&&M.readPixels(F,v,k,L,Lt.convert(St),Lt.convert(Nt),q)}finally{const bt=U!==null?Xt.get(U).__webglFramebuffer:null;gt.bindFramebuffer(M.FRAMEBUFFER,bt)}}},this.readRenderTargetPixelsAsync=async function(X,F,v,k,L,q,dt){if(!(X&&X.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let ut=Xt.get(X).__webglFramebuffer;if(X.isWebGLCubeRenderTarget&&dt!==void 0&&(ut=ut[dt]),ut){const bt=X.texture,St=bt.format,Nt=bt.type;if(!vt.textureFormatReadable(St))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!vt.textureTypeReadable(Nt))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");if(F>=0&&F<=X.width-k&&v>=0&&v<=X.height-L){gt.bindFramebuffer(M.FRAMEBUFFER,ut);const rt=M.createBuffer();M.bindBuffer(M.PIXEL_PACK_BUFFER,rt),M.bufferData(M.PIXEL_PACK_BUFFER,q.byteLength,M.STREAM_READ),M.readPixels(F,v,k,L,Lt.convert(St),Lt.convert(Nt),0);const Ht=U!==null?Xt.get(U).__webglFramebuffer:null;gt.bindFramebuffer(M.FRAMEBUFFER,Ht);const Dt=M.fenceSync(M.SYNC_GPU_COMMANDS_COMPLETE,0);return M.flush(),await No(M,Dt,4),M.bindBuffer(M.PIXEL_PACK_BUFFER,rt),M.getBufferSubData(M.PIXEL_PACK_BUFFER,0,q),M.deleteBuffer(rt),M.deleteSync(Dt),q}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")}},this.copyFramebufferToTexture=function(X,F=null,v=0){X.isTexture!==!0&&(Rn("WebGLRenderer: copyFramebufferToTexture function signature has changed."),F=arguments[0]||null,X=arguments[1]);const k=Math.pow(2,-v),L=Math.floor(X.image.width*k),q=Math.floor(X.image.height*k),dt=F!==null?F.x:0,ut=F!==null?F.y:0;S.setTexture2D(X,0),M.copyTexSubImage2D(M.TEXTURE_2D,v,0,0,dt,ut,L,q),gt.unbindTexture()},this.copyTextureToTexture=function(X,F,v=null,k=null,L=0){X.isTexture!==!0&&(Rn("WebGLRenderer: copyTextureToTexture function signature has changed."),k=arguments[0]||null,X=arguments[1],F=arguments[2],L=arguments[3]||0,v=null);let q,dt,ut,bt,St,Nt,rt,Ht,Dt;const qt=X.isCompressedTexture?X.mipmaps[L]:X.image;v!==null?(q=v.max.x-v.min.x,dt=v.max.y-v.min.y,ut=v.isBox3?v.max.z-v.min.z:1,bt=v.min.x,St=v.min.y,Nt=v.isBox3?v.min.z:0):(q=qt.width,dt=qt.height,ut=qt.depth||1,bt=0,St=0,Nt=0),k!==null?(rt=k.x,Ht=k.y,Dt=k.z):(rt=0,Ht=0,Dt=0);const Ie=Lt.convert(F.format),Bt=Lt.convert(F.type);let Wt;F.isData3DTexture?(S.setTexture3D(F,0),Wt=M.TEXTURE_3D):F.isDataArrayTexture||F.isCompressedArrayTexture?(S.setTexture2DArray(F,0),Wt=M.TEXTURE_2D_ARRAY):(S.setTexture2D(F,0),Wt=M.TEXTURE_2D),M.pixelStorei(M.UNPACK_FLIP_Y_WEBGL,F.flipY),M.pixelStorei(M.UNPACK_PREMULTIPLY_ALPHA_WEBGL,F.premultiplyAlpha),M.pixelStorei(M.UNPACK_ALIGNMENT,F.unpackAlignment);const ol=M.getParameter(M.UNPACK_ROW_LENGTH),Et=M.getParameter(M.UNPACK_IMAGE_HEIGHT),Ae=M.getParameter(M.UNPACK_SKIP_PIXELS),pn=M.getParameter(M.UNPACK_SKIP_ROWS),Ne=M.getParameter(M.UNPACK_SKIP_IMAGES);M.pixelStorei(M.UNPACK_ROW_LENGTH,qt.width),M.pixelStorei(M.UNPACK_IMAGE_HEIGHT,qt.height),M.pixelStorei(M.UNPACK_SKIP_PIXELS,bt),M.pixelStorei(M.UNPACK_SKIP_ROWS,St),M.pixelStorei(M.UNPACK_SKIP_IMAGES,Nt);const Tn=X.isDataArrayTexture||X.isData3DTexture,$t=F.isDataArrayTexture||F.isData3DTexture;if(X.isRenderTargetTexture||X.isDepthTexture){const De=Xt.get(X),vn=Xt.get(F),ve=Xt.get(De.__renderTarget),yl=Xt.get(vn.__renderTarget);gt.bindFramebuffer(M.READ_FRAMEBUFFER,ve.__webglFramebuffer),gt.bindFramebuffer(M.DRAW_FRAMEBUFFER,yl.__webglFramebuffer);for(let Cl=0;Cl<ut;Cl++)Tn&&M.framebufferTextureLayer(M.READ_FRAMEBUFFER,M.COLOR_ATTACHMENT0,Xt.get(X).__webglTexture,L,Nt+Cl),X.isDepthTexture?($t&&M.framebufferTextureLayer(M.DRAW_FRAMEBUFFER,M.COLOR_ATTACHMENT0,Xt.get(F).__webglTexture,L,Dt+Cl),M.blitFramebuffer(bt,St,q,dt,rt,Ht,q,dt,M.DEPTH_BUFFER_BIT,M.NEAREST)):$t?M.copyTexSubImage3D(Wt,L,rt,Ht,Dt+Cl,bt,St,q,dt):M.copyTexSubImage2D(Wt,L,rt,Ht,Dt+Cl,bt,St,q,dt);gt.bindFramebuffer(M.READ_FRAMEBUFFER,null),gt.bindFramebuffer(M.DRAW_FRAMEBUFFER,null)}else $t?X.isDataTexture||X.isData3DTexture?M.texSubImage3D(Wt,L,rt,Ht,Dt,q,dt,ut,Ie,Bt,qt.data):F.isCompressedArrayTexture?M.compressedTexSubImage3D(Wt,L,rt,Ht,Dt,q,dt,ut,Ie,qt.data):M.texSubImage3D(Wt,L,rt,Ht,Dt,q,dt,ut,Ie,Bt,qt):X.isDataTexture?M.texSubImage2D(M.TEXTURE_2D,L,rt,Ht,q,dt,Ie,Bt,qt.data):X.isCompressedTexture?M.compressedTexSubImage2D(M.TEXTURE_2D,L,rt,Ht,qt.width,qt.height,Ie,qt.data):M.texSubImage2D(M.TEXTURE_2D,L,rt,Ht,q,dt,Ie,Bt,qt);M.pixelStorei(M.UNPACK_ROW_LENGTH,ol),M.pixelStorei(M.UNPACK_IMAGE_HEIGHT,Et),M.pixelStorei(M.UNPACK_SKIP_PIXELS,Ae),M.pixelStorei(M.UNPACK_SKIP_ROWS,pn),M.pixelStorei(M.UNPACK_SKIP_IMAGES,Ne),L===0&&F.generateMipmaps&&M.generateMipmap(Wt),gt.unbindTexture()},this.copyTextureToTexture3D=function(X,F,v=null,k=null,L=0){return X.isTexture!==!0&&(Rn("WebGLRenderer: copyTextureToTexture3D function signature has changed."),v=arguments[0]||null,k=arguments[1]||null,X=arguments[2],F=arguments[3],L=arguments[4]||0),Rn('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),this.copyTextureToTexture(X,F,v,k,L)},this.initRenderTarget=function(X){Xt.get(X).__webglFramebuffer===void 0&&S.setupRenderTarget(X)},this.initTexture=function(X){X.isCubeTexture?S.setTextureCube(X,0):X.isData3DTexture?S.setTexture3D(X,0):X.isDataArrayTexture||X.isCompressedArrayTexture?S.setTexture2DArray(X,0):S.setTexture2D(X,0),gt.unbindTexture()},this.resetState=function(){I=0,x=0,U=null,gt.reset(),_t.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return tl}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(t){this._outputColorSpace=t;const e=this.getContext();e.drawingBufferColorspace=kt._getDrawingBufferColorSpace(t),e.unpackColorSpace=kt._getUnpackColorSpace()}}class zd extends Ce{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new il,this.environmentIntensity=1,this.environmentRotation=new il,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,this.backgroundRotation.copy(t.backgroundRotation),this.environmentIntensity=t.environmentIntensity,this.environmentRotation.copy(t.environmentRotation),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(e.object.backgroundIntensity=this.backgroundIntensity),e.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(e.object.environmentIntensity=this.environmentIntensity),e.object.environmentRotation=this.environmentRotation.toArray(),e}}class _e extends Se{constructor(t,e,n,i=1){super(t,e,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}class pi extends Yn{static get type(){return"PointsMaterial"}constructor(t){super(),this.isPointsMaterial=!0,this.color=new Kt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const Hd=new ae,Oa=new Hs,Gi=new Dn,Wi=new J;class qa extends Ce{constructor(t=new Ue,e=new pi){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,s=t.params.Points.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Gi.copy(n.boundingSphere),Gi.applyMatrix4(i),Gi.radius+=s,t.ray.intersectsSphere(Gi)===!1)return;Hd.copy(i).invert(),Oa.copy(t.ray).applyMatrix4(Hd);const d=s/((this.scale.x+this.scale.y+this.scale.z)/3),c=d*d,o=n.index,m=n.attributes.position;if(o!==null){const b=Math.max(0,a.start),h=Math.min(o.count,a.start+a.count);for(let p=b,V=h;p<V;p++){const r=o.getX(p);Wi.fromBufferAttribute(m,r),Kd(Wi,r,c,i,t,e,this)}}else{const b=Math.max(0,a.start),h=Math.min(m.count,a.start+a.count);for(let p=b,V=h;p<V;p++)Wi.fromBufferAttribute(m,p),Kd(Wi,p,c,i,t,e,this)}}updateMorphTargets(){const e=this.geometry.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const d=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[d]=s}}}}}function Kd(l,t,e,n,i,s,a){const d=Oa.distanceSqToPoint(l);if(d<e){const c=new J;Oa.closestPointToPoint(l,c),c.applyMatrix4(n);const o=i.ray.origin.distanceTo(c);if(o<i.near||o>i.far)return;s.push({distance:o,distanceToRay:Math.sqrt(d),point:c,index:t,face:null,faceIndex:null,barycoord:null,object:a})}}class db extends ge{constructor(t,e,n,i,s,a,d,c,o){super(t,e,n,i,s,a,d,c,o),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Bd extends Ue{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}toJSON(){const t=super.toJSON();return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:xi}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=xi);const $a=100,Vi=new Map;let cb=0;const Ed=typeof globalThis.requestAnimationFrame=="function"?l=>globalThis.requestAnimationFrame(l):l=>{const t=++cb,e=setTimeout(()=>{Vi.delete(t),l(performance.now())},16);return Vi.set(t,e),t},ob=typeof globalThis.cancelAnimationFrame=="function"?l=>globalThis.cancelAnimationFrame(l):l=>{const t=Vi.get(l);t&&(clearTimeout(t),Vi.delete(l))};function Xi(l,t=l){if(typeof document<"u"&&document.createElement){const e=document.createElement("canvas");e.width=l,e.height=t;const n=e.getContext("2d");if(!n)throw new Error("Unable to get 2D context");return{canvas:e,ctx:n}}if(typeof OffscreenCanvas<"u"){const e=new OffscreenCanvas(l,t),n=e.getContext("2d");if(!n)throw new Error("Unable to get 2D context");return{canvas:e,ctx:n}}throw new Error("Canvas not supported")}function gi(l){return new db(l)}function Ad(){const{canvas:t,ctx:e}=Xi(32,32),n=e.createRadialGradient(32/2,32/2,0,32/2,32/2,32/2);n.addColorStop(0,"rgba(255, 255, 255, 1)"),n.addColorStop(.4,"rgba(255, 255, 255, 0.5)"),n.addColorStop(1,"rgba(255, 255, 255, 0)"),e.fillStyle=n,e.fillRect(0,0,32,32);const i=gi(t);return i.needsUpdate=!0,i}function mb(){const{canvas:t,ctx:e}=Xi(16,16),n=e.createRadialGradient(16/2,16/2,0,16/2,16/2,16/2);n.addColorStop(0,"rgba(255, 255, 255, 0.55)"),n.addColorStop(.4,"rgba(255, 255, 255, 0.35)"),n.addColorStop(1,"rgba(255, 255, 255, 0)"),e.fillStyle=n,e.fillRect(0,0,16,16);const i=gi(t);return i.needsUpdate=!0,i}const ts=`
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;class Zb{constructor(t){this.canvas=t.canvas,this.viewportWidth=t.viewportWidth,this.viewportHeight=t.viewportHeight,this.devicePixelRatio=t.devicePixelRatio??1,this.isMobile=t.isMobile??!1,this.viewWidth=this.computeViewWidth($a),this.viewHeight=$a,this.camera=this.createCamera(),this.renderer=this.createRenderer(),this.scene=new zd,this.animationFrame=null,this.lastTimestamp=0,this.currentEffect="none",this.activeEffect=null,this.opacity=100,this.effectExtras={},this.lastAppliedExtras={},this.snowSurfaces=[],this.smogOverlay=null,this.windowDropletsOverlay=null,this.lightningOverlay=null,this.auroraOverlay=null,this.renderTarget=null,this.maskScene=null,this.maskCamera=null,this.maskQuad=null,this.renderLoop=e=>this.renderFrame(e)}computeViewWidth(t){return t*(this.viewportWidth/Math.max(1,this.viewportHeight))}createCamera(){const t=this.viewWidth/2,e=this.viewHeight/2,n=new Ha(-t,t,e,-e,-1e3,1e3);return n.position.z=10,n}createRenderer(){const t=new sb({canvas:this.canvas,alpha:!0,antialias:!this.isMobile,powerPreference:"high-performance",stencil:!1,depth:!1,preserveDrawingBuffer:!1});return t.setPixelRatio(Math.min(this.devicePixelRatio||1,this.isMobile?1:1.5)),t.setSize(this.viewportWidth,this.viewportHeight,!1),t}start(t,e,n={}){this.opacity=Math.max(0,Math.min(100,e)),this.effectExtras=n;const i=this.effectExtras.moonPosition,s=this.lastAppliedExtras.moonPosition,a=i?.x!==s?.x||i?.y!==s?.y,d=this.lastAppliedExtras.windBearing!==this.effectExtras.windBearing||this.lastAppliedExtras.windSpeedKmh!==this.effectExtras.windSpeedKmh,c=this.lastAppliedExtras.snowAccumulation!==this.effectExtras.snowAccumulation||this.lastAppliedExtras.matrixRainColor!==this.effectExtras.matrixRainColor||this.lastAppliedExtras.smogActive!==this.effectExtras.smogActive||this.lastAppliedExtras.windowDroplets!==this.effectExtras.windowDroplets||this.lastAppliedExtras.lightningOverlay!==this.effectExtras.lightningOverlay||this.lastAppliedExtras.cloudCoverage!==this.effectExtras.cloudCoverage||this.lastAppliedExtras.themeMode!==this.effectExtras.themeMode||this.lastAppliedExtras.cloudSpeedMultiplier!==this.effectExtras.cloudSpeedMultiplier||this.lastAppliedExtras.auroraOverlay!==this.effectExtras.auroraOverlay||this.lastAppliedExtras.auroraVisibilityScore!==this.effectExtras.auroraVisibilityScore||this.lastAppliedExtras.auroraVariant!==this.effectExtras.auroraVariant||JSON.stringify(this.lastAppliedExtras.effectOpacity||{})!==JSON.stringify(this.effectExtras.effectOpacity||{})||a||d;if(this.currentEffect===t&&this.activeEffect&&!c){this.activeEffect.setOpacity(this.opacity),this.updateSmogOverlay(),this.updateWindowDropletsOverlay(),this.updateLightningOverlay(),this.updateAuroraOverlay(),this.startLoop();return}this.setEffect(t)}stop(){this.disposeSmogOverlay(),this.disposeWindowDropletsOverlay(),this.disposeLightningOverlay(),this.disposeAuroraOverlay(),this.disposeActiveEffect(),this.currentEffect="none",this.stopLoop(),this.lastAppliedExtras={}}updateSmogOverlay(){const t=!!this.effectExtras.smogActive;t&&!this.smogOverlay?(this.smogOverlay=Sb(this),this.scene.add(this.smogOverlay.group)):!t&&this.smogOverlay?this.disposeSmogOverlay():this.smogOverlay&&this.smogOverlay.setOpacity(this.opacity)}disposeSmogOverlay(){this.smogOverlay&&(this.scene.remove(this.smogOverlay.group),this.smogOverlay.dispose(),this.smogOverlay=null)}updateWindowDropletsOverlay(){const t=!!this.effectExtras.windowDroplets;t&&!this.windowDropletsOverlay?(this.windowDropletsOverlay=Cb(this),this.scene.add(this.windowDropletsOverlay.group)):!t&&this.windowDropletsOverlay?this.disposeWindowDropletsOverlay():this.windowDropletsOverlay&&this.windowDropletsOverlay.setOpacity(this.opacity)}disposeWindowDropletsOverlay(){this.windowDropletsOverlay&&(this.scene.remove(this.windowDropletsOverlay.group),this.windowDropletsOverlay.dispose(),this.windowDropletsOverlay=null)}updateLightningOverlay(){const t=this.currentEffect==="rain_storm"&&!!this.effectExtras.lightningData;t&&!this.lightningOverlay?(this.lightningOverlay=_d({viewWidth:this.viewWidth,viewHeight:this.viewHeight,opacity:this.opacity,isMobile:this.isMobile}),this.scene.add(this.lightningOverlay.group)):!t&&this.lightningOverlay?this.disposeLightningOverlay():this.lightningOverlay&&this.lightningOverlay.setOpacity(this.opacity)}disposeLightningOverlay(){this.lightningOverlay&&(this.scene.remove(this.lightningOverlay.group),this.lightningOverlay.dispose(),this.lightningOverlay=null)}updateAuroraOverlay(){const t=this.currentEffect==="stars"&&!!this.effectExtras.auroraOverlay,e=Math.max(0,Math.min(1,this.effectExtras.auroraVisibilityScore??0)),n=this.effectExtras.auroraVariant||"bands",i=this.auroraOverlay&&this.lastAppliedExtras.auroraVariant!==n;t&&(!this.auroraOverlay||i)?(this.auroraOverlay&&this.disposeAuroraOverlay(),this.auroraOverlay=xb(this,e,n),this.scene.add(this.auroraOverlay.group)):!t&&this.auroraOverlay?this.disposeAuroraOverlay():this.auroraOverlay&&(this.auroraOverlay.setOpacity(this.opacity),this.auroraOverlay.setVisibilityScore?.(e))}disposeAuroraOverlay(){this.auroraOverlay&&(this.scene.remove(this.auroraOverlay.group),this.auroraOverlay.dispose(),this.auroraOverlay=null)}setOpacity(t){this.opacity=Math.max(0,Math.min(100,t)),this.activeEffect?.setOpacity(this.opacity)}setSnowSurfaces(t){this.snowSurfaces=t||[],this.activeEffect?.setSnowSurfaces?.(this.snowSurfaces)}getLastAppliedExtras(){return{...this.lastAppliedExtras}}resize(t){if(this.viewportWidth=t.viewportWidth,this.viewportHeight=t.viewportHeight,this.renderTarget&&this.renderTarget.setSize(this.viewportWidth,this.viewportHeight),this.devicePixelRatio=t.devicePixelRatio??1,this.isMobile=t.isMobile??!1,this.viewWidth=this.computeViewWidth($a),this.camera=this.createCamera(),this.renderer.setPixelRatio(Math.min(this.devicePixelRatio||1,this.isMobile?1:1.5)),this.renderer.setSize(this.viewportWidth,this.viewportHeight,!1),this.activeEffect?.onResize)this.activeEffect.onResize(this.viewWidth,this.viewHeight,this.isMobile,this.viewportWidth,this.viewportHeight),this.activeEffect.setSnowSurfaces?.(this.snowSurfaces);else if(this.currentEffect!=="none"){const e=this.currentEffect;this.currentEffect="none",this.setEffect(e)}}destroy(){this.stop(),this.renderTarget&&(this.renderTarget.dispose(),this.renderTarget=null),this.maskQuad?.material&&this.maskQuad.material.dispose(),this.maskScene?.clear(),this.renderer.dispose(),this.scene.clear()}startLoop(){this.animationFrame==null&&(this.lastTimestamp=0,this.animationFrame=Ed(this.renderLoop))}stopLoop(){this.animationFrame!=null&&(ob(this.animationFrame),this.animationFrame=null)}renderFrame(t){this.lastTimestamp===0&&(this.lastTimestamp=t);const e=Math.min((t-this.lastTimestamp)/1e3,.05);this.lastTimestamp=t,this.activeEffect?.update(e,t/1e3,this.effectExtras),this.smogOverlay?.update(e),this.windowDropletsOverlay?.update(e),this.lightningOverlay?.update(e,t/1e3,this.effectExtras),this.auroraOverlay?.update(e);const n=this.effectExtras.spatialMode==="gradient-mask";n&&(this.ensureGradientMaskPass(),this.renderer.setRenderTarget(this.renderTarget)),this.renderer.render(this.scene,this.camera),n&&(this.renderer.setRenderTarget(null),this.maskQuad.material.uniforms.tDiffuse.value=this.renderTarget.texture,this.renderer.render(this.maskScene,this.maskCamera)),this.animationFrame=Ed(this.renderLoop)}ensureGradientMaskPass(){if(this.renderTarget)return;this.renderTarget=new bl(this.viewportWidth,this.viewportHeight,{minFilter:be,magFilter:be,format:Fe,type:Qe,stencilBuffer:!1}),this.maskCamera=new Ha(-1,1,1,-1,0,1),this.maskScene=new zd;const t=new te(2,2),e=new ce({uniforms:{tDiffuse:{value:null},uInner:{value:.32},uOuter:{value:.85}},vertexShader:"varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }",fragmentShader:`
        uniform sampler2D tDiffuse;
        uniform float uInner;
        uniform float uOuter;
        varying vec2 vUv;
        void main() {
          vec4 tex = texture2D(tDiffuse, vUv);
          vec2 c = vUv - 0.5;
          float d = length(c) * 2.0;
          float mask = smoothstep(uInner, uOuter, d);
          gl_FragColor = vec4(tex.rgb, tex.a * mask);
        }
      `,transparent:!0,depthWrite:!1});this.maskQuad=new ee(t,e),this.maskScene.add(this.maskQuad)}setEffect(t){if(this.disposeActiveEffect(),this.currentEffect=t,t==="none"){this.stopLoop();return}const e=this.createEffectInstance(t);if(!e){this.stopLoop(),this.currentEffect="none";return}this.activeEffect=e,this.activeEffect.setOpacity(this.opacity),this.snowSurfaces.length&&this.activeEffect.setSnowSurfaces&&this.activeEffect.setSnowSurfaces(this.snowSurfaces),this.scene.add(e.group),this.lastAppliedExtras={...this.effectExtras},this.updateSmogOverlay(),this.updateWindowDropletsOverlay(),this.updateLightningOverlay(),this.updateAuroraOverlay(),this.startLoop()}disposeActiveEffect(){this.activeEffect&&(this.scene.remove(this.activeEffect.group),this.activeEffect.dispose(),this.activeEffect=null)}createEffectInstance(t){const e={viewWidth:this.viewWidth,viewHeight:this.viewHeight,viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,isMobile:this.isMobile,effect:t,opacity:this.opacity,snowAccumulation:!!this.effectExtras.snowAccumulation,snowSurfaces:this.snowSurfaces,matrixRainColor:this.effectExtras.matrixRainColor,moonPosition:this.effectExtras.moonPosition,windBearing:this.effectExtras.windBearing,windSpeedKmh:this.effectExtras.windSpeedKmh,windSwayFactor:this.effectExtras.windSwayFactor,rainMaxTiltDeg:this.effectExtras.rainMaxTiltDeg,rainWindMinKmh:this.effectExtras.rainWindMinKmh,sunPosition:this.effectExtras.sunPosition,cloudCoverage:this.effectExtras.cloudCoverage,precipitationMultiplier:this.effectExtras.precipitationMultiplier??1,themeMode:this.effectExtras.themeMode??"dark",cloudSpeedMultiplier:this.effectExtras.cloudSpeedMultiplier??1,effectOpacity:this.effectExtras.effectOpacity||{}};return t==="lightning"?_d(e):t==="sun_beams"?Fb(e):t==="stars"?Rb(e):t==="matrix"?Xb(e):t==="clouds"?Lb(e):t==="hail"?Mb(e):t.startsWith("rain")?ub(e):t==="snow_layered"?pb(e):t.startsWith("snow")?rb(e):t.startsWith("fog")?fb(e):null}}function hb(l,t){const e=t?.6:1;return l==="rain_storm"?{count:Math.floor(600*e),length:{min:1.1,max:1.5},speed:{min:1.4,max:1.9},timeScale:1.2,lightning:!0,lightningOnly:!1}:l==="rain_drizzle"?{count:Math.floor(250*e),length:{min:.6,max:.9},speed:{min:.3,max:.6},timeScale:.6,lightning:!1,lightningOnly:!1}:{count:Math.floor(480*e),length:{min:.9,max:1.2},speed:{min:1,max:1.3},timeScale:1,lightning:!1,lightningOnly:!1}}function ub(l){const t=new he,e=hb(l.effect,l.isMobile),n=e.count,i=new te(.06,1),s=new Bd;s.index=i.index,s.attributes.position=i.attributes.position,s.attributes.uv=i.attributes.uv,s.instanceCount=n;const a=new Float32Array(n*3),d=new Float32Array(n),c=new Float32Array(n),o=new Float32Array(n),Z=new Float32Array(n);for(let G=0;G<n;G++){const N=G*3;a[N]=jt.randFloatSpread(l.viewWidth+10),a[N+1]=jt.randFloatSpread(l.viewHeight),a[N+2]=Math.random()*.5,d[G]=jt.randFloat(e.speed.min,e.speed.max),c[G]=jt.randFloat(e.length.min,e.length.max),o[G]=jt.randFloat(.5,1.5),Z[G]=Math.random()}s.setAttribute("instanceOffset",new _e(a,3)),s.setAttribute("instanceSpeed",new _e(d,1)),s.setAttribute("instanceLength",new _e(c,1)),s.setAttribute("instanceSway",new _e(o,1)),s.setAttribute("instancePhase",new _e(Z,1));const m=l.rainWindMinKmh??3,b=l.windSwayFactor??.7,h=l.windSpeedKmh??5,p=(l.windBearing??270)*Math.PI/180;let V=0;h>=m&&(V=-Math.sin(p)*h*.06*b);const r=V*.15,u={uTime:{value:0},uOpacity:{value:l.opacity/100},uViewSize:{value:new ft(l.viewWidth,l.viewHeight)},uWindSway:{value:r}},C=new ce({uniforms:u,vertexShader:`
      attribute vec3 instanceOffset;
      attribute float instanceSpeed;
      attribute float instanceLength;
      attribute float instanceSway;
      attribute float instancePhase;
      uniform float uTime;
      uniform vec2 uViewSize;
      uniform float uWindSway;
      varying float vAlpha;
      void main() {
        float progress = fract(uTime * instanceSpeed + instancePhase);
        float travel = (uViewSize.y * 0.5) - progress * (uViewSize.y + 20.0);
        vec3 transformed = position;
        transformed.y *= instanceLength;
        transformed.x += instanceOffset.x + sin(progress * 6.28318 + instancePhase) * instanceSway + uWindSway * progress * uViewSize.y;
        transformed.y += travel + instanceOffset.y;
        transformed.z += -5.0 + instanceOffset.z;
        vAlpha = 1.0 - progress;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
      }
    `,fragmentShader:`
      uniform float uOpacity;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(0.65, 0.75, 0.9, clamp(vAlpha * 0.85 * uOpacity, 0.0, 1.0));
      }
    `,transparent:!0,depthWrite:!1,blending:fe}),y=new ee(s,C);return y.frustumCulled=!1,t.add(y),{group:t,update(G,N,I){const x=I?.precipitationMultiplier??1;u.uTime.value+=G*e.timeScale*x,u.uViewSize.value.set(l.viewWidth,l.viewHeight)},setOpacity(G){u.uOpacity.value=Math.max(0,Math.min(1,G/100))},onResize(G,N){l.viewWidth=G,l.viewHeight=N,u.uViewSize.value.set(G,N)},dispose(){s.dispose(),C.dispose()}}}function bb(l,t){const e=t?.6:1;return Math.floor(l==="snow_storm"?1e3*e:600*e)}function rb(l){const t=new he,e=bb(l.effect,l.isMobile),n=new Float32Array(e*3),i=new Float32Array(e*3),s=l.rainWindMinKmh??3,a=l.windSwayFactor??.7,d=l.windSpeedKmh??5,c=(l.windBearing??270)*Math.PI/180,o=d>=s?-Math.sin(c)*d*.06*a*.8:0;for(let u=0;u<e;u++){const C=u*3;n[C]=jt.randFloatSpread(l.viewWidth+30),n[C+1]=jt.randFloatSpread(l.viewHeight+30),n[C+2]=Math.random()*4-2,i[C]=jt.randFloat(-.2,.2)+o,i[C+1]=l.effect==="snow_storm"?jt.randFloat(-1.4,-.9):jt.randFloat(-.8,-.4),i[C+2]=jt.randFloat(-.05,.05)}const Z=new Ue;Z.setAttribute("position",new Se(n,3));const m=Ad(),b=l.effect==="snow_storm"?.9:.75,p=l.themeMode==="light"?16777215:15267071,V=new pi({map:m,transparent:!0,opacity:b*(l.opacity/100),sizeAttenuation:!1,size:l.effect==="snow_storm"?3.4:2.6,color:p,depthWrite:!1,depthTest:!1,blending:fe}),r=new qa(Z,V);return r.frustumCulled=!1,t.add(r),{group:t,update(u){const C=Z.attributes.position.array;for(let y=0;y<C.length;y+=3){C[y]+=i[y]*u*25,C[y+1]+=i[y+1]*u*25,C[y+2]+=i[y+2]*u*10;const G=l.viewWidth/2+15,N=l.viewHeight/2+15;C[y+1]<-N&&(C[y+1]=N,C[y]=jt.randFloatSpread(l.viewWidth+30)),C[y]<-G&&(C[y]=G),C[y]>G&&(C[y]=-G)}Z.attributes.position.needsUpdate=!0},setOpacity(u){V.opacity=b*Math.max(0,Math.min(1,u/100))},onResize(u,C){l.viewWidth=u,l.viewHeight=C},dispose(){Z.dispose(),V.dispose(),m.dispose()}}}const Pd=[{sizeMin:24,sizeMax:40,speedFactor:.12,swayAmpMin:10,swayAmpMax:30,opacity:1,colorMin:255,colorMax:255},{sizeMin:20,sizeMax:28,speedFactor:.09,swayAmpMin:10,swayAmpMax:25,opacity:.85,colorMin:255,colorMax:255},{sizeMin:16,sizeMax:24,speedFactor:.07,swayAmpMin:10,swayAmpMax:20,opacity:.75,colorMin:255,colorMax:255},{sizeMin:12,sizeMax:18,speedFactor:.05,swayAmpMin:10,swayAmpMax:20,opacity:.65,colorMin:220,colorMax:229},{sizeMin:10,sizeMax:14,speedFactor:.03,swayAmpMin:10,swayAmpMax:20,opacity:.55,colorMin:210,colorMax:219},{sizeMin:8,sizeMax:12,speedFactor:.01,swayAmpMin:10,swayAmpMax:20,opacity:.4,colorMin:200,colorMax:209}];function pb(l){const t=new he;let e=l.isMobile?180:300;const n=Math.floor(e/Pd.length),i=Ad(),s=l.rainWindMinKmh??3,a=l.windSwayFactor??.7,d=l.windSpeedKmh??5,c=(l.windBearing??270)*Math.PI/180,o=d>=s?-Math.sin(c)*d*.06*a*.12:0,Z=Pd.map(m=>{const b=new Float32Array(n*3),h=new Float32Array(n),p=new Float32Array(n),V=new Float32Array(n),r=new Float32Array(n);for(let N=0;N<n;N++){const I=N*3,x=m.sizeMin+Math.random()*(m.sizeMax-m.sizeMin);b[I]=jt.randFloatSpread(l.viewWidth+20),b[I+1]=jt.randFloatSpread(l.viewHeight+20),b[I+2]=Math.random()*2-1,h[N]=x*m.speedFactor*.15+Math.random()*.02,p[N]=m.swayAmpMin+Math.random()*(m.swayAmpMax-m.swayAmpMin),V[N]=Math.random()*Math.PI*2,r[N]=.01+Math.random()*.02}const u=new Ue;u.setAttribute("position",new Se(b,3));const C=(m.sizeMin+m.sizeMax)/2,y=new pi({map:i,transparent:!0,opacity:m.opacity*(l.opacity/100),sizeAttenuation:!1,size:C*.15,color:16777215,depthWrite:!1,depthTest:!1,blending:fe}),G=new qa(u,y);return G.frustumCulled=!1,t.add(G),{geo:u,mat:y,fallSpeeds:h,swayAmps:p,swayOffsets:V,swaySpeeds:r,baseOpacity:m.opacity}});return{group:t,update(m){Z.forEach(b=>{const h=b.geo.attributes.position.array,p=m*60;for(let V=0;V<h.length/3;V++){const r=V*3;b.swayOffsets[V]+=b.swaySpeeds[V];const u=Math.sin(b.swayOffsets[V])*b.swayAmps[V]*.08;h[r]+=(u+o)*p,h[r+1]-=b.fallSpeeds[V]*p;const C=l.viewWidth/2+15,y=l.viewHeight/2+15;h[r+1]<-y&&(h[r+1]=y,h[r]=jt.randFloatSpread(l.viewWidth+20)),h[r]<-C&&(h[r]=C),h[r]>C&&(h[r]=-C)}b.geo.attributes.position.needsUpdate=!0})},setOpacity(m){const b=Math.max(0,Math.min(1,m/100));Z.forEach(h=>{h.mat.opacity=h.baseOpacity*b})},onResize(m,b){l.viewWidth=m,l.viewHeight=b},dispose(){Z.forEach(m=>{m.geo.dispose(),m.mat.dispose()}),i.dispose()}}}const Qd=["園","迎","簡","益","大","诶","比","西","迪","伊","弗","吉","尺","杰","开","艾","勒","马","娜"],Gb="#00ff41",Wb="#00cc33",Vb=85;function Xb(l){const t=new he,e=Math.max(256,Math.floor(l.viewportWidth/2)),n=Math.max(256,Math.floor(l.viewportHeight/2)),{canvas:i,ctx:s}=Xi(e,n),a=gi(i);a.minFilter=be,a.magFilter=be;const d=new te(l.viewWidth,l.viewHeight),c=new Nn({map:a,transparent:!0,opacity:.9*(l.opacity/100),depthWrite:!1}),o=new ee(d,c);t.add(o);const Z=[];let m=0;return{group:t,update(b){const h=i.width,p=i.height,V=h/l.viewportWidth;m+=b*1e3;const r=p/3,u=Z.some(G=>G.y>r);if((Z.length===0||u)&&m>=.8&&Z.length<6){m=0;const G=h*.28,N=h*.72;let I=15,x;do{x=Math.random()<.5?30+Math.random()*(G-60):N+30+Math.random()*(h-N-60);const R=Vb*(h/l.viewportWidth);if(!Z.some(Y=>Math.abs(Y.x-x)<R))break}while(--I>0);if(I>0){const U=4+Math.floor(Math.random()*8);Z.push({x,y:-80,chars:Array.from({length:U},()=>Qd[Math.floor(Math.random()*Qd.length)]),speed:(.15+Math.random()*.12)*V})}}s.fillStyle="rgba(0,0,0,0.08)",s.fillRect(0,0,h,p),s.font=`${Math.max(12,16*V)}px monospace`,s.textAlign="center",s.textBaseline="top";const y=h/2;for(let G=Z.length-1;G>=0;G--){const N=Z[G];if(N.y+=N.speed,N.y>p+150){Z.splice(G,1);continue}const I=Math.abs(N.x-y),x=I<h*.2?.5+I/(h*.2)*.4:.9,U=16*V;for(let R=0;R<N.chars.length;R++){const g=1-R/N.chars.length*.5;s.globalAlpha=g*x,s.fillStyle=R===0?Gb:Wb,s.fillText(N.chars[R],N.x,N.y+R*U)}s.globalAlpha=1}a.needsUpdate=!0},setOpacity(b){c.opacity=.9*Math.max(0,Math.min(1,b/100))},onResize(b,h){l.viewWidth=b,l.viewHeight=h,o.geometry.dispose(),o.geometry=new te(b,h)},dispose(){d.dispose(),c.dispose(),a.dispose()}}}function gb(l){return Math.floor(l?400*.6:400)}function Rb(l){const t=l.effectOpacity?.moon??1,e=l.effectOpacity?.stars??1,n=new he,i=gb(l.isMobile),s=new Float32Array(i*3),a=l.moonPosition;for(let h=0;h<i;h++){const p=h*3;s[p]=jt.randFloatSpread(l.viewWidth+20),s[p+1]=jt.randFloatSpread(l.viewHeight+20),s[p+2]=Math.random()*2-1}const d=new Ue;d.setAttribute("position",new Se(s,3));const c=mb(),o=new pi({map:c,transparent:!0,opacity:.85*(l.opacity/100)*e,sizeAttenuation:!1,size:2,color:15267071,depthWrite:!1,depthTest:!1,blending:fe}),Z=new qa(d,o);Z.frustumCulled=!1,n.add(Z);let m=null;if(a&&typeof a.x=="number"&&typeof a.y=="number"){const h=(a.x-.5)*l.viewWidth,p=(.5-a.y)*l.viewHeight,V=Math.max(l.viewWidth,l.viewHeight)*.2,r=new te(V,V),u=new ce({uniforms:{uOpacity:{value:.18*(l.opacity/100)*t}},vertexShader:"varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }",fragmentShader:`
        varying vec2 vUv;
        uniform float uOpacity;
        void main() {
          vec2 c = vUv - 0.5;
          float d = length(c) * 2.0;
          float alpha = smoothstep(1.5, 0.1, d) * uOpacity;
          gl_FragColor = vec4(0.96, 0.97, 1.0, alpha);
        }
      `,transparent:!0,depthWrite:!1,blending:fe});m=new ee(r,u),m.position.set(h,p,-1),m.renderOrder=1,n.add(m)}let b=0;return{group:n,update(h){b+=h*1.2,o.opacity=.85*(l.opacity/100)*e*(.8+.2*Math.sin(b))},setOpacity(h){const p=Math.max(0,Math.min(1,h/100));o.opacity=.85*p*e,m&&(m.material.uniforms.uOpacity.value=.18*p*t)},onResize(h,p){l.viewWidth=h,l.viewHeight=p},dispose(){d.dispose(),o.dispose(),c.dispose(),m&&(m.geometry.dispose(),m.material.dispose())}}}const yb=55;function Cb(l){const t=l.viewWidth,e=l.viewHeight,{canvas:n,ctx:i}=Xi(Math.max(256,Math.floor(l.viewportWidth/2)),Math.max(256,Math.floor(l.viewportHeight/2))),s=gi(n);s.minFilter=be,s.magFilter=be;const a=new te(t,e),d=new Nn({map:s,transparent:!0,opacity:.95*(l.opacity/100),depthWrite:!1}),c=new ee(a,d);c.renderOrder=5;const o=new he;o.add(c);const Z=[];let m=0,b=0;function h(V,r,u){for(const C of Z){const y=V-C.x,G=r-C.y,N=yb+(u+C.size)*.5;if(y*y+G*G<N*N)return!0}return!1}function p(){return 2200+Math.random()*2800}return{group:o,update(V){const r=n.width,u=n.height,C=Math.min(V*1e3,50);if(m+=C,b<=0&&(b=p()),m>=b){m=0,b=p();const y=.18,G=r*y,N=r*(1-y),I=Math.random()<.5?"left":"right",x=4+Math.random()*6;let U,R,g=12;do U=I==="left"?Math.random()*G:N+Math.random()*(r-N),R=Math.random()*u*.55;while(--g>0&&h(U,R,x));g>0&&Z.push({x:U,y:R,size:x,phase:"appear",opacity:0,life:0,appearDur:300,restDur:2e3+Math.random()*2500,slideVel:8+Math.random()*6,slideAccel:.8+Math.random()*.6})}i.clearRect(0,0,r,u);for(let y=Z.length-1;y>=0;y--){const G=Z[y];if(G.life+=C,G.phase==="appear")G.opacity=Math.min(1,G.life/G.appearDur*1.8),G.life>=G.appearDur&&(G.phase="rest",G.life=0,G.opacity=1);else if(G.phase==="rest")G.life>=G.restDur&&(G.phase="slide",G.life=0);else{const N=C/1e3;G.slideVel=(G.slideVel||8)+G.slideAccel*N*60,G.y+=G.slideVel*N;const I=G.y/u;if(G.opacity=I<.85?1:Math.max(0,(1-I)/.15),G.y>u+G.size*2){Z.splice(y,1);continue}}if(G.y<=u+G.size*2){i.save(),i.globalAlpha=G.opacity;const N=i.createRadialGradient(G.x-G.size*.3,G.y-G.size*.3,0,G.x,G.y,G.size*1.5);N.addColorStop(0,"rgba(230, 240, 255, 0.42)"),N.addColorStop(.4,"rgba(200, 218, 242, 0.28)"),N.addColorStop(.75,"rgba(170, 190, 215, 0.12)"),N.addColorStop(1,"rgba(150, 170, 195, 0)"),i.fillStyle=N,i.beginPath(),i.ellipse(G.x,G.y,G.size*.5,G.size*1.1,0,0,Math.PI*2),i.fill();const I=i.createRadialGradient(G.x-G.size*.25,G.y-G.size*.4,0,G.x-G.size*.25,G.y-G.size*.4,G.size*.6);I.addColorStop(0,`rgba(255,255,255,${.32*G.opacity})`),I.addColorStop(.55,`rgba(255,255,255,${.1*G.opacity})`),I.addColorStop(1,"rgba(255,255,255,0)"),i.fillStyle=I,i.beginPath(),i.ellipse(G.x-G.size*.2,G.y-G.size*.35,G.size*.35,G.size*.4,0,0,Math.PI*2),i.fill(),i.restore()}}s.needsUpdate=!0},setOpacity(V){const r=l.effectExtras?.effectOpacity?.droplets??1;d.opacity=.95*Math.max(0,Math.min(1,V/100))*r},dispose(){a.dispose(),d.dispose(),s.dispose()}}}function Sb(l){const t=l.viewWidth,e=l.viewHeight,n=l.effectExtras?.effectOpacity?.smog??1,i=new te(t,e),s={uTime:{value:0},uOpacity:{value:.18*(l.opacity/100)*n},uScale:{value:1.4},uResolution:{value:new ft(t,e)}},a=new ce({uniforms:s,vertexShader:ts,fragmentShader:`
      varying vec2 vUv;
      uniform float uTime;
      uniform float uOpacity;
      uniform float uScale;
      uniform vec2 uResolution;
      float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
      float noise(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(mix(hash(i), hash(i + vec2(1,0)), u.x), mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), u.x), u.y);
      }
      float fbm(vec2 p) {
        float v = 0.0, amp = 0.5;
        for (int i = 0; i < 4; i++) {
          v += amp * noise(p);
          p *= 2.0;
          amp *= 0.5;
        }
        return v;
      }
      void main() {
        vec2 aspect = vec2(uResolution.x / max(uResolution.y, 0.0001), 1.0);
        vec2 uv = (vUv - 0.5) * aspect + 0.5;
        uv *= uScale;
        uv += vec2(0.015, 0.06) * uTime;
        float d = fbm(uv);
        d = smoothstep(0.2, 0.65, d);
        float vMask = smoothstep(0.85, 0.25, vUv.y);
        vec3 color = vec3(0.55, 0.52, 0.48);
        gl_FragColor = vec4(color, d * vMask * uOpacity);
      }
    `,transparent:!0,depthWrite:!1,blending:Pe}),d=new ee(i,a);d.renderOrder=10;const c=new he;return c.add(d),{group:c,update(o){s.uTime.value+=o*.15},setOpacity(o){const Z=l.effectExtras?.effectOpacity?.smog??1;s.uOpacity.value=.18*Math.max(0,Math.min(1,o/100))*Z},dispose(){i.dispose(),a.dispose()}}}function Ib(l,t){const e=l.viewWidth,n=l.viewHeight,i=l.effectExtras?.effectOpacity?.aurora??1,s=new te(e*1.2,n*1.2),a={uTime:{value:0},uOpacity:{value:.5*(t||.5)*(l.opacity/100)*i},uResolution:{value:new ft(e,n)}},d=new ce({uniforms:a,vertexShader:`
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,fragmentShader:`
      varying vec2 vUv;
      uniform float uTime;
      uniform float uOpacity;
      uniform vec2 uResolution;
      float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
      float noise(vec2 p) {
        vec2 i = floor(p); vec2 f = fract(p);
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(mix(hash(i), hash(i+vec2(1,0)), u.x), mix(hash(i+vec2(0,1)), hash(i+vec2(1,1)), u.x), u.y);
      }
      float fbm(vec2 p) {
        float v = 0.0, amp = 0.5;
        for (int i = 0; i < 4; i++) { v += amp * noise(p); p *= 2.0; amp *= 0.5; }
        return v;
      }
      vec3 gradient(float t) {
        vec3 a = vec3(0.38, 0.65, 0.98);
        vec3 b = vec3(0.91, 0.47, 0.98);
        vec3 c = vec3(0.37, 0.92, 0.83);
        if (t < 0.2) return mix(a, b, smoothstep(0.0, 0.2, t));
        if (t < 0.4) return mix(b, a, smoothstep(0.2, 0.4, t));
        if (t < 0.6) return mix(a, c, smoothstep(0.4, 0.6, t));
        if (t < 0.8) return mix(c, a, smoothstep(0.6, 0.8, t));
        return mix(a, b, smoothstep(0.8, 1.0, t));
      }
      void main() {
        vec2 uv = vUv;
        float n = fbm(uv * 2.5 + uTime * 0.02) * 0.06;
        float t = fract(uv.x * 0.5 + (1.0 - uv.y) * 0.5 + uTime * 0.01 + n);
        vec3 col = gradient(t);
        vec2 fromTop = uv - vec2(0.5, 1.0);
        float dist = length(fromTop) * 1.6;
        float mask = 1.0 - smoothstep(0.15, 1.0, dist);
        mask = mask * mask;
        float alpha = mask * uOpacity * (0.94 + 0.06 * fbm(uv * 4.0));
        gl_FragColor = vec4(col, alpha);
      }
    `,transparent:!0,depthWrite:!1,blending:fe}),c=new ee(s,d);c.position.set(0,0,-9),c.renderOrder=9;const o=new he;o.add(c);let Z=t||.5;const m=()=>{const b=l.effectExtras?.effectOpacity?.aurora??1,h=.5*Z*Math.max(0,Math.min(1,l.opacity/100))*b;a.uOpacity.value=h};return{group:o,update(b){a.uTime.value+=b},setOpacity(){m()},setVisibilityScore(b){Z=b||.5,m()},dispose(){s.dispose(),d.dispose()}}}const es=[{width:1,colorA:[71/255,60/255,120/255],colorB:[247/255,42/255,59/255],speed:1.26},{width:.9,colorA:[24/255,196/255,153/255],colorB:[216/255,240/255,94/255],speed:1.57},{width:.8,colorA:[255/255,221/255,0/255],colorB:[62/255,51/255,255/255],speed:2.09},{width:.7,colorA:[120/255,24/255,72/255],colorB:[242/255,187/255,233/255],speed:3.14},{width:.6,colorA:[66/255,242/255,161/255],colorB:[244/255,246/255,173/255],speed:6.28}];function xb(l,t,e){if(e==="northern-gradients")return Ib(l,t);const n=l.viewWidth,i=l.viewHeight,s=l.effectExtras?.effectOpacity?.aurora??1,a=28,d=i/2-8,c=new he,o=`
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,Z=`
    varying vec2 vUv;
    uniform float uTime;
    uniform float uOpacity;
    uniform vec3 uColorA;
    uniform vec3 uColorB;
    uniform float uSpeed;
    uniform float uPulsePhase;
    void main() {
      float t = 0.5 + 0.5 * sin(uTime * uSpeed);
      vec3 col = mix(uColorA, uColorB, t);
      float fromTop = 1.0 - vUv.y;
      float fade = smoothstep(0.0, 0.4, fromTop) * smoothstep(1.15, 0.35, fromTop);
      float pulse = 0.96 + 0.04 * sin(uTime * 0.8 + uPulsePhase);
      float alpha = fade * uOpacity * pulse;
      gl_FragColor = vec4(col, alpha);
    }
  `;for(let p=0;p<es.length;p++){const V=es[p],r=n*1.05,u=a,C=new te(r,u),y=p/es.length*6.28,G={uTime:{value:0},uOpacity:{value:.28*(t||.5)*(l.opacity/100)*s},uColorA:{value:new J().fromArray(V.colorA)},uColorB:{value:new J().fromArray(V.colorB)},uSpeed:{value:V.speed*.4},uPulsePhase:{value:y}},N=new ce({uniforms:G,vertexShader:o,fragmentShader:Z,transparent:!0,depthWrite:!1,blending:fe}),I=new ee(C,N);I.position.set(0,d-p*(a+6),-8),I.renderOrder=9,c.add(I)}let m=t||.5;const b=c.children,h=()=>{const p=l.effectExtras?.effectOpacity?.aurora??1,V=.28*m*Math.max(0,Math.min(1,l.opacity/100))*p;for(const r of b)r.material.uniforms.uOpacity.value=V};return{group:c,update(p){for(const V of b)V.material.uniforms.uTime.value+=p},setOpacity(){h()},setVisibilityScore(p){m=p||.5,h()},dispose(){for(const p of b)p.geometry.dispose(),p.material.dispose()}}}const jd=200;function Yb(l,t){const e=l==="fog_dense",n=e?.32:.22,i=t?.85:1,s=e?[{scale:2.2*i,speed:.28,intensity:1,flow:new ft(.08,.02),low:.25,high:.78,contrast:1.1,color:[.86,.89,.95]},{scale:2.8*i,speed:.36,intensity:.85,flow:new ft(-.05,.025),low:.2,high:.7,contrast:1.22,color:[.9,.92,.97]}]:[{scale:2.5*i,speed:.22,intensity:.75,flow:new ft(.05,.015),low:.3,high:.82,contrast:1.15,color:[.88,.91,.96]},{scale:3.2*i,speed:.3,intensity:.55,flow:new ft(-.03,.012),low:.25,high:.75,contrast:1.22,color:[.8,.84,.92]}];return{baseOpacity:n,layers:s}}const Nb=`
  varying vec2 vUv;
  uniform float uTime;
  uniform float uOpacity;
  uniform float uScale;
  uniform vec2 uFlow;
  uniform vec2 uResolution;
  uniform float uLow;
  uniform float uHigh;
  uniform float uContrast;
  uniform vec3 uColor;
  float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123); }
  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(
      mix(hash(i), hash(i + vec2(1,0)), u.x),
      mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), u.x), u.y);
  }
  float fbm(vec2 p) {
    float v = 0.0, amp = 0.5;
    for (int i = 0; i < 5; i++) {
      v += amp * noise(p);
      p *= 2.0;
      amp *= 0.5;
    }
    return v;
  }
  void main() {
    vec2 aspect = vec2(uResolution.x / max(uResolution.y, 0.0001), 1.0);
    vec2 uv = (vUv - 0.5) * aspect + 0.5;
    uv *= uScale;
    uv += uFlow * uTime;
    float primary = fbm(uv);
    float detail = fbm(uv * 1.8 - uFlow.yx * (uTime * 0.35));
    float density = mix(primary, detail, 0.35);
    density = smoothstep(uLow, uHigh, density);
    density = pow(density, uContrast);
    float vMask = 1.0 - smoothstep(0.0, 1.0, vUv.y);
    gl_FragColor = vec4(uColor, density * vMask * uOpacity);
  }
`;function fb(l){const t=new he,e=Yb(l.effect,l.isMobile),n=l.cloudCoverage,i=n!=null?.6+n/100*.5:1,s=l.effectOpacity?.fog??1,a=Math.min(jd,l.viewHeight*.25),d=-l.viewHeight/2+a/2,c=e.layers.map(o=>{const Z=new te(l.viewWidth,a),m={uTime:{value:0},uOpacity:{value:e.baseOpacity*o.intensity*(l.opacity/100)*i*s},uScale:{value:o.scale},uFlow:{value:o.flow.clone()},uResolution:{value:new ft(l.viewWidth,l.viewHeight)},uLow:{value:o.low},uHigh:{value:o.high},uContrast:{value:o.contrast},uColor:{value:new Kt(o.color[0],o.color[1],o.color[2])}},b=new ce({uniforms:m,vertexShader:ts,fragmentShader:Nb,transparent:!0,depthWrite:!1,blending:Pe}),h=new ee(Z,b);return h.position.set(0,d,0),h.renderOrder=-3,t.add(h),{mesh:h,uniforms:m,config:o}});return{group:t,update(o){c.forEach(Z=>{Z.uniforms.uTime.value+=o*Z.config.speed})},setOpacity(o){const Z=Math.max(0,Math.min(1,o/100)),m=l.isMobile?.75:1;c.forEach(b=>{b.uniforms.uOpacity.value=e.baseOpacity*b.config.intensity*Z*m*i*s})},onResize(o,Z){l.viewWidth=o,l.viewHeight=Z;const m=Math.min(jd,Z*.25),b=-Z/2+m/2;c.forEach(h=>{h.uniforms.uResolution.value.set(o,Z),h.mesh.geometry.dispose(),h.mesh.geometry=new te(o,m),h.mesh.position.y=b})},dispose(){c.forEach(o=>{o.mesh.geometry.dispose(),o.mesh.material.dispose()})}}}function Fb(l){const t=new he,e=l.effectOpacity?.sun??1;let n=new te(l.viewWidth,l.viewHeight);const i=l.sunPosition||{azimuth:180,elevation:45,uvIndex:3},s=Math.max(0,Math.min(1,(i.azimuth-90)/180)),a=.08+.35*(1-Math.min(90,Math.max(0,i.elevation))/90),d={uOpacity:{value:l.opacity/100*e},uViewSize:{value:new ft(l.viewWidth,l.viewHeight)},uOrigin:{value:new ft(s,a)},uUvIndex:{value:i.uvIndex}},c=new ce({uniforms:d,vertexShader:"varying vec3 vPosition; void main() { vPosition = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }",fragmentShader:`
      varying vec3 vPosition;
      uniform vec2 uViewSize;
      uniform vec2 uOrigin;
      uniform float uOpacity;
      uniform float uUvIndex;
      void main() {
        vec2 uv = vec2((vPosition.x / uViewSize.x) + 0.5, (vPosition.y / uViewSize.y) + 0.5);
        vec2 dir = uOrigin - uv;
        float dist = length(dir);
        float intensity = smoothstep(0.85, 0.15, dist);
        float alpha = intensity * 0.28 * uOpacity;
        vec3 color;
        if (uUvIndex >= 6.0) {
          color = mix(vec3(1.0, 0.5, 0.15), vec3(1.0, 0.35, 0.1), dist);
        } else if (uUvIndex >= 4.0) {
          color = mix(vec3(1.0, 0.75, 0.35), vec3(1.0, 0.55, 0.2), dist);
        } else {
          color = mix(vec3(1.0, 0.95, 0.8), vec3(1.0, 0.85, 0.4), dist);
        }
        gl_FragColor = vec4(color, alpha);
      }
    `,transparent:!0,depthWrite:!1,blending:fe}),o=new ee(n,c);return o.position.set(0,0,-2),t.add(o),{group:t,update(Z,m,b){if(b?.sunPosition){const h=b.sunPosition;d.uOrigin.value.set(Math.max(0,Math.min(1,(h.azimuth-90)/180)),.08+.35*(1-Math.min(90,Math.max(0,h.elevation))/90)),d.uUvIndex.value=h.uvIndex??3}},setOpacity(Z){d.uOpacity.value=Math.max(0,Math.min(1,Z/100))*e},onResize(Z,m){l.viewWidth=Z,l.viewHeight=m,d.uViewSize.value.set(Z,m),n.dispose(),n=new te(Z,m),o.geometry=n},dispose(){n.dispose(),c.dispose()}}}function Lb(l){const t=new he,e=.6,n=l.cloudCoverage,i=n!=null?.5+n/100*.5:1,s=l.effectOpacity?.clouds??1,a=l.cloudSpeedMultiplier??1;let d=new te(l.viewWidth,l.viewHeight*e);const c={uTime:{value:0},uOpacity:{value:l.opacity/100*.14*i*s},uViewSize:{value:new ft(l.viewWidth,l.viewHeight)},uScale:{value:l.isMobile?1.5:1}},o=`
    varying vec2 vUv;
    uniform float uTime;
    uniform float uOpacity;
    uniform float uScale;
    float hash(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
    float noise(vec2 p) {
      vec2 i = floor(p);
      vec2 f = fract(p);
      vec2 u = f * f * (3.0 - 2.0 * f);
      return mix(mix(hash(i), hash(i+vec2(1,0)), u.x), mix(hash(i+vec2(0,1)), hash(i+vec2(1,1)), u.x), u.y);
    }
    float fbm(vec2 p) {
      float v = 0.0, amp = 0.5, freq = 1.0;
      for (int i = 0; i < 6; i++) {
        v += amp * noise(p * freq);
        amp *= 0.5;
        freq *= 2.0;
      }
      return v;
    }
    void main() {
      vec2 uv = vUv * uScale;
      float time = uTime * 0.05;
      vec2 q = vec2(fbm(uv + vec2(time * 0.5, time * 0.2)), fbm(uv + vec2(1.0)));
      vec2 r = vec2(fbm(uv + q + vec2(1.7, 9.2) + 0.15 * time), fbm(uv + q + vec2(8.3, 2.8) + 0.126 * time));
      float f = fbm(uv + r);
      float cloud = smoothstep(0.2, 0.7, f);
      cloud *= smoothstep(0.0, 0.3, vUv.y);
      cloud *= smoothstep(1.0, 0.8, vUv.y);
      float shadow = smoothstep(0.3, 0.6, fbm(uv * 2.0 + r + vec2(0.5)));
      vec3 color = mix(vec3(0.81, 0.82, 0.89), vec3(1.0), shadow * 0.8 + 0.2);
      gl_FragColor = vec4(color, cloud * uOpacity);
    }
  `,Z=new ce({uniforms:c,vertexShader:"varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }",fragmentShader:o,transparent:!0,depthWrite:!1,blending:Pe}),m=new ee(d,Z);return m.position.set(0,l.viewHeight*.25,-6),m.renderOrder=-2,t.add(m),{group:t,update(b){c.uTime.value+=b*a},setOpacity(b){c.uOpacity.value=Math.max(0,Math.min(1,b/100))*.14*i*s},onResize(b,h,p){d.dispose(),d=new te(b,h*e),m.geometry=d,c.uViewSize.value.set(b,h),c.uScale.value=p?1.5:1,m.position.set(0,h*.25,-6)},dispose(){d.dispose(),Z.dispose()}}}function _d(l){const t=new he,e=`
    varying vec2 vUv;
    uniform float uFlash;
    uniform vec2 uOrigin;
    uniform float uTime;
    float hash(float n) { return fract(sin(n) * 43758.5453); }
    float jaggedLine(vec2 uv, float anchor, float seed) {
      float segments = 8.0;
      float progress = clamp(1.0 - uv.y, 0.0, 0.999) * segments;
      float idx = floor(progress);
      float frac = fract(progress);
      float offsetA = hash(seed + idx) * 0.24 - 0.12;
      float offsetB = hash(seed + idx + 1.0) * 0.24 - 0.12;
      float offset = mix(offsetA, offsetB, smoothstep(0.0, 1.0, frac));
      float width = mix(0.006, 0.02, hash(seed + idx * 1.7));
      float target = anchor + offset;
      float dist = abs(uv.x - target);
      float intensity = smoothstep(width, 0.0, dist);
      float fade = smoothstep(0.0, 0.9, 1.0 - uv.y);
      return intensity * fade;
    }
    void main() {
      float seed = floor(uTime * 11.0);
      float core = jaggedLine(vUv, uOrigin.x, seed);
      float halo = jaggedLine(vUv, uOrigin.x + 0.008, seed + 2.0) * 0.4;
      float alpha = clamp((core + halo) * uFlash, 0.0, 1.0);
      gl_FragColor = vec4(1.0, 0.98, 0.9, alpha);
    }
  `,n={uFlash:{value:0},uOrigin:{value:new ft(.85,1.05)},uTime:{value:0}};let i=new te(l.viewWidth,l.viewHeight);const s=new ce({uniforms:n,vertexShader:ts,fragmentShader:e,transparent:!0,depthWrite:!1,depthTest:!1,blending:fe}),a=new ee(i,s);a.position.set(0,0,-6),a.renderOrder=25,t.add(a);let d=new te(l.viewWidth,l.viewHeight);const c=new Nn({color:16777215,transparent:!0,opacity:0,depthWrite:!1,depthTest:!1,blending:fe}),o=new ee(d,c);o.position.set(0,0,-8),o.renderOrder=30,t.add(o);const Z=20;let m=jt.randFloat(1,3),b=0,h=.25,p=0,V=-1;const r=Math.max(0,Math.min(1,l.opacity/100)),u=()=>{h=jt.randFloat(.18,.32),b=h,n.uFlash.value=1,n.uOrigin.value.set(jt.randFloat(.6,.95),jt.randFloat(.85,1.05)),c.opacity=Math.max(c.opacity,.55*r+.15)};return{group:t,update(C,y,G){const N=G?.lightningData,I=typeof G?.speed_factor_lightning=="number"?G.speed_factor_lightning:1;if(N&&(N.strikesToTrigger>0||N.distanceKm>0)){if(N.strikesToTrigger>0&&p<=0){const x=N.distanceKm*3;V=y+x,p=Z}V>0&&y>=V&&(V=-1,u()),p=Math.max(0,p-C*I)}else m-=C*I,m<=0&&(m=jt.randFloat(1.5,4),u());if(n.uTime.value+=C,b>0){b-=C;const x=Math.max(0,b/Math.max(h,.001));n.uFlash.value=Math.pow(x,1.4)*r}else n.uFlash.value>0&&(n.uFlash.value=Math.max(0,n.uFlash.value-C*8));c.opacity=Math.max(0,c.opacity-C*6)},setOpacity(C){const y=Math.max(0,Math.min(1,C/100));n.uFlash.value*=y/r},onResize(C,y){l.viewWidth=C,l.viewHeight=y,i.dispose(),i=new te(C,y),a.geometry=i,d.dispose(),d=new te(C,y),o.geometry=d},dispose(){i.dispose(),s.dispose(),d.dispose(),c.dispose()}}}function Mb(l){const t=new he,e=l.isMobile?10:15,n=new te(.25,.25),i=new Bd;i.index=n.index,i.attributes.position=n.attributes.position,i.attributes.uv=n.attributes.uv,i.instanceCount=e;const s=new Float32Array(e*3),a=new Float32Array(e),d=new Float32Array(e),c=new Float32Array(e),o=new Float32Array(e);for(let h=0;h<e;h++){const p=h*3;s[p]=jt.randFloatSpread(l.viewWidth+10),s[p+1]=jt.randFloatSpread(l.viewHeight),s[p+2]=Math.random()*2,a[h]=jt.randFloat(2.8,4),d[h]=jt.randFloat(1.8,2.8),c[h]=Math.random()*Math.PI*2,o[h]=Math.random()}i.setAttribute("instanceOffset",new _e(s,3)),i.setAttribute("instanceSpeed",new _e(a,1)),i.setAttribute("instanceSize",new _e(d,1)),i.setAttribute("instanceRotation",new _e(c,1)),i.setAttribute("instancePhase",new _e(o,1));const Z={uTime:{value:0},uOpacity:{value:l.opacity/100},uViewSize:{value:new ft(l.viewWidth,l.viewHeight)}},m=new ce({uniforms:Z,vertexShader:`
      attribute vec3 instanceOffset;
      attribute float instanceSpeed;
      attribute float instanceSize;
      attribute float instanceRotation;
      attribute float instancePhase;
      uniform float uTime;
      uniform vec2 uViewSize;
      varying float vAlpha;
      void main() {
        float progress = fract(uTime * instanceSpeed + instancePhase);
        float travel = (uViewSize.y * 0.5) - progress * (uViewSize.y + 20.0);
        float angle = instanceRotation + uTime * instanceSpeed * 3.0;
        vec2 rotated = vec2(position.x * cos(angle) - position.y * sin(angle), position.x * sin(angle) + position.y * cos(angle));
        vec3 transformed = vec3(rotated * instanceSize, position.z);
        transformed.x += instanceOffset.x;
        transformed.y += travel + instanceOffset.y;
        transformed.z += -5.0 + instanceOffset.z;
        vAlpha = 1.0;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
      }
    `,fragmentShader:`
      uniform float uOpacity;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(0.95, 0.98, 1.0, vAlpha * uOpacity);
      }
    `,transparent:!0,depthWrite:!1,blending:Pe}),b=new ee(i,m);return b.frustumCulled=!1,t.add(b),{group:t,update(h){Z.uTime.value+=h,Z.uViewSize.value.set(l.viewWidth,l.viewHeight)},setOpacity(h){Z.uOpacity.value=Math.max(0,Math.min(1,h/100))},onResize(h,p){l.viewWidth=h,l.viewHeight=p,Z.uViewSize.value.set(h,p)},dispose(){i.dispose(),m.dispose()}}}const Dd="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiOy8qKgogKiBAbGljZW5zZQogKiBDb3B5cmlnaHQgMjAxMC0yMDI0IFRocmVlLmpzIEF1dGhvcnMKICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVAogKi9jb25zdCBOaT0iMTcwIixqdD0iIixidD0ic3JnYiIseG49InNyZ2ItbGluZWFyIixpaT0ibGluZWFyIixxZT0ic3JnYiIsTXI9IjMwMCBlcyI7Y2xhc3MgTW57YWRkRXZlbnRMaXN0ZW5lcihlLHQpe3RoaXMuX2xpc3RlbmVycz09PXZvaWQgMCYmKHRoaXMuX2xpc3RlbmVycz17fSk7Y29uc3QgaT10aGlzLl9saXN0ZW5lcnM7aVtlXT09PXZvaWQgMCYmKGlbZV09W10pLGlbZV0uaW5kZXhPZih0KT09PS0xJiZpW2VdLnB1c2godCl9aGFzRXZlbnRMaXN0ZW5lcihlLHQpe2lmKHRoaXMuX2xpc3RlbmVycz09PXZvaWQgMClyZXR1cm4hMTtjb25zdCBpPXRoaXMuX2xpc3RlbmVycztyZXR1cm4gaVtlXSE9PXZvaWQgMCYmaVtlXS5pbmRleE9mKHQpIT09LTF9cmVtb3ZlRXZlbnRMaXN0ZW5lcihlLHQpe2lmKHRoaXMuX2xpc3RlbmVycz09PXZvaWQgMClyZXR1cm47Y29uc3Qgcj10aGlzLl9saXN0ZW5lcnNbZV07aWYociE9PXZvaWQgMCl7Y29uc3Qgcz1yLmluZGV4T2YodCk7cyE9PS0xJiZyLnNwbGljZShzLDEpfX1kaXNwYXRjaEV2ZW50KGUpe2lmKHRoaXMuX2xpc3RlbmVycz09PXZvaWQgMClyZXR1cm47Y29uc3QgaT10aGlzLl9saXN0ZW5lcnNbZS50eXBlXTtpZihpIT09dm9pZCAwKXtlLnRhcmdldD10aGlzO2NvbnN0IHI9aS5zbGljZSgwKTtmb3IobGV0IHM9MCxvPXIubGVuZ3RoO3M8bztzKyspcltzXS5jYWxsKHRoaXMsZSk7ZS50YXJnZXQ9bnVsbH19fWNvbnN0IGZ0PVsiMDAiLCIwMSIsIjAyIiwiMDMiLCIwNCIsIjA1IiwiMDYiLCIwNyIsIjA4IiwiMDkiLCIwYSIsIjBiIiwiMGMiLCIwZCIsIjBlIiwiMGYiLCIxMCIsIjExIiwiMTIiLCIxMyIsIjE0IiwiMTUiLCIxNiIsIjE3IiwiMTgiLCIxOSIsIjFhIiwiMWIiLCIxYyIsIjFkIiwiMWUiLCIxZiIsIjIwIiwiMjEiLCIyMiIsIjIzIiwiMjQiLCIyNSIsIjI2IiwiMjciLCIyOCIsIjI5IiwiMmEiLCIyYiIsIjJjIiwiMmQiLCIyZSIsIjJmIiwiMzAiLCIzMSIsIjMyIiwiMzMiLCIzNCIsIjM1IiwiMzYiLCIzNyIsIjM4IiwiMzkiLCIzYSIsIjNiIiwiM2MiLCIzZCIsIjNlIiwiM2YiLCI0MCIsIjQxIiwiNDIiLCI0MyIsIjQ0IiwiNDUiLCI0NiIsIjQ3IiwiNDgiLCI0OSIsIjRhIiwiNGIiLCI0YyIsIjRkIiwiNGUiLCI0ZiIsIjUwIiwiNTEiLCI1MiIsIjUzIiwiNTQiLCI1NSIsIjU2IiwiNTciLCI1OCIsIjU5IiwiNWEiLCI1YiIsIjVjIiwiNWQiLCI1ZSIsIjVmIiwiNjAiLCI2MSIsIjYyIiwiNjMiLCI2NCIsIjY1IiwiNjYiLCI2NyIsIjY4IiwiNjkiLCI2YSIsIjZiIiwiNmMiLCI2ZCIsIjZlIiwiNmYiLCI3MCIsIjcxIiwiNzIiLCI3MyIsIjc0IiwiNzUiLCI3NiIsIjc3IiwiNzgiLCI3OSIsIjdhIiwiN2IiLCI3YyIsIjdkIiwiN2UiLCI3ZiIsIjgwIiwiODEiLCI4MiIsIjgzIiwiODQiLCI4NSIsIjg2IiwiODciLCI4OCIsIjg5IiwiOGEiLCI4YiIsIjhjIiwiOGQiLCI4ZSIsIjhmIiwiOTAiLCI5MSIsIjkyIiwiOTMiLCI5NCIsIjk1IiwiOTYiLCI5NyIsIjk4IiwiOTkiLCI5YSIsIjliIiwiOWMiLCI5ZCIsIjllIiwiOWYiLCJhMCIsImExIiwiYTIiLCJhMyIsImE0IiwiYTUiLCJhNiIsImE3IiwiYTgiLCJhOSIsImFhIiwiYWIiLCJhYyIsImFkIiwiYWUiLCJhZiIsImIwIiwiYjEiLCJiMiIsImIzIiwiYjQiLCJiNSIsImI2IiwiYjciLCJiOCIsImI5IiwiYmEiLCJiYiIsImJjIiwiYmQiLCJiZSIsImJmIiwiYzAiLCJjMSIsImMyIiwiYzMiLCJjNCIsImM1IiwiYzYiLCJjNyIsImM4IiwiYzkiLCJjYSIsImNiIiwiY2MiLCJjZCIsImNlIiwiY2YiLCJkMCIsImQxIiwiZDIiLCJkMyIsImQ0IiwiZDUiLCJkNiIsImQ3IiwiZDgiLCJkOSIsImRhIiwiZGIiLCJkYyIsImRkIiwiZGUiLCJkZiIsImUwIiwiZTEiLCJlMiIsImUzIiwiZTQiLCJlNSIsImU2IiwiZTciLCJlOCIsImU5IiwiZWEiLCJlYiIsImVjIiwiZWQiLCJlZSIsImVmIiwiZjAiLCJmMSIsImYyIiwiZjMiLCJmNCIsImY1IiwiZjYiLCJmNyIsImY4IiwiZjkiLCJmYSIsImZiIiwiZmMiLCJmZCIsImZlIiwiZmYiXTtsZXQgU3I9MTIzNDU2Nztjb25zdCBIbj1NYXRoLlBJLzE4MCxWbj0xODAvTWF0aC5QSTtmdW5jdGlvbiBTbigpe2NvbnN0IG49TWF0aC5yYW5kb20oKSo0Mjk0OTY3Mjk1fDAsZT1NYXRoLnJhbmRvbSgpKjQyOTQ5NjcyOTV8MCx0PU1hdGgucmFuZG9tKCkqNDI5NDk2NzI5NXwwLGk9TWF0aC5yYW5kb20oKSo0Mjk0OTY3Mjk1fDA7cmV0dXJuKGZ0W24mMjU1XStmdFtuPj44JjI1NV0rZnRbbj4+MTYmMjU1XStmdFtuPj4yNCYyNTVdKyItIitmdFtlJjI1NV0rZnRbZT4+OCYyNTVdKyItIitmdFtlPj4xNiYxNXw2NF0rZnRbZT4+MjQmMjU1XSsiLSIrZnRbdCY2M3wxMjhdK2Z0W3Q+PjgmMjU1XSsiLSIrZnRbdD4+MTYmMjU1XStmdFt0Pj4yNCYyNTVdK2Z0W2kmMjU1XStmdFtpPj44JjI1NV0rZnRbaT4+MTYmMjU1XStmdFtpPj4yNCYyNTVdKS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIGd0KG4sZSx0KXtyZXR1cm4gTWF0aC5tYXgoZSxNYXRoLm1pbih0LG4pKX1mdW5jdGlvbiBPaShuLGUpe3JldHVybihuJWUrZSklZX1mdW5jdGlvbiBLcyhuLGUsdCxpLHIpe3JldHVybiBpKyhuLWUpKihyLWkpLyh0LWUpfWZ1bmN0aW9uIFpzKG4sZSx0KXtyZXR1cm4gbiE9PWU/KHQtbikvKGUtbik6MH1mdW5jdGlvbiBrbihuLGUsdCl7cmV0dXJuKDEtdCkqbit0KmV9ZnVuY3Rpb24ganMobixlLHQsaSl7cmV0dXJuIGtuKG4sZSwxLU1hdGguZXhwKC10KmkpKX1mdW5jdGlvbiBKcyhuLGU9MSl7cmV0dXJuIGUtTWF0aC5hYnMoT2kobixlKjIpLWUpfWZ1bmN0aW9uIFFzKG4sZSx0KXtyZXR1cm4gbjw9ZT8wOm4+PXQ/MToobj0obi1lKS8odC1lKSxuKm4qKDMtMipuKSl9ZnVuY3Rpb24gZWEobixlLHQpe3JldHVybiBuPD1lPzA6bj49dD8xOihuPShuLWUpLyh0LWUpLG4qbipuKihuKihuKjYtMTUpKzEwKSl9ZnVuY3Rpb24gdGEobixlKXtyZXR1cm4gbitNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKGUtbisxKSl9ZnVuY3Rpb24gbmEobixlKXtyZXR1cm4gbitNYXRoLnJhbmRvbSgpKihlLW4pfWZ1bmN0aW9uIGlhKG4pe3JldHVybiBuKiguNS1NYXRoLnJhbmRvbSgpKX1mdW5jdGlvbiByYShuKXtuIT09dm9pZCAwJiYoU3I9bik7bGV0IGU9U3IrPTE4MzE1NjU4MTM7cmV0dXJuIGU9TWF0aC5pbXVsKGVeZT4+PjE1LGV8MSksZV49ZStNYXRoLmltdWwoZV5lPj4+NyxlfDYxKSwoKGVeZT4+PjE0KT4+PjApLzQyOTQ5NjcyOTZ9ZnVuY3Rpb24gc2Eobil7cmV0dXJuIG4qSG59ZnVuY3Rpb24gYWEobil7cmV0dXJuIG4qVm59ZnVuY3Rpb24gb2Eobil7cmV0dXJuKG4mbi0xKT09PTAmJm4hPT0wfWZ1bmN0aW9uIGxhKG4pe3JldHVybiBNYXRoLnBvdygyLE1hdGguY2VpbChNYXRoLmxvZyhuKS9NYXRoLkxOMikpfWZ1bmN0aW9uIGNhKG4pe3JldHVybiBNYXRoLnBvdygyLE1hdGguZmxvb3IoTWF0aC5sb2cobikvTWF0aC5MTjIpKX1mdW5jdGlvbiB1YShuLGUsdCxpLHIpe2NvbnN0IHM9TWF0aC5jb3Msbz1NYXRoLnNpbixhPXModC8yKSxsPW8odC8yKSxjPXMoKGUraSkvMiksdT1vKChlK2kpLzIpLGQ9cygoZS1pKS8yKSxmPW8oKGUtaSkvMikscD1zKChpLWUpLzIpLGc9bygoaS1lKS8yKTtzd2l0Y2gocil7Y2FzZSJYWVgiOm4uc2V0KGEqdSxsKmQsbCpmLGEqYyk7YnJlYWs7Y2FzZSJZWlkiOm4uc2V0KGwqZixhKnUsbCpkLGEqYyk7YnJlYWs7Y2FzZSJaWFoiOm4uc2V0KGwqZCxsKmYsYSp1LGEqYyk7YnJlYWs7Y2FzZSJYWlgiOm4uc2V0KGEqdSxsKmcsbCpwLGEqYyk7YnJlYWs7Y2FzZSJZWFkiOm4uc2V0KGwqcCxhKnUsbCpnLGEqYyk7YnJlYWs7Y2FzZSJaWVoiOm4uc2V0KGwqZyxsKnAsYSp1LGEqYyk7YnJlYWs7ZGVmYXVsdDpjb25zb2xlLndhcm4oIlRIUkVFLk1hdGhVdGlsczogLnNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAiK3IpfX1mdW5jdGlvbiBFbihuLGUpe3N3aXRjaChlLmNvbnN0cnVjdG9yKXtjYXNlIEZsb2F0MzJBcnJheTpyZXR1cm4gbjtjYXNlIFVpbnQzMkFycmF5OnJldHVybiBuLzQyOTQ5NjcyOTU7Y2FzZSBVaW50MTZBcnJheTpyZXR1cm4gbi82NTUzNTtjYXNlIFVpbnQ4QXJyYXk6cmV0dXJuIG4vMjU1O2Nhc2UgSW50MzJBcnJheTpyZXR1cm4gTWF0aC5tYXgobi8yMTQ3NDgzNjQ3LC0xKTtjYXNlIEludDE2QXJyYXk6cmV0dXJuIE1hdGgubWF4KG4vMzI3NjcsLTEpO2Nhc2UgSW50OEFycmF5OnJldHVybiBNYXRoLm1heChuLzEyNywtMSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgY29tcG9uZW50IHR5cGUuIil9fWZ1bmN0aW9uIF90KG4sZSl7c3dpdGNoKGUuY29uc3RydWN0b3Ipe2Nhc2UgRmxvYXQzMkFycmF5OnJldHVybiBuO2Nhc2UgVWludDMyQXJyYXk6cmV0dXJuIE1hdGgucm91bmQobio0Mjk0OTY3Mjk1KTtjYXNlIFVpbnQxNkFycmF5OnJldHVybiBNYXRoLnJvdW5kKG4qNjU1MzUpO2Nhc2UgVWludDhBcnJheTpyZXR1cm4gTWF0aC5yb3VuZChuKjI1NSk7Y2FzZSBJbnQzMkFycmF5OnJldHVybiBNYXRoLnJvdW5kKG4qMjE0NzQ4MzY0Nyk7Y2FzZSBJbnQxNkFycmF5OnJldHVybiBNYXRoLnJvdW5kKG4qMzI3NjcpO2Nhc2UgSW50OEFycmF5OnJldHVybiBNYXRoLnJvdW5kKG4qMTI3KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiSW52YWxpZCBjb21wb25lbnQgdHlwZS4iKX19Y29uc3QgJGU9e0RFRzJSQUQ6SG4sUkFEMkRFRzpWbixnZW5lcmF0ZVVVSUQ6U24sY2xhbXA6Z3QsZXVjbGlkZWFuTW9kdWxvOk9pLG1hcExpbmVhcjpLcyxpbnZlcnNlTGVycDpacyxsZXJwOmtuLGRhbXA6anMscGluZ3Bvbmc6SnMsc21vb3Roc3RlcDpRcyxzbW9vdGhlcnN0ZXA6ZWEscmFuZEludDp0YSxyYW5kRmxvYXQ6bmEscmFuZEZsb2F0U3ByZWFkOmlhLHNlZWRlZFJhbmRvbTpyYSxkZWdUb1JhZDpzYSxyYWRUb0RlZzphYSxpc1Bvd2VyT2ZUd286b2EsY2VpbFBvd2VyT2ZUd286bGEsZmxvb3JQb3dlck9mVHdvOmNhLHNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXI6dWEsbm9ybWFsaXplOl90LGRlbm9ybWFsaXplOkVufTtjbGFzcyBQZXtjb25zdHJ1Y3RvcihlPTAsdD0wKXtQZS5wcm90b3R5cGUuaXNWZWN0b3IyPSEwLHRoaXMueD1lLHRoaXMueT10fWdldCB3aWR0aCgpe3JldHVybiB0aGlzLnh9c2V0IHdpZHRoKGUpe3RoaXMueD1lfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy55fXNldCBoZWlnaHQoZSl7dGhpcy55PWV9c2V0KGUsdCl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXN9c2V0U2NhbGFyKGUpe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9ZSx0aGlzfXNldFgoZSl7cmV0dXJuIHRoaXMueD1lLHRoaXN9c2V0WShlKXtyZXR1cm4gdGhpcy55PWUsdGhpc31zZXRDb21wb25lbnQoZSx0KXtzd2l0Y2goZSl7Y2FzZSAwOnRoaXMueD10O2JyZWFrO2Nhc2UgMTp0aGlzLnk9dDticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAiK2UpfXJldHVybiB0aGlzfWdldENvbXBvbmVudChlKXtzd2l0Y2goZSl7Y2FzZSAwOnJldHVybiB0aGlzLng7Y2FzZSAxOnJldHVybiB0aGlzLnk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoImluZGV4IGlzIG91dCBvZiByYW5nZTogIitlKX19Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54LHRoaXMueSl9Y29weShlKXtyZXR1cm4gdGhpcy54PWUueCx0aGlzLnk9ZS55LHRoaXN9YWRkKGUpe3JldHVybiB0aGlzLngrPWUueCx0aGlzLnkrPWUueSx0aGlzfWFkZFNjYWxhcihlKXtyZXR1cm4gdGhpcy54Kz1lLHRoaXMueSs9ZSx0aGlzfWFkZFZlY3RvcnMoZSx0KXtyZXR1cm4gdGhpcy54PWUueCt0LngsdGhpcy55PWUueSt0LnksdGhpc31hZGRTY2FsZWRWZWN0b3IoZSx0KXtyZXR1cm4gdGhpcy54Kz1lLngqdCx0aGlzLnkrPWUueSp0LHRoaXN9c3ViKGUpe3JldHVybiB0aGlzLngtPWUueCx0aGlzLnktPWUueSx0aGlzfXN1YlNjYWxhcihlKXtyZXR1cm4gdGhpcy54LT1lLHRoaXMueS09ZSx0aGlzfXN1YlZlY3RvcnMoZSx0KXtyZXR1cm4gdGhpcy54PWUueC10LngsdGhpcy55PWUueS10LnksdGhpc31tdWx0aXBseShlKXtyZXR1cm4gdGhpcy54Kj1lLngsdGhpcy55Kj1lLnksdGhpc31tdWx0aXBseVNjYWxhcihlKXtyZXR1cm4gdGhpcy54Kj1lLHRoaXMueSo9ZSx0aGlzfWRpdmlkZShlKXtyZXR1cm4gdGhpcy54Lz1lLngsdGhpcy55Lz1lLnksdGhpc31kaXZpZGVTY2FsYXIoZSl7cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMS9lKX1hcHBseU1hdHJpeDMoZSl7Y29uc3QgdD10aGlzLngsaT10aGlzLnkscj1lLmVsZW1lbnRzO3JldHVybiB0aGlzLng9clswXSp0K3JbM10qaStyWzZdLHRoaXMueT1yWzFdKnQrcls0XSppK3JbN10sdGhpc31taW4oZSl7cmV0dXJuIHRoaXMueD1NYXRoLm1pbih0aGlzLngsZS54KSx0aGlzLnk9TWF0aC5taW4odGhpcy55LGUueSksdGhpc31tYXgoZSl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0aGlzLngsZS54KSx0aGlzLnk9TWF0aC5tYXgodGhpcy55LGUueSksdGhpc31jbGFtcChlLHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgoZS54LE1hdGgubWluKHQueCx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgoZS55LE1hdGgubWluKHQueSx0aGlzLnkpKSx0aGlzfWNsYW1wU2NhbGFyKGUsdCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heChlLE1hdGgubWluKHQsdGhpcy54KSksdGhpcy55PU1hdGgubWF4KGUsTWF0aC5taW4odCx0aGlzLnkpKSx0aGlzfWNsYW1wTGVuZ3RoKGUsdCl7Y29uc3QgaT10aGlzLmxlbmd0aCgpO3JldHVybiB0aGlzLmRpdmlkZVNjYWxhcihpfHwxKS5tdWx0aXBseVNjYWxhcihNYXRoLm1heChlLE1hdGgubWluKHQsaSkpKX1mbG9vcigpe3JldHVybiB0aGlzLng9TWF0aC5mbG9vcih0aGlzLngpLHRoaXMueT1NYXRoLmZsb29yKHRoaXMueSksdGhpc31jZWlsKCl7cmV0dXJuIHRoaXMueD1NYXRoLmNlaWwodGhpcy54KSx0aGlzLnk9TWF0aC5jZWlsKHRoaXMueSksdGhpc31yb3VuZCgpe3JldHVybiB0aGlzLng9TWF0aC5yb3VuZCh0aGlzLngpLHRoaXMueT1NYXRoLnJvdW5kKHRoaXMueSksdGhpc31yb3VuZFRvWmVybygpe3JldHVybiB0aGlzLng9TWF0aC50cnVuYyh0aGlzLngpLHRoaXMueT1NYXRoLnRydW5jKHRoaXMueSksdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy54PS10aGlzLngsdGhpcy55PS10aGlzLnksdGhpc31kb3QoZSl7cmV0dXJuIHRoaXMueCplLngrdGhpcy55KmUueX1jcm9zcyhlKXtyZXR1cm4gdGhpcy54KmUueS10aGlzLnkqZS54fWxlbmd0aFNxKCl7cmV0dXJuIHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueX1sZW5ndGgoKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSl9bWFuaGF0dGFuTGVuZ3RoKCl7cmV0dXJuIE1hdGguYWJzKHRoaXMueCkrTWF0aC5hYnModGhpcy55KX1ub3JtYWxpemUoKXtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKXx8MSl9YW5nbGUoKXtyZXR1cm4gTWF0aC5hdGFuMigtdGhpcy55LC10aGlzLngpK01hdGguUEl9YW5nbGVUbyhlKXtjb25zdCB0PU1hdGguc3FydCh0aGlzLmxlbmd0aFNxKCkqZS5sZW5ndGhTcSgpKTtpZih0PT09MClyZXR1cm4gTWF0aC5QSS8yO2NvbnN0IGk9dGhpcy5kb3QoZSkvdDtyZXR1cm4gTWF0aC5hY29zKGd0KGksLTEsMSkpfWRpc3RhbmNlVG8oZSl7cmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKGUpKX1kaXN0YW5jZVRvU3F1YXJlZChlKXtjb25zdCB0PXRoaXMueC1lLngsaT10aGlzLnktZS55O3JldHVybiB0KnQraSppfW1hbmhhdHRhbkRpc3RhbmNlVG8oZSl7cmV0dXJuIE1hdGguYWJzKHRoaXMueC1lLngpK01hdGguYWJzKHRoaXMueS1lLnkpfXNldExlbmd0aChlKXtyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihlKX1sZXJwKGUsdCl7cmV0dXJuIHRoaXMueCs9KGUueC10aGlzLngpKnQsdGhpcy55Kz0oZS55LXRoaXMueSkqdCx0aGlzfWxlcnBWZWN0b3JzKGUsdCxpKXtyZXR1cm4gdGhpcy54PWUueCsodC54LWUueCkqaSx0aGlzLnk9ZS55Kyh0LnktZS55KSppLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLng9PT10aGlzLngmJmUueT09PXRoaXMueX1mcm9tQXJyYXkoZSx0PTApe3JldHVybiB0aGlzLng9ZVt0XSx0aGlzLnk9ZVt0KzFdLHRoaXN9dG9BcnJheShlPVtdLHQ9MCl7cmV0dXJuIGVbdF09dGhpcy54LGVbdCsxXT10aGlzLnksZX1mcm9tQnVmZmVyQXR0cmlidXRlKGUsdCl7cmV0dXJuIHRoaXMueD1lLmdldFgodCksdGhpcy55PWUuZ2V0WSh0KSx0aGlzfXJvdGF0ZUFyb3VuZChlLHQpe2NvbnN0IGk9TWF0aC5jb3ModCkscj1NYXRoLnNpbih0KSxzPXRoaXMueC1lLngsbz10aGlzLnktZS55O3JldHVybiB0aGlzLng9cyppLW8qcitlLngsdGhpcy55PXMqcitvKmkrZS55LHRoaXN9cmFuZG9tKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJhbmRvbSgpLHRoaXMueT1NYXRoLnJhbmRvbSgpLHRoaXN9KltTeW1ib2wuaXRlcmF0b3JdKCl7eWllbGQgdGhpcy54LHlpZWxkIHRoaXMueX19Y2xhc3MgYmV7Y29uc3RydWN0b3IoZSx0LGkscixzLG8sYSxsLGMpe2JlLnByb3RvdHlwZS5pc01hdHJpeDM9ITAsdGhpcy5lbGVtZW50cz1bMSwwLDAsMCwxLDAsMCwwLDFdLGUhPT12b2lkIDAmJnRoaXMuc2V0KGUsdCxpLHIscyxvLGEsbCxjKX1zZXQoZSx0LGkscixzLG8sYSxsLGMpe2NvbnN0IHU9dGhpcy5lbGVtZW50cztyZXR1cm4gdVswXT1lLHVbMV09cix1WzJdPWEsdVszXT10LHVbNF09cyx1WzVdPWwsdVs2XT1pLHVbN109byx1WzhdPWMsdGhpc31pZGVudGl0eSgpe3JldHVybiB0aGlzLnNldCgxLDAsMCwwLDEsMCwwLDAsMSksdGhpc31jb3B5KGUpe2NvbnN0IHQ9dGhpcy5lbGVtZW50cyxpPWUuZWxlbWVudHM7cmV0dXJuIHRbMF09aVswXSx0WzFdPWlbMV0sdFsyXT1pWzJdLHRbM109aVszXSx0WzRdPWlbNF0sdFs1XT1pWzVdLHRbNl09aVs2XSx0WzddPWlbN10sdFs4XT1pWzhdLHRoaXN9ZXh0cmFjdEJhc2lzKGUsdCxpKXtyZXR1cm4gZS5zZXRGcm9tTWF0cml4M0NvbHVtbih0aGlzLDApLHQuc2V0RnJvbU1hdHJpeDNDb2x1bW4odGhpcywxKSxpLnNldEZyb21NYXRyaXgzQ29sdW1uKHRoaXMsMiksdGhpc31zZXRGcm9tTWF0cml4NChlKXtjb25zdCB0PWUuZWxlbWVudHM7cmV0dXJuIHRoaXMuc2V0KHRbMF0sdFs0XSx0WzhdLHRbMV0sdFs1XSx0WzldLHRbMl0sdFs2XSx0WzEwXSksdGhpc31tdWx0aXBseShlKXtyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHRoaXMsZSl9cHJlbXVsdGlwbHkoZSl7cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyhlLHRoaXMpfW11bHRpcGx5TWF0cmljZXMoZSx0KXtjb25zdCBpPWUuZWxlbWVudHMscj10LmVsZW1lbnRzLHM9dGhpcy5lbGVtZW50cyxvPWlbMF0sYT1pWzNdLGw9aVs2XSxjPWlbMV0sdT1pWzRdLGQ9aVs3XSxmPWlbMl0scD1pWzVdLGc9aVs4XSx4PXJbMF0sbT1yWzNdLGg9cls2XSxUPXJbMV0seT1yWzRdLF89cls3XSxDPXJbMl0sdz1yWzVdLGI9cls4XTtyZXR1cm4gc1swXT1vKngrYSpUK2wqQyxzWzNdPW8qbSthKnkrbCp3LHNbNl09bypoK2EqXytsKmIsc1sxXT1jKngrdSpUK2QqQyxzWzRdPWMqbSt1KnkrZCp3LHNbN109YypoK3UqXytkKmIsc1syXT1mKngrcCpUK2cqQyxzWzVdPWYqbStwKnkrZyp3LHNbOF09ZipoK3AqXytnKmIsdGhpc31tdWx0aXBseVNjYWxhcihlKXtjb25zdCB0PXRoaXMuZWxlbWVudHM7cmV0dXJuIHRbMF0qPWUsdFszXSo9ZSx0WzZdKj1lLHRbMV0qPWUsdFs0XSo9ZSx0WzddKj1lLHRbMl0qPWUsdFs1XSo9ZSx0WzhdKj1lLHRoaXN9ZGV0ZXJtaW5hbnQoKXtjb25zdCBlPXRoaXMuZWxlbWVudHMsdD1lWzBdLGk9ZVsxXSxyPWVbMl0scz1lWzNdLG89ZVs0XSxhPWVbNV0sbD1lWzZdLGM9ZVs3XSx1PWVbOF07cmV0dXJuIHQqbyp1LXQqYSpjLWkqcyp1K2kqYSpsK3IqcypjLXIqbypsfWludmVydCgpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyx0PWVbMF0saT1lWzFdLHI9ZVsyXSxzPWVbM10sbz1lWzRdLGE9ZVs1XSxsPWVbNl0sYz1lWzddLHU9ZVs4XSxkPXUqby1hKmMsZj1hKmwtdSpzLHA9YypzLW8qbCxnPXQqZCtpKmYrcipwO2lmKGc9PT0wKXJldHVybiB0aGlzLnNldCgwLDAsMCwwLDAsMCwwLDAsMCk7Y29uc3QgeD0xL2c7cmV0dXJuIGVbMF09ZCp4LGVbMV09KHIqYy11KmkpKngsZVsyXT0oYSppLXIqbykqeCxlWzNdPWYqeCxlWzRdPSh1KnQtcipsKSp4LGVbNV09KHIqcy1hKnQpKngsZVs2XT1wKngsZVs3XT0oaSpsLWMqdCkqeCxlWzhdPShvKnQtaSpzKSp4LHRoaXN9dHJhbnNwb3NlKCl7bGV0IGU7Y29uc3QgdD10aGlzLmVsZW1lbnRzO3JldHVybiBlPXRbMV0sdFsxXT10WzNdLHRbM109ZSxlPXRbMl0sdFsyXT10WzZdLHRbNl09ZSxlPXRbNV0sdFs1XT10WzddLHRbN109ZSx0aGlzfWdldE5vcm1hbE1hdHJpeChlKXtyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4NChlKS5pbnZlcnQoKS50cmFuc3Bvc2UoKX10cmFuc3Bvc2VJbnRvQXJyYXkoZSl7Y29uc3QgdD10aGlzLmVsZW1lbnRzO3JldHVybiBlWzBdPXRbMF0sZVsxXT10WzNdLGVbMl09dFs2XSxlWzNdPXRbMV0sZVs0XT10WzRdLGVbNV09dFs3XSxlWzZdPXRbMl0sZVs3XT10WzVdLGVbOF09dFs4XSx0aGlzfXNldFV2VHJhbnNmb3JtKGUsdCxpLHIscyxvLGEpe2NvbnN0IGw9TWF0aC5jb3MocyksYz1NYXRoLnNpbihzKTtyZXR1cm4gdGhpcy5zZXQoaSpsLGkqYywtaSoobCpvK2MqYSkrbytlLC1yKmMscipsLC1yKigtYypvK2wqYSkrYSt0LDAsMCwxKSx0aGlzfXNjYWxlKGUsdCl7cmV0dXJuIHRoaXMucHJlbXVsdGlwbHkoQmkubWFrZVNjYWxlKGUsdCkpLHRoaXN9cm90YXRlKGUpe3JldHVybiB0aGlzLnByZW11bHRpcGx5KEJpLm1ha2VSb3RhdGlvbigtZSkpLHRoaXN9dHJhbnNsYXRlKGUsdCl7cmV0dXJuIHRoaXMucHJlbXVsdGlwbHkoQmkubWFrZVRyYW5zbGF0aW9uKGUsdCkpLHRoaXN9bWFrZVRyYW5zbGF0aW9uKGUsdCl7cmV0dXJuIGUuaXNWZWN0b3IyP3RoaXMuc2V0KDEsMCxlLngsMCwxLGUueSwwLDAsMSk6dGhpcy5zZXQoMSwwLGUsMCwxLHQsMCwwLDEpLHRoaXN9bWFrZVJvdGF0aW9uKGUpe2NvbnN0IHQ9TWF0aC5jb3MoZSksaT1NYXRoLnNpbihlKTtyZXR1cm4gdGhpcy5zZXQodCwtaSwwLGksdCwwLDAsMCwxKSx0aGlzfW1ha2VTY2FsZShlLHQpe3JldHVybiB0aGlzLnNldChlLDAsMCwwLHQsMCwwLDAsMSksdGhpc31lcXVhbHMoZSl7Y29uc3QgdD10aGlzLmVsZW1lbnRzLGk9ZS5lbGVtZW50cztmb3IobGV0IHI9MDtyPDk7cisrKWlmKHRbcl0hPT1pW3JdKXJldHVybiExO3JldHVybiEwfWZyb21BcnJheShlLHQ9MCl7Zm9yKGxldCBpPTA7aTw5O2krKyl0aGlzLmVsZW1lbnRzW2ldPWVbaSt0XTtyZXR1cm4gdGhpc310b0FycmF5KGU9W10sdD0wKXtjb25zdCBpPXRoaXMuZWxlbWVudHM7cmV0dXJuIGVbdF09aVswXSxlW3QrMV09aVsxXSxlW3QrMl09aVsyXSxlW3QrM109aVszXSxlW3QrNF09aVs0XSxlW3QrNV09aVs1XSxlW3QrNl09aVs2XSxlW3QrN109aVs3XSxlW3QrOF09aVs4XSxlfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KHRoaXMuZWxlbWVudHMpfX1jb25zdCBCaT1uZXcgYmU7ZnVuY3Rpb24gRXIobil7Zm9yKGxldCBlPW4ubGVuZ3RoLTE7ZT49MDstLWUpaWYobltlXT49NjU1MzUpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gcmkobil7cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIsbil9ZnVuY3Rpb24gaGEoKXtjb25zdCBuPXJpKCJjYW52YXMiKTtyZXR1cm4gbi5zdHlsZS5kaXNwbGF5PSJibG9jayIsbn1jb25zdCB5cj17fTtmdW5jdGlvbiBXbihuKXtuIGluIHlyfHwoeXJbbl09ITAsY29uc29sZS53YXJuKG4pKX1mdW5jdGlvbiBkYShuLGUsdCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGkscil7ZnVuY3Rpb24gcygpe3N3aXRjaChuLmNsaWVudFdhaXRTeW5jKGUsbi5TWU5DX0ZMVVNIX0NPTU1BTkRTX0JJVCwwKSl7Y2FzZSBuLldBSVRfRkFJTEVEOnIoKTticmVhaztjYXNlIG4uVElNRU9VVF9FWFBJUkVEOnNldFRpbWVvdXQocyx0KTticmVhaztkZWZhdWx0OmkoKX19c2V0VGltZW91dChzLHQpfSl9ZnVuY3Rpb24gZmEobil7Y29uc3QgZT1uLmVsZW1lbnRzO2VbMl09LjUqZVsyXSsuNSplWzNdLGVbNl09LjUqZVs2XSsuNSplWzddLGVbMTBdPS41KmVbMTBdKy41KmVbMTFdLGVbMTRdPS41KmVbMTRdKy41KmVbMTVdfWZ1bmN0aW9uIHBhKG4pe2NvbnN0IGU9bi5lbGVtZW50cztlWzExXT09PS0xPyhlWzEwXT0tZVsxMF0tMSxlWzE0XT0tZVsxNF0pOihlWzEwXT0tZVsxMF0sZVsxNF09LWVbMTRdKzEpfWNvbnN0IEJlPXtlbmFibGVkOiEwLHdvcmtpbmdDb2xvclNwYWNlOnhuLHNwYWNlczp7fSxjb252ZXJ0OmZ1bmN0aW9uKG4sZSx0KXtyZXR1cm4gdGhpcy5lbmFibGVkPT09ITF8fGU9PT10fHwhZXx8IXR8fCh0aGlzLnNwYWNlc1tlXS50cmFuc2Zlcj09PXFlJiYobi5yPVZ0KG4uciksbi5nPVZ0KG4uZyksbi5iPVZ0KG4uYikpLHRoaXMuc3BhY2VzW2VdLnByaW1hcmllcyE9PXRoaXMuc3BhY2VzW3RdLnByaW1hcmllcyYmKG4uYXBwbHlNYXRyaXgzKHRoaXMuc3BhY2VzW2VdLnRvWFlaKSxuLmFwcGx5TWF0cml4Myh0aGlzLnNwYWNlc1t0XS5mcm9tWFlaKSksdGhpcy5zcGFjZXNbdF0udHJhbnNmZXI9PT1xZSYmKG4ucj15bihuLnIpLG4uZz15bihuLmcpLG4uYj15bihuLmIpKSksbn0sZnJvbVdvcmtpbmdDb2xvclNwYWNlOmZ1bmN0aW9uKG4sZSl7cmV0dXJuIHRoaXMuY29udmVydChuLHRoaXMud29ya2luZ0NvbG9yU3BhY2UsZSl9LHRvV29ya2luZ0NvbG9yU3BhY2U6ZnVuY3Rpb24obixlKXtyZXR1cm4gdGhpcy5jb252ZXJ0KG4sZSx0aGlzLndvcmtpbmdDb2xvclNwYWNlKX0sZ2V0UHJpbWFyaWVzOmZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnNwYWNlc1tuXS5wcmltYXJpZXN9LGdldFRyYW5zZmVyOmZ1bmN0aW9uKG4pe3JldHVybiBuPT09anQ/aWk6dGhpcy5zcGFjZXNbbl0udHJhbnNmZXJ9LGdldEx1bWluYW5jZUNvZWZmaWNpZW50czpmdW5jdGlvbihuLGU9dGhpcy53b3JraW5nQ29sb3JTcGFjZSl7cmV0dXJuIG4uZnJvbUFycmF5KHRoaXMuc3BhY2VzW2VdLmx1bWluYW5jZUNvZWZmaWNpZW50cyl9LGRlZmluZTpmdW5jdGlvbihuKXtPYmplY3QuYXNzaWduKHRoaXMuc3BhY2VzLG4pfSxfZ2V0TWF0cml4OmZ1bmN0aW9uKG4sZSx0KXtyZXR1cm4gbi5jb3B5KHRoaXMuc3BhY2VzW2VdLnRvWFlaKS5tdWx0aXBseSh0aGlzLnNwYWNlc1t0XS5mcm9tWFlaKX0sX2dldERyYXdpbmdCdWZmZXJDb2xvclNwYWNlOmZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnNwYWNlc1tuXS5vdXRwdXRDb2xvclNwYWNlQ29uZmlnLmRyYXdpbmdCdWZmZXJDb2xvclNwYWNlfSxfZ2V0VW5wYWNrQ29sb3JTcGFjZTpmdW5jdGlvbihuPXRoaXMud29ya2luZ0NvbG9yU3BhY2Upe3JldHVybiB0aGlzLnNwYWNlc1tuXS53b3JraW5nQ29sb3JTcGFjZUNvbmZpZy51bnBhY2tDb2xvclNwYWNlfX07ZnVuY3Rpb24gVnQobil7cmV0dXJuIG48LjA0MDQ1P24qLjA3NzM5OTM4MDg6TWF0aC5wb3cobiouOTQ3ODY3Mjk4NisuMDUyMTMyNzAxNCwyLjQpfWZ1bmN0aW9uIHluKG4pe3JldHVybiBuPC4wMDMxMzA4P24qMTIuOTI6MS4wNTUqTWF0aC5wb3cobiwuNDE2NjYpLS4wNTV9Y29uc3QgVHI9Wy42NCwuMzMsLjMsLjYsLjE1LC4wNl0sQXI9Wy4yMTI2LC43MTUyLC4wNzIyXSx3cj1bLjMxMjcsLjMyOV0sYnI9bmV3IGJlKCkuc2V0KC40MTIzOTA4LC4zNTc1ODQzLC4xODA0ODA4LC4yMTI2MzksLjcxNTE2ODcsLjA3MjE5MjMsLjAxOTMzMDgsLjExOTE5NDgsLjk1MDUzMjIpLFJyPW5ldyBiZSgpLnNldCgzLjI0MDk2OTksLTEuNTM3MzgzMiwtLjQ5ODYxMDgsLS45NjkyNDM2LDEuODc1OTY3NSwuMDQxNTU1MSwuMDU1NjMwMSwtLjIwMzk3NywxLjA1Njk3MTUpO0JlLmRlZmluZSh7W3huXTp7cHJpbWFyaWVzOlRyLHdoaXRlUG9pbnQ6d3IsdHJhbnNmZXI6aWksdG9YWVo6YnIsZnJvbVhZWjpScixsdW1pbmFuY2VDb2VmZmljaWVudHM6QXIsd29ya2luZ0NvbG9yU3BhY2VDb25maWc6e3VucGFja0NvbG9yU3BhY2U6YnR9LG91dHB1dENvbG9yU3BhY2VDb25maWc6e2RyYXdpbmdCdWZmZXJDb2xvclNwYWNlOmJ0fX0sW2J0XTp7cHJpbWFyaWVzOlRyLHdoaXRlUG9pbnQ6d3IsdHJhbnNmZXI6cWUsdG9YWVo6YnIsZnJvbVhZWjpScixsdW1pbmFuY2VDb2VmZmljaWVudHM6QXIsb3V0cHV0Q29sb3JTcGFjZUNvbmZpZzp7ZHJhd2luZ0J1ZmZlckNvbG9yU3BhY2U6YnR9fX0pO2xldCBUbjtjbGFzcyBtYXtzdGF0aWMgZ2V0RGF0YVVSTChlKXtpZigvXmRhdGE6L2kudGVzdChlLnNyYyl8fHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudD4idSIpcmV0dXJuIGUuc3JjO2xldCB0O2lmKGUgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCl0PWU7ZWxzZXtUbj09PXZvaWQgMCYmKFRuPXJpKCJjYW52YXMiKSksVG4ud2lkdGg9ZS53aWR0aCxUbi5oZWlnaHQ9ZS5oZWlnaHQ7Y29uc3QgaT1Ubi5nZXRDb250ZXh0KCIyZCIpO2UgaW5zdGFuY2VvZiBJbWFnZURhdGE/aS5wdXRJbWFnZURhdGEoZSwwLDApOmkuZHJhd0ltYWdlKGUsMCwwLGUud2lkdGgsZS5oZWlnaHQpLHQ9VG59cmV0dXJuIHQud2lkdGg+MjA0OHx8dC5oZWlnaHQ+MjA0OD8oY29uc29sZS53YXJuKCJUSFJFRS5JbWFnZVV0aWxzLmdldERhdGFVUkw6IEltYWdlIGNvbnZlcnRlZCB0byBqcGcgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMiLGUpLHQudG9EYXRhVVJMKCJpbWFnZS9qcGVnIiwuNikpOnQudG9EYXRhVVJMKCJpbWFnZS9wbmciKX1zdGF0aWMgc1JHQlRvTGluZWFyKGUpe2lmKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50PCJ1IiYmZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnR8fHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudDwidSImJmUgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudHx8dHlwZW9mIEltYWdlQml0bWFwPCJ1IiYmZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKXtjb25zdCB0PXJpKCJjYW52YXMiKTt0LndpZHRoPWUud2lkdGgsdC5oZWlnaHQ9ZS5oZWlnaHQ7Y29uc3QgaT10LmdldENvbnRleHQoIjJkIik7aS5kcmF3SW1hZ2UoZSwwLDAsZS53aWR0aCxlLmhlaWdodCk7Y29uc3Qgcj1pLmdldEltYWdlRGF0YSgwLDAsZS53aWR0aCxlLmhlaWdodCkscz1yLmRhdGE7Zm9yKGxldCBvPTA7bzxzLmxlbmd0aDtvKyspc1tvXT1WdChzW29dLzI1NSkqMjU1O3JldHVybiBpLnB1dEltYWdlRGF0YShyLDAsMCksdH1lbHNlIGlmKGUuZGF0YSl7Y29uc3QgdD1lLmRhdGEuc2xpY2UoMCk7Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDtpKyspdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheT90W2ldPU1hdGguZmxvb3IoVnQodFtpXS8yNTUpKjI1NSk6dFtpXT1WdCh0W2ldKTtyZXR1cm57ZGF0YTp0LHdpZHRoOmUud2lkdGgsaGVpZ2h0OmUuaGVpZ2h0fX1lbHNlIHJldHVybiBjb25zb2xlLndhcm4oIlRIUkVFLkltYWdlVXRpbHMuc1JHQlRvTGluZWFyKCk6IFVuc3VwcG9ydGVkIGltYWdlIHR5cGUuIE5vIGNvbG9yIHNwYWNlIGNvbnZlcnNpb24gYXBwbGllZC4iKSxlfX1sZXQgZ2E9MDtjbGFzcyBDcntjb25zdHJ1Y3RvcihlPW51bGwpe3RoaXMuaXNTb3VyY2U9ITAsT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImlkIix7dmFsdWU6Z2ErK30pLHRoaXMudXVpZD1TbigpLHRoaXMuZGF0YT1lLHRoaXMuZGF0YVJlYWR5PSEwLHRoaXMudmVyc2lvbj0wfXNldCBuZWVkc1VwZGF0ZShlKXtlPT09ITAmJnRoaXMudmVyc2lvbisrfXRvSlNPTihlKXtjb25zdCB0PWU9PT12b2lkIDB8fHR5cGVvZiBlPT0ic3RyaW5nIjtpZighdCYmZS5pbWFnZXNbdGhpcy51dWlkXSE9PXZvaWQgMClyZXR1cm4gZS5pbWFnZXNbdGhpcy51dWlkXTtjb25zdCBpPXt1dWlkOnRoaXMudXVpZCx1cmw6IiJ9LHI9dGhpcy5kYXRhO2lmKHIhPT1udWxsKXtsZXQgcztpZihBcnJheS5pc0FycmF5KHIpKXtzPVtdO2ZvcihsZXQgbz0wLGE9ci5sZW5ndGg7bzxhO28rKylyW29dLmlzRGF0YVRleHR1cmU/cy5wdXNoKHppKHJbb10uaW1hZ2UpKTpzLnB1c2goemkocltvXSkpfWVsc2Ugcz16aShyKTtpLnVybD1zfXJldHVybiB0fHwoZS5pbWFnZXNbdGhpcy51dWlkXT1pKSxpfX1mdW5jdGlvbiB6aShuKXtyZXR1cm4gdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQ8InUiJiZuIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudHx8dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50PCJ1IiYmbiBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50fHx0eXBlb2YgSW1hZ2VCaXRtYXA8InUiJiZuIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXA/bWEuZ2V0RGF0YVVSTChuKTpuLmRhdGE/e2RhdGE6QXJyYXkuZnJvbShuLmRhdGEpLHdpZHRoOm4ud2lkdGgsaGVpZ2h0Om4uaGVpZ2h0LHR5cGU6bi5kYXRhLmNvbnN0cnVjdG9yLm5hbWV9Oihjb25zb2xlLndhcm4oIlRIUkVFLlRleHR1cmU6IFVuYWJsZSB0byBzZXJpYWxpemUgVGV4dHVyZS4iKSx7fSl9bGV0IF9hPTA7Y2xhc3MgdnQgZXh0ZW5kcyBNbntjb25zdHJ1Y3RvcihlPXZ0LkRFRkFVTFRfSU1BR0UsdD12dC5ERUZBVUxUX01BUFBJTkcsaT0xMDAxLHI9MTAwMSxzPTEwMDYsbz0xMDA4LGE9MTAyMyxsPTEwMDksYz12dC5ERUZBVUxUX0FOSVNPVFJPUFksdT1qdCl7c3VwZXIoKSx0aGlzLmlzVGV4dHVyZT0hMCxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiaWQiLHt2YWx1ZTpfYSsrfSksdGhpcy51dWlkPVNuKCksdGhpcy5uYW1lPSIiLHRoaXMuc291cmNlPW5ldyBDcihlKSx0aGlzLm1pcG1hcHM9W10sdGhpcy5tYXBwaW5nPXQsdGhpcy5jaGFubmVsPTAsdGhpcy53cmFwUz1pLHRoaXMud3JhcFQ9cix0aGlzLm1hZ0ZpbHRlcj1zLHRoaXMubWluRmlsdGVyPW8sdGhpcy5hbmlzb3Ryb3B5PWMsdGhpcy5mb3JtYXQ9YSx0aGlzLmludGVybmFsRm9ybWF0PW51bGwsdGhpcy50eXBlPWwsdGhpcy5vZmZzZXQ9bmV3IFBlKDAsMCksdGhpcy5yZXBlYXQ9bmV3IFBlKDEsMSksdGhpcy5jZW50ZXI9bmV3IFBlKDAsMCksdGhpcy5yb3RhdGlvbj0wLHRoaXMubWF0cml4QXV0b1VwZGF0ZT0hMCx0aGlzLm1hdHJpeD1uZXcgYmUsdGhpcy5nZW5lcmF0ZU1pcG1hcHM9ITAsdGhpcy5wcmVtdWx0aXBseUFscGhhPSExLHRoaXMuZmxpcFk9ITAsdGhpcy51bnBhY2tBbGlnbm1lbnQ9NCx0aGlzLmNvbG9yU3BhY2U9dSx0aGlzLnVzZXJEYXRhPXt9LHRoaXMudmVyc2lvbj0wLHRoaXMub25VcGRhdGU9bnVsbCx0aGlzLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hMSx0aGlzLnBtcmVtVmVyc2lvbj0wfWdldCBpbWFnZSgpe3JldHVybiB0aGlzLnNvdXJjZS5kYXRhfXNldCBpbWFnZShlPW51bGwpe3RoaXMuc291cmNlLmRhdGE9ZX11cGRhdGVNYXRyaXgoKXt0aGlzLm1hdHJpeC5zZXRVdlRyYW5zZm9ybSh0aGlzLm9mZnNldC54LHRoaXMub2Zmc2V0LnksdGhpcy5yZXBlYXQueCx0aGlzLnJlcGVhdC55LHRoaXMucm90YXRpb24sdGhpcy5jZW50ZXIueCx0aGlzLmNlbnRlci55KX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9Y29weShlKXtyZXR1cm4gdGhpcy5uYW1lPWUubmFtZSx0aGlzLnNvdXJjZT1lLnNvdXJjZSx0aGlzLm1pcG1hcHM9ZS5taXBtYXBzLnNsaWNlKDApLHRoaXMubWFwcGluZz1lLm1hcHBpbmcsdGhpcy5jaGFubmVsPWUuY2hhbm5lbCx0aGlzLndyYXBTPWUud3JhcFMsdGhpcy53cmFwVD1lLndyYXBULHRoaXMubWFnRmlsdGVyPWUubWFnRmlsdGVyLHRoaXMubWluRmlsdGVyPWUubWluRmlsdGVyLHRoaXMuYW5pc290cm9weT1lLmFuaXNvdHJvcHksdGhpcy5mb3JtYXQ9ZS5mb3JtYXQsdGhpcy5pbnRlcm5hbEZvcm1hdD1lLmludGVybmFsRm9ybWF0LHRoaXMudHlwZT1lLnR5cGUsdGhpcy5vZmZzZXQuY29weShlLm9mZnNldCksdGhpcy5yZXBlYXQuY29weShlLnJlcGVhdCksdGhpcy5jZW50ZXIuY29weShlLmNlbnRlciksdGhpcy5yb3RhdGlvbj1lLnJvdGF0aW9uLHRoaXMubWF0cml4QXV0b1VwZGF0ZT1lLm1hdHJpeEF1dG9VcGRhdGUsdGhpcy5tYXRyaXguY29weShlLm1hdHJpeCksdGhpcy5nZW5lcmF0ZU1pcG1hcHM9ZS5nZW5lcmF0ZU1pcG1hcHMsdGhpcy5wcmVtdWx0aXBseUFscGhhPWUucHJlbXVsdGlwbHlBbHBoYSx0aGlzLmZsaXBZPWUuZmxpcFksdGhpcy51bnBhY2tBbGlnbm1lbnQ9ZS51bnBhY2tBbGlnbm1lbnQsdGhpcy5jb2xvclNwYWNlPWUuY29sb3JTcGFjZSx0aGlzLnVzZXJEYXRhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZS51c2VyRGF0YSkpLHRoaXMubmVlZHNVcGRhdGU9ITAsdGhpc310b0pTT04oZSl7Y29uc3QgdD1lPT09dm9pZCAwfHx0eXBlb2YgZT09InN0cmluZyI7aWYoIXQmJmUudGV4dHVyZXNbdGhpcy51dWlkXSE9PXZvaWQgMClyZXR1cm4gZS50ZXh0dXJlc1t0aGlzLnV1aWRdO2NvbnN0IGk9e21ldGFkYXRhOnt2ZXJzaW9uOjQuNix0eXBlOiJUZXh0dXJlIixnZW5lcmF0b3I6IlRleHR1cmUudG9KU09OIn0sdXVpZDp0aGlzLnV1aWQsbmFtZTp0aGlzLm5hbWUsaW1hZ2U6dGhpcy5zb3VyY2UudG9KU09OKGUpLnV1aWQsbWFwcGluZzp0aGlzLm1hcHBpbmcsY2hhbm5lbDp0aGlzLmNoYW5uZWwscmVwZWF0Olt0aGlzLnJlcGVhdC54LHRoaXMucmVwZWF0LnldLG9mZnNldDpbdGhpcy5vZmZzZXQueCx0aGlzLm9mZnNldC55XSxjZW50ZXI6W3RoaXMuY2VudGVyLngsdGhpcy5jZW50ZXIueV0scm90YXRpb246dGhpcy5yb3RhdGlvbix3cmFwOlt0aGlzLndyYXBTLHRoaXMud3JhcFRdLGZvcm1hdDp0aGlzLmZvcm1hdCxpbnRlcm5hbEZvcm1hdDp0aGlzLmludGVybmFsRm9ybWF0LHR5cGU6dGhpcy50eXBlLGNvbG9yU3BhY2U6dGhpcy5jb2xvclNwYWNlLG1pbkZpbHRlcjp0aGlzLm1pbkZpbHRlcixtYWdGaWx0ZXI6dGhpcy5tYWdGaWx0ZXIsYW5pc290cm9weTp0aGlzLmFuaXNvdHJvcHksZmxpcFk6dGhpcy5mbGlwWSxnZW5lcmF0ZU1pcG1hcHM6dGhpcy5nZW5lcmF0ZU1pcG1hcHMscHJlbXVsdGlwbHlBbHBoYTp0aGlzLnByZW11bHRpcGx5QWxwaGEsdW5wYWNrQWxpZ25tZW50OnRoaXMudW5wYWNrQWxpZ25tZW50fTtyZXR1cm4gT2JqZWN0LmtleXModGhpcy51c2VyRGF0YSkubGVuZ3RoPjAmJihpLnVzZXJEYXRhPXRoaXMudXNlckRhdGEpLHR8fChlLnRleHR1cmVzW3RoaXMudXVpZF09aSksaX1kaXNwb3NlKCl7dGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJkaXNwb3NlIn0pfXRyYW5zZm9ybVV2KGUpe2lmKHRoaXMubWFwcGluZyE9PTMwMClyZXR1cm4gZTtpZihlLmFwcGx5TWF0cml4Myh0aGlzLm1hdHJpeCksZS54PDB8fGUueD4xKXN3aXRjaCh0aGlzLndyYXBTKXtjYXNlIDFlMzplLng9ZS54LU1hdGguZmxvb3IoZS54KTticmVhaztjYXNlIDEwMDE6ZS54PWUueDwwPzA6MTticmVhaztjYXNlIDEwMDI6TWF0aC5hYnMoTWF0aC5mbG9vcihlLngpJTIpPT09MT9lLng9TWF0aC5jZWlsKGUueCktZS54OmUueD1lLngtTWF0aC5mbG9vcihlLngpO2JyZWFrfWlmKGUueTwwfHxlLnk+MSlzd2l0Y2godGhpcy53cmFwVCl7Y2FzZSAxZTM6ZS55PWUueS1NYXRoLmZsb29yKGUueSk7YnJlYWs7Y2FzZSAxMDAxOmUueT1lLnk8MD8wOjE7YnJlYWs7Y2FzZSAxMDAyOk1hdGguYWJzKE1hdGguZmxvb3IoZS55KSUyKT09PTE/ZS55PU1hdGguY2VpbChlLnkpLWUueTplLnk9ZS55LU1hdGguZmxvb3IoZS55KTticmVha31yZXR1cm4gdGhpcy5mbGlwWSYmKGUueT0xLWUueSksZX1zZXQgbmVlZHNVcGRhdGUoZSl7ZT09PSEwJiYodGhpcy52ZXJzaW9uKyssdGhpcy5zb3VyY2UubmVlZHNVcGRhdGU9ITApfXNldCBuZWVkc1BNUkVNVXBkYXRlKGUpe2U9PT0hMCYmdGhpcy5wbXJlbVZlcnNpb24rK319dnQuREVGQVVMVF9JTUFHRT1udWxsLHZ0LkRFRkFVTFRfTUFQUElORz0zMDAsdnQuREVGQVVMVF9BTklTT1RST1BZPTE7Y2xhc3MgcnR7Y29uc3RydWN0b3IoZT0wLHQ9MCxpPTAscj0xKXtydC5wcm90b3R5cGUuaXNWZWN0b3I0PSEwLHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1pLHRoaXMudz1yfWdldCB3aWR0aCgpe3JldHVybiB0aGlzLnp9c2V0IHdpZHRoKGUpe3RoaXMuej1lfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy53fXNldCBoZWlnaHQoZSl7dGhpcy53PWV9c2V0KGUsdCxpLHIpe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzLno9aSx0aGlzLnc9cix0aGlzfXNldFNjYWxhcihlKXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PWUsdGhpcy56PWUsdGhpcy53PWUsdGhpc31zZXRYKGUpe3JldHVybiB0aGlzLng9ZSx0aGlzfXNldFkoZSl7cmV0dXJuIHRoaXMueT1lLHRoaXN9c2V0WihlKXtyZXR1cm4gdGhpcy56PWUsdGhpc31zZXRXKGUpe3JldHVybiB0aGlzLnc9ZSx0aGlzfXNldENvbXBvbmVudChlLHQpe3N3aXRjaChlKXtjYXNlIDA6dGhpcy54PXQ7YnJlYWs7Y2FzZSAxOnRoaXMueT10O2JyZWFrO2Nhc2UgMjp0aGlzLno9dDticmVhaztjYXNlIDM6dGhpcy53PXQ7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoImluZGV4IGlzIG91dCBvZiByYW5nZTogIitlKX1yZXR1cm4gdGhpc31nZXRDb21wb25lbnQoZSl7c3dpdGNoKGUpe2Nhc2UgMDpyZXR1cm4gdGhpcy54O2Nhc2UgMTpyZXR1cm4gdGhpcy55O2Nhc2UgMjpyZXR1cm4gdGhpcy56O2Nhc2UgMzpyZXR1cm4gdGhpcy53O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIrZSl9fWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCx0aGlzLnksdGhpcy56LHRoaXMudyl9Y29weShlKXtyZXR1cm4gdGhpcy54PWUueCx0aGlzLnk9ZS55LHRoaXMuej1lLnosdGhpcy53PWUudyE9PXZvaWQgMD9lLnc6MSx0aGlzfWFkZChlKXtyZXR1cm4gdGhpcy54Kz1lLngsdGhpcy55Kz1lLnksdGhpcy56Kz1lLnosdGhpcy53Kz1lLncsdGhpc31hZGRTY2FsYXIoZSl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPWUsdGhpcy56Kz1lLHRoaXMudys9ZSx0aGlzfWFkZFZlY3RvcnMoZSx0KXtyZXR1cm4gdGhpcy54PWUueCt0LngsdGhpcy55PWUueSt0LnksdGhpcy56PWUueit0LnosdGhpcy53PWUudyt0LncsdGhpc31hZGRTY2FsZWRWZWN0b3IoZSx0KXtyZXR1cm4gdGhpcy54Kz1lLngqdCx0aGlzLnkrPWUueSp0LHRoaXMueis9ZS56KnQsdGhpcy53Kz1lLncqdCx0aGlzfXN1YihlKXtyZXR1cm4gdGhpcy54LT1lLngsdGhpcy55LT1lLnksdGhpcy56LT1lLnosdGhpcy53LT1lLncsdGhpc31zdWJTY2FsYXIoZSl7cmV0dXJuIHRoaXMueC09ZSx0aGlzLnktPWUsdGhpcy56LT1lLHRoaXMudy09ZSx0aGlzfXN1YlZlY3RvcnMoZSx0KXtyZXR1cm4gdGhpcy54PWUueC10LngsdGhpcy55PWUueS10LnksdGhpcy56PWUuei10LnosdGhpcy53PWUudy10LncsdGhpc31tdWx0aXBseShlKXtyZXR1cm4gdGhpcy54Kj1lLngsdGhpcy55Kj1lLnksdGhpcy56Kj1lLnosdGhpcy53Kj1lLncsdGhpc31tdWx0aXBseVNjYWxhcihlKXtyZXR1cm4gdGhpcy54Kj1lLHRoaXMueSo9ZSx0aGlzLnoqPWUsdGhpcy53Kj1lLHRoaXN9YXBwbHlNYXRyaXg0KGUpe2NvbnN0IHQ9dGhpcy54LGk9dGhpcy55LHI9dGhpcy56LHM9dGhpcy53LG89ZS5lbGVtZW50cztyZXR1cm4gdGhpcy54PW9bMF0qdCtvWzRdKmkrb1s4XSpyK29bMTJdKnMsdGhpcy55PW9bMV0qdCtvWzVdKmkrb1s5XSpyK29bMTNdKnMsdGhpcy56PW9bMl0qdCtvWzZdKmkrb1sxMF0qcitvWzE0XSpzLHRoaXMudz1vWzNdKnQrb1s3XSppK29bMTFdKnIrb1sxNV0qcyx0aGlzfWRpdmlkZShlKXtyZXR1cm4gdGhpcy54Lz1lLngsdGhpcy55Lz1lLnksdGhpcy56Lz1lLnosdGhpcy53Lz1lLncsdGhpc31kaXZpZGVTY2FsYXIoZSl7cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMS9lKX1zZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbihlKXt0aGlzLnc9MipNYXRoLmFjb3MoZS53KTtjb25zdCB0PU1hdGguc3FydCgxLWUudyplLncpO3JldHVybiB0PDFlLTQ/KHRoaXMueD0xLHRoaXMueT0wLHRoaXMuej0wKToodGhpcy54PWUueC90LHRoaXMueT1lLnkvdCx0aGlzLno9ZS56L3QpLHRoaXN9c2V0QXhpc0FuZ2xlRnJvbVJvdGF0aW9uTWF0cml4KGUpe2xldCB0LGkscixzO2NvbnN0IGw9ZS5lbGVtZW50cyxjPWxbMF0sdT1sWzRdLGQ9bFs4XSxmPWxbMV0scD1sWzVdLGc9bFs5XSx4PWxbMl0sbT1sWzZdLGg9bFsxMF07aWYoTWF0aC5hYnModS1mKTwuMDEmJk1hdGguYWJzKGQteCk8LjAxJiZNYXRoLmFicyhnLW0pPC4wMSl7aWYoTWF0aC5hYnModStmKTwuMSYmTWF0aC5hYnMoZCt4KTwuMSYmTWF0aC5hYnMoZyttKTwuMSYmTWF0aC5hYnMoYytwK2gtMyk8LjEpcmV0dXJuIHRoaXMuc2V0KDEsMCwwLDApLHRoaXM7dD1NYXRoLlBJO2NvbnN0IHk9KGMrMSkvMixfPShwKzEpLzIsQz0oaCsxKS8yLHc9KHUrZikvNCxiPShkK3gpLzQsRj0oZyttKS80O3JldHVybiB5Pl8mJnk+Qz95PC4wMT8oaT0wLHI9LjcwNzEwNjc4MSxzPS43MDcxMDY3ODEpOihpPU1hdGguc3FydCh5KSxyPXcvaSxzPWIvaSk6Xz5DP188LjAxPyhpPS43MDcxMDY3ODEscj0wLHM9LjcwNzEwNjc4MSk6KHI9TWF0aC5zcXJ0KF8pLGk9dy9yLHM9Ri9yKTpDPC4wMT8oaT0uNzA3MTA2NzgxLHI9LjcwNzEwNjc4MSxzPTApOihzPU1hdGguc3FydChDKSxpPWIvcyxyPUYvcyksdGhpcy5zZXQoaSxyLHMsdCksdGhpc31sZXQgVD1NYXRoLnNxcnQoKG0tZykqKG0tZykrKGQteCkqKGQteCkrKGYtdSkqKGYtdSkpO3JldHVybiBNYXRoLmFicyhUKTwuMDAxJiYoVD0xKSx0aGlzLng9KG0tZykvVCx0aGlzLnk9KGQteCkvVCx0aGlzLno9KGYtdSkvVCx0aGlzLnc9TWF0aC5hY29zKChjK3AraC0xKS8yKSx0aGlzfXNldEZyb21NYXRyaXhQb3NpdGlvbihlKXtjb25zdCB0PWUuZWxlbWVudHM7cmV0dXJuIHRoaXMueD10WzEyXSx0aGlzLnk9dFsxM10sdGhpcy56PXRbMTRdLHRoaXMudz10WzE1XSx0aGlzfW1pbihlKXtyZXR1cm4gdGhpcy54PU1hdGgubWluKHRoaXMueCxlLngpLHRoaXMueT1NYXRoLm1pbih0aGlzLnksZS55KSx0aGlzLno9TWF0aC5taW4odGhpcy56LGUueiksdGhpcy53PU1hdGgubWluKHRoaXMudyxlLncpLHRoaXN9bWF4KGUpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodGhpcy54LGUueCksdGhpcy55PU1hdGgubWF4KHRoaXMueSxlLnkpLHRoaXMuej1NYXRoLm1heCh0aGlzLnosZS56KSx0aGlzLnc9TWF0aC5tYXgodGhpcy53LGUudyksdGhpc31jbGFtcChlLHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgoZS54LE1hdGgubWluKHQueCx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgoZS55LE1hdGgubWluKHQueSx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgoZS56LE1hdGgubWluKHQueix0aGlzLnopKSx0aGlzLnc9TWF0aC5tYXgoZS53LE1hdGgubWluKHQudyx0aGlzLncpKSx0aGlzfWNsYW1wU2NhbGFyKGUsdCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heChlLE1hdGgubWluKHQsdGhpcy54KSksdGhpcy55PU1hdGgubWF4KGUsTWF0aC5taW4odCx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgoZSxNYXRoLm1pbih0LHRoaXMueikpLHRoaXMudz1NYXRoLm1heChlLE1hdGgubWluKHQsdGhpcy53KSksdGhpc31jbGFtcExlbmd0aChlLHQpe2NvbnN0IGk9dGhpcy5sZW5ndGgoKTtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoaXx8MSkubXVsdGlwbHlTY2FsYXIoTWF0aC5tYXgoZSxNYXRoLm1pbih0LGkpKSl9Zmxvb3IoKXtyZXR1cm4gdGhpcy54PU1hdGguZmxvb3IodGhpcy54KSx0aGlzLnk9TWF0aC5mbG9vcih0aGlzLnkpLHRoaXMuej1NYXRoLmZsb29yKHRoaXMueiksdGhpcy53PU1hdGguZmxvb3IodGhpcy53KSx0aGlzfWNlaWwoKXtyZXR1cm4gdGhpcy54PU1hdGguY2VpbCh0aGlzLngpLHRoaXMueT1NYXRoLmNlaWwodGhpcy55KSx0aGlzLno9TWF0aC5jZWlsKHRoaXMueiksdGhpcy53PU1hdGguY2VpbCh0aGlzLncpLHRoaXN9cm91bmQoKXtyZXR1cm4gdGhpcy54PU1hdGgucm91bmQodGhpcy54KSx0aGlzLnk9TWF0aC5yb3VuZCh0aGlzLnkpLHRoaXMuej1NYXRoLnJvdW5kKHRoaXMueiksdGhpcy53PU1hdGgucm91bmQodGhpcy53KSx0aGlzfXJvdW5kVG9aZXJvKCl7cmV0dXJuIHRoaXMueD1NYXRoLnRydW5jKHRoaXMueCksdGhpcy55PU1hdGgudHJ1bmModGhpcy55KSx0aGlzLno9TWF0aC50cnVuYyh0aGlzLnopLHRoaXMudz1NYXRoLnRydW5jKHRoaXMudyksdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy54PS10aGlzLngsdGhpcy55PS10aGlzLnksdGhpcy56PS10aGlzLnosdGhpcy53PS10aGlzLncsdGhpc31kb3QoZSl7cmV0dXJuIHRoaXMueCplLngrdGhpcy55KmUueSt0aGlzLnoqZS56K3RoaXMudyplLnd9bGVuZ3RoU3EoKXtyZXR1cm4gdGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMud31sZW5ndGgoKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56K3RoaXMudyp0aGlzLncpfW1hbmhhdHRhbkxlbmd0aCgpe3JldHVybiBNYXRoLmFicyh0aGlzLngpK01hdGguYWJzKHRoaXMueSkrTWF0aC5hYnModGhpcy56KStNYXRoLmFicyh0aGlzLncpfW5vcm1hbGl6ZSgpe3JldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpfHwxKX1zZXRMZW5ndGgoZSl7cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoZSl9bGVycChlLHQpe3JldHVybiB0aGlzLngrPShlLngtdGhpcy54KSp0LHRoaXMueSs9KGUueS10aGlzLnkpKnQsdGhpcy56Kz0oZS56LXRoaXMueikqdCx0aGlzLncrPShlLnctdGhpcy53KSp0LHRoaXN9bGVycFZlY3RvcnMoZSx0LGkpe3JldHVybiB0aGlzLng9ZS54Kyh0LngtZS54KSppLHRoaXMueT1lLnkrKHQueS1lLnkpKmksdGhpcy56PWUueisodC56LWUueikqaSx0aGlzLnc9ZS53Kyh0LnctZS53KSppLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLng9PT10aGlzLngmJmUueT09PXRoaXMueSYmZS56PT09dGhpcy56JiZlLnc9PT10aGlzLnd9ZnJvbUFycmF5KGUsdD0wKXtyZXR1cm4gdGhpcy54PWVbdF0sdGhpcy55PWVbdCsxXSx0aGlzLno9ZVt0KzJdLHRoaXMudz1lW3QrM10sdGhpc310b0FycmF5KGU9W10sdD0wKXtyZXR1cm4gZVt0XT10aGlzLngsZVt0KzFdPXRoaXMueSxlW3QrMl09dGhpcy56LGVbdCszXT10aGlzLncsZX1mcm9tQnVmZmVyQXR0cmlidXRlKGUsdCl7cmV0dXJuIHRoaXMueD1lLmdldFgodCksdGhpcy55PWUuZ2V0WSh0KSx0aGlzLno9ZS5nZXRaKHQpLHRoaXMudz1lLmdldFcodCksdGhpc31yYW5kb20oKXtyZXR1cm4gdGhpcy54PU1hdGgucmFuZG9tKCksdGhpcy55PU1hdGgucmFuZG9tKCksdGhpcy56PU1hdGgucmFuZG9tKCksdGhpcy53PU1hdGgucmFuZG9tKCksdGhpc30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLngseWllbGQgdGhpcy55LHlpZWxkIHRoaXMueix5aWVsZCB0aGlzLnd9fWNsYXNzIHZhIGV4dGVuZHMgTW57Y29uc3RydWN0b3IoZT0xLHQ9MSxpPXt9KXtzdXBlcigpLHRoaXMuaXNSZW5kZXJUYXJnZXQ9ITAsdGhpcy53aWR0aD1lLHRoaXMuaGVpZ2h0PXQsdGhpcy5kZXB0aD0xLHRoaXMuc2Npc3Nvcj1uZXcgcnQoMCwwLGUsdCksdGhpcy5zY2lzc29yVGVzdD0hMSx0aGlzLnZpZXdwb3J0PW5ldyBydCgwLDAsZSx0KTtjb25zdCByPXt3aWR0aDplLGhlaWdodDp0LGRlcHRoOjF9O2k9T2JqZWN0LmFzc2lnbih7Z2VuZXJhdGVNaXBtYXBzOiExLGludGVybmFsRm9ybWF0Om51bGwsbWluRmlsdGVyOjEwMDYsZGVwdGhCdWZmZXI6ITAsc3RlbmNpbEJ1ZmZlcjohMSxyZXNvbHZlRGVwdGhCdWZmZXI6ITAscmVzb2x2ZVN0ZW5jaWxCdWZmZXI6ITAsZGVwdGhUZXh0dXJlOm51bGwsc2FtcGxlczowLGNvdW50OjF9LGkpO2NvbnN0IHM9bmV3IHZ0KHIsaS5tYXBwaW5nLGkud3JhcFMsaS53cmFwVCxpLm1hZ0ZpbHRlcixpLm1pbkZpbHRlcixpLmZvcm1hdCxpLnR5cGUsaS5hbmlzb3Ryb3B5LGkuY29sb3JTcGFjZSk7cy5mbGlwWT0hMSxzLmdlbmVyYXRlTWlwbWFwcz1pLmdlbmVyYXRlTWlwbWFwcyxzLmludGVybmFsRm9ybWF0PWkuaW50ZXJuYWxGb3JtYXQsdGhpcy50ZXh0dXJlcz1bXTtjb25zdCBvPWkuY291bnQ7Zm9yKGxldCBhPTA7YTxvO2ErKyl0aGlzLnRleHR1cmVzW2FdPXMuY2xvbmUoKSx0aGlzLnRleHR1cmVzW2FdLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hMDt0aGlzLmRlcHRoQnVmZmVyPWkuZGVwdGhCdWZmZXIsdGhpcy5zdGVuY2lsQnVmZmVyPWkuc3RlbmNpbEJ1ZmZlcix0aGlzLnJlc29sdmVEZXB0aEJ1ZmZlcj1pLnJlc29sdmVEZXB0aEJ1ZmZlcix0aGlzLnJlc29sdmVTdGVuY2lsQnVmZmVyPWkucmVzb2x2ZVN0ZW5jaWxCdWZmZXIsdGhpcy5kZXB0aFRleHR1cmU9aS5kZXB0aFRleHR1cmUsdGhpcy5zYW1wbGVzPWkuc2FtcGxlc31nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzLnRleHR1cmVzWzBdfXNldCB0ZXh0dXJlKGUpe3RoaXMudGV4dHVyZXNbMF09ZX1zZXRTaXplKGUsdCxpPTEpe2lmKHRoaXMud2lkdGghPT1lfHx0aGlzLmhlaWdodCE9PXR8fHRoaXMuZGVwdGghPT1pKXt0aGlzLndpZHRoPWUsdGhpcy5oZWlnaHQ9dCx0aGlzLmRlcHRoPWk7Zm9yKGxldCByPTAscz10aGlzLnRleHR1cmVzLmxlbmd0aDtyPHM7cisrKXRoaXMudGV4dHVyZXNbcl0uaW1hZ2Uud2lkdGg9ZSx0aGlzLnRleHR1cmVzW3JdLmltYWdlLmhlaWdodD10LHRoaXMudGV4dHVyZXNbcl0uaW1hZ2UuZGVwdGg9aTt0aGlzLmRpc3Bvc2UoKX10aGlzLnZpZXdwb3J0LnNldCgwLDAsZSx0KSx0aGlzLnNjaXNzb3Iuc2V0KDAsMCxlLHQpfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX1jb3B5KGUpe3RoaXMud2lkdGg9ZS53aWR0aCx0aGlzLmhlaWdodD1lLmhlaWdodCx0aGlzLmRlcHRoPWUuZGVwdGgsdGhpcy5zY2lzc29yLmNvcHkoZS5zY2lzc29yKSx0aGlzLnNjaXNzb3JUZXN0PWUuc2Npc3NvclRlc3QsdGhpcy52aWV3cG9ydC5jb3B5KGUudmlld3BvcnQpLHRoaXMudGV4dHVyZXMubGVuZ3RoPTA7Zm9yKGxldCBpPTAscj1lLnRleHR1cmVzLmxlbmd0aDtpPHI7aSsrKXRoaXMudGV4dHVyZXNbaV09ZS50ZXh0dXJlc1tpXS5jbG9uZSgpLHRoaXMudGV4dHVyZXNbaV0uaXNSZW5kZXJUYXJnZXRUZXh0dXJlPSEwO2NvbnN0IHQ9T2JqZWN0LmFzc2lnbih7fSxlLnRleHR1cmUuaW1hZ2UpO3JldHVybiB0aGlzLnRleHR1cmUuc291cmNlPW5ldyBDcih0KSx0aGlzLmRlcHRoQnVmZmVyPWUuZGVwdGhCdWZmZXIsdGhpcy5zdGVuY2lsQnVmZmVyPWUuc3RlbmNpbEJ1ZmZlcix0aGlzLnJlc29sdmVEZXB0aEJ1ZmZlcj1lLnJlc29sdmVEZXB0aEJ1ZmZlcix0aGlzLnJlc29sdmVTdGVuY2lsQnVmZmVyPWUucmVzb2x2ZVN0ZW5jaWxCdWZmZXIsZS5kZXB0aFRleHR1cmUhPT1udWxsJiYodGhpcy5kZXB0aFRleHR1cmU9ZS5kZXB0aFRleHR1cmUuY2xvbmUoKSksdGhpcy5zYW1wbGVzPWUuc2FtcGxlcyx0aGlzfWRpc3Bvc2UoKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImRpc3Bvc2UifSl9fWNsYXNzIEp0IGV4dGVuZHMgdmF7Y29uc3RydWN0b3IoZT0xLHQ9MSxpPXt9KXtzdXBlcihlLHQsaSksdGhpcy5pc1dlYkdMUmVuZGVyVGFyZ2V0PSEwfX1jbGFzcyBQciBleHRlbmRzIHZ0e2NvbnN0cnVjdG9yKGU9bnVsbCx0PTEsaT0xLHI9MSl7c3VwZXIobnVsbCksdGhpcy5pc0RhdGFBcnJheVRleHR1cmU9ITAsdGhpcy5pbWFnZT17ZGF0YTplLHdpZHRoOnQsaGVpZ2h0OmksZGVwdGg6cn0sdGhpcy5tYWdGaWx0ZXI9MTAwMyx0aGlzLm1pbkZpbHRlcj0xMDAzLHRoaXMud3JhcFI9MTAwMSx0aGlzLmdlbmVyYXRlTWlwbWFwcz0hMSx0aGlzLmZsaXBZPSExLHRoaXMudW5wYWNrQWxpZ25tZW50PTEsdGhpcy5sYXllclVwZGF0ZXM9bmV3IFNldH1hZGRMYXllclVwZGF0ZShlKXt0aGlzLmxheWVyVXBkYXRlcy5hZGQoZSl9Y2xlYXJMYXllclVwZGF0ZXMoKXt0aGlzLmxheWVyVXBkYXRlcy5jbGVhcigpfX1jbGFzcyB4YSBleHRlbmRzIHZ0e2NvbnN0cnVjdG9yKGU9bnVsbCx0PTEsaT0xLHI9MSl7c3VwZXIobnVsbCksdGhpcy5pc0RhdGEzRFRleHR1cmU9ITAsdGhpcy5pbWFnZT17ZGF0YTplLHdpZHRoOnQsaGVpZ2h0OmksZGVwdGg6cn0sdGhpcy5tYWdGaWx0ZXI9MTAwMyx0aGlzLm1pbkZpbHRlcj0xMDAzLHRoaXMud3JhcFI9MTAwMSx0aGlzLmdlbmVyYXRlTWlwbWFwcz0hMSx0aGlzLmZsaXBZPSExLHRoaXMudW5wYWNrQWxpZ25tZW50PTF9fWNsYXNzIFhue2NvbnN0cnVjdG9yKGU9MCx0PTAsaT0wLHI9MSl7dGhpcy5pc1F1YXRlcm5pb249ITAsdGhpcy5feD1lLHRoaXMuX3k9dCx0aGlzLl96PWksdGhpcy5fdz1yfXN0YXRpYyBzbGVycEZsYXQoZSx0LGkscixzLG8sYSl7bGV0IGw9aVtyKzBdLGM9aVtyKzFdLHU9aVtyKzJdLGQ9aVtyKzNdO2NvbnN0IGY9c1tvKzBdLHA9c1tvKzFdLGc9c1tvKzJdLHg9c1tvKzNdO2lmKGE9PT0wKXtlW3QrMF09bCxlW3QrMV09YyxlW3QrMl09dSxlW3QrM109ZDtyZXR1cm59aWYoYT09PTEpe2VbdCswXT1mLGVbdCsxXT1wLGVbdCsyXT1nLGVbdCszXT14O3JldHVybn1pZihkIT09eHx8bCE9PWZ8fGMhPT1wfHx1IT09Zyl7bGV0IG09MS1hO2NvbnN0IGg9bCpmK2MqcCt1KmcrZCp4LFQ9aD49MD8xOi0xLHk9MS1oKmg7aWYoeT5OdW1iZXIuRVBTSUxPTil7Y29uc3QgQz1NYXRoLnNxcnQoeSksdz1NYXRoLmF0YW4yKEMsaCpUKTttPU1hdGguc2luKG0qdykvQyxhPU1hdGguc2luKGEqdykvQ31jb25zdCBfPWEqVDtpZihsPWwqbStmKl8sYz1jKm0rcCpfLHU9dSptK2cqXyxkPWQqbSt4Kl8sbT09PTEtYSl7Y29uc3QgQz0xL01hdGguc3FydChsKmwrYypjK3UqdStkKmQpO2wqPUMsYyo9Qyx1Kj1DLGQqPUN9fWVbdF09bCxlW3QrMV09YyxlW3QrMl09dSxlW3QrM109ZH1zdGF0aWMgbXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQoZSx0LGkscixzLG8pe2NvbnN0IGE9aVtyXSxsPWlbcisxXSxjPWlbcisyXSx1PWlbciszXSxkPXNbb10sZj1zW28rMV0scD1zW28rMl0sZz1zW28rM107cmV0dXJuIGVbdF09YSpnK3UqZCtsKnAtYypmLGVbdCsxXT1sKmcrdSpmK2MqZC1hKnAsZVt0KzJdPWMqZyt1KnArYSpmLWwqZCxlW3QrM109dSpnLWEqZC1sKmYtYypwLGV9Z2V0IHgoKXtyZXR1cm4gdGhpcy5feH1zZXQgeChlKXt0aGlzLl94PWUsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfWdldCB5KCl7cmV0dXJuIHRoaXMuX3l9c2V0IHkoZSl7dGhpcy5feT1lLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKX1nZXQgeigpe3JldHVybiB0aGlzLl96fXNldCB6KGUpe3RoaXMuX3o9ZSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9Z2V0IHcoKXtyZXR1cm4gdGhpcy5fd31zZXQgdyhlKXt0aGlzLl93PWUsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfXNldChlLHQsaSxyKXtyZXR1cm4gdGhpcy5feD1lLHRoaXMuX3k9dCx0aGlzLl96PWksdGhpcy5fdz1yLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuX3gsdGhpcy5feSx0aGlzLl96LHRoaXMuX3cpfWNvcHkoZSl7cmV0dXJuIHRoaXMuX3g9ZS54LHRoaXMuX3k9ZS55LHRoaXMuX3o9ZS56LHRoaXMuX3c9ZS53LHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfXNldEZyb21FdWxlcihlLHQ9ITApe2NvbnN0IGk9ZS5feCxyPWUuX3kscz1lLl96LG89ZS5fb3JkZXIsYT1NYXRoLmNvcyxsPU1hdGguc2luLGM9YShpLzIpLHU9YShyLzIpLGQ9YShzLzIpLGY9bChpLzIpLHA9bChyLzIpLGc9bChzLzIpO3N3aXRjaChvKXtjYXNlIlhZWiI6dGhpcy5feD1mKnUqZCtjKnAqZyx0aGlzLl95PWMqcCpkLWYqdSpnLHRoaXMuX3o9Yyp1KmcrZipwKmQsdGhpcy5fdz1jKnUqZC1mKnAqZzticmVhaztjYXNlIllYWiI6dGhpcy5feD1mKnUqZCtjKnAqZyx0aGlzLl95PWMqcCpkLWYqdSpnLHRoaXMuX3o9Yyp1KmctZipwKmQsdGhpcy5fdz1jKnUqZCtmKnAqZzticmVhaztjYXNlIlpYWSI6dGhpcy5feD1mKnUqZC1jKnAqZyx0aGlzLl95PWMqcCpkK2YqdSpnLHRoaXMuX3o9Yyp1KmcrZipwKmQsdGhpcy5fdz1jKnUqZC1mKnAqZzticmVhaztjYXNlIlpZWCI6dGhpcy5feD1mKnUqZC1jKnAqZyx0aGlzLl95PWMqcCpkK2YqdSpnLHRoaXMuX3o9Yyp1KmctZipwKmQsdGhpcy5fdz1jKnUqZCtmKnAqZzticmVhaztjYXNlIllaWCI6dGhpcy5feD1mKnUqZCtjKnAqZyx0aGlzLl95PWMqcCpkK2YqdSpnLHRoaXMuX3o9Yyp1KmctZipwKmQsdGhpcy5fdz1jKnUqZC1mKnAqZzticmVhaztjYXNlIlhaWSI6dGhpcy5feD1mKnUqZC1jKnAqZyx0aGlzLl95PWMqcCpkLWYqdSpnLHRoaXMuX3o9Yyp1KmcrZipwKmQsdGhpcy5fdz1jKnUqZCtmKnAqZzticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybigiVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICIrbyl9cmV0dXJuIHQ9PT0hMCYmdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbUF4aXNBbmdsZShlLHQpe2NvbnN0IGk9dC8yLHI9TWF0aC5zaW4oaSk7cmV0dXJuIHRoaXMuX3g9ZS54KnIsdGhpcy5feT1lLnkqcix0aGlzLl96PWUueipyLHRoaXMuX3c9TWF0aC5jb3MoaSksdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVJvdGF0aW9uTWF0cml4KGUpe2NvbnN0IHQ9ZS5lbGVtZW50cyxpPXRbMF0scj10WzRdLHM9dFs4XSxvPXRbMV0sYT10WzVdLGw9dFs5XSxjPXRbMl0sdT10WzZdLGQ9dFsxMF0sZj1pK2ErZDtpZihmPjApe2NvbnN0IHA9LjUvTWF0aC5zcXJ0KGYrMSk7dGhpcy5fdz0uMjUvcCx0aGlzLl94PSh1LWwpKnAsdGhpcy5feT0ocy1jKSpwLHRoaXMuX3o9KG8tcikqcH1lbHNlIGlmKGk+YSYmaT5kKXtjb25zdCBwPTIqTWF0aC5zcXJ0KDEraS1hLWQpO3RoaXMuX3c9KHUtbCkvcCx0aGlzLl94PS4yNSpwLHRoaXMuX3k9KHIrbykvcCx0aGlzLl96PShzK2MpL3B9ZWxzZSBpZihhPmQpe2NvbnN0IHA9MipNYXRoLnNxcnQoMSthLWktZCk7dGhpcy5fdz0ocy1jKS9wLHRoaXMuX3g9KHIrbykvcCx0aGlzLl95PS4yNSpwLHRoaXMuX3o9KGwrdSkvcH1lbHNle2NvbnN0IHA9MipNYXRoLnNxcnQoMStkLWktYSk7dGhpcy5fdz0oby1yKS9wLHRoaXMuX3g9KHMrYykvcCx0aGlzLl95PShsK3UpL3AsdGhpcy5fej0uMjUqcH1yZXR1cm4gdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVVuaXRWZWN0b3JzKGUsdCl7bGV0IGk9ZS5kb3QodCkrMTtyZXR1cm4gaTxOdW1iZXIuRVBTSUxPTj8oaT0wLE1hdGguYWJzKGUueCk+TWF0aC5hYnMoZS56KT8odGhpcy5feD0tZS55LHRoaXMuX3k9ZS54LHRoaXMuX3o9MCx0aGlzLl93PWkpOih0aGlzLl94PTAsdGhpcy5feT0tZS56LHRoaXMuX3o9ZS55LHRoaXMuX3c9aSkpOih0aGlzLl94PWUueSp0LnotZS56KnQueSx0aGlzLl95PWUueip0LngtZS54KnQueix0aGlzLl96PWUueCp0LnktZS55KnQueCx0aGlzLl93PWkpLHRoaXMubm9ybWFsaXplKCl9YW5nbGVUbyhlKXtyZXR1cm4gMipNYXRoLmFjb3MoTWF0aC5hYnMoZ3QodGhpcy5kb3QoZSksLTEsMSkpKX1yb3RhdGVUb3dhcmRzKGUsdCl7Y29uc3QgaT10aGlzLmFuZ2xlVG8oZSk7aWYoaT09PTApcmV0dXJuIHRoaXM7Y29uc3Qgcj1NYXRoLm1pbigxLHQvaSk7cmV0dXJuIHRoaXMuc2xlcnAoZSxyKSx0aGlzfWlkZW50aXR5KCl7cmV0dXJuIHRoaXMuc2V0KDAsMCwwLDEpfWludmVydCgpe3JldHVybiB0aGlzLmNvbmp1Z2F0ZSgpfWNvbmp1Z2F0ZSgpe3JldHVybiB0aGlzLl94Kj0tMSx0aGlzLl95Kj0tMSx0aGlzLl96Kj0tMSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31kb3QoZSl7cmV0dXJuIHRoaXMuX3gqZS5feCt0aGlzLl95KmUuX3krdGhpcy5feiplLl96K3RoaXMuX3cqZS5fd31sZW5ndGhTcSgpe3JldHVybiB0aGlzLl94KnRoaXMuX3grdGhpcy5feSp0aGlzLl95K3RoaXMuX3oqdGhpcy5feit0aGlzLl93KnRoaXMuX3d9bGVuZ3RoKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLl94KnRoaXMuX3grdGhpcy5feSp0aGlzLl95K3RoaXMuX3oqdGhpcy5feit0aGlzLl93KnRoaXMuX3cpfW5vcm1hbGl6ZSgpe2xldCBlPXRoaXMubGVuZ3RoKCk7cmV0dXJuIGU9PT0wPyh0aGlzLl94PTAsdGhpcy5feT0wLHRoaXMuX3o9MCx0aGlzLl93PTEpOihlPTEvZSx0aGlzLl94PXRoaXMuX3gqZSx0aGlzLl95PXRoaXMuX3kqZSx0aGlzLl96PXRoaXMuX3oqZSx0aGlzLl93PXRoaXMuX3cqZSksdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9bXVsdGlwbHkoZSl7cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyh0aGlzLGUpfXByZW11bHRpcGx5KGUpe3JldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoZSx0aGlzKX1tdWx0aXBseVF1YXRlcm5pb25zKGUsdCl7Y29uc3QgaT1lLl94LHI9ZS5feSxzPWUuX3osbz1lLl93LGE9dC5feCxsPXQuX3ksYz10Ll96LHU9dC5fdztyZXR1cm4gdGhpcy5feD1pKnUrbyphK3IqYy1zKmwsdGhpcy5feT1yKnUrbypsK3MqYS1pKmMsdGhpcy5fej1zKnUrbypjK2kqbC1yKmEsdGhpcy5fdz1vKnUtaSphLXIqbC1zKmMsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2xlcnAoZSx0KXtpZih0PT09MClyZXR1cm4gdGhpcztpZih0PT09MSlyZXR1cm4gdGhpcy5jb3B5KGUpO2NvbnN0IGk9dGhpcy5feCxyPXRoaXMuX3kscz10aGlzLl96LG89dGhpcy5fdztsZXQgYT1vKmUuX3craSplLl94K3IqZS5feStzKmUuX3o7aWYoYTwwPyh0aGlzLl93PS1lLl93LHRoaXMuX3g9LWUuX3gsdGhpcy5feT0tZS5feSx0aGlzLl96PS1lLl96LGE9LWEpOnRoaXMuY29weShlKSxhPj0xKXJldHVybiB0aGlzLl93PW8sdGhpcy5feD1pLHRoaXMuX3k9cix0aGlzLl96PXMsdGhpcztjb25zdCBsPTEtYSphO2lmKGw8PU51bWJlci5FUFNJTE9OKXtjb25zdCBwPTEtdDtyZXR1cm4gdGhpcy5fdz1wKm8rdCp0aGlzLl93LHRoaXMuX3g9cCppK3QqdGhpcy5feCx0aGlzLl95PXAqcit0KnRoaXMuX3ksdGhpcy5fej1wKnMrdCp0aGlzLl96LHRoaXMubm9ybWFsaXplKCksdGhpc31jb25zdCBjPU1hdGguc3FydChsKSx1PU1hdGguYXRhbjIoYyxhKSxkPU1hdGguc2luKCgxLXQpKnUpL2MsZj1NYXRoLnNpbih0KnUpL2M7cmV0dXJuIHRoaXMuX3c9bypkK3RoaXMuX3cqZix0aGlzLl94PWkqZCt0aGlzLl94KmYsdGhpcy5feT1yKmQrdGhpcy5feSpmLHRoaXMuX3o9cypkK3RoaXMuX3oqZix0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31zbGVycFF1YXRlcm5pb25zKGUsdCxpKXtyZXR1cm4gdGhpcy5jb3B5KGUpLnNsZXJwKHQsaSl9cmFuZG9tKCl7Y29uc3QgZT0yKk1hdGguUEkqTWF0aC5yYW5kb20oKSx0PTIqTWF0aC5QSSpNYXRoLnJhbmRvbSgpLGk9TWF0aC5yYW5kb20oKSxyPU1hdGguc3FydCgxLWkpLHM9TWF0aC5zcXJ0KGkpO3JldHVybiB0aGlzLnNldChyKk1hdGguc2luKGUpLHIqTWF0aC5jb3MoZSkscypNYXRoLnNpbih0KSxzKk1hdGguY29zKHQpKX1lcXVhbHMoZSl7cmV0dXJuIGUuX3g9PT10aGlzLl94JiZlLl95PT09dGhpcy5feSYmZS5fej09PXRoaXMuX3omJmUuX3c9PT10aGlzLl93fWZyb21BcnJheShlLHQ9MCl7cmV0dXJuIHRoaXMuX3g9ZVt0XSx0aGlzLl95PWVbdCsxXSx0aGlzLl96PWVbdCsyXSx0aGlzLl93PWVbdCszXSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc310b0FycmF5KGU9W10sdD0wKXtyZXR1cm4gZVt0XT10aGlzLl94LGVbdCsxXT10aGlzLl95LGVbdCsyXT10aGlzLl96LGVbdCszXT10aGlzLl93LGV9ZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHQpe3JldHVybiB0aGlzLl94PWUuZ2V0WCh0KSx0aGlzLl95PWUuZ2V0WSh0KSx0aGlzLl96PWUuZ2V0Wih0KSx0aGlzLl93PWUuZ2V0Vyh0KSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc310b0pTT04oKXtyZXR1cm4gdGhpcy50b0FycmF5KCl9X29uQ2hhbmdlKGUpe3JldHVybiB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrPWUsdGhpc31fb25DaGFuZ2VDYWxsYmFjaygpe30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLl94LHlpZWxkIHRoaXMuX3kseWllbGQgdGhpcy5feix5aWVsZCB0aGlzLl93fX1jbGFzcyBPe2NvbnN0cnVjdG9yKGU9MCx0PTAsaT0wKXtPLnByb3RvdHlwZS5pc1ZlY3RvcjM9ITAsdGhpcy54PWUsdGhpcy55PXQsdGhpcy56PWl9c2V0KGUsdCxpKXtyZXR1cm4gaT09PXZvaWQgMCYmKGk9dGhpcy56KSx0aGlzLng9ZSx0aGlzLnk9dCx0aGlzLno9aSx0aGlzfXNldFNjYWxhcihlKXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PWUsdGhpcy56PWUsdGhpc31zZXRYKGUpe3JldHVybiB0aGlzLng9ZSx0aGlzfXNldFkoZSl7cmV0dXJuIHRoaXMueT1lLHRoaXN9c2V0WihlKXtyZXR1cm4gdGhpcy56PWUsdGhpc31zZXRDb21wb25lbnQoZSx0KXtzd2l0Y2goZSl7Y2FzZSAwOnRoaXMueD10O2JyZWFrO2Nhc2UgMTp0aGlzLnk9dDticmVhaztjYXNlIDI6dGhpcy56PXQ7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoImluZGV4IGlzIG91dCBvZiByYW5nZTogIitlKX1yZXR1cm4gdGhpc31nZXRDb21wb25lbnQoZSl7c3dpdGNoKGUpe2Nhc2UgMDpyZXR1cm4gdGhpcy54O2Nhc2UgMTpyZXR1cm4gdGhpcy55O2Nhc2UgMjpyZXR1cm4gdGhpcy56O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIrZSl9fWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCx0aGlzLnksdGhpcy56KX1jb3B5KGUpe3JldHVybiB0aGlzLng9ZS54LHRoaXMueT1lLnksdGhpcy56PWUueix0aGlzfWFkZChlKXtyZXR1cm4gdGhpcy54Kz1lLngsdGhpcy55Kz1lLnksdGhpcy56Kz1lLnosdGhpc31hZGRTY2FsYXIoZSl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPWUsdGhpcy56Kz1lLHRoaXN9YWRkVmVjdG9ycyhlLHQpe3JldHVybiB0aGlzLng9ZS54K3QueCx0aGlzLnk9ZS55K3QueSx0aGlzLno9ZS56K3Queix0aGlzfWFkZFNjYWxlZFZlY3RvcihlLHQpe3JldHVybiB0aGlzLngrPWUueCp0LHRoaXMueSs9ZS55KnQsdGhpcy56Kz1lLnoqdCx0aGlzfXN1YihlKXtyZXR1cm4gdGhpcy54LT1lLngsdGhpcy55LT1lLnksdGhpcy56LT1lLnosdGhpc31zdWJTY2FsYXIoZSl7cmV0dXJuIHRoaXMueC09ZSx0aGlzLnktPWUsdGhpcy56LT1lLHRoaXN9c3ViVmVjdG9ycyhlLHQpe3JldHVybiB0aGlzLng9ZS54LXQueCx0aGlzLnk9ZS55LXQueSx0aGlzLno9ZS56LXQueix0aGlzfW11bHRpcGx5KGUpe3JldHVybiB0aGlzLngqPWUueCx0aGlzLnkqPWUueSx0aGlzLnoqPWUueix0aGlzfW11bHRpcGx5U2NhbGFyKGUpe3JldHVybiB0aGlzLngqPWUsdGhpcy55Kj1lLHRoaXMueio9ZSx0aGlzfW11bHRpcGx5VmVjdG9ycyhlLHQpe3JldHVybiB0aGlzLng9ZS54KnQueCx0aGlzLnk9ZS55KnQueSx0aGlzLno9ZS56KnQueix0aGlzfWFwcGx5RXVsZXIoZSl7cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKERyLnNldEZyb21FdWxlcihlKSl9YXBwbHlBeGlzQW5nbGUoZSx0KXtyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oRHIuc2V0RnJvbUF4aXNBbmdsZShlLHQpKX1hcHBseU1hdHJpeDMoZSl7Y29uc3QgdD10aGlzLngsaT10aGlzLnkscj10aGlzLnoscz1lLmVsZW1lbnRzO3JldHVybiB0aGlzLng9c1swXSp0K3NbM10qaStzWzZdKnIsdGhpcy55PXNbMV0qdCtzWzRdKmkrc1s3XSpyLHRoaXMuej1zWzJdKnQrc1s1XSppK3NbOF0qcix0aGlzfWFwcGx5Tm9ybWFsTWF0cml4KGUpe3JldHVybiB0aGlzLmFwcGx5TWF0cml4MyhlKS5ub3JtYWxpemUoKX1hcHBseU1hdHJpeDQoZSl7Y29uc3QgdD10aGlzLngsaT10aGlzLnkscj10aGlzLnoscz1lLmVsZW1lbnRzLG89MS8oc1szXSp0K3NbN10qaStzWzExXSpyK3NbMTVdKTtyZXR1cm4gdGhpcy54PShzWzBdKnQrc1s0XSppK3NbOF0qcitzWzEyXSkqbyx0aGlzLnk9KHNbMV0qdCtzWzVdKmkrc1s5XSpyK3NbMTNdKSpvLHRoaXMuej0oc1syXSp0K3NbNl0qaStzWzEwXSpyK3NbMTRdKSpvLHRoaXN9YXBwbHlRdWF0ZXJuaW9uKGUpe2NvbnN0IHQ9dGhpcy54LGk9dGhpcy55LHI9dGhpcy56LHM9ZS54LG89ZS55LGE9ZS56LGw9ZS53LGM9MioobypyLWEqaSksdT0yKihhKnQtcypyKSxkPTIqKHMqaS1vKnQpO3JldHVybiB0aGlzLng9dCtsKmMrbypkLWEqdSx0aGlzLnk9aStsKnUrYSpjLXMqZCx0aGlzLno9citsKmQrcyp1LW8qYyx0aGlzfXByb2plY3QoZSl7cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KGUubWF0cml4V29ybGRJbnZlcnNlKS5hcHBseU1hdHJpeDQoZS5wcm9qZWN0aW9uTWF0cml4KX11bnByb2plY3QoZSl7cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KGUucHJvamVjdGlvbk1hdHJpeEludmVyc2UpLmFwcGx5TWF0cml4NChlLm1hdHJpeFdvcmxkKX10cmFuc2Zvcm1EaXJlY3Rpb24oZSl7Y29uc3QgdD10aGlzLngsaT10aGlzLnkscj10aGlzLnoscz1lLmVsZW1lbnRzO3JldHVybiB0aGlzLng9c1swXSp0K3NbNF0qaStzWzhdKnIsdGhpcy55PXNbMV0qdCtzWzVdKmkrc1s5XSpyLHRoaXMuej1zWzJdKnQrc1s2XSppK3NbMTBdKnIsdGhpcy5ub3JtYWxpemUoKX1kaXZpZGUoZSl7cmV0dXJuIHRoaXMueC89ZS54LHRoaXMueS89ZS55LHRoaXMuei89ZS56LHRoaXN9ZGl2aWRlU2NhbGFyKGUpe3JldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEvZSl9bWluKGUpe3JldHVybiB0aGlzLng9TWF0aC5taW4odGhpcy54LGUueCksdGhpcy55PU1hdGgubWluKHRoaXMueSxlLnkpLHRoaXMuej1NYXRoLm1pbih0aGlzLnosZS56KSx0aGlzfW1heChlKXtyZXR1cm4gdGhpcy54PU1hdGgubWF4KHRoaXMueCxlLngpLHRoaXMueT1NYXRoLm1heCh0aGlzLnksZS55KSx0aGlzLno9TWF0aC5tYXgodGhpcy56LGUueiksdGhpc31jbGFtcChlLHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgoZS54LE1hdGgubWluKHQueCx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgoZS55LE1hdGgubWluKHQueSx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgoZS56LE1hdGgubWluKHQueix0aGlzLnopKSx0aGlzfWNsYW1wU2NhbGFyKGUsdCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heChlLE1hdGgubWluKHQsdGhpcy54KSksdGhpcy55PU1hdGgubWF4KGUsTWF0aC5taW4odCx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgoZSxNYXRoLm1pbih0LHRoaXMueikpLHRoaXN9Y2xhbXBMZW5ndGgoZSx0KXtjb25zdCBpPXRoaXMubGVuZ3RoKCk7cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKGl8fDEpLm11bHRpcGx5U2NhbGFyKE1hdGgubWF4KGUsTWF0aC5taW4odCxpKSkpfWZsb29yKCl7cmV0dXJuIHRoaXMueD1NYXRoLmZsb29yKHRoaXMueCksdGhpcy55PU1hdGguZmxvb3IodGhpcy55KSx0aGlzLno9TWF0aC5mbG9vcih0aGlzLnopLHRoaXN9Y2VpbCgpe3JldHVybiB0aGlzLng9TWF0aC5jZWlsKHRoaXMueCksdGhpcy55PU1hdGguY2VpbCh0aGlzLnkpLHRoaXMuej1NYXRoLmNlaWwodGhpcy56KSx0aGlzfXJvdW5kKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJvdW5kKHRoaXMueCksdGhpcy55PU1hdGgucm91bmQodGhpcy55KSx0aGlzLno9TWF0aC5yb3VuZCh0aGlzLnopLHRoaXN9cm91bmRUb1plcm8oKXtyZXR1cm4gdGhpcy54PU1hdGgudHJ1bmModGhpcy54KSx0aGlzLnk9TWF0aC50cnVuYyh0aGlzLnkpLHRoaXMuej1NYXRoLnRydW5jKHRoaXMueiksdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy54PS10aGlzLngsdGhpcy55PS10aGlzLnksdGhpcy56PS10aGlzLnosdGhpc31kb3QoZSl7cmV0dXJuIHRoaXMueCplLngrdGhpcy55KmUueSt0aGlzLnoqZS56fWxlbmd0aFNxKCl7cmV0dXJuIHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56fWxlbmd0aCgpe3JldHVybiBNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnopfW1hbmhhdHRhbkxlbmd0aCgpe3JldHVybiBNYXRoLmFicyh0aGlzLngpK01hdGguYWJzKHRoaXMueSkrTWF0aC5hYnModGhpcy56KX1ub3JtYWxpemUoKXtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKXx8MSl9c2V0TGVuZ3RoKGUpe3JldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGUpfWxlcnAoZSx0KXtyZXR1cm4gdGhpcy54Kz0oZS54LXRoaXMueCkqdCx0aGlzLnkrPShlLnktdGhpcy55KSp0LHRoaXMueis9KGUuei10aGlzLnopKnQsdGhpc31sZXJwVmVjdG9ycyhlLHQsaSl7cmV0dXJuIHRoaXMueD1lLngrKHQueC1lLngpKmksdGhpcy55PWUueSsodC55LWUueSkqaSx0aGlzLno9ZS56Kyh0LnotZS56KSppLHRoaXN9Y3Jvc3MoZSl7cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKHRoaXMsZSl9Y3Jvc3NWZWN0b3JzKGUsdCl7Y29uc3QgaT1lLngscj1lLnkscz1lLnosbz10LngsYT10LnksbD10Lno7cmV0dXJuIHRoaXMueD1yKmwtcyphLHRoaXMueT1zKm8taSpsLHRoaXMuej1pKmEtcipvLHRoaXN9cHJvamVjdE9uVmVjdG9yKGUpe2NvbnN0IHQ9ZS5sZW5ndGhTcSgpO2lmKHQ9PT0wKXJldHVybiB0aGlzLnNldCgwLDAsMCk7Y29uc3QgaT1lLmRvdCh0aGlzKS90O3JldHVybiB0aGlzLmNvcHkoZSkubXVsdGlwbHlTY2FsYXIoaSl9cHJvamVjdE9uUGxhbmUoZSl7cmV0dXJuIEdpLmNvcHkodGhpcykucHJvamVjdE9uVmVjdG9yKGUpLHRoaXMuc3ViKEdpKX1yZWZsZWN0KGUpe3JldHVybiB0aGlzLnN1YihHaS5jb3B5KGUpLm11bHRpcGx5U2NhbGFyKDIqdGhpcy5kb3QoZSkpKX1hbmdsZVRvKGUpe2NvbnN0IHQ9TWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3EoKSplLmxlbmd0aFNxKCkpO2lmKHQ9PT0wKXJldHVybiBNYXRoLlBJLzI7Y29uc3QgaT10aGlzLmRvdChlKS90O3JldHVybiBNYXRoLmFjb3MoZ3QoaSwtMSwxKSl9ZGlzdGFuY2VUbyhlKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoZSkpfWRpc3RhbmNlVG9TcXVhcmVkKGUpe2NvbnN0IHQ9dGhpcy54LWUueCxpPXRoaXMueS1lLnkscj10aGlzLnotZS56O3JldHVybiB0KnQraSppK3Iqcn1tYW5oYXR0YW5EaXN0YW5jZVRvKGUpe3JldHVybiBNYXRoLmFicyh0aGlzLngtZS54KStNYXRoLmFicyh0aGlzLnktZS55KStNYXRoLmFicyh0aGlzLnotZS56KX1zZXRGcm9tU3BoZXJpY2FsKGUpe3JldHVybiB0aGlzLnNldEZyb21TcGhlcmljYWxDb29yZHMoZS5yYWRpdXMsZS5waGksZS50aGV0YSl9c2V0RnJvbVNwaGVyaWNhbENvb3JkcyhlLHQsaSl7Y29uc3Qgcj1NYXRoLnNpbih0KSplO3JldHVybiB0aGlzLng9cipNYXRoLnNpbihpKSx0aGlzLnk9TWF0aC5jb3ModCkqZSx0aGlzLno9cipNYXRoLmNvcyhpKSx0aGlzfXNldEZyb21DeWxpbmRyaWNhbChlKXtyZXR1cm4gdGhpcy5zZXRGcm9tQ3lsaW5kcmljYWxDb29yZHMoZS5yYWRpdXMsZS50aGV0YSxlLnkpfXNldEZyb21DeWxpbmRyaWNhbENvb3JkcyhlLHQsaSl7cmV0dXJuIHRoaXMueD1lKk1hdGguc2luKHQpLHRoaXMueT1pLHRoaXMuej1lKk1hdGguY29zKHQpLHRoaXN9c2V0RnJvbU1hdHJpeFBvc2l0aW9uKGUpe2NvbnN0IHQ9ZS5lbGVtZW50cztyZXR1cm4gdGhpcy54PXRbMTJdLHRoaXMueT10WzEzXSx0aGlzLno9dFsxNF0sdGhpc31zZXRGcm9tTWF0cml4U2NhbGUoZSl7Y29uc3QgdD10aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oZSwwKS5sZW5ndGgoKSxpPXRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbihlLDEpLmxlbmd0aCgpLHI9dGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKGUsMikubGVuZ3RoKCk7cmV0dXJuIHRoaXMueD10LHRoaXMueT1pLHRoaXMuej1yLHRoaXN9c2V0RnJvbU1hdHJpeENvbHVtbihlLHQpe3JldHVybiB0aGlzLmZyb21BcnJheShlLmVsZW1lbnRzLHQqNCl9c2V0RnJvbU1hdHJpeDNDb2x1bW4oZSx0KXtyZXR1cm4gdGhpcy5mcm9tQXJyYXkoZS5lbGVtZW50cyx0KjMpfXNldEZyb21FdWxlcihlKXtyZXR1cm4gdGhpcy54PWUuX3gsdGhpcy55PWUuX3ksdGhpcy56PWUuX3osdGhpc31zZXRGcm9tQ29sb3IoZSl7cmV0dXJuIHRoaXMueD1lLnIsdGhpcy55PWUuZyx0aGlzLno9ZS5iLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLng9PT10aGlzLngmJmUueT09PXRoaXMueSYmZS56PT09dGhpcy56fWZyb21BcnJheShlLHQ9MCl7cmV0dXJuIHRoaXMueD1lW3RdLHRoaXMueT1lW3QrMV0sdGhpcy56PWVbdCsyXSx0aGlzfXRvQXJyYXkoZT1bXSx0PTApe3JldHVybiBlW3RdPXRoaXMueCxlW3QrMV09dGhpcy55LGVbdCsyXT10aGlzLnosZX1mcm9tQnVmZmVyQXR0cmlidXRlKGUsdCl7cmV0dXJuIHRoaXMueD1lLmdldFgodCksdGhpcy55PWUuZ2V0WSh0KSx0aGlzLno9ZS5nZXRaKHQpLHRoaXN9cmFuZG9tKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJhbmRvbSgpLHRoaXMueT1NYXRoLnJhbmRvbSgpLHRoaXMuej1NYXRoLnJhbmRvbSgpLHRoaXN9cmFuZG9tRGlyZWN0aW9uKCl7Y29uc3QgZT1NYXRoLnJhbmRvbSgpKk1hdGguUEkqMix0PU1hdGgucmFuZG9tKCkqMi0xLGk9TWF0aC5zcXJ0KDEtdCp0KTtyZXR1cm4gdGhpcy54PWkqTWF0aC5jb3MoZSksdGhpcy55PXQsdGhpcy56PWkqTWF0aC5zaW4oZSksdGhpc30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLngseWllbGQgdGhpcy55LHlpZWxkIHRoaXMuen19Y29uc3QgR2k9bmV3IE8sRHI9bmV3IFhuO2NsYXNzIHFue2NvbnN0cnVjdG9yKGU9bmV3IE8oMS8wLDEvMCwxLzApLHQ9bmV3IE8oLTEvMCwtMS8wLC0xLzApKXt0aGlzLmlzQm94Mz0hMCx0aGlzLm1pbj1lLHRoaXMubWF4PXR9c2V0KGUsdCl7cmV0dXJuIHRoaXMubWluLmNvcHkoZSksdGhpcy5tYXguY29weSh0KSx0aGlzfXNldEZyb21BcnJheShlKXt0aGlzLm1ha2VFbXB0eSgpO2ZvcihsZXQgdD0wLGk9ZS5sZW5ndGg7dDxpO3QrPTMpdGhpcy5leHBhbmRCeVBvaW50KEx0LmZyb21BcnJheShlLHQpKTtyZXR1cm4gdGhpc31zZXRGcm9tQnVmZmVyQXR0cmlidXRlKGUpe3RoaXMubWFrZUVtcHR5KCk7Zm9yKGxldCB0PTAsaT1lLmNvdW50O3Q8aTt0KyspdGhpcy5leHBhbmRCeVBvaW50KEx0LmZyb21CdWZmZXJBdHRyaWJ1dGUoZSx0KSk7cmV0dXJuIHRoaXN9c2V0RnJvbVBvaW50cyhlKXt0aGlzLm1ha2VFbXB0eSgpO2ZvcihsZXQgdD0wLGk9ZS5sZW5ndGg7dDxpO3QrKyl0aGlzLmV4cGFuZEJ5UG9pbnQoZVt0XSk7cmV0dXJuIHRoaXN9c2V0RnJvbUNlbnRlckFuZFNpemUoZSx0KXtjb25zdCBpPUx0LmNvcHkodCkubXVsdGlwbHlTY2FsYXIoLjUpO3JldHVybiB0aGlzLm1pbi5jb3B5KGUpLnN1YihpKSx0aGlzLm1heC5jb3B5KGUpLmFkZChpKSx0aGlzfXNldEZyb21PYmplY3QoZSx0PSExKXtyZXR1cm4gdGhpcy5tYWtlRW1wdHkoKSx0aGlzLmV4cGFuZEJ5T2JqZWN0KGUsdCl9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfWNvcHkoZSl7cmV0dXJuIHRoaXMubWluLmNvcHkoZS5taW4pLHRoaXMubWF4LmNvcHkoZS5tYXgpLHRoaXN9bWFrZUVtcHR5KCl7cmV0dXJuIHRoaXMubWluLng9dGhpcy5taW4ueT10aGlzLm1pbi56PTEvMCx0aGlzLm1heC54PXRoaXMubWF4Lnk9dGhpcy5tYXguej0tMS8wLHRoaXN9aXNFbXB0eSgpe3JldHVybiB0aGlzLm1heC54PHRoaXMubWluLnh8fHRoaXMubWF4Lnk8dGhpcy5taW4ueXx8dGhpcy5tYXguejx0aGlzLm1pbi56fWdldENlbnRlcihlKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/ZS5zZXQoMCwwLDApOmUuYWRkVmVjdG9ycyh0aGlzLm1pbix0aGlzLm1heCkubXVsdGlwbHlTY2FsYXIoLjUpfWdldFNpemUoZSl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP2Uuc2V0KDAsMCwwKTplLnN1YlZlY3RvcnModGhpcy5tYXgsdGhpcy5taW4pfWV4cGFuZEJ5UG9pbnQoZSl7cmV0dXJuIHRoaXMubWluLm1pbihlKSx0aGlzLm1heC5tYXgoZSksdGhpc31leHBhbmRCeVZlY3RvcihlKXtyZXR1cm4gdGhpcy5taW4uc3ViKGUpLHRoaXMubWF4LmFkZChlKSx0aGlzfWV4cGFuZEJ5U2NhbGFyKGUpe3JldHVybiB0aGlzLm1pbi5hZGRTY2FsYXIoLWUpLHRoaXMubWF4LmFkZFNjYWxhcihlKSx0aGlzfWV4cGFuZEJ5T2JqZWN0KGUsdD0hMSl7ZS51cGRhdGVXb3JsZE1hdHJpeCghMSwhMSk7Y29uc3QgaT1lLmdlb21ldHJ5O2lmKGkhPT12b2lkIDApe2NvbnN0IHM9aS5nZXRBdHRyaWJ1dGUoInBvc2l0aW9uIik7aWYodD09PSEwJiZzIT09dm9pZCAwJiZlLmlzSW5zdGFuY2VkTWVzaCE9PSEwKWZvcihsZXQgbz0wLGE9cy5jb3VudDtvPGE7bysrKWUuaXNNZXNoPT09ITA/ZS5nZXRWZXJ0ZXhQb3NpdGlvbihvLEx0KTpMdC5mcm9tQnVmZmVyQXR0cmlidXRlKHMsbyksTHQuYXBwbHlNYXRyaXg0KGUubWF0cml4V29ybGQpLHRoaXMuZXhwYW5kQnlQb2ludChMdCk7ZWxzZSBlLmJvdW5kaW5nQm94IT09dm9pZCAwPyhlLmJvdW5kaW5nQm94PT09bnVsbCYmZS5jb21wdXRlQm91bmRpbmdCb3goKSxzaS5jb3B5KGUuYm91bmRpbmdCb3gpKTooaS5ib3VuZGluZ0JveD09PW51bGwmJmkuY29tcHV0ZUJvdW5kaW5nQm94KCksc2kuY29weShpLmJvdW5kaW5nQm94KSksc2kuYXBwbHlNYXRyaXg0KGUubWF0cml4V29ybGQpLHRoaXMudW5pb24oc2kpfWNvbnN0IHI9ZS5jaGlsZHJlbjtmb3IobGV0IHM9MCxvPXIubGVuZ3RoO3M8bztzKyspdGhpcy5leHBhbmRCeU9iamVjdChyW3NdLHQpO3JldHVybiB0aGlzfWNvbnRhaW5zUG9pbnQoZSl7cmV0dXJuIGUueD49dGhpcy5taW4ueCYmZS54PD10aGlzLm1heC54JiZlLnk+PXRoaXMubWluLnkmJmUueTw9dGhpcy5tYXgueSYmZS56Pj10aGlzLm1pbi56JiZlLno8PXRoaXMubWF4Lnp9Y29udGFpbnNCb3goZSl7cmV0dXJuIHRoaXMubWluLng8PWUubWluLngmJmUubWF4Lng8PXRoaXMubWF4LngmJnRoaXMubWluLnk8PWUubWluLnkmJmUubWF4Lnk8PXRoaXMubWF4LnkmJnRoaXMubWluLno8PWUubWluLnomJmUubWF4Lno8PXRoaXMubWF4Lnp9Z2V0UGFyYW1ldGVyKGUsdCl7cmV0dXJuIHQuc2V0KChlLngtdGhpcy5taW4ueCkvKHRoaXMubWF4LngtdGhpcy5taW4ueCksKGUueS10aGlzLm1pbi55KS8odGhpcy5tYXgueS10aGlzLm1pbi55KSwoZS56LXRoaXMubWluLnopLyh0aGlzLm1heC56LXRoaXMubWluLnopKX1pbnRlcnNlY3RzQm94KGUpe3JldHVybiBlLm1heC54Pj10aGlzLm1pbi54JiZlLm1pbi54PD10aGlzLm1heC54JiZlLm1heC55Pj10aGlzLm1pbi55JiZlLm1pbi55PD10aGlzLm1heC55JiZlLm1heC56Pj10aGlzLm1pbi56JiZlLm1pbi56PD10aGlzLm1heC56fWludGVyc2VjdHNTcGhlcmUoZSl7cmV0dXJuIHRoaXMuY2xhbXBQb2ludChlLmNlbnRlcixMdCksTHQuZGlzdGFuY2VUb1NxdWFyZWQoZS5jZW50ZXIpPD1lLnJhZGl1cyplLnJhZGl1c31pbnRlcnNlY3RzUGxhbmUoZSl7bGV0IHQsaTtyZXR1cm4gZS5ub3JtYWwueD4wPyh0PWUubm9ybWFsLngqdGhpcy5taW4ueCxpPWUubm9ybWFsLngqdGhpcy5tYXgueCk6KHQ9ZS5ub3JtYWwueCp0aGlzLm1heC54LGk9ZS5ub3JtYWwueCp0aGlzLm1pbi54KSxlLm5vcm1hbC55PjA/KHQrPWUubm9ybWFsLnkqdGhpcy5taW4ueSxpKz1lLm5vcm1hbC55KnRoaXMubWF4LnkpOih0Kz1lLm5vcm1hbC55KnRoaXMubWF4LnksaSs9ZS5ub3JtYWwueSp0aGlzLm1pbi55KSxlLm5vcm1hbC56PjA/KHQrPWUubm9ybWFsLnoqdGhpcy5taW4ueixpKz1lLm5vcm1hbC56KnRoaXMubWF4LnopOih0Kz1lLm5vcm1hbC56KnRoaXMubWF4LnosaSs9ZS5ub3JtYWwueip0aGlzLm1pbi56KSx0PD0tZS5jb25zdGFudCYmaT49LWUuY29uc3RhbnR9aW50ZXJzZWN0c1RyaWFuZ2xlKGUpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiExO3RoaXMuZ2V0Q2VudGVyKFluKSxhaS5zdWJWZWN0b3JzKHRoaXMubWF4LFluKSxBbi5zdWJWZWN0b3JzKGUuYSxZbiksd24uc3ViVmVjdG9ycyhlLmIsWW4pLGJuLnN1YlZlY3RvcnMoZS5jLFluKSxRdC5zdWJWZWN0b3JzKHduLEFuKSxlbi5zdWJWZWN0b3JzKGJuLHduKSxsbi5zdWJWZWN0b3JzKEFuLGJuKTtsZXQgdD1bMCwtUXQueixRdC55LDAsLWVuLnosZW4ueSwwLC1sbi56LGxuLnksUXQueiwwLC1RdC54LGVuLnosMCwtZW4ueCxsbi56LDAsLWxuLngsLVF0LnksUXQueCwwLC1lbi55LGVuLngsMCwtbG4ueSxsbi54LDBdO3JldHVybiFIaSh0LEFuLHduLGJuLGFpKXx8KHQ9WzEsMCwwLDAsMSwwLDAsMCwxXSwhSGkodCxBbix3bixibixhaSkpPyExOihvaS5jcm9zc1ZlY3RvcnMoUXQsZW4pLHQ9W29pLngsb2kueSxvaS56XSxIaSh0LEFuLHduLGJuLGFpKSl9Y2xhbXBQb2ludChlLHQpe3JldHVybiB0LmNvcHkoZSkuY2xhbXAodGhpcy5taW4sdGhpcy5tYXgpfWRpc3RhbmNlVG9Qb2ludChlKXtyZXR1cm4gdGhpcy5jbGFtcFBvaW50KGUsTHQpLmRpc3RhbmNlVG8oZSl9Z2V0Qm91bmRpbmdTcGhlcmUoZSl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP2UubWFrZUVtcHR5KCk6KHRoaXMuZ2V0Q2VudGVyKGUuY2VudGVyKSxlLnJhZGl1cz10aGlzLmdldFNpemUoTHQpLmxlbmd0aCgpKi41KSxlfWludGVyc2VjdChlKXtyZXR1cm4gdGhpcy5taW4ubWF4KGUubWluKSx0aGlzLm1heC5taW4oZS5tYXgpLHRoaXMuaXNFbXB0eSgpJiZ0aGlzLm1ha2VFbXB0eSgpLHRoaXN9dW5pb24oZSl7cmV0dXJuIHRoaXMubWluLm1pbihlLm1pbiksdGhpcy5tYXgubWF4KGUubWF4KSx0aGlzfWFwcGx5TWF0cml4NChlKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/dGhpczooa3RbMF0uc2V0KHRoaXMubWluLngsdGhpcy5taW4ueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoZSksa3RbMV0uc2V0KHRoaXMubWluLngsdGhpcy5taW4ueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoZSksa3RbMl0uc2V0KHRoaXMubWluLngsdGhpcy5tYXgueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoZSksa3RbM10uc2V0KHRoaXMubWluLngsdGhpcy5tYXgueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoZSksa3RbNF0uc2V0KHRoaXMubWF4LngsdGhpcy5taW4ueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoZSksa3RbNV0uc2V0KHRoaXMubWF4LngsdGhpcy5taW4ueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoZSksa3RbNl0uc2V0KHRoaXMubWF4LngsdGhpcy5tYXgueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoZSksa3RbN10uc2V0KHRoaXMubWF4LngsdGhpcy5tYXgueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoZSksdGhpcy5zZXRGcm9tUG9pbnRzKGt0KSx0aGlzKX10cmFuc2xhdGUoZSl7cmV0dXJuIHRoaXMubWluLmFkZChlKSx0aGlzLm1heC5hZGQoZSksdGhpc31lcXVhbHMoZSl7cmV0dXJuIGUubWluLmVxdWFscyh0aGlzLm1pbikmJmUubWF4LmVxdWFscyh0aGlzLm1heCl9fWNvbnN0IGt0PVtuZXcgTyxuZXcgTyxuZXcgTyxuZXcgTyxuZXcgTyxuZXcgTyxuZXcgTyxuZXcgT10sTHQ9bmV3IE8sc2k9bmV3IHFuLEFuPW5ldyBPLHduPW5ldyBPLGJuPW5ldyBPLFF0PW5ldyBPLGVuPW5ldyBPLGxuPW5ldyBPLFluPW5ldyBPLGFpPW5ldyBPLG9pPW5ldyBPLGNuPW5ldyBPO2Z1bmN0aW9uIEhpKG4sZSx0LGkscil7Zm9yKGxldCBzPTAsbz1uLmxlbmd0aC0zO3M8PW87cys9Myl7Y24uZnJvbUFycmF5KG4scyk7Y29uc3QgYT1yLngqTWF0aC5hYnMoY24ueCkrci55Kk1hdGguYWJzKGNuLnkpK3IueipNYXRoLmFicyhjbi56KSxsPWUuZG90KGNuKSxjPXQuZG90KGNuKSx1PWkuZG90KGNuKTtpZihNYXRoLm1heCgtTWF0aC5tYXgobCxjLHUpLE1hdGgubWluKGwsYyx1KSk+YSlyZXR1cm4hMX1yZXR1cm4hMH1jb25zdCBNYT1uZXcgcW4sJG49bmV3IE8sVmk9bmV3IE87Y2xhc3MgbGl7Y29uc3RydWN0b3IoZT1uZXcgTyx0PS0xKXt0aGlzLmlzU3BoZXJlPSEwLHRoaXMuY2VudGVyPWUsdGhpcy5yYWRpdXM9dH1zZXQoZSx0KXtyZXR1cm4gdGhpcy5jZW50ZXIuY29weShlKSx0aGlzLnJhZGl1cz10LHRoaXN9c2V0RnJvbVBvaW50cyhlLHQpe2NvbnN0IGk9dGhpcy5jZW50ZXI7dCE9PXZvaWQgMD9pLmNvcHkodCk6TWEuc2V0RnJvbVBvaW50cyhlKS5nZXRDZW50ZXIoaSk7bGV0IHI9MDtmb3IobGV0IHM9MCxvPWUubGVuZ3RoO3M8bztzKyspcj1NYXRoLm1heChyLGkuZGlzdGFuY2VUb1NxdWFyZWQoZVtzXSkpO3JldHVybiB0aGlzLnJhZGl1cz1NYXRoLnNxcnQociksdGhpc31jb3B5KGUpe3JldHVybiB0aGlzLmNlbnRlci5jb3B5KGUuY2VudGVyKSx0aGlzLnJhZGl1cz1lLnJhZGl1cyx0aGlzfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5yYWRpdXM8MH1tYWtlRW1wdHkoKXtyZXR1cm4gdGhpcy5jZW50ZXIuc2V0KDAsMCwwKSx0aGlzLnJhZGl1cz0tMSx0aGlzfWNvbnRhaW5zUG9pbnQoZSl7cmV0dXJuIGUuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5jZW50ZXIpPD10aGlzLnJhZGl1cyp0aGlzLnJhZGl1c31kaXN0YW5jZVRvUG9pbnQoZSl7cmV0dXJuIGUuZGlzdGFuY2VUbyh0aGlzLmNlbnRlciktdGhpcy5yYWRpdXN9aW50ZXJzZWN0c1NwaGVyZShlKXtjb25zdCB0PXRoaXMucmFkaXVzK2UucmFkaXVzO3JldHVybiBlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCh0aGlzLmNlbnRlcik8PXQqdH1pbnRlcnNlY3RzQm94KGUpe3JldHVybiBlLmludGVyc2VjdHNTcGhlcmUodGhpcyl9aW50ZXJzZWN0c1BsYW5lKGUpe3JldHVybiBNYXRoLmFicyhlLmRpc3RhbmNlVG9Qb2ludCh0aGlzLmNlbnRlcikpPD10aGlzLnJhZGl1c31jbGFtcFBvaW50KGUsdCl7Y29uc3QgaT10aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZChlKTtyZXR1cm4gdC5jb3B5KGUpLGk+dGhpcy5yYWRpdXMqdGhpcy5yYWRpdXMmJih0LnN1Yih0aGlzLmNlbnRlcikubm9ybWFsaXplKCksdC5tdWx0aXBseVNjYWxhcih0aGlzLnJhZGl1cykuYWRkKHRoaXMuY2VudGVyKSksdH1nZXRCb3VuZGluZ0JveChlKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/KGUubWFrZUVtcHR5KCksZSk6KGUuc2V0KHRoaXMuY2VudGVyLHRoaXMuY2VudGVyKSxlLmV4cGFuZEJ5U2NhbGFyKHRoaXMucmFkaXVzKSxlKX1hcHBseU1hdHJpeDQoZSl7cmV0dXJuIHRoaXMuY2VudGVyLmFwcGx5TWF0cml4NChlKSx0aGlzLnJhZGl1cz10aGlzLnJhZGl1cyplLmdldE1heFNjYWxlT25BeGlzKCksdGhpc310cmFuc2xhdGUoZSl7cmV0dXJuIHRoaXMuY2VudGVyLmFkZChlKSx0aGlzfWV4cGFuZEJ5UG9pbnQoZSl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuY2VudGVyLmNvcHkoZSksdGhpcy5yYWRpdXM9MCx0aGlzOyRuLnN1YlZlY3RvcnMoZSx0aGlzLmNlbnRlcik7Y29uc3QgdD0kbi5sZW5ndGhTcSgpO2lmKHQ+dGhpcy5yYWRpdXMqdGhpcy5yYWRpdXMpe2NvbnN0IGk9TWF0aC5zcXJ0KHQpLHI9KGktdGhpcy5yYWRpdXMpKi41O3RoaXMuY2VudGVyLmFkZFNjYWxlZFZlY3RvcigkbixyL2kpLHRoaXMucmFkaXVzKz1yfXJldHVybiB0aGlzfXVuaW9uKGUpe3JldHVybiBlLmlzRW1wdHkoKT90aGlzOnRoaXMuaXNFbXB0eSgpPyh0aGlzLmNvcHkoZSksdGhpcyk6KHRoaXMuY2VudGVyLmVxdWFscyhlLmNlbnRlcik9PT0hMD90aGlzLnJhZGl1cz1NYXRoLm1heCh0aGlzLnJhZGl1cyxlLnJhZGl1cyk6KFZpLnN1YlZlY3RvcnMoZS5jZW50ZXIsdGhpcy5jZW50ZXIpLnNldExlbmd0aChlLnJhZGl1cyksdGhpcy5leHBhbmRCeVBvaW50KCRuLmNvcHkoZS5jZW50ZXIpLmFkZChWaSkpLHRoaXMuZXhwYW5kQnlQb2ludCgkbi5jb3B5KGUuY2VudGVyKS5zdWIoVmkpKSksdGhpcyl9ZXF1YWxzKGUpe3JldHVybiBlLmNlbnRlci5lcXVhbHModGhpcy5jZW50ZXIpJiZlLnJhZGl1cz09PXRoaXMucmFkaXVzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX19Y29uc3QgV3Q9bmV3IE8sa2k9bmV3IE8sY2k9bmV3IE8sdG49bmV3IE8sV2k9bmV3IE8sdWk9bmV3IE8sWGk9bmV3IE87Y2xhc3MgTHJ7Y29uc3RydWN0b3IoZT1uZXcgTyx0PW5ldyBPKDAsMCwtMSkpe3RoaXMub3JpZ2luPWUsdGhpcy5kaXJlY3Rpb249dH1zZXQoZSx0KXtyZXR1cm4gdGhpcy5vcmlnaW4uY29weShlKSx0aGlzLmRpcmVjdGlvbi5jb3B5KHQpLHRoaXN9Y29weShlKXtyZXR1cm4gdGhpcy5vcmlnaW4uY29weShlLm9yaWdpbiksdGhpcy5kaXJlY3Rpb24uY29weShlLmRpcmVjdGlvbiksdGhpc31hdChlLHQpe3JldHVybiB0LmNvcHkodGhpcy5vcmlnaW4pLmFkZFNjYWxlZFZlY3Rvcih0aGlzLmRpcmVjdGlvbixlKX1sb29rQXQoZSl7cmV0dXJuIHRoaXMuZGlyZWN0aW9uLmNvcHkoZSkuc3ViKHRoaXMub3JpZ2luKS5ub3JtYWxpemUoKSx0aGlzfXJlY2FzdChlKXtyZXR1cm4gdGhpcy5vcmlnaW4uY29weSh0aGlzLmF0KGUsV3QpKSx0aGlzfWNsb3Nlc3RQb2ludFRvUG9pbnQoZSx0KXt0LnN1YlZlY3RvcnMoZSx0aGlzLm9yaWdpbik7Y29uc3QgaT10LmRvdCh0aGlzLmRpcmVjdGlvbik7cmV0dXJuIGk8MD90LmNvcHkodGhpcy5vcmlnaW4pOnQuY29weSh0aGlzLm9yaWdpbikuYWRkU2NhbGVkVmVjdG9yKHRoaXMuZGlyZWN0aW9uLGkpfWRpc3RhbmNlVG9Qb2ludChlKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQoZSkpfWRpc3RhbmNlU3FUb1BvaW50KGUpe2NvbnN0IHQ9V3Quc3ViVmVjdG9ycyhlLHRoaXMub3JpZ2luKS5kb3QodGhpcy5kaXJlY3Rpb24pO3JldHVybiB0PDA/dGhpcy5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQoZSk6KFd0LmNvcHkodGhpcy5vcmlnaW4pLmFkZFNjYWxlZFZlY3Rvcih0aGlzLmRpcmVjdGlvbix0KSxXdC5kaXN0YW5jZVRvU3F1YXJlZChlKSl9ZGlzdGFuY2VTcVRvU2VnbWVudChlLHQsaSxyKXtraS5jb3B5KGUpLmFkZCh0KS5tdWx0aXBseVNjYWxhciguNSksY2kuY29weSh0KS5zdWIoZSkubm9ybWFsaXplKCksdG4uY29weSh0aGlzLm9yaWdpbikuc3ViKGtpKTtjb25zdCBzPWUuZGlzdGFuY2VUbyh0KSouNSxvPS10aGlzLmRpcmVjdGlvbi5kb3QoY2kpLGE9dG4uZG90KHRoaXMuZGlyZWN0aW9uKSxsPS10bi5kb3QoY2kpLGM9dG4ubGVuZ3RoU3EoKSx1PU1hdGguYWJzKDEtbypvKTtsZXQgZCxmLHAsZztpZih1PjApaWYoZD1vKmwtYSxmPW8qYS1sLGc9cyp1LGQ+PTApaWYoZj49LWcpaWYoZjw9Zyl7Y29uc3QgeD0xL3U7ZCo9eCxmKj14LHA9ZCooZCtvKmYrMiphKStmKihvKmQrZisyKmwpK2N9ZWxzZSBmPXMsZD1NYXRoLm1heCgwLC0obypmK2EpKSxwPS1kKmQrZiooZisyKmwpK2M7ZWxzZSBmPS1zLGQ9TWF0aC5tYXgoMCwtKG8qZithKSkscD0tZCpkK2YqKGYrMipsKStjO2Vsc2UgZjw9LWc/KGQ9TWF0aC5tYXgoMCwtKC1vKnMrYSkpLGY9ZD4wPy1zOk1hdGgubWluKE1hdGgubWF4KC1zLC1sKSxzKSxwPS1kKmQrZiooZisyKmwpK2MpOmY8PWc/KGQ9MCxmPU1hdGgubWluKE1hdGgubWF4KC1zLC1sKSxzKSxwPWYqKGYrMipsKStjKTooZD1NYXRoLm1heCgwLC0obypzK2EpKSxmPWQ+MD9zOk1hdGgubWluKE1hdGgubWF4KC1zLC1sKSxzKSxwPS1kKmQrZiooZisyKmwpK2MpO2Vsc2UgZj1vPjA/LXM6cyxkPU1hdGgubWF4KDAsLShvKmYrYSkpLHA9LWQqZCtmKihmKzIqbCkrYztyZXR1cm4gaSYmaS5jb3B5KHRoaXMub3JpZ2luKS5hZGRTY2FsZWRWZWN0b3IodGhpcy5kaXJlY3Rpb24sZCksciYmci5jb3B5KGtpKS5hZGRTY2FsZWRWZWN0b3IoY2ksZikscH1pbnRlcnNlY3RTcGhlcmUoZSx0KXtXdC5zdWJWZWN0b3JzKGUuY2VudGVyLHRoaXMub3JpZ2luKTtjb25zdCBpPVd0LmRvdCh0aGlzLmRpcmVjdGlvbikscj1XdC5kb3QoV3QpLWkqaSxzPWUucmFkaXVzKmUucmFkaXVzO2lmKHI+cylyZXR1cm4gbnVsbDtjb25zdCBvPU1hdGguc3FydChzLXIpLGE9aS1vLGw9aStvO3JldHVybiBsPDA/bnVsbDphPDA/dGhpcy5hdChsLHQpOnRoaXMuYXQoYSx0KX1pbnRlcnNlY3RzU3BoZXJlKGUpe3JldHVybiB0aGlzLmRpc3RhbmNlU3FUb1BvaW50KGUuY2VudGVyKTw9ZS5yYWRpdXMqZS5yYWRpdXN9ZGlzdGFuY2VUb1BsYW5lKGUpe2NvbnN0IHQ9ZS5ub3JtYWwuZG90KHRoaXMuZGlyZWN0aW9uKTtpZih0PT09MClyZXR1cm4gZS5kaXN0YW5jZVRvUG9pbnQodGhpcy5vcmlnaW4pPT09MD8wOm51bGw7Y29uc3QgaT0tKHRoaXMub3JpZ2luLmRvdChlLm5vcm1hbCkrZS5jb25zdGFudCkvdDtyZXR1cm4gaT49MD9pOm51bGx9aW50ZXJzZWN0UGxhbmUoZSx0KXtjb25zdCBpPXRoaXMuZGlzdGFuY2VUb1BsYW5lKGUpO3JldHVybiBpPT09bnVsbD9udWxsOnRoaXMuYXQoaSx0KX1pbnRlcnNlY3RzUGxhbmUoZSl7Y29uc3QgdD1lLmRpc3RhbmNlVG9Qb2ludCh0aGlzLm9yaWdpbik7cmV0dXJuIHQ9PT0wfHxlLm5vcm1hbC5kb3QodGhpcy5kaXJlY3Rpb24pKnQ8MH1pbnRlcnNlY3RCb3goZSx0KXtsZXQgaSxyLHMsbyxhLGw7Y29uc3QgYz0xL3RoaXMuZGlyZWN0aW9uLngsdT0xL3RoaXMuZGlyZWN0aW9uLnksZD0xL3RoaXMuZGlyZWN0aW9uLnosZj10aGlzLm9yaWdpbjtyZXR1cm4gYz49MD8oaT0oZS5taW4ueC1mLngpKmMscj0oZS5tYXgueC1mLngpKmMpOihpPShlLm1heC54LWYueCkqYyxyPShlLm1pbi54LWYueCkqYyksdT49MD8ocz0oZS5taW4ueS1mLnkpKnUsbz0oZS5tYXgueS1mLnkpKnUpOihzPShlLm1heC55LWYueSkqdSxvPShlLm1pbi55LWYueSkqdSksaT5vfHxzPnJ8fCgocz5pfHxpc05hTihpKSkmJihpPXMpLChvPHJ8fGlzTmFOKHIpKSYmKHI9byksZD49MD8oYT0oZS5taW4uei1mLnopKmQsbD0oZS5tYXguei1mLnopKmQpOihhPShlLm1heC56LWYueikqZCxsPShlLm1pbi56LWYueikqZCksaT5sfHxhPnIpfHwoKGE+aXx8aSE9PWkpJiYoaT1hKSwobDxyfHxyIT09cikmJihyPWwpLHI8MCk/bnVsbDp0aGlzLmF0KGk+PTA/aTpyLHQpfWludGVyc2VjdHNCb3goZSl7cmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KGUsV3QpIT09bnVsbH1pbnRlcnNlY3RUcmlhbmdsZShlLHQsaSxyLHMpe1dpLnN1YlZlY3RvcnModCxlKSx1aS5zdWJWZWN0b3JzKGksZSksWGkuY3Jvc3NWZWN0b3JzKFdpLHVpKTtsZXQgbz10aGlzLmRpcmVjdGlvbi5kb3QoWGkpLGE7aWYobz4wKXtpZihyKXJldHVybiBudWxsO2E9MX1lbHNlIGlmKG88MClhPS0xLG89LW87ZWxzZSByZXR1cm4gbnVsbDt0bi5zdWJWZWN0b3JzKHRoaXMub3JpZ2luLGUpO2NvbnN0IGw9YSp0aGlzLmRpcmVjdGlvbi5kb3QodWkuY3Jvc3NWZWN0b3JzKHRuLHVpKSk7aWYobDwwKXJldHVybiBudWxsO2NvbnN0IGM9YSp0aGlzLmRpcmVjdGlvbi5kb3QoV2kuY3Jvc3ModG4pKTtpZihjPDB8fGwrYz5vKXJldHVybiBudWxsO2NvbnN0IHU9LWEqdG4uZG90KFhpKTtyZXR1cm4gdTwwP251bGw6dGhpcy5hdCh1L28scyl9YXBwbHlNYXRyaXg0KGUpe3JldHVybiB0aGlzLm9yaWdpbi5hcHBseU1hdHJpeDQoZSksdGhpcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKGUpLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLm9yaWdpbi5lcXVhbHModGhpcy5vcmlnaW4pJiZlLmRpcmVjdGlvbi5lcXVhbHModGhpcy5kaXJlY3Rpb24pfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX19Y2xhc3Mgc3R7Y29uc3RydWN0b3IoZSx0LGkscixzLG8sYSxsLGMsdSxkLGYscCxnLHgsbSl7c3QucHJvdG90eXBlLmlzTWF0cml4ND0hMCx0aGlzLmVsZW1lbnRzPVsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxXSxlIT09dm9pZCAwJiZ0aGlzLnNldChlLHQsaSxyLHMsbyxhLGwsYyx1LGQsZixwLGcseCxtKX1zZXQoZSx0LGkscixzLG8sYSxsLGMsdSxkLGYscCxnLHgsbSl7Y29uc3QgaD10aGlzLmVsZW1lbnRzO3JldHVybiBoWzBdPWUsaFs0XT10LGhbOF09aSxoWzEyXT1yLGhbMV09cyxoWzVdPW8saFs5XT1hLGhbMTNdPWwsaFsyXT1jLGhbNl09dSxoWzEwXT1kLGhbMTRdPWYsaFszXT1wLGhbN109ZyxoWzExXT14LGhbMTVdPW0sdGhpc31pZGVudGl0eSgpe3JldHVybiB0aGlzLnNldCgxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyBzdCgpLmZyb21BcnJheSh0aGlzLmVsZW1lbnRzKX1jb3B5KGUpe2NvbnN0IHQ9dGhpcy5lbGVtZW50cyxpPWUuZWxlbWVudHM7cmV0dXJuIHRbMF09aVswXSx0WzFdPWlbMV0sdFsyXT1pWzJdLHRbM109aVszXSx0WzRdPWlbNF0sdFs1XT1pWzVdLHRbNl09aVs2XSx0WzddPWlbN10sdFs4XT1pWzhdLHRbOV09aVs5XSx0WzEwXT1pWzEwXSx0WzExXT1pWzExXSx0WzEyXT1pWzEyXSx0WzEzXT1pWzEzXSx0WzE0XT1pWzE0XSx0WzE1XT1pWzE1XSx0aGlzfWNvcHlQb3NpdGlvbihlKXtjb25zdCB0PXRoaXMuZWxlbWVudHMsaT1lLmVsZW1lbnRzO3JldHVybiB0WzEyXT1pWzEyXSx0WzEzXT1pWzEzXSx0WzE0XT1pWzE0XSx0aGlzfXNldEZyb21NYXRyaXgzKGUpe2NvbnN0IHQ9ZS5lbGVtZW50cztyZXR1cm4gdGhpcy5zZXQodFswXSx0WzNdLHRbNl0sMCx0WzFdLHRbNF0sdFs3XSwwLHRbMl0sdFs1XSx0WzhdLDAsMCwwLDAsMSksdGhpc31leHRyYWN0QmFzaXMoZSx0LGkpe3JldHVybiBlLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywwKSx0LnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywxKSxpLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywyKSx0aGlzfW1ha2VCYXNpcyhlLHQsaSl7cmV0dXJuIHRoaXMuc2V0KGUueCx0LngsaS54LDAsZS55LHQueSxpLnksMCxlLnosdC56LGkueiwwLDAsMCwwLDEpLHRoaXN9ZXh0cmFjdFJvdGF0aW9uKGUpe2NvbnN0IHQ9dGhpcy5lbGVtZW50cyxpPWUuZWxlbWVudHMscj0xL1JuLnNldEZyb21NYXRyaXhDb2x1bW4oZSwwKS5sZW5ndGgoKSxzPTEvUm4uc2V0RnJvbU1hdHJpeENvbHVtbihlLDEpLmxlbmd0aCgpLG89MS9Sbi5zZXRGcm9tTWF0cml4Q29sdW1uKGUsMikubGVuZ3RoKCk7cmV0dXJuIHRbMF09aVswXSpyLHRbMV09aVsxXSpyLHRbMl09aVsyXSpyLHRbM109MCx0WzRdPWlbNF0qcyx0WzVdPWlbNV0qcyx0WzZdPWlbNl0qcyx0WzddPTAsdFs4XT1pWzhdKm8sdFs5XT1pWzldKm8sdFsxMF09aVsxMF0qbyx0WzExXT0wLHRbMTJdPTAsdFsxM109MCx0WzE0XT0wLHRbMTVdPTEsdGhpc31tYWtlUm90YXRpb25Gcm9tRXVsZXIoZSl7Y29uc3QgdD10aGlzLmVsZW1lbnRzLGk9ZS54LHI9ZS55LHM9ZS56LG89TWF0aC5jb3MoaSksYT1NYXRoLnNpbihpKSxsPU1hdGguY29zKHIpLGM9TWF0aC5zaW4ociksdT1NYXRoLmNvcyhzKSxkPU1hdGguc2luKHMpO2lmKGUub3JkZXI9PT0iWFlaIil7Y29uc3QgZj1vKnUscD1vKmQsZz1hKnUseD1hKmQ7dFswXT1sKnUsdFs0XT0tbCpkLHRbOF09Yyx0WzFdPXArZypjLHRbNV09Zi14KmMsdFs5XT0tYSpsLHRbMl09eC1mKmMsdFs2XT1nK3AqYyx0WzEwXT1vKmx9ZWxzZSBpZihlLm9yZGVyPT09IllYWiIpe2NvbnN0IGY9bCp1LHA9bCpkLGc9Yyp1LHg9YypkO3RbMF09Zit4KmEsdFs0XT1nKmEtcCx0WzhdPW8qYyx0WzFdPW8qZCx0WzVdPW8qdSx0WzldPS1hLHRbMl09cCphLWcsdFs2XT14K2YqYSx0WzEwXT1vKmx9ZWxzZSBpZihlLm9yZGVyPT09IlpYWSIpe2NvbnN0IGY9bCp1LHA9bCpkLGc9Yyp1LHg9YypkO3RbMF09Zi14KmEsdFs0XT0tbypkLHRbOF09ZytwKmEsdFsxXT1wK2cqYSx0WzVdPW8qdSx0WzldPXgtZiphLHRbMl09LW8qYyx0WzZdPWEsdFsxMF09bypsfWVsc2UgaWYoZS5vcmRlcj09PSJaWVgiKXtjb25zdCBmPW8qdSxwPW8qZCxnPWEqdSx4PWEqZDt0WzBdPWwqdSx0WzRdPWcqYy1wLHRbOF09ZipjK3gsdFsxXT1sKmQsdFs1XT14KmMrZix0WzldPXAqYy1nLHRbMl09LWMsdFs2XT1hKmwsdFsxMF09bypsfWVsc2UgaWYoZS5vcmRlcj09PSJZWlgiKXtjb25zdCBmPW8qbCxwPW8qYyxnPWEqbCx4PWEqYzt0WzBdPWwqdSx0WzRdPXgtZipkLHRbOF09ZypkK3AsdFsxXT1kLHRbNV09byp1LHRbOV09LWEqdSx0WzJdPS1jKnUsdFs2XT1wKmQrZyx0WzEwXT1mLXgqZH1lbHNlIGlmKGUub3JkZXI9PT0iWFpZIil7Y29uc3QgZj1vKmwscD1vKmMsZz1hKmwseD1hKmM7dFswXT1sKnUsdFs0XT0tZCx0WzhdPWMqdSx0WzFdPWYqZCt4LHRbNV09byp1LHRbOV09cCpkLWcsdFsyXT1nKmQtcCx0WzZdPWEqdSx0WzEwXT14KmQrZn1yZXR1cm4gdFszXT0wLHRbN109MCx0WzExXT0wLHRbMTJdPTAsdFsxM109MCx0WzE0XT0wLHRbMTVdPTEsdGhpc31tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihlKXtyZXR1cm4gdGhpcy5jb21wb3NlKFNhLGUsRWEpfWxvb2tBdChlLHQsaSl7Y29uc3Qgcj10aGlzLmVsZW1lbnRzO3JldHVybiB5dC5zdWJWZWN0b3JzKGUsdCkseXQubGVuZ3RoU3EoKT09PTAmJih5dC56PTEpLHl0Lm5vcm1hbGl6ZSgpLG5uLmNyb3NzVmVjdG9ycyhpLHl0KSxubi5sZW5ndGhTcSgpPT09MCYmKE1hdGguYWJzKGkueik9PT0xP3l0LngrPTFlLTQ6eXQueis9MWUtNCx5dC5ub3JtYWxpemUoKSxubi5jcm9zc1ZlY3RvcnMoaSx5dCkpLG5uLm5vcm1hbGl6ZSgpLGhpLmNyb3NzVmVjdG9ycyh5dCxubiksclswXT1ubi54LHJbNF09aGkueCxyWzhdPXl0LngsclsxXT1ubi55LHJbNV09aGkueSxyWzldPXl0LnksclsyXT1ubi56LHJbNl09aGkueixyWzEwXT15dC56LHRoaXN9bXVsdGlwbHkoZSl7cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyh0aGlzLGUpfXByZW11bHRpcGx5KGUpe3JldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoZSx0aGlzKX1tdWx0aXBseU1hdHJpY2VzKGUsdCl7Y29uc3QgaT1lLmVsZW1lbnRzLHI9dC5lbGVtZW50cyxzPXRoaXMuZWxlbWVudHMsbz1pWzBdLGE9aVs0XSxsPWlbOF0sYz1pWzEyXSx1PWlbMV0sZD1pWzVdLGY9aVs5XSxwPWlbMTNdLGc9aVsyXSx4PWlbNl0sbT1pWzEwXSxoPWlbMTRdLFQ9aVszXSx5PWlbN10sXz1pWzExXSxDPWlbMTVdLHc9clswXSxiPXJbNF0sRj1yWzhdLEU9clsxMl0sUz1yWzFdLFI9cls1XSxxPXJbOV0sej1yWzEzXSxXPXJbMl0sWj1yWzZdLFY9clsxMF0sUT1yWzE0XSxIPXJbM10saWU9cls3XSxjZT1yWzExXSx4ZT1yWzE1XTtyZXR1cm4gc1swXT1vKncrYSpTK2wqVytjKkgsc1s0XT1vKmIrYSpSK2wqWitjKmllLHNbOF09bypGK2EqcStsKlYrYypjZSxzWzEyXT1vKkUrYSp6K2wqUStjKnhlLHNbMV09dSp3K2QqUytmKlcrcCpILHNbNV09dSpiK2QqUitmKlorcCppZSxzWzldPXUqRitkKnErZipWK3AqY2Usc1sxM109dSpFK2QqeitmKlErcCp4ZSxzWzJdPWcqdyt4KlMrbSpXK2gqSCxzWzZdPWcqYit4KlIrbSpaK2gqaWUsc1sxMF09ZypGK3gqcSttKlYraCpjZSxzWzE0XT1nKkUreCp6K20qUStoKnhlLHNbM109VCp3K3kqUytfKlcrQypILHNbN109VCpiK3kqUitfKlorQyppZSxzWzExXT1UKkYreSpxK18qVitDKmNlLHNbMTVdPVQqRSt5KnorXypRK0MqeGUsdGhpc31tdWx0aXBseVNjYWxhcihlKXtjb25zdCB0PXRoaXMuZWxlbWVudHM7cmV0dXJuIHRbMF0qPWUsdFs0XSo9ZSx0WzhdKj1lLHRbMTJdKj1lLHRbMV0qPWUsdFs1XSo9ZSx0WzldKj1lLHRbMTNdKj1lLHRbMl0qPWUsdFs2XSo9ZSx0WzEwXSo9ZSx0WzE0XSo9ZSx0WzNdKj1lLHRbN10qPWUsdFsxMV0qPWUsdFsxNV0qPWUsdGhpc31kZXRlcm1pbmFudCgpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyx0PWVbMF0saT1lWzRdLHI9ZVs4XSxzPWVbMTJdLG89ZVsxXSxhPWVbNV0sbD1lWzldLGM9ZVsxM10sdT1lWzJdLGQ9ZVs2XSxmPWVbMTBdLHA9ZVsxNF0sZz1lWzNdLHg9ZVs3XSxtPWVbMTFdLGg9ZVsxNV07cmV0dXJuIGcqKCtzKmwqZC1yKmMqZC1zKmEqZitpKmMqZityKmEqcC1pKmwqcCkreCooK3QqbCpwLXQqYypmK3MqbypmLXIqbypwK3IqYyp1LXMqbCp1KSttKigrdCpjKmQtdCphKnAtcypvKmQraSpvKnArcyphKnUtaSpjKnUpK2gqKC1yKmEqdS10KmwqZCt0KmEqZityKm8qZC1pKm8qZitpKmwqdSl9dHJhbnNwb3NlKCl7Y29uc3QgZT10aGlzLmVsZW1lbnRzO2xldCB0O3JldHVybiB0PWVbMV0sZVsxXT1lWzRdLGVbNF09dCx0PWVbMl0sZVsyXT1lWzhdLGVbOF09dCx0PWVbNl0sZVs2XT1lWzldLGVbOV09dCx0PWVbM10sZVszXT1lWzEyXSxlWzEyXT10LHQ9ZVs3XSxlWzddPWVbMTNdLGVbMTNdPXQsdD1lWzExXSxlWzExXT1lWzE0XSxlWzE0XT10LHRoaXN9c2V0UG9zaXRpb24oZSx0LGkpe2NvbnN0IHI9dGhpcy5lbGVtZW50cztyZXR1cm4gZS5pc1ZlY3RvcjM/KHJbMTJdPWUueCxyWzEzXT1lLnksclsxNF09ZS56KTooclsxMl09ZSxyWzEzXT10LHJbMTRdPWkpLHRoaXN9aW52ZXJ0KCl7Y29uc3QgZT10aGlzLmVsZW1lbnRzLHQ9ZVswXSxpPWVbMV0scj1lWzJdLHM9ZVszXSxvPWVbNF0sYT1lWzVdLGw9ZVs2XSxjPWVbN10sdT1lWzhdLGQ9ZVs5XSxmPWVbMTBdLHA9ZVsxMV0sZz1lWzEyXSx4PWVbMTNdLG09ZVsxNF0saD1lWzE1XSxUPWQqbSpjLXgqZipjK3gqbCpwLWEqbSpwLWQqbCpoK2EqZipoLHk9ZypmKmMtdSptKmMtZypsKnArbyptKnArdSpsKmgtbypmKmgsXz11KngqYy1nKmQqYytnKmEqcC1vKngqcC11KmEqaCtvKmQqaCxDPWcqZCpsLXUqeCpsLWcqYSpmK28qeCpmK3UqYSptLW8qZCptLHc9dCpUK2kqeStyKl8rcypDO2lmKHc9PT0wKXJldHVybiB0aGlzLnNldCgwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwKTtjb25zdCBiPTEvdztyZXR1cm4gZVswXT1UKmIsZVsxXT0oeCpmKnMtZCptKnMteCpyKnAraSptKnArZCpyKmgtaSpmKmgpKmIsZVsyXT0oYSptKnMteCpsKnMreCpyKmMtaSptKmMtYSpyKmgraSpsKmgpKmIsZVszXT0oZCpsKnMtYSpmKnMtZCpyKmMraSpmKmMrYSpyKnAtaSpsKnApKmIsZVs0XT15KmIsZVs1XT0odSptKnMtZypmKnMrZypyKnAtdCptKnAtdSpyKmgrdCpmKmgpKmIsZVs2XT0oZypsKnMtbyptKnMtZypyKmMrdCptKmMrbypyKmgtdCpsKmgpKmIsZVs3XT0obypmKnMtdSpsKnMrdSpyKmMtdCpmKmMtbypyKnArdCpsKnApKmIsZVs4XT1fKmIsZVs5XT0oZypkKnMtdSp4KnMtZyppKnArdCp4KnArdSppKmgtdCpkKmgpKmIsZVsxMF09KG8qeCpzLWcqYSpzK2cqaSpjLXQqeCpjLW8qaSpoK3QqYSpoKSpiLGVbMTFdPSh1KmEqcy1vKmQqcy11KmkqYyt0KmQqYytvKmkqcC10KmEqcCkqYixlWzEyXT1DKmIsZVsxM109KHUqeCpyLWcqZCpyK2cqaSpmLXQqeCpmLXUqaSptK3QqZCptKSpiLGVbMTRdPShnKmEqci1vKngqci1nKmkqbCt0KngqbCtvKmkqbS10KmEqbSkqYixlWzE1XT0obypkKnItdSphKnIrdSppKmwtdCpkKmwtbyppKmYrdCphKmYpKmIsdGhpc31zY2FsZShlKXtjb25zdCB0PXRoaXMuZWxlbWVudHMsaT1lLngscj1lLnkscz1lLno7cmV0dXJuIHRbMF0qPWksdFs0XSo9cix0WzhdKj1zLHRbMV0qPWksdFs1XSo9cix0WzldKj1zLHRbMl0qPWksdFs2XSo9cix0WzEwXSo9cyx0WzNdKj1pLHRbN10qPXIsdFsxMV0qPXMsdGhpc31nZXRNYXhTY2FsZU9uQXhpcygpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyx0PWVbMF0qZVswXStlWzFdKmVbMV0rZVsyXSplWzJdLGk9ZVs0XSplWzRdK2VbNV0qZVs1XStlWzZdKmVbNl0scj1lWzhdKmVbOF0rZVs5XSplWzldK2VbMTBdKmVbMTBdO3JldHVybiBNYXRoLnNxcnQoTWF0aC5tYXgodCxpLHIpKX1tYWtlVHJhbnNsYXRpb24oZSx0LGkpe3JldHVybiBlLmlzVmVjdG9yMz90aGlzLnNldCgxLDAsMCxlLngsMCwxLDAsZS55LDAsMCwxLGUueiwwLDAsMCwxKTp0aGlzLnNldCgxLDAsMCxlLDAsMSwwLHQsMCwwLDEsaSwwLDAsMCwxKSx0aGlzfW1ha2VSb3RhdGlvblgoZSl7Y29uc3QgdD1NYXRoLmNvcyhlKSxpPU1hdGguc2luKGUpO3JldHVybiB0aGlzLnNldCgxLDAsMCwwLDAsdCwtaSwwLDAsaSx0LDAsMCwwLDAsMSksdGhpc31tYWtlUm90YXRpb25ZKGUpe2NvbnN0IHQ9TWF0aC5jb3MoZSksaT1NYXRoLnNpbihlKTtyZXR1cm4gdGhpcy5zZXQodCwwLGksMCwwLDEsMCwwLC1pLDAsdCwwLDAsMCwwLDEpLHRoaXN9bWFrZVJvdGF0aW9uWihlKXtjb25zdCB0PU1hdGguY29zKGUpLGk9TWF0aC5zaW4oZSk7cmV0dXJuIHRoaXMuc2V0KHQsLWksMCwwLGksdCwwLDAsMCwwLDEsMCwwLDAsMCwxKSx0aGlzfW1ha2VSb3RhdGlvbkF4aXMoZSx0KXtjb25zdCBpPU1hdGguY29zKHQpLHI9TWF0aC5zaW4odCkscz0xLWksbz1lLngsYT1lLnksbD1lLnosYz1zKm8sdT1zKmE7cmV0dXJuIHRoaXMuc2V0KGMqbytpLGMqYS1yKmwsYypsK3IqYSwwLGMqYStyKmwsdSphK2ksdSpsLXIqbywwLGMqbC1yKmEsdSpsK3IqbyxzKmwqbCtpLDAsMCwwLDAsMSksdGhpc31tYWtlU2NhbGUoZSx0LGkpe3JldHVybiB0aGlzLnNldChlLDAsMCwwLDAsdCwwLDAsMCwwLGksMCwwLDAsMCwxKSx0aGlzfW1ha2VTaGVhcihlLHQsaSxyLHMsbyl7cmV0dXJuIHRoaXMuc2V0KDEsaSxzLDAsZSwxLG8sMCx0LHIsMSwwLDAsMCwwLDEpLHRoaXN9Y29tcG9zZShlLHQsaSl7Y29uc3Qgcj10aGlzLmVsZW1lbnRzLHM9dC5feCxvPXQuX3ksYT10Ll96LGw9dC5fdyxjPXMrcyx1PW8rbyxkPWErYSxmPXMqYyxwPXMqdSxnPXMqZCx4PW8qdSxtPW8qZCxoPWEqZCxUPWwqYyx5PWwqdSxfPWwqZCxDPWkueCx3PWkueSxiPWkuejtyZXR1cm4gclswXT0oMS0oeCtoKSkqQyxyWzFdPShwK18pKkMsclsyXT0oZy15KSpDLHJbM109MCxyWzRdPShwLV8pKncscls1XT0oMS0oZitoKSkqdyxyWzZdPShtK1QpKncscls3XT0wLHJbOF09KGcreSkqYixyWzldPShtLVQpKmIsclsxMF09KDEtKGYreCkpKmIsclsxMV09MCxyWzEyXT1lLngsclsxM109ZS55LHJbMTRdPWUueixyWzE1XT0xLHRoaXN9ZGVjb21wb3NlKGUsdCxpKXtjb25zdCByPXRoaXMuZWxlbWVudHM7bGV0IHM9Um4uc2V0KHJbMF0sclsxXSxyWzJdKS5sZW5ndGgoKTtjb25zdCBvPVJuLnNldChyWzRdLHJbNV0scls2XSkubGVuZ3RoKCksYT1Sbi5zZXQocls4XSxyWzldLHJbMTBdKS5sZW5ndGgoKTt0aGlzLmRldGVybWluYW50KCk8MCYmKHM9LXMpLGUueD1yWzEyXSxlLnk9clsxM10sZS56PXJbMTRdLFV0LmNvcHkodGhpcyk7Y29uc3QgYz0xL3MsdT0xL28sZD0xL2E7cmV0dXJuIFV0LmVsZW1lbnRzWzBdKj1jLFV0LmVsZW1lbnRzWzFdKj1jLFV0LmVsZW1lbnRzWzJdKj1jLFV0LmVsZW1lbnRzWzRdKj11LFV0LmVsZW1lbnRzWzVdKj11LFV0LmVsZW1lbnRzWzZdKj11LFV0LmVsZW1lbnRzWzhdKj1kLFV0LmVsZW1lbnRzWzldKj1kLFV0LmVsZW1lbnRzWzEwXSo9ZCx0LnNldEZyb21Sb3RhdGlvbk1hdHJpeChVdCksaS54PXMsaS55PW8saS56PWEsdGhpc31tYWtlUGVyc3BlY3RpdmUoZSx0LGkscixzLG8sYT0yZTMpe2NvbnN0IGw9dGhpcy5lbGVtZW50cyxjPTIqcy8odC1lKSx1PTIqcy8oaS1yKSxkPSh0K2UpLyh0LWUpLGY9KGkrcikvKGktcik7bGV0IHAsZztpZihhPT09MmUzKXA9LShvK3MpLyhvLXMpLGc9LTIqbypzLyhvLXMpO2Vsc2UgaWYoYT09PTIwMDEpcD0tby8oby1zKSxnPS1vKnMvKG8tcyk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLk1hdHJpeDQubWFrZVBlcnNwZWN0aXZlKCk6IEludmFsaWQgY29vcmRpbmF0ZSBzeXN0ZW06ICIrYSk7cmV0dXJuIGxbMF09YyxsWzRdPTAsbFs4XT1kLGxbMTJdPTAsbFsxXT0wLGxbNV09dSxsWzldPWYsbFsxM109MCxsWzJdPTAsbFs2XT0wLGxbMTBdPXAsbFsxNF09ZyxsWzNdPTAsbFs3XT0wLGxbMTFdPS0xLGxbMTVdPTAsdGhpc31tYWtlT3J0aG9ncmFwaGljKGUsdCxpLHIscyxvLGE9MmUzKXtjb25zdCBsPXRoaXMuZWxlbWVudHMsYz0xLyh0LWUpLHU9MS8oaS1yKSxkPTEvKG8tcyksZj0odCtlKSpjLHA9KGkrcikqdTtsZXQgZyx4O2lmKGE9PT0yZTMpZz0obytzKSpkLHg9LTIqZDtlbHNlIGlmKGE9PT0yMDAxKWc9cypkLHg9LTEqZDtlbHNlIHRocm93IG5ldyBFcnJvcigiVEhSRUUuTWF0cml4NC5tYWtlT3J0aG9ncmFwaGljKCk6IEludmFsaWQgY29vcmRpbmF0ZSBzeXN0ZW06ICIrYSk7cmV0dXJuIGxbMF09MipjLGxbNF09MCxsWzhdPTAsbFsxMl09LWYsbFsxXT0wLGxbNV09Mip1LGxbOV09MCxsWzEzXT0tcCxsWzJdPTAsbFs2XT0wLGxbMTBdPXgsbFsxNF09LWcsbFszXT0wLGxbN109MCxsWzExXT0wLGxbMTVdPTEsdGhpc31lcXVhbHMoZSl7Y29uc3QgdD10aGlzLmVsZW1lbnRzLGk9ZS5lbGVtZW50cztmb3IobGV0IHI9MDtyPDE2O3IrKylpZih0W3JdIT09aVtyXSlyZXR1cm4hMTtyZXR1cm4hMH1mcm9tQXJyYXkoZSx0PTApe2ZvcihsZXQgaT0wO2k8MTY7aSsrKXRoaXMuZWxlbWVudHNbaV09ZVtpK3RdO3JldHVybiB0aGlzfXRvQXJyYXkoZT1bXSx0PTApe2NvbnN0IGk9dGhpcy5lbGVtZW50cztyZXR1cm4gZVt0XT1pWzBdLGVbdCsxXT1pWzFdLGVbdCsyXT1pWzJdLGVbdCszXT1pWzNdLGVbdCs0XT1pWzRdLGVbdCs1XT1pWzVdLGVbdCs2XT1pWzZdLGVbdCs3XT1pWzddLGVbdCs4XT1pWzhdLGVbdCs5XT1pWzldLGVbdCsxMF09aVsxMF0sZVt0KzExXT1pWzExXSxlW3QrMTJdPWlbMTJdLGVbdCsxM109aVsxM10sZVt0KzE0XT1pWzE0XSxlW3QrMTVdPWlbMTVdLGV9fWNvbnN0IFJuPW5ldyBPLFV0PW5ldyBzdCxTYT1uZXcgTygwLDAsMCksRWE9bmV3IE8oMSwxLDEpLG5uPW5ldyBPLGhpPW5ldyBPLHl0PW5ldyBPLFVyPW5ldyBzdCxGcj1uZXcgWG47Y2xhc3MgWHR7Y29uc3RydWN0b3IoZT0wLHQ9MCxpPTAscj1YdC5ERUZBVUxUX09SREVSKXt0aGlzLmlzRXVsZXI9ITAsdGhpcy5feD1lLHRoaXMuX3k9dCx0aGlzLl96PWksdGhpcy5fb3JkZXI9cn1nZXQgeCgpe3JldHVybiB0aGlzLl94fXNldCB4KGUpe3RoaXMuX3g9ZSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9Z2V0IHkoKXtyZXR1cm4gdGhpcy5feX1zZXQgeShlKXt0aGlzLl95PWUsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfWdldCB6KCl7cmV0dXJuIHRoaXMuX3p9c2V0IHooZSl7dGhpcy5fej1lLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKX1nZXQgb3JkZXIoKXtyZXR1cm4gdGhpcy5fb3JkZXJ9c2V0IG9yZGVyKGUpe3RoaXMuX29yZGVyPWUsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfXNldChlLHQsaSxyPXRoaXMuX29yZGVyKXtyZXR1cm4gdGhpcy5feD1lLHRoaXMuX3k9dCx0aGlzLl96PWksdGhpcy5fb3JkZXI9cix0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLl94LHRoaXMuX3ksdGhpcy5feix0aGlzLl9vcmRlcil9Y29weShlKXtyZXR1cm4gdGhpcy5feD1lLl94LHRoaXMuX3k9ZS5feSx0aGlzLl96PWUuX3osdGhpcy5fb3JkZXI9ZS5fb3JkZXIsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVJvdGF0aW9uTWF0cml4KGUsdD10aGlzLl9vcmRlcixpPSEwKXtjb25zdCByPWUuZWxlbWVudHMscz1yWzBdLG89cls0XSxhPXJbOF0sbD1yWzFdLGM9cls1XSx1PXJbOV0sZD1yWzJdLGY9cls2XSxwPXJbMTBdO3N3aXRjaCh0KXtjYXNlIlhZWiI6dGhpcy5feT1NYXRoLmFzaW4oZ3QoYSwtMSwxKSksTWF0aC5hYnMoYSk8Ljk5OTk5OTk/KHRoaXMuX3g9TWF0aC5hdGFuMigtdSxwKSx0aGlzLl96PU1hdGguYXRhbjIoLW8scykpOih0aGlzLl94PU1hdGguYXRhbjIoZixjKSx0aGlzLl96PTApO2JyZWFrO2Nhc2UiWVhaIjp0aGlzLl94PU1hdGguYXNpbigtZ3QodSwtMSwxKSksTWF0aC5hYnModSk8Ljk5OTk5OTk/KHRoaXMuX3k9TWF0aC5hdGFuMihhLHApLHRoaXMuX3o9TWF0aC5hdGFuMihsLGMpKToodGhpcy5feT1NYXRoLmF0YW4yKC1kLHMpLHRoaXMuX3o9MCk7YnJlYWs7Y2FzZSJaWFkiOnRoaXMuX3g9TWF0aC5hc2luKGd0KGYsLTEsMSkpLE1hdGguYWJzKGYpPC45OTk5OTk5Pyh0aGlzLl95PU1hdGguYXRhbjIoLWQscCksdGhpcy5fej1NYXRoLmF0YW4yKC1vLGMpKToodGhpcy5feT0wLHRoaXMuX3o9TWF0aC5hdGFuMihsLHMpKTticmVhaztjYXNlIlpZWCI6dGhpcy5feT1NYXRoLmFzaW4oLWd0KGQsLTEsMSkpLE1hdGguYWJzKGQpPC45OTk5OTk5Pyh0aGlzLl94PU1hdGguYXRhbjIoZixwKSx0aGlzLl96PU1hdGguYXRhbjIobCxzKSk6KHRoaXMuX3g9MCx0aGlzLl96PU1hdGguYXRhbjIoLW8sYykpO2JyZWFrO2Nhc2UiWVpYIjp0aGlzLl96PU1hdGguYXNpbihndChsLC0xLDEpKSxNYXRoLmFicyhsKTwuOTk5OTk5OT8odGhpcy5feD1NYXRoLmF0YW4yKC11LGMpLHRoaXMuX3k9TWF0aC5hdGFuMigtZCxzKSk6KHRoaXMuX3g9MCx0aGlzLl95PU1hdGguYXRhbjIoYSxwKSk7YnJlYWs7Y2FzZSJYWlkiOnRoaXMuX3o9TWF0aC5hc2luKC1ndChvLC0xLDEpKSxNYXRoLmFicyhvKTwuOTk5OTk5OT8odGhpcy5feD1NYXRoLmF0YW4yKGYsYyksdGhpcy5feT1NYXRoLmF0YW4yKGEscykpOih0aGlzLl94PU1hdGguYXRhbjIoLXUscCksdGhpcy5feT0wKTticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybigiVEhSRUUuRXVsZXI6IC5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAiK3QpfXJldHVybiB0aGlzLl9vcmRlcj10LGk9PT0hMCYmdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVF1YXRlcm5pb24oZSx0LGkpe3JldHVybiBVci5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihlKSx0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeChVcix0LGkpfXNldEZyb21WZWN0b3IzKGUsdD10aGlzLl9vcmRlcil7cmV0dXJuIHRoaXMuc2V0KGUueCxlLnksZS56LHQpfXJlb3JkZXIoZSl7cmV0dXJuIEZyLnNldEZyb21FdWxlcih0aGlzKSx0aGlzLnNldEZyb21RdWF0ZXJuaW9uKEZyLGUpfWVxdWFscyhlKXtyZXR1cm4gZS5feD09PXRoaXMuX3gmJmUuX3k9PT10aGlzLl95JiZlLl96PT09dGhpcy5feiYmZS5fb3JkZXI9PT10aGlzLl9vcmRlcn1mcm9tQXJyYXkoZSl7cmV0dXJuIHRoaXMuX3g9ZVswXSx0aGlzLl95PWVbMV0sdGhpcy5fej1lWzJdLGVbM10hPT12b2lkIDAmJih0aGlzLl9vcmRlcj1lWzNdKSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc310b0FycmF5KGU9W10sdD0wKXtyZXR1cm4gZVt0XT10aGlzLl94LGVbdCsxXT10aGlzLl95LGVbdCsyXT10aGlzLl96LGVbdCszXT10aGlzLl9vcmRlcixlfV9vbkNoYW5nZShlKXtyZXR1cm4gdGhpcy5fb25DaGFuZ2VDYWxsYmFjaz1lLHRoaXN9X29uQ2hhbmdlQ2FsbGJhY2soKXt9KltTeW1ib2wuaXRlcmF0b3JdKCl7eWllbGQgdGhpcy5feCx5aWVsZCB0aGlzLl95LHlpZWxkIHRoaXMuX3oseWllbGQgdGhpcy5fb3JkZXJ9fVh0LkRFRkFVTFRfT1JERVI9IlhZWiI7Y2xhc3MgSXJ7Y29uc3RydWN0b3IoKXt0aGlzLm1hc2s9MX1zZXQoZSl7dGhpcy5tYXNrPSgxPDxlfDApPj4+MH1lbmFibGUoZSl7dGhpcy5tYXNrfD0xPDxlfDB9ZW5hYmxlQWxsKCl7dGhpcy5tYXNrPS0xfXRvZ2dsZShlKXt0aGlzLm1hc2tePTE8PGV8MH1kaXNhYmxlKGUpe3RoaXMubWFzayY9figxPDxlfDApfWRpc2FibGVBbGwoKXt0aGlzLm1hc2s9MH10ZXN0KGUpe3JldHVybih0aGlzLm1hc2smZS5tYXNrKSE9PTB9aXNFbmFibGVkKGUpe3JldHVybih0aGlzLm1hc2smKDE8PGV8MCkpIT09MH19bGV0IHlhPTA7Y29uc3QgTnI9bmV3IE8sQ249bmV3IFhuLHF0PW5ldyBzdCxkaT1uZXcgTyxLbj1uZXcgTyxUYT1uZXcgTyxBYT1uZXcgWG4sT3I9bmV3IE8oMSwwLDApLEJyPW5ldyBPKDAsMSwwKSx6cj1uZXcgTygwLDAsMSksR3I9e3R5cGU6ImFkZGVkIn0sd2E9e3R5cGU6InJlbW92ZWQifSxQbj17dHlwZToiY2hpbGRhZGRlZCIsY2hpbGQ6bnVsbH0scWk9e3R5cGU6ImNoaWxkcmVtb3ZlZCIsY2hpbGQ6bnVsbH07Y2xhc3MgTXQgZXh0ZW5kcyBNbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5pc09iamVjdDNEPSEwLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJpZCIse3ZhbHVlOnlhKyt9KSx0aGlzLnV1aWQ9U24oKSx0aGlzLm5hbWU9IiIsdGhpcy50eXBlPSJPYmplY3QzRCIsdGhpcy5wYXJlbnQ9bnVsbCx0aGlzLmNoaWxkcmVuPVtdLHRoaXMudXA9TXQuREVGQVVMVF9VUC5jbG9uZSgpO2NvbnN0IGU9bmV3IE8sdD1uZXcgWHQsaT1uZXcgWG4scj1uZXcgTygxLDEsMSk7ZnVuY3Rpb24gcygpe2kuc2V0RnJvbUV1bGVyKHQsITEpfWZ1bmN0aW9uIG8oKXt0LnNldEZyb21RdWF0ZXJuaW9uKGksdm9pZCAwLCExKX10Ll9vbkNoYW5nZShzKSxpLl9vbkNoYW5nZShvKSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLHtwb3NpdGlvbjp7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6ZX0scm90YXRpb246e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOnR9LHF1YXRlcm5pb246e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOml9LHNjYWxlOntjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTpyfSxtb2RlbFZpZXdNYXRyaXg6e3ZhbHVlOm5ldyBzdH0sbm9ybWFsTWF0cml4Ont2YWx1ZTpuZXcgYmV9fSksdGhpcy5tYXRyaXg9bmV3IHN0LHRoaXMubWF0cml4V29ybGQ9bmV3IHN0LHRoaXMubWF0cml4QXV0b1VwZGF0ZT1NdC5ERUZBVUxUX01BVFJJWF9BVVRPX1VQREFURSx0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZT1NdC5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURSx0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITEsdGhpcy5sYXllcnM9bmV3IElyLHRoaXMudmlzaWJsZT0hMCx0aGlzLmNhc3RTaGFkb3c9ITEsdGhpcy5yZWNlaXZlU2hhZG93PSExLHRoaXMuZnJ1c3R1bUN1bGxlZD0hMCx0aGlzLnJlbmRlck9yZGVyPTAsdGhpcy5hbmltYXRpb25zPVtdLHRoaXMudXNlckRhdGE9e319b25CZWZvcmVTaGFkb3coKXt9b25BZnRlclNoYWRvdygpe31vbkJlZm9yZVJlbmRlcigpe31vbkFmdGVyUmVuZGVyKCl7fWFwcGx5TWF0cml4NChlKXt0aGlzLm1hdHJpeEF1dG9VcGRhdGUmJnRoaXMudXBkYXRlTWF0cml4KCksdGhpcy5tYXRyaXgucHJlbXVsdGlwbHkoZSksdGhpcy5tYXRyaXguZGVjb21wb3NlKHRoaXMucG9zaXRpb24sdGhpcy5xdWF0ZXJuaW9uLHRoaXMuc2NhbGUpfWFwcGx5UXVhdGVybmlvbihlKXtyZXR1cm4gdGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KGUpLHRoaXN9c2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlKGUsdCl7dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoZSx0KX1zZXRSb3RhdGlvbkZyb21FdWxlcihlKXt0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKGUsITApfXNldFJvdGF0aW9uRnJvbU1hdHJpeChlKXt0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KGUpfXNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oZSl7dGhpcy5xdWF0ZXJuaW9uLmNvcHkoZSl9cm90YXRlT25BeGlzKGUsdCl7cmV0dXJuIENuLnNldEZyb21BeGlzQW5nbGUoZSx0KSx0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkoQ24pLHRoaXN9cm90YXRlT25Xb3JsZEF4aXMoZSx0KXtyZXR1cm4gQ24uc2V0RnJvbUF4aXNBbmdsZShlLHQpLHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseShDbiksdGhpc31yb3RhdGVYKGUpe3JldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhPcixlKX1yb3RhdGVZKGUpe3JldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhCcixlKX1yb3RhdGVaKGUpe3JldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyh6cixlKX10cmFuc2xhdGVPbkF4aXMoZSx0KXtyZXR1cm4gTnIuY29weShlKS5hcHBseVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKSx0aGlzLnBvc2l0aW9uLmFkZChOci5tdWx0aXBseVNjYWxhcih0KSksdGhpc310cmFuc2xhdGVYKGUpe3JldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhPcixlKX10cmFuc2xhdGVZKGUpe3JldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhCcixlKX10cmFuc2xhdGVaKGUpe3JldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyh6cixlKX1sb2NhbFRvV29ybGQoZSl7cmV0dXJuIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLGUuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpfXdvcmxkVG9Mb2NhbChlKXtyZXR1cm4gdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksZS5hcHBseU1hdHJpeDQocXQuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKSl9bG9va0F0KGUsdCxpKXtlLmlzVmVjdG9yMz9kaS5jb3B5KGUpOmRpLnNldChlLHQsaSk7Y29uc3Qgcj10aGlzLnBhcmVudDt0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxLbi5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5tYXRyaXhXb3JsZCksdGhpcy5pc0NhbWVyYXx8dGhpcy5pc0xpZ2h0P3F0Lmxvb2tBdChLbixkaSx0aGlzLnVwKTpxdC5sb29rQXQoZGksS24sdGhpcy51cCksdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChxdCksciYmKHF0LmV4dHJhY3RSb3RhdGlvbihyLm1hdHJpeFdvcmxkKSxDbi5zZXRGcm9tUm90YXRpb25NYXRyaXgocXQpLHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseShDbi5pbnZlcnQoKSkpfWFkZChlKXtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2ZvcihsZXQgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspdGhpcy5hZGQoYXJndW1lbnRzW3RdKTtyZXR1cm4gdGhpc31yZXR1cm4gZT09PXRoaXM/KGNvbnNvbGUuZXJyb3IoIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhbid0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLiIsZSksdGhpcyk6KGUmJmUuaXNPYmplY3QzRD8oZS5yZW1vdmVGcm9tUGFyZW50KCksZS5wYXJlbnQ9dGhpcyx0aGlzLmNoaWxkcmVuLnB1c2goZSksZS5kaXNwYXRjaEV2ZW50KEdyKSxQbi5jaGlsZD1lLHRoaXMuZGlzcGF0Y2hFdmVudChQbiksUG4uY2hpbGQ9bnVsbCk6Y29uc29sZS5lcnJvcigiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3Qgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk9iamVjdDNELiIsZSksdGhpcyl9cmVtb3ZlKGUpe2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKGxldCBpPTA7aTxhcmd1bWVudHMubGVuZ3RoO2krKyl0aGlzLnJlbW92ZShhcmd1bWVudHNbaV0pO3JldHVybiB0aGlzfWNvbnN0IHQ9dGhpcy5jaGlsZHJlbi5pbmRleE9mKGUpO3JldHVybiB0IT09LTEmJihlLnBhcmVudD1udWxsLHRoaXMuY2hpbGRyZW4uc3BsaWNlKHQsMSksZS5kaXNwYXRjaEV2ZW50KHdhKSxxaS5jaGlsZD1lLHRoaXMuZGlzcGF0Y2hFdmVudChxaSkscWkuY2hpbGQ9bnVsbCksdGhpc31yZW1vdmVGcm9tUGFyZW50KCl7Y29uc3QgZT10aGlzLnBhcmVudDtyZXR1cm4gZSE9PW51bGwmJmUucmVtb3ZlKHRoaXMpLHRoaXN9Y2xlYXIoKXtyZXR1cm4gdGhpcy5yZW1vdmUoLi4udGhpcy5jaGlsZHJlbil9YXR0YWNoKGUpe3JldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxxdC5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpLGUucGFyZW50IT09bnVsbCYmKGUucGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxxdC5tdWx0aXBseShlLnBhcmVudC5tYXRyaXhXb3JsZCkpLGUuYXBwbHlNYXRyaXg0KHF0KSxlLnJlbW92ZUZyb21QYXJlbnQoKSxlLnBhcmVudD10aGlzLHRoaXMuY2hpbGRyZW4ucHVzaChlKSxlLnVwZGF0ZVdvcmxkTWF0cml4KCExLCEwKSxlLmRpc3BhdGNoRXZlbnQoR3IpLFBuLmNoaWxkPWUsdGhpcy5kaXNwYXRjaEV2ZW50KFBuKSxQbi5jaGlsZD1udWxsLHRoaXN9Z2V0T2JqZWN0QnlJZChlKXtyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCJpZCIsZSl9Z2V0T2JqZWN0QnlOYW1lKGUpe3JldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoIm5hbWUiLGUpfWdldE9iamVjdEJ5UHJvcGVydHkoZSx0KXtpZih0aGlzW2VdPT09dClyZXR1cm4gdGhpcztmb3IobGV0IGk9MCxyPXRoaXMuY2hpbGRyZW4ubGVuZ3RoO2k8cjtpKyspe2NvbnN0IG89dGhpcy5jaGlsZHJlbltpXS5nZXRPYmplY3RCeVByb3BlcnR5KGUsdCk7aWYobyE9PXZvaWQgMClyZXR1cm4gb319Z2V0T2JqZWN0c0J5UHJvcGVydHkoZSx0LGk9W10pe3RoaXNbZV09PT10JiZpLnB1c2godGhpcyk7Y29uc3Qgcj10aGlzLmNoaWxkcmVuO2ZvcihsZXQgcz0wLG89ci5sZW5ndGg7czxvO3MrKylyW3NdLmdldE9iamVjdHNCeVByb3BlcnR5KGUsdCxpKTtyZXR1cm4gaX1nZXRXb3JsZFBvc2l0aW9uKGUpe3JldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxlLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1hdHJpeFdvcmxkKX1nZXRXb3JsZFF1YXRlcm5pb24oZSl7cmV0dXJuIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKEtuLGUsVGEpLGV9Z2V0V29ybGRTY2FsZShlKXtyZXR1cm4gdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoS24sQWEsZSksZX1nZXRXb3JsZERpcmVjdGlvbihlKXt0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKTtjb25zdCB0PXRoaXMubWF0cml4V29ybGQuZWxlbWVudHM7cmV0dXJuIGUuc2V0KHRbOF0sdFs5XSx0WzEwXSkubm9ybWFsaXplKCl9cmF5Y2FzdCgpe310cmF2ZXJzZShlKXtlKHRoaXMpO2NvbnN0IHQ9dGhpcy5jaGlsZHJlbjtmb3IobGV0IGk9MCxyPXQubGVuZ3RoO2k8cjtpKyspdFtpXS50cmF2ZXJzZShlKX10cmF2ZXJzZVZpc2libGUoZSl7aWYodGhpcy52aXNpYmxlPT09ITEpcmV0dXJuO2UodGhpcyk7Y29uc3QgdD10aGlzLmNoaWxkcmVuO2ZvcihsZXQgaT0wLHI9dC5sZW5ndGg7aTxyO2krKyl0W2ldLnRyYXZlcnNlVmlzaWJsZShlKX10cmF2ZXJzZUFuY2VzdG9ycyhlKXtjb25zdCB0PXRoaXMucGFyZW50O3QhPT1udWxsJiYoZSh0KSx0LnRyYXZlcnNlQW5jZXN0b3JzKGUpKX11cGRhdGVNYXRyaXgoKXt0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sdGhpcy5xdWF0ZXJuaW9uLHRoaXMuc2NhbGUpLHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMH11cGRhdGVNYXRyaXhXb3JsZChlKXt0aGlzLm1hdHJpeEF1dG9VcGRhdGUmJnRoaXMudXBkYXRlTWF0cml4KCksKHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZXx8ZSkmJih0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZT09PSEwJiYodGhpcy5wYXJlbnQ9PT1udWxsP3RoaXMubWF0cml4V29ybGQuY29weSh0aGlzLm1hdHJpeCk6dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLHRoaXMubWF0cml4KSksdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSExLGU9ITApO2NvbnN0IHQ9dGhpcy5jaGlsZHJlbjtmb3IobGV0IGk9MCxyPXQubGVuZ3RoO2k8cjtpKyspdFtpXS51cGRhdGVNYXRyaXhXb3JsZChlKX11cGRhdGVXb3JsZE1hdHJpeChlLHQpe2NvbnN0IGk9dGhpcy5wYXJlbnQ7aWYoZT09PSEwJiZpIT09bnVsbCYmaS51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksdGhpcy5tYXRyaXhBdXRvVXBkYXRlJiZ0aGlzLnVwZGF0ZU1hdHJpeCgpLHRoaXMubWF0cml4V29ybGRBdXRvVXBkYXRlPT09ITAmJih0aGlzLnBhcmVudD09PW51bGw/dGhpcy5tYXRyaXhXb3JsZC5jb3B5KHRoaXMubWF0cml4KTp0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXModGhpcy5wYXJlbnQubWF0cml4V29ybGQsdGhpcy5tYXRyaXgpKSx0PT09ITApe2NvbnN0IHI9dGhpcy5jaGlsZHJlbjtmb3IobGV0IHM9MCxvPXIubGVuZ3RoO3M8bztzKyspcltzXS51cGRhdGVXb3JsZE1hdHJpeCghMSwhMCl9fXRvSlNPTihlKXtjb25zdCB0PWU9PT12b2lkIDB8fHR5cGVvZiBlPT0ic3RyaW5nIixpPXt9O3QmJihlPXtnZW9tZXRyaWVzOnt9LG1hdGVyaWFsczp7fSx0ZXh0dXJlczp7fSxpbWFnZXM6e30sc2hhcGVzOnt9LHNrZWxldG9uczp7fSxhbmltYXRpb25zOnt9LG5vZGVzOnt9fSxpLm1ldGFkYXRhPXt2ZXJzaW9uOjQuNix0eXBlOiJPYmplY3QiLGdlbmVyYXRvcjoiT2JqZWN0M0QudG9KU09OIn0pO2NvbnN0IHI9e307ci51dWlkPXRoaXMudXVpZCxyLnR5cGU9dGhpcy50eXBlLHRoaXMubmFtZSE9PSIiJiYoci5uYW1lPXRoaXMubmFtZSksdGhpcy5jYXN0U2hhZG93PT09ITAmJihyLmNhc3RTaGFkb3c9ITApLHRoaXMucmVjZWl2ZVNoYWRvdz09PSEwJiYoci5yZWNlaXZlU2hhZG93PSEwKSx0aGlzLnZpc2libGU9PT0hMSYmKHIudmlzaWJsZT0hMSksdGhpcy5mcnVzdHVtQ3VsbGVkPT09ITEmJihyLmZydXN0dW1DdWxsZWQ9ITEpLHRoaXMucmVuZGVyT3JkZXIhPT0wJiYoci5yZW5kZXJPcmRlcj10aGlzLnJlbmRlck9yZGVyKSxPYmplY3Qua2V5cyh0aGlzLnVzZXJEYXRhKS5sZW5ndGg+MCYmKHIudXNlckRhdGE9dGhpcy51c2VyRGF0YSksci5sYXllcnM9dGhpcy5sYXllcnMubWFzayxyLm1hdHJpeD10aGlzLm1hdHJpeC50b0FycmF5KCksci51cD10aGlzLnVwLnRvQXJyYXkoKSx0aGlzLm1hdHJpeEF1dG9VcGRhdGU9PT0hMSYmKHIubWF0cml4QXV0b1VwZGF0ZT0hMSksdGhpcy5pc0luc3RhbmNlZE1lc2gmJihyLnR5cGU9Ikluc3RhbmNlZE1lc2giLHIuY291bnQ9dGhpcy5jb3VudCxyLmluc3RhbmNlTWF0cml4PXRoaXMuaW5zdGFuY2VNYXRyaXgudG9KU09OKCksdGhpcy5pbnN0YW5jZUNvbG9yIT09bnVsbCYmKHIuaW5zdGFuY2VDb2xvcj10aGlzLmluc3RhbmNlQ29sb3IudG9KU09OKCkpKSx0aGlzLmlzQmF0Y2hlZE1lc2gmJihyLnR5cGU9IkJhdGNoZWRNZXNoIixyLnBlck9iamVjdEZydXN0dW1DdWxsZWQ9dGhpcy5wZXJPYmplY3RGcnVzdHVtQ3VsbGVkLHIuc29ydE9iamVjdHM9dGhpcy5zb3J0T2JqZWN0cyxyLmRyYXdSYW5nZXM9dGhpcy5fZHJhd1JhbmdlcyxyLnJlc2VydmVkUmFuZ2VzPXRoaXMuX3Jlc2VydmVkUmFuZ2VzLHIudmlzaWJpbGl0eT10aGlzLl92aXNpYmlsaXR5LHIuYWN0aXZlPXRoaXMuX2FjdGl2ZSxyLmJvdW5kcz10aGlzLl9ib3VuZHMubWFwKGE9Pih7Ym94SW5pdGlhbGl6ZWQ6YS5ib3hJbml0aWFsaXplZCxib3hNaW46YS5ib3gubWluLnRvQXJyYXkoKSxib3hNYXg6YS5ib3gubWF4LnRvQXJyYXkoKSxzcGhlcmVJbml0aWFsaXplZDphLnNwaGVyZUluaXRpYWxpemVkLHNwaGVyZVJhZGl1czphLnNwaGVyZS5yYWRpdXMsc3BoZXJlQ2VudGVyOmEuc3BoZXJlLmNlbnRlci50b0FycmF5KCl9KSksci5tYXhJbnN0YW5jZUNvdW50PXRoaXMuX21heEluc3RhbmNlQ291bnQsci5tYXhWZXJ0ZXhDb3VudD10aGlzLl9tYXhWZXJ0ZXhDb3VudCxyLm1heEluZGV4Q291bnQ9dGhpcy5fbWF4SW5kZXhDb3VudCxyLmdlb21ldHJ5SW5pdGlhbGl6ZWQ9dGhpcy5fZ2VvbWV0cnlJbml0aWFsaXplZCxyLmdlb21ldHJ5Q291bnQ9dGhpcy5fZ2VvbWV0cnlDb3VudCxyLm1hdHJpY2VzVGV4dHVyZT10aGlzLl9tYXRyaWNlc1RleHR1cmUudG9KU09OKGUpLHRoaXMuX2NvbG9yc1RleHR1cmUhPT1udWxsJiYoci5jb2xvcnNUZXh0dXJlPXRoaXMuX2NvbG9yc1RleHR1cmUudG9KU09OKGUpKSx0aGlzLmJvdW5kaW5nU3BoZXJlIT09bnVsbCYmKHIuYm91bmRpbmdTcGhlcmU9e2NlbnRlcjpyLmJvdW5kaW5nU3BoZXJlLmNlbnRlci50b0FycmF5KCkscmFkaXVzOnIuYm91bmRpbmdTcGhlcmUucmFkaXVzfSksdGhpcy5ib3VuZGluZ0JveCE9PW51bGwmJihyLmJvdW5kaW5nQm94PXttaW46ci5ib3VuZGluZ0JveC5taW4udG9BcnJheSgpLG1heDpyLmJvdW5kaW5nQm94Lm1heC50b0FycmF5KCl9KSk7ZnVuY3Rpb24gcyhhLGwpe3JldHVybiBhW2wudXVpZF09PT12b2lkIDAmJihhW2wudXVpZF09bC50b0pTT04oZSkpLGwudXVpZH1pZih0aGlzLmlzU2NlbmUpdGhpcy5iYWNrZ3JvdW5kJiYodGhpcy5iYWNrZ3JvdW5kLmlzQ29sb3I/ci5iYWNrZ3JvdW5kPXRoaXMuYmFja2dyb3VuZC50b0pTT04oKTp0aGlzLmJhY2tncm91bmQuaXNUZXh0dXJlJiYoci5iYWNrZ3JvdW5kPXRoaXMuYmFja2dyb3VuZC50b0pTT04oZSkudXVpZCkpLHRoaXMuZW52aXJvbm1lbnQmJnRoaXMuZW52aXJvbm1lbnQuaXNUZXh0dXJlJiZ0aGlzLmVudmlyb25tZW50LmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSE9PSEwJiYoci5lbnZpcm9ubWVudD10aGlzLmVudmlyb25tZW50LnRvSlNPTihlKS51dWlkKTtlbHNlIGlmKHRoaXMuaXNNZXNofHx0aGlzLmlzTGluZXx8dGhpcy5pc1BvaW50cyl7ci5nZW9tZXRyeT1zKGUuZ2VvbWV0cmllcyx0aGlzLmdlb21ldHJ5KTtjb25zdCBhPXRoaXMuZ2VvbWV0cnkucGFyYW1ldGVycztpZihhIT09dm9pZCAwJiZhLnNoYXBlcyE9PXZvaWQgMCl7Y29uc3QgbD1hLnNoYXBlcztpZihBcnJheS5pc0FycmF5KGwpKWZvcihsZXQgYz0wLHU9bC5sZW5ndGg7Yzx1O2MrKyl7Y29uc3QgZD1sW2NdO3MoZS5zaGFwZXMsZCl9ZWxzZSBzKGUuc2hhcGVzLGwpfX1pZih0aGlzLmlzU2tpbm5lZE1lc2gmJihyLmJpbmRNb2RlPXRoaXMuYmluZE1vZGUsci5iaW5kTWF0cml4PXRoaXMuYmluZE1hdHJpeC50b0FycmF5KCksdGhpcy5za2VsZXRvbiE9PXZvaWQgMCYmKHMoZS5za2VsZXRvbnMsdGhpcy5za2VsZXRvbiksci5za2VsZXRvbj10aGlzLnNrZWxldG9uLnV1aWQpKSx0aGlzLm1hdGVyaWFsIT09dm9pZCAwKWlmKEFycmF5LmlzQXJyYXkodGhpcy5tYXRlcmlhbCkpe2NvbnN0IGE9W107Zm9yKGxldCBsPTAsYz10aGlzLm1hdGVyaWFsLmxlbmd0aDtsPGM7bCsrKWEucHVzaChzKGUubWF0ZXJpYWxzLHRoaXMubWF0ZXJpYWxbbF0pKTtyLm1hdGVyaWFsPWF9ZWxzZSByLm1hdGVyaWFsPXMoZS5tYXRlcmlhbHMsdGhpcy5tYXRlcmlhbCk7aWYodGhpcy5jaGlsZHJlbi5sZW5ndGg+MCl7ci5jaGlsZHJlbj1bXTtmb3IobGV0IGE9MDthPHRoaXMuY2hpbGRyZW4ubGVuZ3RoO2ErKylyLmNoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlblthXS50b0pTT04oZSkub2JqZWN0KX1pZih0aGlzLmFuaW1hdGlvbnMubGVuZ3RoPjApe3IuYW5pbWF0aW9ucz1bXTtmb3IobGV0IGE9MDthPHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7YSsrKXtjb25zdCBsPXRoaXMuYW5pbWF0aW9uc1thXTtyLmFuaW1hdGlvbnMucHVzaChzKGUuYW5pbWF0aW9ucyxsKSl9fWlmKHQpe2NvbnN0IGE9byhlLmdlb21ldHJpZXMpLGw9byhlLm1hdGVyaWFscyksYz1vKGUudGV4dHVyZXMpLHU9byhlLmltYWdlcyksZD1vKGUuc2hhcGVzKSxmPW8oZS5za2VsZXRvbnMpLHA9byhlLmFuaW1hdGlvbnMpLGc9byhlLm5vZGVzKTthLmxlbmd0aD4wJiYoaS5nZW9tZXRyaWVzPWEpLGwubGVuZ3RoPjAmJihpLm1hdGVyaWFscz1sKSxjLmxlbmd0aD4wJiYoaS50ZXh0dXJlcz1jKSx1Lmxlbmd0aD4wJiYoaS5pbWFnZXM9dSksZC5sZW5ndGg+MCYmKGkuc2hhcGVzPWQpLGYubGVuZ3RoPjAmJihpLnNrZWxldG9ucz1mKSxwLmxlbmd0aD4wJiYoaS5hbmltYXRpb25zPXApLGcubGVuZ3RoPjAmJihpLm5vZGVzPWcpfXJldHVybiBpLm9iamVjdD1yLGk7ZnVuY3Rpb24gbyhhKXtjb25zdCBsPVtdO2Zvcihjb25zdCBjIGluIGEpe2NvbnN0IHU9YVtjXTtkZWxldGUgdS5tZXRhZGF0YSxsLnB1c2godSl9cmV0dXJuIGx9fWNsb25lKGUpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyxlKX1jb3B5KGUsdD0hMCl7aWYodGhpcy5uYW1lPWUubmFtZSx0aGlzLnVwLmNvcHkoZS51cCksdGhpcy5wb3NpdGlvbi5jb3B5KGUucG9zaXRpb24pLHRoaXMucm90YXRpb24ub3JkZXI9ZS5yb3RhdGlvbi5vcmRlcix0aGlzLnF1YXRlcm5pb24uY29weShlLnF1YXRlcm5pb24pLHRoaXMuc2NhbGUuY29weShlLnNjYWxlKSx0aGlzLm1hdHJpeC5jb3B5KGUubWF0cml4KSx0aGlzLm1hdHJpeFdvcmxkLmNvcHkoZS5tYXRyaXhXb3JsZCksdGhpcy5tYXRyaXhBdXRvVXBkYXRlPWUubWF0cml4QXV0b1VwZGF0ZSx0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZT1lLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSx0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlLHRoaXMubGF5ZXJzLm1hc2s9ZS5sYXllcnMubWFzayx0aGlzLnZpc2libGU9ZS52aXNpYmxlLHRoaXMuY2FzdFNoYWRvdz1lLmNhc3RTaGFkb3csdGhpcy5yZWNlaXZlU2hhZG93PWUucmVjZWl2ZVNoYWRvdyx0aGlzLmZydXN0dW1DdWxsZWQ9ZS5mcnVzdHVtQ3VsbGVkLHRoaXMucmVuZGVyT3JkZXI9ZS5yZW5kZXJPcmRlcix0aGlzLmFuaW1hdGlvbnM9ZS5hbmltYXRpb25zLnNsaWNlKCksdGhpcy51c2VyRGF0YT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGUudXNlckRhdGEpKSx0PT09ITApZm9yKGxldCBpPTA7aTxlLmNoaWxkcmVuLmxlbmd0aDtpKyspe2NvbnN0IHI9ZS5jaGlsZHJlbltpXTt0aGlzLmFkZChyLmNsb25lKCkpfXJldHVybiB0aGlzfX1NdC5ERUZBVUxUX1VQPW5ldyBPKDAsMSwwKSxNdC5ERUZBVUxUX01BVFJJWF9BVVRPX1VQREFURT0hMCxNdC5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURT0hMDtjb25zdCBGdD1uZXcgTyxZdD1uZXcgTyxZaT1uZXcgTywkdD1uZXcgTyxEbj1uZXcgTyxMbj1uZXcgTyxIcj1uZXcgTywkaT1uZXcgTyxLaT1uZXcgTyxaaT1uZXcgTyxqaT1uZXcgcnQsSmk9bmV3IHJ0LFFpPW5ldyBydDtjbGFzcyBJdHtjb25zdHJ1Y3RvcihlPW5ldyBPLHQ9bmV3IE8saT1uZXcgTyl7dGhpcy5hPWUsdGhpcy5iPXQsdGhpcy5jPWl9c3RhdGljIGdldE5vcm1hbChlLHQsaSxyKXtyLnN1YlZlY3RvcnMoaSx0KSxGdC5zdWJWZWN0b3JzKGUsdCksci5jcm9zcyhGdCk7Y29uc3Qgcz1yLmxlbmd0aFNxKCk7cmV0dXJuIHM+MD9yLm11bHRpcGx5U2NhbGFyKDEvTWF0aC5zcXJ0KHMpKTpyLnNldCgwLDAsMCl9c3RhdGljIGdldEJhcnljb29yZChlLHQsaSxyLHMpe0Z0LnN1YlZlY3RvcnMocix0KSxZdC5zdWJWZWN0b3JzKGksdCksWWkuc3ViVmVjdG9ycyhlLHQpO2NvbnN0IG89RnQuZG90KEZ0KSxhPUZ0LmRvdChZdCksbD1GdC5kb3QoWWkpLGM9WXQuZG90KFl0KSx1PVl0LmRvdChZaSksZD1vKmMtYSphO2lmKGQ9PT0wKXJldHVybiBzLnNldCgwLDAsMCksbnVsbDtjb25zdCBmPTEvZCxwPShjKmwtYSp1KSpmLGc9KG8qdS1hKmwpKmY7cmV0dXJuIHMuc2V0KDEtcC1nLGcscCl9c3RhdGljIGNvbnRhaW5zUG9pbnQoZSx0LGkscil7cmV0dXJuIHRoaXMuZ2V0QmFyeWNvb3JkKGUsdCxpLHIsJHQpPT09bnVsbD8hMTokdC54Pj0wJiYkdC55Pj0wJiYkdC54KyR0Lnk8PTF9c3RhdGljIGdldEludGVycG9sYXRpb24oZSx0LGkscixzLG8sYSxsKXtyZXR1cm4gdGhpcy5nZXRCYXJ5Y29vcmQoZSx0LGksciwkdCk9PT1udWxsPyhsLng9MCxsLnk9MCwieiJpbiBsJiYobC56PTApLCJ3ImluIGwmJihsLnc9MCksbnVsbCk6KGwuc2V0U2NhbGFyKDApLGwuYWRkU2NhbGVkVmVjdG9yKHMsJHQueCksbC5hZGRTY2FsZWRWZWN0b3IobywkdC55KSxsLmFkZFNjYWxlZFZlY3RvcihhLCR0LnopLGwpfXN0YXRpYyBnZXRJbnRlcnBvbGF0ZWRBdHRyaWJ1dGUoZSx0LGkscixzLG8pe3JldHVybiBqaS5zZXRTY2FsYXIoMCksSmkuc2V0U2NhbGFyKDApLFFpLnNldFNjYWxhcigwKSxqaS5mcm9tQnVmZmVyQXR0cmlidXRlKGUsdCksSmkuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLGkpLFFpLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSxyKSxvLnNldFNjYWxhcigwKSxvLmFkZFNjYWxlZFZlY3RvcihqaSxzLngpLG8uYWRkU2NhbGVkVmVjdG9yKEppLHMueSksby5hZGRTY2FsZWRWZWN0b3IoUWkscy56KSxvfXN0YXRpYyBpc0Zyb250RmFjaW5nKGUsdCxpLHIpe3JldHVybiBGdC5zdWJWZWN0b3JzKGksdCksWXQuc3ViVmVjdG9ycyhlLHQpLEZ0LmNyb3NzKFl0KS5kb3Qocik8MH1zZXQoZSx0LGkpe3JldHVybiB0aGlzLmEuY29weShlKSx0aGlzLmIuY29weSh0KSx0aGlzLmMuY29weShpKSx0aGlzfXNldEZyb21Qb2ludHNBbmRJbmRpY2VzKGUsdCxpLHIpe3JldHVybiB0aGlzLmEuY29weShlW3RdKSx0aGlzLmIuY29weShlW2ldKSx0aGlzLmMuY29weShlW3JdKSx0aGlzfXNldEZyb21BdHRyaWJ1dGVBbmRJbmRpY2VzKGUsdCxpLHIpe3JldHVybiB0aGlzLmEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHQpLHRoaXMuYi5mcm9tQnVmZmVyQXR0cmlidXRlKGUsaSksdGhpcy5jLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSxyKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX1jb3B5KGUpe3JldHVybiB0aGlzLmEuY29weShlLmEpLHRoaXMuYi5jb3B5KGUuYiksdGhpcy5jLmNvcHkoZS5jKSx0aGlzfWdldEFyZWEoKXtyZXR1cm4gRnQuc3ViVmVjdG9ycyh0aGlzLmMsdGhpcy5iKSxZdC5zdWJWZWN0b3JzKHRoaXMuYSx0aGlzLmIpLEZ0LmNyb3NzKFl0KS5sZW5ndGgoKSouNX1nZXRNaWRwb2ludChlKXtyZXR1cm4gZS5hZGRWZWN0b3JzKHRoaXMuYSx0aGlzLmIpLmFkZCh0aGlzLmMpLm11bHRpcGx5U2NhbGFyKDEvMyl9Z2V0Tm9ybWFsKGUpe3JldHVybiBJdC5nZXROb3JtYWwodGhpcy5hLHRoaXMuYix0aGlzLmMsZSl9Z2V0UGxhbmUoZSl7cmV0dXJuIGUuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKHRoaXMuYSx0aGlzLmIsdGhpcy5jKX1nZXRCYXJ5Y29vcmQoZSx0KXtyZXR1cm4gSXQuZ2V0QmFyeWNvb3JkKGUsdGhpcy5hLHRoaXMuYix0aGlzLmMsdCl9Z2V0SW50ZXJwb2xhdGlvbihlLHQsaSxyLHMpe3JldHVybiBJdC5nZXRJbnRlcnBvbGF0aW9uKGUsdGhpcy5hLHRoaXMuYix0aGlzLmMsdCxpLHIscyl9Y29udGFpbnNQb2ludChlKXtyZXR1cm4gSXQuY29udGFpbnNQb2ludChlLHRoaXMuYSx0aGlzLmIsdGhpcy5jKX1pc0Zyb250RmFjaW5nKGUpe3JldHVybiBJdC5pc0Zyb250RmFjaW5nKHRoaXMuYSx0aGlzLmIsdGhpcy5jLGUpfWludGVyc2VjdHNCb3goZSl7cmV0dXJuIGUuaW50ZXJzZWN0c1RyaWFuZ2xlKHRoaXMpfWNsb3Nlc3RQb2ludFRvUG9pbnQoZSx0KXtjb25zdCBpPXRoaXMuYSxyPXRoaXMuYixzPXRoaXMuYztsZXQgbyxhO0RuLnN1YlZlY3RvcnMocixpKSxMbi5zdWJWZWN0b3JzKHMsaSksJGkuc3ViVmVjdG9ycyhlLGkpO2NvbnN0IGw9RG4uZG90KCRpKSxjPUxuLmRvdCgkaSk7aWYobDw9MCYmYzw9MClyZXR1cm4gdC5jb3B5KGkpO0tpLnN1YlZlY3RvcnMoZSxyKTtjb25zdCB1PURuLmRvdChLaSksZD1Mbi5kb3QoS2kpO2lmKHU+PTAmJmQ8PXUpcmV0dXJuIHQuY29weShyKTtjb25zdCBmPWwqZC11KmM7aWYoZjw9MCYmbD49MCYmdTw9MClyZXR1cm4gbz1sLyhsLXUpLHQuY29weShpKS5hZGRTY2FsZWRWZWN0b3IoRG4sbyk7Wmkuc3ViVmVjdG9ycyhlLHMpO2NvbnN0IHA9RG4uZG90KFppKSxnPUxuLmRvdChaaSk7aWYoZz49MCYmcDw9ZylyZXR1cm4gdC5jb3B5KHMpO2NvbnN0IHg9cCpjLWwqZztpZih4PD0wJiZjPj0wJiZnPD0wKXJldHVybiBhPWMvKGMtZyksdC5jb3B5KGkpLmFkZFNjYWxlZFZlY3RvcihMbixhKTtjb25zdCBtPXUqZy1wKmQ7aWYobTw9MCYmZC11Pj0wJiZwLWc+PTApcmV0dXJuIEhyLnN1YlZlY3RvcnMocyxyKSxhPShkLXUpLyhkLXUrKHAtZykpLHQuY29weShyKS5hZGRTY2FsZWRWZWN0b3IoSHIsYSk7Y29uc3QgaD0xLyhtK3grZik7cmV0dXJuIG89eCpoLGE9ZipoLHQuY29weShpKS5hZGRTY2FsZWRWZWN0b3IoRG4sbykuYWRkU2NhbGVkVmVjdG9yKExuLGEpfWVxdWFscyhlKXtyZXR1cm4gZS5hLmVxdWFscyh0aGlzLmEpJiZlLmIuZXF1YWxzKHRoaXMuYikmJmUuYy5lcXVhbHModGhpcy5jKX19Y29uc3QgVnI9e2FsaWNlYmx1ZToxNTc5MjM4MyxhbnRpcXVld2hpdGU6MTY0NDQzNzUsYXF1YTo2NTUzNSxhcXVhbWFyaW5lOjgzODg1NjQsYXp1cmU6MTU3OTQxNzUsYmVpZ2U6MTYxMTkyNjAsYmlzcXVlOjE2NzcwMjQ0LGJsYWNrOjAsYmxhbmNoZWRhbG1vbmQ6MTY3NzIwNDUsYmx1ZToyNTUsYmx1ZXZpb2xldDo5MDU1MjAyLGJyb3duOjEwODI0MjM0LGJ1cmx5d29vZDoxNDU5NjIzMSxjYWRldGJsdWU6NjI2NjUyOCxjaGFydHJldXNlOjgzODgzNTIsY2hvY29sYXRlOjEzNzg5NDcwLGNvcmFsOjE2NzQ0MjcyLGNvcm5mbG93ZXJibHVlOjY1OTE5ODEsY29ybnNpbGs6MTY3NzUzODgsY3JpbXNvbjoxNDQyMzEwMCxjeWFuOjY1NTM1LGRhcmtibHVlOjEzOSxkYXJrY3lhbjozNTcyMyxkYXJrZ29sZGVucm9kOjEyMDkyOTM5LGRhcmtncmF5OjExMTE5MDE3LGRhcmtncmVlbjoyNTYwMCxkYXJrZ3JleToxMTExOTAxNyxkYXJra2hha2k6MTI0MzMyNTksZGFya21hZ2VudGE6OTEwOTY0MyxkYXJrb2xpdmVncmVlbjo1NTk3OTk5LGRhcmtvcmFuZ2U6MTY3NDc1MjAsZGFya29yY2hpZDoxMDA0MDAxMixkYXJrcmVkOjkxMDk1MDQsZGFya3NhbG1vbjoxNTMwODQxMCxkYXJrc2VhZ3JlZW46OTQxOTkxOSxkYXJrc2xhdGVibHVlOjQ3MzQzNDcsZGFya3NsYXRlZ3JheTozMTAwNDk1LGRhcmtzbGF0ZWdyZXk6MzEwMDQ5NSxkYXJrdHVycXVvaXNlOjUyOTQ1LGRhcmt2aW9sZXQ6OTY5OTUzOSxkZWVwcGluazoxNjcxNjk0NyxkZWVwc2t5Ymx1ZTo0OTE1MSxkaW1ncmF5OjY5MDgyNjUsZGltZ3JleTo2OTA4MjY1LGRvZGdlcmJsdWU6MjAwMzE5OSxmaXJlYnJpY2s6MTE2NzQxNDYsZmxvcmFsd2hpdGU6MTY3NzU5MjAsZm9yZXN0Z3JlZW46MjI2Mzg0MixmdWNoc2lhOjE2NzExOTM1LGdhaW5zYm9ybzoxNDQ3NDQ2MCxnaG9zdHdoaXRlOjE2MzE2NjcxLGdvbGQ6MTY3NjY3MjAsZ29sZGVucm9kOjE0MzI5MTIwLGdyYXk6ODQyMTUwNCxncmVlbjozMjc2OCxncmVlbnllbGxvdzoxMTQwMzA1NSxncmV5Ojg0MjE1MDQsaG9uZXlkZXc6MTU3OTQxNjAsaG90cGluazoxNjczODc0MCxpbmRpYW5yZWQ6MTM0NTg1MjQsaW5kaWdvOjQ5MTUzMzAsaXZvcnk6MTY3NzcyMDAsa2hha2k6MTU3ODc2NjAsbGF2ZW5kZXI6MTUxMzI0MTAsbGF2ZW5kZXJibHVzaDoxNjc3MzM2NSxsYXduZ3JlZW46ODE5MDk3NixsZW1vbmNoaWZmb246MTY3NzU4ODUsbGlnaHRibHVlOjExMzkzMjU0LGxpZ2h0Y29yYWw6MTU3NjE1MzYsbGlnaHRjeWFuOjE0NzQ1NTk5LGxpZ2h0Z29sZGVucm9keWVsbG93OjE2NDQ4MjEwLGxpZ2h0Z3JheToxMzg4MjMyMyxsaWdodGdyZWVuOjk0OTgyNTYsbGlnaHRncmV5OjEzODgyMzIzLGxpZ2h0cGluazoxNjc1ODQ2NSxsaWdodHNhbG1vbjoxNjc1Mjc2MixsaWdodHNlYWdyZWVuOjIxNDI4OTAsbGlnaHRza3libHVlOjg5MDAzNDYsbGlnaHRzbGF0ZWdyYXk6NzgzMzc1MyxsaWdodHNsYXRlZ3JleTo3ODMzNzUzLGxpZ2h0c3RlZWxibHVlOjExNTg0NzM0LGxpZ2h0eWVsbG93OjE2Nzc3MTg0LGxpbWU6NjUyODAsbGltZWdyZWVuOjMzMjkzMzAsbGluZW46MTY0NDU2NzAsbWFnZW50YToxNjcxMTkzNSxtYXJvb246ODM4ODYwOCxtZWRpdW1hcXVhbWFyaW5lOjY3MzczMjIsbWVkaXVtYmx1ZToyMDUsbWVkaXVtb3JjaGlkOjEyMjExNjY3LG1lZGl1bXB1cnBsZTo5NjYyNjgzLG1lZGl1bXNlYWdyZWVuOjM5NzgwOTcsbWVkaXVtc2xhdGVibHVlOjgwODc3OTAsbWVkaXVtc3ByaW5nZ3JlZW46NjQxNTQsbWVkaXVtdHVycXVvaXNlOjQ3NzIzMDAsbWVkaXVtdmlvbGV0cmVkOjEzMDQ3MTczLG1pZG5pZ2h0Ymx1ZToxNjQ0OTEyLG1pbnRjcmVhbToxNjEyMTg1MCxtaXN0eXJvc2U6MTY3NzAyNzMsbW9jY2FzaW46MTY3NzAyMjksbmF2YWpvd2hpdGU6MTY3Njg2ODUsbmF2eToxMjgsb2xkbGFjZToxNjY0MzU1OCxvbGl2ZTo4NDIxMzc2LG9saXZlZHJhYjo3MDQ4NzM5LG9yYW5nZToxNjc1MzkyMCxvcmFuZ2VyZWQ6MTY3MjkzNDQsb3JjaGlkOjE0MzE1NzM0LHBhbGVnb2xkZW5yb2Q6MTU2NTcxMzAscGFsZWdyZWVuOjEwMDI1ODgwLHBhbGV0dXJxdW9pc2U6MTE1Mjk5NjYscGFsZXZpb2xldHJlZDoxNDM4MTIwMyxwYXBheWF3aGlwOjE2NzczMDc3LHBlYWNocHVmZjoxNjc2NzY3MyxwZXJ1OjEzNDY4OTkxLHBpbms6MTY3NjEwMzUscGx1bToxNDUyNDYzNyxwb3dkZXJibHVlOjExNTkxOTEwLHB1cnBsZTo4Mzg4NzM2LHJlYmVjY2FwdXJwbGU6NjY5Nzg4MSxyZWQ6MTY3MTE2ODAscm9zeWJyb3duOjEyMzU3NTE5LHJveWFsYmx1ZTo0Mjg2OTQ1LHNhZGRsZWJyb3duOjkxMjcxODcsc2FsbW9uOjE2NDE2ODgyLHNhbmR5YnJvd246MTYwMzI4NjQsc2VhZ3JlZW46MzA1MDMyNyxzZWFzaGVsbDoxNjc3NDYzOCxzaWVubmE6MTA1MDY3OTcsc2lsdmVyOjEyNjMyMjU2LHNreWJsdWU6ODkwMDMzMSxzbGF0ZWJsdWU6Njk3MDA2MSxzbGF0ZWdyYXk6NzM3Mjk0NCxzbGF0ZWdyZXk6NzM3Mjk0NCxzbm93OjE2Nzc1OTMwLHNwcmluZ2dyZWVuOjY1NDA3LHN0ZWVsYmx1ZTo0NjIwOTgwLHRhbjoxMzgwODc4MCx0ZWFsOjMyODk2LHRoaXN0bGU6MTQyMDQ4ODgsdG9tYXRvOjE2NzM3MDk1LHR1cnF1b2lzZTo0MjUxODU2LHZpb2xldDoxNTYzMTA4Nix3aGVhdDoxNjExMzMzMSx3aGl0ZToxNjc3NzIxNSx3aGl0ZXNtb2tlOjE2MTE5Mjg1LHllbGxvdzoxNjc3Njk2MCx5ZWxsb3dncmVlbjoxMDE0NTA3NH0scm49e2g6MCxzOjAsbDowfSxmaT17aDowLHM6MCxsOjB9O2Z1bmN0aW9uIGVyKG4sZSx0KXtyZXR1cm4gdDwwJiYodCs9MSksdD4xJiYodC09MSksdDwxLzY/bisoZS1uKSo2KnQ6dDwxLzI/ZTp0PDIvMz9uKyhlLW4pKjYqKDIvMy10KTpufWNsYXNzIFZle2NvbnN0cnVjdG9yKGUsdCxpKXtyZXR1cm4gdGhpcy5pc0NvbG9yPSEwLHRoaXMucj0xLHRoaXMuZz0xLHRoaXMuYj0xLHRoaXMuc2V0KGUsdCxpKX1zZXQoZSx0LGkpe2lmKHQ9PT12b2lkIDAmJmk9PT12b2lkIDApe2NvbnN0IHI9ZTtyJiZyLmlzQ29sb3I/dGhpcy5jb3B5KHIpOnR5cGVvZiByPT0ibnVtYmVyIj90aGlzLnNldEhleChyKTp0eXBlb2Ygcj09InN0cmluZyImJnRoaXMuc2V0U3R5bGUocil9ZWxzZSB0aGlzLnNldFJHQihlLHQsaSk7cmV0dXJuIHRoaXN9c2V0U2NhbGFyKGUpe3JldHVybiB0aGlzLnI9ZSx0aGlzLmc9ZSx0aGlzLmI9ZSx0aGlzfXNldEhleChlLHQ9YnQpe3JldHVybiBlPU1hdGguZmxvb3IoZSksdGhpcy5yPShlPj4xNiYyNTUpLzI1NSx0aGlzLmc9KGU+PjgmMjU1KS8yNTUsdGhpcy5iPShlJjI1NSkvMjU1LEJlLnRvV29ya2luZ0NvbG9yU3BhY2UodGhpcyx0KSx0aGlzfXNldFJHQihlLHQsaSxyPUJlLndvcmtpbmdDb2xvclNwYWNlKXtyZXR1cm4gdGhpcy5yPWUsdGhpcy5nPXQsdGhpcy5iPWksQmUudG9Xb3JraW5nQ29sb3JTcGFjZSh0aGlzLHIpLHRoaXN9c2V0SFNMKGUsdCxpLHI9QmUud29ya2luZ0NvbG9yU3BhY2Upe2lmKGU9T2koZSwxKSx0PWd0KHQsMCwxKSxpPWd0KGksMCwxKSx0PT09MCl0aGlzLnI9dGhpcy5nPXRoaXMuYj1pO2Vsc2V7Y29uc3Qgcz1pPD0uNT9pKigxK3QpOmkrdC1pKnQsbz0yKmktczt0aGlzLnI9ZXIobyxzLGUrMS8zKSx0aGlzLmc9ZXIobyxzLGUpLHRoaXMuYj1lcihvLHMsZS0xLzMpfXJldHVybiBCZS50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsciksdGhpc31zZXRTdHlsZShlLHQ9YnQpe2Z1bmN0aW9uIGkocyl7cyE9PXZvaWQgMCYmcGFyc2VGbG9hdChzKTwxJiZjb25zb2xlLndhcm4oIlRIUkVFLkNvbG9yOiBBbHBoYSBjb21wb25lbnQgb2YgIitlKyIgd2lsbCBiZSBpZ25vcmVkLiIpfWxldCByO2lmKHI9L14oXHcrKVwoKFteXCldKilcKS8uZXhlYyhlKSl7bGV0IHM7Y29uc3Qgbz1yWzFdLGE9clsyXTtzd2l0Y2gobyl7Y2FzZSJyZ2IiOmNhc2UicmdiYSI6aWYocz0vXlxzKihcZCspXHMqLFxzKihcZCspXHMqLFxzKihcZCspXHMqKD86LFxzKihcZCpcLj9cZCspXHMqKT8kLy5leGVjKGEpKXJldHVybiBpKHNbNF0pLHRoaXMuc2V0UkdCKE1hdGgubWluKDI1NSxwYXJzZUludChzWzFdLDEwKSkvMjU1LE1hdGgubWluKDI1NSxwYXJzZUludChzWzJdLDEwKSkvMjU1LE1hdGgubWluKDI1NSxwYXJzZUludChzWzNdLDEwKSkvMjU1LHQpO2lmKHM9L15ccyooXGQrKVwlXHMqLFxzKihcZCspXCVccyosXHMqKFxkKylcJVxzKig/OixccyooXGQqXC4/XGQrKVxzKik/JC8uZXhlYyhhKSlyZXR1cm4gaShzWzRdKSx0aGlzLnNldFJHQihNYXRoLm1pbigxMDAscGFyc2VJbnQoc1sxXSwxMCkpLzEwMCxNYXRoLm1pbigxMDAscGFyc2VJbnQoc1syXSwxMCkpLzEwMCxNYXRoLm1pbigxMDAscGFyc2VJbnQoc1szXSwxMCkpLzEwMCx0KTticmVhaztjYXNlImhzbCI6Y2FzZSJoc2xhIjppZihzPS9eXHMqKFxkKlwuP1xkKylccyosXHMqKFxkKlwuP1xkKylcJVxzKixccyooXGQqXC4/XGQrKVwlXHMqKD86LFxzKihcZCpcLj9cZCspXHMqKT8kLy5leGVjKGEpKXJldHVybiBpKHNbNF0pLHRoaXMuc2V0SFNMKHBhcnNlRmxvYXQoc1sxXSkvMzYwLHBhcnNlRmxvYXQoc1syXSkvMTAwLHBhcnNlRmxvYXQoc1szXSkvMTAwLHQpO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS53YXJuKCJUSFJFRS5Db2xvcjogVW5rbm93biBjb2xvciBtb2RlbCAiK2UpfX1lbHNlIGlmKHI9L15cIyhbQS1GYS1mXGRdKykkLy5leGVjKGUpKXtjb25zdCBzPXJbMV0sbz1zLmxlbmd0aDtpZihvPT09MylyZXR1cm4gdGhpcy5zZXRSR0IocGFyc2VJbnQocy5jaGFyQXQoMCksMTYpLzE1LHBhcnNlSW50KHMuY2hhckF0KDEpLDE2KS8xNSxwYXJzZUludChzLmNoYXJBdCgyKSwxNikvMTUsdCk7aWYobz09PTYpcmV0dXJuIHRoaXMuc2V0SGV4KHBhcnNlSW50KHMsMTYpLHQpO2NvbnNvbGUud2FybigiVEhSRUUuQ29sb3I6IEludmFsaWQgaGV4IGNvbG9yICIrZSl9ZWxzZSBpZihlJiZlLmxlbmd0aD4wKXJldHVybiB0aGlzLnNldENvbG9yTmFtZShlLHQpO3JldHVybiB0aGlzfXNldENvbG9yTmFtZShlLHQ9YnQpe2NvbnN0IGk9VnJbZS50b0xvd2VyQ2FzZSgpXTtyZXR1cm4gaSE9PXZvaWQgMD90aGlzLnNldEhleChpLHQpOmNvbnNvbGUud2FybigiVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgIitlKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucix0aGlzLmcsdGhpcy5iKX1jb3B5KGUpe3JldHVybiB0aGlzLnI9ZS5yLHRoaXMuZz1lLmcsdGhpcy5iPWUuYix0aGlzfWNvcHlTUkdCVG9MaW5lYXIoZSl7cmV0dXJuIHRoaXMucj1WdChlLnIpLHRoaXMuZz1WdChlLmcpLHRoaXMuYj1WdChlLmIpLHRoaXN9Y29weUxpbmVhclRvU1JHQihlKXtyZXR1cm4gdGhpcy5yPXluKGUuciksdGhpcy5nPXluKGUuZyksdGhpcy5iPXluKGUuYiksdGhpc31jb252ZXJ0U1JHQlRvTGluZWFyKCl7cmV0dXJuIHRoaXMuY29weVNSR0JUb0xpbmVhcih0aGlzKSx0aGlzfWNvbnZlcnRMaW5lYXJUb1NSR0IoKXtyZXR1cm4gdGhpcy5jb3B5TGluZWFyVG9TUkdCKHRoaXMpLHRoaXN9Z2V0SGV4KGU9YnQpe3JldHVybiBCZS5mcm9tV29ya2luZ0NvbG9yU3BhY2UocHQuY29weSh0aGlzKSxlKSxNYXRoLnJvdW5kKGd0KHB0LnIqMjU1LDAsMjU1KSkqNjU1MzYrTWF0aC5yb3VuZChndChwdC5nKjI1NSwwLDI1NSkpKjI1NitNYXRoLnJvdW5kKGd0KHB0LmIqMjU1LDAsMjU1KSl9Z2V0SGV4U3RyaW5nKGU9YnQpe3JldHVybigiMDAwMDAwIit0aGlzLmdldEhleChlKS50b1N0cmluZygxNikpLnNsaWNlKC02KX1nZXRIU0woZSx0PUJlLndvcmtpbmdDb2xvclNwYWNlKXtCZS5mcm9tV29ya2luZ0NvbG9yU3BhY2UocHQuY29weSh0aGlzKSx0KTtjb25zdCBpPXB0LnIscj1wdC5nLHM9cHQuYixvPU1hdGgubWF4KGkscixzKSxhPU1hdGgubWluKGkscixzKTtsZXQgbCxjO2NvbnN0IHU9KGErbykvMjtpZihhPT09bylsPTAsYz0wO2Vsc2V7Y29uc3QgZD1vLWE7c3dpdGNoKGM9dTw9LjU/ZC8obythKTpkLygyLW8tYSksbyl7Y2FzZSBpOmw9KHItcykvZCsocjxzPzY6MCk7YnJlYWs7Y2FzZSByOmw9KHMtaSkvZCsyO2JyZWFrO2Nhc2UgczpsPShpLXIpL2QrNDticmVha31sLz02fXJldHVybiBlLmg9bCxlLnM9YyxlLmw9dSxlfWdldFJHQihlLHQ9QmUud29ya2luZ0NvbG9yU3BhY2Upe3JldHVybiBCZS5mcm9tV29ya2luZ0NvbG9yU3BhY2UocHQuY29weSh0aGlzKSx0KSxlLnI9cHQucixlLmc9cHQuZyxlLmI9cHQuYixlfWdldFN0eWxlKGU9YnQpe0JlLmZyb21Xb3JraW5nQ29sb3JTcGFjZShwdC5jb3B5KHRoaXMpLGUpO2NvbnN0IHQ9cHQucixpPXB0Lmcscj1wdC5iO3JldHVybiBlIT09YnQ/YGNvbG9yKCR7ZX0gJHt0LnRvRml4ZWQoMyl9ICR7aS50b0ZpeGVkKDMpfSAke3IudG9GaXhlZCgzKX0pYDpgcmdiKCR7TWF0aC5yb3VuZCh0KjI1NSl9LCR7TWF0aC5yb3VuZChpKjI1NSl9LCR7TWF0aC5yb3VuZChyKjI1NSl9KWB9b2Zmc2V0SFNMKGUsdCxpKXtyZXR1cm4gdGhpcy5nZXRIU0wocm4pLHRoaXMuc2V0SFNMKHJuLmgrZSxybi5zK3Qscm4ubCtpKX1hZGQoZSl7cmV0dXJuIHRoaXMucis9ZS5yLHRoaXMuZys9ZS5nLHRoaXMuYis9ZS5iLHRoaXN9YWRkQ29sb3JzKGUsdCl7cmV0dXJuIHRoaXMucj1lLnIrdC5yLHRoaXMuZz1lLmcrdC5nLHRoaXMuYj1lLmIrdC5iLHRoaXN9YWRkU2NhbGFyKGUpe3JldHVybiB0aGlzLnIrPWUsdGhpcy5nKz1lLHRoaXMuYis9ZSx0aGlzfXN1YihlKXtyZXR1cm4gdGhpcy5yPU1hdGgubWF4KDAsdGhpcy5yLWUuciksdGhpcy5nPU1hdGgubWF4KDAsdGhpcy5nLWUuZyksdGhpcy5iPU1hdGgubWF4KDAsdGhpcy5iLWUuYiksdGhpc31tdWx0aXBseShlKXtyZXR1cm4gdGhpcy5yKj1lLnIsdGhpcy5nKj1lLmcsdGhpcy5iKj1lLmIsdGhpc31tdWx0aXBseVNjYWxhcihlKXtyZXR1cm4gdGhpcy5yKj1lLHRoaXMuZyo9ZSx0aGlzLmIqPWUsdGhpc31sZXJwKGUsdCl7cmV0dXJuIHRoaXMucis9KGUuci10aGlzLnIpKnQsdGhpcy5nKz0oZS5nLXRoaXMuZykqdCx0aGlzLmIrPShlLmItdGhpcy5iKSp0LHRoaXN9bGVycENvbG9ycyhlLHQsaSl7cmV0dXJuIHRoaXMucj1lLnIrKHQuci1lLnIpKmksdGhpcy5nPWUuZysodC5nLWUuZykqaSx0aGlzLmI9ZS5iKyh0LmItZS5iKSppLHRoaXN9bGVycEhTTChlLHQpe3RoaXMuZ2V0SFNMKHJuKSxlLmdldEhTTChmaSk7Y29uc3QgaT1rbihybi5oLGZpLmgsdCkscj1rbihybi5zLGZpLnMsdCkscz1rbihybi5sLGZpLmwsdCk7cmV0dXJuIHRoaXMuc2V0SFNMKGkscixzKSx0aGlzfXNldEZyb21WZWN0b3IzKGUpe3JldHVybiB0aGlzLnI9ZS54LHRoaXMuZz1lLnksdGhpcy5iPWUueix0aGlzfWFwcGx5TWF0cml4MyhlKXtjb25zdCB0PXRoaXMucixpPXRoaXMuZyxyPXRoaXMuYixzPWUuZWxlbWVudHM7cmV0dXJuIHRoaXMucj1zWzBdKnQrc1szXSppK3NbNl0qcix0aGlzLmc9c1sxXSp0K3NbNF0qaStzWzddKnIsdGhpcy5iPXNbMl0qdCtzWzVdKmkrc1s4XSpyLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLnI9PT10aGlzLnImJmUuZz09PXRoaXMuZyYmZS5iPT09dGhpcy5ifWZyb21BcnJheShlLHQ9MCl7cmV0dXJuIHRoaXMucj1lW3RdLHRoaXMuZz1lW3QrMV0sdGhpcy5iPWVbdCsyXSx0aGlzfXRvQXJyYXkoZT1bXSx0PTApe3JldHVybiBlW3RdPXRoaXMucixlW3QrMV09dGhpcy5nLGVbdCsyXT10aGlzLmIsZX1mcm9tQnVmZmVyQXR0cmlidXRlKGUsdCl7cmV0dXJuIHRoaXMucj1lLmdldFgodCksdGhpcy5nPWUuZ2V0WSh0KSx0aGlzLmI9ZS5nZXRaKHQpLHRoaXN9dG9KU09OKCl7cmV0dXJuIHRoaXMuZ2V0SGV4KCl9KltTeW1ib2wuaXRlcmF0b3JdKCl7eWllbGQgdGhpcy5yLHlpZWxkIHRoaXMuZyx5aWVsZCB0aGlzLmJ9fWNvbnN0IHB0PW5ldyBWZTtWZS5OQU1FUz1WcjtsZXQgYmE9MDtjbGFzcyBabiBleHRlbmRzIE1ue3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJNYXRlcmlhbCJ9Z2V0IHR5cGUoKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50eXBlfXNldCB0eXBlKGUpe31jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5pc01hdGVyaWFsPSEwLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJpZCIse3ZhbHVlOmJhKyt9KSx0aGlzLnV1aWQ9U24oKSx0aGlzLm5hbWU9IiIsdGhpcy5ibGVuZGluZz0xLHRoaXMuc2lkZT0wLHRoaXMudmVydGV4Q29sb3JzPSExLHRoaXMub3BhY2l0eT0xLHRoaXMudHJhbnNwYXJlbnQ9ITEsdGhpcy5hbHBoYUhhc2g9ITEsdGhpcy5ibGVuZFNyYz0yMDQsdGhpcy5ibGVuZERzdD0yMDUsdGhpcy5ibGVuZEVxdWF0aW9uPTEwMCx0aGlzLmJsZW5kU3JjQWxwaGE9bnVsbCx0aGlzLmJsZW5kRHN0QWxwaGE9bnVsbCx0aGlzLmJsZW5kRXF1YXRpb25BbHBoYT1udWxsLHRoaXMuYmxlbmRDb2xvcj1uZXcgVmUoMCwwLDApLHRoaXMuYmxlbmRBbHBoYT0wLHRoaXMuZGVwdGhGdW5jPTMsdGhpcy5kZXB0aFRlc3Q9ITAsdGhpcy5kZXB0aFdyaXRlPSEwLHRoaXMuc3RlbmNpbFdyaXRlTWFzaz0yNTUsdGhpcy5zdGVuY2lsRnVuYz01MTksdGhpcy5zdGVuY2lsUmVmPTAsdGhpcy5zdGVuY2lsRnVuY01hc2s9MjU1LHRoaXMuc3RlbmNpbEZhaWw9NzY4MCx0aGlzLnN0ZW5jaWxaRmFpbD03NjgwLHRoaXMuc3RlbmNpbFpQYXNzPTc2ODAsdGhpcy5zdGVuY2lsV3JpdGU9ITEsdGhpcy5jbGlwcGluZ1BsYW5lcz1udWxsLHRoaXMuY2xpcEludGVyc2VjdGlvbj0hMSx0aGlzLmNsaXBTaGFkb3dzPSExLHRoaXMuc2hhZG93U2lkZT1udWxsLHRoaXMuY29sb3JXcml0ZT0hMCx0aGlzLnByZWNpc2lvbj1udWxsLHRoaXMucG9seWdvbk9mZnNldD0hMSx0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3I9MCx0aGlzLnBvbHlnb25PZmZzZXRVbml0cz0wLHRoaXMuZGl0aGVyaW5nPSExLHRoaXMuYWxwaGFUb0NvdmVyYWdlPSExLHRoaXMucHJlbXVsdGlwbGllZEFscGhhPSExLHRoaXMuZm9yY2VTaW5nbGVQYXNzPSExLHRoaXMudmlzaWJsZT0hMCx0aGlzLnRvbmVNYXBwZWQ9ITAsdGhpcy51c2VyRGF0YT17fSx0aGlzLnZlcnNpb249MCx0aGlzLl9hbHBoYVRlc3Q9MH1nZXQgYWxwaGFUZXN0KCl7cmV0dXJuIHRoaXMuX2FscGhhVGVzdH1zZXQgYWxwaGFUZXN0KGUpe3RoaXMuX2FscGhhVGVzdD4wIT1lPjAmJnRoaXMudmVyc2lvbisrLHRoaXMuX2FscGhhVGVzdD1lfW9uQmVmb3JlUmVuZGVyKCl7fW9uQmVmb3JlQ29tcGlsZSgpe31jdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKXtyZXR1cm4gdGhpcy5vbkJlZm9yZUNvbXBpbGUudG9TdHJpbmcoKX1zZXRWYWx1ZXMoZSl7aWYoZSE9PXZvaWQgMClmb3IoY29uc3QgdCBpbiBlKXtjb25zdCBpPWVbdF07aWYoaT09PXZvaWQgMCl7Y29uc29sZS53YXJuKGBUSFJFRS5NYXRlcmlhbDogcGFyYW1ldGVyICcke3R9JyBoYXMgdmFsdWUgb2YgdW5kZWZpbmVkLmApO2NvbnRpbnVlfWNvbnN0IHI9dGhpc1t0XTtpZihyPT09dm9pZCAwKXtjb25zb2xlLndhcm4oYFRIUkVFLk1hdGVyaWFsOiAnJHt0fScgaXMgbm90IGEgcHJvcGVydHkgb2YgVEhSRUUuJHt0aGlzLnR5cGV9LmApO2NvbnRpbnVlfXImJnIuaXNDb2xvcj9yLnNldChpKTpyJiZyLmlzVmVjdG9yMyYmaSYmaS5pc1ZlY3RvcjM/ci5jb3B5KGkpOnRoaXNbdF09aX19dG9KU09OKGUpe2NvbnN0IHQ9ZT09PXZvaWQgMHx8dHlwZW9mIGU9PSJzdHJpbmciO3QmJihlPXt0ZXh0dXJlczp7fSxpbWFnZXM6e319KTtjb25zdCBpPXttZXRhZGF0YTp7dmVyc2lvbjo0LjYsdHlwZToiTWF0ZXJpYWwiLGdlbmVyYXRvcjoiTWF0ZXJpYWwudG9KU09OIn19O2kudXVpZD10aGlzLnV1aWQsaS50eXBlPXRoaXMudHlwZSx0aGlzLm5hbWUhPT0iIiYmKGkubmFtZT10aGlzLm5hbWUpLHRoaXMuY29sb3ImJnRoaXMuY29sb3IuaXNDb2xvciYmKGkuY29sb3I9dGhpcy5jb2xvci5nZXRIZXgoKSksdGhpcy5yb3VnaG5lc3MhPT12b2lkIDAmJihpLnJvdWdobmVzcz10aGlzLnJvdWdobmVzcyksdGhpcy5tZXRhbG5lc3MhPT12b2lkIDAmJihpLm1ldGFsbmVzcz10aGlzLm1ldGFsbmVzcyksdGhpcy5zaGVlbiE9PXZvaWQgMCYmKGkuc2hlZW49dGhpcy5zaGVlbiksdGhpcy5zaGVlbkNvbG9yJiZ0aGlzLnNoZWVuQ29sb3IuaXNDb2xvciYmKGkuc2hlZW5Db2xvcj10aGlzLnNoZWVuQ29sb3IuZ2V0SGV4KCkpLHRoaXMuc2hlZW5Sb3VnaG5lc3MhPT12b2lkIDAmJihpLnNoZWVuUm91Z2huZXNzPXRoaXMuc2hlZW5Sb3VnaG5lc3MpLHRoaXMuZW1pc3NpdmUmJnRoaXMuZW1pc3NpdmUuaXNDb2xvciYmKGkuZW1pc3NpdmU9dGhpcy5lbWlzc2l2ZS5nZXRIZXgoKSksdGhpcy5lbWlzc2l2ZUludGVuc2l0eSE9PXZvaWQgMCYmdGhpcy5lbWlzc2l2ZUludGVuc2l0eSE9PTEmJihpLmVtaXNzaXZlSW50ZW5zaXR5PXRoaXMuZW1pc3NpdmVJbnRlbnNpdHkpLHRoaXMuc3BlY3VsYXImJnRoaXMuc3BlY3VsYXIuaXNDb2xvciYmKGkuc3BlY3VsYXI9dGhpcy5zcGVjdWxhci5nZXRIZXgoKSksdGhpcy5zcGVjdWxhckludGVuc2l0eSE9PXZvaWQgMCYmKGkuc3BlY3VsYXJJbnRlbnNpdHk9dGhpcy5zcGVjdWxhckludGVuc2l0eSksdGhpcy5zcGVjdWxhckNvbG9yJiZ0aGlzLnNwZWN1bGFyQ29sb3IuaXNDb2xvciYmKGkuc3BlY3VsYXJDb2xvcj10aGlzLnNwZWN1bGFyQ29sb3IuZ2V0SGV4KCkpLHRoaXMuc2hpbmluZXNzIT09dm9pZCAwJiYoaS5zaGluaW5lc3M9dGhpcy5zaGluaW5lc3MpLHRoaXMuY2xlYXJjb2F0IT09dm9pZCAwJiYoaS5jbGVhcmNvYXQ9dGhpcy5jbGVhcmNvYXQpLHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzIT09dm9pZCAwJiYoaS5jbGVhcmNvYXRSb3VnaG5lc3M9dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MpLHRoaXMuY2xlYXJjb2F0TWFwJiZ0aGlzLmNsZWFyY29hdE1hcC5pc1RleHR1cmUmJihpLmNsZWFyY29hdE1hcD10aGlzLmNsZWFyY29hdE1hcC50b0pTT04oZSkudXVpZCksdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAmJnRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwLmlzVGV4dHVyZSYmKGkuY2xlYXJjb2F0Um91Z2huZXNzTWFwPXRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLmNsZWFyY29hdE5vcm1hbE1hcCYmdGhpcy5jbGVhcmNvYXROb3JtYWxNYXAuaXNUZXh0dXJlJiYoaS5jbGVhcmNvYXROb3JtYWxNYXA9dGhpcy5jbGVhcmNvYXROb3JtYWxNYXAudG9KU09OKGUpLnV1aWQsaS5jbGVhcmNvYXROb3JtYWxTY2FsZT10aGlzLmNsZWFyY29hdE5vcm1hbFNjYWxlLnRvQXJyYXkoKSksdGhpcy5kaXNwZXJzaW9uIT09dm9pZCAwJiYoaS5kaXNwZXJzaW9uPXRoaXMuZGlzcGVyc2lvbiksdGhpcy5pcmlkZXNjZW5jZSE9PXZvaWQgMCYmKGkuaXJpZGVzY2VuY2U9dGhpcy5pcmlkZXNjZW5jZSksdGhpcy5pcmlkZXNjZW5jZUlPUiE9PXZvaWQgMCYmKGkuaXJpZGVzY2VuY2VJT1I9dGhpcy5pcmlkZXNjZW5jZUlPUiksdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlIT09dm9pZCAwJiYoaS5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlPXRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSksdGhpcy5pcmlkZXNjZW5jZU1hcCYmdGhpcy5pcmlkZXNjZW5jZU1hcC5pc1RleHR1cmUmJihpLmlyaWRlc2NlbmNlTWFwPXRoaXMuaXJpZGVzY2VuY2VNYXAudG9KU09OKGUpLnV1aWQpLHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAmJnRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAuaXNUZXh0dXJlJiYoaS5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcD10aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLmFuaXNvdHJvcHkhPT12b2lkIDAmJihpLmFuaXNvdHJvcHk9dGhpcy5hbmlzb3Ryb3B5KSx0aGlzLmFuaXNvdHJvcHlSb3RhdGlvbiE9PXZvaWQgMCYmKGkuYW5pc290cm9weVJvdGF0aW9uPXRoaXMuYW5pc290cm9weVJvdGF0aW9uKSx0aGlzLmFuaXNvdHJvcHlNYXAmJnRoaXMuYW5pc290cm9weU1hcC5pc1RleHR1cmUmJihpLmFuaXNvdHJvcHlNYXA9dGhpcy5hbmlzb3Ryb3B5TWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLm1hcCYmdGhpcy5tYXAuaXNUZXh0dXJlJiYoaS5tYXA9dGhpcy5tYXAudG9KU09OKGUpLnV1aWQpLHRoaXMubWF0Y2FwJiZ0aGlzLm1hdGNhcC5pc1RleHR1cmUmJihpLm1hdGNhcD10aGlzLm1hdGNhcC50b0pTT04oZSkudXVpZCksdGhpcy5hbHBoYU1hcCYmdGhpcy5hbHBoYU1hcC5pc1RleHR1cmUmJihpLmFscGhhTWFwPXRoaXMuYWxwaGFNYXAudG9KU09OKGUpLnV1aWQpLHRoaXMubGlnaHRNYXAmJnRoaXMubGlnaHRNYXAuaXNUZXh0dXJlJiYoaS5saWdodE1hcD10aGlzLmxpZ2h0TWFwLnRvSlNPTihlKS51dWlkLGkubGlnaHRNYXBJbnRlbnNpdHk9dGhpcy5saWdodE1hcEludGVuc2l0eSksdGhpcy5hb01hcCYmdGhpcy5hb01hcC5pc1RleHR1cmUmJihpLmFvTWFwPXRoaXMuYW9NYXAudG9KU09OKGUpLnV1aWQsaS5hb01hcEludGVuc2l0eT10aGlzLmFvTWFwSW50ZW5zaXR5KSx0aGlzLmJ1bXBNYXAmJnRoaXMuYnVtcE1hcC5pc1RleHR1cmUmJihpLmJ1bXBNYXA9dGhpcy5idW1wTWFwLnRvSlNPTihlKS51dWlkLGkuYnVtcFNjYWxlPXRoaXMuYnVtcFNjYWxlKSx0aGlzLm5vcm1hbE1hcCYmdGhpcy5ub3JtYWxNYXAuaXNUZXh0dXJlJiYoaS5ub3JtYWxNYXA9dGhpcy5ub3JtYWxNYXAudG9KU09OKGUpLnV1aWQsaS5ub3JtYWxNYXBUeXBlPXRoaXMubm9ybWFsTWFwVHlwZSxpLm5vcm1hbFNjYWxlPXRoaXMubm9ybWFsU2NhbGUudG9BcnJheSgpKSx0aGlzLmRpc3BsYWNlbWVudE1hcCYmdGhpcy5kaXNwbGFjZW1lbnRNYXAuaXNUZXh0dXJlJiYoaS5kaXNwbGFjZW1lbnRNYXA9dGhpcy5kaXNwbGFjZW1lbnRNYXAudG9KU09OKGUpLnV1aWQsaS5kaXNwbGFjZW1lbnRTY2FsZT10aGlzLmRpc3BsYWNlbWVudFNjYWxlLGkuZGlzcGxhY2VtZW50Qmlhcz10aGlzLmRpc3BsYWNlbWVudEJpYXMpLHRoaXMucm91Z2huZXNzTWFwJiZ0aGlzLnJvdWdobmVzc01hcC5pc1RleHR1cmUmJihpLnJvdWdobmVzc01hcD10aGlzLnJvdWdobmVzc01hcC50b0pTT04oZSkudXVpZCksdGhpcy5tZXRhbG5lc3NNYXAmJnRoaXMubWV0YWxuZXNzTWFwLmlzVGV4dHVyZSYmKGkubWV0YWxuZXNzTWFwPXRoaXMubWV0YWxuZXNzTWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLmVtaXNzaXZlTWFwJiZ0aGlzLmVtaXNzaXZlTWFwLmlzVGV4dHVyZSYmKGkuZW1pc3NpdmVNYXA9dGhpcy5lbWlzc2l2ZU1hcC50b0pTT04oZSkudXVpZCksdGhpcy5zcGVjdWxhck1hcCYmdGhpcy5zcGVjdWxhck1hcC5pc1RleHR1cmUmJihpLnNwZWN1bGFyTWFwPXRoaXMuc3BlY3VsYXJNYXAudG9KU09OKGUpLnV1aWQpLHRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAmJnRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAuaXNUZXh0dXJlJiYoaS5zcGVjdWxhckludGVuc2l0eU1hcD10aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLnNwZWN1bGFyQ29sb3JNYXAmJnRoaXMuc3BlY3VsYXJDb2xvck1hcC5pc1RleHR1cmUmJihpLnNwZWN1bGFyQ29sb3JNYXA9dGhpcy5zcGVjdWxhckNvbG9yTWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLmVudk1hcCYmdGhpcy5lbnZNYXAuaXNUZXh0dXJlJiYoaS5lbnZNYXA9dGhpcy5lbnZNYXAudG9KU09OKGUpLnV1aWQsdGhpcy5jb21iaW5lIT09dm9pZCAwJiYoaS5jb21iaW5lPXRoaXMuY29tYmluZSkpLHRoaXMuZW52TWFwUm90YXRpb24hPT12b2lkIDAmJihpLmVudk1hcFJvdGF0aW9uPXRoaXMuZW52TWFwUm90YXRpb24udG9BcnJheSgpKSx0aGlzLmVudk1hcEludGVuc2l0eSE9PXZvaWQgMCYmKGkuZW52TWFwSW50ZW5zaXR5PXRoaXMuZW52TWFwSW50ZW5zaXR5KSx0aGlzLnJlZmxlY3Rpdml0eSE9PXZvaWQgMCYmKGkucmVmbGVjdGl2aXR5PXRoaXMucmVmbGVjdGl2aXR5KSx0aGlzLnJlZnJhY3Rpb25SYXRpbyE9PXZvaWQgMCYmKGkucmVmcmFjdGlvblJhdGlvPXRoaXMucmVmcmFjdGlvblJhdGlvKSx0aGlzLmdyYWRpZW50TWFwJiZ0aGlzLmdyYWRpZW50TWFwLmlzVGV4dHVyZSYmKGkuZ3JhZGllbnRNYXA9dGhpcy5ncmFkaWVudE1hcC50b0pTT04oZSkudXVpZCksdGhpcy50cmFuc21pc3Npb24hPT12b2lkIDAmJihpLnRyYW5zbWlzc2lvbj10aGlzLnRyYW5zbWlzc2lvbiksdGhpcy50cmFuc21pc3Npb25NYXAmJnRoaXMudHJhbnNtaXNzaW9uTWFwLmlzVGV4dHVyZSYmKGkudHJhbnNtaXNzaW9uTWFwPXRoaXMudHJhbnNtaXNzaW9uTWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLnRoaWNrbmVzcyE9PXZvaWQgMCYmKGkudGhpY2tuZXNzPXRoaXMudGhpY2tuZXNzKSx0aGlzLnRoaWNrbmVzc01hcCYmdGhpcy50aGlja25lc3NNYXAuaXNUZXh0dXJlJiYoaS50aGlja25lc3NNYXA9dGhpcy50aGlja25lc3NNYXAudG9KU09OKGUpLnV1aWQpLHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZSE9PXZvaWQgMCYmdGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlIT09MS8wJiYoaS5hdHRlbnVhdGlvbkRpc3RhbmNlPXRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZSksdGhpcy5hdHRlbnVhdGlvbkNvbG9yIT09dm9pZCAwJiYoaS5hdHRlbnVhdGlvbkNvbG9yPXRoaXMuYXR0ZW51YXRpb25Db2xvci5nZXRIZXgoKSksdGhpcy5zaXplIT09dm9pZCAwJiYoaS5zaXplPXRoaXMuc2l6ZSksdGhpcy5zaGFkb3dTaWRlIT09bnVsbCYmKGkuc2hhZG93U2lkZT10aGlzLnNoYWRvd1NpZGUpLHRoaXMuc2l6ZUF0dGVudWF0aW9uIT09dm9pZCAwJiYoaS5zaXplQXR0ZW51YXRpb249dGhpcy5zaXplQXR0ZW51YXRpb24pLHRoaXMuYmxlbmRpbmchPT0xJiYoaS5ibGVuZGluZz10aGlzLmJsZW5kaW5nKSx0aGlzLnNpZGUhPT0wJiYoaS5zaWRlPXRoaXMuc2lkZSksdGhpcy52ZXJ0ZXhDb2xvcnM9PT0hMCYmKGkudmVydGV4Q29sb3JzPSEwKSx0aGlzLm9wYWNpdHk8MSYmKGkub3BhY2l0eT10aGlzLm9wYWNpdHkpLHRoaXMudHJhbnNwYXJlbnQ9PT0hMCYmKGkudHJhbnNwYXJlbnQ9ITApLHRoaXMuYmxlbmRTcmMhPT0yMDQmJihpLmJsZW5kU3JjPXRoaXMuYmxlbmRTcmMpLHRoaXMuYmxlbmREc3QhPT0yMDUmJihpLmJsZW5kRHN0PXRoaXMuYmxlbmREc3QpLHRoaXMuYmxlbmRFcXVhdGlvbiE9PTEwMCYmKGkuYmxlbmRFcXVhdGlvbj10aGlzLmJsZW5kRXF1YXRpb24pLHRoaXMuYmxlbmRTcmNBbHBoYSE9PW51bGwmJihpLmJsZW5kU3JjQWxwaGE9dGhpcy5ibGVuZFNyY0FscGhhKSx0aGlzLmJsZW5kRHN0QWxwaGEhPT1udWxsJiYoaS5ibGVuZERzdEFscGhhPXRoaXMuYmxlbmREc3RBbHBoYSksdGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEhPT1udWxsJiYoaS5ibGVuZEVxdWF0aW9uQWxwaGE9dGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEpLHRoaXMuYmxlbmRDb2xvciYmdGhpcy5ibGVuZENvbG9yLmlzQ29sb3ImJihpLmJsZW5kQ29sb3I9dGhpcy5ibGVuZENvbG9yLmdldEhleCgpKSx0aGlzLmJsZW5kQWxwaGEhPT0wJiYoaS5ibGVuZEFscGhhPXRoaXMuYmxlbmRBbHBoYSksdGhpcy5kZXB0aEZ1bmMhPT0zJiYoaS5kZXB0aEZ1bmM9dGhpcy5kZXB0aEZ1bmMpLHRoaXMuZGVwdGhUZXN0PT09ITEmJihpLmRlcHRoVGVzdD10aGlzLmRlcHRoVGVzdCksdGhpcy5kZXB0aFdyaXRlPT09ITEmJihpLmRlcHRoV3JpdGU9dGhpcy5kZXB0aFdyaXRlKSx0aGlzLmNvbG9yV3JpdGU9PT0hMSYmKGkuY29sb3JXcml0ZT10aGlzLmNvbG9yV3JpdGUpLHRoaXMuc3RlbmNpbFdyaXRlTWFzayE9PTI1NSYmKGkuc3RlbmNpbFdyaXRlTWFzaz10aGlzLnN0ZW5jaWxXcml0ZU1hc2spLHRoaXMuc3RlbmNpbEZ1bmMhPT01MTkmJihpLnN0ZW5jaWxGdW5jPXRoaXMuc3RlbmNpbEZ1bmMpLHRoaXMuc3RlbmNpbFJlZiE9PTAmJihpLnN0ZW5jaWxSZWY9dGhpcy5zdGVuY2lsUmVmKSx0aGlzLnN0ZW5jaWxGdW5jTWFzayE9PTI1NSYmKGkuc3RlbmNpbEZ1bmNNYXNrPXRoaXMuc3RlbmNpbEZ1bmNNYXNrKSx0aGlzLnN0ZW5jaWxGYWlsIT09NzY4MCYmKGkuc3RlbmNpbEZhaWw9dGhpcy5zdGVuY2lsRmFpbCksdGhpcy5zdGVuY2lsWkZhaWwhPT03NjgwJiYoaS5zdGVuY2lsWkZhaWw9dGhpcy5zdGVuY2lsWkZhaWwpLHRoaXMuc3RlbmNpbFpQYXNzIT09NzY4MCYmKGkuc3RlbmNpbFpQYXNzPXRoaXMuc3RlbmNpbFpQYXNzKSx0aGlzLnN0ZW5jaWxXcml0ZT09PSEwJiYoaS5zdGVuY2lsV3JpdGU9dGhpcy5zdGVuY2lsV3JpdGUpLHRoaXMucm90YXRpb24hPT12b2lkIDAmJnRoaXMucm90YXRpb24hPT0wJiYoaS5yb3RhdGlvbj10aGlzLnJvdGF0aW9uKSx0aGlzLnBvbHlnb25PZmZzZXQ9PT0hMCYmKGkucG9seWdvbk9mZnNldD0hMCksdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yIT09MCYmKGkucG9seWdvbk9mZnNldEZhY3Rvcj10aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IpLHRoaXMucG9seWdvbk9mZnNldFVuaXRzIT09MCYmKGkucG9seWdvbk9mZnNldFVuaXRzPXRoaXMucG9seWdvbk9mZnNldFVuaXRzKSx0aGlzLmxpbmV3aWR0aCE9PXZvaWQgMCYmdGhpcy5saW5ld2lkdGghPT0xJiYoaS5saW5ld2lkdGg9dGhpcy5saW5ld2lkdGgpLHRoaXMuZGFzaFNpemUhPT12b2lkIDAmJihpLmRhc2hTaXplPXRoaXMuZGFzaFNpemUpLHRoaXMuZ2FwU2l6ZSE9PXZvaWQgMCYmKGkuZ2FwU2l6ZT10aGlzLmdhcFNpemUpLHRoaXMuc2NhbGUhPT12b2lkIDAmJihpLnNjYWxlPXRoaXMuc2NhbGUpLHRoaXMuZGl0aGVyaW5nPT09ITAmJihpLmRpdGhlcmluZz0hMCksdGhpcy5hbHBoYVRlc3Q+MCYmKGkuYWxwaGFUZXN0PXRoaXMuYWxwaGFUZXN0KSx0aGlzLmFscGhhSGFzaD09PSEwJiYoaS5hbHBoYUhhc2g9ITApLHRoaXMuYWxwaGFUb0NvdmVyYWdlPT09ITAmJihpLmFscGhhVG9Db3ZlcmFnZT0hMCksdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGE9PT0hMCYmKGkucHJlbXVsdGlwbGllZEFscGhhPSEwKSx0aGlzLmZvcmNlU2luZ2xlUGFzcz09PSEwJiYoaS5mb3JjZVNpbmdsZVBhc3M9ITApLHRoaXMud2lyZWZyYW1lPT09ITAmJihpLndpcmVmcmFtZT0hMCksdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg+MSYmKGkud2lyZWZyYW1lTGluZXdpZHRoPXRoaXMud2lyZWZyYW1lTGluZXdpZHRoKSx0aGlzLndpcmVmcmFtZUxpbmVjYXAhPT0icm91bmQiJiYoaS53aXJlZnJhbWVMaW5lY2FwPXRoaXMud2lyZWZyYW1lTGluZWNhcCksdGhpcy53aXJlZnJhbWVMaW5lam9pbiE9PSJyb3VuZCImJihpLndpcmVmcmFtZUxpbmVqb2luPXRoaXMud2lyZWZyYW1lTGluZWpvaW4pLHRoaXMuZmxhdFNoYWRpbmc9PT0hMCYmKGkuZmxhdFNoYWRpbmc9ITApLHRoaXMudmlzaWJsZT09PSExJiYoaS52aXNpYmxlPSExKSx0aGlzLnRvbmVNYXBwZWQ9PT0hMSYmKGkudG9uZU1hcHBlZD0hMSksdGhpcy5mb2c9PT0hMSYmKGkuZm9nPSExKSxPYmplY3Qua2V5cyh0aGlzLnVzZXJEYXRhKS5sZW5ndGg+MCYmKGkudXNlckRhdGE9dGhpcy51c2VyRGF0YSk7ZnVuY3Rpb24gcihzKXtjb25zdCBvPVtdO2Zvcihjb25zdCBhIGluIHMpe2NvbnN0IGw9c1thXTtkZWxldGUgbC5tZXRhZGF0YSxvLnB1c2gobCl9cmV0dXJuIG99aWYodCl7Y29uc3Qgcz1yKGUudGV4dHVyZXMpLG89cihlLmltYWdlcyk7cy5sZW5ndGg+MCYmKGkudGV4dHVyZXM9cyksby5sZW5ndGg+MCYmKGkuaW1hZ2VzPW8pfXJldHVybiBpfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX1jb3B5KGUpe3RoaXMubmFtZT1lLm5hbWUsdGhpcy5ibGVuZGluZz1lLmJsZW5kaW5nLHRoaXMuc2lkZT1lLnNpZGUsdGhpcy52ZXJ0ZXhDb2xvcnM9ZS52ZXJ0ZXhDb2xvcnMsdGhpcy5vcGFjaXR5PWUub3BhY2l0eSx0aGlzLnRyYW5zcGFyZW50PWUudHJhbnNwYXJlbnQsdGhpcy5ibGVuZFNyYz1lLmJsZW5kU3JjLHRoaXMuYmxlbmREc3Q9ZS5ibGVuZERzdCx0aGlzLmJsZW5kRXF1YXRpb249ZS5ibGVuZEVxdWF0aW9uLHRoaXMuYmxlbmRTcmNBbHBoYT1lLmJsZW5kU3JjQWxwaGEsdGhpcy5ibGVuZERzdEFscGhhPWUuYmxlbmREc3RBbHBoYSx0aGlzLmJsZW5kRXF1YXRpb25BbHBoYT1lLmJsZW5kRXF1YXRpb25BbHBoYSx0aGlzLmJsZW5kQ29sb3IuY29weShlLmJsZW5kQ29sb3IpLHRoaXMuYmxlbmRBbHBoYT1lLmJsZW5kQWxwaGEsdGhpcy5kZXB0aEZ1bmM9ZS5kZXB0aEZ1bmMsdGhpcy5kZXB0aFRlc3Q9ZS5kZXB0aFRlc3QsdGhpcy5kZXB0aFdyaXRlPWUuZGVwdGhXcml0ZSx0aGlzLnN0ZW5jaWxXcml0ZU1hc2s9ZS5zdGVuY2lsV3JpdGVNYXNrLHRoaXMuc3RlbmNpbEZ1bmM9ZS5zdGVuY2lsRnVuYyx0aGlzLnN0ZW5jaWxSZWY9ZS5zdGVuY2lsUmVmLHRoaXMuc3RlbmNpbEZ1bmNNYXNrPWUuc3RlbmNpbEZ1bmNNYXNrLHRoaXMuc3RlbmNpbEZhaWw9ZS5zdGVuY2lsRmFpbCx0aGlzLnN0ZW5jaWxaRmFpbD1lLnN0ZW5jaWxaRmFpbCx0aGlzLnN0ZW5jaWxaUGFzcz1lLnN0ZW5jaWxaUGFzcyx0aGlzLnN0ZW5jaWxXcml0ZT1lLnN0ZW5jaWxXcml0ZTtjb25zdCB0PWUuY2xpcHBpbmdQbGFuZXM7bGV0IGk9bnVsbDtpZih0IT09bnVsbCl7Y29uc3Qgcj10Lmxlbmd0aDtpPW5ldyBBcnJheShyKTtmb3IobGV0IHM9MDtzIT09cjsrK3MpaVtzXT10W3NdLmNsb25lKCl9cmV0dXJuIHRoaXMuY2xpcHBpbmdQbGFuZXM9aSx0aGlzLmNsaXBJbnRlcnNlY3Rpb249ZS5jbGlwSW50ZXJzZWN0aW9uLHRoaXMuY2xpcFNoYWRvd3M9ZS5jbGlwU2hhZG93cyx0aGlzLnNoYWRvd1NpZGU9ZS5zaGFkb3dTaWRlLHRoaXMuY29sb3JXcml0ZT1lLmNvbG9yV3JpdGUsdGhpcy5wcmVjaXNpb249ZS5wcmVjaXNpb24sdGhpcy5wb2x5Z29uT2Zmc2V0PWUucG9seWdvbk9mZnNldCx0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3I9ZS5wb2x5Z29uT2Zmc2V0RmFjdG9yLHRoaXMucG9seWdvbk9mZnNldFVuaXRzPWUucG9seWdvbk9mZnNldFVuaXRzLHRoaXMuZGl0aGVyaW5nPWUuZGl0aGVyaW5nLHRoaXMuYWxwaGFUZXN0PWUuYWxwaGFUZXN0LHRoaXMuYWxwaGFIYXNoPWUuYWxwaGFIYXNoLHRoaXMuYWxwaGFUb0NvdmVyYWdlPWUuYWxwaGFUb0NvdmVyYWdlLHRoaXMucHJlbXVsdGlwbGllZEFscGhhPWUucHJlbXVsdGlwbGllZEFscGhhLHRoaXMuZm9yY2VTaW5nbGVQYXNzPWUuZm9yY2VTaW5nbGVQYXNzLHRoaXMudmlzaWJsZT1lLnZpc2libGUsdGhpcy50b25lTWFwcGVkPWUudG9uZU1hcHBlZCx0aGlzLnVzZXJEYXRhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZS51c2VyRGF0YSkpLHRoaXN9ZGlzcG9zZSgpe3RoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToiZGlzcG9zZSJ9KX1zZXQgbmVlZHNVcGRhdGUoZSl7ZT09PSEwJiZ0aGlzLnZlcnNpb24rK31vbkJ1aWxkKCl7Y29uc29sZS53YXJuKCJNYXRlcmlhbDogb25CdWlsZCgpIGhhcyBiZWVuIHJlbW92ZWQuIil9fWNsYXNzIGpuIGV4dGVuZHMgWm57c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIk1lc2hCYXNpY01hdGVyaWFsIn1jb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuaXNNZXNoQmFzaWNNYXRlcmlhbD0hMCx0aGlzLmNvbG9yPW5ldyBWZSgxNjc3NzIxNSksdGhpcy5tYXA9bnVsbCx0aGlzLmxpZ2h0TWFwPW51bGwsdGhpcy5saWdodE1hcEludGVuc2l0eT0xLHRoaXMuYW9NYXA9bnVsbCx0aGlzLmFvTWFwSW50ZW5zaXR5PTEsdGhpcy5zcGVjdWxhck1hcD1udWxsLHRoaXMuYWxwaGFNYXA9bnVsbCx0aGlzLmVudk1hcD1udWxsLHRoaXMuZW52TWFwUm90YXRpb249bmV3IFh0LHRoaXMuY29tYmluZT0wLHRoaXMucmVmbGVjdGl2aXR5PTEsdGhpcy5yZWZyYWN0aW9uUmF0aW89Ljk4LHRoaXMud2lyZWZyYW1lPSExLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPTEsdGhpcy53aXJlZnJhbWVMaW5lY2FwPSJyb3VuZCIsdGhpcy53aXJlZnJhbWVMaW5lam9pbj0icm91bmQiLHRoaXMuZm9nPSEwLHRoaXMuc2V0VmFsdWVzKGUpfWNvcHkoZSl7cmV0dXJuIHN1cGVyLmNvcHkoZSksdGhpcy5jb2xvci5jb3B5KGUuY29sb3IpLHRoaXMubWFwPWUubWFwLHRoaXMubGlnaHRNYXA9ZS5saWdodE1hcCx0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5PWUubGlnaHRNYXBJbnRlbnNpdHksdGhpcy5hb01hcD1lLmFvTWFwLHRoaXMuYW9NYXBJbnRlbnNpdHk9ZS5hb01hcEludGVuc2l0eSx0aGlzLnNwZWN1bGFyTWFwPWUuc3BlY3VsYXJNYXAsdGhpcy5hbHBoYU1hcD1lLmFscGhhTWFwLHRoaXMuZW52TWFwPWUuZW52TWFwLHRoaXMuZW52TWFwUm90YXRpb24uY29weShlLmVudk1hcFJvdGF0aW9uKSx0aGlzLmNvbWJpbmU9ZS5jb21iaW5lLHRoaXMucmVmbGVjdGl2aXR5PWUucmVmbGVjdGl2aXR5LHRoaXMucmVmcmFjdGlvblJhdGlvPWUucmVmcmFjdGlvblJhdGlvLHRoaXMud2lyZWZyYW1lPWUud2lyZWZyYW1lLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPWUud2lyZWZyYW1lTGluZXdpZHRoLHRoaXMud2lyZWZyYW1lTGluZWNhcD1lLndpcmVmcmFtZUxpbmVjYXAsdGhpcy53aXJlZnJhbWVMaW5lam9pbj1lLndpcmVmcmFtZUxpbmVqb2luLHRoaXMuZm9nPWUuZm9nLHRoaXN9fWNvbnN0IG90PW5ldyBPLHBpPW5ldyBQZTtjbGFzcyBTdHtjb25zdHJ1Y3RvcihlLHQsaT0hMSl7aWYoQXJyYXkuaXNBcnJheShlKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LiIpO3RoaXMuaXNCdWZmZXJBdHRyaWJ1dGU9ITAsdGhpcy5uYW1lPSIiLHRoaXMuYXJyYXk9ZSx0aGlzLml0ZW1TaXplPXQsdGhpcy5jb3VudD1lIT09dm9pZCAwP2UubGVuZ3RoL3Q6MCx0aGlzLm5vcm1hbGl6ZWQ9aSx0aGlzLnVzYWdlPTM1MDQ0LHRoaXMudXBkYXRlUmFuZ2VzPVtdLHRoaXMuZ3B1VHlwZT0xMDE1LHRoaXMudmVyc2lvbj0wfW9uVXBsb2FkQ2FsbGJhY2soKXt9c2V0IG5lZWRzVXBkYXRlKGUpe2U9PT0hMCYmdGhpcy52ZXJzaW9uKyt9c2V0VXNhZ2UoZSl7cmV0dXJuIHRoaXMudXNhZ2U9ZSx0aGlzfWFkZFVwZGF0ZVJhbmdlKGUsdCl7dGhpcy51cGRhdGVSYW5nZXMucHVzaCh7c3RhcnQ6ZSxjb3VudDp0fSl9Y2xlYXJVcGRhdGVSYW5nZXMoKXt0aGlzLnVwZGF0ZVJhbmdlcy5sZW5ndGg9MH1jb3B5KGUpe3JldHVybiB0aGlzLm5hbWU9ZS5uYW1lLHRoaXMuYXJyYXk9bmV3IGUuYXJyYXkuY29uc3RydWN0b3IoZS5hcnJheSksdGhpcy5pdGVtU2l6ZT1lLml0ZW1TaXplLHRoaXMuY291bnQ9ZS5jb3VudCx0aGlzLm5vcm1hbGl6ZWQ9ZS5ub3JtYWxpemVkLHRoaXMudXNhZ2U9ZS51c2FnZSx0aGlzLmdwdVR5cGU9ZS5ncHVUeXBlLHRoaXN9Y29weUF0KGUsdCxpKXtlKj10aGlzLml0ZW1TaXplLGkqPXQuaXRlbVNpemU7Zm9yKGxldCByPTAscz10aGlzLml0ZW1TaXplO3I8cztyKyspdGhpcy5hcnJheVtlK3JdPXQuYXJyYXlbaStyXTtyZXR1cm4gdGhpc31jb3B5QXJyYXkoZSl7cmV0dXJuIHRoaXMuYXJyYXkuc2V0KGUpLHRoaXN9YXBwbHlNYXRyaXgzKGUpe2lmKHRoaXMuaXRlbVNpemU9PT0yKWZvcihsZXQgdD0wLGk9dGhpcy5jb3VudDt0PGk7dCsrKXBpLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcyx0KSxwaS5hcHBseU1hdHJpeDMoZSksdGhpcy5zZXRYWSh0LHBpLngscGkueSk7ZWxzZSBpZih0aGlzLml0ZW1TaXplPT09Mylmb3IobGV0IHQ9MCxpPXRoaXMuY291bnQ7dDxpO3QrKylvdC5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsdCksb3QuYXBwbHlNYXRyaXgzKGUpLHRoaXMuc2V0WFlaKHQsb3QueCxvdC55LG90LnopO3JldHVybiB0aGlzfWFwcGx5TWF0cml4NChlKXtmb3IobGV0IHQ9MCxpPXRoaXMuY291bnQ7dDxpO3QrKylvdC5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsdCksb3QuYXBwbHlNYXRyaXg0KGUpLHRoaXMuc2V0WFlaKHQsb3QueCxvdC55LG90LnopO3JldHVybiB0aGlzfWFwcGx5Tm9ybWFsTWF0cml4KGUpe2ZvcihsZXQgdD0wLGk9dGhpcy5jb3VudDt0PGk7dCsrKW90LmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcyx0KSxvdC5hcHBseU5vcm1hbE1hdHJpeChlKSx0aGlzLnNldFhZWih0LG90Lngsb3QueSxvdC56KTtyZXR1cm4gdGhpc310cmFuc2Zvcm1EaXJlY3Rpb24oZSl7Zm9yKGxldCB0PTAsaT10aGlzLmNvdW50O3Q8aTt0Kyspb3QuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLHQpLG90LnRyYW5zZm9ybURpcmVjdGlvbihlKSx0aGlzLnNldFhZWih0LG90Lngsb3QueSxvdC56KTtyZXR1cm4gdGhpc31zZXQoZSx0PTApe3JldHVybiB0aGlzLmFycmF5LnNldChlLHQpLHRoaXN9Z2V0Q29tcG9uZW50KGUsdCl7bGV0IGk9dGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrdF07cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKGk9RW4oaSx0aGlzLmFycmF5KSksaX1zZXRDb21wb25lbnQoZSx0LGkpe3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihpPV90KGksdGhpcy5hcnJheSkpLHRoaXMuYXJyYXlbZSp0aGlzLml0ZW1TaXplK3RdPWksdGhpc31nZXRYKGUpe2xldCB0PXRoaXMuYXJyYXlbZSp0aGlzLml0ZW1TaXplXTtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYodD1Fbih0LHRoaXMuYXJyYXkpKSx0fXNldFgoZSx0KXtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYodD1fdCh0LHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W2UqdGhpcy5pdGVtU2l6ZV09dCx0aGlzfWdldFkoZSl7bGV0IHQ9dGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrMV07cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9RW4odCx0aGlzLmFycmF5KSksdH1zZXRZKGUsdCl7cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9X3QodCx0aGlzLmFycmF5KSksdGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrMV09dCx0aGlzfWdldFooZSl7bGV0IHQ9dGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrMl07cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9RW4odCx0aGlzLmFycmF5KSksdH1zZXRaKGUsdCl7cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9X3QodCx0aGlzLmFycmF5KSksdGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrMl09dCx0aGlzfWdldFcoZSl7bGV0IHQ9dGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrM107cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9RW4odCx0aGlzLmFycmF5KSksdH1zZXRXKGUsdCl7cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9X3QodCx0aGlzLmFycmF5KSksdGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrM109dCx0aGlzfXNldFhZKGUsdCxpKXtyZXR1cm4gZSo9dGhpcy5pdGVtU2l6ZSx0aGlzLm5vcm1hbGl6ZWQmJih0PV90KHQsdGhpcy5hcnJheSksaT1fdChpLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W2UrMF09dCx0aGlzLmFycmF5W2UrMV09aSx0aGlzfXNldFhZWihlLHQsaSxyKXtyZXR1cm4gZSo9dGhpcy5pdGVtU2l6ZSx0aGlzLm5vcm1hbGl6ZWQmJih0PV90KHQsdGhpcy5hcnJheSksaT1fdChpLHRoaXMuYXJyYXkpLHI9X3Qocix0aGlzLmFycmF5KSksdGhpcy5hcnJheVtlKzBdPXQsdGhpcy5hcnJheVtlKzFdPWksdGhpcy5hcnJheVtlKzJdPXIsdGhpc31zZXRYWVpXKGUsdCxpLHIscyl7cmV0dXJuIGUqPXRoaXMuaXRlbVNpemUsdGhpcy5ub3JtYWxpemVkJiYodD1fdCh0LHRoaXMuYXJyYXkpLGk9X3QoaSx0aGlzLmFycmF5KSxyPV90KHIsdGhpcy5hcnJheSkscz1fdChzLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W2UrMF09dCx0aGlzLmFycmF5W2UrMV09aSx0aGlzLmFycmF5W2UrMl09cix0aGlzLmFycmF5W2UrM109cyx0aGlzfW9uVXBsb2FkKGUpe3JldHVybiB0aGlzLm9uVXBsb2FkQ2FsbGJhY2s9ZSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYXJyYXksdGhpcy5pdGVtU2l6ZSkuY29weSh0aGlzKX10b0pTT04oKXtjb25zdCBlPXtpdGVtU2l6ZTp0aGlzLml0ZW1TaXplLHR5cGU6dGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLGFycmF5OkFycmF5LmZyb20odGhpcy5hcnJheSksbm9ybWFsaXplZDp0aGlzLm5vcm1hbGl6ZWR9O3JldHVybiB0aGlzLm5hbWUhPT0iIiYmKGUubmFtZT10aGlzLm5hbWUpLHRoaXMudXNhZ2UhPT0zNTA0NCYmKGUudXNhZ2U9dGhpcy51c2FnZSksZX19Y2xhc3Mga3IgZXh0ZW5kcyBTdHtjb25zdHJ1Y3RvcihlLHQsaSl7c3VwZXIobmV3IFVpbnQxNkFycmF5KGUpLHQsaSl9fWNsYXNzIFdyIGV4dGVuZHMgU3R7Y29uc3RydWN0b3IoZSx0LGkpe3N1cGVyKG5ldyBVaW50MzJBcnJheShlKSx0LGkpfX1jbGFzcyB1biBleHRlbmRzIFN0e2NvbnN0cnVjdG9yKGUsdCxpKXtzdXBlcihuZXcgRmxvYXQzMkFycmF5KGUpLHQsaSl9fWxldCBSYT0wO2NvbnN0IFJ0PW5ldyBzdCx0cj1uZXcgTXQsVW49bmV3IE8sVHQ9bmV3IHFuLEpuPW5ldyBxbixodD1uZXcgTztjbGFzcyBDdCBleHRlbmRzIE1ue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmlzQnVmZmVyR2VvbWV0cnk9ITAsT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImlkIix7dmFsdWU6UmErK30pLHRoaXMudXVpZD1TbigpLHRoaXMubmFtZT0iIix0aGlzLnR5cGU9IkJ1ZmZlckdlb21ldHJ5Iix0aGlzLmluZGV4PW51bGwsdGhpcy5pbmRpcmVjdD1udWxsLHRoaXMuYXR0cmlidXRlcz17fSx0aGlzLm1vcnBoQXR0cmlidXRlcz17fSx0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPSExLHRoaXMuZ3JvdXBzPVtdLHRoaXMuYm91bmRpbmdCb3g9bnVsbCx0aGlzLmJvdW5kaW5nU3BoZXJlPW51bGwsdGhpcy5kcmF3UmFuZ2U9e3N0YXJ0OjAsY291bnQ6MS8wfSx0aGlzLnVzZXJEYXRhPXt9fWdldEluZGV4KCl7cmV0dXJuIHRoaXMuaW5kZXh9c2V0SW5kZXgoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/dGhpcy5pbmRleD1uZXcoRXIoZSk/V3I6a3IpKGUsMSk6dGhpcy5pbmRleD1lLHRoaXN9c2V0SW5kaXJlY3QoZSl7cmV0dXJuIHRoaXMuaW5kaXJlY3Q9ZSx0aGlzfWdldEluZGlyZWN0KCl7cmV0dXJuIHRoaXMuaW5kaXJlY3R9Z2V0QXR0cmlidXRlKGUpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbZV19c2V0QXR0cmlidXRlKGUsdCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlc1tlXT10LHRoaXN9ZGVsZXRlQXR0cmlidXRlKGUpe3JldHVybiBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW2VdLHRoaXN9aGFzQXR0cmlidXRlKGUpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbZV0hPT12b2lkIDB9YWRkR3JvdXAoZSx0LGk9MCl7dGhpcy5ncm91cHMucHVzaCh7c3RhcnQ6ZSxjb3VudDp0LG1hdGVyaWFsSW5kZXg6aX0pfWNsZWFyR3JvdXBzKCl7dGhpcy5ncm91cHM9W119c2V0RHJhd1JhbmdlKGUsdCl7dGhpcy5kcmF3UmFuZ2Uuc3RhcnQ9ZSx0aGlzLmRyYXdSYW5nZS5jb3VudD10fWFwcGx5TWF0cml4NChlKXtjb25zdCB0PXRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjt0IT09dm9pZCAwJiYodC5hcHBseU1hdHJpeDQoZSksdC5uZWVkc1VwZGF0ZT0hMCk7Y29uc3QgaT10aGlzLmF0dHJpYnV0ZXMubm9ybWFsO2lmKGkhPT12b2lkIDApe2NvbnN0IHM9bmV3IGJlKCkuZ2V0Tm9ybWFsTWF0cml4KGUpO2kuYXBwbHlOb3JtYWxNYXRyaXgocyksaS5uZWVkc1VwZGF0ZT0hMH1jb25zdCByPXRoaXMuYXR0cmlidXRlcy50YW5nZW50O3JldHVybiByIT09dm9pZCAwJiYoci50cmFuc2Zvcm1EaXJlY3Rpb24oZSksci5uZWVkc1VwZGF0ZT0hMCksdGhpcy5ib3VuZGluZ0JveCE9PW51bGwmJnRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCksdGhpcy5ib3VuZGluZ1NwaGVyZSE9PW51bGwmJnRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksdGhpc31hcHBseVF1YXRlcm5pb24oZSl7cmV0dXJuIFJ0Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKGUpLHRoaXMuYXBwbHlNYXRyaXg0KFJ0KSx0aGlzfXJvdGF0ZVgoZSl7cmV0dXJuIFJ0Lm1ha2VSb3RhdGlvblgoZSksdGhpcy5hcHBseU1hdHJpeDQoUnQpLHRoaXN9cm90YXRlWShlKXtyZXR1cm4gUnQubWFrZVJvdGF0aW9uWShlKSx0aGlzLmFwcGx5TWF0cml4NChSdCksdGhpc31yb3RhdGVaKGUpe3JldHVybiBSdC5tYWtlUm90YXRpb25aKGUpLHRoaXMuYXBwbHlNYXRyaXg0KFJ0KSx0aGlzfXRyYW5zbGF0ZShlLHQsaSl7cmV0dXJuIFJ0Lm1ha2VUcmFuc2xhdGlvbihlLHQsaSksdGhpcy5hcHBseU1hdHJpeDQoUnQpLHRoaXN9c2NhbGUoZSx0LGkpe3JldHVybiBSdC5tYWtlU2NhbGUoZSx0LGkpLHRoaXMuYXBwbHlNYXRyaXg0KFJ0KSx0aGlzfWxvb2tBdChlKXtyZXR1cm4gdHIubG9va0F0KGUpLHRyLnVwZGF0ZU1hdHJpeCgpLHRoaXMuYXBwbHlNYXRyaXg0KHRyLm1hdHJpeCksdGhpc31jZW50ZXIoKXtyZXR1cm4gdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKSx0aGlzLmJvdW5kaW5nQm94LmdldENlbnRlcihVbikubmVnYXRlKCksdGhpcy50cmFuc2xhdGUoVW4ueCxVbi55LFVuLnopLHRoaXN9c2V0RnJvbVBvaW50cyhlKXtjb25zdCB0PXRoaXMuZ2V0QXR0cmlidXRlKCJwb3NpdGlvbiIpO2lmKHQ9PT12b2lkIDApe2NvbnN0IGk9W107Zm9yKGxldCByPTAscz1lLmxlbmd0aDtyPHM7cisrKXtjb25zdCBvPWVbcl07aS5wdXNoKG8ueCxvLnksby56fHwwKX10aGlzLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyB1bihpLDMpKX1lbHNle2ZvcihsZXQgaT0wLHI9dC5jb3VudDtpPHI7aSsrKXtjb25zdCBzPWVbaV07dC5zZXRYWVooaSxzLngscy55LHMuenx8MCl9ZS5sZW5ndGg+dC5jb3VudCYmY29uc29sZS53YXJuKCJUSFJFRS5CdWZmZXJHZW9tZXRyeTogQnVmZmVyIHNpemUgdG9vIHNtYWxsIGZvciBwb2ludHMgZGF0YS4gVXNlIC5kaXNwb3NlKCkgYW5kIGNyZWF0ZSBhIG5ldyBnZW9tZXRyeS4iKSx0Lm5lZWRzVXBkYXRlPSEwfXJldHVybiB0aGlzfWNvbXB1dGVCb3VuZGluZ0JveCgpe3RoaXMuYm91bmRpbmdCb3g9PT1udWxsJiYodGhpcy5ib3VuZGluZ0JveD1uZXcgcW4pO2NvbnN0IGU9dGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLHQ9dGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247aWYoZSYmZS5pc0dMQnVmZmVyQXR0cmlidXRlKXtjb25zb2xlLmVycm9yKCJUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTogR0xCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgYSBtYW51YWwgYm91bmRpbmcgYm94LiIsdGhpcyksdGhpcy5ib3VuZGluZ0JveC5zZXQobmV3IE8oLTEvMCwtMS8wLC0xLzApLG5ldyBPKDEvMCwxLzAsMS8wKSk7cmV0dXJufWlmKGUhPT12b2lkIDApe2lmKHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShlKSx0KWZvcihsZXQgaT0wLHI9dC5sZW5ndGg7aTxyO2krKyl7Y29uc3Qgcz10W2ldO1R0LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUocyksdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZT8oaHQuYWRkVmVjdG9ycyh0aGlzLmJvdW5kaW5nQm94Lm1pbixUdC5taW4pLHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChodCksaHQuYWRkVmVjdG9ycyh0aGlzLmJvdW5kaW5nQm94Lm1heCxUdC5tYXgpLHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChodCkpOih0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoVHQubWluKSx0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoVHQubWF4KSl9fWVsc2UgdGhpcy5ib3VuZGluZ0JveC5tYWtlRW1wdHkoKTsoaXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueCl8fGlzTmFOKHRoaXMuYm91bmRpbmdCb3gubWluLnkpfHxpc05hTih0aGlzLmJvdW5kaW5nQm94Lm1pbi56KSkmJmNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpOiBDb21wdXRlZCBtaW4vbWF4IGhhdmUgTmFOIHZhbHVlcy4gVGhlICJwb3NpdGlvbiIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJyx0aGlzKX1jb21wdXRlQm91bmRpbmdTcGhlcmUoKXt0aGlzLmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmKHRoaXMuYm91bmRpbmdTcGhlcmU9bmV3IGxpKTtjb25zdCBlPXRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbix0PXRoaXMubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO2lmKGUmJmUuaXNHTEJ1ZmZlckF0dHJpYnV0ZSl7Y29uc29sZS5lcnJvcigiVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IEdMQnVmZmVyQXR0cmlidXRlIHJlcXVpcmVzIGEgbWFudWFsIGJvdW5kaW5nIHNwaGVyZS4iLHRoaXMpLHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0KG5ldyBPLDEvMCk7cmV0dXJufWlmKGUpe2NvbnN0IGk9dGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7aWYoVHQuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShlKSx0KWZvcihsZXQgcz0wLG89dC5sZW5ndGg7czxvO3MrKyl7Y29uc3QgYT10W3NdO0puLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoYSksdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZT8oaHQuYWRkVmVjdG9ycyhUdC5taW4sSm4ubWluKSxUdC5leHBhbmRCeVBvaW50KGh0KSxodC5hZGRWZWN0b3JzKFR0Lm1heCxKbi5tYXgpLFR0LmV4cGFuZEJ5UG9pbnQoaHQpKTooVHQuZXhwYW5kQnlQb2ludChKbi5taW4pLFR0LmV4cGFuZEJ5UG9pbnQoSm4ubWF4KSl9VHQuZ2V0Q2VudGVyKGkpO2xldCByPTA7Zm9yKGxldCBzPTAsbz1lLmNvdW50O3M8bztzKyspaHQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHMpLHI9TWF0aC5tYXgocixpLmRpc3RhbmNlVG9TcXVhcmVkKGh0KSk7aWYodClmb3IobGV0IHM9MCxvPXQubGVuZ3RoO3M8bztzKyspe2NvbnN0IGE9dFtzXSxsPXRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7Zm9yKGxldCBjPTAsdT1hLmNvdW50O2M8dTtjKyspaHQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhLGMpLGwmJihVbi5mcm9tQnVmZmVyQXR0cmlidXRlKGUsYyksaHQuYWRkKFVuKSkscj1NYXRoLm1heChyLGkuZGlzdGFuY2VUb1NxdWFyZWQoaHQpKX10aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cz1NYXRoLnNxcnQociksaXNOYU4odGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMpJiZjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogQ29tcHV0ZWQgcmFkaXVzIGlzIE5hTi4gVGhlICJwb3NpdGlvbiIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJyx0aGlzKX19Y29tcHV0ZVRhbmdlbnRzKCl7Y29uc3QgZT10aGlzLmluZGV4LHQ9dGhpcy5hdHRyaWJ1dGVzO2lmKGU9PT1udWxsfHx0LnBvc2l0aW9uPT09dm9pZCAwfHx0Lm5vcm1hbD09PXZvaWQgMHx8dC51dj09PXZvaWQgMCl7Y29uc29sZS5lcnJvcigiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBmYWlsZWQuIE1pc3NpbmcgcmVxdWlyZWQgYXR0cmlidXRlcyAoaW5kZXgsIHBvc2l0aW9uLCBub3JtYWwgb3IgdXYpIik7cmV0dXJufWNvbnN0IGk9dC5wb3NpdGlvbixyPXQubm9ybWFsLHM9dC51djt0aGlzLmhhc0F0dHJpYnV0ZSgidGFuZ2VudCIpPT09ITEmJnRoaXMuc2V0QXR0cmlidXRlKCJ0YW5nZW50IixuZXcgU3QobmV3IEZsb2F0MzJBcnJheSg0KmkuY291bnQpLDQpKTtjb25zdCBvPXRoaXMuZ2V0QXR0cmlidXRlKCJ0YW5nZW50IiksYT1bXSxsPVtdO2ZvcihsZXQgRj0wO0Y8aS5jb3VudDtGKyspYVtGXT1uZXcgTyxsW0ZdPW5ldyBPO2NvbnN0IGM9bmV3IE8sdT1uZXcgTyxkPW5ldyBPLGY9bmV3IFBlLHA9bmV3IFBlLGc9bmV3IFBlLHg9bmV3IE8sbT1uZXcgTztmdW5jdGlvbiBoKEYsRSxTKXtjLmZyb21CdWZmZXJBdHRyaWJ1dGUoaSxGKSx1LmZyb21CdWZmZXJBdHRyaWJ1dGUoaSxFKSxkLmZyb21CdWZmZXJBdHRyaWJ1dGUoaSxTKSxmLmZyb21CdWZmZXJBdHRyaWJ1dGUocyxGKSxwLmZyb21CdWZmZXJBdHRyaWJ1dGUocyxFKSxnLmZyb21CdWZmZXJBdHRyaWJ1dGUocyxTKSx1LnN1YihjKSxkLnN1YihjKSxwLnN1YihmKSxnLnN1YihmKTtjb25zdCBSPTEvKHAueCpnLnktZy54KnAueSk7aXNGaW5pdGUoUikmJih4LmNvcHkodSkubXVsdGlwbHlTY2FsYXIoZy55KS5hZGRTY2FsZWRWZWN0b3IoZCwtcC55KS5tdWx0aXBseVNjYWxhcihSKSxtLmNvcHkoZCkubXVsdGlwbHlTY2FsYXIocC54KS5hZGRTY2FsZWRWZWN0b3IodSwtZy54KS5tdWx0aXBseVNjYWxhcihSKSxhW0ZdLmFkZCh4KSxhW0VdLmFkZCh4KSxhW1NdLmFkZCh4KSxsW0ZdLmFkZChtKSxsW0VdLmFkZChtKSxsW1NdLmFkZChtKSl9bGV0IFQ9dGhpcy5ncm91cHM7VC5sZW5ndGg9PT0wJiYoVD1be3N0YXJ0OjAsY291bnQ6ZS5jb3VudH1dKTtmb3IobGV0IEY9MCxFPVQubGVuZ3RoO0Y8RTsrK0Ype2NvbnN0IFM9VFtGXSxSPVMuc3RhcnQscT1TLmNvdW50O2ZvcihsZXQgej1SLFc9UitxO3o8Vzt6Kz0zKWgoZS5nZXRYKHorMCksZS5nZXRYKHorMSksZS5nZXRYKHorMikpfWNvbnN0IHk9bmV3IE8sXz1uZXcgTyxDPW5ldyBPLHc9bmV3IE87ZnVuY3Rpb24gYihGKXtDLmZyb21CdWZmZXJBdHRyaWJ1dGUocixGKSx3LmNvcHkoQyk7Y29uc3QgRT1hW0ZdO3kuY29weShFKSx5LnN1YihDLm11bHRpcGx5U2NhbGFyKEMuZG90KEUpKSkubm9ybWFsaXplKCksXy5jcm9zc1ZlY3RvcnModyxFKTtjb25zdCBSPV8uZG90KGxbRl0pPDA/LTE6MTtvLnNldFhZWlcoRix5LngseS55LHkueixSKX1mb3IobGV0IEY9MCxFPVQubGVuZ3RoO0Y8RTsrK0Ype2NvbnN0IFM9VFtGXSxSPVMuc3RhcnQscT1TLmNvdW50O2ZvcihsZXQgej1SLFc9UitxO3o8Vzt6Kz0zKWIoZS5nZXRYKHorMCkpLGIoZS5nZXRYKHorMSkpLGIoZS5nZXRYKHorMikpfX1jb21wdXRlVmVydGV4Tm9ybWFscygpe2NvbnN0IGU9dGhpcy5pbmRleCx0PXRoaXMuZ2V0QXR0cmlidXRlKCJwb3NpdGlvbiIpO2lmKHQhPT12b2lkIDApe2xldCBpPXRoaXMuZ2V0QXR0cmlidXRlKCJub3JtYWwiKTtpZihpPT09dm9pZCAwKWk9bmV3IFN0KG5ldyBGbG9hdDMyQXJyYXkodC5jb3VudCozKSwzKSx0aGlzLnNldEF0dHJpYnV0ZSgibm9ybWFsIixpKTtlbHNlIGZvcihsZXQgZj0wLHA9aS5jb3VudDtmPHA7ZisrKWkuc2V0WFlaKGYsMCwwLDApO2NvbnN0IHI9bmV3IE8scz1uZXcgTyxvPW5ldyBPLGE9bmV3IE8sbD1uZXcgTyxjPW5ldyBPLHU9bmV3IE8sZD1uZXcgTztpZihlKWZvcihsZXQgZj0wLHA9ZS5jb3VudDtmPHA7Zis9Myl7Y29uc3QgZz1lLmdldFgoZiswKSx4PWUuZ2V0WChmKzEpLG09ZS5nZXRYKGYrMik7ci5mcm9tQnVmZmVyQXR0cmlidXRlKHQsZykscy5mcm9tQnVmZmVyQXR0cmlidXRlKHQseCksby5mcm9tQnVmZmVyQXR0cmlidXRlKHQsbSksdS5zdWJWZWN0b3JzKG8scyksZC5zdWJWZWN0b3JzKHIscyksdS5jcm9zcyhkKSxhLmZyb21CdWZmZXJBdHRyaWJ1dGUoaSxnKSxsLmZyb21CdWZmZXJBdHRyaWJ1dGUoaSx4KSxjLmZyb21CdWZmZXJBdHRyaWJ1dGUoaSxtKSxhLmFkZCh1KSxsLmFkZCh1KSxjLmFkZCh1KSxpLnNldFhZWihnLGEueCxhLnksYS56KSxpLnNldFhZWih4LGwueCxsLnksbC56KSxpLnNldFhZWihtLGMueCxjLnksYy56KX1lbHNlIGZvcihsZXQgZj0wLHA9dC5jb3VudDtmPHA7Zis9MylyLmZyb21CdWZmZXJBdHRyaWJ1dGUodCxmKzApLHMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LGYrMSksby5mcm9tQnVmZmVyQXR0cmlidXRlKHQsZisyKSx1LnN1YlZlY3RvcnMobyxzKSxkLnN1YlZlY3RvcnMocixzKSx1LmNyb3NzKGQpLGkuc2V0WFlaKGYrMCx1LngsdS55LHUueiksaS5zZXRYWVooZisxLHUueCx1LnksdS56KSxpLnNldFhZWihmKzIsdS54LHUueSx1LnopO3RoaXMubm9ybWFsaXplTm9ybWFscygpLGkubmVlZHNVcGRhdGU9ITB9fW5vcm1hbGl6ZU5vcm1hbHMoKXtjb25zdCBlPXRoaXMuYXR0cmlidXRlcy5ub3JtYWw7Zm9yKGxldCB0PTAsaT1lLmNvdW50O3Q8aTt0KyspaHQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHQpLGh0Lm5vcm1hbGl6ZSgpLGUuc2V0WFlaKHQsaHQueCxodC55LGh0LnopfXRvTm9uSW5kZXhlZCgpe2Z1bmN0aW9uIGUoYSxsKXtjb25zdCBjPWEuYXJyYXksdT1hLml0ZW1TaXplLGQ9YS5ub3JtYWxpemVkLGY9bmV3IGMuY29uc3RydWN0b3IobC5sZW5ndGgqdSk7bGV0IHA9MCxnPTA7Zm9yKGxldCB4PTAsbT1sLmxlbmd0aDt4PG07eCsrKXthLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU/cD1sW3hdKmEuZGF0YS5zdHJpZGUrYS5vZmZzZXQ6cD1sW3hdKnU7Zm9yKGxldCBoPTA7aDx1O2grKylmW2crK109Y1twKytdfXJldHVybiBuZXcgU3QoZix1LGQpfWlmKHRoaXMuaW5kZXg9PT1udWxsKXJldHVybiBjb25zb2xlLndhcm4oIlRIUkVFLkJ1ZmZlckdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpOiBCdWZmZXJHZW9tZXRyeSBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLiIpLHRoaXM7Y29uc3QgdD1uZXcgQ3QsaT10aGlzLmluZGV4LmFycmF5LHI9dGhpcy5hdHRyaWJ1dGVzO2Zvcihjb25zdCBhIGluIHIpe2NvbnN0IGw9clthXSxjPWUobCxpKTt0LnNldEF0dHJpYnV0ZShhLGMpfWNvbnN0IHM9dGhpcy5tb3JwaEF0dHJpYnV0ZXM7Zm9yKGNvbnN0IGEgaW4gcyl7Y29uc3QgbD1bXSxjPXNbYV07Zm9yKGxldCB1PTAsZD1jLmxlbmd0aDt1PGQ7dSsrKXtjb25zdCBmPWNbdV0scD1lKGYsaSk7bC5wdXNoKHApfXQubW9ycGhBdHRyaWJ1dGVzW2FdPWx9dC5tb3JwaFRhcmdldHNSZWxhdGl2ZT10aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO2NvbnN0IG89dGhpcy5ncm91cHM7Zm9yKGxldCBhPTAsbD1vLmxlbmd0aDthPGw7YSsrKXtjb25zdCBjPW9bYV07dC5hZGRHcm91cChjLnN0YXJ0LGMuY291bnQsYy5tYXRlcmlhbEluZGV4KX1yZXR1cm4gdH10b0pTT04oKXtjb25zdCBlPXttZXRhZGF0YTp7dmVyc2lvbjo0LjYsdHlwZToiQnVmZmVyR2VvbWV0cnkiLGdlbmVyYXRvcjoiQnVmZmVyR2VvbWV0cnkudG9KU09OIn19O2lmKGUudXVpZD10aGlzLnV1aWQsZS50eXBlPXRoaXMudHlwZSx0aGlzLm5hbWUhPT0iIiYmKGUubmFtZT10aGlzLm5hbWUpLE9iamVjdC5rZXlzKHRoaXMudXNlckRhdGEpLmxlbmd0aD4wJiYoZS51c2VyRGF0YT10aGlzLnVzZXJEYXRhKSx0aGlzLnBhcmFtZXRlcnMhPT12b2lkIDApe2NvbnN0IGw9dGhpcy5wYXJhbWV0ZXJzO2Zvcihjb25zdCBjIGluIGwpbFtjXSE9PXZvaWQgMCYmKGVbY109bFtjXSk7cmV0dXJuIGV9ZS5kYXRhPXthdHRyaWJ1dGVzOnt9fTtjb25zdCB0PXRoaXMuaW5kZXg7dCE9PW51bGwmJihlLmRhdGEuaW5kZXg9e3R5cGU6dC5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLGFycmF5OkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQuYXJyYXkpfSk7Y29uc3QgaT10aGlzLmF0dHJpYnV0ZXM7Zm9yKGNvbnN0IGwgaW4gaSl7Y29uc3QgYz1pW2xdO2UuZGF0YS5hdHRyaWJ1dGVzW2xdPWMudG9KU09OKGUuZGF0YSl9Y29uc3Qgcj17fTtsZXQgcz0hMTtmb3IoY29uc3QgbCBpbiB0aGlzLm1vcnBoQXR0cmlidXRlcyl7Y29uc3QgYz10aGlzLm1vcnBoQXR0cmlidXRlc1tsXSx1PVtdO2ZvcihsZXQgZD0wLGY9Yy5sZW5ndGg7ZDxmO2QrKyl7Y29uc3QgcD1jW2RdO3UucHVzaChwLnRvSlNPTihlLmRhdGEpKX11Lmxlbmd0aD4wJiYocltsXT11LHM9ITApfXMmJihlLmRhdGEubW9ycGhBdHRyaWJ1dGVzPXIsZS5kYXRhLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPXRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUpO2NvbnN0IG89dGhpcy5ncm91cHM7by5sZW5ndGg+MCYmKGUuZGF0YS5ncm91cHM9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvKSkpO2NvbnN0IGE9dGhpcy5ib3VuZGluZ1NwaGVyZTtyZXR1cm4gYSE9PW51bGwmJihlLmRhdGEuYm91bmRpbmdTcGhlcmU9e2NlbnRlcjphLmNlbnRlci50b0FycmF5KCkscmFkaXVzOmEucmFkaXVzfSksZX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9Y29weShlKXt0aGlzLmluZGV4PW51bGwsdGhpcy5hdHRyaWJ1dGVzPXt9LHRoaXMubW9ycGhBdHRyaWJ1dGVzPXt9LHRoaXMuZ3JvdXBzPVtdLHRoaXMuYm91bmRpbmdCb3g9bnVsbCx0aGlzLmJvdW5kaW5nU3BoZXJlPW51bGw7Y29uc3QgdD17fTt0aGlzLm5hbWU9ZS5uYW1lO2NvbnN0IGk9ZS5pbmRleDtpIT09bnVsbCYmdGhpcy5zZXRJbmRleChpLmNsb25lKHQpKTtjb25zdCByPWUuYXR0cmlidXRlcztmb3IoY29uc3QgYyBpbiByKXtjb25zdCB1PXJbY107dGhpcy5zZXRBdHRyaWJ1dGUoYyx1LmNsb25lKHQpKX1jb25zdCBzPWUubW9ycGhBdHRyaWJ1dGVzO2Zvcihjb25zdCBjIGluIHMpe2NvbnN0IHU9W10sZD1zW2NdO2ZvcihsZXQgZj0wLHA9ZC5sZW5ndGg7ZjxwO2YrKyl1LnB1c2goZFtmXS5jbG9uZSh0KSk7dGhpcy5tb3JwaEF0dHJpYnV0ZXNbY109dX10aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPWUubW9ycGhUYXJnZXRzUmVsYXRpdmU7Y29uc3Qgbz1lLmdyb3Vwcztmb3IobGV0IGM9MCx1PW8ubGVuZ3RoO2M8dTtjKyspe2NvbnN0IGQ9b1tjXTt0aGlzLmFkZEdyb3VwKGQuc3RhcnQsZC5jb3VudCxkLm1hdGVyaWFsSW5kZXgpfWNvbnN0IGE9ZS5ib3VuZGluZ0JveDthIT09bnVsbCYmKHRoaXMuYm91bmRpbmdCb3g9YS5jbG9uZSgpKTtjb25zdCBsPWUuYm91bmRpbmdTcGhlcmU7cmV0dXJuIGwhPT1udWxsJiYodGhpcy5ib3VuZGluZ1NwaGVyZT1sLmNsb25lKCkpLHRoaXMuZHJhd1JhbmdlLnN0YXJ0PWUuZHJhd1JhbmdlLnN0YXJ0LHRoaXMuZHJhd1JhbmdlLmNvdW50PWUuZHJhd1JhbmdlLmNvdW50LHRoaXMudXNlckRhdGE9ZS51c2VyRGF0YSx0aGlzfWRpc3Bvc2UoKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImRpc3Bvc2UifSl9fWNvbnN0IFhyPW5ldyBzdCxobj1uZXcgTHIsbWk9bmV3IGxpLHFyPW5ldyBPLGdpPW5ldyBPLF9pPW5ldyBPLHZpPW5ldyBPLG5yPW5ldyBPLHhpPW5ldyBPLFlyPW5ldyBPLE1pPW5ldyBPO2NsYXNzIHR0IGV4dGVuZHMgTXR7Y29uc3RydWN0b3IoZT1uZXcgQ3QsdD1uZXcgam4pe3N1cGVyKCksdGhpcy5pc01lc2g9ITAsdGhpcy50eXBlPSJNZXNoIix0aGlzLmdlb21ldHJ5PWUsdGhpcy5tYXRlcmlhbD10LHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCl9Y29weShlLHQpe3JldHVybiBzdXBlci5jb3B5KGUsdCksZS5tb3JwaFRhcmdldEluZmx1ZW5jZXMhPT12b2lkIDAmJih0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcz1lLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5zbGljZSgpKSxlLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSE9PXZvaWQgMCYmKHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5PU9iamVjdC5hc3NpZ24oe30sZS5tb3JwaFRhcmdldERpY3Rpb25hcnkpKSx0aGlzLm1hdGVyaWFsPUFycmF5LmlzQXJyYXkoZS5tYXRlcmlhbCk/ZS5tYXRlcmlhbC5zbGljZSgpOmUubWF0ZXJpYWwsdGhpcy5nZW9tZXRyeT1lLmdlb21ldHJ5LHRoaXN9dXBkYXRlTW9ycGhUYXJnZXRzKCl7Y29uc3QgdD10aGlzLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyxpPU9iamVjdC5rZXlzKHQpO2lmKGkubGVuZ3RoPjApe2NvbnN0IHI9dFtpWzBdXTtpZihyIT09dm9pZCAwKXt0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcz1bXSx0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeT17fTtmb3IobGV0IHM9MCxvPXIubGVuZ3RoO3M8bztzKyspe2NvbnN0IGE9cltzXS5uYW1lfHxTdHJpbmcocyk7dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCgwKSx0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVthXT1zfX19fWdldFZlcnRleFBvc2l0aW9uKGUsdCl7Y29uc3QgaT10aGlzLmdlb21ldHJ5LHI9aS5hdHRyaWJ1dGVzLnBvc2l0aW9uLHM9aS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24sbz1pLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO3QuZnJvbUJ1ZmZlckF0dHJpYnV0ZShyLGUpO2NvbnN0IGE9dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7aWYocyYmYSl7eGkuc2V0KDAsMCwwKTtmb3IobGV0IGw9MCxjPXMubGVuZ3RoO2w8YztsKyspe2NvbnN0IHU9YVtsXSxkPXNbbF07dSE9PTAmJihuci5mcm9tQnVmZmVyQXR0cmlidXRlKGQsZSksbz94aS5hZGRTY2FsZWRWZWN0b3IobnIsdSk6eGkuYWRkU2NhbGVkVmVjdG9yKG5yLnN1Yih0KSx1KSl9dC5hZGQoeGkpfXJldHVybiB0fXJheWNhc3QoZSx0KXtjb25zdCBpPXRoaXMuZ2VvbWV0cnkscj10aGlzLm1hdGVyaWFsLHM9dGhpcy5tYXRyaXhXb3JsZDtyIT09dm9pZCAwJiYoaS5ib3VuZGluZ1NwaGVyZT09PW51bGwmJmkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksbWkuY29weShpLmJvdW5kaW5nU3BoZXJlKSxtaS5hcHBseU1hdHJpeDQocyksaG4uY29weShlLnJheSkucmVjYXN0KGUubmVhciksIShtaS5jb250YWluc1BvaW50KGhuLm9yaWdpbik9PT0hMSYmKGhuLmludGVyc2VjdFNwaGVyZShtaSxxcik9PT1udWxsfHxobi5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQocXIpPihlLmZhci1lLm5lYXIpKioyKSkmJihYci5jb3B5KHMpLmludmVydCgpLGhuLmNvcHkoZS5yYXkpLmFwcGx5TWF0cml4NChYciksIShpLmJvdW5kaW5nQm94IT09bnVsbCYmaG4uaW50ZXJzZWN0c0JveChpLmJvdW5kaW5nQm94KT09PSExKSYmdGhpcy5fY29tcHV0ZUludGVyc2VjdGlvbnMoZSx0LGhuKSkpfV9jb21wdXRlSW50ZXJzZWN0aW9ucyhlLHQsaSl7bGV0IHI7Y29uc3Qgcz10aGlzLmdlb21ldHJ5LG89dGhpcy5tYXRlcmlhbCxhPXMuaW5kZXgsbD1zLmF0dHJpYnV0ZXMucG9zaXRpb24sYz1zLmF0dHJpYnV0ZXMudXYsdT1zLmF0dHJpYnV0ZXMudXYxLGQ9cy5hdHRyaWJ1dGVzLm5vcm1hbCxmPXMuZ3JvdXBzLHA9cy5kcmF3UmFuZ2U7aWYoYSE9PW51bGwpaWYoQXJyYXkuaXNBcnJheShvKSlmb3IobGV0IGc9MCx4PWYubGVuZ3RoO2c8eDtnKyspe2NvbnN0IG09ZltnXSxoPW9bbS5tYXRlcmlhbEluZGV4XSxUPU1hdGgubWF4KG0uc3RhcnQscC5zdGFydCkseT1NYXRoLm1pbihhLmNvdW50LE1hdGgubWluKG0uc3RhcnQrbS5jb3VudCxwLnN0YXJ0K3AuY291bnQpKTtmb3IobGV0IF89VCxDPXk7XzxDO18rPTMpe2NvbnN0IHc9YS5nZXRYKF8pLGI9YS5nZXRYKF8rMSksRj1hLmdldFgoXysyKTtyPVNpKHRoaXMsaCxlLGksYyx1LGQsdyxiLEYpLHImJihyLmZhY2VJbmRleD1NYXRoLmZsb29yKF8vMyksci5mYWNlLm1hdGVyaWFsSW5kZXg9bS5tYXRlcmlhbEluZGV4LHQucHVzaChyKSl9fWVsc2V7Y29uc3QgZz1NYXRoLm1heCgwLHAuc3RhcnQpLHg9TWF0aC5taW4oYS5jb3VudCxwLnN0YXJ0K3AuY291bnQpO2ZvcihsZXQgbT1nLGg9eDttPGg7bSs9Myl7Y29uc3QgVD1hLmdldFgobSkseT1hLmdldFgobSsxKSxfPWEuZ2V0WChtKzIpO3I9U2kodGhpcyxvLGUsaSxjLHUsZCxULHksXyksciYmKHIuZmFjZUluZGV4PU1hdGguZmxvb3IobS8zKSx0LnB1c2gocikpfX1lbHNlIGlmKGwhPT12b2lkIDApaWYoQXJyYXkuaXNBcnJheShvKSlmb3IobGV0IGc9MCx4PWYubGVuZ3RoO2c8eDtnKyspe2NvbnN0IG09ZltnXSxoPW9bbS5tYXRlcmlhbEluZGV4XSxUPU1hdGgubWF4KG0uc3RhcnQscC5zdGFydCkseT1NYXRoLm1pbihsLmNvdW50LE1hdGgubWluKG0uc3RhcnQrbS5jb3VudCxwLnN0YXJ0K3AuY291bnQpKTtmb3IobGV0IF89VCxDPXk7XzxDO18rPTMpe2NvbnN0IHc9XyxiPV8rMSxGPV8rMjtyPVNpKHRoaXMsaCxlLGksYyx1LGQsdyxiLEYpLHImJihyLmZhY2VJbmRleD1NYXRoLmZsb29yKF8vMyksci5mYWNlLm1hdGVyaWFsSW5kZXg9bS5tYXRlcmlhbEluZGV4LHQucHVzaChyKSl9fWVsc2V7Y29uc3QgZz1NYXRoLm1heCgwLHAuc3RhcnQpLHg9TWF0aC5taW4obC5jb3VudCxwLnN0YXJ0K3AuY291bnQpO2ZvcihsZXQgbT1nLGg9eDttPGg7bSs9Myl7Y29uc3QgVD1tLHk9bSsxLF89bSsyO3I9U2kodGhpcyxvLGUsaSxjLHUsZCxULHksXyksciYmKHIuZmFjZUluZGV4PU1hdGguZmxvb3IobS8zKSx0LnB1c2gocikpfX19fWZ1bmN0aW9uIENhKG4sZSx0LGkscixzLG8sYSl7bGV0IGw7aWYoZS5zaWRlPT09MT9sPWkuaW50ZXJzZWN0VHJpYW5nbGUobyxzLHIsITAsYSk6bD1pLmludGVyc2VjdFRyaWFuZ2xlKHIscyxvLGUuc2lkZT09PTAsYSksbD09PW51bGwpcmV0dXJuIG51bGw7TWkuY29weShhKSxNaS5hcHBseU1hdHJpeDQobi5tYXRyaXhXb3JsZCk7Y29uc3QgYz10LnJheS5vcmlnaW4uZGlzdGFuY2VUbyhNaSk7cmV0dXJuIGM8dC5uZWFyfHxjPnQuZmFyP251bGw6e2Rpc3RhbmNlOmMscG9pbnQ6TWkuY2xvbmUoKSxvYmplY3Q6bn19ZnVuY3Rpb24gU2kobixlLHQsaSxyLHMsbyxhLGwsYyl7bi5nZXRWZXJ0ZXhQb3NpdGlvbihhLGdpKSxuLmdldFZlcnRleFBvc2l0aW9uKGwsX2kpLG4uZ2V0VmVydGV4UG9zaXRpb24oYyx2aSk7Y29uc3QgdT1DYShuLGUsdCxpLGdpLF9pLHZpLFlyKTtpZih1KXtjb25zdCBkPW5ldyBPO0l0LmdldEJhcnljb29yZChZcixnaSxfaSx2aSxkKSxyJiYodS51dj1JdC5nZXRJbnRlcnBvbGF0ZWRBdHRyaWJ1dGUocixhLGwsYyxkLG5ldyBQZSkpLHMmJih1LnV2MT1JdC5nZXRJbnRlcnBvbGF0ZWRBdHRyaWJ1dGUocyxhLGwsYyxkLG5ldyBQZSkpLG8mJih1Lm5vcm1hbD1JdC5nZXRJbnRlcnBvbGF0ZWRBdHRyaWJ1dGUobyxhLGwsYyxkLG5ldyBPKSx1Lm5vcm1hbC5kb3QoaS5kaXJlY3Rpb24pPjAmJnUubm9ybWFsLm11bHRpcGx5U2NhbGFyKC0xKSk7Y29uc3QgZj17YSxiOmwsYyxub3JtYWw6bmV3IE8sbWF0ZXJpYWxJbmRleDowfTtJdC5nZXROb3JtYWwoZ2ksX2ksdmksZi5ub3JtYWwpLHUuZmFjZT1mLHUuYmFyeWNvb3JkPWR9cmV0dXJuIHV9Y2xhc3MgUW4gZXh0ZW5kcyBDdHtjb25zdHJ1Y3RvcihlPTEsdD0xLGk9MSxyPTEscz0xLG89MSl7c3VwZXIoKSx0aGlzLnR5cGU9IkJveEdlb21ldHJ5Iix0aGlzLnBhcmFtZXRlcnM9e3dpZHRoOmUsaGVpZ2h0OnQsZGVwdGg6aSx3aWR0aFNlZ21lbnRzOnIsaGVpZ2h0U2VnbWVudHM6cyxkZXB0aFNlZ21lbnRzOm99O2NvbnN0IGE9dGhpcztyPU1hdGguZmxvb3Iocikscz1NYXRoLmZsb29yKHMpLG89TWF0aC5mbG9vcihvKTtjb25zdCBsPVtdLGM9W10sdT1bXSxkPVtdO2xldCBmPTAscD0wO2coInoiLCJ5IiwieCIsLTEsLTEsaSx0LGUsbyxzLDApLGcoInoiLCJ5IiwieCIsMSwtMSxpLHQsLWUsbyxzLDEpLGcoIngiLCJ6IiwieSIsMSwxLGUsaSx0LHIsbywyKSxnKCJ4IiwieiIsInkiLDEsLTEsZSxpLC10LHIsbywzKSxnKCJ4IiwieSIsInoiLDEsLTEsZSx0LGkscixzLDQpLGcoIngiLCJ5IiwieiIsLTEsLTEsZSx0LC1pLHIscyw1KSx0aGlzLnNldEluZGV4KGwpLHRoaXMuc2V0QXR0cmlidXRlKCJwb3NpdGlvbiIsbmV3IHVuKGMsMykpLHRoaXMuc2V0QXR0cmlidXRlKCJub3JtYWwiLG5ldyB1bih1LDMpKSx0aGlzLnNldEF0dHJpYnV0ZSgidXYiLG5ldyB1bihkLDIpKTtmdW5jdGlvbiBnKHgsbSxoLFQseSxfLEMsdyxiLEYsRSl7Y29uc3QgUz1fL2IsUj1DL0YscT1fLzIsej1DLzIsVz13LzIsWj1iKzEsVj1GKzE7bGV0IFE9MCxIPTA7Y29uc3QgaWU9bmV3IE87Zm9yKGxldCBjZT0wO2NlPFY7Y2UrKyl7Y29uc3QgeGU9Y2UqUi16O2ZvcihsZXQgVWU9MDtVZTxaO1VlKyspe2NvbnN0IFllPVVlKlMtcTtpZVt4XT1ZZSpULGllW21dPXhlKnksaWVbaF09VyxjLnB1c2goaWUueCxpZS55LGllLnopLGllW3hdPTAsaWVbbV09MCxpZVtoXT13PjA/MTotMSx1LnB1c2goaWUueCxpZS55LGllLnopLGQucHVzaChVZS9iKSxkLnB1c2goMS1jZS9GKSxRKz0xfX1mb3IobGV0IGNlPTA7Y2U8RjtjZSsrKWZvcihsZXQgeGU9MDt4ZTxiO3hlKyspe2NvbnN0IFVlPWYreGUrWipjZSxZZT1mK3hlK1oqKGNlKzEpLFg9ZisoeGUrMSkrWiooY2UrMSksZWU9ZisoeGUrMSkrWipjZTtsLnB1c2goVWUsWWUsZWUpLGwucHVzaChZZSxYLGVlKSxIKz02fWEuYWRkR3JvdXAocCxILEUpLHArPUgsZis9UX19Y29weShlKXtyZXR1cm4gc3VwZXIuY29weShlKSx0aGlzLnBhcmFtZXRlcnM9T2JqZWN0LmFzc2lnbih7fSxlLnBhcmFtZXRlcnMpLHRoaXN9c3RhdGljIGZyb21KU09OKGUpe3JldHVybiBuZXcgUW4oZS53aWR0aCxlLmhlaWdodCxlLmRlcHRoLGUud2lkdGhTZWdtZW50cyxlLmhlaWdodFNlZ21lbnRzLGUuZGVwdGhTZWdtZW50cyl9fWZ1bmN0aW9uIEZuKG4pe2NvbnN0IGU9e307Zm9yKGNvbnN0IHQgaW4gbil7ZVt0XT17fTtmb3IoY29uc3QgaSBpbiBuW3RdKXtjb25zdCByPW5bdF1baV07ciYmKHIuaXNDb2xvcnx8ci5pc01hdHJpeDN8fHIuaXNNYXRyaXg0fHxyLmlzVmVjdG9yMnx8ci5pc1ZlY3RvcjN8fHIuaXNWZWN0b3I0fHxyLmlzVGV4dHVyZXx8ci5pc1F1YXRlcm5pb24pP3IuaXNSZW5kZXJUYXJnZXRUZXh0dXJlPyhjb25zb2xlLndhcm4oIlVuaWZvcm1zVXRpbHM6IFRleHR1cmVzIG9mIHJlbmRlciB0YXJnZXRzIGNhbm5vdCBiZSBjbG9uZWQgdmlhIGNsb25lVW5pZm9ybXMoKSBvciBtZXJnZVVuaWZvcm1zKCkuIiksZVt0XVtpXT1udWxsKTplW3RdW2ldPXIuY2xvbmUoKTpBcnJheS5pc0FycmF5KHIpP2VbdF1baV09ci5zbGljZSgpOmVbdF1baV09cn19cmV0dXJuIGV9ZnVuY3Rpb24geHQobil7Y29uc3QgZT17fTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyl7Y29uc3QgaT1GbihuW3RdKTtmb3IoY29uc3QgciBpbiBpKWVbcl09aVtyXX1yZXR1cm4gZX1mdW5jdGlvbiBQYShuKXtjb25zdCBlPVtdO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWUucHVzaChuW3RdLmNsb25lKCkpO3JldHVybiBlfWZ1bmN0aW9uICRyKG4pe2NvbnN0IGU9bi5nZXRSZW5kZXJUYXJnZXQoKTtyZXR1cm4gZT09PW51bGw/bi5vdXRwdXRDb2xvclNwYWNlOmUuaXNYUlJlbmRlclRhcmdldD09PSEwP2UudGV4dHVyZS5jb2xvclNwYWNlOkJlLndvcmtpbmdDb2xvclNwYWNlfWNvbnN0IERhPXtjbG9uZTpGbixtZXJnZTp4dH07dmFyIExhPWB2b2lkIG1haW4oKSB7CglnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7Cn1gLFVhPWB2b2lkIG1haW4oKSB7CglnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMC4wLCAxLjAgKTsKfWA7Y2xhc3MgbHQgZXh0ZW5kcyBabntzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iU2hhZGVyTWF0ZXJpYWwifWNvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5pc1NoYWRlck1hdGVyaWFsPSEwLHRoaXMuZGVmaW5lcz17fSx0aGlzLnVuaWZvcm1zPXt9LHRoaXMudW5pZm9ybXNHcm91cHM9W10sdGhpcy52ZXJ0ZXhTaGFkZXI9TGEsdGhpcy5mcmFnbWVudFNoYWRlcj1VYSx0aGlzLmxpbmV3aWR0aD0xLHRoaXMud2lyZWZyYW1lPSExLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPTEsdGhpcy5mb2c9ITEsdGhpcy5saWdodHM9ITEsdGhpcy5jbGlwcGluZz0hMSx0aGlzLmZvcmNlU2luZ2xlUGFzcz0hMCx0aGlzLmV4dGVuc2lvbnM9e2NsaXBDdWxsRGlzdGFuY2U6ITEsbXVsdGlEcmF3OiExfSx0aGlzLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXM9e2NvbG9yOlsxLDEsMV0sdXY6WzAsMF0sdXYxOlswLDBdfSx0aGlzLmluZGV4MEF0dHJpYnV0ZU5hbWU9dm9pZCAwLHRoaXMudW5pZm9ybXNOZWVkVXBkYXRlPSExLHRoaXMuZ2xzbFZlcnNpb249bnVsbCxlIT09dm9pZCAwJiZ0aGlzLnNldFZhbHVlcyhlKX1jb3B5KGUpe3JldHVybiBzdXBlci5jb3B5KGUpLHRoaXMuZnJhZ21lbnRTaGFkZXI9ZS5mcmFnbWVudFNoYWRlcix0aGlzLnZlcnRleFNoYWRlcj1lLnZlcnRleFNoYWRlcix0aGlzLnVuaWZvcm1zPUZuKGUudW5pZm9ybXMpLHRoaXMudW5pZm9ybXNHcm91cHM9UGEoZS51bmlmb3Jtc0dyb3VwcyksdGhpcy5kZWZpbmVzPU9iamVjdC5hc3NpZ24oe30sZS5kZWZpbmVzKSx0aGlzLndpcmVmcmFtZT1lLndpcmVmcmFtZSx0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD1lLndpcmVmcmFtZUxpbmV3aWR0aCx0aGlzLmZvZz1lLmZvZyx0aGlzLmxpZ2h0cz1lLmxpZ2h0cyx0aGlzLmNsaXBwaW5nPWUuY2xpcHBpbmcsdGhpcy5leHRlbnNpb25zPU9iamVjdC5hc3NpZ24oe30sZS5leHRlbnNpb25zKSx0aGlzLmdsc2xWZXJzaW9uPWUuZ2xzbFZlcnNpb24sdGhpc310b0pTT04oZSl7Y29uc3QgdD1zdXBlci50b0pTT04oZSk7dC5nbHNsVmVyc2lvbj10aGlzLmdsc2xWZXJzaW9uLHQudW5pZm9ybXM9e307Zm9yKGNvbnN0IHIgaW4gdGhpcy51bmlmb3Jtcyl7Y29uc3Qgbz10aGlzLnVuaWZvcm1zW3JdLnZhbHVlO28mJm8uaXNUZXh0dXJlP3QudW5pZm9ybXNbcl09e3R5cGU6InQiLHZhbHVlOm8udG9KU09OKGUpLnV1aWR9Om8mJm8uaXNDb2xvcj90LnVuaWZvcm1zW3JdPXt0eXBlOiJjIix2YWx1ZTpvLmdldEhleCgpfTpvJiZvLmlzVmVjdG9yMj90LnVuaWZvcm1zW3JdPXt0eXBlOiJ2MiIsdmFsdWU6by50b0FycmF5KCl9Om8mJm8uaXNWZWN0b3IzP3QudW5pZm9ybXNbcl09e3R5cGU6InYzIix2YWx1ZTpvLnRvQXJyYXkoKX06byYmby5pc1ZlY3RvcjQ/dC51bmlmb3Jtc1tyXT17dHlwZToidjQiLHZhbHVlOm8udG9BcnJheSgpfTpvJiZvLmlzTWF0cml4Mz90LnVuaWZvcm1zW3JdPXt0eXBlOiJtMyIsdmFsdWU6by50b0FycmF5KCl9Om8mJm8uaXNNYXRyaXg0P3QudW5pZm9ybXNbcl09e3R5cGU6Im00Iix2YWx1ZTpvLnRvQXJyYXkoKX06dC51bmlmb3Jtc1tyXT17dmFsdWU6b319T2JqZWN0LmtleXModGhpcy5kZWZpbmVzKS5sZW5ndGg+MCYmKHQuZGVmaW5lcz10aGlzLmRlZmluZXMpLHQudmVydGV4U2hhZGVyPXRoaXMudmVydGV4U2hhZGVyLHQuZnJhZ21lbnRTaGFkZXI9dGhpcy5mcmFnbWVudFNoYWRlcix0LmxpZ2h0cz10aGlzLmxpZ2h0cyx0LmNsaXBwaW5nPXRoaXMuY2xpcHBpbmc7Y29uc3QgaT17fTtmb3IoY29uc3QgciBpbiB0aGlzLmV4dGVuc2lvbnMpdGhpcy5leHRlbnNpb25zW3JdPT09ITAmJihpW3JdPSEwKTtyZXR1cm4gT2JqZWN0LmtleXMoaSkubGVuZ3RoPjAmJih0LmV4dGVuc2lvbnM9aSksdH19Y2xhc3MgS3IgZXh0ZW5kcyBNdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5pc0NhbWVyYT0hMCx0aGlzLnR5cGU9IkNhbWVyYSIsdGhpcy5tYXRyaXhXb3JsZEludmVyc2U9bmV3IHN0LHRoaXMucHJvamVjdGlvbk1hdHJpeD1uZXcgc3QsdGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZT1uZXcgc3QsdGhpcy5jb29yZGluYXRlU3lzdGVtPTJlM31jb3B5KGUsdCl7cmV0dXJuIHN1cGVyLmNvcHkoZSx0KSx0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KGUubWF0cml4V29ybGRJbnZlcnNlKSx0aGlzLnByb2plY3Rpb25NYXRyaXguY29weShlLnByb2plY3Rpb25NYXRyaXgpLHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weShlLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKSx0aGlzLmNvb3JkaW5hdGVTeXN0ZW09ZS5jb29yZGluYXRlU3lzdGVtLHRoaXN9Z2V0V29ybGREaXJlY3Rpb24oZSl7cmV0dXJuIHN1cGVyLmdldFdvcmxkRGlyZWN0aW9uKGUpLm5lZ2F0ZSgpfXVwZGF0ZU1hdHJpeFdvcmxkKGUpe3N1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKGUpLHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkodGhpcy5tYXRyaXhXb3JsZCkuaW52ZXJ0KCl9dXBkYXRlV29ybGRNYXRyaXgoZSx0KXtzdXBlci51cGRhdGVXb3JsZE1hdHJpeChlLHQpLHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkodGhpcy5tYXRyaXhXb3JsZCkuaW52ZXJ0KCl9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfX1jb25zdCBzbj1uZXcgTyxacj1uZXcgUGUsanI9bmV3IFBlO2NsYXNzIE50IGV4dGVuZHMgS3J7Y29uc3RydWN0b3IoZT01MCx0PTEsaT0uMSxyPTJlMyl7c3VwZXIoKSx0aGlzLmlzUGVyc3BlY3RpdmVDYW1lcmE9ITAsdGhpcy50eXBlPSJQZXJzcGVjdGl2ZUNhbWVyYSIsdGhpcy5mb3Y9ZSx0aGlzLnpvb209MSx0aGlzLm5lYXI9aSx0aGlzLmZhcj1yLHRoaXMuZm9jdXM9MTAsdGhpcy5hc3BlY3Q9dCx0aGlzLnZpZXc9bnVsbCx0aGlzLmZpbG1HYXVnZT0zNSx0aGlzLmZpbG1PZmZzZXQ9MCx0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX1jb3B5KGUsdCl7cmV0dXJuIHN1cGVyLmNvcHkoZSx0KSx0aGlzLmZvdj1lLmZvdix0aGlzLnpvb209ZS56b29tLHRoaXMubmVhcj1lLm5lYXIsdGhpcy5mYXI9ZS5mYXIsdGhpcy5mb2N1cz1lLmZvY3VzLHRoaXMuYXNwZWN0PWUuYXNwZWN0LHRoaXMudmlldz1lLnZpZXc9PT1udWxsP251bGw6T2JqZWN0LmFzc2lnbih7fSxlLnZpZXcpLHRoaXMuZmlsbUdhdWdlPWUuZmlsbUdhdWdlLHRoaXMuZmlsbU9mZnNldD1lLmZpbG1PZmZzZXQsdGhpc31zZXRGb2NhbExlbmd0aChlKXtjb25zdCB0PS41KnRoaXMuZ2V0RmlsbUhlaWdodCgpL2U7dGhpcy5mb3Y9Vm4qMipNYXRoLmF0YW4odCksdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9Z2V0Rm9jYWxMZW5ndGgoKXtjb25zdCBlPU1hdGgudGFuKEhuKi41KnRoaXMuZm92KTtyZXR1cm4gLjUqdGhpcy5nZXRGaWxtSGVpZ2h0KCkvZX1nZXRFZmZlY3RpdmVGT1YoKXtyZXR1cm4gVm4qMipNYXRoLmF0YW4oTWF0aC50YW4oSG4qLjUqdGhpcy5mb3YpL3RoaXMuem9vbSl9Z2V0RmlsbVdpZHRoKCl7cmV0dXJuIHRoaXMuZmlsbUdhdWdlKk1hdGgubWluKHRoaXMuYXNwZWN0LDEpfWdldEZpbG1IZWlnaHQoKXtyZXR1cm4gdGhpcy5maWxtR2F1Z2UvTWF0aC5tYXgodGhpcy5hc3BlY3QsMSl9Z2V0Vmlld0JvdW5kcyhlLHQsaSl7c24uc2V0KC0xLC0xLC41KS5hcHBseU1hdHJpeDQodGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSksdC5zZXQoc24ueCxzbi55KS5tdWx0aXBseVNjYWxhcigtZS9zbi56KSxzbi5zZXQoMSwxLC41KS5hcHBseU1hdHJpeDQodGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSksaS5zZXQoc24ueCxzbi55KS5tdWx0aXBseVNjYWxhcigtZS9zbi56KX1nZXRWaWV3U2l6ZShlLHQpe3JldHVybiB0aGlzLmdldFZpZXdCb3VuZHMoZSxacixqciksdC5zdWJWZWN0b3JzKGpyLFpyKX1zZXRWaWV3T2Zmc2V0KGUsdCxpLHIscyxvKXt0aGlzLmFzcGVjdD1lL3QsdGhpcy52aWV3PT09bnVsbCYmKHRoaXMudmlldz17ZW5hYmxlZDohMCxmdWxsV2lkdGg6MSxmdWxsSGVpZ2h0OjEsb2Zmc2V0WDowLG9mZnNldFk6MCx3aWR0aDoxLGhlaWdodDoxfSksdGhpcy52aWV3LmVuYWJsZWQ9ITAsdGhpcy52aWV3LmZ1bGxXaWR0aD1lLHRoaXMudmlldy5mdWxsSGVpZ2h0PXQsdGhpcy52aWV3Lm9mZnNldFg9aSx0aGlzLnZpZXcub2Zmc2V0WT1yLHRoaXMudmlldy53aWR0aD1zLHRoaXMudmlldy5oZWlnaHQ9byx0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX1jbGVhclZpZXdPZmZzZXQoKXt0aGlzLnZpZXchPT1udWxsJiYodGhpcy52aWV3LmVuYWJsZWQ9ITEpLHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfXVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKXtjb25zdCBlPXRoaXMubmVhcjtsZXQgdD1lKk1hdGgudGFuKEhuKi41KnRoaXMuZm92KS90aGlzLnpvb20saT0yKnQscj10aGlzLmFzcGVjdCppLHM9LS41KnI7Y29uc3Qgbz10aGlzLnZpZXc7aWYodGhpcy52aWV3IT09bnVsbCYmdGhpcy52aWV3LmVuYWJsZWQpe2NvbnN0IGw9by5mdWxsV2lkdGgsYz1vLmZ1bGxIZWlnaHQ7cys9by5vZmZzZXRYKnIvbCx0LT1vLm9mZnNldFkqaS9jLHIqPW8ud2lkdGgvbCxpKj1vLmhlaWdodC9jfWNvbnN0IGE9dGhpcy5maWxtT2Zmc2V0O2EhPT0wJiYocys9ZSphL3RoaXMuZ2V0RmlsbVdpZHRoKCkpLHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUocyxzK3IsdCx0LWksZSx0aGlzLmZhcix0aGlzLmNvb3JkaW5hdGVTeXN0ZW0pLHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSh0aGlzLnByb2plY3Rpb25NYXRyaXgpLmludmVydCgpfXRvSlNPTihlKXtjb25zdCB0PXN1cGVyLnRvSlNPTihlKTtyZXR1cm4gdC5vYmplY3QuZm92PXRoaXMuZm92LHQub2JqZWN0Lnpvb209dGhpcy56b29tLHQub2JqZWN0Lm5lYXI9dGhpcy5uZWFyLHQub2JqZWN0LmZhcj10aGlzLmZhcix0Lm9iamVjdC5mb2N1cz10aGlzLmZvY3VzLHQub2JqZWN0LmFzcGVjdD10aGlzLmFzcGVjdCx0aGlzLnZpZXchPT1udWxsJiYodC5vYmplY3Qudmlldz1PYmplY3QuYXNzaWduKHt9LHRoaXMudmlldykpLHQub2JqZWN0LmZpbG1HYXVnZT10aGlzLmZpbG1HYXVnZSx0Lm9iamVjdC5maWxtT2Zmc2V0PXRoaXMuZmlsbU9mZnNldCx0fX1jb25zdCBJbj0tOTAsTm49MTtjbGFzcyBGYSBleHRlbmRzIE10e2NvbnN0cnVjdG9yKGUsdCxpKXtzdXBlcigpLHRoaXMudHlwZT0iQ3ViZUNhbWVyYSIsdGhpcy5yZW5kZXJUYXJnZXQ9aSx0aGlzLmNvb3JkaW5hdGVTeXN0ZW09bnVsbCx0aGlzLmFjdGl2ZU1pcG1hcExldmVsPTA7Y29uc3Qgcj1uZXcgTnQoSW4sTm4sZSx0KTtyLmxheWVycz10aGlzLmxheWVycyx0aGlzLmFkZChyKTtjb25zdCBzPW5ldyBOdChJbixObixlLHQpO3MubGF5ZXJzPXRoaXMubGF5ZXJzLHRoaXMuYWRkKHMpO2NvbnN0IG89bmV3IE50KEluLE5uLGUsdCk7by5sYXllcnM9dGhpcy5sYXllcnMsdGhpcy5hZGQobyk7Y29uc3QgYT1uZXcgTnQoSW4sTm4sZSx0KTthLmxheWVycz10aGlzLmxheWVycyx0aGlzLmFkZChhKTtjb25zdCBsPW5ldyBOdChJbixObixlLHQpO2wubGF5ZXJzPXRoaXMubGF5ZXJzLHRoaXMuYWRkKGwpO2NvbnN0IGM9bmV3IE50KEluLE5uLGUsdCk7Yy5sYXllcnM9dGhpcy5sYXllcnMsdGhpcy5hZGQoYyl9dXBkYXRlQ29vcmRpbmF0ZVN5c3RlbSgpe2NvbnN0IGU9dGhpcy5jb29yZGluYXRlU3lzdGVtLHQ9dGhpcy5jaGlsZHJlbi5jb25jYXQoKSxbaSxyLHMsbyxhLGxdPXQ7Zm9yKGNvbnN0IGMgb2YgdCl0aGlzLnJlbW92ZShjKTtpZihlPT09MmUzKWkudXAuc2V0KDAsMSwwKSxpLmxvb2tBdCgxLDAsMCksci51cC5zZXQoMCwxLDApLHIubG9va0F0KC0xLDAsMCkscy51cC5zZXQoMCwwLC0xKSxzLmxvb2tBdCgwLDEsMCksby51cC5zZXQoMCwwLDEpLG8ubG9va0F0KDAsLTEsMCksYS51cC5zZXQoMCwxLDApLGEubG9va0F0KDAsMCwxKSxsLnVwLnNldCgwLDEsMCksbC5sb29rQXQoMCwwLC0xKTtlbHNlIGlmKGU9PT0yMDAxKWkudXAuc2V0KDAsLTEsMCksaS5sb29rQXQoLTEsMCwwKSxyLnVwLnNldCgwLC0xLDApLHIubG9va0F0KDEsMCwwKSxzLnVwLnNldCgwLDAsMSkscy5sb29rQXQoMCwxLDApLG8udXAuc2V0KDAsMCwtMSksby5sb29rQXQoMCwtMSwwKSxhLnVwLnNldCgwLC0xLDApLGEubG9va0F0KDAsMCwxKSxsLnVwLnNldCgwLC0xLDApLGwubG9va0F0KDAsMCwtMSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLkN1YmVDYW1lcmEudXBkYXRlQ29vcmRpbmF0ZVN5c3RlbSgpOiBJbnZhbGlkIGNvb3JkaW5hdGUgc3lzdGVtOiAiK2UpO2Zvcihjb25zdCBjIG9mIHQpdGhpcy5hZGQoYyksYy51cGRhdGVNYXRyaXhXb3JsZCgpfXVwZGF0ZShlLHQpe3RoaXMucGFyZW50PT09bnVsbCYmdGhpcy51cGRhdGVNYXRyaXhXb3JsZCgpO2NvbnN0e3JlbmRlclRhcmdldDppLGFjdGl2ZU1pcG1hcExldmVsOnJ9PXRoaXM7dGhpcy5jb29yZGluYXRlU3lzdGVtIT09ZS5jb29yZGluYXRlU3lzdGVtJiYodGhpcy5jb29yZGluYXRlU3lzdGVtPWUuY29vcmRpbmF0ZVN5c3RlbSx0aGlzLnVwZGF0ZUNvb3JkaW5hdGVTeXN0ZW0oKSk7Y29uc3RbcyxvLGEsbCxjLHVdPXRoaXMuY2hpbGRyZW4sZD1lLmdldFJlbmRlclRhcmdldCgpLGY9ZS5nZXRBY3RpdmVDdWJlRmFjZSgpLHA9ZS5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpLGc9ZS54ci5lbmFibGVkO2UueHIuZW5hYmxlZD0hMTtjb25zdCB4PWkudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7aS50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcz0hMSxlLnNldFJlbmRlclRhcmdldChpLDAsciksZS5yZW5kZXIodCxzKSxlLnNldFJlbmRlclRhcmdldChpLDEsciksZS5yZW5kZXIodCxvKSxlLnNldFJlbmRlclRhcmdldChpLDIsciksZS5yZW5kZXIodCxhKSxlLnNldFJlbmRlclRhcmdldChpLDMsciksZS5yZW5kZXIodCxsKSxlLnNldFJlbmRlclRhcmdldChpLDQsciksZS5yZW5kZXIodCxjKSxpLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzPXgsZS5zZXRSZW5kZXJUYXJnZXQoaSw1LHIpLGUucmVuZGVyKHQsdSksZS5zZXRSZW5kZXJUYXJnZXQoZCxmLHApLGUueHIuZW5hYmxlZD1nLGkudGV4dHVyZS5uZWVkc1BNUkVNVXBkYXRlPSEwfX1jbGFzcyBKciBleHRlbmRzIHZ0e2NvbnN0cnVjdG9yKGUsdCxpLHIscyxvLGEsbCxjLHUpe2U9ZSE9PXZvaWQgMD9lOltdLHQ9dCE9PXZvaWQgMD90OjMwMSxzdXBlcihlLHQsaSxyLHMsbyxhLGwsYyx1KSx0aGlzLmlzQ3ViZVRleHR1cmU9ITAsdGhpcy5mbGlwWT0hMX1nZXQgaW1hZ2VzKCl7cmV0dXJuIHRoaXMuaW1hZ2V9c2V0IGltYWdlcyhlKXt0aGlzLmltYWdlPWV9fWNsYXNzIElhIGV4dGVuZHMgSnR7Y29uc3RydWN0b3IoZT0xLHQ9e30pe3N1cGVyKGUsZSx0KSx0aGlzLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0PSEwO2NvbnN0IGk9e3dpZHRoOmUsaGVpZ2h0OmUsZGVwdGg6MX0scj1baSxpLGksaSxpLGldO3RoaXMudGV4dHVyZT1uZXcgSnIocix0Lm1hcHBpbmcsdC53cmFwUyx0LndyYXBULHQubWFnRmlsdGVyLHQubWluRmlsdGVyLHQuZm9ybWF0LHQudHlwZSx0LmFuaXNvdHJvcHksdC5jb2xvclNwYWNlKSx0aGlzLnRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlPSEwLHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM9dC5nZW5lcmF0ZU1pcG1hcHMhPT12b2lkIDA/dC5nZW5lcmF0ZU1pcG1hcHM6ITEsdGhpcy50ZXh0dXJlLm1pbkZpbHRlcj10Lm1pbkZpbHRlciE9PXZvaWQgMD90Lm1pbkZpbHRlcjoxMDA2fWZyb21FcXVpcmVjdGFuZ3VsYXJUZXh0dXJlKGUsdCl7dGhpcy50ZXh0dXJlLnR5cGU9dC50eXBlLHRoaXMudGV4dHVyZS5jb2xvclNwYWNlPXQuY29sb3JTcGFjZSx0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzPXQuZ2VuZXJhdGVNaXBtYXBzLHRoaXMudGV4dHVyZS5taW5GaWx0ZXI9dC5taW5GaWx0ZXIsdGhpcy50ZXh0dXJlLm1hZ0ZpbHRlcj10Lm1hZ0ZpbHRlcjtjb25zdCBpPXt1bmlmb3Jtczp7dEVxdWlyZWN0Ont2YWx1ZTpudWxsfX0sdmVydGV4U2hhZGVyOmAKCgkJCQl2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uOwoKCQkJCXZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7CgoJCQkJCXJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggZGlyLCAwLjAgKSApLnh5eiApOwoKCQkJCX0KCgkJCQl2b2lkIG1haW4oKSB7CgoJCQkJCXZXb3JsZERpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7CgoJCQkJCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkJCQkJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoKCQkJCX0KCQkJYCxmcmFnbWVudFNoYWRlcjpgCgoJCQkJdW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0OwoKCQkJCXZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247CgoJCQkJI2luY2x1ZGUgPGNvbW1vbj4KCgkJCQl2b2lkIG1haW4oKSB7CgoJCQkJCXZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGREaXJlY3Rpb24gKTsKCgkJCQkJdmVjMiBzYW1wbGVVViA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApOwoKCQkJCQlnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHRFcXVpcmVjdCwgc2FtcGxlVVYgKTsKCgkJCQl9CgkJCWB9LHI9bmV3IFFuKDUsNSw1KSxzPW5ldyBsdCh7bmFtZToiQ3ViZW1hcEZyb21FcXVpcmVjdCIsdW5pZm9ybXM6Rm4oaS51bmlmb3JtcyksdmVydGV4U2hhZGVyOmkudmVydGV4U2hhZGVyLGZyYWdtZW50U2hhZGVyOmkuZnJhZ21lbnRTaGFkZXIsc2lkZToxLGJsZW5kaW5nOjB9KTtzLnVuaWZvcm1zLnRFcXVpcmVjdC52YWx1ZT10O2NvbnN0IG89bmV3IHR0KHIscyksYT10Lm1pbkZpbHRlcjtyZXR1cm4gdC5taW5GaWx0ZXI9PT0xMDA4JiYodC5taW5GaWx0ZXI9MTAwNiksbmV3IEZhKDEsMTAsdGhpcykudXBkYXRlKGUsbyksdC5taW5GaWx0ZXI9YSxvLmdlb21ldHJ5LmRpc3Bvc2UoKSxvLm1hdGVyaWFsLmRpc3Bvc2UoKSx0aGlzfWNsZWFyKGUsdCxpLHIpe2NvbnN0IHM9ZS5nZXRSZW5kZXJUYXJnZXQoKTtmb3IobGV0IG89MDtvPDY7bysrKWUuc2V0UmVuZGVyVGFyZ2V0KHRoaXMsbyksZS5jbGVhcih0LGkscik7ZS5zZXRSZW5kZXJUYXJnZXQocyl9fWNvbnN0IGlyPW5ldyBPLE5hPW5ldyBPLE9hPW5ldyBiZTtjbGFzcyBkbntjb25zdHJ1Y3RvcihlPW5ldyBPKDEsMCwwKSx0PTApe3RoaXMuaXNQbGFuZT0hMCx0aGlzLm5vcm1hbD1lLHRoaXMuY29uc3RhbnQ9dH1zZXQoZSx0KXtyZXR1cm4gdGhpcy5ub3JtYWwuY29weShlKSx0aGlzLmNvbnN0YW50PXQsdGhpc31zZXRDb21wb25lbnRzKGUsdCxpLHIpe3JldHVybiB0aGlzLm5vcm1hbC5zZXQoZSx0LGkpLHRoaXMuY29uc3RhbnQ9cix0aGlzfXNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KGUsdCl7cmV0dXJuIHRoaXMubm9ybWFsLmNvcHkoZSksdGhpcy5jb25zdGFudD0tdC5kb3QodGhpcy5ub3JtYWwpLHRoaXN9c2V0RnJvbUNvcGxhbmFyUG9pbnRzKGUsdCxpKXtjb25zdCByPWlyLnN1YlZlY3RvcnMoaSx0KS5jcm9zcyhOYS5zdWJWZWN0b3JzKGUsdCkpLm5vcm1hbGl6ZSgpO3JldHVybiB0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KHIsZSksdGhpc31jb3B5KGUpe3JldHVybiB0aGlzLm5vcm1hbC5jb3B5KGUubm9ybWFsKSx0aGlzLmNvbnN0YW50PWUuY29uc3RhbnQsdGhpc31ub3JtYWxpemUoKXtjb25zdCBlPTEvdGhpcy5ub3JtYWwubGVuZ3RoKCk7cmV0dXJuIHRoaXMubm9ybWFsLm11bHRpcGx5U2NhbGFyKGUpLHRoaXMuY29uc3RhbnQqPWUsdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy5jb25zdGFudCo9LTEsdGhpcy5ub3JtYWwubmVnYXRlKCksdGhpc31kaXN0YW5jZVRvUG9pbnQoZSl7cmV0dXJuIHRoaXMubm9ybWFsLmRvdChlKSt0aGlzLmNvbnN0YW50fWRpc3RhbmNlVG9TcGhlcmUoZSl7cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KGUuY2VudGVyKS1lLnJhZGl1c31wcm9qZWN0UG9pbnQoZSx0KXtyZXR1cm4gdC5jb3B5KGUpLmFkZFNjYWxlZFZlY3Rvcih0aGlzLm5vcm1hbCwtdGhpcy5kaXN0YW5jZVRvUG9pbnQoZSkpfWludGVyc2VjdExpbmUoZSx0KXtjb25zdCBpPWUuZGVsdGEoaXIpLHI9dGhpcy5ub3JtYWwuZG90KGkpO2lmKHI9PT0wKXJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludChlLnN0YXJ0KT09PTA/dC5jb3B5KGUuc3RhcnQpOm51bGw7Y29uc3Qgcz0tKGUuc3RhcnQuZG90KHRoaXMubm9ybWFsKSt0aGlzLmNvbnN0YW50KS9yO3JldHVybiBzPDB8fHM+MT9udWxsOnQuY29weShlLnN0YXJ0KS5hZGRTY2FsZWRWZWN0b3IoaSxzKX1pbnRlcnNlY3RzTGluZShlKXtjb25zdCB0PXRoaXMuZGlzdGFuY2VUb1BvaW50KGUuc3RhcnQpLGk9dGhpcy5kaXN0YW5jZVRvUG9pbnQoZS5lbmQpO3JldHVybiB0PDAmJmk+MHx8aTwwJiZ0PjB9aW50ZXJzZWN0c0JveChlKXtyZXR1cm4gZS5pbnRlcnNlY3RzUGxhbmUodGhpcyl9aW50ZXJzZWN0c1NwaGVyZShlKXtyZXR1cm4gZS5pbnRlcnNlY3RzUGxhbmUodGhpcyl9Y29wbGFuYXJQb2ludChlKXtyZXR1cm4gZS5jb3B5KHRoaXMubm9ybWFsKS5tdWx0aXBseVNjYWxhcigtdGhpcy5jb25zdGFudCl9YXBwbHlNYXRyaXg0KGUsdCl7Y29uc3QgaT10fHxPYS5nZXROb3JtYWxNYXRyaXgoZSkscj10aGlzLmNvcGxhbmFyUG9pbnQoaXIpLmFwcGx5TWF0cml4NChlKSxzPXRoaXMubm9ybWFsLmFwcGx5TWF0cml4MyhpKS5ub3JtYWxpemUoKTtyZXR1cm4gdGhpcy5jb25zdGFudD0tci5kb3QocyksdGhpc310cmFuc2xhdGUoZSl7cmV0dXJuIHRoaXMuY29uc3RhbnQtPWUuZG90KHRoaXMubm9ybWFsKSx0aGlzfWVxdWFscyhlKXtyZXR1cm4gZS5ub3JtYWwuZXF1YWxzKHRoaXMubm9ybWFsKSYmZS5jb25zdGFudD09PXRoaXMuY29uc3RhbnR9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfX1jb25zdCBmbj1uZXcgbGksRWk9bmV3IE87Y2xhc3MgUXJ7Y29uc3RydWN0b3IoZT1uZXcgZG4sdD1uZXcgZG4saT1uZXcgZG4scj1uZXcgZG4scz1uZXcgZG4sbz1uZXcgZG4pe3RoaXMucGxhbmVzPVtlLHQsaSxyLHMsb119c2V0KGUsdCxpLHIscyxvKXtjb25zdCBhPXRoaXMucGxhbmVzO3JldHVybiBhWzBdLmNvcHkoZSksYVsxXS5jb3B5KHQpLGFbMl0uY29weShpKSxhWzNdLmNvcHkociksYVs0XS5jb3B5KHMpLGFbNV0uY29weShvKSx0aGlzfWNvcHkoZSl7Y29uc3QgdD10aGlzLnBsYW5lcztmb3IobGV0IGk9MDtpPDY7aSsrKXRbaV0uY29weShlLnBsYW5lc1tpXSk7cmV0dXJuIHRoaXN9c2V0RnJvbVByb2plY3Rpb25NYXRyaXgoZSx0PTJlMyl7Y29uc3QgaT10aGlzLnBsYW5lcyxyPWUuZWxlbWVudHMscz1yWzBdLG89clsxXSxhPXJbMl0sbD1yWzNdLGM9cls0XSx1PXJbNV0sZD1yWzZdLGY9cls3XSxwPXJbOF0sZz1yWzldLHg9clsxMF0sbT1yWzExXSxoPXJbMTJdLFQ9clsxM10seT1yWzE0XSxfPXJbMTVdO2lmKGlbMF0uc2V0Q29tcG9uZW50cyhsLXMsZi1jLG0tcCxfLWgpLm5vcm1hbGl6ZSgpLGlbMV0uc2V0Q29tcG9uZW50cyhsK3MsZitjLG0rcCxfK2gpLm5vcm1hbGl6ZSgpLGlbMl0uc2V0Q29tcG9uZW50cyhsK28sZit1LG0rZyxfK1QpLm5vcm1hbGl6ZSgpLGlbM10uc2V0Q29tcG9uZW50cyhsLW8sZi11LG0tZyxfLVQpLm5vcm1hbGl6ZSgpLGlbNF0uc2V0Q29tcG9uZW50cyhsLWEsZi1kLG0teCxfLXkpLm5vcm1hbGl6ZSgpLHQ9PT0yZTMpaVs1XS5zZXRDb21wb25lbnRzKGwrYSxmK2QsbSt4LF8reSkubm9ybWFsaXplKCk7ZWxzZSBpZih0PT09MjAwMSlpWzVdLnNldENvbXBvbmVudHMoYSxkLHgseSkubm9ybWFsaXplKCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLkZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoKTogSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbTogIit0KTtyZXR1cm4gdGhpc31pbnRlcnNlY3RzT2JqZWN0KGUpe2lmKGUuYm91bmRpbmdTcGhlcmUhPT12b2lkIDApZS5ib3VuZGluZ1NwaGVyZT09PW51bGwmJmUuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksZm4uY29weShlLmJvdW5kaW5nU3BoZXJlKS5hcHBseU1hdHJpeDQoZS5tYXRyaXhXb3JsZCk7ZWxzZXtjb25zdCB0PWUuZ2VvbWV0cnk7dC5ib3VuZGluZ1NwaGVyZT09PW51bGwmJnQuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksZm4uY29weSh0LmJvdW5kaW5nU3BoZXJlKS5hcHBseU1hdHJpeDQoZS5tYXRyaXhXb3JsZCl9cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZShmbil9aW50ZXJzZWN0c1Nwcml0ZShlKXtyZXR1cm4gZm4uY2VudGVyLnNldCgwLDAsMCksZm4ucmFkaXVzPS43MDcxMDY3ODExODY1NDc2LGZuLmFwcGx5TWF0cml4NChlLm1hdHJpeFdvcmxkKSx0aGlzLmludGVyc2VjdHNTcGhlcmUoZm4pfWludGVyc2VjdHNTcGhlcmUoZSl7Y29uc3QgdD10aGlzLnBsYW5lcyxpPWUuY2VudGVyLHI9LWUucmFkaXVzO2ZvcihsZXQgcz0wO3M8NjtzKyspaWYodFtzXS5kaXN0YW5jZVRvUG9pbnQoaSk8cilyZXR1cm4hMTtyZXR1cm4hMH1pbnRlcnNlY3RzQm94KGUpe2NvbnN0IHQ9dGhpcy5wbGFuZXM7Zm9yKGxldCBpPTA7aTw2O2krKyl7Y29uc3Qgcj10W2ldO2lmKEVpLng9ci5ub3JtYWwueD4wP2UubWF4Lng6ZS5taW4ueCxFaS55PXIubm9ybWFsLnk+MD9lLm1heC55OmUubWluLnksRWkuej1yLm5vcm1hbC56PjA/ZS5tYXguejplLm1pbi56LHIuZGlzdGFuY2VUb1BvaW50KEVpKTwwKXJldHVybiExfXJldHVybiEwfWNvbnRhaW5zUG9pbnQoZSl7Y29uc3QgdD10aGlzLnBsYW5lcztmb3IobGV0IGk9MDtpPDY7aSsrKWlmKHRbaV0uZGlzdGFuY2VUb1BvaW50KGUpPDApcmV0dXJuITE7cmV0dXJuITB9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfX1mdW5jdGlvbiBlcygpe2xldCBuPW51bGwsZT0hMSx0PW51bGwsaT1udWxsO2Z1bmN0aW9uIHIocyxvKXt0KHMsbyksaT1uLnJlcXVlc3RBbmltYXRpb25GcmFtZShyKX1yZXR1cm57c3RhcnQ6ZnVuY3Rpb24oKXtlIT09ITAmJnQhPT1udWxsJiYoaT1uLnJlcXVlc3RBbmltYXRpb25GcmFtZShyKSxlPSEwKX0sc3RvcDpmdW5jdGlvbigpe24uY2FuY2VsQW5pbWF0aW9uRnJhbWUoaSksZT0hMX0sc2V0QW5pbWF0aW9uTG9vcDpmdW5jdGlvbihzKXt0PXN9LHNldENvbnRleHQ6ZnVuY3Rpb24ocyl7bj1zfX19ZnVuY3Rpb24gQmEobil7Y29uc3QgZT1uZXcgV2Vha01hcDtmdW5jdGlvbiB0KGEsbCl7Y29uc3QgYz1hLmFycmF5LHU9YS51c2FnZSxkPWMuYnl0ZUxlbmd0aCxmPW4uY3JlYXRlQnVmZmVyKCk7bi5iaW5kQnVmZmVyKGwsZiksbi5idWZmZXJEYXRhKGwsYyx1KSxhLm9uVXBsb2FkQ2FsbGJhY2soKTtsZXQgcDtpZihjIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KXA9bi5GTE9BVDtlbHNlIGlmKGMgaW5zdGFuY2VvZiBVaW50MTZBcnJheSlhLmlzRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZT9wPW4uSEFMRl9GTE9BVDpwPW4uVU5TSUdORURfU0hPUlQ7ZWxzZSBpZihjIGluc3RhbmNlb2YgSW50MTZBcnJheSlwPW4uU0hPUlQ7ZWxzZSBpZihjIGluc3RhbmNlb2YgVWludDMyQXJyYXkpcD1uLlVOU0lHTkVEX0lOVDtlbHNlIGlmKGMgaW5zdGFuY2VvZiBJbnQzMkFycmF5KXA9bi5JTlQ7ZWxzZSBpZihjIGluc3RhbmNlb2YgSW50OEFycmF5KXA9bi5CWVRFO2Vsc2UgaWYoYyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpcD1uLlVOU0lHTkVEX0JZVEU7ZWxzZSBpZihjIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpcD1uLlVOU0lHTkVEX0JZVEU7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLldlYkdMQXR0cmlidXRlczogVW5zdXBwb3J0ZWQgYnVmZmVyIGRhdGEgZm9ybWF0OiAiK2MpO3JldHVybntidWZmZXI6Zix0eXBlOnAsYnl0ZXNQZXJFbGVtZW50OmMuQllURVNfUEVSX0VMRU1FTlQsdmVyc2lvbjphLnZlcnNpb24sc2l6ZTpkfX1mdW5jdGlvbiBpKGEsbCxjKXtjb25zdCB1PWwuYXJyYXksZD1sLnVwZGF0ZVJhbmdlcztpZihuLmJpbmRCdWZmZXIoYyxhKSxkLmxlbmd0aD09PTApbi5idWZmZXJTdWJEYXRhKGMsMCx1KTtlbHNle2Quc29ydCgocCxnKT0+cC5zdGFydC1nLnN0YXJ0KTtsZXQgZj0wO2ZvcihsZXQgcD0xO3A8ZC5sZW5ndGg7cCsrKXtjb25zdCBnPWRbZl0seD1kW3BdO3guc3RhcnQ8PWcuc3RhcnQrZy5jb3VudCsxP2cuY291bnQ9TWF0aC5tYXgoZy5jb3VudCx4LnN0YXJ0K3guY291bnQtZy5zdGFydCk6KCsrZixkW2ZdPXgpfWQubGVuZ3RoPWYrMTtmb3IobGV0IHA9MCxnPWQubGVuZ3RoO3A8ZztwKyspe2NvbnN0IHg9ZFtwXTtuLmJ1ZmZlclN1YkRhdGEoYyx4LnN0YXJ0KnUuQllURVNfUEVSX0VMRU1FTlQsdSx4LnN0YXJ0LHguY291bnQpfWwuY2xlYXJVcGRhdGVSYW5nZXMoKX1sLm9uVXBsb2FkQ2FsbGJhY2soKX1mdW5jdGlvbiByKGEpe3JldHVybiBhLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUmJihhPWEuZGF0YSksZS5nZXQoYSl9ZnVuY3Rpb24gcyhhKXthLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUmJihhPWEuZGF0YSk7Y29uc3QgbD1lLmdldChhKTtsJiYobi5kZWxldGVCdWZmZXIobC5idWZmZXIpLGUuZGVsZXRlKGEpKX1mdW5jdGlvbiBvKGEsbCl7aWYoYS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlJiYoYT1hLmRhdGEpLGEuaXNHTEJ1ZmZlckF0dHJpYnV0ZSl7Y29uc3QgdT1lLmdldChhKTsoIXV8fHUudmVyc2lvbjxhLnZlcnNpb24pJiZlLnNldChhLHtidWZmZXI6YS5idWZmZXIsdHlwZTphLnR5cGUsYnl0ZXNQZXJFbGVtZW50OmEuZWxlbWVudFNpemUsdmVyc2lvbjphLnZlcnNpb259KTtyZXR1cm59Y29uc3QgYz1lLmdldChhKTtpZihjPT09dm9pZCAwKWUuc2V0KGEsdChhLGwpKTtlbHNlIGlmKGMudmVyc2lvbjxhLnZlcnNpb24pe2lmKGMuc2l6ZSE9PWEuYXJyYXkuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLldlYkdMQXR0cmlidXRlczogVGhlIHNpemUgb2YgdGhlIGJ1ZmZlciBhdHRyaWJ1dGUncyBhcnJheSBidWZmZXIgZG9lcyBub3QgbWF0Y2ggdGhlIG9yaWdpbmFsIHNpemUuIFJlc2l6aW5nIGJ1ZmZlciBhdHRyaWJ1dGVzIGlzIG5vdCBzdXBwb3J0ZWQuIik7aShjLmJ1ZmZlcixhLGwpLGMudmVyc2lvbj1hLnZlcnNpb259fXJldHVybntnZXQ6cixyZW1vdmU6cyx1cGRhdGU6b319Y2xhc3MgZXQgZXh0ZW5kcyBDdHtjb25zdHJ1Y3RvcihlPTEsdD0xLGk9MSxyPTEpe3N1cGVyKCksdGhpcy50eXBlPSJQbGFuZUdlb21ldHJ5Iix0aGlzLnBhcmFtZXRlcnM9e3dpZHRoOmUsaGVpZ2h0OnQsd2lkdGhTZWdtZW50czppLGhlaWdodFNlZ21lbnRzOnJ9O2NvbnN0IHM9ZS8yLG89dC8yLGE9TWF0aC5mbG9vcihpKSxsPU1hdGguZmxvb3IociksYz1hKzEsdT1sKzEsZD1lL2EsZj10L2wscD1bXSxnPVtdLHg9W10sbT1bXTtmb3IobGV0IGg9MDtoPHU7aCsrKXtjb25zdCBUPWgqZi1vO2ZvcihsZXQgeT0wO3k8Yzt5Kyspe2NvbnN0IF89eSpkLXM7Zy5wdXNoKF8sLVQsMCkseC5wdXNoKDAsMCwxKSxtLnB1c2goeS9hKSxtLnB1c2goMS1oL2wpfX1mb3IobGV0IGg9MDtoPGw7aCsrKWZvcihsZXQgVD0wO1Q8YTtUKyspe2NvbnN0IHk9VCtjKmgsXz1UK2MqKGgrMSksQz1UKzErYyooaCsxKSx3PVQrMStjKmg7cC5wdXNoKHksXyx3KSxwLnB1c2goXyxDLHcpfXRoaXMuc2V0SW5kZXgocCksdGhpcy5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgdW4oZywzKSksdGhpcy5zZXRBdHRyaWJ1dGUoIm5vcm1hbCIsbmV3IHVuKHgsMykpLHRoaXMuc2V0QXR0cmlidXRlKCJ1diIsbmV3IHVuKG0sMikpfWNvcHkoZSl7cmV0dXJuIHN1cGVyLmNvcHkoZSksdGhpcy5wYXJhbWV0ZXJzPU9iamVjdC5hc3NpZ24oe30sZS5wYXJhbWV0ZXJzKSx0aGlzfXN0YXRpYyBmcm9tSlNPTihlKXtyZXR1cm4gbmV3IGV0KGUud2lkdGgsZS5oZWlnaHQsZS53aWR0aFNlZ21lbnRzLGUuaGVpZ2h0U2VnbWVudHMpfX12YXIgemE9YCNpZmRlZiBVU0VfQUxQSEFIQVNICglpZiAoIGRpZmZ1c2VDb2xvci5hIDwgZ2V0QWxwaGFIYXNoVGhyZXNob2xkKCB2UG9zaXRpb24gKSApIGRpc2NhcmQ7CiNlbmRpZmAsR2E9YCNpZmRlZiBVU0VfQUxQSEFIQVNICgljb25zdCBmbG9hdCBBTFBIQV9IQVNIX1NDQUxFID0gMC4wNTsKCWZsb2F0IGhhc2gyRCggdmVjMiB2YWx1ZSApIHsKCQlyZXR1cm4gZnJhY3QoIDEuMGU0ICogc2luKCAxNy4wICogdmFsdWUueCArIDAuMSAqIHZhbHVlLnkgKSAqICggMC4xICsgYWJzKCBzaW4oIDEzLjAgKiB2YWx1ZS55ICsgdmFsdWUueCApICkgKSApOwoJfQoJZmxvYXQgaGFzaDNEKCB2ZWMzIHZhbHVlICkgewoJCXJldHVybiBoYXNoMkQoIHZlYzIoIGhhc2gyRCggdmFsdWUueHkgKSwgdmFsdWUueiApICk7Cgl9CglmbG9hdCBnZXRBbHBoYUhhc2hUaHJlc2hvbGQoIHZlYzMgcG9zaXRpb24gKSB7CgkJZmxvYXQgbWF4RGVyaXYgPSBtYXgoCgkJCWxlbmd0aCggZEZkeCggcG9zaXRpb24ueHl6ICkgKSwKCQkJbGVuZ3RoKCBkRmR5KCBwb3NpdGlvbi54eXogKSApCgkJKTsKCQlmbG9hdCBwaXhTY2FsZSA9IDEuMCAvICggQUxQSEFfSEFTSF9TQ0FMRSAqIG1heERlcml2ICk7CgkJdmVjMiBwaXhTY2FsZXMgPSB2ZWMyKAoJCQlleHAyKCBmbG9vciggbG9nMiggcGl4U2NhbGUgKSApICksCgkJCWV4cDIoIGNlaWwoIGxvZzIoIHBpeFNjYWxlICkgKSApCgkJKTsKCQl2ZWMyIGFscGhhID0gdmVjMigKCQkJaGFzaDNEKCBmbG9vciggcGl4U2NhbGVzLnggKiBwb3NpdGlvbi54eXogKSApLAoJCQloYXNoM0QoIGZsb29yKCBwaXhTY2FsZXMueSAqIHBvc2l0aW9uLnh5eiApICkKCQkpOwoJCWZsb2F0IGxlcnBGYWN0b3IgPSBmcmFjdCggbG9nMiggcGl4U2NhbGUgKSApOwoJCWZsb2F0IHggPSAoIDEuMCAtIGxlcnBGYWN0b3IgKSAqIGFscGhhLnggKyBsZXJwRmFjdG9yICogYWxwaGEueTsKCQlmbG9hdCBhID0gbWluKCBsZXJwRmFjdG9yLCAxLjAgLSBsZXJwRmFjdG9yICk7CgkJdmVjMyBjYXNlcyA9IHZlYzMoCgkJCXggKiB4IC8gKCAyLjAgKiBhICogKCAxLjAgLSBhICkgKSwKCQkJKCB4IC0gMC41ICogYSApIC8gKCAxLjAgLSBhICksCgkJCTEuMCAtICggKCAxLjAgLSB4ICkgKiAoIDEuMCAtIHggKSAvICggMi4wICogYSAqICggMS4wIC0gYSApICkgKQoJCSk7CgkJZmxvYXQgdGhyZXNob2xkID0gKCB4IDwgKCAxLjAgLSBhICkgKQoJCQk/ICggKCB4IDwgYSApID8gY2FzZXMueCA6IGNhc2VzLnkgKQoJCQk6IGNhc2VzLno7CgkJcmV0dXJuIGNsYW1wKCB0aHJlc2hvbGQgLCAxLjBlLTYsIDEuMCApOwoJfQojZW5kaWZgLEhhPWAjaWZkZWYgVVNFX0FMUEhBTUFQCglkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB2QWxwaGFNYXBVdiApLmc7CiNlbmRpZmAsVmE9YCNpZmRlZiBVU0VfQUxQSEFNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwOwojZW5kaWZgLGthPWAjaWZkZWYgVVNFX0FMUEhBVEVTVAoJI2lmZGVmIEFMUEhBX1RPX0NPVkVSQUdFCglkaWZmdXNlQ29sb3IuYSA9IHNtb290aHN0ZXAoIGFscGhhVGVzdCwgYWxwaGFUZXN0ICsgZndpZHRoKCBkaWZmdXNlQ29sb3IuYSApLCBkaWZmdXNlQ29sb3IuYSApOwoJaWYgKCBkaWZmdXNlQ29sb3IuYSA9PSAwLjAgKSBkaXNjYXJkOwoJI2Vsc2UKCWlmICggZGlmZnVzZUNvbG9yLmEgPCBhbHBoYVRlc3QgKSBkaXNjYXJkOwoJI2VuZGlmCiNlbmRpZmAsV2E9YCNpZmRlZiBVU0VfQUxQSEFURVNUCgl1bmlmb3JtIGZsb2F0IGFscGhhVGVzdDsKI2VuZGlmYCxYYT1gI2lmZGVmIFVTRV9BT01BUAoJZmxvYXQgYW1iaWVudE9jY2x1c2lvbiA9ICggdGV4dHVyZTJEKCBhb01hcCwgdkFvTWFwVXYgKS5yIC0gMS4wICkgKiBhb01hcEludGVuc2l0eSArIDEuMDsKCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBhbWJpZW50T2NjbHVzaW9uOwoJI2lmIGRlZmluZWQoIFVTRV9DTEVBUkNPQVQgKSAKCQljbGVhcmNvYXRTcGVjdWxhckluZGlyZWN0ICo9IGFtYmllbnRPY2NsdXNpb247CgkjZW5kaWYKCSNpZiBkZWZpbmVkKCBVU0VfU0hFRU4gKSAKCQlzaGVlblNwZWN1bGFySW5kaXJlY3QgKj0gYW1iaWVudE9jY2x1c2lvbjsKCSNlbmRpZgoJI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBTVEFOREFSRCApCgkJZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyICkgKTsKCQlyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICo9IGNvbXB1dGVTcGVjdWxhck9jY2x1c2lvbiggZG90TlYsIGFtYmllbnRPY2NsdXNpb24sIG1hdGVyaWFsLnJvdWdobmVzcyApOwoJI2VuZGlmCiNlbmRpZmAscWE9YCNpZmRlZiBVU0VfQU9NQVAKCXVuaWZvcm0gc2FtcGxlcjJEIGFvTWFwOwoJdW5pZm9ybSBmbG9hdCBhb01hcEludGVuc2l0eTsKI2VuZGlmYCxZYT1gI2lmZGVmIFVTRV9CQVRDSElORwoJI2lmICEgZGVmaW5lZCggR0xfQU5HTEVfbXVsdGlfZHJhdyApCgkjZGVmaW5lIGdsX0RyYXdJRCBfZ2xfRHJhd0lECgl1bmlmb3JtIGludCBfZ2xfRHJhd0lEOwoJI2VuZGlmCgl1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBiYXRjaGluZ1RleHR1cmU7Cgl1bmlmb3JtIGhpZ2hwIHVzYW1wbGVyMkQgYmF0Y2hpbmdJZFRleHR1cmU7CgltYXQ0IGdldEJhdGNoaW5nTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkgewoJCWludCBzaXplID0gdGV4dHVyZVNpemUoIGJhdGNoaW5nVGV4dHVyZSwgMCApLng7CgkJaW50IGogPSBpbnQoIGkgKSAqIDQ7CgkJaW50IHggPSBqICUgc2l6ZTsKCQlpbnQgeSA9IGogLyBzaXplOwoJCXZlYzQgdjEgPSB0ZXhlbEZldGNoKCBiYXRjaGluZ1RleHR1cmUsIGl2ZWMyKCB4LCB5ICksIDAgKTsKCQl2ZWM0IHYyID0gdGV4ZWxGZXRjaCggYmF0Y2hpbmdUZXh0dXJlLCBpdmVjMiggeCArIDEsIHkgKSwgMCApOwoJCXZlYzQgdjMgPSB0ZXhlbEZldGNoKCBiYXRjaGluZ1RleHR1cmUsIGl2ZWMyKCB4ICsgMiwgeSApLCAwICk7CgkJdmVjNCB2NCA9IHRleGVsRmV0Y2goIGJhdGNoaW5nVGV4dHVyZSwgaXZlYzIoIHggKyAzLCB5ICksIDAgKTsKCQlyZXR1cm4gbWF0NCggdjEsIHYyLCB2MywgdjQgKTsKCX0KCWZsb2F0IGdldEluZGlyZWN0SW5kZXgoIGNvbnN0IGluIGludCBpICkgewoJCWludCBzaXplID0gdGV4dHVyZVNpemUoIGJhdGNoaW5nSWRUZXh0dXJlLCAwICkueDsKCQlpbnQgeCA9IGkgJSBzaXplOwoJCWludCB5ID0gaSAvIHNpemU7CgkJcmV0dXJuIGZsb2F0KCB0ZXhlbEZldGNoKCBiYXRjaGluZ0lkVGV4dHVyZSwgaXZlYzIoIHgsIHkgKSwgMCApLnIgKTsKCX0KI2VuZGlmCiNpZmRlZiBVU0VfQkFUQ0hJTkdfQ09MT1IKCXVuaWZvcm0gc2FtcGxlcjJEIGJhdGNoaW5nQ29sb3JUZXh0dXJlOwoJdmVjMyBnZXRCYXRjaGluZ0NvbG9yKCBjb25zdCBpbiBmbG9hdCBpICkgewoJCWludCBzaXplID0gdGV4dHVyZVNpemUoIGJhdGNoaW5nQ29sb3JUZXh0dXJlLCAwICkueDsKCQlpbnQgaiA9IGludCggaSApOwoJCWludCB4ID0gaiAlIHNpemU7CgkJaW50IHkgPSBqIC8gc2l6ZTsKCQlyZXR1cm4gdGV4ZWxGZXRjaCggYmF0Y2hpbmdDb2xvclRleHR1cmUsIGl2ZWMyKCB4LCB5ICksIDAgKS5yZ2I7Cgl9CiNlbmRpZmAsJGE9YCNpZmRlZiBVU0VfQkFUQ0hJTkcKCW1hdDQgYmF0Y2hpbmdNYXRyaXggPSBnZXRCYXRjaGluZ01hdHJpeCggZ2V0SW5kaXJlY3RJbmRleCggZ2xfRHJhd0lEICkgKTsKI2VuZGlmYCxLYT1gdmVjMyB0cmFuc2Zvcm1lZCA9IHZlYzMoIHBvc2l0aW9uICk7CiNpZmRlZiBVU0VfQUxQSEFIQVNICgl2UG9zaXRpb24gPSB2ZWMzKCBwb3NpdGlvbiApOwojZW5kaWZgLFphPWB2ZWMzIG9iamVjdE5vcm1hbCA9IHZlYzMoIG5vcm1hbCApOwojaWZkZWYgVVNFX1RBTkdFTlQKCXZlYzMgb2JqZWN0VGFuZ2VudCA9IHZlYzMoIHRhbmdlbnQueHl6ICk7CiNlbmRpZmAsamE9YGZsb2F0IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggKSB7CglyZXR1cm4gMC4yNTsKfQpmbG9hdCBEX0JsaW5uUGhvbmcoIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcywgY29uc3QgaW4gZmxvYXQgZG90TkggKSB7CglyZXR1cm4gUkVDSVBST0NBTF9QSSAqICggc2hpbmluZXNzICogMC41ICsgMS4wICkgKiBwb3coIGRvdE5ILCBzaGluaW5lc3MgKTsKfQp2ZWMzIEJSREZfQmxpbm5QaG9uZyggY29uc3QgaW4gdmVjMyBsaWdodERpciwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzaGluaW5lc3MgKSB7Cgl2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApOwoJZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApOwoJZmxvYXQgZG90VkggPSBzYXR1cmF0ZSggZG90KCB2aWV3RGlyLCBoYWxmRGlyICkgKTsKCXZlYzMgRiA9IEZfU2NobGljayggc3BlY3VsYXJDb2xvciwgMS4wLCBkb3RWSCApOwoJZmxvYXQgRyA9IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggKTsKCWZsb2F0IEQgPSBEX0JsaW5uUGhvbmcoIHNoaW5pbmVzcywgZG90TkggKTsKCXJldHVybiBGICogKCBHICogRCApOwp9IC8vIHZhbGlkYXRlZGAsSmE9YCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0UKCWNvbnN0IG1hdDMgWFlaX1RPX1JFQzcwOSA9IG1hdDMoCgkJIDMuMjQwNDU0MiwgLTAuOTY5MjY2MCwgIDAuMDU1NjQzNCwKCQktMS41MzcxMzg1LCAgMS44NzYwMTA4LCAtMC4yMDQwMjU5LAoJCS0wLjQ5ODUzMTQsICAwLjA0MTU1NjAsICAxLjA1NzIyNTIKCSk7Cgl2ZWMzIEZyZXNuZWwwVG9Jb3IoIHZlYzMgZnJlc25lbDAgKSB7CgkJdmVjMyBzcXJ0RjAgPSBzcXJ0KCBmcmVzbmVsMCApOwoJCXJldHVybiAoIHZlYzMoIDEuMCApICsgc3FydEYwICkgLyAoIHZlYzMoIDEuMCApIC0gc3FydEYwICk7Cgl9Cgl2ZWMzIElvclRvRnJlc25lbDAoIHZlYzMgdHJhbnNtaXR0ZWRJb3IsIGZsb2F0IGluY2lkZW50SW9yICkgewoJCXJldHVybiBwb3cyKCAoIHRyYW5zbWl0dGVkSW9yIC0gdmVjMyggaW5jaWRlbnRJb3IgKSApIC8gKCB0cmFuc21pdHRlZElvciArIHZlYzMoIGluY2lkZW50SW9yICkgKSApOwoJfQoJZmxvYXQgSW9yVG9GcmVzbmVsMCggZmxvYXQgdHJhbnNtaXR0ZWRJb3IsIGZsb2F0IGluY2lkZW50SW9yICkgewoJCXJldHVybiBwb3cyKCAoIHRyYW5zbWl0dGVkSW9yIC0gaW5jaWRlbnRJb3IgKSAvICggdHJhbnNtaXR0ZWRJb3IgKyBpbmNpZGVudElvciApKTsKCX0KCXZlYzMgZXZhbFNlbnNpdGl2aXR5KCBmbG9hdCBPUEQsIHZlYzMgc2hpZnQgKSB7CgkJZmxvYXQgcGhhc2UgPSAyLjAgKiBQSSAqIE9QRCAqIDEuMGUtOTsKCQl2ZWMzIHZhbCA9IHZlYzMoIDUuNDg1NmUtMTMsIDQuNDIwMWUtMTMsIDUuMjQ4MWUtMTMgKTsKCQl2ZWMzIHBvcyA9IHZlYzMoIDEuNjgxMGUrMDYsIDEuNzk1M2UrMDYsIDIuMjA4NGUrMDYgKTsKCQl2ZWMzIHZhciA9IHZlYzMoIDQuMzI3OGUrMDksIDkuMzA0NmUrMDksIDYuNjEyMWUrMDkgKTsKCQl2ZWMzIHh5eiA9IHZhbCAqIHNxcnQoIDIuMCAqIFBJICogdmFyICkgKiBjb3MoIHBvcyAqIHBoYXNlICsgc2hpZnQgKSAqIGV4cCggLSBwb3cyKCBwaGFzZSApICogdmFyICk7CgkJeHl6LnggKz0gOS43NDcwZS0xNCAqIHNxcnQoIDIuMCAqIFBJICogNC41MjgyZSswOSApICogY29zKCAyLjIzOTllKzA2ICogcGhhc2UgKyBzaGlmdFsgMCBdICkgKiBleHAoIC0gNC41MjgyZSswOSAqIHBvdzIoIHBoYXNlICkgKTsKCQl4eXogLz0gMS4wNjg1ZS03OwoJCXZlYzMgcmdiID0gWFlaX1RPX1JFQzcwOSAqIHh5ejsKCQlyZXR1cm4gcmdiOwoJfQoJdmVjMyBldmFsSXJpZGVzY2VuY2UoIGZsb2F0IG91dHNpZGVJT1IsIGZsb2F0IGV0YTIsIGZsb2F0IGNvc1RoZXRhMSwgZmxvYXQgdGhpbkZpbG1UaGlja25lc3MsIHZlYzMgYmFzZUYwICkgewoJCXZlYzMgSTsKCQlmbG9hdCBpcmlkZXNjZW5jZUlPUiA9IG1peCggb3V0c2lkZUlPUiwgZXRhMiwgc21vb3Roc3RlcCggMC4wLCAwLjAzLCB0aGluRmlsbVRoaWNrbmVzcyApICk7CgkJZmxvYXQgc2luVGhldGEyU3EgPSBwb3cyKCBvdXRzaWRlSU9SIC8gaXJpZGVzY2VuY2VJT1IgKSAqICggMS4wIC0gcG93MiggY29zVGhldGExICkgKTsKCQlmbG9hdCBjb3NUaGV0YTJTcSA9IDEuMCAtIHNpblRoZXRhMlNxOwoJCWlmICggY29zVGhldGEyU3EgPCAwLjAgKSB7CgkJCXJldHVybiB2ZWMzKCAxLjAgKTsKCQl9CgkJZmxvYXQgY29zVGhldGEyID0gc3FydCggY29zVGhldGEyU3EgKTsKCQlmbG9hdCBSMCA9IElvclRvRnJlc25lbDAoIGlyaWRlc2NlbmNlSU9SLCBvdXRzaWRlSU9SICk7CgkJZmxvYXQgUjEyID0gRl9TY2hsaWNrKCBSMCwgMS4wLCBjb3NUaGV0YTEgKTsKCQlmbG9hdCBUMTIxID0gMS4wIC0gUjEyOwoJCWZsb2F0IHBoaTEyID0gMC4wOwoJCWlmICggaXJpZGVzY2VuY2VJT1IgPCBvdXRzaWRlSU9SICkgcGhpMTIgPSBQSTsKCQlmbG9hdCBwaGkyMSA9IFBJIC0gcGhpMTI7CgkJdmVjMyBiYXNlSU9SID0gRnJlc25lbDBUb0lvciggY2xhbXAoIGJhc2VGMCwgMC4wLCAwLjk5OTkgKSApOwkJdmVjMyBSMSA9IElvclRvRnJlc25lbDAoIGJhc2VJT1IsIGlyaWRlc2NlbmNlSU9SICk7CgkJdmVjMyBSMjMgPSBGX1NjaGxpY2soIFIxLCAxLjAsIGNvc1RoZXRhMiApOwoJCXZlYzMgcGhpMjMgPSB2ZWMzKCAwLjAgKTsKCQlpZiAoIGJhc2VJT1JbIDAgXSA8IGlyaWRlc2NlbmNlSU9SICkgcGhpMjNbIDAgXSA9IFBJOwoJCWlmICggYmFzZUlPUlsgMSBdIDwgaXJpZGVzY2VuY2VJT1IgKSBwaGkyM1sgMSBdID0gUEk7CgkJaWYgKCBiYXNlSU9SWyAyIF0gPCBpcmlkZXNjZW5jZUlPUiApIHBoaTIzWyAyIF0gPSBQSTsKCQlmbG9hdCBPUEQgPSAyLjAgKiBpcmlkZXNjZW5jZUlPUiAqIHRoaW5GaWxtVGhpY2tuZXNzICogY29zVGhldGEyOwoJCXZlYzMgcGhpID0gdmVjMyggcGhpMjEgKSArIHBoaTIzOwoJCXZlYzMgUjEyMyA9IGNsYW1wKCBSMTIgKiBSMjMsIDFlLTUsIDAuOTk5OSApOwoJCXZlYzMgcjEyMyA9IHNxcnQoIFIxMjMgKTsKCQl2ZWMzIFJzID0gcG93MiggVDEyMSApICogUjIzIC8gKCB2ZWMzKCAxLjAgKSAtIFIxMjMgKTsKCQl2ZWMzIEMwID0gUjEyICsgUnM7CgkJSSA9IEMwOwoJCXZlYzMgQ20gPSBScyAtIFQxMjE7CgkJZm9yICggaW50IG0gPSAxOyBtIDw9IDI7ICsrIG0gKSB7CgkJCUNtICo9IHIxMjM7CgkJCXZlYzMgU20gPSAyLjAgKiBldmFsU2Vuc2l0aXZpdHkoIGZsb2F0KCBtICkgKiBPUEQsIGZsb2F0KCBtICkgKiBwaGkgKTsKCQkJSSArPSBDbSAqIFNtOwoJCX0KCQlyZXR1cm4gbWF4KCBJLCB2ZWMzKCAwLjAgKSApOwoJfQojZW5kaWZgLFFhPWAjaWZkZWYgVVNFX0JVTVBNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIGJ1bXBNYXA7Cgl1bmlmb3JtIGZsb2F0IGJ1bXBTY2FsZTsKCXZlYzIgZEhkeHlfZndkKCkgewoJCXZlYzIgZFNUZHggPSBkRmR4KCB2QnVtcE1hcFV2ICk7CgkJdmVjMiBkU1RkeSA9IGRGZHkoIHZCdW1wTWFwVXYgKTsKCQlmbG9hdCBIbGwgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZCdW1wTWFwVXYgKS54OwoJCWZsb2F0IGRCeCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdkJ1bXBNYXBVdiArIGRTVGR4ICkueCAtIEhsbDsKCQlmbG9hdCBkQnkgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZCdW1wTWFwVXYgKyBkU1RkeSApLnggLSBIbGw7CgkJcmV0dXJuIHZlYzIoIGRCeCwgZEJ5ICk7Cgl9Cgl2ZWMzIHBlcnR1cmJOb3JtYWxBcmIoIHZlYzMgc3VyZl9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMyIGRIZHh5LCBmbG9hdCBmYWNlRGlyZWN0aW9uICkgewoJCXZlYzMgdlNpZ21hWCA9IG5vcm1hbGl6ZSggZEZkeCggc3VyZl9wb3MueHl6ICkgKTsKCQl2ZWMzIHZTaWdtYVkgPSBub3JtYWxpemUoIGRGZHkoIHN1cmZfcG9zLnh5eiApICk7CgkJdmVjMyB2TiA9IHN1cmZfbm9ybTsKCQl2ZWMzIFIxID0gY3Jvc3MoIHZTaWdtYVksIHZOICk7CgkJdmVjMyBSMiA9IGNyb3NzKCB2TiwgdlNpZ21hWCApOwoJCWZsb2F0IGZEZXQgPSBkb3QoIHZTaWdtYVgsIFIxICkgKiBmYWNlRGlyZWN0aW9uOwoJCXZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApOwoJCXJldHVybiBub3JtYWxpemUoIGFicyggZkRldCApICogc3VyZl9ub3JtIC0gdkdyYWQgKTsKCX0KI2VuZGlmYCxlbz1gI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwCgl2ZWM0IHBsYW5lOwoJI2lmZGVmIEFMUEhBX1RPX0NPVkVSQUdFCgkJZmxvYXQgZGlzdGFuY2VUb1BsYW5lLCBkaXN0YW5jZUdyYWRpZW50OwoJCWZsb2F0IGNsaXBPcGFjaXR5ID0gMS4wOwoJCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCQlmb3IgKCBpbnQgaSA9IDA7IGkgPCBVTklPTl9DTElQUElOR19QTEFORVM7IGkgKysgKSB7CgkJCXBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTsKCQkJZGlzdGFuY2VUb1BsYW5lID0gLSBkb3QoIHZDbGlwUG9zaXRpb24sIHBsYW5lLnh5eiApICsgcGxhbmUudzsKCQkJZGlzdGFuY2VHcmFkaWVudCA9IGZ3aWR0aCggZGlzdGFuY2VUb1BsYW5lICkgLyAyLjA7CgkJCWNsaXBPcGFjaXR5ICo9IHNtb290aHN0ZXAoIC0gZGlzdGFuY2VHcmFkaWVudCwgZGlzdGFuY2VHcmFkaWVudCwgZGlzdGFuY2VUb1BsYW5lICk7CgkJCWlmICggY2xpcE9wYWNpdHkgPT0gMC4wICkgZGlzY2FyZDsKCQl9CgkJI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQKCQkjaWYgVU5JT05fQ0xJUFBJTkdfUExBTkVTIDwgTlVNX0NMSVBQSU5HX1BMQU5FUwoJCQlmbG9hdCB1bmlvbkNsaXBPcGFjaXR5ID0gMS4wOwoJCQkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0CgkJCWZvciAoIGludCBpID0gVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpIDwgTlVNX0NMSVBQSU5HX1BMQU5FUzsgaSArKyApIHsKCQkJCXBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTsKCQkJCWRpc3RhbmNlVG9QbGFuZSA9IC0gZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSArIHBsYW5lLnc7CgkJCQlkaXN0YW5jZUdyYWRpZW50ID0gZndpZHRoKCBkaXN0YW5jZVRvUGxhbmUgKSAvIDIuMDsKCQkJCXVuaW9uQ2xpcE9wYWNpdHkgKj0gMS4wIC0gc21vb3Roc3RlcCggLSBkaXN0YW5jZUdyYWRpZW50LCBkaXN0YW5jZUdyYWRpZW50LCBkaXN0YW5jZVRvUGxhbmUgKTsKCQkJfQoJCQkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJCQljbGlwT3BhY2l0eSAqPSAxLjAgLSB1bmlvbkNsaXBPcGFjaXR5OwoJCSNlbmRpZgoJCWRpZmZ1c2VDb2xvci5hICo9IGNsaXBPcGFjaXR5OwoJCWlmICggZGlmZnVzZUNvbG9yLmEgPT0gMC4wICkgZGlzY2FyZDsKCSNlbHNlCgkJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJCWZvciAoIGludCBpID0gMDsgaSA8IFVOSU9OX0NMSVBQSU5HX1BMQU5FUzsgaSArKyApIHsKCQkJcGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdOwoJCQlpZiAoIGRvdCggdkNsaXBQb3NpdGlvbiwgcGxhbmUueHl6ICkgPiBwbGFuZS53ICkgZGlzY2FyZDsKCQl9CgkJI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQKCQkjaWYgVU5JT05fQ0xJUFBJTkdfUExBTkVTIDwgTlVNX0NMSVBQSU5HX1BMQU5FUwoJCQlib29sIGNsaXBwZWQgPSB0cnVlOwoJCQkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0CgkJCWZvciAoIGludCBpID0gVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpIDwgTlVNX0NMSVBQSU5HX1BMQU5FUzsgaSArKyApIHsKCQkJCXBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTsKCQkJCWNsaXBwZWQgPSAoIGRvdCggdkNsaXBQb3NpdGlvbiwgcGxhbmUueHl6ICkgPiBwbGFuZS53ICkgJiYgY2xpcHBlZDsKCQkJfQoJCQkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJCQlpZiAoIGNsaXBwZWQgKSBkaXNjYXJkOwoJCSNlbmRpZgoJI2VuZGlmCiNlbmRpZmAsdG89YCNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMAoJdmFyeWluZyB2ZWMzIHZDbGlwUG9zaXRpb247Cgl1bmlmb3JtIHZlYzQgY2xpcHBpbmdQbGFuZXNbIE5VTV9DTElQUElOR19QTEFORVMgXTsKI2VuZGlmYCxubz1gI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwCgl2YXJ5aW5nIHZlYzMgdkNsaXBQb3NpdGlvbjsKI2VuZGlmYCxpbz1gI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwCgl2Q2xpcFBvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejsKI2VuZGlmYCxybz1gI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApCglkaWZmdXNlQ29sb3IgKj0gdkNvbG9yOwojZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKQoJZGlmZnVzZUNvbG9yLnJnYiAqPSB2Q29sb3I7CiNlbmRpZmAsc289YCNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKQoJdmFyeWluZyB2ZWM0IHZDb2xvcjsKI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SICkKCXZhcnlpbmcgdmVjMyB2Q29sb3I7CiNlbmRpZmAsYW89YCNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKQoJdmFyeWluZyB2ZWM0IHZDb2xvcjsKI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SICkgfHwgZGVmaW5lZCggVVNFX0lOU1RBTkNJTkdfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfQkFUQ0hJTkdfQ09MT1IgKQoJdmFyeWluZyB2ZWMzIHZDb2xvcjsKI2VuZGlmYCxvbz1gI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApCgl2Q29sb3IgPSB2ZWM0KCAxLjAgKTsKI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SICkgfHwgZGVmaW5lZCggVVNFX0lOU1RBTkNJTkdfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfQkFUQ0hJTkdfQ09MT1IgKQoJdkNvbG9yID0gdmVjMyggMS4wICk7CiNlbmRpZgojaWZkZWYgVVNFX0NPTE9SCgl2Q29sb3IgKj0gY29sb3I7CiNlbmRpZgojaWZkZWYgVVNFX0lOU1RBTkNJTkdfQ09MT1IKCXZDb2xvci54eXogKj0gaW5zdGFuY2VDb2xvci54eXo7CiNlbmRpZgojaWZkZWYgVVNFX0JBVENISU5HX0NPTE9SCgl2ZWMzIGJhdGNoaW5nQ29sb3IgPSBnZXRCYXRjaGluZ0NvbG9yKCBnZXRJbmRpcmVjdEluZGV4KCBnbF9EcmF3SUQgKSApOwoJdkNvbG9yLnh5eiAqPSBiYXRjaGluZ0NvbG9yLnh5ejsKI2VuZGlmYCxsbz1gI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU4OTc5MwojZGVmaW5lIFBJMiA2LjI4MzE4NTMwNzE3OTU4NgojZGVmaW5lIFBJX0hBTEYgMS41NzA3OTYzMjY3OTQ4OTY2CiNkZWZpbmUgUkVDSVBST0NBTF9QSSAwLjMxODMwOTg4NjE4Mzc5MDcKI2RlZmluZSBSRUNJUFJPQ0FMX1BJMiAwLjE1OTE1NDk0MzA5MTg5NTM1CiNkZWZpbmUgRVBTSUxPTiAxZS02CiNpZm5kZWYgc2F0dXJhdGUKI2RlZmluZSBzYXR1cmF0ZSggYSApIGNsYW1wKCBhLCAwLjAsIDEuMCApCiNlbmRpZgojZGVmaW5lIHdoaXRlQ29tcGxlbWVudCggYSApICggMS4wIC0gc2F0dXJhdGUoIGEgKSApCmZsb2F0IHBvdzIoIGNvbnN0IGluIGZsb2F0IHggKSB7IHJldHVybiB4Kng7IH0KdmVjMyBwb3cyKCBjb25zdCBpbiB2ZWMzIHggKSB7IHJldHVybiB4Kng7IH0KZmxvYXQgcG93MyggY29uc3QgaW4gZmxvYXQgeCApIHsgcmV0dXJuIHgqeCp4OyB9CmZsb2F0IHBvdzQoIGNvbnN0IGluIGZsb2F0IHggKSB7IGZsb2F0IHgyID0geCp4OyByZXR1cm4geDIqeDI7IH0KZmxvYXQgbWF4MyggY29uc3QgaW4gdmVjMyB2ICkgeyByZXR1cm4gbWF4KCBtYXgoIHYueCwgdi55ICksIHYueiApOyB9CmZsb2F0IGF2ZXJhZ2UoIGNvbnN0IGluIHZlYzMgdiApIHsgcmV0dXJuIGRvdCggdiwgdmVjMyggMC4zMzMzMzMzICkgKTsgfQpoaWdocCBmbG9hdCByYW5kKCBjb25zdCBpbiB2ZWMyIHV2ICkgewoJY29uc3QgaGlnaHAgZmxvYXQgYSA9IDEyLjk4OTgsIGIgPSA3OC4yMzMsIGMgPSA0Mzc1OC41NDUzOwoJaGlnaHAgZmxvYXQgZHQgPSBkb3QoIHV2Lnh5LCB2ZWMyKCBhLGIgKSApLCBzbiA9IG1vZCggZHQsIFBJICk7CglyZXR1cm4gZnJhY3QoIHNpbiggc24gKSAqIGMgKTsKfQojaWZkZWYgSElHSF9QUkVDSVNJT04KCWZsb2F0IHByZWNpc2lvblNhZmVMZW5ndGgoIHZlYzMgdiApIHsgcmV0dXJuIGxlbmd0aCggdiApOyB9CiNlbHNlCglmbG9hdCBwcmVjaXNpb25TYWZlTGVuZ3RoKCB2ZWMzIHYgKSB7CgkJZmxvYXQgbWF4Q29tcG9uZW50ID0gbWF4MyggYWJzKCB2ICkgKTsKCQlyZXR1cm4gbGVuZ3RoKCB2IC8gbWF4Q29tcG9uZW50ICkgKiBtYXhDb21wb25lbnQ7Cgl9CiNlbmRpZgpzdHJ1Y3QgSW5jaWRlbnRMaWdodCB7Cgl2ZWMzIGNvbG9yOwoJdmVjMyBkaXJlY3Rpb247Cglib29sIHZpc2libGU7Cn07CnN0cnVjdCBSZWZsZWN0ZWRMaWdodCB7Cgl2ZWMzIGRpcmVjdERpZmZ1c2U7Cgl2ZWMzIGRpcmVjdFNwZWN1bGFyOwoJdmVjMyBpbmRpcmVjdERpZmZ1c2U7Cgl2ZWMzIGluZGlyZWN0U3BlY3VsYXI7Cn07CiNpZmRlZiBVU0VfQUxQSEFIQVNICgl2YXJ5aW5nIHZlYzMgdlBvc2l0aW9uOwojZW5kaWYKdmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHsKCXJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggZGlyLCAwLjAgKSApLnh5eiApOwp9CnZlYzMgaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkgewoJcmV0dXJuIG5vcm1hbGl6ZSggKCB2ZWM0KCBkaXIsIDAuMCApICogbWF0cml4ICkueHl6ICk7Cn0KbWF0MyB0cmFuc3Bvc2VNYXQzKCBjb25zdCBpbiBtYXQzIG0gKSB7CgltYXQzIHRtcDsKCXRtcFsgMCBdID0gdmVjMyggbVsgMCBdLngsIG1bIDEgXS54LCBtWyAyIF0ueCApOwoJdG1wWyAxIF0gPSB2ZWMzKCBtWyAwIF0ueSwgbVsgMSBdLnksIG1bIDIgXS55ICk7Cgl0bXBbIDIgXSA9IHZlYzMoIG1bIDAgXS56LCBtWyAxIF0ueiwgbVsgMiBdLnogKTsKCXJldHVybiB0bXA7Cn0KYm9vbCBpc1BlcnNwZWN0aXZlTWF0cml4KCBtYXQ0IG0gKSB7CglyZXR1cm4gbVsgMiBdWyAzIF0gPT0gLSAxLjA7Cn0KdmVjMiBlcXVpcmVjdFV2KCBpbiB2ZWMzIGRpciApIHsKCWZsb2F0IHUgPSBhdGFuKCBkaXIueiwgZGlyLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41OwoJZmxvYXQgdiA9IGFzaW4oIGNsYW1wKCBkaXIueSwgLSAxLjAsIDEuMCApICkgKiBSRUNJUFJPQ0FMX1BJICsgMC41OwoJcmV0dXJuIHZlYzIoIHUsIHYgKTsKfQp2ZWMzIEJSREZfTGFtYmVydCggY29uc3QgaW4gdmVjMyBkaWZmdXNlQ29sb3IgKSB7CglyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGRpZmZ1c2VDb2xvcjsKfQp2ZWMzIEZfU2NobGljayggY29uc3QgaW4gdmVjMyBmMCwgY29uc3QgaW4gZmxvYXQgZjkwLCBjb25zdCBpbiBmbG9hdCBkb3RWSCApIHsKCWZsb2F0IGZyZXNuZWwgPSBleHAyKCAoIC0gNS41NTQ3MyAqIGRvdFZIIC0gNi45ODMxNiApICogZG90VkggKTsKCXJldHVybiBmMCAqICggMS4wIC0gZnJlc25lbCApICsgKCBmOTAgKiBmcmVzbmVsICk7Cn0KZmxvYXQgRl9TY2hsaWNrKCBjb25zdCBpbiBmbG9hdCBmMCwgY29uc3QgaW4gZmxvYXQgZjkwLCBjb25zdCBpbiBmbG9hdCBkb3RWSCApIHsKCWZsb2F0IGZyZXNuZWwgPSBleHAyKCAoIC0gNS41NTQ3MyAqIGRvdFZIIC0gNi45ODMxNiApICogZG90VkggKTsKCXJldHVybiBmMCAqICggMS4wIC0gZnJlc25lbCApICsgKCBmOTAgKiBmcmVzbmVsICk7Cn0gLy8gdmFsaWRhdGVkYCxjbz1gI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVfVVYKCSNkZWZpbmUgY3ViZVVWX21pbk1pcExldmVsIDQuMAoJI2RlZmluZSBjdWJlVVZfbWluVGlsZVNpemUgMTYuMAoJZmxvYXQgZ2V0RmFjZSggdmVjMyBkaXJlY3Rpb24gKSB7CgkJdmVjMyBhYnNEaXJlY3Rpb24gPSBhYnMoIGRpcmVjdGlvbiApOwoJCWZsb2F0IGZhY2UgPSAtIDEuMDsKCQlpZiAoIGFic0RpcmVjdGlvbi54ID4gYWJzRGlyZWN0aW9uLnogKSB7CgkJCWlmICggYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueSApCgkJCQlmYWNlID0gZGlyZWN0aW9uLnggPiAwLjAgPyAwLjAgOiAzLjA7CgkJCWVsc2UKCQkJCWZhY2UgPSBkaXJlY3Rpb24ueSA+IDAuMCA/IDEuMCA6IDQuMDsKCQl9IGVsc2UgewoJCQlpZiAoIGFic0RpcmVjdGlvbi56ID4gYWJzRGlyZWN0aW9uLnkgKQoJCQkJZmFjZSA9IGRpcmVjdGlvbi56ID4gMC4wID8gMi4wIDogNS4wOwoJCQllbHNlCgkJCQlmYWNlID0gZGlyZWN0aW9uLnkgPiAwLjAgPyAxLjAgOiA0LjA7CgkJfQoJCXJldHVybiBmYWNlOwoJfQoJdmVjMiBnZXRVViggdmVjMyBkaXJlY3Rpb24sIGZsb2F0IGZhY2UgKSB7CgkJdmVjMiB1djsKCQlpZiAoIGZhY2UgPT0gMC4wICkgewoJCQl1diA9IHZlYzIoIGRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueSApIC8gYWJzKCBkaXJlY3Rpb24ueCApOwoJCX0gZWxzZSBpZiAoIGZhY2UgPT0gMS4wICkgewoJCQl1diA9IHZlYzIoIC0gZGlyZWN0aW9uLngsIC0gZGlyZWN0aW9uLnogKSAvIGFicyggZGlyZWN0aW9uLnkgKTsKCQl9IGVsc2UgaWYgKCBmYWNlID09IDIuMCApIHsKCQkJdXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSApIC8gYWJzKCBkaXJlY3Rpb24ueiApOwoJCX0gZWxzZSBpZiAoIGZhY2UgPT0gMy4wICkgewoJCQl1diA9IHZlYzIoIC0gZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi54ICk7CgkJfSBlbHNlIGlmICggZmFjZSA9PSA0LjAgKSB7CgkJCXV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnogKSAvIGFicyggZGlyZWN0aW9uLnkgKTsKCQl9IGVsc2UgewoJCQl1diA9IHZlYzIoIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSApIC8gYWJzKCBkaXJlY3Rpb24ueiApOwoJCX0KCQlyZXR1cm4gMC41ICogKCB1diArIDEuMCApOwoJfQoJdmVjMyBiaWxpbmVhckN1YmVVViggc2FtcGxlcjJEIGVudk1hcCwgdmVjMyBkaXJlY3Rpb24sIGZsb2F0IG1pcEludCApIHsKCQlmbG9hdCBmYWNlID0gZ2V0RmFjZSggZGlyZWN0aW9uICk7CgkJZmxvYXQgZmlsdGVySW50ID0gbWF4KCBjdWJlVVZfbWluTWlwTGV2ZWwgLSBtaXBJbnQsIDAuMCApOwoJCW1pcEludCA9IG1heCggbWlwSW50LCBjdWJlVVZfbWluTWlwTGV2ZWwgKTsKCQlmbG9hdCBmYWNlU2l6ZSA9IGV4cDIoIG1pcEludCApOwoJCWhpZ2hwIHZlYzIgdXYgPSBnZXRVViggZGlyZWN0aW9uLCBmYWNlICkgKiAoIGZhY2VTaXplIC0gMi4wICkgKyAxLjA7CgkJaWYgKCBmYWNlID4gMi4wICkgewoJCQl1di55ICs9IGZhY2VTaXplOwoJCQlmYWNlIC09IDMuMDsKCQl9CgkJdXYueCArPSBmYWNlICogZmFjZVNpemU7CgkJdXYueCArPSBmaWx0ZXJJbnQgKiAzLjAgKiBjdWJlVVZfbWluVGlsZVNpemU7CgkJdXYueSArPSA0LjAgKiAoIGV4cDIoIENVQkVVVl9NQVhfTUlQICkgLSBmYWNlU2l6ZSApOwoJCXV2LnggKj0gQ1VCRVVWX1RFWEVMX1dJRFRIOwoJCXV2LnkgKj0gQ1VCRVVWX1RFWEVMX0hFSUdIVDsKCQkjaWZkZWYgdGV4dHVyZTJER3JhZEVYVAoJCQlyZXR1cm4gdGV4dHVyZTJER3JhZEVYVCggZW52TWFwLCB1diwgdmVjMiggMC4wICksIHZlYzIoIDAuMCApICkucmdiOwoJCSNlbHNlCgkJCXJldHVybiB0ZXh0dXJlMkQoIGVudk1hcCwgdXYgKS5yZ2I7CgkJI2VuZGlmCgl9CgkjZGVmaW5lIGN1YmVVVl9yMCAxLjAKCSNkZWZpbmUgY3ViZVVWX20wIC0gMi4wCgkjZGVmaW5lIGN1YmVVVl9yMSAwLjgKCSNkZWZpbmUgY3ViZVVWX20xIC0gMS4wCgkjZGVmaW5lIGN1YmVVVl9yNCAwLjQKCSNkZWZpbmUgY3ViZVVWX200IDIuMAoJI2RlZmluZSBjdWJlVVZfcjUgMC4zMDUKCSNkZWZpbmUgY3ViZVVWX201IDMuMAoJI2RlZmluZSBjdWJlVVZfcjYgMC4yMQoJI2RlZmluZSBjdWJlVVZfbTYgNC4wCglmbG9hdCByb3VnaG5lc3NUb01pcCggZmxvYXQgcm91Z2huZXNzICkgewoJCWZsb2F0IG1pcCA9IDAuMDsKCQlpZiAoIHJvdWdobmVzcyA+PSBjdWJlVVZfcjEgKSB7CgkJCW1pcCA9ICggY3ViZVVWX3IwIC0gcm91Z2huZXNzICkgKiAoIGN1YmVVVl9tMSAtIGN1YmVVVl9tMCApIC8gKCBjdWJlVVZfcjAgLSBjdWJlVVZfcjEgKSArIGN1YmVVVl9tMDsKCQl9IGVsc2UgaWYgKCByb3VnaG5lc3MgPj0gY3ViZVVWX3I0ICkgewoJCQltaXAgPSAoIGN1YmVVVl9yMSAtIHJvdWdobmVzcyApICogKCBjdWJlVVZfbTQgLSBjdWJlVVZfbTEgKSAvICggY3ViZVVWX3IxIC0gY3ViZVVWX3I0ICkgKyBjdWJlVVZfbTE7CgkJfSBlbHNlIGlmICggcm91Z2huZXNzID49IGN1YmVVVl9yNSApIHsKCQkJbWlwID0gKCBjdWJlVVZfcjQgLSByb3VnaG5lc3MgKSAqICggY3ViZVVWX201IC0gY3ViZVVWX200ICkgLyAoIGN1YmVVVl9yNCAtIGN1YmVVVl9yNSApICsgY3ViZVVWX200OwoJCX0gZWxzZSBpZiAoIHJvdWdobmVzcyA+PSBjdWJlVVZfcjYgKSB7CgkJCW1pcCA9ICggY3ViZVVWX3I1IC0gcm91Z2huZXNzICkgKiAoIGN1YmVVVl9tNiAtIGN1YmVVVl9tNSApIC8gKCBjdWJlVVZfcjUgLSBjdWJlVVZfcjYgKSArIGN1YmVVVl9tNTsKCQl9IGVsc2UgewoJCQltaXAgPSAtIDIuMCAqIGxvZzIoIDEuMTYgKiByb3VnaG5lc3MgKTsJCX0KCQlyZXR1cm4gbWlwOwoJfQoJdmVjNCB0ZXh0dXJlQ3ViZVVWKCBzYW1wbGVyMkQgZW52TWFwLCB2ZWMzIHNhbXBsZURpciwgZmxvYXQgcm91Z2huZXNzICkgewoJCWZsb2F0IG1pcCA9IGNsYW1wKCByb3VnaG5lc3NUb01pcCggcm91Z2huZXNzICksIGN1YmVVVl9tMCwgQ1VCRVVWX01BWF9NSVAgKTsKCQlmbG9hdCBtaXBGID0gZnJhY3QoIG1pcCApOwoJCWZsb2F0IG1pcEludCA9IGZsb29yKCBtaXAgKTsKCQl2ZWMzIGNvbG9yMCA9IGJpbGluZWFyQ3ViZVVWKCBlbnZNYXAsIHNhbXBsZURpciwgbWlwSW50ICk7CgkJaWYgKCBtaXBGID09IDAuMCApIHsKCQkJcmV0dXJuIHZlYzQoIGNvbG9yMCwgMS4wICk7CgkJfSBlbHNlIHsKCQkJdmVjMyBjb2xvcjEgPSBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXIsIG1pcEludCArIDEuMCApOwoJCQlyZXR1cm4gdmVjNCggbWl4KCBjb2xvcjAsIGNvbG9yMSwgbWlwRiApLCAxLjAgKTsKCQl9Cgl9CiNlbmRpZmAsdW89YHZlYzMgdHJhbnNmb3JtZWROb3JtYWwgPSBvYmplY3ROb3JtYWw7CiNpZmRlZiBVU0VfVEFOR0VOVAoJdmVjMyB0cmFuc2Zvcm1lZFRhbmdlbnQgPSBvYmplY3RUYW5nZW50OwojZW5kaWYKI2lmZGVmIFVTRV9CQVRDSElORwoJbWF0MyBibSA9IG1hdDMoIGJhdGNoaW5nTWF0cml4ICk7Cgl0cmFuc2Zvcm1lZE5vcm1hbCAvPSB2ZWMzKCBkb3QoIGJtWyAwIF0sIGJtWyAwIF0gKSwgZG90KCBibVsgMSBdLCBibVsgMSBdICksIGRvdCggYm1bIDIgXSwgYm1bIDIgXSApICk7Cgl0cmFuc2Zvcm1lZE5vcm1hbCA9IGJtICogdHJhbnNmb3JtZWROb3JtYWw7CgkjaWZkZWYgVVNFX1RBTkdFTlQKCQl0cmFuc2Zvcm1lZFRhbmdlbnQgPSBibSAqIHRyYW5zZm9ybWVkVGFuZ2VudDsKCSNlbmRpZgojZW5kaWYKI2lmZGVmIFVTRV9JTlNUQU5DSU5HCgltYXQzIGltID0gbWF0MyggaW5zdGFuY2VNYXRyaXggKTsKCXRyYW5zZm9ybWVkTm9ybWFsIC89IHZlYzMoIGRvdCggaW1bIDAgXSwgaW1bIDAgXSApLCBkb3QoIGltWyAxIF0sIGltWyAxIF0gKSwgZG90KCBpbVsgMiBdLCBpbVsgMiBdICkgKTsKCXRyYW5zZm9ybWVkTm9ybWFsID0gaW0gKiB0cmFuc2Zvcm1lZE5vcm1hbDsKCSNpZmRlZiBVU0VfVEFOR0VOVAoJCXRyYW5zZm9ybWVkVGFuZ2VudCA9IGltICogdHJhbnNmb3JtZWRUYW5nZW50OwoJI2VuZGlmCiNlbmRpZgp0cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbE1hdHJpeCAqIHRyYW5zZm9ybWVkTm9ybWFsOwojaWZkZWYgRkxJUF9TSURFRAoJdHJhbnNmb3JtZWROb3JtYWwgPSAtIHRyYW5zZm9ybWVkTm9ybWFsOwojZW5kaWYKI2lmZGVmIFVTRV9UQU5HRU5UCgl0cmFuc2Zvcm1lZFRhbmdlbnQgPSAoIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkVGFuZ2VudCwgMC4wICkgKS54eXo7CgkjaWZkZWYgRkxJUF9TSURFRAoJCXRyYW5zZm9ybWVkVGFuZ2VudCA9IC0gdHJhbnNmb3JtZWRUYW5nZW50OwoJI2VuZGlmCiNlbmRpZmAsaG89YCNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBkaXNwbGFjZW1lbnRNYXA7Cgl1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudFNjYWxlOwoJdW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRCaWFzOwojZW5kaWZgLGZvPWAjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUAoJdHJhbnNmb3JtZWQgKz0gbm9ybWFsaXplKCBvYmplY3ROb3JtYWwgKSAqICggdGV4dHVyZTJEKCBkaXNwbGFjZW1lbnRNYXAsIHZEaXNwbGFjZW1lbnRNYXBVdiApLnggKiBkaXNwbGFjZW1lbnRTY2FsZSArIGRpc3BsYWNlbWVudEJpYXMgKTsKI2VuZGlmYCxwbz1gI2lmZGVmIFVTRV9FTUlTU0lWRU1BUAoJdmVjNCBlbWlzc2l2ZUNvbG9yID0gdGV4dHVyZTJEKCBlbWlzc2l2ZU1hcCwgdkVtaXNzaXZlTWFwVXYgKTsKCSNpZmRlZiBERUNPREVfVklERU9fVEVYVFVSRV9FTUlTU0lWRQoJCWVtaXNzaXZlQ29sb3IgPSBzUkdCVHJhbnNmZXJFT1RGKCBlbWlzc2l2ZUNvbG9yICk7CgkjZW5kaWYKCXRvdGFsRW1pc3NpdmVSYWRpYW5jZSAqPSBlbWlzc2l2ZUNvbG9yLnJnYjsKI2VuZGlmYCxtbz1gI2lmZGVmIFVTRV9FTUlTU0lWRU1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7CiNlbmRpZmAsZ289ImdsX0ZyYWdDb2xvciA9IGxpbmVhclRvT3V0cHV0VGV4ZWwoIGdsX0ZyYWdDb2xvciApOyIsX289YHZlYzQgTGluZWFyVHJhbnNmZXJPRVRGKCBpbiB2ZWM0IHZhbHVlICkgewoJcmV0dXJuIHZhbHVlOwp9CnZlYzQgc1JHQlRyYW5zZmVyRU9URiggaW4gdmVjNCB2YWx1ZSApIHsKCXJldHVybiB2ZWM0KCBtaXgoIHBvdyggdmFsdWUucmdiICogMC45NDc4NjcyOTg2ICsgdmVjMyggMC4wNTIxMzI3MDE0ICksIHZlYzMoIDIuNCApICksIHZhbHVlLnJnYiAqIDAuMDc3Mzk5MzgwOCwgdmVjMyggbGVzc1RoYW5FcXVhbCggdmFsdWUucmdiLCB2ZWMzKCAwLjA0MDQ1ICkgKSApICksIHZhbHVlLmEgKTsKfQp2ZWM0IHNSR0JUcmFuc2Zlck9FVEYoIGluIHZlYzQgdmFsdWUgKSB7CglyZXR1cm4gdmVjNCggbWl4KCBwb3coIHZhbHVlLnJnYiwgdmVjMyggMC40MTY2NiApICkgKiAxLjA1NSAtIHZlYzMoIDAuMDU1ICksIHZhbHVlLnJnYiAqIDEyLjkyLCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDAzMTMwOCApICkgKSApLCB2YWx1ZS5hICk7Cn1gLHZvPWAjaWZkZWYgVVNFX0VOVk1BUAoJI2lmZGVmIEVOVl9XT1JMRFBPUwoJCXZlYzMgY2FtZXJhVG9GcmFnOwoJCWlmICggaXNPcnRob2dyYXBoaWMgKSB7CgkJCWNhbWVyYVRvRnJhZyA9IG5vcm1hbGl6ZSggdmVjMyggLSB2aWV3TWF0cml4WyAwIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAxIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAyIF1bIDIgXSApICk7CgkJfSBlbHNlIHsKCQkJY2FtZXJhVG9GcmFnID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiAtIGNhbWVyYVBvc2l0aW9uICk7CgkJfQoJCXZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTsKCQkjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTgoJCQl2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCBjYW1lcmFUb0ZyYWcsIHdvcmxkTm9ybWFsICk7CgkJI2Vsc2UKCQkJdmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggY2FtZXJhVG9GcmFnLCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7CgkJI2VuZGlmCgkjZWxzZQoJCXZlYzMgcmVmbGVjdFZlYyA9IHZSZWZsZWN0OwoJI2VuZGlmCgkjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRQoJCXZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBlbnZNYXBSb3RhdGlvbiAqIHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKSApOwoJI2Vsc2UKCQl2ZWM0IGVudkNvbG9yID0gdmVjNCggMC4wICk7CgkjZW5kaWYKCSNpZmRlZiBFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFkKCQlvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBvdXRnb2luZ0xpZ2h0ICogZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7CgkjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfTUlYICkKCQlvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTsKCSNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19BREQgKQoJCW91dGdvaW5nTGlnaHQgKz0gZW52Q29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTsKCSNlbmRpZgojZW5kaWZgLHhvPWAjaWZkZWYgVVNFX0VOVk1BUAoJdW5pZm9ybSBmbG9hdCBlbnZNYXBJbnRlbnNpdHk7Cgl1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7Cgl1bmlmb3JtIG1hdDMgZW52TWFwUm90YXRpb247CgkjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRQoJCXVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwOwoJI2Vsc2UKCQl1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7CgkjZW5kaWYKCQojZW5kaWZgLE1vPWAjaWZkZWYgVVNFX0VOVk1BUAoJdW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7CgkjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSB8fCBkZWZpbmVkKCBMQU1CRVJUICkKCQkjZGVmaW5lIEVOVl9XT1JMRFBPUwoJI2VuZGlmCgkjaWZkZWYgRU5WX1dPUkxEUE9TCgkJdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uOwoJCXVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvOwoJI2Vsc2UKCQl2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7CgkjZW5kaWYKI2VuZGlmYCxTbz1gI2lmZGVmIFVTRV9FTlZNQVAKCSNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIExBTUJFUlQgKQoJCSNkZWZpbmUgRU5WX1dPUkxEUE9TCgkjZW5kaWYKCSNpZmRlZiBFTlZfV09STERQT1MKCQkKCQl2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247CgkjZWxzZQoJCXZhcnlpbmcgdmVjMyB2UmVmbGVjdDsKCQl1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbzsKCSNlbmRpZgojZW5kaWZgLEVvPWAjaWZkZWYgVVNFX0VOVk1BUAoJI2lmZGVmIEVOVl9XT1JMRFBPUwoJCXZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7CgkjZWxzZQoJCXZlYzMgY2FtZXJhVG9WZXJ0ZXg7CgkJaWYgKCBpc09ydGhvZ3JhcGhpYyApIHsKCQkJY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZlYzMoIC0gdmlld01hdHJpeFsgMCBdWyAyIF0sIC0gdmlld01hdHJpeFsgMSBdWyAyIF0sIC0gdmlld01hdHJpeFsgMiBdWyAyIF0gKSApOwoJCX0gZWxzZSB7CgkJCWNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7CgkJfQoJCXZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCB0cmFuc2Zvcm1lZE5vcm1hbCwgdmlld01hdHJpeCApOwoJCSNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OCgkJCXZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7CgkJI2Vsc2UKCQkJdlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApOwoJCSNlbmRpZgoJI2VuZGlmCiNlbmRpZmAseW89YCNpZmRlZiBVU0VfRk9HCgl2Rm9nRGVwdGggPSAtIG12UG9zaXRpb24uejsKI2VuZGlmYCxUbz1gI2lmZGVmIFVTRV9GT0cKCXZhcnlpbmcgZmxvYXQgdkZvZ0RlcHRoOwojZW5kaWZgLEFvPWAjaWZkZWYgVVNFX0ZPRwoJI2lmZGVmIEZPR19FWFAyCgkJZmxvYXQgZm9nRmFjdG9yID0gMS4wIC0gZXhwKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogdkZvZ0RlcHRoICogdkZvZ0RlcHRoICk7CgkjZWxzZQoJCWZsb2F0IGZvZ0ZhY3RvciA9IHNtb290aHN0ZXAoIGZvZ05lYXIsIGZvZ0ZhciwgdkZvZ0RlcHRoICk7CgkjZW5kaWYKCWdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgoIGdsX0ZyYWdDb2xvci5yZ2IsIGZvZ0NvbG9yLCBmb2dGYWN0b3IgKTsKI2VuZGlmYCx3bz1gI2lmZGVmIFVTRV9GT0cKCXVuaWZvcm0gdmVjMyBmb2dDb2xvcjsKCXZhcnlpbmcgZmxvYXQgdkZvZ0RlcHRoOwoJI2lmZGVmIEZPR19FWFAyCgkJdW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5OwoJI2Vsc2UKCQl1bmlmb3JtIGZsb2F0IGZvZ05lYXI7CgkJdW5pZm9ybSBmbG9hdCBmb2dGYXI7CgkjZW5kaWYKI2VuZGlmYCxibz1gI2lmZGVmIFVTRV9HUkFESUVOVE1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgZ3JhZGllbnRNYXA7CiNlbmRpZgp2ZWMzIGdldEdyYWRpZW50SXJyYWRpYW5jZSggdmVjMyBub3JtYWwsIHZlYzMgbGlnaHREaXJlY3Rpb24gKSB7CglmbG9hdCBkb3ROTCA9IGRvdCggbm9ybWFsLCBsaWdodERpcmVjdGlvbiApOwoJdmVjMiBjb29yZCA9IHZlYzIoIGRvdE5MICogMC41ICsgMC41LCAwLjAgKTsKCSNpZmRlZiBVU0VfR1JBRElFTlRNQVAKCQlyZXR1cm4gdmVjMyggdGV4dHVyZTJEKCBncmFkaWVudE1hcCwgY29vcmQgKS5yICk7CgkjZWxzZQoJCXZlYzIgZncgPSBmd2lkdGgoIGNvb3JkICkgKiAwLjU7CgkJcmV0dXJuIG1peCggdmVjMyggMC43ICksIHZlYzMoIDEuMCApLCBzbW9vdGhzdGVwKCAwLjcgLSBmdy54LCAwLjcgKyBmdy54LCBjb29yZC54ICkgKTsKCSNlbmRpZgp9YCxSbz1gI2lmZGVmIFVTRV9MSUdIVE1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7Cgl1bmlmb3JtIGZsb2F0IGxpZ2h0TWFwSW50ZW5zaXR5OwojZW5kaWZgLENvPWBMYW1iZXJ0TWF0ZXJpYWwgbWF0ZXJpYWw7Cm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2I7Cm1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGggPSBzcGVjdWxhclN0cmVuZ3RoO2AsUG89YHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uOwpzdHJ1Y3QgTGFtYmVydE1hdGVyaWFsIHsKCXZlYzMgZGlmZnVzZUNvbG9yOwoJZmxvYXQgc3BlY3VsYXJTdHJlbmd0aDsKfTsKdm9pZCBSRV9EaXJlY3RfTGFtYmVydCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gTGFtYmVydE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHsKCWZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnlOb3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7Cgl2ZWMzIGlycmFkaWFuY2UgPSBkb3ROTCAqIGRpcmVjdExpZ2h0LmNvbG9yOwoJcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTsKfQp2b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9MYW1iZXJ0KCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIExhbWJlcnRNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7CglyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7Cn0KI2RlZmluZSBSRV9EaXJlY3QJCQkJUkVfRGlyZWN0X0xhbWJlcnQKI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2UJCVJFX0luZGlyZWN0RGlmZnVzZV9MYW1iZXJ0YCxEbz1gdW5pZm9ybSBib29sIHJlY2VpdmVTaGFkb3c7CnVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjsKI2lmIGRlZmluZWQoIFVTRV9MSUdIVF9QUk9CRVMgKQoJdW5pZm9ybSB2ZWMzIGxpZ2h0UHJvYmVbIDkgXTsKI2VuZGlmCnZlYzMgc2hHZXRJcnJhZGlhbmNlQXQoIGluIHZlYzMgbm9ybWFsLCBpbiB2ZWMzIHNoQ29lZmZpY2llbnRzWyA5IF0gKSB7CglmbG9hdCB4ID0gbm9ybWFsLngsIHkgPSBub3JtYWwueSwgeiA9IG5vcm1hbC56OwoJdmVjMyByZXN1bHQgPSBzaENvZWZmaWNpZW50c1sgMCBdICogMC44ODYyMjc7CglyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDEgXSAqIDIuMCAqIDAuNTExNjY0ICogeTsKCXJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgMiBdICogMi4wICogMC41MTE2NjQgKiB6OwoJcmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAzIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHg7CglyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDQgXSAqIDIuMCAqIDAuNDI5MDQzICogeCAqIHk7CglyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDUgXSAqIDIuMCAqIDAuNDI5MDQzICogeSAqIHo7CglyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDYgXSAqICggMC43NDMxMjUgKiB6ICogeiAtIDAuMjQ3NzA4ICk7CglyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDcgXSAqIDIuMCAqIDAuNDI5MDQzICogeCAqIHo7CglyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDggXSAqIDAuNDI5MDQzICogKCB4ICogeCAtIHkgKiB5ICk7CglyZXR1cm4gcmVzdWx0Owp9CnZlYzMgZ2V0TGlnaHRQcm9iZUlycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgbGlnaHRQcm9iZVsgOSBdLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHsKCXZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTsKCXZlYzMgaXJyYWRpYW5jZSA9IHNoR2V0SXJyYWRpYW5jZUF0KCB3b3JsZE5vcm1hbCwgbGlnaHRQcm9iZSApOwoJcmV0dXJuIGlycmFkaWFuY2U7Cn0KdmVjMyBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIGFtYmllbnRMaWdodENvbG9yICkgewoJdmVjMyBpcnJhZGlhbmNlID0gYW1iaWVudExpZ2h0Q29sb3I7CglyZXR1cm4gaXJyYWRpYW5jZTsKfQpmbG9hdCBnZXREaXN0YW5jZUF0dGVudWF0aW9uKCBjb25zdCBpbiBmbG9hdCBsaWdodERpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBjdXRvZmZEaXN0YW5jZSwgY29uc3QgaW4gZmxvYXQgZGVjYXlFeHBvbmVudCApIHsKCWZsb2F0IGRpc3RhbmNlRmFsbG9mZiA9IDEuMCAvIG1heCggcG93KCBsaWdodERpc3RhbmNlLCBkZWNheUV4cG9uZW50ICksIDAuMDEgKTsKCWlmICggY3V0b2ZmRGlzdGFuY2UgPiAwLjAgKSB7CgkJZGlzdGFuY2VGYWxsb2ZmICo9IHBvdzIoIHNhdHVyYXRlKCAxLjAgLSBwb3c0KCBsaWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKSApICk7Cgl9CglyZXR1cm4gZGlzdGFuY2VGYWxsb2ZmOwp9CmZsb2F0IGdldFNwb3RBdHRlbnVhdGlvbiggY29uc3QgaW4gZmxvYXQgY29uZUNvc2luZSwgY29uc3QgaW4gZmxvYXQgcGVudW1icmFDb3NpbmUsIGNvbnN0IGluIGZsb2F0IGFuZ2xlQ29zaW5lICkgewoJcmV0dXJuIHNtb290aHN0ZXAoIGNvbmVDb3NpbmUsIHBlbnVtYnJhQ29zaW5lLCBhbmdsZUNvc2luZSApOwp9CiNpZiBOVU1fRElSX0xJR0hUUyA+IDAKCXN0cnVjdCBEaXJlY3Rpb25hbExpZ2h0IHsKCQl2ZWMzIGRpcmVjdGlvbjsKCQl2ZWMzIGNvbG9yOwoJfTsKCXVuaWZvcm0gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0c1sgTlVNX0RJUl9MSUdIVFMgXTsKCXZvaWQgZ2V0RGlyZWN0aW9uYWxMaWdodEluZm8oIGNvbnN0IGluIERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodCwgb3V0IEluY2lkZW50TGlnaHQgbGlnaHQgKSB7CgkJbGlnaHQuY29sb3IgPSBkaXJlY3Rpb25hbExpZ2h0LmNvbG9yOwoJCWxpZ2h0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbmFsTGlnaHQuZGlyZWN0aW9uOwoJCWxpZ2h0LnZpc2libGUgPSB0cnVlOwoJfQojZW5kaWYKI2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwCglzdHJ1Y3QgUG9pbnRMaWdodCB7CgkJdmVjMyBwb3NpdGlvbjsKCQl2ZWMzIGNvbG9yOwoJCWZsb2F0IGRpc3RhbmNlOwoJCWZsb2F0IGRlY2F5OwoJfTsKCXVuaWZvcm0gUG9pbnRMaWdodCBwb2ludExpZ2h0c1sgTlVNX1BPSU5UX0xJR0hUUyBdOwoJdm9pZCBnZXRQb2ludExpZ2h0SW5mbyggY29uc3QgaW4gUG9pbnRMaWdodCBwb2ludExpZ2h0LCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIG91dCBJbmNpZGVudExpZ2h0IGxpZ2h0ICkgewoJCXZlYzMgbFZlY3RvciA9IHBvaW50TGlnaHQucG9zaXRpb24gLSBnZW9tZXRyeVBvc2l0aW9uOwoJCWxpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApOwoJCWZsb2F0IGxpZ2h0RGlzdGFuY2UgPSBsZW5ndGgoIGxWZWN0b3IgKTsKCQlsaWdodC5jb2xvciA9IHBvaW50TGlnaHQuY29sb3I7CgkJbGlnaHQuY29sb3IgKj0gZ2V0RGlzdGFuY2VBdHRlbnVhdGlvbiggbGlnaHREaXN0YW5jZSwgcG9pbnRMaWdodC5kaXN0YW5jZSwgcG9pbnRMaWdodC5kZWNheSApOwoJCWxpZ2h0LnZpc2libGUgPSAoIGxpZ2h0LmNvbG9yICE9IHZlYzMoIDAuMCApICk7Cgl9CiNlbmRpZgojaWYgTlVNX1NQT1RfTElHSFRTID4gMAoJc3RydWN0IFNwb3RMaWdodCB7CgkJdmVjMyBwb3NpdGlvbjsKCQl2ZWMzIGRpcmVjdGlvbjsKCQl2ZWMzIGNvbG9yOwoJCWZsb2F0IGRpc3RhbmNlOwoJCWZsb2F0IGRlY2F5OwoJCWZsb2F0IGNvbmVDb3M7CgkJZmxvYXQgcGVudW1icmFDb3M7Cgl9OwoJdW5pZm9ybSBTcG90TGlnaHQgc3BvdExpZ2h0c1sgTlVNX1NQT1RfTElHSFRTIF07Cgl2b2lkIGdldFNwb3RMaWdodEluZm8oIGNvbnN0IGluIFNwb3RMaWdodCBzcG90TGlnaHQsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgb3V0IEluY2lkZW50TGlnaHQgbGlnaHQgKSB7CgkJdmVjMyBsVmVjdG9yID0gc3BvdExpZ2h0LnBvc2l0aW9uIC0gZ2VvbWV0cnlQb3NpdGlvbjsKCQlsaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTsKCQlmbG9hdCBhbmdsZUNvcyA9IGRvdCggbGlnaHQuZGlyZWN0aW9uLCBzcG90TGlnaHQuZGlyZWN0aW9uICk7CgkJZmxvYXQgc3BvdEF0dGVudWF0aW9uID0gZ2V0U3BvdEF0dGVudWF0aW9uKCBzcG90TGlnaHQuY29uZUNvcywgc3BvdExpZ2h0LnBlbnVtYnJhQ29zLCBhbmdsZUNvcyApOwoJCWlmICggc3BvdEF0dGVudWF0aW9uID4gMC4wICkgewoJCQlmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7CgkJCWxpZ2h0LmNvbG9yID0gc3BvdExpZ2h0LmNvbG9yICogc3BvdEF0dGVudWF0aW9uOwoJCQlsaWdodC5jb2xvciAqPSBnZXREaXN0YW5jZUF0dGVudWF0aW9uKCBsaWdodERpc3RhbmNlLCBzcG90TGlnaHQuZGlzdGFuY2UsIHNwb3RMaWdodC5kZWNheSApOwoJCQlsaWdodC52aXNpYmxlID0gKCBsaWdodC5jb2xvciAhPSB2ZWMzKCAwLjAgKSApOwoJCX0gZWxzZSB7CgkJCWxpZ2h0LmNvbG9yID0gdmVjMyggMC4wICk7CgkJCWxpZ2h0LnZpc2libGUgPSBmYWxzZTsKCQl9Cgl9CiNlbmRpZgojaWYgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwCglzdHJ1Y3QgUmVjdEFyZWFMaWdodCB7CgkJdmVjMyBjb2xvcjsKCQl2ZWMzIHBvc2l0aW9uOwoJCXZlYzMgaGFsZldpZHRoOwoJCXZlYzMgaGFsZkhlaWdodDsKCX07Cgl1bmlmb3JtIHNhbXBsZXIyRCBsdGNfMTsJdW5pZm9ybSBzYW1wbGVyMkQgbHRjXzI7Cgl1bmlmb3JtIFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodHNbIE5VTV9SRUNUX0FSRUFfTElHSFRTIF07CiNlbmRpZgojaWYgTlVNX0hFTUlfTElHSFRTID4gMAoJc3RydWN0IEhlbWlzcGhlcmVMaWdodCB7CgkJdmVjMyBkaXJlY3Rpb247CgkJdmVjMyBza3lDb2xvcjsKCQl2ZWMzIGdyb3VuZENvbG9yOwoJfTsKCXVuaWZvcm0gSGVtaXNwaGVyZUxpZ2h0IGhlbWlzcGhlcmVMaWdodHNbIE5VTV9IRU1JX0xJR0hUUyBdOwoJdmVjMyBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBIZW1pc3BoZXJlTGlnaHQgaGVtaUxpZ2h0LCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHsKCQlmbG9hdCBkb3ROTCA9IGRvdCggbm9ybWFsLCBoZW1pTGlnaHQuZGlyZWN0aW9uICk7CgkJZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3ROTCArIDAuNTsKCQl2ZWMzIGlycmFkaWFuY2UgPSBtaXgoIGhlbWlMaWdodC5ncm91bmRDb2xvciwgaGVtaUxpZ2h0LnNreUNvbG9yLCBoZW1pRGlmZnVzZVdlaWdodCApOwoJCXJldHVybiBpcnJhZGlhbmNlOwoJfQojZW5kaWZgLExvPWAjaWZkZWYgVVNFX0VOVk1BUAoJdmVjMyBnZXRJQkxJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHsKCQkjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRV9VVgoJCQl2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7CgkJCXZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZVVWKCBlbnZNYXAsIGVudk1hcFJvdGF0aW9uICogd29ybGROb3JtYWwsIDEuMCApOwoJCQlyZXR1cm4gUEkgKiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7CgkJI2Vsc2UKCQkJcmV0dXJuIHZlYzMoIDAuMCApOwoJCSNlbmRpZgoJfQoJdmVjMyBnZXRJQkxSYWRpYW5jZSggY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkgewoJCSNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWCgkJCXZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIC0gdmlld0Rpciwgbm9ybWFsICk7CgkJCXJlZmxlY3RWZWMgPSBub3JtYWxpemUoIG1peCggcmVmbGVjdFZlYywgbm9ybWFsLCByb3VnaG5lc3MgKiByb3VnaG5lc3MpICk7CgkJCXJlZmxlY3RWZWMgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCByZWZsZWN0VmVjLCB2aWV3TWF0cml4ICk7CgkJCXZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZVVWKCBlbnZNYXAsIGVudk1hcFJvdGF0aW9uICogcmVmbGVjdFZlYywgcm91Z2huZXNzICk7CgkJCXJldHVybiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7CgkJI2Vsc2UKCQkJcmV0dXJuIHZlYzMoIDAuMCApOwoJCSNlbmRpZgoJfQoJI2lmZGVmIFVTRV9BTklTT1RST1BZCgkJdmVjMyBnZXRJQkxBbmlzb3Ryb3B5UmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gdmVjMyBiaXRhbmdlbnQsIGNvbnN0IGluIGZsb2F0IGFuaXNvdHJvcHkgKSB7CgkJCSNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWCgkJCQl2ZWMzIGJlbnROb3JtYWwgPSBjcm9zcyggYml0YW5nZW50LCB2aWV3RGlyICk7CgkJCQliZW50Tm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggYmVudE5vcm1hbCwgYml0YW5nZW50ICkgKTsKCQkJCWJlbnROb3JtYWwgPSBub3JtYWxpemUoIG1peCggYmVudE5vcm1hbCwgbm9ybWFsLCBwb3cyKCBwb3cyKCAxLjAgLSBhbmlzb3Ryb3B5ICogKCAxLjAgLSByb3VnaG5lc3MgKSApICkgKSApOwoJCQkJcmV0dXJuIGdldElCTFJhZGlhbmNlKCB2aWV3RGlyLCBiZW50Tm9ybWFsLCByb3VnaG5lc3MgKTsKCQkJI2Vsc2UKCQkJCXJldHVybiB2ZWMzKCAwLjAgKTsKCQkJI2VuZGlmCgkJfQoJI2VuZGlmCiNlbmRpZmAsVW89YFRvb25NYXRlcmlhbCBtYXRlcmlhbDsKbWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjtgLEZvPWB2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjsKc3RydWN0IFRvb25NYXRlcmlhbCB7Cgl2ZWMzIGRpZmZ1c2VDb2xvcjsKfTsKdm9pZCBSRV9EaXJlY3RfVG9vbiggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gVG9vbk1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHsKCXZlYzMgaXJyYWRpYW5jZSA9IGdldEdyYWRpZW50SXJyYWRpYW5jZSggZ2VvbWV0cnlOb3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICogZGlyZWN0TGlnaHQuY29sb3I7CglyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApOwp9CnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX1Rvb24oIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gVG9vbk1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHsKCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTsKfQojZGVmaW5lIFJFX0RpcmVjdAkJCQlSRV9EaXJlY3RfVG9vbgojZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZQkJUkVfSW5kaXJlY3REaWZmdXNlX1Rvb25gLElvPWBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWw7Cm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2I7Cm1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBzcGVjdWxhcjsKbWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgPSBzaGluaW5lc3M7Cm1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGggPSBzcGVjdWxhclN0cmVuZ3RoO2AsTm89YHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uOwpzdHJ1Y3QgQmxpbm5QaG9uZ01hdGVyaWFsIHsKCXZlYzMgZGlmZnVzZUNvbG9yOwoJdmVjMyBzcGVjdWxhckNvbG9yOwoJZmxvYXQgc3BlY3VsYXJTaGluaW5lc3M7CglmbG9hdCBzcGVjdWxhclN0cmVuZ3RoOwp9Owp2b2lkIFJFX0RpcmVjdF9CbGlublBob25nKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkgewoJZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeU5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTsKCXZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7CglyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApOwoJcmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIEJSREZfQmxpbm5QaG9uZyggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Tm9ybWFsLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyApICogbWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aDsKfQp2b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7CglyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7Cn0KI2RlZmluZSBSRV9EaXJlY3QJCQkJUkVfRGlyZWN0X0JsaW5uUGhvbmcKI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2UJCVJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nYCxPbz1gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbDsKbWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYiAqICggMS4wIC0gbWV0YWxuZXNzRmFjdG9yICk7CnZlYzMgZHh5ID0gbWF4KCBhYnMoIGRGZHgoIG5vblBlcnR1cmJlZE5vcm1hbCApICksIGFicyggZEZkeSggbm9uUGVydHVyYmVkTm9ybWFsICkgKSApOwpmbG9hdCBnZW9tZXRyeVJvdWdobmVzcyA9IG1heCggbWF4KCBkeHkueCwgZHh5LnkgKSwgZHh5LnogKTsKbWF0ZXJpYWwucm91Z2huZXNzID0gbWF4KCByb3VnaG5lc3NGYWN0b3IsIDAuMDUyNSApO21hdGVyaWFsLnJvdWdobmVzcyArPSBnZW9tZXRyeVJvdWdobmVzczsKbWF0ZXJpYWwucm91Z2huZXNzID0gbWluKCBtYXRlcmlhbC5yb3VnaG5lc3MsIDEuMCApOwojaWZkZWYgSU9SCgltYXRlcmlhbC5pb3IgPSBpb3I7CgkjaWZkZWYgVVNFX1NQRUNVTEFSCgkJZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IgPSBzcGVjdWxhckludGVuc2l0eTsKCQl2ZWMzIHNwZWN1bGFyQ29sb3JGYWN0b3IgPSBzcGVjdWxhckNvbG9yOwoJCSNpZmRlZiBVU0VfU1BFQ1VMQVJfQ09MT1JNQVAKCQkJc3BlY3VsYXJDb2xvckZhY3RvciAqPSB0ZXh0dXJlMkQoIHNwZWN1bGFyQ29sb3JNYXAsIHZTcGVjdWxhckNvbG9yTWFwVXYgKS5yZ2I7CgkJI2VuZGlmCgkJI2lmZGVmIFVTRV9TUEVDVUxBUl9JTlRFTlNJVFlNQVAKCQkJc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IgKj0gdGV4dHVyZTJEKCBzcGVjdWxhckludGVuc2l0eU1hcCwgdlNwZWN1bGFySW50ZW5zaXR5TWFwVXYgKS5hOwoJCSNlbmRpZgoJCW1hdGVyaWFsLnNwZWN1bGFyRjkwID0gbWl4KCBzcGVjdWxhckludGVuc2l0eUZhY3RvciwgMS4wLCBtZXRhbG5lc3NGYWN0b3IgKTsKCSNlbHNlCgkJZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IgPSAxLjA7CgkJdmVjMyBzcGVjdWxhckNvbG9yRmFjdG9yID0gdmVjMyggMS4wICk7CgkJbWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSAxLjA7CgkjZW5kaWYKCW1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBtaXgoIG1pbiggcG93MiggKCBtYXRlcmlhbC5pb3IgLSAxLjAgKSAvICggbWF0ZXJpYWwuaW9yICsgMS4wICkgKSAqIHNwZWN1bGFyQ29sb3JGYWN0b3IsIHZlYzMoIDEuMCApICkgKiBzcGVjdWxhckludGVuc2l0eUZhY3RvciwgZGlmZnVzZUNvbG9yLnJnYiwgbWV0YWxuZXNzRmFjdG9yICk7CiNlbHNlCgltYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gbWl4KCB2ZWMzKCAwLjA0ICksIGRpZmZ1c2VDb2xvci5yZ2IsIG1ldGFsbmVzc0ZhY3RvciApOwoJbWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSAxLjA7CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVAoJbWF0ZXJpYWwuY2xlYXJjb2F0ID0gY2xlYXJjb2F0OwoJbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gY2xlYXJjb2F0Um91Z2huZXNzOwoJbWF0ZXJpYWwuY2xlYXJjb2F0RjAgPSB2ZWMzKCAwLjA0ICk7CgltYXRlcmlhbC5jbGVhcmNvYXRGOTAgPSAxLjA7CgkjaWZkZWYgVVNFX0NMRUFSQ09BVE1BUAoJCW1hdGVyaWFsLmNsZWFyY29hdCAqPSB0ZXh0dXJlMkQoIGNsZWFyY29hdE1hcCwgdkNsZWFyY29hdE1hcFV2ICkueDsKCSNlbmRpZgoJI2lmZGVmIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTTUFQCgkJbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICo9IHRleHR1cmUyRCggY2xlYXJjb2F0Um91Z2huZXNzTWFwLCB2Q2xlYXJjb2F0Um91Z2huZXNzTWFwVXYgKS55OwoJI2VuZGlmCgltYXRlcmlhbC5jbGVhcmNvYXQgPSBzYXR1cmF0ZSggbWF0ZXJpYWwuY2xlYXJjb2F0ICk7CW1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyA9IG1heCggbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzLCAwLjA1MjUgKTsKCW1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyArPSBnZW9tZXRyeVJvdWdobmVzczsKCW1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyA9IG1pbiggbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzLCAxLjAgKTsKI2VuZGlmCiNpZmRlZiBVU0VfRElTUEVSU0lPTgoJbWF0ZXJpYWwuZGlzcGVyc2lvbiA9IGRpc3BlcnNpb247CiNlbmRpZgojaWZkZWYgVVNFX0lSSURFU0NFTkNFCgltYXRlcmlhbC5pcmlkZXNjZW5jZSA9IGlyaWRlc2NlbmNlOwoJbWF0ZXJpYWwuaXJpZGVzY2VuY2VJT1IgPSBpcmlkZXNjZW5jZUlPUjsKCSNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VNQVAKCQltYXRlcmlhbC5pcmlkZXNjZW5jZSAqPSB0ZXh0dXJlMkQoIGlyaWRlc2NlbmNlTWFwLCB2SXJpZGVzY2VuY2VNYXBVdiApLnI7CgkjZW5kaWYKCSNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQCgkJbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3MgPSAoaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtIC0gaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtKSAqIHRleHR1cmUyRCggaXJpZGVzY2VuY2VUaGlja25lc3NNYXAsIHZJcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2ICkuZyArIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bTsKCSNlbHNlCgkJbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3MgPSBpcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW07CgkjZW5kaWYKI2VuZGlmCiNpZmRlZiBVU0VfU0hFRU4KCW1hdGVyaWFsLnNoZWVuQ29sb3IgPSBzaGVlbkNvbG9yOwoJI2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUAoJCW1hdGVyaWFsLnNoZWVuQ29sb3IgKj0gdGV4dHVyZTJEKCBzaGVlbkNvbG9yTWFwLCB2U2hlZW5Db2xvck1hcFV2ICkucmdiOwoJI2VuZGlmCgltYXRlcmlhbC5zaGVlblJvdWdobmVzcyA9IGNsYW1wKCBzaGVlblJvdWdobmVzcywgMC4wNywgMS4wICk7CgkjaWZkZWYgVVNFX1NIRUVOX1JPVUdITkVTU01BUAoJCW1hdGVyaWFsLnNoZWVuUm91Z2huZXNzICo9IHRleHR1cmUyRCggc2hlZW5Sb3VnaG5lc3NNYXAsIHZTaGVlblJvdWdobmVzc01hcFV2ICkuYTsKCSNlbmRpZgojZW5kaWYKI2lmZGVmIFVTRV9BTklTT1RST1BZCgkjaWZkZWYgVVNFX0FOSVNPVFJPUFlNQVAKCQltYXQyIGFuaXNvdHJvcHlNYXQgPSBtYXQyKCBhbmlzb3Ryb3B5VmVjdG9yLngsIGFuaXNvdHJvcHlWZWN0b3IueSwgLSBhbmlzb3Ryb3B5VmVjdG9yLnksIGFuaXNvdHJvcHlWZWN0b3IueCApOwoJCXZlYzMgYW5pc290cm9weVBvbGFyID0gdGV4dHVyZTJEKCBhbmlzb3Ryb3B5TWFwLCB2QW5pc290cm9weU1hcFV2ICkucmdiOwoJCXZlYzIgYW5pc290cm9weVYgPSBhbmlzb3Ryb3B5TWF0ICogbm9ybWFsaXplKCAyLjAgKiBhbmlzb3Ryb3B5UG9sYXIucmcgLSB2ZWMyKCAxLjAgKSApICogYW5pc290cm9weVBvbGFyLmI7CgkjZWxzZQoJCXZlYzIgYW5pc290cm9weVYgPSBhbmlzb3Ryb3B5VmVjdG9yOwoJI2VuZGlmCgltYXRlcmlhbC5hbmlzb3Ryb3B5ID0gbGVuZ3RoKCBhbmlzb3Ryb3B5ViApOwoJaWYoIG1hdGVyaWFsLmFuaXNvdHJvcHkgPT0gMC4wICkgewoJCWFuaXNvdHJvcHlWID0gdmVjMiggMS4wLCAwLjAgKTsKCX0gZWxzZSB7CgkJYW5pc290cm9weVYgLz0gbWF0ZXJpYWwuYW5pc290cm9weTsKCQltYXRlcmlhbC5hbmlzb3Ryb3B5ID0gc2F0dXJhdGUoIG1hdGVyaWFsLmFuaXNvdHJvcHkgKTsKCX0KCW1hdGVyaWFsLmFscGhhVCA9IG1peCggcG93MiggbWF0ZXJpYWwucm91Z2huZXNzICksIDEuMCwgcG93MiggbWF0ZXJpYWwuYW5pc290cm9weSApICk7CgltYXRlcmlhbC5hbmlzb3Ryb3B5VCA9IHRiblsgMCBdICogYW5pc290cm9weVYueCArIHRiblsgMSBdICogYW5pc290cm9weVYueTsKCW1hdGVyaWFsLmFuaXNvdHJvcHlCID0gdGJuWyAxIF0gKiBhbmlzb3Ryb3B5Vi54IC0gdGJuWyAwIF0gKiBhbmlzb3Ryb3B5Vi55OwojZW5kaWZgLEJvPWBzdHJ1Y3QgUGh5c2ljYWxNYXRlcmlhbCB7Cgl2ZWMzIGRpZmZ1c2VDb2xvcjsKCWZsb2F0IHJvdWdobmVzczsKCXZlYzMgc3BlY3VsYXJDb2xvcjsKCWZsb2F0IHNwZWN1bGFyRjkwOwoJZmxvYXQgZGlzcGVyc2lvbjsKCSNpZmRlZiBVU0VfQ0xFQVJDT0FUCgkJZmxvYXQgY2xlYXJjb2F0OwoJCWZsb2F0IGNsZWFyY29hdFJvdWdobmVzczsKCQl2ZWMzIGNsZWFyY29hdEYwOwoJCWZsb2F0IGNsZWFyY29hdEY5MDsKCSNlbmRpZgoJI2lmZGVmIFVTRV9JUklERVNDRU5DRQoJCWZsb2F0IGlyaWRlc2NlbmNlOwoJCWZsb2F0IGlyaWRlc2NlbmNlSU9SOwoJCWZsb2F0IGlyaWRlc2NlbmNlVGhpY2tuZXNzOwoJCXZlYzMgaXJpZGVzY2VuY2VGcmVzbmVsOwoJCXZlYzMgaXJpZGVzY2VuY2VGMDsKCSNlbmRpZgoJI2lmZGVmIFVTRV9TSEVFTgoJCXZlYzMgc2hlZW5Db2xvcjsKCQlmbG9hdCBzaGVlblJvdWdobmVzczsKCSNlbmRpZgoJI2lmZGVmIElPUgoJCWZsb2F0IGlvcjsKCSNlbmRpZgoJI2lmZGVmIFVTRV9UUkFOU01JU1NJT04KCQlmbG9hdCB0cmFuc21pc3Npb247CgkJZmxvYXQgdHJhbnNtaXNzaW9uQWxwaGE7CgkJZmxvYXQgdGhpY2tuZXNzOwoJCWZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2U7CgkJdmVjMyBhdHRlbnVhdGlvbkNvbG9yOwoJI2VuZGlmCgkjaWZkZWYgVVNFX0FOSVNPVFJPUFkKCQlmbG9hdCBhbmlzb3Ryb3B5OwoJCWZsb2F0IGFscGhhVDsKCQl2ZWMzIGFuaXNvdHJvcHlUOwoJCXZlYzMgYW5pc290cm9weUI7CgkjZW5kaWYKfTsKdmVjMyBjbGVhcmNvYXRTcGVjdWxhckRpcmVjdCA9IHZlYzMoIDAuMCApOwp2ZWMzIGNsZWFyY29hdFNwZWN1bGFySW5kaXJlY3QgPSB2ZWMzKCAwLjAgKTsKdmVjMyBzaGVlblNwZWN1bGFyRGlyZWN0ID0gdmVjMyggMC4wICk7CnZlYzMgc2hlZW5TcGVjdWxhckluZGlyZWN0ID0gdmVjMygwLjAgKTsKdmVjMyBTY2hsaWNrX3RvX0YwKCBjb25zdCBpbiB2ZWMzIGYsIGNvbnN0IGluIGZsb2F0IGY5MCwgY29uc3QgaW4gZmxvYXQgZG90VkggKSB7CiAgICBmbG9hdCB4ID0gY2xhbXAoIDEuMCAtIGRvdFZILCAwLjAsIDEuMCApOwogICAgZmxvYXQgeDIgPSB4ICogeDsKICAgIGZsb2F0IHg1ID0gY2xhbXAoIHggKiB4MiAqIHgyLCAwLjAsIDAuOTk5OSApOwogICAgcmV0dXJuICggZiAtIHZlYzMoIGY5MCApICogeDUgKSAvICggMS4wIC0geDUgKTsKfQpmbG9hdCBWX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROTCwgY29uc3QgaW4gZmxvYXQgZG90TlYgKSB7CglmbG9hdCBhMiA9IHBvdzIoIGFscGhhICk7CglmbG9hdCBndiA9IGRvdE5MICogc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROViApICk7CglmbG9hdCBnbCA9IGRvdE5WICogc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROTCApICk7CglyZXR1cm4gMC41IC8gbWF4KCBndiArIGdsLCBFUFNJTE9OICk7Cn0KZmxvYXQgRF9HR1goIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHsKCWZsb2F0IGEyID0gcG93MiggYWxwaGEgKTsKCWZsb2F0IGRlbm9tID0gcG93MiggZG90TkggKSAqICggYTIgLSAxLjAgKSArIDEuMDsKCXJldHVybiBSRUNJUFJPQ0FMX1BJICogYTIgLyBwb3cyKCBkZW5vbSApOwp9CiNpZmRlZiBVU0VfQU5JU09UUk9QWQoJZmxvYXQgVl9HR1hfU21pdGhDb3JyZWxhdGVkX0FuaXNvdHJvcGljKCBjb25zdCBpbiBmbG9hdCBhbHBoYVQsIGNvbnN0IGluIGZsb2F0IGFscGhhQiwgY29uc3QgaW4gZmxvYXQgZG90VFYsIGNvbnN0IGluIGZsb2F0IGRvdEJWLCBjb25zdCBpbiBmbG9hdCBkb3RUTCwgY29uc3QgaW4gZmxvYXQgZG90QkwsIGNvbnN0IGluIGZsb2F0IGRvdE5WLCBjb25zdCBpbiBmbG9hdCBkb3ROTCApIHsKCQlmbG9hdCBndiA9IGRvdE5MICogbGVuZ3RoKCB2ZWMzKCBhbHBoYVQgKiBkb3RUViwgYWxwaGFCICogZG90QlYsIGRvdE5WICkgKTsKCQlmbG9hdCBnbCA9IGRvdE5WICogbGVuZ3RoKCB2ZWMzKCBhbHBoYVQgKiBkb3RUTCwgYWxwaGFCICogZG90QkwsIGRvdE5MICkgKTsKCQlmbG9hdCB2ID0gMC41IC8gKCBndiArIGdsICk7CgkJcmV0dXJuIHNhdHVyYXRlKHYpOwoJfQoJZmxvYXQgRF9HR1hfQW5pc290cm9waWMoIGNvbnN0IGluIGZsb2F0IGFscGhhVCwgY29uc3QgaW4gZmxvYXQgYWxwaGFCLCBjb25zdCBpbiBmbG9hdCBkb3ROSCwgY29uc3QgaW4gZmxvYXQgZG90VEgsIGNvbnN0IGluIGZsb2F0IGRvdEJIICkgewoJCWZsb2F0IGEyID0gYWxwaGFUICogYWxwaGFCOwoJCWhpZ2hwIHZlYzMgdiA9IHZlYzMoIGFscGhhQiAqIGRvdFRILCBhbHBoYVQgKiBkb3RCSCwgYTIgKiBkb3ROSCApOwoJCWhpZ2hwIGZsb2F0IHYyID0gZG90KCB2LCB2ICk7CgkJZmxvYXQgdzIgPSBhMiAvIHYyOwoJCXJldHVybiBSRUNJUFJPQ0FMX1BJICogYTIgKiBwb3cyICggdzIgKTsKCX0KI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUCgl2ZWMzIEJSREZfR0dYX0NsZWFyY29hdCggY29uc3QgaW4gdmVjMyBsaWdodERpciwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCkgewoJCXZlYzMgZjAgPSBtYXRlcmlhbC5jbGVhcmNvYXRGMDsKCQlmbG9hdCBmOTAgPSBtYXRlcmlhbC5jbGVhcmNvYXRGOTA7CgkJZmxvYXQgcm91Z2huZXNzID0gbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzOwoJCWZsb2F0IGFscGhhID0gcG93Miggcm91Z2huZXNzICk7CgkJdmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBsaWdodERpciArIHZpZXdEaXIgKTsKCQlmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApOwoJCWZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTsKCQlmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7CgkJZmxvYXQgZG90VkggPSBzYXR1cmF0ZSggZG90KCB2aWV3RGlyLCBoYWxmRGlyICkgKTsKCQl2ZWMzIEYgPSBGX1NjaGxpY2soIGYwLCBmOTAsIGRvdFZIICk7CgkJZmxvYXQgViA9IFZfR0dYX1NtaXRoQ29ycmVsYXRlZCggYWxwaGEsIGRvdE5MLCBkb3ROViApOwoJCWZsb2F0IEQgPSBEX0dHWCggYWxwaGEsIGRvdE5IICk7CgkJcmV0dXJuIEYgKiAoIFYgKiBEICk7Cgl9CiNlbmRpZgp2ZWMzIEJSREZfR0dYKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsICkgewoJdmVjMyBmMCA9IG1hdGVyaWFsLnNwZWN1bGFyQ29sb3I7CglmbG9hdCBmOTAgPSBtYXRlcmlhbC5zcGVjdWxhckY5MDsKCWZsb2F0IHJvdWdobmVzcyA9IG1hdGVyaWFsLnJvdWdobmVzczsKCWZsb2F0IGFscGhhID0gcG93Miggcm91Z2huZXNzICk7Cgl2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApOwoJZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTsKCWZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTsKCWZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTsKCWZsb2F0IGRvdFZIID0gc2F0dXJhdGUoIGRvdCggdmlld0RpciwgaGFsZkRpciApICk7Cgl2ZWMzIEYgPSBGX1NjaGxpY2soIGYwLCBmOTAsIGRvdFZIICk7CgkjaWZkZWYgVVNFX0lSSURFU0NFTkNFCgkJRiA9IG1peCggRiwgbWF0ZXJpYWwuaXJpZGVzY2VuY2VGcmVzbmVsLCBtYXRlcmlhbC5pcmlkZXNjZW5jZSApOwoJI2VuZGlmCgkjaWZkZWYgVVNFX0FOSVNPVFJPUFkKCQlmbG9hdCBkb3RUTCA9IGRvdCggbWF0ZXJpYWwuYW5pc290cm9weVQsIGxpZ2h0RGlyICk7CgkJZmxvYXQgZG90VFYgPSBkb3QoIG1hdGVyaWFsLmFuaXNvdHJvcHlULCB2aWV3RGlyICk7CgkJZmxvYXQgZG90VEggPSBkb3QoIG1hdGVyaWFsLmFuaXNvdHJvcHlULCBoYWxmRGlyICk7CgkJZmxvYXQgZG90QkwgPSBkb3QoIG1hdGVyaWFsLmFuaXNvdHJvcHlCLCBsaWdodERpciApOwoJCWZsb2F0IGRvdEJWID0gZG90KCBtYXRlcmlhbC5hbmlzb3Ryb3B5Qiwgdmlld0RpciApOwoJCWZsb2F0IGRvdEJIID0gZG90KCBtYXRlcmlhbC5hbmlzb3Ryb3B5QiwgaGFsZkRpciApOwoJCWZsb2F0IFYgPSBWX0dHWF9TbWl0aENvcnJlbGF0ZWRfQW5pc290cm9waWMoIG1hdGVyaWFsLmFscGhhVCwgYWxwaGEsIGRvdFRWLCBkb3RCViwgZG90VEwsIGRvdEJMLCBkb3ROViwgZG90TkwgKTsKCQlmbG9hdCBEID0gRF9HR1hfQW5pc290cm9waWMoIG1hdGVyaWFsLmFscGhhVCwgYWxwaGEsIGRvdE5ILCBkb3RUSCwgZG90QkggKTsKCSNlbHNlCgkJZmxvYXQgViA9IFZfR0dYX1NtaXRoQ29ycmVsYXRlZCggYWxwaGEsIGRvdE5MLCBkb3ROViApOwoJCWZsb2F0IEQgPSBEX0dHWCggYWxwaGEsIGRvdE5IICk7CgkjZW5kaWYKCXJldHVybiBGICogKCBWICogRCApOwp9CnZlYzIgTFRDX1V2KCBjb25zdCBpbiB2ZWMzIE4sIGNvbnN0IGluIHZlYzMgViwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkgewoJY29uc3QgZmxvYXQgTFVUX1NJWkUgPSA2NC4wOwoJY29uc3QgZmxvYXQgTFVUX1NDQUxFID0gKCBMVVRfU0laRSAtIDEuMCApIC8gTFVUX1NJWkU7Cgljb25zdCBmbG9hdCBMVVRfQklBUyA9IDAuNSAvIExVVF9TSVpFOwoJZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBOLCBWICkgKTsKCXZlYzIgdXYgPSB2ZWMyKCByb3VnaG5lc3MsIHNxcnQoIDEuMCAtIGRvdE5WICkgKTsKCXV2ID0gdXYgKiBMVVRfU0NBTEUgKyBMVVRfQklBUzsKCXJldHVybiB1djsKfQpmbG9hdCBMVENfQ2xpcHBlZFNwaGVyZUZvcm1GYWN0b3IoIGNvbnN0IGluIHZlYzMgZiApIHsKCWZsb2F0IGwgPSBsZW5ndGgoIGYgKTsKCXJldHVybiBtYXgoICggbCAqIGwgKyBmLnogKSAvICggbCArIDEuMCApLCAwLjAgKTsKfQp2ZWMzIExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29uc3QgaW4gdmVjMyB2MSwgY29uc3QgaW4gdmVjMyB2MiApIHsKCWZsb2F0IHggPSBkb3QoIHYxLCB2MiApOwoJZmxvYXQgeSA9IGFicyggeCApOwoJZmxvYXQgYSA9IDAuODU0Mzk4NSArICggMC40OTY1MTU1ICsgMC4wMTQ1MjA2ICogeSApICogeTsKCWZsb2F0IGIgPSAzLjQxNzU5NDAgKyAoIDQuMTYxNjcyNCArIHkgKSAqIHk7CglmbG9hdCB2ID0gYSAvIGI7CglmbG9hdCB0aGV0YV9zaW50aGV0YSA9ICggeCA+IDAuMCApID8gdiA6IDAuNSAqIGludmVyc2VzcXJ0KCBtYXgoIDEuMCAtIHggKiB4LCAxZS03ICkgKSAtIHY7CglyZXR1cm4gY3Jvc3MoIHYxLCB2MiApICogdGhldGFfc2ludGhldGE7Cn0KdmVjMyBMVENfRXZhbHVhdGUoIGNvbnN0IGluIHZlYzMgTiwgY29uc3QgaW4gdmVjMyBWLCBjb25zdCBpbiB2ZWMzIFAsIGNvbnN0IGluIG1hdDMgbUludiwgY29uc3QgaW4gdmVjMyByZWN0Q29vcmRzWyA0IF0gKSB7Cgl2ZWMzIHYxID0gcmVjdENvb3Jkc1sgMSBdIC0gcmVjdENvb3Jkc1sgMCBdOwoJdmVjMyB2MiA9IHJlY3RDb29yZHNbIDMgXSAtIHJlY3RDb29yZHNbIDAgXTsKCXZlYzMgbGlnaHROb3JtYWwgPSBjcm9zcyggdjEsIHYyICk7CglpZiggZG90KCBsaWdodE5vcm1hbCwgUCAtIHJlY3RDb29yZHNbIDAgXSApIDwgMC4wICkgcmV0dXJuIHZlYzMoIDAuMCApOwoJdmVjMyBUMSwgVDI7CglUMSA9IG5vcm1hbGl6ZSggViAtIE4gKiBkb3QoIFYsIE4gKSApOwoJVDIgPSAtIGNyb3NzKCBOLCBUMSApOwoJbWF0MyBtYXQgPSBtSW52ICogdHJhbnNwb3NlTWF0MyggbWF0MyggVDEsIFQyLCBOICkgKTsKCXZlYzMgY29vcmRzWyA0IF07Cgljb29yZHNbIDAgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMCBdIC0gUCApOwoJY29vcmRzWyAxIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDEgXSAtIFAgKTsKCWNvb3Jkc1sgMiBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAyIF0gLSBQICk7Cgljb29yZHNbIDMgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMyBdIC0gUCApOwoJY29vcmRzWyAwIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMCBdICk7Cgljb29yZHNbIDEgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAxIF0gKTsKCWNvb3Jkc1sgMiBdID0gbm9ybWFsaXplKCBjb29yZHNbIDIgXSApOwoJY29vcmRzWyAzIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMyBdICk7Cgl2ZWMzIHZlY3RvckZvcm1GYWN0b3IgPSB2ZWMzKCAwLjAgKTsKCXZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDAgXSwgY29vcmRzWyAxIF0gKTsKCXZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDEgXSwgY29vcmRzWyAyIF0gKTsKCXZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDIgXSwgY29vcmRzWyAzIF0gKTsKCXZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDMgXSwgY29vcmRzWyAwIF0gKTsKCWZsb2F0IHJlc3VsdCA9IExUQ19DbGlwcGVkU3BoZXJlRm9ybUZhY3RvciggdmVjdG9yRm9ybUZhY3RvciApOwoJcmV0dXJuIHZlYzMoIHJlc3VsdCApOwp9CiNpZiBkZWZpbmVkKCBVU0VfU0hFRU4gKQpmbG9hdCBEX0NoYXJsaWUoIGZsb2F0IHJvdWdobmVzcywgZmxvYXQgZG90TkggKSB7CglmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApOwoJZmxvYXQgaW52QWxwaGEgPSAxLjAgLyBhbHBoYTsKCWZsb2F0IGNvczJoID0gZG90TkggKiBkb3ROSDsKCWZsb2F0IHNpbjJoID0gbWF4KCAxLjAgLSBjb3MyaCwgMC4wMDc4MTI1ICk7CglyZXR1cm4gKCAyLjAgKyBpbnZBbHBoYSApICogcG93KCBzaW4yaCwgaW52QWxwaGEgKiAwLjUgKSAvICggMi4wICogUEkgKTsKfQpmbG9hdCBWX05ldWJlbHQoIGZsb2F0IGRvdE5WLCBmbG9hdCBkb3ROTCApIHsKCXJldHVybiBzYXR1cmF0ZSggMS4wIC8gKCA0LjAgKiAoIGRvdE5MICsgZG90TlYgLSBkb3ROTCAqIGRvdE5WICkgKSApOwp9CnZlYzMgQlJERl9TaGVlbiggY29uc3QgaW4gdmVjMyBsaWdodERpciwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgdmVjMyBzaGVlbkNvbG9yLCBjb25zdCBpbiBmbG9hdCBzaGVlblJvdWdobmVzcyApIHsKCXZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7CglmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApOwoJZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApOwoJZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApOwoJZmxvYXQgRCA9IERfQ2hhcmxpZSggc2hlZW5Sb3VnaG5lc3MsIGRvdE5IICk7CglmbG9hdCBWID0gVl9OZXViZWx0KCBkb3ROViwgZG90TkwgKTsKCXJldHVybiBzaGVlbkNvbG9yICogKCBEICogViApOwp9CiNlbmRpZgpmbG9hdCBJQkxTaGVlbkJSREYoIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHsKCWZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTsKCWZsb2F0IHIyID0gcm91Z2huZXNzICogcm91Z2huZXNzOwoJZmxvYXQgYSA9IHJvdWdobmVzcyA8IDAuMjUgPyAtMzM5LjIgKiByMiArIDE2MS40ICogcm91Z2huZXNzIC0gMjUuOSA6IC04LjQ4ICogcjIgKyAxNC4zICogcm91Z2huZXNzIC0gOS45NTsKCWZsb2F0IGIgPSByb3VnaG5lc3MgPCAwLjI1ID8gNDQuMCAqIHIyIC0gMjMuNyAqIHJvdWdobmVzcyArIDMuMjYgOiAxLjk3ICogcjIgLSAzLjI3ICogcm91Z2huZXNzICsgMC43MjsKCWZsb2F0IERHID0gZXhwKCBhICogZG90TlYgKyBiICkgKyAoIHJvdWdobmVzcyA8IDAuMjUgPyAwLjAgOiAwLjEgKiAoIHJvdWdobmVzcyAtIDAuMjUgKSApOwoJcmV0dXJuIHNhdHVyYXRlKCBERyAqIFJFQ0lQUk9DQUxfUEkgKTsKfQp2ZWMyIERGR0FwcHJveCggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkgewoJZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApOwoJY29uc3QgdmVjNCBjMCA9IHZlYzQoIC0gMSwgLSAwLjAyNzUsIC0gMC41NzIsIDAuMDIyICk7Cgljb25zdCB2ZWM0IGMxID0gdmVjNCggMSwgMC4wNDI1LCAxLjA0LCAtIDAuMDQgKTsKCXZlYzQgciA9IHJvdWdobmVzcyAqIGMwICsgYzE7CglmbG9hdCBhMDA0ID0gbWluKCByLnggKiByLngsIGV4cDIoIC0gOS4yOCAqIGRvdE5WICkgKSAqIHIueCArIHIueTsKCXZlYzIgZmFiID0gdmVjMiggLSAxLjA0LCAxLjA0ICkgKiBhMDA0ICsgci56dzsKCXJldHVybiBmYWI7Cn0KdmVjMyBFbnZpcm9ubWVudEJSREYoIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc3BlY3VsYXJGOTAsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHsKCXZlYzIgZmFiID0gREZHQXBwcm94KCBub3JtYWwsIHZpZXdEaXIsIHJvdWdobmVzcyApOwoJcmV0dXJuIHNwZWN1bGFyQ29sb3IgKiBmYWIueCArIHNwZWN1bGFyRjkwICogZmFiLnk7Cn0KI2lmZGVmIFVTRV9JUklERVNDRU5DRQp2b2lkIGNvbXB1dGVNdWx0aXNjYXR0ZXJpbmdJcmlkZXNjZW5jZSggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gZmxvYXQgaXJpZGVzY2VuY2UsIGNvbnN0IGluIHZlYzMgaXJpZGVzY2VuY2VGMCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBpbm91dCB2ZWMzIHNpbmdsZVNjYXR0ZXIsIGlub3V0IHZlYzMgbXVsdGlTY2F0dGVyICkgewojZWxzZQp2b2lkIGNvbXB1dGVNdWx0aXNjYXR0ZXJpbmcoIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc3BlY3VsYXJGOTAsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgaW5vdXQgdmVjMyBzaW5nbGVTY2F0dGVyLCBpbm91dCB2ZWMzIG11bHRpU2NhdHRlciApIHsKI2VuZGlmCgl2ZWMyIGZhYiA9IERGR0FwcHJveCggbm9ybWFsLCB2aWV3RGlyLCByb3VnaG5lc3MgKTsKCSNpZmRlZiBVU0VfSVJJREVTQ0VOQ0UKCQl2ZWMzIEZyID0gbWl4KCBzcGVjdWxhckNvbG9yLCBpcmlkZXNjZW5jZUYwLCBpcmlkZXNjZW5jZSApOwoJI2Vsc2UKCQl2ZWMzIEZyID0gc3BlY3VsYXJDb2xvcjsKCSNlbmRpZgoJdmVjMyBGc3NFc3MgPSBGciAqIGZhYi54ICsgc3BlY3VsYXJGOTAgKiBmYWIueTsKCWZsb2F0IEVzcyA9IGZhYi54ICsgZmFiLnk7CglmbG9hdCBFbXMgPSAxLjAgLSBFc3M7Cgl2ZWMzIEZhdmcgPSBGciArICggMS4wIC0gRnIgKSAqIDAuMDQ3NjE5Owl2ZWMzIEZtcyA9IEZzc0VzcyAqIEZhdmcgLyAoIDEuMCAtIEVtcyAqIEZhdmcgKTsKCXNpbmdsZVNjYXR0ZXIgKz0gRnNzRXNzOwoJbXVsdGlTY2F0dGVyICs9IEZtcyAqIEVtczsKfQojaWYgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwCgl2b2lkIFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbCggY29uc3QgaW4gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0LCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHsKCQl2ZWMzIG5vcm1hbCA9IGdlb21ldHJ5Tm9ybWFsOwoJCXZlYzMgdmlld0RpciA9IGdlb21ldHJ5Vmlld0RpcjsKCQl2ZWMzIHBvc2l0aW9uID0gZ2VvbWV0cnlQb3NpdGlvbjsKCQl2ZWMzIGxpZ2h0UG9zID0gcmVjdEFyZWFMaWdodC5wb3NpdGlvbjsKCQl2ZWMzIGhhbGZXaWR0aCA9IHJlY3RBcmVhTGlnaHQuaGFsZldpZHRoOwoJCXZlYzMgaGFsZkhlaWdodCA9IHJlY3RBcmVhTGlnaHQuaGFsZkhlaWdodDsKCQl2ZWMzIGxpZ2h0Q29sb3IgPSByZWN0QXJlYUxpZ2h0LmNvbG9yOwoJCWZsb2F0IHJvdWdobmVzcyA9IG1hdGVyaWFsLnJvdWdobmVzczsKCQl2ZWMzIHJlY3RDb29yZHNbIDQgXTsKCQlyZWN0Q29vcmRzWyAwIF0gPSBsaWdodFBvcyArIGhhbGZXaWR0aCAtIGhhbGZIZWlnaHQ7CQlyZWN0Q29vcmRzWyAxIF0gPSBsaWdodFBvcyAtIGhhbGZXaWR0aCAtIGhhbGZIZWlnaHQ7CgkJcmVjdENvb3Jkc1sgMiBdID0gbGlnaHRQb3MgLSBoYWxmV2lkdGggKyBoYWxmSGVpZ2h0OwoJCXJlY3RDb29yZHNbIDMgXSA9IGxpZ2h0UG9zICsgaGFsZldpZHRoICsgaGFsZkhlaWdodDsKCQl2ZWMyIHV2ID0gTFRDX1V2KCBub3JtYWwsIHZpZXdEaXIsIHJvdWdobmVzcyApOwoJCXZlYzQgdDEgPSB0ZXh0dXJlMkQoIGx0Y18xLCB1diApOwoJCXZlYzQgdDIgPSB0ZXh0dXJlMkQoIGx0Y18yLCB1diApOwoJCW1hdDMgbUludiA9IG1hdDMoCgkJCXZlYzMoIHQxLngsIDAsIHQxLnkgKSwKCQkJdmVjMyggICAgMCwgMSwgICAgMCApLAoJCQl2ZWMzKCB0MS56LCAwLCB0MS53ICkKCQkpOwoJCXZlYzMgZnJlc25lbCA9ICggbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciAqIHQyLnggKyAoIHZlYzMoIDEuMCApIC0gbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciApICogdDIueSApOwoJCXJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGxpZ2h0Q29sb3IgKiBmcmVzbmVsICogTFRDX0V2YWx1YXRlKCBub3JtYWwsIHZpZXdEaXIsIHBvc2l0aW9uLCBtSW52LCByZWN0Q29vcmRzICk7CgkJcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBsaWdodENvbG9yICogbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICogTFRDX0V2YWx1YXRlKCBub3JtYWwsIHZpZXdEaXIsIHBvc2l0aW9uLCBtYXQzKCAxLjAgKSwgcmVjdENvb3JkcyApOwoJfQojZW5kaWYKdm9pZCBSRV9EaXJlY3RfUGh5c2ljYWwoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkgewoJZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeU5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTsKCXZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7CgkjaWZkZWYgVVNFX0NMRUFSQ09BVAoJCWZsb2F0IGRvdE5MY2MgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTsKCQl2ZWMzIGNjSXJyYWRpYW5jZSA9IGRvdE5MY2MgKiBkaXJlY3RMaWdodC5jb2xvcjsKCQljbGVhcmNvYXRTcGVjdWxhckRpcmVjdCArPSBjY0lycmFkaWFuY2UgKiBCUkRGX0dHWF9DbGVhcmNvYXQoIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwgKTsKCSNlbmRpZgoJI2lmZGVmIFVTRV9TSEVFTgoJCXNoZWVuU3BlY3VsYXJEaXJlY3QgKz0gaXJyYWRpYW5jZSAqIEJSREZfU2hlZW4oIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeU5vcm1hbCwgbWF0ZXJpYWwuc2hlZW5Db2xvciwgbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgKTsKCSNlbmRpZgoJcmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIEJSREZfR0dYKCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlOb3JtYWwsIG1hdGVyaWFsICk7CglyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApOwp9CnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX1BoeXNpY2FsKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkgewoJcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApOwp9CnZvaWQgUkVfSW5kaXJlY3RTcGVjdWxhcl9QaHlzaWNhbCggY29uc3QgaW4gdmVjMyByYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGNsZWFyY29hdFJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCkgewoJI2lmZGVmIFVTRV9DTEVBUkNPQVQKCQljbGVhcmNvYXRTcGVjdWxhckluZGlyZWN0ICs9IGNsZWFyY29hdFJhZGlhbmNlICogRW52aXJvbm1lbnRCUkRGKCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBtYXRlcmlhbC5jbGVhcmNvYXRGMCwgbWF0ZXJpYWwuY2xlYXJjb2F0RjkwLCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKTsKCSNlbmRpZgoJI2lmZGVmIFVTRV9TSEVFTgoJCXNoZWVuU3BlY3VsYXJJbmRpcmVjdCArPSBpcnJhZGlhbmNlICogbWF0ZXJpYWwuc2hlZW5Db2xvciAqIElCTFNoZWVuQlJERiggZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgKTsKCSNlbmRpZgoJdmVjMyBzaW5nbGVTY2F0dGVyaW5nID0gdmVjMyggMC4wICk7Cgl2ZWMzIG11bHRpU2NhdHRlcmluZyA9IHZlYzMoIDAuMCApOwoJdmVjMyBjb3NpbmVXZWlnaHRlZElycmFkaWFuY2UgPSBpcnJhZGlhbmNlICogUkVDSVBST0NBTF9QSTsKCSNpZmRlZiBVU0VfSVJJREVTQ0VOQ0UKCQljb21wdXRlTXVsdGlzY2F0dGVyaW5nSXJpZGVzY2VuY2UoIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyRjkwLCBtYXRlcmlhbC5pcmlkZXNjZW5jZSwgbWF0ZXJpYWwuaXJpZGVzY2VuY2VGcmVzbmVsLCBtYXRlcmlhbC5yb3VnaG5lc3MsIHNpbmdsZVNjYXR0ZXJpbmcsIG11bHRpU2NhdHRlcmluZyApOwoJI2Vsc2UKCQljb21wdXRlTXVsdGlzY2F0dGVyaW5nKCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCwgbWF0ZXJpYWwucm91Z2huZXNzLCBzaW5nbGVTY2F0dGVyaW5nLCBtdWx0aVNjYXR0ZXJpbmcgKTsKCSNlbmRpZgoJdmVjMyB0b3RhbFNjYXR0ZXJpbmcgPSBzaW5nbGVTY2F0dGVyaW5nICsgbXVsdGlTY2F0dGVyaW5nOwoJdmVjMyBkaWZmdXNlID0gbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICogKCAxLjAgLSBtYXgoIG1heCggdG90YWxTY2F0dGVyaW5nLnIsIHRvdGFsU2NhdHRlcmluZy5nICksIHRvdGFsU2NhdHRlcmluZy5iICkgKTsKCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gcmFkaWFuY2UgKiBzaW5nbGVTY2F0dGVyaW5nOwoJcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArPSBtdWx0aVNjYXR0ZXJpbmcgKiBjb3NpbmVXZWlnaHRlZElycmFkaWFuY2U7CglyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gZGlmZnVzZSAqIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZTsKfQojZGVmaW5lIFJFX0RpcmVjdAkJCQlSRV9EaXJlY3RfUGh5c2ljYWwKI2RlZmluZSBSRV9EaXJlY3RfUmVjdEFyZWEJCVJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbAojZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZQkJUkVfSW5kaXJlY3REaWZmdXNlX1BoeXNpY2FsCiNkZWZpbmUgUkVfSW5kaXJlY3RTcGVjdWxhcgkJUkVfSW5kaXJlY3RTcGVjdWxhcl9QaHlzaWNhbApmbG9hdCBjb21wdXRlU3BlY3VsYXJPY2NsdXNpb24oIGNvbnN0IGluIGZsb2F0IGRvdE5WLCBjb25zdCBpbiBmbG9hdCBhbWJpZW50T2NjbHVzaW9uLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7CglyZXR1cm4gc2F0dXJhdGUoIHBvdyggZG90TlYgKyBhbWJpZW50T2NjbHVzaW9uLCBleHAyKCAtIDE2LjAgKiByb3VnaG5lc3MgLSAxLjAgKSApIC0gMS4wICsgYW1iaWVudE9jY2x1c2lvbiApOwp9YCx6bz1gCnZlYzMgZ2VvbWV0cnlQb3NpdGlvbiA9IC0gdlZpZXdQb3NpdGlvbjsKdmVjMyBnZW9tZXRyeU5vcm1hbCA9IG5vcm1hbDsKdmVjMyBnZW9tZXRyeVZpZXdEaXIgPSAoIGlzT3J0aG9ncmFwaGljICkgPyB2ZWMzKCAwLCAwLCAxICkgOiBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTsKdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCA9IHZlYzMoIDAuMCApOwojaWZkZWYgVVNFX0NMRUFSQ09BVAoJZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwgPSBjbGVhcmNvYXROb3JtYWw7CiNlbmRpZgojaWZkZWYgVVNFX0lSSURFU0NFTkNFCglmbG9hdCBkb3ROVmkgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGdlb21ldHJ5Vmlld0RpciApICk7CglpZiAoIG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzID09IDAuMCApIHsKCQltYXRlcmlhbC5pcmlkZXNjZW5jZSA9IDAuMDsKCX0gZWxzZSB7CgkJbWF0ZXJpYWwuaXJpZGVzY2VuY2UgPSBzYXR1cmF0ZSggbWF0ZXJpYWwuaXJpZGVzY2VuY2UgKTsKCX0KCWlmICggbWF0ZXJpYWwuaXJpZGVzY2VuY2UgPiAwLjAgKSB7CgkJbWF0ZXJpYWwuaXJpZGVzY2VuY2VGcmVzbmVsID0gZXZhbElyaWRlc2NlbmNlKCAxLjAsIG1hdGVyaWFsLmlyaWRlc2NlbmNlSU9SLCBkb3ROVmksIG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICk7CgkJbWF0ZXJpYWwuaXJpZGVzY2VuY2VGMCA9IFNjaGxpY2tfdG9fRjAoIG1hdGVyaWFsLmlyaWRlc2NlbmNlRnJlc25lbCwgMS4wLCBkb3ROVmkgKTsKCX0KI2VuZGlmCkluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7CiNpZiAoIE5VTV9QT0lOVF9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0ICkKCVBvaW50TGlnaHQgcG9pbnRMaWdodDsKCSNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwCglQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3c7CgkjZW5kaWYKCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCWZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7CgkJcG9pbnRMaWdodCA9IHBvaW50TGlnaHRzWyBpIF07CgkJZ2V0UG9pbnRMaWdodEluZm8oIHBvaW50TGlnaHQsIGdlb21ldHJ5UG9zaXRpb24sIGRpcmVjdExpZ2h0ICk7CgkJI2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyApCgkJcG9pbnRMaWdodFNoYWRvdyA9IHBvaW50TGlnaHRTaGFkb3dzWyBpIF07CgkJZGlyZWN0TGlnaHQuY29sb3IgKj0gKCBkaXJlY3RMaWdodC52aXNpYmxlICYmIHJlY2VpdmVTaGFkb3cgKSA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0U2hhZG93LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93SW50ZW5zaXR5LCBwb2ludExpZ2h0U2hhZG93LnNoYWRvd0JpYXMsIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93UmFkaXVzLCB2UG9pbnRTaGFkb3dDb29yZFsgaSBdLCBwb2ludExpZ2h0U2hhZG93LnNoYWRvd0NhbWVyYU5lYXIsIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93Q2FtZXJhRmFyICkgOiAxLjA7CgkJI2VuZGlmCgkJUkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnlQb3NpdGlvbiwgZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApOwoJfQoJI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQKI2VuZGlmCiNpZiAoIE5VTV9TUE9UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKQoJU3BvdExpZ2h0IHNwb3RMaWdodDsKCXZlYzQgc3BvdENvbG9yOwoJdmVjMyBzcG90TGlnaHRDb29yZDsKCWJvb2wgaW5TcG90TGlnaHRNYXA7CgkjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwCglTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0U2hhZG93OwoJI2VuZGlmCgkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7CgkJc3BvdExpZ2h0ID0gc3BvdExpZ2h0c1sgaSBdOwoJCWdldFNwb3RMaWdodEluZm8oIHNwb3RMaWdodCwgZ2VvbWV0cnlQb3NpdGlvbiwgZGlyZWN0TGlnaHQgKTsKCQkjaWYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XU19XSVRIX01BUFMgKQoJCSNkZWZpbmUgU1BPVF9MSUdIVF9NQVBfSU5ERVggVU5ST0xMRURfTE9PUF9JTkRFWAoJCSNlbGlmICggVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgKQoJCSNkZWZpbmUgU1BPVF9MSUdIVF9NQVBfSU5ERVggTlVNX1NQT1RfTElHSFRfTUFQUwoJCSNlbHNlCgkJI2RlZmluZSBTUE9UX0xJR0hUX01BUF9JTkRFWCAoIFVOUk9MTEVEX0xPT1BfSU5ERVggLSBOVU1fU1BPVF9MSUdIVF9TSEFET1dTICsgTlVNX1NQT1RfTElHSFRfU0hBRE9XU19XSVRIX01BUFMgKQoJCSNlbmRpZgoJCSNpZiAoIFNQT1RfTElHSFRfTUFQX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfTUFQUyApCgkJCXNwb3RMaWdodENvb3JkID0gdlNwb3RMaWdodENvb3JkWyBpIF0ueHl6IC8gdlNwb3RMaWdodENvb3JkWyBpIF0udzsKCQkJaW5TcG90TGlnaHRNYXAgPSBhbGwoIGxlc3NUaGFuKCBhYnMoIHNwb3RMaWdodENvb3JkICogMi4gLSAxLiApLCB2ZWMzKCAxLjAgKSApICk7CgkJCXNwb3RDb2xvciA9IHRleHR1cmUyRCggc3BvdExpZ2h0TWFwWyBTUE9UX0xJR0hUX01BUF9JTkRFWCBdLCBzcG90TGlnaHRDb29yZC54eSApOwoJCQlkaXJlY3RMaWdodC5jb2xvciA9IGluU3BvdExpZ2h0TWFwID8gZGlyZWN0TGlnaHQuY29sb3IgKiBzcG90Q29sb3IucmdiIDogZGlyZWN0TGlnaHQuY29sb3I7CgkJI2VuZGlmCgkJI3VuZGVmIFNQT1RfTElHSFRfTUFQX0lOREVYCgkJI2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTICkKCQlzcG90TGlnaHRTaGFkb3cgPSBzcG90TGlnaHRTaGFkb3dzWyBpIF07CgkJZGlyZWN0TGlnaHQuY29sb3IgKj0gKCBkaXJlY3RMaWdodC52aXNpYmxlICYmIHJlY2VpdmVTaGFkb3cgKSA/IGdldFNoYWRvdyggc3BvdFNoYWRvd01hcFsgaSBdLCBzcG90TGlnaHRTaGFkb3cuc2hhZG93TWFwU2l6ZSwgc3BvdExpZ2h0U2hhZG93LnNoYWRvd0ludGVuc2l0eSwgc3BvdExpZ2h0U2hhZG93LnNoYWRvd0JpYXMsIHNwb3RMaWdodFNoYWRvdy5zaGFkb3dSYWRpdXMsIHZTcG90TGlnaHRDb29yZFsgaSBdICkgOiAxLjA7CgkJI2VuZGlmCgkJUkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnlQb3NpdGlvbiwgZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApOwoJfQoJI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQKI2VuZGlmCiNpZiAoIE5VTV9ESVJfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApCglEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQ7CgkjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDAKCURpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodFNoYWRvdzsKCSNlbmRpZgoJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJZm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7CgkJZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRzWyBpIF07CgkJZ2V0RGlyZWN0aW9uYWxMaWdodEluZm8oIGRpcmVjdGlvbmFsTGlnaHQsIGRpcmVjdExpZ2h0ICk7CgkJI2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fRElSX0xJR0hUX1NIQURPV1MgKQoJCWRpcmVjdGlvbmFsTGlnaHRTaGFkb3cgPSBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdOwoJCWRpcmVjdExpZ2h0LmNvbG9yICo9ICggZGlyZWN0TGlnaHQudmlzaWJsZSAmJiByZWNlaXZlU2hhZG93ICkgPyBnZXRTaGFkb3coIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBpIF0sIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3cuc2hhZG93TWFwU2l6ZSwgZGlyZWN0aW9uYWxMaWdodFNoYWRvdy5zaGFkb3dJbnRlbnNpdHksIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3cuc2hhZG93QmlhcywgZGlyZWN0aW9uYWxMaWdodFNoYWRvdy5zaGFkb3dSYWRpdXMsIHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDsKCQkjZW5kaWYKCQlSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeVBvc2l0aW9uLCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7Cgl9CgkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAojZW5kaWYKI2lmICggTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0X1JlY3RBcmVhICkKCVJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodDsKCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCWZvciAoIGludCBpID0gMDsgaSA8IE5VTV9SRUNUX0FSRUFfTElHSFRTOyBpICsrICkgewoJCXJlY3RBcmVhTGlnaHQgPSByZWN0QXJlYUxpZ2h0c1sgaSBdOwoJCVJFX0RpcmVjdF9SZWN0QXJlYSggcmVjdEFyZWFMaWdodCwgZ2VvbWV0cnlQb3NpdGlvbiwgZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApOwoJfQoJI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQKI2VuZGlmCiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdERpZmZ1c2UgKQoJdmVjMyBpYmxJcnJhZGlhbmNlID0gdmVjMyggMC4wICk7Cgl2ZWMzIGlycmFkaWFuY2UgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApOwoJI2lmIGRlZmluZWQoIFVTRV9MSUdIVF9QUk9CRVMgKQoJCWlycmFkaWFuY2UgKz0gZ2V0TGlnaHRQcm9iZUlycmFkaWFuY2UoIGxpZ2h0UHJvYmUsIGdlb21ldHJ5Tm9ybWFsICk7CgkjZW5kaWYKCSNpZiAoIE5VTV9IRU1JX0xJR0hUUyA+IDAgKQoJCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCQlmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fSEVNSV9MSUdIVFM7IGkgKysgKSB7CgkJCWlycmFkaWFuY2UgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBnZW9tZXRyeU5vcm1hbCApOwoJCX0KCQkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJI2VuZGlmCiNlbmRpZgojaWYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApCgl2ZWMzIHJhZGlhbmNlID0gdmVjMyggMC4wICk7Cgl2ZWMzIGNsZWFyY29hdFJhZGlhbmNlID0gdmVjMyggMC4wICk7CiNlbmRpZmAsR289YCNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdERpZmZ1c2UgKQoJI2lmZGVmIFVTRV9MSUdIVE1BUAoJCXZlYzQgbGlnaHRNYXBUZXhlbCA9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZMaWdodE1hcFV2ICk7CgkJdmVjMyBsaWdodE1hcElycmFkaWFuY2UgPSBsaWdodE1hcFRleGVsLnJnYiAqIGxpZ2h0TWFwSW50ZW5zaXR5OwoJCWlycmFkaWFuY2UgKz0gbGlnaHRNYXBJcnJhZGlhbmNlOwoJI2VuZGlmCgkjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFNUQU5EQVJEICkgJiYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApCgkJaWJsSXJyYWRpYW5jZSArPSBnZXRJQkxJcnJhZGlhbmNlKCBnZW9tZXRyeU5vcm1hbCApOwoJI2VuZGlmCiNlbmRpZgojaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKQoJI2lmZGVmIFVTRV9BTklTT1RST1BZCgkJcmFkaWFuY2UgKz0gZ2V0SUJMQW5pc290cm9weVJhZGlhbmNlKCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Tm9ybWFsLCBtYXRlcmlhbC5yb3VnaG5lc3MsIG1hdGVyaWFsLmFuaXNvdHJvcHlCLCBtYXRlcmlhbC5hbmlzb3Ryb3B5ICk7CgkjZWxzZQoJCXJhZGlhbmNlICs9IGdldElCTFJhZGlhbmNlKCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Tm9ybWFsLCBtYXRlcmlhbC5yb3VnaG5lc3MgKTsKCSNlbmRpZgoJI2lmZGVmIFVTRV9DTEVBUkNPQVQKCQljbGVhcmNvYXRSYWRpYW5jZSArPSBnZXRJQkxSYWRpYW5jZSggZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICk7CgkjZW5kaWYKI2VuZGlmYCxIbz1gI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApCglSRV9JbmRpcmVjdERpZmZ1c2UoIGlycmFkaWFuY2UsIGdlb21ldHJ5UG9zaXRpb24sIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTsKI2VuZGlmCiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdFNwZWN1bGFyICkKCVJFX0luZGlyZWN0U3BlY3VsYXIoIHJhZGlhbmNlLCBpYmxJcnJhZGlhbmNlLCBjbGVhcmNvYXRSYWRpYW5jZSwgZ2VvbWV0cnlQb3NpdGlvbiwgZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApOwojZW5kaWZgLFZvPWAjaWYgZGVmaW5lZCggVVNFX0xPR0RFUFRIQlVGICkKCWdsX0ZyYWdEZXB0aCA9IHZJc1BlcnNwZWN0aXZlID09IDAuMCA/IGdsX0ZyYWdDb29yZC56IDogbG9nMiggdkZyYWdEZXB0aCApICogbG9nRGVwdGhCdWZGQyAqIDAuNTsKI2VuZGlmYCxrbz1gI2lmIGRlZmluZWQoIFVTRV9MT0dERVBUSEJVRiApCgl1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7Cgl2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7Cgl2YXJ5aW5nIGZsb2F0IHZJc1BlcnNwZWN0aXZlOwojZW5kaWZgLFdvPWAjaWZkZWYgVVNFX0xPR0RFUFRIQlVGCgl2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7Cgl2YXJ5aW5nIGZsb2F0IHZJc1BlcnNwZWN0aXZlOwojZW5kaWZgLFhvPWAjaWZkZWYgVVNFX0xPR0RFUFRIQlVGCgl2RnJhZ0RlcHRoID0gMS4wICsgZ2xfUG9zaXRpb24udzsKCXZJc1BlcnNwZWN0aXZlID0gZmxvYXQoIGlzUGVyc3BlY3RpdmVNYXRyaXgoIHByb2plY3Rpb25NYXRyaXggKSApOwojZW5kaWZgLHFvPWAjaWZkZWYgVVNFX01BUAoJdmVjNCBzYW1wbGVkRGlmZnVzZUNvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZNYXBVdiApOwoJI2lmZGVmIERFQ09ERV9WSURFT19URVhUVVJFCgkJc2FtcGxlZERpZmZ1c2VDb2xvciA9IHNSR0JUcmFuc2ZlckVPVEYoIHNhbXBsZWREaWZmdXNlQ29sb3IgKTsKCSNlbmRpZgoJZGlmZnVzZUNvbG9yICo9IHNhbXBsZWREaWZmdXNlQ29sb3I7CiNlbmRpZmAsWW89YCNpZmRlZiBVU0VfTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBtYXA7CiNlbmRpZmAsJG89YCNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkKCSNpZiBkZWZpbmVkKCBVU0VfUE9JTlRTX1VWICkKCQl2ZWMyIHV2ID0gdlV2OwoJI2Vsc2UKCQl2ZWMyIHV2ID0gKCB1dlRyYW5zZm9ybSAqIHZlYzMoIGdsX1BvaW50Q29vcmQueCwgMS4wIC0gZ2xfUG9pbnRDb29yZC55LCAxICkgKS54eTsKCSNlbmRpZgojZW5kaWYKI2lmZGVmIFVTRV9NQVAKCWRpZmZ1c2VDb2xvciAqPSB0ZXh0dXJlMkQoIG1hcCwgdXYgKTsKI2VuZGlmCiNpZmRlZiBVU0VfQUxQSEFNQVAKCWRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHV2ICkuZzsKI2VuZGlmYCxLbz1gI2lmIGRlZmluZWQoIFVTRV9QT0lOVFNfVVYgKQoJdmFyeWluZyB2ZWMyIHZVdjsKI2Vsc2UKCSNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkKCQl1bmlmb3JtIG1hdDMgdXZUcmFuc2Zvcm07CgkjZW5kaWYKI2VuZGlmCiNpZmRlZiBVU0VfTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBtYXA7CiNlbmRpZgojaWZkZWYgVVNFX0FMUEhBTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBhbHBoYU1hcDsKI2VuZGlmYCxabz1gZmxvYXQgbWV0YWxuZXNzRmFjdG9yID0gbWV0YWxuZXNzOwojaWZkZWYgVVNFX01FVEFMTkVTU01BUAoJdmVjNCB0ZXhlbE1ldGFsbmVzcyA9IHRleHR1cmUyRCggbWV0YWxuZXNzTWFwLCB2TWV0YWxuZXNzTWFwVXYgKTsKCW1ldGFsbmVzc0ZhY3RvciAqPSB0ZXhlbE1ldGFsbmVzcy5iOwojZW5kaWZgLGpvPWAjaWZkZWYgVVNFX01FVEFMTkVTU01BUAoJdW5pZm9ybSBzYW1wbGVyMkQgbWV0YWxuZXNzTWFwOwojZW5kaWZgLEpvPWAjaWZkZWYgVVNFX0lOU1RBTkNJTkdfTU9SUEgKCWZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgTU9SUEhUQVJHRVRTX0NPVU5UIF07CglmbG9hdCBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2UgPSB0ZXhlbEZldGNoKCBtb3JwaFRleHR1cmUsIGl2ZWMyKCAwLCBnbF9JbnN0YW5jZUlEICksIDAgKS5yOwoJZm9yICggaW50IGkgPSAwOyBpIDwgTU9SUEhUQVJHRVRTX0NPVU5UOyBpICsrICkgewoJCW1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tpXSA9ICB0ZXhlbEZldGNoKCBtb3JwaFRleHR1cmUsIGl2ZWMyKCBpICsgMSwgZ2xfSW5zdGFuY2VJRCApLCAwICkucjsKCX0KI2VuZGlmYCxRbz1gI2lmIGRlZmluZWQoIFVTRV9NT1JQSENPTE9SUyApCgl2Q29sb3IgKj0gbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlOwoJZm9yICggaW50IGkgPSAwOyBpIDwgTU9SUEhUQVJHRVRTX0NPVU5UOyBpICsrICkgewoJCSNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKQoJCQlpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdICE9IDAuMCApIHZDb2xvciArPSBnZXRNb3JwaCggZ2xfVmVydGV4SUQsIGksIDIgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdOwoJCSNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApCgkJCWlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gIT0gMC4wICkgdkNvbG9yICs9IGdldE1vcnBoKCBnbF9WZXJ0ZXhJRCwgaSwgMiApLnJnYiAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdOwoJCSNlbmRpZgoJfQojZW5kaWZgLGVsPWAjaWZkZWYgVVNFX01PUlBITk9STUFMUwoJb2JqZWN0Tm9ybWFsICo9IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZTsKCWZvciAoIGludCBpID0gMDsgaSA8IE1PUlBIVEFSR0VUU19DT1VOVDsgaSArKyApIHsKCQlpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdICE9IDAuMCApIG9iamVjdE5vcm1hbCArPSBnZXRNb3JwaCggZ2xfVmVydGV4SUQsIGksIDEgKS54eXogKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTsKCX0KI2VuZGlmYCx0bD1gI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFMKCSNpZm5kZWYgVVNFX0lOU1RBTkNJTkdfTU9SUEgKCQl1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZTsKCQl1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgTU9SUEhUQVJHRVRTX0NPVU5UIF07CgkjZW5kaWYKCXVuaWZvcm0gc2FtcGxlcjJEQXJyYXkgbW9ycGhUYXJnZXRzVGV4dHVyZTsKCXVuaWZvcm0gaXZlYzIgbW9ycGhUYXJnZXRzVGV4dHVyZVNpemU7Cgl2ZWM0IGdldE1vcnBoKCBjb25zdCBpbiBpbnQgdmVydGV4SW5kZXgsIGNvbnN0IGluIGludCBtb3JwaFRhcmdldEluZGV4LCBjb25zdCBpbiBpbnQgb2Zmc2V0ICkgewoJCWludCB0ZXhlbEluZGV4ID0gdmVydGV4SW5kZXggKiBNT1JQSFRBUkdFVFNfVEVYVFVSRV9TVFJJREUgKyBvZmZzZXQ7CgkJaW50IHkgPSB0ZXhlbEluZGV4IC8gbW9ycGhUYXJnZXRzVGV4dHVyZVNpemUueDsKCQlpbnQgeCA9IHRleGVsSW5kZXggLSB5ICogbW9ycGhUYXJnZXRzVGV4dHVyZVNpemUueDsKCQlpdmVjMyBtb3JwaFVWID0gaXZlYzMoIHgsIHksIG1vcnBoVGFyZ2V0SW5kZXggKTsKCQlyZXR1cm4gdGV4ZWxGZXRjaCggbW9ycGhUYXJnZXRzVGV4dHVyZSwgbW9ycGhVViwgMCApOwoJfQojZW5kaWZgLG5sPWAjaWZkZWYgVVNFX01PUlBIVEFSR0VUUwoJdHJhbnNmb3JtZWQgKj0gbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlOwoJZm9yICggaW50IGkgPSAwOyBpIDwgTU9SUEhUQVJHRVRTX0NPVU5UOyBpICsrICkgewoJCWlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gIT0gMC4wICkgdHJhbnNmb3JtZWQgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAwICkueHl6ICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07Cgl9CiNlbmRpZmAsaWw9YGZsb2F0IGZhY2VEaXJlY3Rpb24gPSBnbF9Gcm9udEZhY2luZyA/IDEuMCA6IC0gMS4wOwojaWZkZWYgRkxBVF9TSEFERUQKCXZlYzMgZmR4ID0gZEZkeCggdlZpZXdQb3NpdGlvbiApOwoJdmVjMyBmZHkgPSBkRmR5KCB2Vmlld1Bvc2l0aW9uICk7Cgl2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGZkeCwgZmR5ICkgKTsKI2Vsc2UKCXZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7CgkjaWZkZWYgRE9VQkxFX1NJREVECgkJbm9ybWFsICo9IGZhY2VEaXJlY3Rpb247CgkjZW5kaWYKI2VuZGlmCiNpZiBkZWZpbmVkKCBVU0VfTk9STUFMTUFQX1RBTkdFTlRTUEFDRSApIHx8IGRlZmluZWQoIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX0FOSVNPVFJPUFkgKQoJI2lmZGVmIFVTRV9UQU5HRU5UCgkJbWF0MyB0Ym4gPSBtYXQzKCBub3JtYWxpemUoIHZUYW5nZW50ICksIG5vcm1hbGl6ZSggdkJpdGFuZ2VudCApLCBub3JtYWwgKTsKCSNlbHNlCgkJbWF0MyB0Ym4gPSBnZXRUYW5nZW50RnJhbWUoIC0gdlZpZXdQb3NpdGlvbiwgbm9ybWFsLAoJCSNpZiBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkKCQkJdk5vcm1hbE1hcFV2CgkJI2VsaWYgZGVmaW5lZCggVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAgKQoJCQl2Q2xlYXJjb2F0Tm9ybWFsTWFwVXYKCQkjZWxzZQoJCQl2VXYKCQkjZW5kaWYKCQkpOwoJI2VuZGlmCgkjaWYgZGVmaW5lZCggRE9VQkxFX1NJREVEICkgJiYgISBkZWZpbmVkKCBGTEFUX1NIQURFRCApCgkJdGJuWzBdICo9IGZhY2VEaXJlY3Rpb247CgkJdGJuWzFdICo9IGZhY2VEaXJlY3Rpb247CgkjZW5kaWYKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUAoJI2lmZGVmIFVTRV9UQU5HRU5UCgkJbWF0MyB0Ym4yID0gbWF0Myggbm9ybWFsaXplKCB2VGFuZ2VudCApLCBub3JtYWxpemUoIHZCaXRhbmdlbnQgKSwgbm9ybWFsICk7CgkjZWxzZQoJCW1hdDMgdGJuMiA9IGdldFRhbmdlbnRGcmFtZSggLSB2Vmlld1Bvc2l0aW9uLCBub3JtYWwsIHZDbGVhcmNvYXROb3JtYWxNYXBVdiApOwoJI2VuZGlmCgkjaWYgZGVmaW5lZCggRE9VQkxFX1NJREVEICkgJiYgISBkZWZpbmVkKCBGTEFUX1NIQURFRCApCgkJdGJuMlswXSAqPSBmYWNlRGlyZWN0aW9uOwoJCXRibjJbMV0gKj0gZmFjZURpcmVjdGlvbjsKCSNlbmRpZgojZW5kaWYKdmVjMyBub25QZXJ0dXJiZWROb3JtYWwgPSBub3JtYWw7YCxybD1gI2lmZGVmIFVTRV9OT1JNQUxNQVBfT0JKRUNUU1BBQ0UKCW5vcm1hbCA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2Tm9ybWFsTWFwVXYgKS54eXogKiAyLjAgLSAxLjA7CgkjaWZkZWYgRkxJUF9TSURFRAoJCW5vcm1hbCA9IC0gbm9ybWFsOwoJI2VuZGlmCgkjaWZkZWYgRE9VQkxFX1NJREVECgkJbm9ybWFsID0gbm9ybWFsICogZmFjZURpcmVjdGlvbjsKCSNlbmRpZgoJbm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBub3JtYWwgKTsKI2VsaWYgZGVmaW5lZCggVVNFX05PUk1BTE1BUF9UQU5HRU5UU1BBQ0UgKQoJdmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZOb3JtYWxNYXBVdiApLnh5eiAqIDIuMCAtIDEuMDsKCW1hcE4ueHkgKj0gbm9ybWFsU2NhbGU7Cglub3JtYWwgPSBub3JtYWxpemUoIHRibiAqIG1hcE4gKTsKI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKQoJbm9ybWFsID0gcGVydHVyYk5vcm1hbEFyYiggLSB2Vmlld1Bvc2l0aW9uLCBub3JtYWwsIGRIZHh5X2Z3ZCgpLCBmYWNlRGlyZWN0aW9uICk7CiNlbmRpZmAsc2w9YCNpZm5kZWYgRkxBVF9TSEFERUQKCXZhcnlpbmcgdmVjMyB2Tm9ybWFsOwoJI2lmZGVmIFVTRV9UQU5HRU5UCgkJdmFyeWluZyB2ZWMzIHZUYW5nZW50OwoJCXZhcnlpbmcgdmVjMyB2Qml0YW5nZW50OwoJI2VuZGlmCiNlbmRpZmAsYWw9YCNpZm5kZWYgRkxBVF9TSEFERUQKCXZhcnlpbmcgdmVjMyB2Tm9ybWFsOwoJI2lmZGVmIFVTRV9UQU5HRU5UCgkJdmFyeWluZyB2ZWMzIHZUYW5nZW50OwoJCXZhcnlpbmcgdmVjMyB2Qml0YW5nZW50OwoJI2VuZGlmCiNlbmRpZmAsb2w9YCNpZm5kZWYgRkxBVF9TSEFERUQKCXZOb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7CgkjaWZkZWYgVVNFX1RBTkdFTlQKCQl2VGFuZ2VudCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWRUYW5nZW50ICk7CgkJdkJpdGFuZ2VudCA9IG5vcm1hbGl6ZSggY3Jvc3MoIHZOb3JtYWwsIHZUYW5nZW50ICkgKiB0YW5nZW50LncgKTsKCSNlbmRpZgojZW5kaWZgLGxsPWAjaWZkZWYgVVNFX05PUk1BTE1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwOwoJdW5pZm9ybSB2ZWMyIG5vcm1hbFNjYWxlOwojZW5kaWYKI2lmZGVmIFVTRV9OT1JNQUxNQVBfT0JKRUNUU1BBQ0UKCXVuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7CiNlbmRpZgojaWYgISBkZWZpbmVkICggVVNFX1RBTkdFTlQgKSAmJiAoIGRlZmluZWQgKCBVU0VfTk9STUFMTUFQX1RBTkdFTlRTUEFDRSApIHx8IGRlZmluZWQgKCBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9BTklTT1RST1BZICkgKQoJbWF0MyBnZXRUYW5nZW50RnJhbWUoIHZlYzMgZXllX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgdXYgKSB7CgkJdmVjMyBxMCA9IGRGZHgoIGV5ZV9wb3MueHl6ICk7CgkJdmVjMyBxMSA9IGRGZHkoIGV5ZV9wb3MueHl6ICk7CgkJdmVjMiBzdDAgPSBkRmR4KCB1di5zdCApOwoJCXZlYzIgc3QxID0gZEZkeSggdXYuc3QgKTsKCQl2ZWMzIE4gPSBzdXJmX25vcm07CgkJdmVjMyBxMXBlcnAgPSBjcm9zcyggcTEsIE4gKTsKCQl2ZWMzIHEwcGVycCA9IGNyb3NzKCBOLCBxMCApOwoJCXZlYzMgVCA9IHExcGVycCAqIHN0MC54ICsgcTBwZXJwICogc3QxLng7CgkJdmVjMyBCID0gcTFwZXJwICogc3QwLnkgKyBxMHBlcnAgKiBzdDEueTsKCQlmbG9hdCBkZXQgPSBtYXgoIGRvdCggVCwgVCApLCBkb3QoIEIsIEIgKSApOwoJCWZsb2F0IHNjYWxlID0gKCBkZXQgPT0gMC4wICkgPyAwLjAgOiBpbnZlcnNlc3FydCggZGV0ICk7CgkJcmV0dXJuIG1hdDMoIFQgKiBzY2FsZSwgQiAqIHNjYWxlLCBOICk7Cgl9CiNlbmRpZmAsY2w9YCNpZmRlZiBVU0VfQ0xFQVJDT0FUCgl2ZWMzIGNsZWFyY29hdE5vcm1hbCA9IG5vblBlcnR1cmJlZE5vcm1hbDsKI2VuZGlmYCx1bD1gI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQCgl2ZWMzIGNsZWFyY29hdE1hcE4gPSB0ZXh0dXJlMkQoIGNsZWFyY29hdE5vcm1hbE1hcCwgdkNsZWFyY29hdE5vcm1hbE1hcFV2ICkueHl6ICogMi4wIC0gMS4wOwoJY2xlYXJjb2F0TWFwTi54eSAqPSBjbGVhcmNvYXROb3JtYWxTY2FsZTsKCWNsZWFyY29hdE5vcm1hbCA9IG5vcm1hbGl6ZSggdGJuMiAqIGNsZWFyY29hdE1hcE4gKTsKI2VuZGlmYCxobD1gI2lmZGVmIFVTRV9DTEVBUkNPQVRNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyY29hdE1hcDsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgY2xlYXJjb2F0Tm9ybWFsTWFwOwoJdW5pZm9ybSB2ZWMyIGNsZWFyY29hdE5vcm1hbFNjYWxlOwojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBjbGVhcmNvYXRSb3VnaG5lc3NNYXA7CiNlbmRpZmAsZGw9YCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIGlyaWRlc2NlbmNlTWFwOwojZW5kaWYKI2lmZGVmIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwOwojZW5kaWZgLGZsPWAjaWZkZWYgT1BBUVVFCmRpZmZ1c2VDb2xvci5hID0gMS4wOwojZW5kaWYKI2lmZGVmIFVTRV9UUkFOU01JU1NJT04KZGlmZnVzZUNvbG9yLmEgKj0gbWF0ZXJpYWwudHJhbnNtaXNzaW9uQWxwaGE7CiNlbmRpZgpnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO2AscGw9YHZlYzMgcGFja05vcm1hbFRvUkdCKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHsKCXJldHVybiBub3JtYWxpemUoIG5vcm1hbCApICogMC41ICsgMC41Owp9CnZlYzMgdW5wYWNrUkdCVG9Ob3JtYWwoIGNvbnN0IGluIHZlYzMgcmdiICkgewoJcmV0dXJuIDIuMCAqIHJnYi54eXogLSAxLjA7Cn0KY29uc3QgZmxvYXQgUGFja1Vwc2NhbGUgPSAyNTYuIC8gMjU1Ljtjb25zdCBmbG9hdCBVbnBhY2tEb3duc2NhbGUgPSAyNTUuIC8gMjU2Ljtjb25zdCBmbG9hdCBTaGlmdFJpZ2h0OCA9IDEuIC8gMjU2LjsKY29uc3QgZmxvYXQgSW52MjU1ID0gMS4gLyAyNTUuOwpjb25zdCB2ZWM0IFBhY2tGYWN0b3JzID0gdmVjNCggMS4wLCAyNTYuMCwgMjU2LjAgKiAyNTYuMCwgMjU2LjAgKiAyNTYuMCAqIDI1Ni4wICk7CmNvbnN0IHZlYzIgVW5wYWNrRmFjdG9yczIgPSB2ZWMyKCBVbnBhY2tEb3duc2NhbGUsIDEuMCAvIFBhY2tGYWN0b3JzLmcgKTsKY29uc3QgdmVjMyBVbnBhY2tGYWN0b3JzMyA9IHZlYzMoIFVucGFja0Rvd25zY2FsZSAvIFBhY2tGYWN0b3JzLnJnLCAxLjAgLyBQYWNrRmFjdG9ycy5iICk7CmNvbnN0IHZlYzQgVW5wYWNrRmFjdG9yczQgPSB2ZWM0KCBVbnBhY2tEb3duc2NhbGUgLyBQYWNrRmFjdG9ycy5yZ2IsIDEuMCAvIFBhY2tGYWN0b3JzLmEgKTsKdmVjNCBwYWNrRGVwdGhUb1JHQkEoIGNvbnN0IGluIGZsb2F0IHYgKSB7CglpZiggdiA8PSAwLjAgKQoJCXJldHVybiB2ZWM0KCAwLiwgMC4sIDAuLCAwLiApOwoJaWYoIHYgPj0gMS4wICkKCQlyZXR1cm4gdmVjNCggMS4sIDEuLCAxLiwgMS4gKTsKCWZsb2F0IHZ1ZjsKCWZsb2F0IGFmID0gbW9kZiggdiAqIFBhY2tGYWN0b3JzLmEsIHZ1ZiApOwoJZmxvYXQgYmYgPSBtb2RmKCB2dWYgKiBTaGlmdFJpZ2h0OCwgdnVmICk7CglmbG9hdCBnZiA9IG1vZGYoIHZ1ZiAqIFNoaWZ0UmlnaHQ4LCB2dWYgKTsKCXJldHVybiB2ZWM0KCB2dWYgKiBJbnYyNTUsIGdmICogUGFja1Vwc2NhbGUsIGJmICogUGFja1Vwc2NhbGUsIGFmICk7Cn0KdmVjMyBwYWNrRGVwdGhUb1JHQiggY29uc3QgaW4gZmxvYXQgdiApIHsKCWlmKCB2IDw9IDAuMCApCgkJcmV0dXJuIHZlYzMoIDAuLCAwLiwgMC4gKTsKCWlmKCB2ID49IDEuMCApCgkJcmV0dXJuIHZlYzMoIDEuLCAxLiwgMS4gKTsKCWZsb2F0IHZ1ZjsKCWZsb2F0IGJmID0gbW9kZiggdiAqIFBhY2tGYWN0b3JzLmIsIHZ1ZiApOwoJZmxvYXQgZ2YgPSBtb2RmKCB2dWYgKiBTaGlmdFJpZ2h0OCwgdnVmICk7CglyZXR1cm4gdmVjMyggdnVmICogSW52MjU1LCBnZiAqIFBhY2tVcHNjYWxlLCBiZiApOwp9CnZlYzIgcGFja0RlcHRoVG9SRyggY29uc3QgaW4gZmxvYXQgdiApIHsKCWlmKCB2IDw9IDAuMCApCgkJcmV0dXJuIHZlYzIoIDAuLCAwLiApOwoJaWYoIHYgPj0gMS4wICkKCQlyZXR1cm4gdmVjMiggMS4sIDEuICk7CglmbG9hdCB2dWY7CglmbG9hdCBnZiA9IG1vZGYoIHYgKiAyNTYuLCB2dWYgKTsKCXJldHVybiB2ZWMyKCB2dWYgKiBJbnYyNTUsIGdmICk7Cn0KZmxvYXQgdW5wYWNrUkdCQVRvRGVwdGgoIGNvbnN0IGluIHZlYzQgdiApIHsKCXJldHVybiBkb3QoIHYsIFVucGFja0ZhY3RvcnM0ICk7Cn0KZmxvYXQgdW5wYWNrUkdCVG9EZXB0aCggY29uc3QgaW4gdmVjMyB2ICkgewoJcmV0dXJuIGRvdCggdiwgVW5wYWNrRmFjdG9yczMgKTsKfQpmbG9hdCB1bnBhY2tSR1RvRGVwdGgoIGNvbnN0IGluIHZlYzIgdiApIHsKCXJldHVybiB2LnIgKiBVbnBhY2tGYWN0b3JzMi5yICsgdi5nICogVW5wYWNrRmFjdG9yczIuZzsKfQp2ZWM0IHBhY2sySGFsZlRvUkdCQSggY29uc3QgaW4gdmVjMiB2ICkgewoJdmVjNCByID0gdmVjNCggdi54LCBmcmFjdCggdi54ICogMjU1LjAgKSwgdi55LCBmcmFjdCggdi55ICogMjU1LjAgKSApOwoJcmV0dXJuIHZlYzQoIHIueCAtIHIueSAvIDI1NS4wLCByLnksIHIueiAtIHIudyAvIDI1NS4wLCByLncgKTsKfQp2ZWMyIHVucGFja1JHQkFUbzJIYWxmKCBjb25zdCBpbiB2ZWM0IHYgKSB7CglyZXR1cm4gdmVjMiggdi54ICsgKCB2LnkgLyAyNTUuMCApLCB2LnogKyAoIHYudyAvIDI1NS4wICkgKTsKfQpmbG9hdCB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoIGNvbnN0IGluIGZsb2F0IHZpZXdaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7CglyZXR1cm4gKCB2aWV3WiArIG5lYXIgKSAvICggbmVhciAtIGZhciApOwp9CmZsb2F0IG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WiggY29uc3QgaW4gZmxvYXQgZGVwdGgsIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHsKCXJldHVybiBkZXB0aCAqICggbmVhciAtIGZhciApIC0gbmVhcjsKfQpmbG9hdCB2aWV3WlRvUGVyc3BlY3RpdmVEZXB0aCggY29uc3QgaW4gZmxvYXQgdmlld1osIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHsKCXJldHVybiAoICggbmVhciArIHZpZXdaICkgKiBmYXIgKSAvICggKCBmYXIgLSBuZWFyICkgKiB2aWV3WiApOwp9CmZsb2F0IHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKCBjb25zdCBpbiBmbG9hdCBkZXB0aCwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkgewoJcmV0dXJuICggbmVhciAqIGZhciApIC8gKCAoIGZhciAtIG5lYXIgKSAqIGRlcHRoIC0gZmFyICk7Cn1gLG1sPWAjaWZkZWYgUFJFTVVMVElQTElFRF9BTFBIQQoJZ2xfRnJhZ0NvbG9yLnJnYiAqPSBnbF9GcmFnQ29sb3IuYTsKI2VuZGlmYCxnbD1gdmVjNCBtdlBvc2l0aW9uID0gdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApOwojaWZkZWYgVVNFX0JBVENISU5HCgltdlBvc2l0aW9uID0gYmF0Y2hpbmdNYXRyaXggKiBtdlBvc2l0aW9uOwojZW5kaWYKI2lmZGVmIFVTRV9JTlNUQU5DSU5HCgltdlBvc2l0aW9uID0gaW5zdGFuY2VNYXRyaXggKiBtdlBvc2l0aW9uOwojZW5kaWYKbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIG12UG9zaXRpb247CmdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247YCxfbD1gI2lmZGVmIERJVEhFUklORwoJZ2xfRnJhZ0NvbG9yLnJnYiA9IGRpdGhlcmluZyggZ2xfRnJhZ0NvbG9yLnJnYiApOwojZW5kaWZgLHZsPWAjaWZkZWYgRElUSEVSSU5HCgl2ZWMzIGRpdGhlcmluZyggdmVjMyBjb2xvciApIHsKCQlmbG9hdCBncmlkX3Bvc2l0aW9uID0gcmFuZCggZ2xfRnJhZ0Nvb3JkLnh5ICk7CgkJdmVjMyBkaXRoZXJfc2hpZnRfUkdCID0gdmVjMyggMC4yNSAvIDI1NS4wLCAtMC4yNSAvIDI1NS4wLCAwLjI1IC8gMjU1LjAgKTsKCQlkaXRoZXJfc2hpZnRfUkdCID0gbWl4KCAyLjAgKiBkaXRoZXJfc2hpZnRfUkdCLCAtMi4wICogZGl0aGVyX3NoaWZ0X1JHQiwgZ3JpZF9wb3NpdGlvbiApOwoJCXJldHVybiBjb2xvciArIGRpdGhlcl9zaGlmdF9SR0I7Cgl9CiNlbmRpZmAseGw9YGZsb2F0IHJvdWdobmVzc0ZhY3RvciA9IHJvdWdobmVzczsKI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVAKCXZlYzQgdGV4ZWxSb3VnaG5lc3MgPSB0ZXh0dXJlMkQoIHJvdWdobmVzc01hcCwgdlJvdWdobmVzc01hcFV2ICk7Cglyb3VnaG5lc3NGYWN0b3IgKj0gdGV4ZWxSb3VnaG5lc3MuZzsKI2VuZGlmYCxNbD1gI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIHJvdWdobmVzc01hcDsKI2VuZGlmYCxTbD1gI2lmIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyA+IDAKCXZhcnlpbmcgdmVjNCB2U3BvdExpZ2h0Q29vcmRbIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyBdOwojZW5kaWYKI2lmIE5VTV9TUE9UX0xJR0hUX01BUFMgPiAwCgl1bmlmb3JtIHNhbXBsZXIyRCBzcG90TGlnaHRNYXBbIE5VTV9TUE9UX0xJR0hUX01BUFMgXTsKI2VuZGlmCiNpZmRlZiBVU0VfU0hBRE9XTUFQCgkjaWYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMAoJCXVuaWZvcm0gc2FtcGxlcjJEIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTsKCQl2YXJ5aW5nIHZlYzQgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdOwoJCXN0cnVjdCBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IHsKCQkJZmxvYXQgc2hhZG93SW50ZW5zaXR5OwoJCQlmbG9hdCBzaGFkb3dCaWFzOwoJCQlmbG9hdCBzaGFkb3dOb3JtYWxCaWFzOwoJCQlmbG9hdCBzaGFkb3dSYWRpdXM7CgkJCXZlYzIgc2hhZG93TWFwU2l6ZTsKCQl9OwoJCXVuaWZvcm0gRGlyZWN0aW9uYWxMaWdodFNoYWRvdyBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07CgkjZW5kaWYKCSNpZiBOVU1fU1BPVF9MSUdIVF9TSEFET1dTID4gMAoJCXVuaWZvcm0gc2FtcGxlcjJEIHNwb3RTaGFkb3dNYXBbIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgXTsKCQlzdHJ1Y3QgU3BvdExpZ2h0U2hhZG93IHsKCQkJZmxvYXQgc2hhZG93SW50ZW5zaXR5OwoJCQlmbG9hdCBzaGFkb3dCaWFzOwoJCQlmbG9hdCBzaGFkb3dOb3JtYWxCaWFzOwoJCQlmbG9hdCBzaGFkb3dSYWRpdXM7CgkJCXZlYzIgc2hhZG93TWFwU2l6ZTsKCQl9OwoJCXVuaWZvcm0gU3BvdExpZ2h0U2hhZG93IHNwb3RMaWdodFNoYWRvd3NbIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgXTsKCSNlbmRpZgoJI2lmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMAoJCXVuaWZvcm0gc2FtcGxlcjJEIHBvaW50U2hhZG93TWFwWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdOwoJCXZhcnlpbmcgdmVjNCB2UG9pbnRTaGFkb3dDb29yZFsgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTsKCQlzdHJ1Y3QgUG9pbnRMaWdodFNoYWRvdyB7CgkJCWZsb2F0IHNoYWRvd0ludGVuc2l0eTsKCQkJZmxvYXQgc2hhZG93QmlhczsKCQkJZmxvYXQgc2hhZG93Tm9ybWFsQmlhczsKCQkJZmxvYXQgc2hhZG93UmFkaXVzOwoJCQl2ZWMyIHNoYWRvd01hcFNpemU7CgkJCWZsb2F0IHNoYWRvd0NhbWVyYU5lYXI7CgkJCWZsb2F0IHNoYWRvd0NhbWVyYUZhcjsKCQl9OwoJCXVuaWZvcm0gUG9pbnRMaWdodFNoYWRvdyBwb2ludExpZ2h0U2hhZG93c1sgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTsKCSNlbmRpZgoJZmxvYXQgdGV4dHVyZTJEQ29tcGFyZSggc2FtcGxlcjJEIGRlcHRocywgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApIHsKCQlyZXR1cm4gc3RlcCggY29tcGFyZSwgdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggZGVwdGhzLCB1diApICkgKTsKCX0KCXZlYzIgdGV4dHVyZTJERGlzdHJpYnV0aW9uKCBzYW1wbGVyMkQgc2hhZG93LCB2ZWMyIHV2ICkgewoJCXJldHVybiB1bnBhY2tSR0JBVG8ySGFsZiggdGV4dHVyZTJEKCBzaGFkb3csIHV2ICkgKTsKCX0KCWZsb2F0IFZTTVNoYWRvdyAoc2FtcGxlcjJEIHNoYWRvdywgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApewoJCWZsb2F0IG9jY2x1c2lvbiA9IDEuMDsKCQl2ZWMyIGRpc3RyaWJ1dGlvbiA9IHRleHR1cmUyRERpc3RyaWJ1dGlvbiggc2hhZG93LCB1diApOwoJCWZsb2F0IGhhcmRfc2hhZG93ID0gc3RlcCggY29tcGFyZSAsIGRpc3RyaWJ1dGlvbi54ICk7CgkJaWYgKGhhcmRfc2hhZG93ICE9IDEuMCApIHsKCQkJZmxvYXQgZGlzdGFuY2UgPSBjb21wYXJlIC0gZGlzdHJpYnV0aW9uLnggOwoJCQlmbG9hdCB2YXJpYW5jZSA9IG1heCggMC4wMDAwMCwgZGlzdHJpYnV0aW9uLnkgKiBkaXN0cmlidXRpb24ueSApOwoJCQlmbG9hdCBzb2Z0bmVzc19wcm9iYWJpbGl0eSA9IHZhcmlhbmNlIC8gKHZhcmlhbmNlICsgZGlzdGFuY2UgKiBkaXN0YW5jZSApOwkJCXNvZnRuZXNzX3Byb2JhYmlsaXR5ID0gY2xhbXAoICggc29mdG5lc3NfcHJvYmFiaWxpdHkgLSAwLjMgKSAvICggMC45NSAtIDAuMyApLCAwLjAsIDEuMCApOwkJCW9jY2x1c2lvbiA9IGNsYW1wKCBtYXgoIGhhcmRfc2hhZG93LCBzb2Z0bmVzc19wcm9iYWJpbGl0eSApLCAwLjAsIDEuMCApOwoJCX0KCQlyZXR1cm4gb2NjbHVzaW9uOwoJfQoJZmxvYXQgZ2V0U2hhZG93KCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFNpemUsIGZsb2F0IHNoYWRvd0ludGVuc2l0eSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkICkgewoJCWZsb2F0IHNoYWRvdyA9IDEuMDsKCQlzaGFkb3dDb29yZC54eXogLz0gc2hhZG93Q29vcmQudzsKCQlzaGFkb3dDb29yZC56ICs9IHNoYWRvd0JpYXM7CgkJYm9vbCBpbkZydXN0dW0gPSBzaGFkb3dDb29yZC54ID49IDAuMCAmJiBzaGFkb3dDb29yZC54IDw9IDEuMCAmJiBzaGFkb3dDb29yZC55ID49IDAuMCAmJiBzaGFkb3dDb29yZC55IDw9IDEuMDsKCQlib29sIGZydXN0dW1UZXN0ID0gaW5GcnVzdHVtICYmIHNoYWRvd0Nvb3JkLnogPD0gMS4wOwoJCWlmICggZnJ1c3R1bVRlc3QgKSB7CgkJI2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApCgkJCXZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplOwoJCQlmbG9hdCBkeDAgPSAtIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzOwoJCQlmbG9hdCBkeTAgPSAtIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzOwoJCQlmbG9hdCBkeDEgPSArIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzOwoJCQlmbG9hdCBkeTEgPSArIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzOwoJCQlmbG9hdCBkeDIgPSBkeDAgLyAyLjA7CgkJCWZsb2F0IGR5MiA9IGR5MCAvIDIuMDsKCQkJZmxvYXQgZHgzID0gZHgxIC8gMi4wOwoJCQlmbG9hdCBkeTMgPSBkeTEgLyAyLjA7CgkJCXNoYWRvdyA9ICgKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDIsIGR5MiApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkyICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgzLCBkeTIgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MiwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MywgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDIsIGR5MyApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkzICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgzLCBkeTMgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSwgc2hhZG93Q29vcmQueiApCgkJCSkgKiAoIDEuMCAvIDE3LjAgKTsKCQkjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApCgkJCXZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplOwoJCQlmbG9hdCBkeCA9IHRleGVsU2l6ZS54OwoJCQlmbG9hdCBkeSA9IHRleGVsU2l6ZS55OwoJCQl2ZWMyIHV2ID0gc2hhZG93Q29vcmQueHk7CgkJCXZlYzIgZiA9IGZyYWN0KCB1diAqIHNoYWRvd01hcFNpemUgKyAwLjUgKTsKCQkJdXYgLT0gZiAqIHRleGVsU2l6ZTsKCQkJc2hhZG93ID0gKAoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCBkeCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCBkeSApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHRleGVsU2l6ZSwgc2hhZG93Q29vcmQueiApICsKCQkJCW1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIC1keCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApLAoJCQkJCSBmLnggKSArCgkJCQltaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIGR5ICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCBkeSApLCBzaGFkb3dDb29yZC56ICksCgkJCQkJIGYueCApICsKCQkJCW1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDAuMCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDAuMCwgMi4wICogZHkgKSwgc2hhZG93Q29vcmQueiApLAoJCQkJCSBmLnkgKSArCgkJCQltaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCBkeCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksCgkJCQkJIGYueSApICsKCQkJCW1peCggbWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAtZHkgKSwgc2hhZG93Q29vcmQueiApLAoJCQkJCQkgIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAyLjAgKiBkeCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkJICBmLnggKSwKCQkJCQkgbWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksCgkJCQkJCSAgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksCgkJCQkJCSAgZi54ICksCgkJCQkJIGYueSApCgkJCSkgKiAoIDEuMCAvIDkuMCApOwoJCSNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1ZTTSApCgkJCXNoYWRvdyA9IFZTTVNoYWRvdyggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApOwoJCSNlbHNlCgkJCXNoYWRvdyA9IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKTsKCQkjZW5kaWYKCQl9CgkJcmV0dXJuIG1peCggMS4wLCBzaGFkb3csIHNoYWRvd0ludGVuc2l0eSApOwoJfQoJdmVjMiBjdWJlVG9VViggdmVjMyB2LCBmbG9hdCB0ZXhlbFNpemVZICkgewoJCXZlYzMgYWJzViA9IGFicyggdiApOwoJCWZsb2F0IHNjYWxlVG9DdWJlID0gMS4wIC8gbWF4KCBhYnNWLngsIG1heCggYWJzVi55LCBhYnNWLnogKSApOwoJCWFic1YgKj0gc2NhbGVUb0N1YmU7CgkJdiAqPSBzY2FsZVRvQ3ViZSAqICggMS4wIC0gMi4wICogdGV4ZWxTaXplWSApOwoJCXZlYzIgcGxhbmFyID0gdi54eTsKCQlmbG9hdCBhbG1vc3RBVGV4ZWwgPSAxLjUgKiB0ZXhlbFNpemVZOwoJCWZsb2F0IGFsbW9zdE9uZSA9IDEuMCAtIGFsbW9zdEFUZXhlbDsKCQlpZiAoIGFic1YueiA+PSBhbG1vc3RPbmUgKSB7CgkJCWlmICggdi56ID4gMC4wICkKCQkJCXBsYW5hci54ID0gNC4wIC0gdi54OwoJCX0gZWxzZSBpZiAoIGFic1YueCA+PSBhbG1vc3RPbmUgKSB7CgkJCWZsb2F0IHNpZ25YID0gc2lnbiggdi54ICk7CgkJCXBsYW5hci54ID0gdi56ICogc2lnblggKyAyLjAgKiBzaWduWDsKCQl9IGVsc2UgaWYgKCBhYnNWLnkgPj0gYWxtb3N0T25lICkgewoJCQlmbG9hdCBzaWduWSA9IHNpZ24oIHYueSApOwoJCQlwbGFuYXIueCA9IHYueCArIDIuMCAqIHNpZ25ZICsgMi4wOwoJCQlwbGFuYXIueSA9IHYueiAqIHNpZ25ZIC0gMi4wOwoJCX0KCQlyZXR1cm4gdmVjMiggMC4xMjUsIDAuMjUgKSAqIHBsYW5hciArIHZlYzIoIDAuMzc1LCAwLjc1ICk7Cgl9CglmbG9hdCBnZXRQb2ludFNoYWRvdyggc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiBzaGFkb3dNYXBTaXplLCBmbG9hdCBzaGFkb3dJbnRlbnNpdHksIGZsb2F0IHNoYWRvd0JpYXMsIGZsb2F0IHNoYWRvd1JhZGl1cywgdmVjNCBzaGFkb3dDb29yZCwgZmxvYXQgc2hhZG93Q2FtZXJhTmVhciwgZmxvYXQgc2hhZG93Q2FtZXJhRmFyICkgewoJCWZsb2F0IHNoYWRvdyA9IDEuMDsKCQl2ZWMzIGxpZ2h0VG9Qb3NpdGlvbiA9IHNoYWRvd0Nvb3JkLnh5ejsKCQkKCQlmbG9hdCBsaWdodFRvUG9zaXRpb25MZW5ndGggPSBsZW5ndGgoIGxpZ2h0VG9Qb3NpdGlvbiApOwoJCWlmICggbGlnaHRUb1Bvc2l0aW9uTGVuZ3RoIC0gc2hhZG93Q2FtZXJhRmFyIDw9IDAuMCAmJiBsaWdodFRvUG9zaXRpb25MZW5ndGggLSBzaGFkb3dDYW1lcmFOZWFyID49IDAuMCApIHsKCQkJZmxvYXQgZHAgPSAoIGxpZ2h0VG9Qb3NpdGlvbkxlbmd0aCAtIHNoYWRvd0NhbWVyYU5lYXIgKSAvICggc2hhZG93Q2FtZXJhRmFyIC0gc2hhZG93Q2FtZXJhTmVhciApOwkJCWRwICs9IHNoYWRvd0JpYXM7CgkJCXZlYzMgYmQzRCA9IG5vcm1hbGl6ZSggbGlnaHRUb1Bvc2l0aW9uICk7CgkJCXZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyAoIHNoYWRvd01hcFNpemUgKiB2ZWMyKCA0LjAsIDIuMCApICk7CgkJCSNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKSB8fCBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApIHx8IGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1ZTTSApCgkJCQl2ZWMyIG9mZnNldCA9IHZlYzIoIC0gMSwgMSApICogc2hhZG93UmFkaXVzICogdGV4ZWxTaXplLnk7CgkJCQlzaGFkb3cgPSAoCgkJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eXksIHRleGVsU2l6ZS55ICksIGRwICkgKwoJCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXl5LCB0ZXhlbFNpemUueSApLCBkcCApICsKCQkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh5eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArCgkJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eXgsIHRleGVsU2l6ZS55ICksIGRwICkgKwoJCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZS55ICksIGRwICkgKwoJCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHh5LCB0ZXhlbFNpemUueSApLCBkcCApICsKCQkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArCgkJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHgsIHRleGVsU2l6ZS55ICksIGRwICkgKwoJCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXh4LCB0ZXhlbFNpemUueSApLCBkcCApCgkJCQkpICogKCAxLjAgLyA5LjAgKTsKCQkJI2Vsc2UKCQkJCXNoYWRvdyA9IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZS55ICksIGRwICk7CgkJCSNlbmRpZgoJCX0KCQlyZXR1cm4gbWl4KCAxLjAsIHNoYWRvdywgc2hhZG93SW50ZW5zaXR5ICk7Cgl9CiNlbmRpZmAsRWw9YCNpZiBOVU1fU1BPVF9MSUdIVF9DT09SRFMgPiAwCgl1bmlmb3JtIG1hdDQgc3BvdExpZ2h0TWF0cml4WyBOVU1fU1BPVF9MSUdIVF9DT09SRFMgXTsKCXZhcnlpbmcgdmVjNCB2U3BvdExpZ2h0Q29vcmRbIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyBdOwojZW5kaWYKI2lmZGVmIFVTRV9TSEFET1dNQVAKCSNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwCgkJdW5pZm9ybSBtYXQ0IGRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTsKCQl2YXJ5aW5nIHZlYzQgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdOwoJCXN0cnVjdCBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IHsKCQkJZmxvYXQgc2hhZG93SW50ZW5zaXR5OwoJCQlmbG9hdCBzaGFkb3dCaWFzOwoJCQlmbG9hdCBzaGFkb3dOb3JtYWxCaWFzOwoJCQlmbG9hdCBzaGFkb3dSYWRpdXM7CgkJCXZlYzIgc2hhZG93TWFwU2l6ZTsKCQl9OwoJCXVuaWZvcm0gRGlyZWN0aW9uYWxMaWdodFNoYWRvdyBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07CgkjZW5kaWYKCSNpZiBOVU1fU1BPVF9MSUdIVF9TSEFET1dTID4gMAoJCXN0cnVjdCBTcG90TGlnaHRTaGFkb3cgewoJCQlmbG9hdCBzaGFkb3dJbnRlbnNpdHk7CgkJCWZsb2F0IHNoYWRvd0JpYXM7CgkJCWZsb2F0IHNoYWRvd05vcm1hbEJpYXM7CgkJCWZsb2F0IHNoYWRvd1JhZGl1czsKCQkJdmVjMiBzaGFkb3dNYXBTaXplOwoJCX07CgkJdW5pZm9ybSBTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0U2hhZG93c1sgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdOwoJI2VuZGlmCgkjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwCgkJdW5pZm9ybSBtYXQ0IHBvaW50U2hhZG93TWF0cml4WyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdOwoJCXZhcnlpbmcgdmVjNCB2UG9pbnRTaGFkb3dDb29yZFsgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTsKCQlzdHJ1Y3QgUG9pbnRMaWdodFNoYWRvdyB7CgkJCWZsb2F0IHNoYWRvd0ludGVuc2l0eTsKCQkJZmxvYXQgc2hhZG93QmlhczsKCQkJZmxvYXQgc2hhZG93Tm9ybWFsQmlhczsKCQkJZmxvYXQgc2hhZG93UmFkaXVzOwoJCQl2ZWMyIHNoYWRvd01hcFNpemU7CgkJCWZsb2F0IHNoYWRvd0NhbWVyYU5lYXI7CgkJCWZsb2F0IHNoYWRvd0NhbWVyYUZhcjsKCQl9OwoJCXVuaWZvcm0gUG9pbnRMaWdodFNoYWRvdyBwb2ludExpZ2h0U2hhZG93c1sgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTsKCSNlbmRpZgojZW5kaWZgLHlsPWAjaWYgKCBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgKCBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwIHx8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMCApICkgfHwgKCBOVU1fU1BPVF9MSUdIVF9DT09SRFMgPiAwICkKCXZlYzMgc2hhZG93V29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCB0cmFuc2Zvcm1lZE5vcm1hbCwgdmlld01hdHJpeCApOwoJdmVjNCBzaGFkb3dXb3JsZFBvc2l0aW9uOwojZW5kaWYKI2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKQoJI2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDAKCQkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0CgkJZm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTOyBpICsrICkgewoJCQlzaGFkb3dXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbiArIHZlYzQoIHNoYWRvd1dvcmxkTm9ybWFsICogZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXS5zaGFkb3dOb3JtYWxCaWFzLCAwICk7CgkJCXZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gPSBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjsKCQl9CgkJI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQKCSNlbmRpZgoJI2lmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMAoJCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCQlmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUzsgaSArKyApIHsKCQkJc2hhZG93V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24gKyB2ZWM0KCBzaGFkb3dXb3JsZE5vcm1hbCAqIHBvaW50TGlnaHRTaGFkb3dzWyBpIF0uc2hhZG93Tm9ybWFsQmlhcywgMCApOwoJCQl2UG9pbnRTaGFkb3dDb29yZFsgaSBdID0gcG9pbnRTaGFkb3dNYXRyaXhbIGkgXSAqIHNoYWRvd1dvcmxkUG9zaXRpb247CgkJfQoJCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCgkjZW5kaWYKI2VuZGlmCiNpZiBOVU1fU1BPVF9MSUdIVF9DT09SRFMgPiAwCgkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVF9DT09SRFM7IGkgKysgKSB7CgkJc2hhZG93V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb247CgkJI2lmICggZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTICkKCQkJc2hhZG93V29ybGRQb3NpdGlvbi54eXogKz0gc2hhZG93V29ybGROb3JtYWwgKiBzcG90TGlnaHRTaGFkb3dzWyBpIF0uc2hhZG93Tm9ybWFsQmlhczsKCQkjZW5kaWYKCQl2U3BvdExpZ2h0Q29vcmRbIGkgXSA9IHNwb3RMaWdodE1hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjsKCX0KCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCiNlbmRpZmAsVGw9YGZsb2F0IGdldFNoYWRvd01hc2soKSB7CglmbG9hdCBzaGFkb3cgPSAxLjA7CgkjaWZkZWYgVVNFX1NIQURPV01BUAoJI2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDAKCURpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodDsKCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCWZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRfU0hBRE9XUzsgaSArKyApIHsKCQlkaXJlY3Rpb25hbExpZ2h0ID0gZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXTsKCQlzaGFkb3cgKj0gcmVjZWl2ZVNoYWRvdyA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0ludGVuc2l0eSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dCaWFzLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd1JhZGl1cywgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSApIDogMS4wOwoJfQoJI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQKCSNlbmRpZgoJI2lmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwCglTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0OwoJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJZm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUzsgaSArKyApIHsKCQlzcG90TGlnaHQgPSBzcG90TGlnaHRTaGFkb3dzWyBpIF07CgkJc2hhZG93ICo9IHJlY2VpdmVTaGFkb3cgPyBnZXRTaGFkb3coIHNwb3RTaGFkb3dNYXBbIGkgXSwgc3BvdExpZ2h0LnNoYWRvd01hcFNpemUsIHNwb3RMaWdodC5zaGFkb3dJbnRlbnNpdHksIHNwb3RMaWdodC5zaGFkb3dCaWFzLCBzcG90TGlnaHQuc2hhZG93UmFkaXVzLCB2U3BvdExpZ2h0Q29vcmRbIGkgXSApIDogMS4wOwoJfQoJI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQKCSNlbmRpZgoJI2lmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMAoJUG9pbnRMaWdodFNoYWRvdyBwb2ludExpZ2h0OwoJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJZm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7CgkJcG9pbnRMaWdodCA9IHBvaW50TGlnaHRTaGFkb3dzWyBpIF07CgkJc2hhZG93ICo9IHJlY2VpdmVTaGFkb3cgPyBnZXRQb2ludFNoYWRvdyggcG9pbnRTaGFkb3dNYXBbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dNYXBTaXplLCBwb2ludExpZ2h0LnNoYWRvd0ludGVuc2l0eSwgcG9pbnRMaWdodC5zaGFkb3dCaWFzLCBwb2ludExpZ2h0LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dDYW1lcmFOZWFyLCBwb2ludExpZ2h0LnNoYWRvd0NhbWVyYUZhciApIDogMS4wOwoJfQoJI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQKCSNlbmRpZgoJI2VuZGlmCglyZXR1cm4gc2hhZG93Owp9YCxBbD1gI2lmZGVmIFVTRV9TS0lOTklORwoJbWF0NCBib25lTWF0WCA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC54ICk7CgltYXQ0IGJvbmVNYXRZID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnkgKTsKCW1hdDQgYm9uZU1hdFogPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueiApOwoJbWF0NCBib25lTWF0VyA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC53ICk7CiNlbmRpZmAsd2w9YCNpZmRlZiBVU0VfU0tJTk5JTkcKCXVuaWZvcm0gbWF0NCBiaW5kTWF0cml4OwoJdW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXhJbnZlcnNlOwoJdW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgYm9uZVRleHR1cmU7CgltYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7CgkJaW50IHNpemUgPSB0ZXh0dXJlU2l6ZSggYm9uZVRleHR1cmUsIDAgKS54OwoJCWludCBqID0gaW50KCBpICkgKiA0OwoJCWludCB4ID0gaiAlIHNpemU7CgkJaW50IHkgPSBqIC8gc2l6ZTsKCQl2ZWM0IHYxID0gdGV4ZWxGZXRjaCggYm9uZVRleHR1cmUsIGl2ZWMyKCB4LCB5ICksIDAgKTsKCQl2ZWM0IHYyID0gdGV4ZWxGZXRjaCggYm9uZVRleHR1cmUsIGl2ZWMyKCB4ICsgMSwgeSApLCAwICk7CgkJdmVjNCB2MyA9IHRleGVsRmV0Y2goIGJvbmVUZXh0dXJlLCBpdmVjMiggeCArIDIsIHkgKSwgMCApOwoJCXZlYzQgdjQgPSB0ZXhlbEZldGNoKCBib25lVGV4dHVyZSwgaXZlYzIoIHggKyAzLCB5ICksIDAgKTsKCQlyZXR1cm4gbWF0NCggdjEsIHYyLCB2MywgdjQgKTsKCX0KI2VuZGlmYCxibD1gI2lmZGVmIFVTRV9TS0lOTklORwoJdmVjNCBza2luVmVydGV4ID0gYmluZE1hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTsKCXZlYzQgc2tpbm5lZCA9IHZlYzQoIDAuMCApOwoJc2tpbm5lZCArPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7Cglza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTsKCXNraW5uZWQgKz0gYm9uZU1hdFogKiBza2luVmVydGV4ICogc2tpbldlaWdodC56OwoJc2tpbm5lZCArPSBib25lTWF0VyAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnc7Cgl0cmFuc2Zvcm1lZCA9ICggYmluZE1hdHJpeEludmVyc2UgKiBza2lubmVkICkueHl6OwojZW5kaWZgLFJsPWAjaWZkZWYgVVNFX1NLSU5OSU5HCgltYXQ0IHNraW5NYXRyaXggPSBtYXQ0KCAwLjAgKTsKCXNraW5NYXRyaXggKz0gc2tpbldlaWdodC54ICogYm9uZU1hdFg7Cglza2luTWF0cml4ICs9IHNraW5XZWlnaHQueSAqIGJvbmVNYXRZOwoJc2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnogKiBib25lTWF0WjsKCXNraW5NYXRyaXggKz0gc2tpbldlaWdodC53ICogYm9uZU1hdFc7Cglza2luTWF0cml4ID0gYmluZE1hdHJpeEludmVyc2UgKiBza2luTWF0cml4ICogYmluZE1hdHJpeDsKCW9iamVjdE5vcm1hbCA9IHZlYzQoIHNraW5NYXRyaXggKiB2ZWM0KCBvYmplY3ROb3JtYWwsIDAuMCApICkueHl6OwoJI2lmZGVmIFVTRV9UQU5HRU5UCgkJb2JqZWN0VGFuZ2VudCA9IHZlYzQoIHNraW5NYXRyaXggKiB2ZWM0KCBvYmplY3RUYW5nZW50LCAwLjAgKSApLnh5ejsKCSNlbmRpZgojZW5kaWZgLENsPWBmbG9hdCBzcGVjdWxhclN0cmVuZ3RoOwojaWZkZWYgVVNFX1NQRUNVTEFSTUFQCgl2ZWM0IHRleGVsU3BlY3VsYXIgPSB0ZXh0dXJlMkQoIHNwZWN1bGFyTWFwLCB2U3BlY3VsYXJNYXBVdiApOwoJc3BlY3VsYXJTdHJlbmd0aCA9IHRleGVsU3BlY3VsYXIucjsKI2Vsc2UKCXNwZWN1bGFyU3RyZW5ndGggPSAxLjA7CiNlbmRpZmAsUGw9YCNpZmRlZiBVU0VfU1BFQ1VMQVJNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwOwojZW5kaWZgLERsPWAjaWYgZGVmaW5lZCggVE9ORV9NQVBQSU5HICkKCWdsX0ZyYWdDb2xvci5yZ2IgPSB0b25lTWFwcGluZyggZ2xfRnJhZ0NvbG9yLnJnYiApOwojZW5kaWZgLExsPWAjaWZuZGVmIHNhdHVyYXRlCiNkZWZpbmUgc2F0dXJhdGUoIGEgKSBjbGFtcCggYSwgMC4wLCAxLjAgKQojZW5kaWYKdW5pZm9ybSBmbG9hdCB0b25lTWFwcGluZ0V4cG9zdXJlOwp2ZWMzIExpbmVhclRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkgewoJcmV0dXJuIHNhdHVyYXRlKCB0b25lTWFwcGluZ0V4cG9zdXJlICogY29sb3IgKTsKfQp2ZWMzIFJlaW5oYXJkVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7Cgljb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlOwoJcmV0dXJuIHNhdHVyYXRlKCBjb2xvciAvICggdmVjMyggMS4wICkgKyBjb2xvciApICk7Cn0KdmVjMyBDaW5lb25Ub25lTWFwcGluZyggdmVjMyBjb2xvciApIHsKCWNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7Cgljb2xvciA9IG1heCggdmVjMyggMC4wICksIGNvbG9yIC0gMC4wMDQgKTsKCXJldHVybiBwb3coICggY29sb3IgKiAoIDYuMiAqIGNvbG9yICsgMC41ICkgKSAvICggY29sb3IgKiAoIDYuMiAqIGNvbG9yICsgMS43ICkgKyAwLjA2ICksIHZlYzMoIDIuMiApICk7Cn0KdmVjMyBSUlRBbmRPRFRGaXQoIHZlYzMgdiApIHsKCXZlYzMgYSA9IHYgKiAoIHYgKyAwLjAyNDU3ODYgKSAtIDAuMDAwMDkwNTM3OwoJdmVjMyBiID0gdiAqICggMC45ODM3MjkgKiB2ICsgMC40MzI5NTEwICkgKyAwLjIzODA4MTsKCXJldHVybiBhIC8gYjsKfQp2ZWMzIEFDRVNGaWxtaWNUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHsKCWNvbnN0IG1hdDMgQUNFU0lucHV0TWF0ID0gbWF0MygKCQl2ZWMzKCAwLjU5NzE5LCAwLjA3NjAwLCAwLjAyODQwICksCQl2ZWMzKCAwLjM1NDU4LCAwLjkwODM0LCAwLjEzMzgzICksCgkJdmVjMyggMC4wNDgyMywgMC4wMTU2NiwgMC44Mzc3NyApCgkpOwoJY29uc3QgbWF0MyBBQ0VTT3V0cHV0TWF0ID0gbWF0MygKCQl2ZWMzKCAgMS42MDQ3NSwgLTAuMTAyMDgsIC0wLjAwMzI3ICksCQl2ZWMzKCAtMC41MzEwOCwgIDEuMTA4MTMsIC0wLjA3Mjc2ICksCgkJdmVjMyggLTAuMDczNjcsIC0wLjAwNjA1LCAgMS4wNzYwMiApCgkpOwoJY29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZSAvIDAuNjsKCWNvbG9yID0gQUNFU0lucHV0TWF0ICogY29sb3I7Cgljb2xvciA9IFJSVEFuZE9EVEZpdCggY29sb3IgKTsKCWNvbG9yID0gQUNFU091dHB1dE1hdCAqIGNvbG9yOwoJcmV0dXJuIHNhdHVyYXRlKCBjb2xvciApOwp9CmNvbnN0IG1hdDMgTElORUFSX1JFQzIwMjBfVE9fTElORUFSX1NSR0IgPSBtYXQzKAoJdmVjMyggMS42NjA1LCAtIDAuMTI0NiwgLSAwLjAxODIgKSwKCXZlYzMoIC0gMC41ODc2LCAxLjEzMjksIC0gMC4xMDA2ICksCgl2ZWMzKCAtIDAuMDcyOCwgLSAwLjAwODMsIDEuMTE4NyApCik7CmNvbnN0IG1hdDMgTElORUFSX1NSR0JfVE9fTElORUFSX1JFQzIwMjAgPSBtYXQzKAoJdmVjMyggMC42Mjc0LCAwLjA2OTEsIDAuMDE2NCApLAoJdmVjMyggMC4zMjkzLCAwLjkxOTUsIDAuMDg4MCApLAoJdmVjMyggMC4wNDMzLCAwLjAxMTMsIDAuODk1NiApCik7CnZlYzMgYWd4RGVmYXVsdENvbnRyYXN0QXBwcm94KCB2ZWMzIHggKSB7Cgl2ZWMzIHgyID0geCAqIHg7Cgl2ZWMzIHg0ID0geDIgKiB4MjsKCXJldHVybiArIDE1LjUgKiB4NCAqIHgyCgkJLSA0MC4xNCAqIHg0ICogeAoJCSsgMzEuOTYgKiB4NAoJCS0gNi44NjggKiB4MiAqIHgKCQkrIDAuNDI5OCAqIHgyCgkJKyAwLjExOTEgKiB4CgkJLSAwLjAwMjMyOwp9CnZlYzMgQWdYVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7Cgljb25zdCBtYXQzIEFnWEluc2V0TWF0cml4ID0gbWF0MygKCQl2ZWMzKCAwLjg1NjYyNzE1MzMxNTk4MywgMC4xMzczMTg5NzI5Mjk4NDcsIDAuMTExODk4MjEyOTk5OTUgKSwKCQl2ZWMzKCAwLjA5NTEyMTI0MDUzODE1ODgsIDAuNzYxMjQxOTkwNjAyNTkxLCAwLjA3Njc5OTQxODYwMzE5MDMgKSwKCQl2ZWMzKCAwLjA0ODI1MTYwNjE0NTg1ODMsIDAuMTAxNDM5MDM2NDY3NTYyLCAwLjgxMTMwMjM2ODM5Njg1OSApCgkpOwoJY29uc3QgbWF0MyBBZ1hPdXRzZXRNYXRyaXggPSBtYXQzKAoJCXZlYzMoIDEuMTI3MTAwNTgxODE0NDM2OCwgLSAwLjE0MTMyOTc2MzQ5ODQzODMsIC0gMC4xNDEzMjk3NjM0OTg0MzgyNiApLAoJCXZlYzMoIC0gMC4xMTA2MDY2NDMwOTY2MDMyMywgMS4xNTc4MjM3MDIyMTYyNzIsIC0gMC4xMTA2MDY2NDMwOTY2MDI5NCApLAoJCXZlYzMoIC0gMC4wMTY0OTM5Mzg3MTc4MzQ1NzMsIC0gMC4wMTY0OTM5Mzg3MTc4MzQyNTcsIDEuMjUxOTM2NDA2NTk1MDQwNSApCgkpOwoJY29uc3QgZmxvYXQgQWd4TWluRXYgPSAtIDEyLjQ3MzkzOwljb25zdCBmbG9hdCBBZ3hNYXhFdiA9IDQuMDI2MDY5OwoJY29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTsKCWNvbG9yID0gTElORUFSX1NSR0JfVE9fTElORUFSX1JFQzIwMjAgKiBjb2xvcjsKCWNvbG9yID0gQWdYSW5zZXRNYXRyaXggKiBjb2xvcjsKCWNvbG9yID0gbWF4KCBjb2xvciwgMWUtMTAgKTsJY29sb3IgPSBsb2cyKCBjb2xvciApOwoJY29sb3IgPSAoIGNvbG9yIC0gQWd4TWluRXYgKSAvICggQWd4TWF4RXYgLSBBZ3hNaW5FdiApOwoJY29sb3IgPSBjbGFtcCggY29sb3IsIDAuMCwgMS4wICk7Cgljb2xvciA9IGFneERlZmF1bHRDb250cmFzdEFwcHJveCggY29sb3IgKTsKCWNvbG9yID0gQWdYT3V0c2V0TWF0cml4ICogY29sb3I7Cgljb2xvciA9IHBvdyggbWF4KCB2ZWMzKCAwLjAgKSwgY29sb3IgKSwgdmVjMyggMi4yICkgKTsKCWNvbG9yID0gTElORUFSX1JFQzIwMjBfVE9fTElORUFSX1NSR0IgKiBjb2xvcjsKCWNvbG9yID0gY2xhbXAoIGNvbG9yLCAwLjAsIDEuMCApOwoJcmV0dXJuIGNvbG9yOwp9CnZlYzMgTmV1dHJhbFRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkgewoJY29uc3QgZmxvYXQgU3RhcnRDb21wcmVzc2lvbiA9IDAuOCAtIDAuMDQ7Cgljb25zdCBmbG9hdCBEZXNhdHVyYXRpb24gPSAwLjE1OwoJY29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTsKCWZsb2F0IHggPSBtaW4oIGNvbG9yLnIsIG1pbiggY29sb3IuZywgY29sb3IuYiApICk7CglmbG9hdCBvZmZzZXQgPSB4IDwgMC4wOCA/IHggLSA2LjI1ICogeCAqIHggOiAwLjA0OwoJY29sb3IgLT0gb2Zmc2V0OwoJZmxvYXQgcGVhayA9IG1heCggY29sb3IuciwgbWF4KCBjb2xvci5nLCBjb2xvci5iICkgKTsKCWlmICggcGVhayA8IFN0YXJ0Q29tcHJlc3Npb24gKSByZXR1cm4gY29sb3I7CglmbG9hdCBkID0gMS4gLSBTdGFydENvbXByZXNzaW9uOwoJZmxvYXQgbmV3UGVhayA9IDEuIC0gZCAqIGQgLyAoIHBlYWsgKyBkIC0gU3RhcnRDb21wcmVzc2lvbiApOwoJY29sb3IgKj0gbmV3UGVhayAvIHBlYWs7CglmbG9hdCBnID0gMS4gLSAxLiAvICggRGVzYXR1cmF0aW9uICogKCBwZWFrIC0gbmV3UGVhayApICsgMS4gKTsKCXJldHVybiBtaXgoIGNvbG9yLCB2ZWMzKCBuZXdQZWFrICksIGcgKTsKfQp2ZWMzIEN1c3RvbVRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkgeyByZXR1cm4gY29sb3I7IH1gLFVsPWAjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTgoJbWF0ZXJpYWwudHJhbnNtaXNzaW9uID0gdHJhbnNtaXNzaW9uOwoJbWF0ZXJpYWwudHJhbnNtaXNzaW9uQWxwaGEgPSAxLjA7CgltYXRlcmlhbC50aGlja25lc3MgPSB0aGlja25lc3M7CgltYXRlcmlhbC5hdHRlbnVhdGlvbkRpc3RhbmNlID0gYXR0ZW51YXRpb25EaXN0YW5jZTsKCW1hdGVyaWFsLmF0dGVudWF0aW9uQ29sb3IgPSBhdHRlbnVhdGlvbkNvbG9yOwoJI2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVAKCQltYXRlcmlhbC50cmFuc21pc3Npb24gKj0gdGV4dHVyZTJEKCB0cmFuc21pc3Npb25NYXAsIHZUcmFuc21pc3Npb25NYXBVdiApLnI7CgkjZW5kaWYKCSNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQCgkJbWF0ZXJpYWwudGhpY2tuZXNzICo9IHRleHR1cmUyRCggdGhpY2tuZXNzTWFwLCB2VGhpY2tuZXNzTWFwVXYgKS5nOwoJI2VuZGlmCgl2ZWMzIHBvcyA9IHZXb3JsZFBvc2l0aW9uOwoJdmVjMyB2ID0gbm9ybWFsaXplKCBjYW1lcmFQb3NpdGlvbiAtIHBvcyApOwoJdmVjMyBuID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7Cgl2ZWM0IHRyYW5zbWl0dGVkID0gZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbigKCQluLCB2LCBtYXRlcmlhbC5yb3VnaG5lc3MsIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsCgkJcG9zLCBtb2RlbE1hdHJpeCwgdmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeCwgbWF0ZXJpYWwuZGlzcGVyc2lvbiwgbWF0ZXJpYWwuaW9yLCBtYXRlcmlhbC50aGlja25lc3MsCgkJbWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvciwgbWF0ZXJpYWwuYXR0ZW51YXRpb25EaXN0YW5jZSApOwoJbWF0ZXJpYWwudHJhbnNtaXNzaW9uQWxwaGEgPSBtaXgoIG1hdGVyaWFsLnRyYW5zbWlzc2lvbkFscGhhLCB0cmFuc21pdHRlZC5hLCBtYXRlcmlhbC50cmFuc21pc3Npb24gKTsKCXRvdGFsRGlmZnVzZSA9IG1peCggdG90YWxEaWZmdXNlLCB0cmFuc21pdHRlZC5yZ2IsIG1hdGVyaWFsLnRyYW5zbWlzc2lvbiApOwojZW5kaWZgLEZsPWAjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTgoJdW5pZm9ybSBmbG9hdCB0cmFuc21pc3Npb247Cgl1bmlmb3JtIGZsb2F0IHRoaWNrbmVzczsKCXVuaWZvcm0gZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZTsKCXVuaWZvcm0gdmVjMyBhdHRlbnVhdGlvbkNvbG9yOwoJI2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVAKCQl1bmlmb3JtIHNhbXBsZXIyRCB0cmFuc21pc3Npb25NYXA7CgkjZW5kaWYKCSNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQCgkJdW5pZm9ybSBzYW1wbGVyMkQgdGhpY2tuZXNzTWFwOwoJI2VuZGlmCgl1bmlmb3JtIHZlYzIgdHJhbnNtaXNzaW9uU2FtcGxlclNpemU7Cgl1bmlmb3JtIHNhbXBsZXIyRCB0cmFuc21pc3Npb25TYW1wbGVyTWFwOwoJdW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4OwoJdW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7Cgl2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247CglmbG9hdCB3MCggZmxvYXQgYSApIHsKCQlyZXR1cm4gKCAxLjAgLyA2LjAgKSAqICggYSAqICggYSAqICggLSBhICsgMy4wICkgLSAzLjAgKSArIDEuMCApOwoJfQoJZmxvYXQgdzEoIGZsb2F0IGEgKSB7CgkJcmV0dXJuICggMS4wIC8gNi4wICkgKiAoIGEgKiAgYSAqICggMy4wICogYSAtIDYuMCApICsgNC4wICk7Cgl9CglmbG9hdCB3MiggZmxvYXQgYSApewoJCXJldHVybiAoIDEuMCAvIDYuMCApICogKCBhICogKCBhICogKCAtIDMuMCAqIGEgKyAzLjAgKSArIDMuMCApICsgMS4wICk7Cgl9CglmbG9hdCB3MyggZmxvYXQgYSApIHsKCQlyZXR1cm4gKCAxLjAgLyA2LjAgKSAqICggYSAqIGEgKiBhICk7Cgl9CglmbG9hdCBnMCggZmxvYXQgYSApIHsKCQlyZXR1cm4gdzAoIGEgKSArIHcxKCBhICk7Cgl9CglmbG9hdCBnMSggZmxvYXQgYSApIHsKCQlyZXR1cm4gdzIoIGEgKSArIHczKCBhICk7Cgl9CglmbG9hdCBoMCggZmxvYXQgYSApIHsKCQlyZXR1cm4gLSAxLjAgKyB3MSggYSApIC8gKCB3MCggYSApICsgdzEoIGEgKSApOwoJfQoJZmxvYXQgaDEoIGZsb2F0IGEgKSB7CgkJcmV0dXJuIDEuMCArIHczKCBhICkgLyAoIHcyKCBhICkgKyB3MyggYSApICk7Cgl9Cgl2ZWM0IGJpY3ViaWMoIHNhbXBsZXIyRCB0ZXgsIHZlYzIgdXYsIHZlYzQgdGV4ZWxTaXplLCBmbG9hdCBsb2QgKSB7CgkJdXYgPSB1diAqIHRleGVsU2l6ZS56dyArIDAuNTsKCQl2ZWMyIGl1diA9IGZsb29yKCB1diApOwoJCXZlYzIgZnV2ID0gZnJhY3QoIHV2ICk7CgkJZmxvYXQgZzB4ID0gZzAoIGZ1di54ICk7CgkJZmxvYXQgZzF4ID0gZzEoIGZ1di54ICk7CgkJZmxvYXQgaDB4ID0gaDAoIGZ1di54ICk7CgkJZmxvYXQgaDF4ID0gaDEoIGZ1di54ICk7CgkJZmxvYXQgaDB5ID0gaDAoIGZ1di55ICk7CgkJZmxvYXQgaDF5ID0gaDEoIGZ1di55ICk7CgkJdmVjMiBwMCA9ICggdmVjMiggaXV2LnggKyBoMHgsIGl1di55ICsgaDB5ICkgLSAwLjUgKSAqIHRleGVsU2l6ZS54eTsKCQl2ZWMyIHAxID0gKCB2ZWMyKCBpdXYueCArIGgxeCwgaXV2LnkgKyBoMHkgKSAtIDAuNSApICogdGV4ZWxTaXplLnh5OwoJCXZlYzIgcDIgPSAoIHZlYzIoIGl1di54ICsgaDB4LCBpdXYueSArIGgxeSApIC0gMC41ICkgKiB0ZXhlbFNpemUueHk7CgkJdmVjMiBwMyA9ICggdmVjMiggaXV2LnggKyBoMXgsIGl1di55ICsgaDF5ICkgLSAwLjUgKSAqIHRleGVsU2l6ZS54eTsKCQlyZXR1cm4gZzAoIGZ1di55ICkgKiAoIGcweCAqIHRleHR1cmVMb2QoIHRleCwgcDAsIGxvZCApICsgZzF4ICogdGV4dHVyZUxvZCggdGV4LCBwMSwgbG9kICkgKSArCgkJCWcxKCBmdXYueSApICogKCBnMHggKiB0ZXh0dXJlTG9kKCB0ZXgsIHAyLCBsb2QgKSArIGcxeCAqIHRleHR1cmVMb2QoIHRleCwgcDMsIGxvZCApICk7Cgl9Cgl2ZWM0IHRleHR1cmVCaWN1YmljKCBzYW1wbGVyMkQgc2FtcGxlciwgdmVjMiB1diwgZmxvYXQgbG9kICkgewoJCXZlYzIgZkxvZFNpemUgPSB2ZWMyKCB0ZXh0dXJlU2l6ZSggc2FtcGxlciwgaW50KCBsb2QgKSApICk7CgkJdmVjMiBjTG9kU2l6ZSA9IHZlYzIoIHRleHR1cmVTaXplKCBzYW1wbGVyLCBpbnQoIGxvZCArIDEuMCApICkgKTsKCQl2ZWMyIGZMb2RTaXplSW52ID0gMS4wIC8gZkxvZFNpemU7CgkJdmVjMiBjTG9kU2l6ZUludiA9IDEuMCAvIGNMb2RTaXplOwoJCXZlYzQgZlNhbXBsZSA9IGJpY3ViaWMoIHNhbXBsZXIsIHV2LCB2ZWM0KCBmTG9kU2l6ZUludiwgZkxvZFNpemUgKSwgZmxvb3IoIGxvZCApICk7CgkJdmVjNCBjU2FtcGxlID0gYmljdWJpYyggc2FtcGxlciwgdXYsIHZlYzQoIGNMb2RTaXplSW52LCBjTG9kU2l6ZSApLCBjZWlsKCBsb2QgKSApOwoJCXJldHVybiBtaXgoIGZTYW1wbGUsIGNTYW1wbGUsIGZyYWN0KCBsb2QgKSApOwoJfQoJdmVjMyBnZXRWb2x1bWVUcmFuc21pc3Npb25SYXkoIGNvbnN0IGluIHZlYzMgbiwgY29uc3QgaW4gdmVjMyB2LCBjb25zdCBpbiBmbG9hdCB0aGlja25lc3MsIGNvbnN0IGluIGZsb2F0IGlvciwgY29uc3QgaW4gbWF0NCBtb2RlbE1hdHJpeCApIHsKCQl2ZWMzIHJlZnJhY3Rpb25WZWN0b3IgPSByZWZyYWN0KCAtIHYsIG5vcm1hbGl6ZSggbiApLCAxLjAgLyBpb3IgKTsKCQl2ZWMzIG1vZGVsU2NhbGU7CgkJbW9kZWxTY2FsZS54ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMCBdLnh5eiApICk7CgkJbW9kZWxTY2FsZS55ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMSBdLnh5eiApICk7CgkJbW9kZWxTY2FsZS56ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMiBdLnh5eiApICk7CgkJcmV0dXJuIG5vcm1hbGl6ZSggcmVmcmFjdGlvblZlY3RvciApICogdGhpY2tuZXNzICogbW9kZWxTY2FsZTsKCX0KCWZsb2F0IGFwcGx5SW9yVG9Sb3VnaG5lc3MoIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gZmxvYXQgaW9yICkgewoJCXJldHVybiByb3VnaG5lc3MgKiBjbGFtcCggaW9yICogMi4wIC0gMi4wLCAwLjAsIDEuMCApOwoJfQoJdmVjNCBnZXRUcmFuc21pc3Npb25TYW1wbGUoIGNvbnN0IGluIHZlYzIgZnJhZ0Nvb3JkLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGZsb2F0IGlvciApIHsKCQlmbG9hdCBsb2QgPSBsb2cyKCB0cmFuc21pc3Npb25TYW1wbGVyU2l6ZS54ICkgKiBhcHBseUlvclRvUm91Z2huZXNzKCByb3VnaG5lc3MsIGlvciApOwoJCXJldHVybiB0ZXh0dXJlQmljdWJpYyggdHJhbnNtaXNzaW9uU2FtcGxlck1hcCwgZnJhZ0Nvb3JkLnh5LCBsb2QgKTsKCX0KCXZlYzMgdm9sdW1lQXR0ZW51YXRpb24oIGNvbnN0IGluIGZsb2F0IHRyYW5zbWlzc2lvbkRpc3RhbmNlLCBjb25zdCBpbiB2ZWMzIGF0dGVudWF0aW9uQ29sb3IsIGNvbnN0IGluIGZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2UgKSB7CgkJaWYgKCBpc2luZiggYXR0ZW51YXRpb25EaXN0YW5jZSApICkgewoJCQlyZXR1cm4gdmVjMyggMS4wICk7CgkJfSBlbHNlIHsKCQkJdmVjMyBhdHRlbnVhdGlvbkNvZWZmaWNpZW50ID0gLWxvZyggYXR0ZW51YXRpb25Db2xvciApIC8gYXR0ZW51YXRpb25EaXN0YW5jZTsKCQkJdmVjMyB0cmFuc21pdHRhbmNlID0gZXhwKCAtIGF0dGVudWF0aW9uQ29lZmZpY2llbnQgKiB0cmFuc21pc3Npb25EaXN0YW5jZSApOwkJCXJldHVybiB0cmFuc21pdHRhbmNlOwoJCX0KCX0KCXZlYzQgZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbiggY29uc3QgaW4gdmVjMyBuLCBjb25zdCBpbiB2ZWMzIHYsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gdmVjMyBkaWZmdXNlQ29sb3IsCgkJY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gdmVjMyBwb3NpdGlvbiwgY29uc3QgaW4gbWF0NCBtb2RlbE1hdHJpeCwKCQljb25zdCBpbiBtYXQ0IHZpZXdNYXRyaXgsIGNvbnN0IGluIG1hdDQgcHJvak1hdHJpeCwgY29uc3QgaW4gZmxvYXQgZGlzcGVyc2lvbiwgY29uc3QgaW4gZmxvYXQgaW9yLCBjb25zdCBpbiBmbG9hdCB0aGlja25lc3MsCgkJY29uc3QgaW4gdmVjMyBhdHRlbnVhdGlvbkNvbG9yLCBjb25zdCBpbiBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlICkgewoJCXZlYzQgdHJhbnNtaXR0ZWRMaWdodDsKCQl2ZWMzIHRyYW5zbWl0dGFuY2U7CgkJI2lmZGVmIFVTRV9ESVNQRVJTSU9OCgkJCWZsb2F0IGhhbGZTcHJlYWQgPSAoIGlvciAtIDEuMCApICogMC4wMjUgKiBkaXNwZXJzaW9uOwoJCQl2ZWMzIGlvcnMgPSB2ZWMzKCBpb3IgLSBoYWxmU3ByZWFkLCBpb3IsIGlvciArIGhhbGZTcHJlYWQgKTsKCQkJZm9yICggaW50IGkgPSAwOyBpIDwgMzsgaSArKyApIHsKCQkJCXZlYzMgdHJhbnNtaXNzaW9uUmF5ID0gZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCBuLCB2LCB0aGlja25lc3MsIGlvcnNbIGkgXSwgbW9kZWxNYXRyaXggKTsKCQkJCXZlYzMgcmVmcmFjdGVkUmF5RXhpdCA9IHBvc2l0aW9uICsgdHJhbnNtaXNzaW9uUmF5OwoJCQoJCQkJdmVjNCBuZGNQb3MgPSBwcm9qTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzQoIHJlZnJhY3RlZFJheUV4aXQsIDEuMCApOwoJCQkJdmVjMiByZWZyYWN0aW9uQ29vcmRzID0gbmRjUG9zLnh5IC8gbmRjUG9zLnc7CgkJCQlyZWZyYWN0aW9uQ29vcmRzICs9IDEuMDsKCQkJCXJlZnJhY3Rpb25Db29yZHMgLz0gMi4wOwoJCQoJCQkJdmVjNCB0cmFuc21pc3Npb25TYW1wbGUgPSBnZXRUcmFuc21pc3Npb25TYW1wbGUoIHJlZnJhY3Rpb25Db29yZHMsIHJvdWdobmVzcywgaW9yc1sgaSBdICk7CgkJCQl0cmFuc21pdHRlZExpZ2h0WyBpIF0gPSB0cmFuc21pc3Npb25TYW1wbGVbIGkgXTsKCQkJCXRyYW5zbWl0dGVkTGlnaHQuYSArPSB0cmFuc21pc3Npb25TYW1wbGUuYTsKCQkJCXRyYW5zbWl0dGFuY2VbIGkgXSA9IGRpZmZ1c2VDb2xvclsgaSBdICogdm9sdW1lQXR0ZW51YXRpb24oIGxlbmd0aCggdHJhbnNtaXNzaW9uUmF5ICksIGF0dGVudWF0aW9uQ29sb3IsIGF0dGVudWF0aW9uRGlzdGFuY2UgKVsgaSBdOwoJCQl9CgkJCXRyYW5zbWl0dGVkTGlnaHQuYSAvPSAzLjA7CgkJCgkJI2Vsc2UKCQkKCQkJdmVjMyB0cmFuc21pc3Npb25SYXkgPSBnZXRWb2x1bWVUcmFuc21pc3Npb25SYXkoIG4sIHYsIHRoaWNrbmVzcywgaW9yLCBtb2RlbE1hdHJpeCApOwoJCQl2ZWMzIHJlZnJhY3RlZFJheUV4aXQgPSBwb3NpdGlvbiArIHRyYW5zbWlzc2lvblJheTsKCQkJdmVjNCBuZGNQb3MgPSBwcm9qTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzQoIHJlZnJhY3RlZFJheUV4aXQsIDEuMCApOwoJCQl2ZWMyIHJlZnJhY3Rpb25Db29yZHMgPSBuZGNQb3MueHkgLyBuZGNQb3MudzsKCQkJcmVmcmFjdGlvbkNvb3JkcyArPSAxLjA7CgkJCXJlZnJhY3Rpb25Db29yZHMgLz0gMi4wOwoJCQl0cmFuc21pdHRlZExpZ2h0ID0gZ2V0VHJhbnNtaXNzaW9uU2FtcGxlKCByZWZyYWN0aW9uQ29vcmRzLCByb3VnaG5lc3MsIGlvciApOwoJCQl0cmFuc21pdHRhbmNlID0gZGlmZnVzZUNvbG9yICogdm9sdW1lQXR0ZW51YXRpb24oIGxlbmd0aCggdHJhbnNtaXNzaW9uUmF5ICksIGF0dGVudWF0aW9uQ29sb3IsIGF0dGVudWF0aW9uRGlzdGFuY2UgKTsKCQkKCQkjZW5kaWYKCQl2ZWMzIGF0dGVudWF0ZWRDb2xvciA9IHRyYW5zbWl0dGFuY2UgKiB0cmFuc21pdHRlZExpZ2h0LnJnYjsKCQl2ZWMzIEYgPSBFbnZpcm9ubWVudEJSREYoIG4sIHYsIHNwZWN1bGFyQ29sb3IsIHNwZWN1bGFyRjkwLCByb3VnaG5lc3MgKTsKCQlmbG9hdCB0cmFuc21pdHRhbmNlRmFjdG9yID0gKCB0cmFuc21pdHRhbmNlLnIgKyB0cmFuc21pdHRhbmNlLmcgKyB0cmFuc21pdHRhbmNlLmIgKSAvIDMuMDsKCQlyZXR1cm4gdmVjNCggKCAxLjAgLSBGICkgKiBhdHRlbnVhdGVkQ29sb3IsIDEuMCAtICggMS4wIC0gdHJhbnNtaXR0ZWRMaWdodC5hICkgKiB0cmFuc21pdHRhbmNlRmFjdG9yICk7Cgl9CiNlbmRpZmAsSWw9YCNpZiBkZWZpbmVkKCBVU0VfVVYgKSB8fCBkZWZpbmVkKCBVU0VfQU5JU09UUk9QWSApCgl2YXJ5aW5nIHZlYzIgdlV2OwojZW5kaWYKI2lmZGVmIFVTRV9NQVAKCXZhcnlpbmcgdmVjMiB2TWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0FMUEhBTUFQCgl2YXJ5aW5nIHZlYzIgdkFscGhhTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0xJR0hUTUFQCgl2YXJ5aW5nIHZlYzIgdkxpZ2h0TWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0FPTUFQCgl2YXJ5aW5nIHZlYzIgdkFvTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0JVTVBNQVAKCXZhcnlpbmcgdmVjMiB2QnVtcE1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9OT1JNQUxNQVAKCXZhcnlpbmcgdmVjMiB2Tm9ybWFsTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0VNSVNTSVZFTUFQCgl2YXJ5aW5nIHZlYzIgdkVtaXNzaXZlTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX01FVEFMTkVTU01BUAoJdmFyeWluZyB2ZWMyIHZNZXRhbG5lc3NNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQCgl2YXJ5aW5nIHZlYzIgdlJvdWdobmVzc01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9BTklTT1RST1BZTUFQCgl2YXJ5aW5nIHZlYzIgdkFuaXNvdHJvcHlNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQCgl2YXJ5aW5nIHZlYzIgdkNsZWFyY29hdE1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQCgl2YXJ5aW5nIHZlYzIgdkNsZWFyY29hdE5vcm1hbE1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTTUFQCgl2YXJ5aW5nIHZlYzIgdkNsZWFyY29hdFJvdWdobmVzc01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9JUklERVNDRU5DRU1BUAoJdmFyeWluZyB2ZWMyIHZJcmlkZXNjZW5jZU1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVAKCXZhcnlpbmcgdmVjMiB2SXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfU0hFRU5fQ09MT1JNQVAKCXZhcnlpbmcgdmVjMiB2U2hlZW5Db2xvck1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9TSEVFTl9ST1VHSE5FU1NNQVAKCXZhcnlpbmcgdmVjMiB2U2hlZW5Sb3VnaG5lc3NNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVAKCXZhcnlpbmcgdmVjMiB2U3BlY3VsYXJNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfU1BFQ1VMQVJfQ09MT1JNQVAKCXZhcnlpbmcgdmVjMiB2U3BlY3VsYXJDb2xvck1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9TUEVDVUxBUl9JTlRFTlNJVFlNQVAKCXZhcnlpbmcgdmVjMiB2U3BlY3VsYXJJbnRlbnNpdHlNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OTUFQCgl1bmlmb3JtIG1hdDMgdHJhbnNtaXNzaW9uTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZUcmFuc21pc3Npb25NYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQCgl1bmlmb3JtIG1hdDMgdGhpY2tuZXNzTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZUaGlja25lc3NNYXBVdjsKI2VuZGlmYCxObD1gI2lmIGRlZmluZWQoIFVTRV9VViApIHx8IGRlZmluZWQoIFVTRV9BTklTT1RST1BZICkKCXZhcnlpbmcgdmVjMiB2VXY7CiNlbmRpZgojaWZkZWYgVVNFX01BUAoJdW5pZm9ybSBtYXQzIG1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2TWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0FMUEhBTUFQCgl1bmlmb3JtIG1hdDMgYWxwaGFNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdkFscGhhTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0xJR0hUTUFQCgl1bmlmb3JtIG1hdDMgbGlnaHRNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdkxpZ2h0TWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0FPTUFQCgl1bmlmb3JtIG1hdDMgYW9NYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdkFvTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0JVTVBNQVAKCXVuaWZvcm0gbWF0MyBidW1wTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZCdW1wTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX05PUk1BTE1BUAoJdW5pZm9ybSBtYXQzIG5vcm1hbE1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2Tm9ybWFsTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUAoJdW5pZm9ybSBtYXQzIGRpc3BsYWNlbWVudE1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2RGlzcGxhY2VtZW50TWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0VNSVNTSVZFTUFQCgl1bmlmb3JtIG1hdDMgZW1pc3NpdmVNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdkVtaXNzaXZlTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX01FVEFMTkVTU01BUAoJdW5pZm9ybSBtYXQzIG1ldGFsbmVzc01hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2TWV0YWxuZXNzTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1JPVUdITkVTU01BUAoJdW5pZm9ybSBtYXQzIHJvdWdobmVzc01hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2Um91Z2huZXNzTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0FOSVNPVFJPUFlNQVAKCXVuaWZvcm0gbWF0MyBhbmlzb3Ryb3B5TWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZBbmlzb3Ryb3B5TWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVE1BUAoJdW5pZm9ybSBtYXQzIGNsZWFyY29hdE1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2Q2xlYXJjb2F0TWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAKCXVuaWZvcm0gbWF0MyBjbGVhcmNvYXROb3JtYWxNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdkNsZWFyY29hdE5vcm1hbE1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTTUFQCgl1bmlmb3JtIG1hdDMgY2xlYXJjb2F0Um91Z2huZXNzTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZDbGVhcmNvYXRSb3VnaG5lc3NNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfU0hFRU5fQ09MT1JNQVAKCXVuaWZvcm0gbWF0MyBzaGVlbkNvbG9yTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZTaGVlbkNvbG9yTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1NIRUVOX1JPVUdITkVTU01BUAoJdW5pZm9ybSBtYXQzIHNoZWVuUm91Z2huZXNzTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZTaGVlblJvdWdobmVzc01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9JUklERVNDRU5DRU1BUAoJdW5pZm9ybSBtYXQzIGlyaWRlc2NlbmNlTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZJcmlkZXNjZW5jZU1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVAKCXVuaWZvcm0gbWF0MyBpcmlkZXNjZW5jZVRoaWNrbmVzc01hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2SXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVAKCXVuaWZvcm0gbWF0MyBzcGVjdWxhck1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2U3BlY3VsYXJNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfU1BFQ1VMQVJfQ09MT1JNQVAKCXVuaWZvcm0gbWF0MyBzcGVjdWxhckNvbG9yTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZTcGVjdWxhckNvbG9yTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUAoJdW5pZm9ybSBtYXQzIHNwZWN1bGFySW50ZW5zaXR5TWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZTcGVjdWxhckludGVuc2l0eU1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVAKCXVuaWZvcm0gbWF0MyB0cmFuc21pc3Npb25NYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdlRyYW5zbWlzc2lvbk1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9USElDS05FU1NNQVAKCXVuaWZvcm0gbWF0MyB0aGlja25lc3NNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdlRoaWNrbmVzc01hcFV2OwojZW5kaWZgLE9sPWAjaWYgZGVmaW5lZCggVVNFX1VWICkgfHwgZGVmaW5lZCggVVNFX0FOSVNPVFJPUFkgKQoJdlV2ID0gdmVjMyggdXYsIDEgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfTUFQCgl2TWFwVXYgPSAoIG1hcFRyYW5zZm9ybSAqIHZlYzMoIE1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX0FMUEhBTUFQCgl2QWxwaGFNYXBVdiA9ICggYWxwaGFNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBBTFBIQU1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX0xJR0hUTUFQCgl2TGlnaHRNYXBVdiA9ICggbGlnaHRNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBMSUdIVE1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX0FPTUFQCgl2QW9NYXBVdiA9ICggYW9NYXBUcmFuc2Zvcm0gKiB2ZWMzKCBBT01BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX0JVTVBNQVAKCXZCdW1wTWFwVXYgPSAoIGJ1bXBNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBCVU1QTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfTk9STUFMTUFQCgl2Tm9ybWFsTWFwVXYgPSAoIG5vcm1hbE1hcFRyYW5zZm9ybSAqIHZlYzMoIE5PUk1BTE1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUAoJdkRpc3BsYWNlbWVudE1hcFV2ID0gKCBkaXNwbGFjZW1lbnRNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBESVNQTEFDRU1FTlRNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9FTUlTU0lWRU1BUAoJdkVtaXNzaXZlTWFwVXYgPSAoIGVtaXNzaXZlTWFwVHJhbnNmb3JtICogdmVjMyggRU1JU1NJVkVNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVAKCXZNZXRhbG5lc3NNYXBVdiA9ICggbWV0YWxuZXNzTWFwVHJhbnNmb3JtICogdmVjMyggTUVUQUxORVNTTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQCgl2Um91Z2huZXNzTWFwVXYgPSAoIHJvdWdobmVzc01hcFRyYW5zZm9ybSAqIHZlYzMoIFJPVUdITkVTU01BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX0FOSVNPVFJPUFlNQVAKCXZBbmlzb3Ryb3B5TWFwVXYgPSAoIGFuaXNvdHJvcHlNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBBTklTT1RST1BZTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQCgl2Q2xlYXJjb2F0TWFwVXYgPSAoIGNsZWFyY29hdE1hcFRyYW5zZm9ybSAqIHZlYzMoIENMRUFSQ09BVE1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAKCXZDbGVhcmNvYXROb3JtYWxNYXBVdiA9ICggY2xlYXJjb2F0Tm9ybWFsTWFwVHJhbnNmb3JtICogdmVjMyggQ0xFQVJDT0FUX05PUk1BTE1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAKCXZDbGVhcmNvYXRSb3VnaG5lc3NNYXBVdiA9ICggY2xlYXJjb2F0Um91Z2huZXNzTWFwVHJhbnNmb3JtICogdmVjMyggQ0xFQVJDT0FUX1JPVUdITkVTU01BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX0lSSURFU0NFTkNFTUFQCgl2SXJpZGVzY2VuY2VNYXBVdiA9ICggaXJpZGVzY2VuY2VNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBJUklERVNDRU5DRU1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUAoJdklyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXYgPSAoIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVHJhbnNmb3JtICogdmVjMyggSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfU0hFRU5fQ09MT1JNQVAKCXZTaGVlbkNvbG9yTWFwVXYgPSAoIHNoZWVuQ29sb3JNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBTSEVFTl9DT0xPUk1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX1NIRUVOX1JPVUdITkVTU01BUAoJdlNoZWVuUm91Z2huZXNzTWFwVXYgPSAoIHNoZWVuUm91Z2huZXNzTWFwVHJhbnNmb3JtICogdmVjMyggU0hFRU5fUk9VR0hORVNTTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVAKCXZTcGVjdWxhck1hcFV2ID0gKCBzcGVjdWxhck1hcFRyYW5zZm9ybSAqIHZlYzMoIFNQRUNVTEFSTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfU1BFQ1VMQVJfQ09MT1JNQVAKCXZTcGVjdWxhckNvbG9yTWFwVXYgPSAoIHNwZWN1bGFyQ29sb3JNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBTUEVDVUxBUl9DT0xPUk1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUAoJdlNwZWN1bGFySW50ZW5zaXR5TWFwVXYgPSAoIHNwZWN1bGFySW50ZW5zaXR5TWFwVHJhbnNmb3JtICogdmVjMyggU1BFQ1VMQVJfSU5URU5TSVRZTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OTUFQCgl2VHJhbnNtaXNzaW9uTWFwVXYgPSAoIHRyYW5zbWlzc2lvbk1hcFRyYW5zZm9ybSAqIHZlYzMoIFRSQU5TTUlTU0lPTk1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX1RISUNLTkVTU01BUAoJdlRoaWNrbmVzc01hcFV2ID0gKCB0aGlja25lc3NNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBUSElDS05FU1NNQVBfVVYsIDEgKSApLnh5OwojZW5kaWZgLEJsPWAjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIERJU1RBTkNFICkgfHwgZGVmaW5lZCAoIFVTRV9TSEFET1dNQVAgKSB8fCBkZWZpbmVkICggVVNFX1RSQU5TTUlTU0lPTiApIHx8IE5VTV9TUE9UX0xJR0hUX0NPT1JEUyA+IDAKCXZlYzQgd29ybGRQb3NpdGlvbiA9IHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTsKCSNpZmRlZiBVU0VfQkFUQ0hJTkcKCQl3b3JsZFBvc2l0aW9uID0gYmF0Y2hpbmdNYXRyaXggKiB3b3JsZFBvc2l0aW9uOwoJI2VuZGlmCgkjaWZkZWYgVVNFX0lOU1RBTkNJTkcKCQl3b3JsZFBvc2l0aW9uID0gaW5zdGFuY2VNYXRyaXggKiB3b3JsZFBvc2l0aW9uOwoJI2VuZGlmCgl3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB3b3JsZFBvc2l0aW9uOwojZW5kaWZgO2NvbnN0IERlPXthbHBoYWhhc2hfZnJhZ21lbnQ6emEsYWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ6R2EsYWxwaGFtYXBfZnJhZ21lbnQ6SGEsYWxwaGFtYXBfcGFyc19mcmFnbWVudDpWYSxhbHBoYXRlc3RfZnJhZ21lbnQ6a2EsYWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ6V2EsYW9tYXBfZnJhZ21lbnQ6WGEsYW9tYXBfcGFyc19mcmFnbWVudDpxYSxiYXRjaGluZ19wYXJzX3ZlcnRleDpZYSxiYXRjaGluZ192ZXJ0ZXg6JGEsYmVnaW5fdmVydGV4OkthLGJlZ2lubm9ybWFsX3ZlcnRleDpaYSxic2RmczpqYSxpcmlkZXNjZW5jZV9mcmFnbWVudDpKYSxidW1wbWFwX3BhcnNfZnJhZ21lbnQ6UWEsY2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50OmVvLGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50OnRvLGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleDpubyxjbGlwcGluZ19wbGFuZXNfdmVydGV4OmlvLGNvbG9yX2ZyYWdtZW50OnJvLGNvbG9yX3BhcnNfZnJhZ21lbnQ6c28sY29sb3JfcGFyc192ZXJ0ZXg6YW8sY29sb3JfdmVydGV4Om9vLGNvbW1vbjpsbyxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ6Y28sZGVmYXVsdG5vcm1hbF92ZXJ0ZXg6dW8sZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4OmhvLGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg6Zm8sZW1pc3NpdmVtYXBfZnJhZ21lbnQ6cG8sZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudDptbyxjb2xvcnNwYWNlX2ZyYWdtZW50OmdvLGNvbG9yc3BhY2VfcGFyc19mcmFnbWVudDpfbyxlbnZtYXBfZnJhZ21lbnQ6dm8sZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50OnhvLGVudm1hcF9wYXJzX2ZyYWdtZW50Ok1vLGVudm1hcF9wYXJzX3ZlcnRleDpTbyxlbnZtYXBfcGh5c2ljYWxfcGFyc19mcmFnbWVudDpMbyxlbnZtYXBfdmVydGV4OkVvLGZvZ192ZXJ0ZXg6eW8sZm9nX3BhcnNfdmVydGV4OlRvLGZvZ19mcmFnbWVudDpBbyxmb2dfcGFyc19mcmFnbWVudDp3byxncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50OmJvLGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ6Um8sbGlnaHRzX2xhbWJlcnRfZnJhZ21lbnQ6Q28sbGlnaHRzX2xhbWJlcnRfcGFyc19mcmFnbWVudDpQbyxsaWdodHNfcGFyc19iZWdpbjpEbyxsaWdodHNfdG9vbl9mcmFnbWVudDpVbyxsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50OkZvLGxpZ2h0c19waG9uZ19mcmFnbWVudDpJbyxsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudDpObyxsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ6T28sbGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ6Qm8sbGlnaHRzX2ZyYWdtZW50X2JlZ2luOnpvLGxpZ2h0c19mcmFnbWVudF9tYXBzOkdvLGxpZ2h0c19mcmFnbWVudF9lbmQ6SG8sbG9nZGVwdGhidWZfZnJhZ21lbnQ6Vm8sbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudDprbyxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleDpXbyxsb2dkZXB0aGJ1Zl92ZXJ0ZXg6WG8sbWFwX2ZyYWdtZW50OnFvLG1hcF9wYXJzX2ZyYWdtZW50OllvLG1hcF9wYXJ0aWNsZV9mcmFnbWVudDokbyxtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudDpLbyxtZXRhbG5lc3NtYXBfZnJhZ21lbnQ6Wm8sbWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ6am8sbW9ycGhpbnN0YW5jZV92ZXJ0ZXg6Sm8sbW9ycGhjb2xvcl92ZXJ0ZXg6UW8sbW9ycGhub3JtYWxfdmVydGV4OmVsLG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4OnRsLG1vcnBodGFyZ2V0X3ZlcnRleDpubCxub3JtYWxfZnJhZ21lbnRfYmVnaW46aWwsbm9ybWFsX2ZyYWdtZW50X21hcHM6cmwsbm9ybWFsX3BhcnNfZnJhZ21lbnQ6c2wsbm9ybWFsX3BhcnNfdmVydGV4OmFsLG5vcm1hbF92ZXJ0ZXg6b2wsbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ6bGwsY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbjpjbCxjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X21hcHM6dWwsY2xlYXJjb2F0X3BhcnNfZnJhZ21lbnQ6aGwsaXJpZGVzY2VuY2VfcGFyc19mcmFnbWVudDpkbCxvcGFxdWVfZnJhZ21lbnQ6ZmwscGFja2luZzpwbCxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50Om1sLHByb2plY3RfdmVydGV4OmdsLGRpdGhlcmluZ19mcmFnbWVudDpfbCxkaXRoZXJpbmdfcGFyc19mcmFnbWVudDp2bCxyb3VnaG5lc3NtYXBfZnJhZ21lbnQ6eGwscm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQ6TWwsc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ6U2wsc2hhZG93bWFwX3BhcnNfdmVydGV4OkVsLHNoYWRvd21hcF92ZXJ0ZXg6eWwsc2hhZG93bWFza19wYXJzX2ZyYWdtZW50OlRsLHNraW5iYXNlX3ZlcnRleDpBbCxza2lubmluZ19wYXJzX3ZlcnRleDp3bCxza2lubmluZ192ZXJ0ZXg6Ymwsc2tpbm5vcm1hbF92ZXJ0ZXg6Umwsc3BlY3VsYXJtYXBfZnJhZ21lbnQ6Q2wsc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudDpQbCx0b25lbWFwcGluZ19mcmFnbWVudDpEbCx0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50OkxsLHRyYW5zbWlzc2lvbl9mcmFnbWVudDpVbCx0cmFuc21pc3Npb25fcGFyc19mcmFnbWVudDpGbCx1dl9wYXJzX2ZyYWdtZW50OklsLHV2X3BhcnNfdmVydGV4Ok5sLHV2X3ZlcnRleDpPbCx3b3JsZHBvc192ZXJ0ZXg6QmwsYmFja2dyb3VuZF92ZXJ0OmB2YXJ5aW5nIHZlYzIgdlV2Owp1bmlmb3JtIG1hdDMgdXZUcmFuc2Zvcm07CnZvaWQgbWFpbigpIHsKCXZVdiA9ICggdXZUcmFuc2Zvcm0gKiB2ZWMzKCB1diwgMSApICkueHk7CglnbF9Qb3NpdGlvbiA9IHZlYzQoIHBvc2l0aW9uLnh5LCAxLjAsIDEuMCApOwp9YCxiYWNrZ3JvdW5kX2ZyYWc6YHVuaWZvcm0gc2FtcGxlcjJEIHQyRDsKdW5pZm9ybSBmbG9hdCBiYWNrZ3JvdW5kSW50ZW5zaXR5Owp2YXJ5aW5nIHZlYzIgdlV2Owp2b2lkIG1haW4oKSB7Cgl2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKCB0MkQsIHZVdiApOwoJI2lmZGVmIERFQ09ERV9WSURFT19URVhUVVJFCgkJdGV4Q29sb3IgPSB2ZWM0KCBtaXgoIHBvdyggdGV4Q29sb3IucmdiICogMC45NDc4NjcyOTg2ICsgdmVjMyggMC4wNTIxMzI3MDE0ICksIHZlYzMoIDIuNCApICksIHRleENvbG9yLnJnYiAqIDAuMDc3Mzk5MzgwOCwgdmVjMyggbGVzc1RoYW5FcXVhbCggdGV4Q29sb3IucmdiLCB2ZWMzKCAwLjA0MDQ1ICkgKSApICksIHRleENvbG9yLncgKTsKCSNlbmRpZgoJdGV4Q29sb3IucmdiICo9IGJhY2tncm91bmRJbnRlbnNpdHk7CglnbF9GcmFnQ29sb3IgPSB0ZXhDb2xvcjsKCSNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50Pgp9YCxiYWNrZ3JvdW5kQ3ViZV92ZXJ0OmB2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uOwojaW5jbHVkZSA8Y29tbW9uPgp2b2lkIG1haW4oKSB7Cgl2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApOwoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCWdsX1Bvc2l0aW9uLnogPSBnbF9Qb3NpdGlvbi53Owp9YCxiYWNrZ3JvdW5kQ3ViZV9mcmFnOmAjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRQoJdW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7CiNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKQoJdW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwOwojZW5kaWYKdW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwOwp1bmlmb3JtIGZsb2F0IGJhY2tncm91bmRCbHVycmluZXNzOwp1bmlmb3JtIGZsb2F0IGJhY2tncm91bmRJbnRlbnNpdHk7CnVuaWZvcm0gbWF0MyBiYWNrZ3JvdW5kUm90YXRpb247CnZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247CiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCSNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFCgkJdmVjNCB0ZXhDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIGJhY2tncm91bmRSb3RhdGlvbiAqIHZlYzMoIGZsaXBFbnZNYXAgKiB2V29ybGREaXJlY3Rpb24ueCwgdldvcmxkRGlyZWN0aW9uLnl6ICkgKTsKCSNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKQoJCXZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlQ3ViZVVWKCBlbnZNYXAsIGJhY2tncm91bmRSb3RhdGlvbiAqIHZXb3JsZERpcmVjdGlvbiwgYmFja2dyb3VuZEJsdXJyaW5lc3MgKTsKCSNlbHNlCgkJdmVjNCB0ZXhDb2xvciA9IHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApOwoJI2VuZGlmCgl0ZXhDb2xvci5yZ2IgKj0gYmFja2dyb3VuZEludGVuc2l0eTsKCWdsX0ZyYWdDb2xvciA9IHRleENvbG9yOwoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+Cn1gLGN1YmVfdmVydDpgdmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4Kdm9pZCBtYWluKCkgewoJdldvcmxkRGlyZWN0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTsKCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CglnbF9Qb3NpdGlvbi56ID0gZ2xfUG9zaXRpb24udzsKfWAsY3ViZV9mcmFnOmB1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlOwp1bmlmb3JtIGZsb2F0IHRGbGlwOwp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CnZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247CnZvaWQgbWFpbigpIHsKCXZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIHRGbGlwICogdldvcmxkRGlyZWN0aW9uLngsIHZXb3JsZERpcmVjdGlvbi55eiApICk7CglnbF9GcmFnQ29sb3IgPSB0ZXhDb2xvcjsKCWdsX0ZyYWdDb2xvci5hICo9IG9wYWNpdHk7CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KfWAsZGVwdGhfdmVydDpgI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+CnZhcnlpbmcgdmVjMiB2SGlnaFByZWNpc2lvblpXOwp2b2lkIG1haW4oKSB7CgkjaW5jbHVkZSA8dXZfdmVydGV4PgoJI2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+CgkjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUAoJCSNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+CgkJI2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD4KCQkjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+CgkjZW5kaWYKCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD4KCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PgoJdkhpZ2hQcmVjaXNpb25aVyA9IGdsX1Bvc2l0aW9uLnp3Owp9YCxkZXB0aF9mcmFnOmAjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwCgl1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CiNlbmRpZgojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8cGFja2luZz4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Pgp2YXJ5aW5nIHZlYzIgdkhpZ2hQcmVjaXNpb25aVzsKdm9pZCBtYWluKCkgewoJdmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAxLjAgKTsKCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+CgkjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwCgkJZGlmZnVzZUNvbG9yLmEgPSBvcGFjaXR5OwoJI2VuZGlmCgkjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+CglmbG9hdCBmcmFnQ29vcmRaID0gMC41ICogdkhpZ2hQcmVjaXNpb25aV1swXSAvIHZIaWdoUHJlY2lzaW9uWldbMV0gKyAwLjU7CgkjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwCgkJZ2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggMS4wIC0gZnJhZ0Nvb3JkWiApLCBvcGFjaXR5ICk7CgkjZWxpZiBERVBUSF9QQUNLSU5HID09IDMyMDEKCQlnbF9GcmFnQ29sb3IgPSBwYWNrRGVwdGhUb1JHQkEoIGZyYWdDb29yZFogKTsKCSNlbGlmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMgoJCWdsX0ZyYWdDb2xvciA9IHZlYzQoIHBhY2tEZXB0aFRvUkdCKCBmcmFnQ29vcmRaICksIDEuMCApOwoJI2VsaWYgREVQVEhfUEFDS0lORyA9PSAzMjAzCgkJZ2xfRnJhZ0NvbG9yID0gdmVjNCggcGFja0RlcHRoVG9SRyggZnJhZ0Nvb3JkWiApLCAwLjAsIDEuMCApOwoJI2VuZGlmCn1gLGRpc3RhbmNlUkdCQV92ZXJ0OmAjZGVmaW5lIERJU1RBTkNFCnZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Pgp2b2lkIG1haW4oKSB7CgkjaW5jbHVkZSA8dXZfdmVydGV4PgoJI2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+CgkjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUAoJCSNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+CgkJI2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD4KCQkjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+CgkjZW5kaWYKCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJI2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD4KCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PgoJdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejsKfWAsZGlzdGFuY2VSR0JBX2ZyYWc6YCNkZWZpbmUgRElTVEFOQ0UKdW5pZm9ybSB2ZWMzIHJlZmVyZW5jZVBvc2l0aW9uOwp1bmlmb3JtIGZsb2F0IG5lYXJEaXN0YW5jZTsKdW5pZm9ybSBmbG9hdCBmYXJEaXN0YW5jZTsKdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uOwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8cGFja2luZz4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbiAoKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDEuMCApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCSNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD4KCWZsb2F0IGRpc3QgPSBsZW5ndGgoIHZXb3JsZFBvc2l0aW9uIC0gcmVmZXJlbmNlUG9zaXRpb24gKTsKCWRpc3QgPSAoIGRpc3QgLSBuZWFyRGlzdGFuY2UgKSAvICggZmFyRGlzdGFuY2UgLSBuZWFyRGlzdGFuY2UgKTsKCWRpc3QgPSBzYXR1cmF0ZSggZGlzdCApOwoJZ2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBkaXN0ICk7Cn1gLGVxdWlyZWN0X3ZlcnQ6YHZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247CiNpbmNsdWRlIDxjb21tb24+CnZvaWQgbWFpbigpIHsKCXZXb3JsZERpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4Pgp9YCxlcXVpcmVjdF9mcmFnOmB1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7CnZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247CiNpbmNsdWRlIDxjb21tb24+CnZvaWQgbWFpbigpIHsKCXZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGREaXJlY3Rpb24gKTsKCXZlYzIgc2FtcGxlVVYgPSBlcXVpcmVjdFV2KCBkaXJlY3Rpb24gKTsKCWdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdEVxdWlyZWN0LCBzYW1wbGVVViApOwoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+Cn1gLGxpbmVkYXNoZWRfdmVydDpgdW5pZm9ybSBmbG9hdCBzY2FsZTsKYXR0cmlidXRlIGZsb2F0IGxpbmVEaXN0YW5jZTsKdmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlOwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+CnZvaWQgbWFpbigpIHsKCXZMaW5lRGlzdGFuY2UgPSBzY2FsZSAqIGxpbmVEaXN0YW5jZTsKCSNpbmNsdWRlIDx1dl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PgoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+CgkjaW5jbHVkZSA8Zm9nX3ZlcnRleD4KfWAsbGluZWRhc2hlZF9mcmFnOmB1bmlmb3JtIHZlYzMgZGlmZnVzZTsKdW5pZm9ybSBmbG9hdCBvcGFjaXR5Owp1bmlmb3JtIGZsb2F0IGRhc2hTaXplOwp1bmlmb3JtIGZsb2F0IHRvdGFsU2l6ZTsKdmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlOwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Pgp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTsKCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+CglpZiAoIG1vZCggdkxpbmVEaXN0YW5jZSwgdG90YWxTaXplICkgPiBkYXNoU2l6ZSApIHsKCQlkaXNjYXJkOwoJfQoJdmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PgoJb3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7CgkjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+Cn1gLG1lc2hiYXNpY192ZXJ0OmAjaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Pgp2b2lkIG1haW4oKSB7CgkjaW5jbHVkZSA8dXZfdmVydGV4PgoJI2luY2x1ZGUgPGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+CgkjaWYgZGVmaW5lZCAoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkICggVVNFX1NLSU5OSU5HICkKCQkjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PgoJCSNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+CgkJI2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD4KCQkjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+CgkJI2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PgoJI2VuZGlmCgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PgoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+CgkjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PgoJI2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8Zm9nX3ZlcnRleD4KfWAsbWVzaGJhc2ljX2ZyYWc6YHVuaWZvcm0gdmVjMyBkaWZmdXNlOwp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CiNpZm5kZWYgRkxBVF9TSEFERUQKCXZhcnlpbmcgdmVjMyB2Tm9ybWFsOwojZW5kaWYKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD4Kdm9pZCBtYWluKCkgewoJdmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PgoJUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTsKCSNpZmRlZiBVU0VfTElHSFRNQVAKCQl2ZWM0IGxpZ2h0TWFwVGV4ZWwgPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2TGlnaHRNYXBVdiApOwoJCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBsaWdodE1hcFRleGVsLnJnYiAqIGxpZ2h0TWFwSW50ZW5zaXR5ICogUkVDSVBST0NBTF9QSTsKCSNlbHNlCgkJcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IHZlYzMoIDEuMCApOwoJI2VuZGlmCgkjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+CglyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gZGlmZnVzZUNvbG9yLnJnYjsKCXZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTsKCSNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Pgp9YCxtZXNobGFtYmVydF92ZXJ0OmAjZGVmaW5lIExBTUJFUlQKdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxiYXRjaGluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+CnZvaWQgbWFpbigpIHsKCSNpbmNsdWRlIDx1dl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PgoJI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PgoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+Cgl2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejsKCSNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+CgkjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PgoJI2luY2x1ZGUgPGZvZ192ZXJ0ZXg+Cn1gLG1lc2hsYW1iZXJ0X2ZyYWc6YCNkZWZpbmUgTEFNQkVSVAp1bmlmb3JtIHZlYzMgZGlmZnVzZTsKdW5pZm9ybSB2ZWMzIGVtaXNzaXZlOwp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxwYWNraW5nPgojaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YnNkZnM+CiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bGlnaHRzX2xhbWJlcnRfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Pgp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTsKCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+CglSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApOwoJdmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTsKCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD4KCSNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD4KCSNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+CgkjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+CgkjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bGlnaHRzX2xhbWJlcnRfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPgoJI2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9tYXBzPgoJI2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+CgkjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+Cgl2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlOwoJI2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxvcGFxdWVfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KCSNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD4KCSNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+Cn1gLG1lc2htYXRjYXBfdmVydDpgI2RlZmluZSBNQVRDQVAKdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxiYXRjaGluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+CnZvaWQgbWFpbigpIHsKCSNpbmNsdWRlIDx1dl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PgoJI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PgoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+CgkjaW5jbHVkZSA8Zm9nX3ZlcnRleD4KCXZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6Owp9YCxtZXNobWF0Y2FwX2ZyYWc6YCNkZWZpbmUgTUFUQ0FQCnVuaWZvcm0gdmVjMyBkaWZmdXNlOwp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CnVuaWZvcm0gc2FtcGxlcjJEIG1hdGNhcDsKdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD4Kdm9pZCBtYWluKCkgewoJdmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj4KCSNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz4KCXZlYzMgdmlld0RpciA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApOwoJdmVjMyB4ID0gbm9ybWFsaXplKCB2ZWMzKCB2aWV3RGlyLnosIDAuMCwgLSB2aWV3RGlyLnggKSApOwoJdmVjMyB5ID0gY3Jvc3MoIHZpZXdEaXIsIHggKTsKCXZlYzIgdXYgPSB2ZWMyKCBkb3QoIHgsIG5vcm1hbCApLCBkb3QoIHksIG5vcm1hbCApICkgKiAwLjQ5NSArIDAuNTsKCSNpZmRlZiBVU0VfTUFUQ0FQCgkJdmVjNCBtYXRjYXBDb2xvciA9IHRleHR1cmUyRCggbWF0Y2FwLCB1diApOwoJI2Vsc2UKCQl2ZWM0IG1hdGNhcENvbG9yID0gdmVjNCggdmVjMyggbWl4KCAwLjIsIDAuOCwgdXYueSApICksIDEuMCApOwoJI2VuZGlmCgl2ZWMzIG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiICogbWF0Y2FwQ29sb3IucmdiOwoJI2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD4KCSNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGZvZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD4KfWAsbWVzaG5vcm1hbF92ZXJ0OmAjZGVmaW5lIE5PUk1BTAojaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFICkKCXZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uOwojZW5kaWYKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+CnZvaWQgbWFpbigpIHsKCSNpbmNsdWRlIDx1dl92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KI2lmIGRlZmluZWQoIEZMQVRfU0hBREVEICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQX1RBTkdFTlRTUEFDRSApCgl2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejsKI2VuZGlmCn1gLG1lc2hub3JtYWxfZnJhZzpgI2RlZmluZSBOT1JNQUwKdW5pZm9ybSBmbG9hdCBvcGFjaXR5OwojaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFICkKCXZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uOwojZW5kaWYKI2luY2x1ZGUgPHBhY2tpbmc+CiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD4Kdm9pZCBtYWluKCkgewoJdmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAwLjAsIDAuMCwgMC4wLCBvcGFjaXR5ICk7CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj4KCSNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz4KCWdsX0ZyYWdDb2xvciA9IHZlYzQoIHBhY2tOb3JtYWxUb1JHQiggbm9ybWFsICksIGRpZmZ1c2VDb2xvci5hICk7CgkjaWZkZWYgT1BBUVVFCgkJZ2xfRnJhZ0NvbG9yLmEgPSAxLjA7CgkjZW5kaWYKfWAsbWVzaHBob25nX3ZlcnQ6YCNkZWZpbmUgUEhPTkcKdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxiYXRjaGluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+CnZvaWQgbWFpbigpIHsKCSNpbmNsdWRlIDx1dl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PgoJI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PgoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+Cgl2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejsKCSNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+CgkjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PgoJI2luY2x1ZGUgPGZvZ192ZXJ0ZXg+Cn1gLG1lc2hwaG9uZ19mcmFnOmAjZGVmaW5lIFBIT05HCnVuaWZvcm0gdmVjMyBkaWZmdXNlOwp1bmlmb3JtIHZlYzMgZW1pc3NpdmU7CnVuaWZvcm0gdmVjMyBzcGVjdWxhcjsKdW5pZm9ybSBmbG9hdCBzaGluaW5lc3M7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPHBhY2tpbmc+CiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxic2Rmcz4KI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Pgp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTsKCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+CglSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApOwoJdmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTsKCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD4KCSNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD4KCSNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+CgkjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+CgkjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bGlnaHRzX3Bob25nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9iZWdpbj4KCSNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfbWFwcz4KCSNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfZW5kPgoJI2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PgoJdmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTsKCSNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Pgp9YCxtZXNocGh5c2ljYWxfdmVydDpgI2RlZmluZSBTVEFOREFSRAp2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjsKI2lmZGVmIFVTRV9UUkFOU01JU1NJT04KCXZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjsKI2VuZGlmCiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxiYXRjaGluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+CnZvaWQgbWFpbigpIHsKCSNpbmNsdWRlIDx1dl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PgoJI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PgoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+Cgl2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejsKCSNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+CgkjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxmb2dfdmVydGV4PgojaWZkZWYgVVNFX1RSQU5TTUlTU0lPTgoJdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejsKI2VuZGlmCn1gLG1lc2hwaHlzaWNhbF9mcmFnOmAjZGVmaW5lIFNUQU5EQVJECiNpZmRlZiBQSFlTSUNBTAoJI2RlZmluZSBJT1IKCSNkZWZpbmUgVVNFX1NQRUNVTEFSCiNlbmRpZgp1bmlmb3JtIHZlYzMgZGlmZnVzZTsKdW5pZm9ybSB2ZWMzIGVtaXNzaXZlOwp1bmlmb3JtIGZsb2F0IHJvdWdobmVzczsKdW5pZm9ybSBmbG9hdCBtZXRhbG5lc3M7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2lmZGVmIElPUgoJdW5pZm9ybSBmbG9hdCBpb3I7CiNlbmRpZgojaWZkZWYgVVNFX1NQRUNVTEFSCgl1bmlmb3JtIGZsb2F0IHNwZWN1bGFySW50ZW5zaXR5OwoJdW5pZm9ybSB2ZWMzIHNwZWN1bGFyQ29sb3I7CgkjaWZkZWYgVVNFX1NQRUNVTEFSX0NPTE9STUFQCgkJdW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJDb2xvck1hcDsKCSNlbmRpZgoJI2lmZGVmIFVTRV9TUEVDVUxBUl9JTlRFTlNJVFlNQVAKCQl1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhckludGVuc2l0eU1hcDsKCSNlbmRpZgojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVQKCXVuaWZvcm0gZmxvYXQgY2xlYXJjb2F0OwoJdW5pZm9ybSBmbG9hdCBjbGVhcmNvYXRSb3VnaG5lc3M7CiNlbmRpZgojaWZkZWYgVVNFX0RJU1BFUlNJT04KCXVuaWZvcm0gZmxvYXQgZGlzcGVyc2lvbjsKI2VuZGlmCiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0UKCXVuaWZvcm0gZmxvYXQgaXJpZGVzY2VuY2U7Cgl1bmlmb3JtIGZsb2F0IGlyaWRlc2NlbmNlSU9SOwoJdW5pZm9ybSBmbG9hdCBpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW07Cgl1bmlmb3JtIGZsb2F0IGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTsKI2VuZGlmCiNpZmRlZiBVU0VfU0hFRU4KCXVuaWZvcm0gdmVjMyBzaGVlbkNvbG9yOwoJdW5pZm9ybSBmbG9hdCBzaGVlblJvdWdobmVzczsKCSNpZmRlZiBVU0VfU0hFRU5fQ09MT1JNQVAKCQl1bmlmb3JtIHNhbXBsZXIyRCBzaGVlbkNvbG9yTWFwOwoJI2VuZGlmCgkjaWZkZWYgVVNFX1NIRUVOX1JPVUdITkVTU01BUAoJCXVuaWZvcm0gc2FtcGxlcjJEIHNoZWVuUm91Z2huZXNzTWFwOwoJI2VuZGlmCiNlbmRpZgojaWZkZWYgVVNFX0FOSVNPVFJPUFkKCXVuaWZvcm0gdmVjMiBhbmlzb3Ryb3B5VmVjdG9yOwoJI2lmZGVmIFVTRV9BTklTT1RST1BZTUFQCgkJdW5pZm9ybSBzYW1wbGVyMkQgYW5pc290cm9weU1hcDsKCSNlbmRpZgojZW5kaWYKdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxwYWNraW5nPgojaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxpcmlkZXNjZW5jZV9mcmFnbWVudD4KI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD4KI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVudm1hcF9waHlzaWNhbF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDx0cmFuc21pc3Npb25fcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjbGVhcmNvYXRfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGlyaWRlc2NlbmNlX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Pgp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTsKCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+CglSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApOwoJdmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTsKCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD4KCSNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD4KCSNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bWV0YWxuZXNzbWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj4KCSNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz4KCSNpbmNsdWRlIDxjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X2JlZ2luPgoJI2luY2x1ZGUgPGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwcz4KCSNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPgoJI2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9tYXBzPgoJI2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+CgkjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+Cgl2ZWMzIHRvdGFsRGlmZnVzZSA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2U7Cgl2ZWMzIHRvdGFsU3BlY3VsYXIgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXI7CgkjaW5jbHVkZSA8dHJhbnNtaXNzaW9uX2ZyYWdtZW50PgoJdmVjMyBvdXRnb2luZ0xpZ2h0ID0gdG90YWxEaWZmdXNlICsgdG90YWxTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTsKCSNpZmRlZiBVU0VfU0hFRU4KCQlmbG9hdCBzaGVlbkVuZXJneUNvbXAgPSAxLjAgLSAwLjE1NyAqIG1heDMoIG1hdGVyaWFsLnNoZWVuQ29sb3IgKTsKCQlvdXRnb2luZ0xpZ2h0ID0gb3V0Z29pbmdMaWdodCAqIHNoZWVuRW5lcmd5Q29tcCArIHNoZWVuU3BlY3VsYXJEaXJlY3QgKyBzaGVlblNwZWN1bGFySW5kaXJlY3Q7CgkjZW5kaWYKCSNpZmRlZiBVU0VfQ0xFQVJDT0FUCgkJZmxvYXQgZG90TlZjYyA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIgKSApOwoJCXZlYzMgRmNjID0gRl9TY2hsaWNrKCBtYXRlcmlhbC5jbGVhcmNvYXRGMCwgbWF0ZXJpYWwuY2xlYXJjb2F0RjkwLCBkb3ROVmNjICk7CgkJb3V0Z29pbmdMaWdodCA9IG91dGdvaW5nTGlnaHQgKiAoIDEuMCAtIG1hdGVyaWFsLmNsZWFyY29hdCAqIEZjYyApICsgKCBjbGVhcmNvYXRTcGVjdWxhckRpcmVjdCArIGNsZWFyY29hdFNwZWN1bGFySW5kaXJlY3QgKSAqIG1hdGVyaWFsLmNsZWFyY29hdDsKCSNlbmRpZgoJI2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD4KCSNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGZvZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD4KfWAsbWVzaHRvb25fdmVydDpgI2RlZmluZSBUT09OCnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uOwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Pgp2b2lkIG1haW4oKSB7CgkjaW5jbHVkZSA8dXZfdmVydGV4PgoJI2luY2x1ZGUgPGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD4KCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PgoJdlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7CgkjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PgoJI2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8Zm9nX3ZlcnRleD4KfWAsbWVzaHRvb25fZnJhZzpgI2RlZmluZSBUT09OCnVuaWZvcm0gdmVjMyBkaWZmdXNlOwp1bmlmb3JtIHZlYzMgZW1pc3NpdmU7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPHBhY2tpbmc+CiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGJzZGZzPgojaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+CiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxpZ2h0c190b29uX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Pgp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTsKCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+CglSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApOwoJdmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTsKCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD4KCSNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD4KCSNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+CgkjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+CgkjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bGlnaHRzX3Rvb25fZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPgoJI2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9tYXBzPgoJI2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+CgkjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+Cgl2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlOwoJI2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD4KCSNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGZvZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD4KfWAscG9pbnRzX3ZlcnQ6YHVuaWZvcm0gZmxvYXQgc2l6ZTsKdW5pZm9ybSBmbG9hdCBzY2FsZTsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4KI2lmZGVmIFVTRV9QT0lOVFNfVVYKCXZhcnlpbmcgdmVjMiB2VXY7Cgl1bmlmb3JtIG1hdDMgdXZUcmFuc2Zvcm07CiNlbmRpZgp2b2lkIG1haW4oKSB7CgkjaWZkZWYgVVNFX1BPSU5UU19VVgoJCXZVdiA9ICggdXZUcmFuc2Zvcm0gKiB2ZWMzKCB1diwgMSApICkueHk7CgkjZW5kaWYKCSNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCWdsX1BvaW50U2l6ZSA9IHNpemU7CgkjaWZkZWYgVVNFX1NJWkVBVFRFTlVBVElPTgoJCWJvb2wgaXNQZXJzcGVjdGl2ZSA9IGlzUGVyc3BlY3RpdmVNYXRyaXgoIHByb2plY3Rpb25NYXRyaXggKTsKCQlpZiAoIGlzUGVyc3BlY3RpdmUgKSBnbF9Qb2ludFNpemUgKj0gKCBzY2FsZSAvIC0gbXZQb3NpdGlvbi56ICk7CgkjZW5kaWYKCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KCSNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+CgkjaW5jbHVkZSA8Zm9nX3ZlcnRleD4KfWAscG9pbnRzX2ZyYWc6YHVuaWZvcm0gdmVjMyBkaWZmdXNlOwp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCXZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApOwoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9wYXJ0aWNsZV9mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJb3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7CgkjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+Cn1gLHNoYWRvd192ZXJ0OmAjaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+CnZvaWQgbWFpbigpIHsKCSNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PgoJI2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD4KCSNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PgoJI2luY2x1ZGUgPGZvZ192ZXJ0ZXg+Cn1gLHNoYWRvd19mcmFnOmB1bmlmb3JtIHZlYzMgY29sb3I7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPHBhY2tpbmc+CiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGJzZGZzPgojaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD4KCWdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yLCBvcGFjaXR5ICogKCAxLjAgLSBnZXRTaGFkb3dNYXNrKCkgKSApOwoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50Pgp9YCxzcHJpdGVfdmVydDpgdW5pZm9ybSBmbG9hdCByb3RhdGlvbjsKdW5pZm9ybSB2ZWMyIGNlbnRlcjsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+CnZvaWQgbWFpbigpIHsKCSNpbmNsdWRlIDx1dl92ZXJ0ZXg+Cgl2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXhbIDMgXTsKCXZlYzIgc2NhbGUgPSB2ZWMyKCBsZW5ndGgoIG1vZGVsTWF0cml4WyAwIF0ueHl6ICksIGxlbmd0aCggbW9kZWxNYXRyaXhbIDEgXS54eXogKSApOwoJI2lmbmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OCgkJYm9vbCBpc1BlcnNwZWN0aXZlID0gaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApOwoJCWlmICggaXNQZXJzcGVjdGl2ZSApIHNjYWxlICo9IC0gbXZQb3NpdGlvbi56OwoJI2VuZGlmCgl2ZWMyIGFsaWduZWRQb3NpdGlvbiA9ICggcG9zaXRpb24ueHkgLSAoIGNlbnRlciAtIHZlYzIoIDAuNSApICkgKSAqIHNjYWxlOwoJdmVjMiByb3RhdGVkUG9zaXRpb247Cglyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7Cglyb3RhdGVkUG9zaXRpb24ueSA9IHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7CgltdlBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbjsKCWdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PgoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+CgkjaW5jbHVkZSA8Zm9nX3ZlcnRleD4KfWAsc3ByaXRlX2ZyYWc6YHVuaWZvcm0gdmVjMyBkaWZmdXNlOwp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Pgp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTsKCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+Cgl2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTsKCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD4KCSNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD4KCW91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiOwoJI2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD4KCSNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGZvZ19mcmFnbWVudD4KfWB9LHRlPXtjb21tb246e2RpZmZ1c2U6e3ZhbHVlOm5ldyBWZSgxNjc3NzIxNSl9LG9wYWNpdHk6e3ZhbHVlOjF9LG1hcDp7dmFsdWU6bnVsbH0sbWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9LGFscGhhTWFwOnt2YWx1ZTpudWxsfSxhbHBoYU1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfSxhbHBoYVRlc3Q6e3ZhbHVlOjB9fSxzcGVjdWxhcm1hcDp7c3BlY3VsYXJNYXA6e3ZhbHVlOm51bGx9LHNwZWN1bGFyTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9fSxlbnZtYXA6e2Vudk1hcDp7dmFsdWU6bnVsbH0sZW52TWFwUm90YXRpb246e3ZhbHVlOm5ldyBiZX0sZmxpcEVudk1hcDp7dmFsdWU6LTF9LHJlZmxlY3Rpdml0eTp7dmFsdWU6MX0saW9yOnt2YWx1ZToxLjV9LHJlZnJhY3Rpb25SYXRpbzp7dmFsdWU6Ljk4fX0sYW9tYXA6e2FvTWFwOnt2YWx1ZTpudWxsfSxhb01hcEludGVuc2l0eTp7dmFsdWU6MX0sYW9NYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX19LGxpZ2h0bWFwOntsaWdodE1hcDp7dmFsdWU6bnVsbH0sbGlnaHRNYXBJbnRlbnNpdHk6e3ZhbHVlOjF9LGxpZ2h0TWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9fSxidW1wbWFwOntidW1wTWFwOnt2YWx1ZTpudWxsfSxidW1wTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9LGJ1bXBTY2FsZTp7dmFsdWU6MX19LG5vcm1hbG1hcDp7bm9ybWFsTWFwOnt2YWx1ZTpudWxsfSxub3JtYWxNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX0sbm9ybWFsU2NhbGU6e3ZhbHVlOm5ldyBQZSgxLDEpfX0sZGlzcGxhY2VtZW50bWFwOntkaXNwbGFjZW1lbnRNYXA6e3ZhbHVlOm51bGx9LGRpc3BsYWNlbWVudE1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfSxkaXNwbGFjZW1lbnRTY2FsZTp7dmFsdWU6MX0sZGlzcGxhY2VtZW50Qmlhczp7dmFsdWU6MH19LGVtaXNzaXZlbWFwOntlbWlzc2l2ZU1hcDp7dmFsdWU6bnVsbH0sZW1pc3NpdmVNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX19LG1ldGFsbmVzc21hcDp7bWV0YWxuZXNzTWFwOnt2YWx1ZTpudWxsfSxtZXRhbG5lc3NNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX19LHJvdWdobmVzc21hcDp7cm91Z2huZXNzTWFwOnt2YWx1ZTpudWxsfSxyb3VnaG5lc3NNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX19LGdyYWRpZW50bWFwOntncmFkaWVudE1hcDp7dmFsdWU6bnVsbH19LGZvZzp7Zm9nRGVuc2l0eTp7dmFsdWU6MjVlLTV9LGZvZ05lYXI6e3ZhbHVlOjF9LGZvZ0Zhcjp7dmFsdWU6MmUzfSxmb2dDb2xvcjp7dmFsdWU6bmV3IFZlKDE2Nzc3MjE1KX19LGxpZ2h0czp7YW1iaWVudExpZ2h0Q29sb3I6e3ZhbHVlOltdfSxsaWdodFByb2JlOnt2YWx1ZTpbXX0sZGlyZWN0aW9uYWxMaWdodHM6e3ZhbHVlOltdLHByb3BlcnRpZXM6e2RpcmVjdGlvbjp7fSxjb2xvcjp7fX19LGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzOnt2YWx1ZTpbXSxwcm9wZXJ0aWVzOntzaGFkb3dJbnRlbnNpdHk6MSxzaGFkb3dCaWFzOnt9LHNoYWRvd05vcm1hbEJpYXM6e30sc2hhZG93UmFkaXVzOnt9LHNoYWRvd01hcFNpemU6e319fSxkaXJlY3Rpb25hbFNoYWRvd01hcDp7dmFsdWU6W119LGRpcmVjdGlvbmFsU2hhZG93TWF0cml4Ont2YWx1ZTpbXX0sc3BvdExpZ2h0czp7dmFsdWU6W10scHJvcGVydGllczp7Y29sb3I6e30scG9zaXRpb246e30sZGlyZWN0aW9uOnt9LGRpc3RhbmNlOnt9LGNvbmVDb3M6e30scGVudW1icmFDb3M6e30sZGVjYXk6e319fSxzcG90TGlnaHRTaGFkb3dzOnt2YWx1ZTpbXSxwcm9wZXJ0aWVzOntzaGFkb3dJbnRlbnNpdHk6MSxzaGFkb3dCaWFzOnt9LHNoYWRvd05vcm1hbEJpYXM6e30sc2hhZG93UmFkaXVzOnt9LHNoYWRvd01hcFNpemU6e319fSxzcG90TGlnaHRNYXA6e3ZhbHVlOltdfSxzcG90U2hhZG93TWFwOnt2YWx1ZTpbXX0sc3BvdExpZ2h0TWF0cml4Ont2YWx1ZTpbXX0scG9pbnRMaWdodHM6e3ZhbHVlOltdLHByb3BlcnRpZXM6e2NvbG9yOnt9LHBvc2l0aW9uOnt9LGRlY2F5Ont9LGRpc3RhbmNlOnt9fX0scG9pbnRMaWdodFNoYWRvd3M6e3ZhbHVlOltdLHByb3BlcnRpZXM6e3NoYWRvd0ludGVuc2l0eToxLHNoYWRvd0JpYXM6e30sc2hhZG93Tm9ybWFsQmlhczp7fSxzaGFkb3dSYWRpdXM6e30sc2hhZG93TWFwU2l6ZTp7fSxzaGFkb3dDYW1lcmFOZWFyOnt9LHNoYWRvd0NhbWVyYUZhcjp7fX19LHBvaW50U2hhZG93TWFwOnt2YWx1ZTpbXX0scG9pbnRTaGFkb3dNYXRyaXg6e3ZhbHVlOltdfSxoZW1pc3BoZXJlTGlnaHRzOnt2YWx1ZTpbXSxwcm9wZXJ0aWVzOntkaXJlY3Rpb246e30sc2t5Q29sb3I6e30sZ3JvdW5kQ29sb3I6e319fSxyZWN0QXJlYUxpZ2h0czp7dmFsdWU6W10scHJvcGVydGllczp7Y29sb3I6e30scG9zaXRpb246e30sd2lkdGg6e30saGVpZ2h0Ont9fX0sbHRjXzE6e3ZhbHVlOm51bGx9LGx0Y18yOnt2YWx1ZTpudWxsfX0scG9pbnRzOntkaWZmdXNlOnt2YWx1ZTpuZXcgVmUoMTY3NzcyMTUpfSxvcGFjaXR5Ont2YWx1ZToxfSxzaXplOnt2YWx1ZToxfSxzY2FsZTp7dmFsdWU6MX0sbWFwOnt2YWx1ZTpudWxsfSxhbHBoYU1hcDp7dmFsdWU6bnVsbH0sYWxwaGFNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX0sYWxwaGFUZXN0Ont2YWx1ZTowfSx1dlRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfX0sc3ByaXRlOntkaWZmdXNlOnt2YWx1ZTpuZXcgVmUoMTY3NzcyMTUpfSxvcGFjaXR5Ont2YWx1ZToxfSxjZW50ZXI6e3ZhbHVlOm5ldyBQZSguNSwuNSl9LHJvdGF0aW9uOnt2YWx1ZTowfSxtYXA6e3ZhbHVlOm51bGx9LG1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfSxhbHBoYU1hcDp7dmFsdWU6bnVsbH0sYWxwaGFNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX0sYWxwaGFUZXN0Ont2YWx1ZTowfX19LHp0PXtiYXNpYzp7dW5pZm9ybXM6eHQoW3RlLmNvbW1vbix0ZS5zcGVjdWxhcm1hcCx0ZS5lbnZtYXAsdGUuYW9tYXAsdGUubGlnaHRtYXAsdGUuZm9nXSksdmVydGV4U2hhZGVyOkRlLm1lc2hiYXNpY192ZXJ0LGZyYWdtZW50U2hhZGVyOkRlLm1lc2hiYXNpY19mcmFnfSxsYW1iZXJ0Ont1bmlmb3Jtczp4dChbdGUuY29tbW9uLHRlLnNwZWN1bGFybWFwLHRlLmVudm1hcCx0ZS5hb21hcCx0ZS5saWdodG1hcCx0ZS5lbWlzc2l2ZW1hcCx0ZS5idW1wbWFwLHRlLm5vcm1hbG1hcCx0ZS5kaXNwbGFjZW1lbnRtYXAsdGUuZm9nLHRlLmxpZ2h0cyx7ZW1pc3NpdmU6e3ZhbHVlOm5ldyBWZSgwKX19XSksdmVydGV4U2hhZGVyOkRlLm1lc2hsYW1iZXJ0X3ZlcnQsZnJhZ21lbnRTaGFkZXI6RGUubWVzaGxhbWJlcnRfZnJhZ30scGhvbmc6e3VuaWZvcm1zOnh0KFt0ZS5jb21tb24sdGUuc3BlY3VsYXJtYXAsdGUuZW52bWFwLHRlLmFvbWFwLHRlLmxpZ2h0bWFwLHRlLmVtaXNzaXZlbWFwLHRlLmJ1bXBtYXAsdGUubm9ybWFsbWFwLHRlLmRpc3BsYWNlbWVudG1hcCx0ZS5mb2csdGUubGlnaHRzLHtlbWlzc2l2ZTp7dmFsdWU6bmV3IFZlKDApfSxzcGVjdWxhcjp7dmFsdWU6bmV3IFZlKDExMTg0ODEpfSxzaGluaW5lc3M6e3ZhbHVlOjMwfX1dKSx2ZXJ0ZXhTaGFkZXI6RGUubWVzaHBob25nX3ZlcnQsZnJhZ21lbnRTaGFkZXI6RGUubWVzaHBob25nX2ZyYWd9LHN0YW5kYXJkOnt1bmlmb3Jtczp4dChbdGUuY29tbW9uLHRlLmVudm1hcCx0ZS5hb21hcCx0ZS5saWdodG1hcCx0ZS5lbWlzc2l2ZW1hcCx0ZS5idW1wbWFwLHRlLm5vcm1hbG1hcCx0ZS5kaXNwbGFjZW1lbnRtYXAsdGUucm91Z2huZXNzbWFwLHRlLm1ldGFsbmVzc21hcCx0ZS5mb2csdGUubGlnaHRzLHtlbWlzc2l2ZTp7dmFsdWU6bmV3IFZlKDApfSxyb3VnaG5lc3M6e3ZhbHVlOjF9LG1ldGFsbmVzczp7dmFsdWU6MH0sZW52TWFwSW50ZW5zaXR5Ont2YWx1ZToxfX1dKSx2ZXJ0ZXhTaGFkZXI6RGUubWVzaHBoeXNpY2FsX3ZlcnQsZnJhZ21lbnRTaGFkZXI6RGUubWVzaHBoeXNpY2FsX2ZyYWd9LHRvb246e3VuaWZvcm1zOnh0KFt0ZS5jb21tb24sdGUuYW9tYXAsdGUubGlnaHRtYXAsdGUuZW1pc3NpdmVtYXAsdGUuYnVtcG1hcCx0ZS5ub3JtYWxtYXAsdGUuZGlzcGxhY2VtZW50bWFwLHRlLmdyYWRpZW50bWFwLHRlLmZvZyx0ZS5saWdodHMse2VtaXNzaXZlOnt2YWx1ZTpuZXcgVmUoMCl9fV0pLHZlcnRleFNoYWRlcjpEZS5tZXNodG9vbl92ZXJ0LGZyYWdtZW50U2hhZGVyOkRlLm1lc2h0b29uX2ZyYWd9LG1hdGNhcDp7dW5pZm9ybXM6eHQoW3RlLmNvbW1vbix0ZS5idW1wbWFwLHRlLm5vcm1hbG1hcCx0ZS5kaXNwbGFjZW1lbnRtYXAsdGUuZm9nLHttYXRjYXA6e3ZhbHVlOm51bGx9fV0pLHZlcnRleFNoYWRlcjpEZS5tZXNobWF0Y2FwX3ZlcnQsZnJhZ21lbnRTaGFkZXI6RGUubWVzaG1hdGNhcF9mcmFnfSxwb2ludHM6e3VuaWZvcm1zOnh0KFt0ZS5wb2ludHMsdGUuZm9nXSksdmVydGV4U2hhZGVyOkRlLnBvaW50c192ZXJ0LGZyYWdtZW50U2hhZGVyOkRlLnBvaW50c19mcmFnfSxkYXNoZWQ6e3VuaWZvcm1zOnh0KFt0ZS5jb21tb24sdGUuZm9nLHtzY2FsZTp7dmFsdWU6MX0sZGFzaFNpemU6e3ZhbHVlOjF9LHRvdGFsU2l6ZTp7dmFsdWU6Mn19XSksdmVydGV4U2hhZGVyOkRlLmxpbmVkYXNoZWRfdmVydCxmcmFnbWVudFNoYWRlcjpEZS5saW5lZGFzaGVkX2ZyYWd9LGRlcHRoOnt1bmlmb3Jtczp4dChbdGUuY29tbW9uLHRlLmRpc3BsYWNlbWVudG1hcF0pLHZlcnRleFNoYWRlcjpEZS5kZXB0aF92ZXJ0LGZyYWdtZW50U2hhZGVyOkRlLmRlcHRoX2ZyYWd9LG5vcm1hbDp7dW5pZm9ybXM6eHQoW3RlLmNvbW1vbix0ZS5idW1wbWFwLHRlLm5vcm1hbG1hcCx0ZS5kaXNwbGFjZW1lbnRtYXAse29wYWNpdHk6e3ZhbHVlOjF9fV0pLHZlcnRleFNoYWRlcjpEZS5tZXNobm9ybWFsX3ZlcnQsZnJhZ21lbnRTaGFkZXI6RGUubWVzaG5vcm1hbF9mcmFnfSxzcHJpdGU6e3VuaWZvcm1zOnh0KFt0ZS5zcHJpdGUsdGUuZm9nXSksdmVydGV4U2hhZGVyOkRlLnNwcml0ZV92ZXJ0LGZyYWdtZW50U2hhZGVyOkRlLnNwcml0ZV9mcmFnfSxiYWNrZ3JvdW5kOnt1bmlmb3Jtczp7dXZUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX0sdDJEOnt2YWx1ZTpudWxsfSxiYWNrZ3JvdW5kSW50ZW5zaXR5Ont2YWx1ZToxfX0sdmVydGV4U2hhZGVyOkRlLmJhY2tncm91bmRfdmVydCxmcmFnbWVudFNoYWRlcjpEZS5iYWNrZ3JvdW5kX2ZyYWd9LGJhY2tncm91bmRDdWJlOnt1bmlmb3Jtczp7ZW52TWFwOnt2YWx1ZTpudWxsfSxmbGlwRW52TWFwOnt2YWx1ZTotMX0sYmFja2dyb3VuZEJsdXJyaW5lc3M6e3ZhbHVlOjB9LGJhY2tncm91bmRJbnRlbnNpdHk6e3ZhbHVlOjF9LGJhY2tncm91bmRSb3RhdGlvbjp7dmFsdWU6bmV3IGJlfX0sdmVydGV4U2hhZGVyOkRlLmJhY2tncm91bmRDdWJlX3ZlcnQsZnJhZ21lbnRTaGFkZXI6RGUuYmFja2dyb3VuZEN1YmVfZnJhZ30sY3ViZTp7dW5pZm9ybXM6e3RDdWJlOnt2YWx1ZTpudWxsfSx0RmxpcDp7dmFsdWU6LTF9LG9wYWNpdHk6e3ZhbHVlOjF9fSx2ZXJ0ZXhTaGFkZXI6RGUuY3ViZV92ZXJ0LGZyYWdtZW50U2hhZGVyOkRlLmN1YmVfZnJhZ30sZXF1aXJlY3Q6e3VuaWZvcm1zOnt0RXF1aXJlY3Q6e3ZhbHVlOm51bGx9fSx2ZXJ0ZXhTaGFkZXI6RGUuZXF1aXJlY3RfdmVydCxmcmFnbWVudFNoYWRlcjpEZS5lcXVpcmVjdF9mcmFnfSxkaXN0YW5jZVJHQkE6e3VuaWZvcm1zOnh0KFt0ZS5jb21tb24sdGUuZGlzcGxhY2VtZW50bWFwLHtyZWZlcmVuY2VQb3NpdGlvbjp7dmFsdWU6bmV3IE99LG5lYXJEaXN0YW5jZTp7dmFsdWU6MX0sZmFyRGlzdGFuY2U6e3ZhbHVlOjFlM319XSksdmVydGV4U2hhZGVyOkRlLmRpc3RhbmNlUkdCQV92ZXJ0LGZyYWdtZW50U2hhZGVyOkRlLmRpc3RhbmNlUkdCQV9mcmFnfSxzaGFkb3c6e3VuaWZvcm1zOnh0KFt0ZS5saWdodHMsdGUuZm9nLHtjb2xvcjp7dmFsdWU6bmV3IFZlKDApfSxvcGFjaXR5Ont2YWx1ZToxfX1dKSx2ZXJ0ZXhTaGFkZXI6RGUuc2hhZG93X3ZlcnQsZnJhZ21lbnRTaGFkZXI6RGUuc2hhZG93X2ZyYWd9fTt6dC5waHlzaWNhbD17dW5pZm9ybXM6eHQoW3p0LnN0YW5kYXJkLnVuaWZvcm1zLHtjbGVhcmNvYXQ6e3ZhbHVlOjB9LGNsZWFyY29hdE1hcDp7dmFsdWU6bnVsbH0sY2xlYXJjb2F0TWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9LGNsZWFyY29hdE5vcm1hbE1hcDp7dmFsdWU6bnVsbH0sY2xlYXJjb2F0Tm9ybWFsTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9LGNsZWFyY29hdE5vcm1hbFNjYWxlOnt2YWx1ZTpuZXcgUGUoMSwxKX0sY2xlYXJjb2F0Um91Z2huZXNzOnt2YWx1ZTowfSxjbGVhcmNvYXRSb3VnaG5lc3NNYXA6e3ZhbHVlOm51bGx9LGNsZWFyY29hdFJvdWdobmVzc01hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfSxkaXNwZXJzaW9uOnt2YWx1ZTowfSxpcmlkZXNjZW5jZTp7dmFsdWU6MH0saXJpZGVzY2VuY2VNYXA6e3ZhbHVlOm51bGx9LGlyaWRlc2NlbmNlTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9LGlyaWRlc2NlbmNlSU9SOnt2YWx1ZToxLjN9LGlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bTp7dmFsdWU6MTAwfSxpcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW06e3ZhbHVlOjQwMH0saXJpZGVzY2VuY2VUaGlja25lc3NNYXA6e3ZhbHVlOm51bGx9LGlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9LHNoZWVuOnt2YWx1ZTowfSxzaGVlbkNvbG9yOnt2YWx1ZTpuZXcgVmUoMCl9LHNoZWVuQ29sb3JNYXA6e3ZhbHVlOm51bGx9LHNoZWVuQ29sb3JNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX0sc2hlZW5Sb3VnaG5lc3M6e3ZhbHVlOjF9LHNoZWVuUm91Z2huZXNzTWFwOnt2YWx1ZTpudWxsfSxzaGVlblJvdWdobmVzc01hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfSx0cmFuc21pc3Npb246e3ZhbHVlOjB9LHRyYW5zbWlzc2lvbk1hcDp7dmFsdWU6bnVsbH0sdHJhbnNtaXNzaW9uTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9LHRyYW5zbWlzc2lvblNhbXBsZXJTaXplOnt2YWx1ZTpuZXcgUGV9LHRyYW5zbWlzc2lvblNhbXBsZXJNYXA6e3ZhbHVlOm51bGx9LHRoaWNrbmVzczp7dmFsdWU6MH0sdGhpY2tuZXNzTWFwOnt2YWx1ZTpudWxsfSx0aGlja25lc3NNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX0sYXR0ZW51YXRpb25EaXN0YW5jZTp7dmFsdWU6MH0sYXR0ZW51YXRpb25Db2xvcjp7dmFsdWU6bmV3IFZlKDApfSxzcGVjdWxhckNvbG9yOnt2YWx1ZTpuZXcgVmUoMSwxLDEpfSxzcGVjdWxhckNvbG9yTWFwOnt2YWx1ZTpudWxsfSxzcGVjdWxhckNvbG9yTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9LHNwZWN1bGFySW50ZW5zaXR5Ont2YWx1ZToxfSxzcGVjdWxhckludGVuc2l0eU1hcDp7dmFsdWU6bnVsbH0sc3BlY3VsYXJJbnRlbnNpdHlNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX0sYW5pc290cm9weVZlY3Rvcjp7dmFsdWU6bmV3IFBlfSxhbmlzb3Ryb3B5TWFwOnt2YWx1ZTpudWxsfSxhbmlzb3Ryb3B5TWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9fV0pLHZlcnRleFNoYWRlcjpEZS5tZXNocGh5c2ljYWxfdmVydCxmcmFnbWVudFNoYWRlcjpEZS5tZXNocGh5c2ljYWxfZnJhZ307Y29uc3QgeWk9e3I6MCxiOjAsZzowfSxwbj1uZXcgWHQsemw9bmV3IHN0O2Z1bmN0aW9uIEdsKG4sZSx0LGkscixzLG8pe2NvbnN0IGE9bmV3IFZlKDApO2xldCBsPXM9PT0hMD8wOjEsYyx1LGQ9bnVsbCxmPTAscD1udWxsO2Z1bmN0aW9uIGcoVCl7bGV0IHk9VC5pc1NjZW5lPT09ITA/VC5iYWNrZ3JvdW5kOm51bGw7cmV0dXJuIHkmJnkuaXNUZXh0dXJlJiYoeT0oVC5iYWNrZ3JvdW5kQmx1cnJpbmVzcz4wP3Q6ZSkuZ2V0KHkpKSx5fWZ1bmN0aW9uIHgoVCl7bGV0IHk9ITE7Y29uc3QgXz1nKFQpO189PT1udWxsP2goYSxsKTpfJiZfLmlzQ29sb3ImJihoKF8sMSkseT0hMCk7Y29uc3QgQz1uLnhyLmdldEVudmlyb25tZW50QmxlbmRNb2RlKCk7Qz09PSJhZGRpdGl2ZSI/aS5idWZmZXJzLmNvbG9yLnNldENsZWFyKDAsMCwwLDEsbyk6Qz09PSJhbHBoYS1ibGVuZCImJmkuYnVmZmVycy5jb2xvci5zZXRDbGVhcigwLDAsMCwwLG8pLChuLmF1dG9DbGVhcnx8eSkmJihpLmJ1ZmZlcnMuZGVwdGguc2V0VGVzdCghMCksaS5idWZmZXJzLmRlcHRoLnNldE1hc2soITApLGkuYnVmZmVycy5jb2xvci5zZXRNYXNrKCEwKSxuLmNsZWFyKG4uYXV0b0NsZWFyQ29sb3Isbi5hdXRvQ2xlYXJEZXB0aCxuLmF1dG9DbGVhclN0ZW5jaWwpKX1mdW5jdGlvbiBtKFQseSl7Y29uc3QgXz1nKHkpO18mJihfLmlzQ3ViZVRleHR1cmV8fF8ubWFwcGluZz09PTMwNik/KHU9PT12b2lkIDAmJih1PW5ldyB0dChuZXcgUW4oMSwxLDEpLG5ldyBsdCh7bmFtZToiQmFja2dyb3VuZEN1YmVNYXRlcmlhbCIsdW5pZm9ybXM6Rm4oenQuYmFja2dyb3VuZEN1YmUudW5pZm9ybXMpLHZlcnRleFNoYWRlcjp6dC5iYWNrZ3JvdW5kQ3ViZS52ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXI6enQuYmFja2dyb3VuZEN1YmUuZnJhZ21lbnRTaGFkZXIsc2lkZToxLGRlcHRoVGVzdDohMSxkZXB0aFdyaXRlOiExLGZvZzohMX0pKSx1Lmdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSgibm9ybWFsIiksdS5nZW9tZXRyeS5kZWxldGVBdHRyaWJ1dGUoInV2IiksdS5vbkJlZm9yZVJlbmRlcj1mdW5jdGlvbihDLHcsYil7dGhpcy5tYXRyaXhXb3JsZC5jb3B5UG9zaXRpb24oYi5tYXRyaXhXb3JsZCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1Lm1hdGVyaWFsLCJlbnZNYXAiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5lbnZNYXAudmFsdWV9fSksci51cGRhdGUodSkpLHBuLmNvcHkoeS5iYWNrZ3JvdW5kUm90YXRpb24pLHBuLngqPS0xLHBuLnkqPS0xLHBuLnoqPS0xLF8uaXNDdWJlVGV4dHVyZSYmXy5pc1JlbmRlclRhcmdldFRleHR1cmU9PT0hMSYmKHBuLnkqPS0xLHBuLnoqPS0xKSx1Lm1hdGVyaWFsLnVuaWZvcm1zLmVudk1hcC52YWx1ZT1fLHUubWF0ZXJpYWwudW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZT1fLmlzQ3ViZVRleHR1cmUmJl8uaXNSZW5kZXJUYXJnZXRUZXh0dXJlPT09ITE/LTE6MSx1Lm1hdGVyaWFsLnVuaWZvcm1zLmJhY2tncm91bmRCbHVycmluZXNzLnZhbHVlPXkuYmFja2dyb3VuZEJsdXJyaW5lc3MsdS5tYXRlcmlhbC51bmlmb3Jtcy5iYWNrZ3JvdW5kSW50ZW5zaXR5LnZhbHVlPXkuYmFja2dyb3VuZEludGVuc2l0eSx1Lm1hdGVyaWFsLnVuaWZvcm1zLmJhY2tncm91bmRSb3RhdGlvbi52YWx1ZS5zZXRGcm9tTWF0cml4NCh6bC5tYWtlUm90YXRpb25Gcm9tRXVsZXIocG4pKSx1Lm1hdGVyaWFsLnRvbmVNYXBwZWQ9QmUuZ2V0VHJhbnNmZXIoXy5jb2xvclNwYWNlKSE9PXFlLChkIT09X3x8ZiE9PV8udmVyc2lvbnx8cCE9PW4udG9uZU1hcHBpbmcpJiYodS5tYXRlcmlhbC5uZWVkc1VwZGF0ZT0hMCxkPV8sZj1fLnZlcnNpb24scD1uLnRvbmVNYXBwaW5nKSx1LmxheWVycy5lbmFibGVBbGwoKSxULnVuc2hpZnQodSx1Lmdlb21ldHJ5LHUubWF0ZXJpYWwsMCwwLG51bGwpKTpfJiZfLmlzVGV4dHVyZSYmKGM9PT12b2lkIDAmJihjPW5ldyB0dChuZXcgZXQoMiwyKSxuZXcgbHQoe25hbWU6IkJhY2tncm91bmRNYXRlcmlhbCIsdW5pZm9ybXM6Rm4oenQuYmFja2dyb3VuZC51bmlmb3JtcyksdmVydGV4U2hhZGVyOnp0LmJhY2tncm91bmQudmVydGV4U2hhZGVyLGZyYWdtZW50U2hhZGVyOnp0LmJhY2tncm91bmQuZnJhZ21lbnRTaGFkZXIsc2lkZTowLGRlcHRoVGVzdDohMSxkZXB0aFdyaXRlOiExLGZvZzohMX0pKSxjLmdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSgibm9ybWFsIiksT2JqZWN0LmRlZmluZVByb3BlcnR5KGMubWF0ZXJpYWwsIm1hcCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLnQyRC52YWx1ZX19KSxyLnVwZGF0ZShjKSksYy5tYXRlcmlhbC51bmlmb3Jtcy50MkQudmFsdWU9XyxjLm1hdGVyaWFsLnVuaWZvcm1zLmJhY2tncm91bmRJbnRlbnNpdHkudmFsdWU9eS5iYWNrZ3JvdW5kSW50ZW5zaXR5LGMubWF0ZXJpYWwudG9uZU1hcHBlZD1CZS5nZXRUcmFuc2ZlcihfLmNvbG9yU3BhY2UpIT09cWUsXy5tYXRyaXhBdXRvVXBkYXRlPT09ITAmJl8udXBkYXRlTWF0cml4KCksYy5tYXRlcmlhbC51bmlmb3Jtcy51dlRyYW5zZm9ybS52YWx1ZS5jb3B5KF8ubWF0cml4KSwoZCE9PV98fGYhPT1fLnZlcnNpb258fHAhPT1uLnRvbmVNYXBwaW5nKSYmKGMubWF0ZXJpYWwubmVlZHNVcGRhdGU9ITAsZD1fLGY9Xy52ZXJzaW9uLHA9bi50b25lTWFwcGluZyksYy5sYXllcnMuZW5hYmxlQWxsKCksVC51bnNoaWZ0KGMsYy5nZW9tZXRyeSxjLm1hdGVyaWFsLDAsMCxudWxsKSl9ZnVuY3Rpb24gaChULHkpe1QuZ2V0UkdCKHlpLCRyKG4pKSxpLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoeWkucix5aS5nLHlpLmIseSxvKX1yZXR1cm57Z2V0Q2xlYXJDb2xvcjpmdW5jdGlvbigpe3JldHVybiBhfSxzZXRDbGVhckNvbG9yOmZ1bmN0aW9uKFQseT0xKXthLnNldChUKSxsPXksaChhLGwpfSxnZXRDbGVhckFscGhhOmZ1bmN0aW9uKCl7cmV0dXJuIGx9LHNldENsZWFyQWxwaGE6ZnVuY3Rpb24oVCl7bD1ULGgoYSxsKX0scmVuZGVyOngsYWRkVG9SZW5kZXJMaXN0Om19fWZ1bmN0aW9uIEhsKG4sZSl7Y29uc3QgdD1uLmdldFBhcmFtZXRlcihuLk1BWF9WRVJURVhfQVRUUklCUyksaT17fSxyPWYobnVsbCk7bGV0IHM9cixvPSExO2Z1bmN0aW9uIGEoUyxSLHEseixXKXtsZXQgWj0hMTtjb25zdCBWPWQoeixxLFIpO3MhPT1WJiYocz1WLGMocy5vYmplY3QpKSxaPXAoUyx6LHEsVyksWiYmZyhTLHoscSxXKSxXIT09bnVsbCYmZS51cGRhdGUoVyxuLkVMRU1FTlRfQVJSQVlfQlVGRkVSKSwoWnx8bykmJihvPSExLF8oUyxSLHEseiksVyE9PW51bGwmJm4uYmluZEJ1ZmZlcihuLkVMRU1FTlRfQVJSQVlfQlVGRkVSLGUuZ2V0KFcpLmJ1ZmZlcikpfWZ1bmN0aW9uIGwoKXtyZXR1cm4gbi5jcmVhdGVWZXJ0ZXhBcnJheSgpfWZ1bmN0aW9uIGMoUyl7cmV0dXJuIG4uYmluZFZlcnRleEFycmF5KFMpfWZ1bmN0aW9uIHUoUyl7cmV0dXJuIG4uZGVsZXRlVmVydGV4QXJyYXkoUyl9ZnVuY3Rpb24gZChTLFIscSl7Y29uc3Qgej1xLndpcmVmcmFtZT09PSEwO2xldCBXPWlbUy5pZF07Vz09PXZvaWQgMCYmKFc9e30saVtTLmlkXT1XKTtsZXQgWj1XW1IuaWRdO1o9PT12b2lkIDAmJihaPXt9LFdbUi5pZF09Wik7bGV0IFY9Wlt6XTtyZXR1cm4gVj09PXZvaWQgMCYmKFY9ZihsKCkpLFpbel09ViksVn1mdW5jdGlvbiBmKFMpe2NvbnN0IFI9W10scT1bXSx6PVtdO2ZvcihsZXQgVz0wO1c8dDtXKyspUltXXT0wLHFbV109MCx6W1ddPTA7cmV0dXJue2dlb21ldHJ5Om51bGwscHJvZ3JhbTpudWxsLHdpcmVmcmFtZTohMSxuZXdBdHRyaWJ1dGVzOlIsZW5hYmxlZEF0dHJpYnV0ZXM6cSxhdHRyaWJ1dGVEaXZpc29yczp6LG9iamVjdDpTLGF0dHJpYnV0ZXM6e30saW5kZXg6bnVsbH19ZnVuY3Rpb24gcChTLFIscSx6KXtjb25zdCBXPXMuYXR0cmlidXRlcyxaPVIuYXR0cmlidXRlcztsZXQgVj0wO2NvbnN0IFE9cS5nZXRBdHRyaWJ1dGVzKCk7Zm9yKGNvbnN0IEggaW4gUSlpZihRW0hdLmxvY2F0aW9uPj0wKXtjb25zdCBjZT1XW0hdO2xldCB4ZT1aW0hdO2lmKHhlPT09dm9pZCAwJiYoSD09PSJpbnN0YW5jZU1hdHJpeCImJlMuaW5zdGFuY2VNYXRyaXgmJih4ZT1TLmluc3RhbmNlTWF0cml4KSxIPT09Imluc3RhbmNlQ29sb3IiJiZTLmluc3RhbmNlQ29sb3ImJih4ZT1TLmluc3RhbmNlQ29sb3IpKSxjZT09PXZvaWQgMHx8Y2UuYXR0cmlidXRlIT09eGV8fHhlJiZjZS5kYXRhIT09eGUuZGF0YSlyZXR1cm4hMDtWKyt9cmV0dXJuIHMuYXR0cmlidXRlc051bSE9PVZ8fHMuaW5kZXghPT16fWZ1bmN0aW9uIGcoUyxSLHEseil7Y29uc3QgVz17fSxaPVIuYXR0cmlidXRlcztsZXQgVj0wO2NvbnN0IFE9cS5nZXRBdHRyaWJ1dGVzKCk7Zm9yKGNvbnN0IEggaW4gUSlpZihRW0hdLmxvY2F0aW9uPj0wKXtsZXQgY2U9WltIXTtjZT09PXZvaWQgMCYmKEg9PT0iaW5zdGFuY2VNYXRyaXgiJiZTLmluc3RhbmNlTWF0cml4JiYoY2U9Uy5pbnN0YW5jZU1hdHJpeCksSD09PSJpbnN0YW5jZUNvbG9yIiYmUy5pbnN0YW5jZUNvbG9yJiYoY2U9Uy5pbnN0YW5jZUNvbG9yKSk7Y29uc3QgeGU9e307eGUuYXR0cmlidXRlPWNlLGNlJiZjZS5kYXRhJiYoeGUuZGF0YT1jZS5kYXRhKSxXW0hdPXhlLFYrK31zLmF0dHJpYnV0ZXM9VyxzLmF0dHJpYnV0ZXNOdW09VixzLmluZGV4PXp9ZnVuY3Rpb24geCgpe2NvbnN0IFM9cy5uZXdBdHRyaWJ1dGVzO2ZvcihsZXQgUj0wLHE9Uy5sZW5ndGg7UjxxO1IrKylTW1JdPTB9ZnVuY3Rpb24gbShTKXtoKFMsMCl9ZnVuY3Rpb24gaChTLFIpe2NvbnN0IHE9cy5uZXdBdHRyaWJ1dGVzLHo9cy5lbmFibGVkQXR0cmlidXRlcyxXPXMuYXR0cmlidXRlRGl2aXNvcnM7cVtTXT0xLHpbU109PT0wJiYobi5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShTKSx6W1NdPTEpLFdbU10hPT1SJiYobi52ZXJ0ZXhBdHRyaWJEaXZpc29yKFMsUiksV1tTXT1SKX1mdW5jdGlvbiBUKCl7Y29uc3QgUz1zLm5ld0F0dHJpYnV0ZXMsUj1zLmVuYWJsZWRBdHRyaWJ1dGVzO2ZvcihsZXQgcT0wLHo9Ui5sZW5ndGg7cTx6O3ErKylSW3FdIT09U1txXSYmKG4uZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHEpLFJbcV09MCl9ZnVuY3Rpb24geShTLFIscSx6LFcsWixWKXtWPT09ITA/bi52ZXJ0ZXhBdHRyaWJJUG9pbnRlcihTLFIscSxXLFopOm4udmVydGV4QXR0cmliUG9pbnRlcihTLFIscSx6LFcsWil9ZnVuY3Rpb24gXyhTLFIscSx6KXt4KCk7Y29uc3QgVz16LmF0dHJpYnV0ZXMsWj1xLmdldEF0dHJpYnV0ZXMoKSxWPVIuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcztmb3IoY29uc3QgUSBpbiBaKXtjb25zdCBIPVpbUV07aWYoSC5sb2NhdGlvbj49MCl7bGV0IGllPVdbUV07aWYoaWU9PT12b2lkIDAmJihRPT09Imluc3RhbmNlTWF0cml4IiYmUy5pbnN0YW5jZU1hdHJpeCYmKGllPVMuaW5zdGFuY2VNYXRyaXgpLFE9PT0iaW5zdGFuY2VDb2xvciImJlMuaW5zdGFuY2VDb2xvciYmKGllPVMuaW5zdGFuY2VDb2xvcikpLGllIT09dm9pZCAwKXtjb25zdCBjZT1pZS5ub3JtYWxpemVkLHhlPWllLml0ZW1TaXplLFVlPWUuZ2V0KGllKTtpZihVZT09PXZvaWQgMCljb250aW51ZTtjb25zdCBZZT1VZS5idWZmZXIsWD1VZS50eXBlLGVlPVVlLmJ5dGVzUGVyRWxlbWVudCxnZT1YPT09bi5JTlR8fFg9PT1uLlVOU0lHTkVEX0lOVHx8aWUuZ3B1VHlwZT09PTEwMTM7aWYoaWUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSl7Y29uc3QgcmU9aWUuZGF0YSx5ZT1yZS5zdHJpZGUsd2U9aWUub2Zmc2V0O2lmKHJlLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIpe2ZvcihsZXQgRmU9MDtGZTxILmxvY2F0aW9uU2l6ZTtGZSsrKWgoSC5sb2NhdGlvbitGZSxyZS5tZXNoUGVyQXR0cmlidXRlKTtTLmlzSW5zdGFuY2VkTWVzaCE9PSEwJiZ6Ll9tYXhJbnN0YW5jZUNvdW50PT09dm9pZCAwJiYoei5fbWF4SW5zdGFuY2VDb3VudD1yZS5tZXNoUGVyQXR0cmlidXRlKnJlLmNvdW50KX1lbHNlIGZvcihsZXQgRmU9MDtGZTxILmxvY2F0aW9uU2l6ZTtGZSsrKW0oSC5sb2NhdGlvbitGZSk7bi5iaW5kQnVmZmVyKG4uQVJSQVlfQlVGRkVSLFllKTtmb3IobGV0IEZlPTA7RmU8SC5sb2NhdGlvblNpemU7RmUrKyl5KEgubG9jYXRpb24rRmUseGUvSC5sb2NhdGlvblNpemUsWCxjZSx5ZSplZSwod2UreGUvSC5sb2NhdGlvblNpemUqRmUpKmVlLGdlKX1lbHNle2lmKGllLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKXtmb3IobGV0IHJlPTA7cmU8SC5sb2NhdGlvblNpemU7cmUrKyloKEgubG9jYXRpb24rcmUsaWUubWVzaFBlckF0dHJpYnV0ZSk7Uy5pc0luc3RhbmNlZE1lc2ghPT0hMCYmei5fbWF4SW5zdGFuY2VDb3VudD09PXZvaWQgMCYmKHouX21heEluc3RhbmNlQ291bnQ9aWUubWVzaFBlckF0dHJpYnV0ZSppZS5jb3VudCl9ZWxzZSBmb3IobGV0IHJlPTA7cmU8SC5sb2NhdGlvblNpemU7cmUrKyltKEgubG9jYXRpb24rcmUpO24uYmluZEJ1ZmZlcihuLkFSUkFZX0JVRkZFUixZZSk7Zm9yKGxldCByZT0wO3JlPEgubG9jYXRpb25TaXplO3JlKyspeShILmxvY2F0aW9uK3JlLHhlL0gubG9jYXRpb25TaXplLFgsY2UseGUqZWUseGUvSC5sb2NhdGlvblNpemUqcmUqZWUsZ2UpfX1lbHNlIGlmKFYhPT12b2lkIDApe2NvbnN0IGNlPVZbUV07aWYoY2UhPT12b2lkIDApc3dpdGNoKGNlLmxlbmd0aCl7Y2FzZSAyOm4udmVydGV4QXR0cmliMmZ2KEgubG9jYXRpb24sY2UpO2JyZWFrO2Nhc2UgMzpuLnZlcnRleEF0dHJpYjNmdihILmxvY2F0aW9uLGNlKTticmVhaztjYXNlIDQ6bi52ZXJ0ZXhBdHRyaWI0ZnYoSC5sb2NhdGlvbixjZSk7YnJlYWs7ZGVmYXVsdDpuLnZlcnRleEF0dHJpYjFmdihILmxvY2F0aW9uLGNlKX19fX1UKCl9ZnVuY3Rpb24gQygpe0YoKTtmb3IoY29uc3QgUyBpbiBpKXtjb25zdCBSPWlbU107Zm9yKGNvbnN0IHEgaW4gUil7Y29uc3Qgej1SW3FdO2Zvcihjb25zdCBXIGluIHopdSh6W1ddLm9iamVjdCksZGVsZXRlIHpbV107ZGVsZXRlIFJbcV19ZGVsZXRlIGlbU119fWZ1bmN0aW9uIHcoUyl7aWYoaVtTLmlkXT09PXZvaWQgMClyZXR1cm47Y29uc3QgUj1pW1MuaWRdO2Zvcihjb25zdCBxIGluIFIpe2NvbnN0IHo9UltxXTtmb3IoY29uc3QgVyBpbiB6KXUoeltXXS5vYmplY3QpLGRlbGV0ZSB6W1ddO2RlbGV0ZSBSW3FdfWRlbGV0ZSBpW1MuaWRdfWZ1bmN0aW9uIGIoUyl7Zm9yKGNvbnN0IFIgaW4gaSl7Y29uc3QgcT1pW1JdO2lmKHFbUy5pZF09PT12b2lkIDApY29udGludWU7Y29uc3Qgej1xW1MuaWRdO2Zvcihjb25zdCBXIGluIHopdSh6W1ddLm9iamVjdCksZGVsZXRlIHpbV107ZGVsZXRlIHFbUy5pZF19fWZ1bmN0aW9uIEYoKXtFKCksbz0hMCxzIT09ciYmKHM9cixjKHMub2JqZWN0KSl9ZnVuY3Rpb24gRSgpe3IuZ2VvbWV0cnk9bnVsbCxyLnByb2dyYW09bnVsbCxyLndpcmVmcmFtZT0hMX1yZXR1cm57c2V0dXA6YSxyZXNldDpGLHJlc2V0RGVmYXVsdFN0YXRlOkUsZGlzcG9zZTpDLHJlbGVhc2VTdGF0ZXNPZkdlb21ldHJ5OncscmVsZWFzZVN0YXRlc09mUHJvZ3JhbTpiLGluaXRBdHRyaWJ1dGVzOngsZW5hYmxlQXR0cmlidXRlOm0sZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXM6VH19ZnVuY3Rpb24gVmwobixlLHQpe2xldCBpO2Z1bmN0aW9uIHIoYyl7aT1jfWZ1bmN0aW9uIHMoYyx1KXtuLmRyYXdBcnJheXMoaSxjLHUpLHQudXBkYXRlKHUsaSwxKX1mdW5jdGlvbiBvKGMsdSxkKXtkIT09MCYmKG4uZHJhd0FycmF5c0luc3RhbmNlZChpLGMsdSxkKSx0LnVwZGF0ZSh1LGksZCkpfWZ1bmN0aW9uIGEoYyx1LGQpe2lmKGQ9PT0wKXJldHVybjtlLmdldCgiV0VCR0xfbXVsdGlfZHJhdyIpLm11bHRpRHJhd0FycmF5c1dFQkdMKGksYywwLHUsMCxkKTtsZXQgcD0wO2ZvcihsZXQgZz0wO2c8ZDtnKyspcCs9dVtnXTt0LnVwZGF0ZShwLGksMSl9ZnVuY3Rpb24gbChjLHUsZCxmKXtpZihkPT09MClyZXR1cm47Y29uc3QgcD1lLmdldCgiV0VCR0xfbXVsdGlfZHJhdyIpO2lmKHA9PT1udWxsKWZvcihsZXQgZz0wO2c8Yy5sZW5ndGg7ZysrKW8oY1tnXSx1W2ddLGZbZ10pO2Vsc2V7cC5tdWx0aURyYXdBcnJheXNJbnN0YW5jZWRXRUJHTChpLGMsMCx1LDAsZiwwLGQpO2xldCBnPTA7Zm9yKGxldCB4PTA7eDxkO3grKylnKz11W3hdKmZbeF07dC51cGRhdGUoZyxpLDEpfX10aGlzLnNldE1vZGU9cix0aGlzLnJlbmRlcj1zLHRoaXMucmVuZGVySW5zdGFuY2VzPW8sdGhpcy5yZW5kZXJNdWx0aURyYXc9YSx0aGlzLnJlbmRlck11bHRpRHJhd0luc3RhbmNlcz1sfWZ1bmN0aW9uIGtsKG4sZSx0LGkpe2xldCByO2Z1bmN0aW9uIHMoKXtpZihyIT09dm9pZCAwKXJldHVybiByO2lmKGUuaGFzKCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMiKT09PSEwKXtjb25zdCBiPWUuZ2V0KCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMiKTtyPW4uZ2V0UGFyYW1ldGVyKGIuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKX1lbHNlIHI9MDtyZXR1cm4gcn1mdW5jdGlvbiBvKGIpe3JldHVybiEoYiE9PTEwMjMmJmkuY29udmVydChiKSE9PW4uZ2V0UGFyYW1ldGVyKG4uSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9GT1JNQVQpKX1mdW5jdGlvbiBhKGIpe2NvbnN0IEY9Yj09PTEwMTYmJihlLmhhcygiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0Iil8fGUuaGFzKCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0IikpO3JldHVybiEoYiE9PTEwMDkmJmkuY29udmVydChiKSE9PW4uZ2V0UGFyYW1ldGVyKG4uSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9UWVBFKSYmYiE9PTEwMTUmJiFGKX1mdW5jdGlvbiBsKGIpe2lmKGI9PT0iaGlnaHAiKXtpZihuLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChuLlZFUlRFWF9TSEFERVIsbi5ISUdIX0ZMT0FUKS5wcmVjaXNpb24+MCYmbi5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQobi5GUkFHTUVOVF9TSEFERVIsbi5ISUdIX0ZMT0FUKS5wcmVjaXNpb24+MClyZXR1cm4iaGlnaHAiO2I9Im1lZGl1bXAifXJldHVybiBiPT09Im1lZGl1bXAiJiZuLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChuLlZFUlRFWF9TSEFERVIsbi5NRURJVU1fRkxPQVQpLnByZWNpc2lvbj4wJiZuLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChuLkZSQUdNRU5UX1NIQURFUixuLk1FRElVTV9GTE9BVCkucHJlY2lzaW9uPjA/Im1lZGl1bXAiOiJsb3dwIn1sZXQgYz10LnByZWNpc2lvbiE9PXZvaWQgMD90LnByZWNpc2lvbjoiaGlnaHAiO2NvbnN0IHU9bChjKTt1IT09YyYmKGNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjoiLGMsIm5vdCBzdXBwb3J0ZWQsIHVzaW5nIix1LCJpbnN0ZWFkLiIpLGM9dSk7Y29uc3QgZD10LmxvZ2FyaXRobWljRGVwdGhCdWZmZXI9PT0hMCxmPXQucmV2ZXJzZURlcHRoQnVmZmVyPT09ITAmJmUuaGFzKCJFWFRfY2xpcF9jb250cm9sIikscD1uLmdldFBhcmFtZXRlcihuLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKSxnPW4uZ2V0UGFyYW1ldGVyKG4uTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTKSx4PW4uZ2V0UGFyYW1ldGVyKG4uTUFYX1RFWFRVUkVfU0laRSksbT1uLmdldFBhcmFtZXRlcihuLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUpLGg9bi5nZXRQYXJhbWV0ZXIobi5NQVhfVkVSVEVYX0FUVFJJQlMpLFQ9bi5nZXRQYXJhbWV0ZXIobi5NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUykseT1uLmdldFBhcmFtZXRlcihuLk1BWF9WQVJZSU5HX1ZFQ1RPUlMpLF89bi5nZXRQYXJhbWV0ZXIobi5NQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTKSxDPWc+MCx3PW4uZ2V0UGFyYW1ldGVyKG4uTUFYX1NBTVBMRVMpO3JldHVybntpc1dlYkdMMjohMCxnZXRNYXhBbmlzb3Ryb3B5OnMsZ2V0TWF4UHJlY2lzaW9uOmwsdGV4dHVyZUZvcm1hdFJlYWRhYmxlOm8sdGV4dHVyZVR5cGVSZWFkYWJsZTphLHByZWNpc2lvbjpjLGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6ZCxyZXZlcnNlRGVwdGhCdWZmZXI6ZixtYXhUZXh0dXJlczpwLG1heFZlcnRleFRleHR1cmVzOmcsbWF4VGV4dHVyZVNpemU6eCxtYXhDdWJlbWFwU2l6ZTptLG1heEF0dHJpYnV0ZXM6aCxtYXhWZXJ0ZXhVbmlmb3JtczpULG1heFZhcnlpbmdzOnksbWF4RnJhZ21lbnRVbmlmb3JtczpfLHZlcnRleFRleHR1cmVzOkMsbWF4U2FtcGxlczp3fX1mdW5jdGlvbiBXbChuKXtjb25zdCBlPXRoaXM7bGV0IHQ9bnVsbCxpPTAscj0hMSxzPSExO2NvbnN0IG89bmV3IGRuLGE9bmV3IGJlLGw9e3ZhbHVlOm51bGwsbmVlZHNVcGRhdGU6ITF9O3RoaXMudW5pZm9ybT1sLHRoaXMubnVtUGxhbmVzPTAsdGhpcy5udW1JbnRlcnNlY3Rpb249MCx0aGlzLmluaXQ9ZnVuY3Rpb24oZCxmKXtjb25zdCBwPWQubGVuZ3RoIT09MHx8Znx8aSE9PTB8fHI7cmV0dXJuIHI9ZixpPWQubGVuZ3RoLHB9LHRoaXMuYmVnaW5TaGFkb3dzPWZ1bmN0aW9uKCl7cz0hMCx1KG51bGwpfSx0aGlzLmVuZFNoYWRvd3M9ZnVuY3Rpb24oKXtzPSExfSx0aGlzLnNldEdsb2JhbFN0YXRlPWZ1bmN0aW9uKGQsZil7dD11KGQsZiwwKX0sdGhpcy5zZXRTdGF0ZT1mdW5jdGlvbihkLGYscCl7Y29uc3QgZz1kLmNsaXBwaW5nUGxhbmVzLHg9ZC5jbGlwSW50ZXJzZWN0aW9uLG09ZC5jbGlwU2hhZG93cyxoPW4uZ2V0KGQpO2lmKCFyfHxnPT09bnVsbHx8Zy5sZW5ndGg9PT0wfHxzJiYhbSlzP3UobnVsbCk6YygpO2Vsc2V7Y29uc3QgVD1zPzA6aSx5PVQqNDtsZXQgXz1oLmNsaXBwaW5nU3RhdGV8fG51bGw7bC52YWx1ZT1fLF89dShnLGYseSxwKTtmb3IobGV0IEM9MDtDIT09eTsrK0MpX1tDXT10W0NdO2guY2xpcHBpbmdTdGF0ZT1fLHRoaXMubnVtSW50ZXJzZWN0aW9uPXg/dGhpcy5udW1QbGFuZXM6MCx0aGlzLm51bVBsYW5lcys9VH19O2Z1bmN0aW9uIGMoKXtsLnZhbHVlIT09dCYmKGwudmFsdWU9dCxsLm5lZWRzVXBkYXRlPWk+MCksZS5udW1QbGFuZXM9aSxlLm51bUludGVyc2VjdGlvbj0wfWZ1bmN0aW9uIHUoZCxmLHAsZyl7Y29uc3QgeD1kIT09bnVsbD9kLmxlbmd0aDowO2xldCBtPW51bGw7aWYoeCE9PTApe2lmKG09bC52YWx1ZSxnIT09ITB8fG09PT1udWxsKXtjb25zdCBoPXAreCo0LFQ9Zi5tYXRyaXhXb3JsZEludmVyc2U7YS5nZXROb3JtYWxNYXRyaXgoVCksKG09PT1udWxsfHxtLmxlbmd0aDxoKSYmKG09bmV3IEZsb2F0MzJBcnJheShoKSk7Zm9yKGxldCB5PTAsXz1wO3khPT14OysreSxfKz00KW8uY29weShkW3ldKS5hcHBseU1hdHJpeDQoVCxhKSxvLm5vcm1hbC50b0FycmF5KG0sXyksbVtfKzNdPW8uY29uc3RhbnR9bC52YWx1ZT1tLGwubmVlZHNVcGRhdGU9ITB9cmV0dXJuIGUubnVtUGxhbmVzPXgsZS5udW1JbnRlcnNlY3Rpb249MCxtfX1mdW5jdGlvbiBYbChuKXtsZXQgZT1uZXcgV2Vha01hcDtmdW5jdGlvbiB0KG8sYSl7cmV0dXJuIGE9PT0zMDM/by5tYXBwaW5nPTMwMTphPT09MzA0JiYoby5tYXBwaW5nPTMwMiksb31mdW5jdGlvbiBpKG8pe2lmKG8mJm8uaXNUZXh0dXJlKXtjb25zdCBhPW8ubWFwcGluZztpZihhPT09MzAzfHxhPT09MzA0KWlmKGUuaGFzKG8pKXtjb25zdCBsPWUuZ2V0KG8pLnRleHR1cmU7cmV0dXJuIHQobCxvLm1hcHBpbmcpfWVsc2V7Y29uc3QgbD1vLmltYWdlO2lmKGwmJmwuaGVpZ2h0PjApe2NvbnN0IGM9bmV3IElhKGwuaGVpZ2h0KTtyZXR1cm4gYy5mcm9tRXF1aXJlY3Rhbmd1bGFyVGV4dHVyZShuLG8pLGUuc2V0KG8sYyksby5hZGRFdmVudExpc3RlbmVyKCJkaXNwb3NlIixyKSx0KGMudGV4dHVyZSxvLm1hcHBpbmcpfWVsc2UgcmV0dXJuIG51bGx9fXJldHVybiBvfWZ1bmN0aW9uIHIobyl7Y29uc3QgYT1vLnRhcmdldDthLnJlbW92ZUV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLHIpO2NvbnN0IGw9ZS5nZXQoYSk7bCE9PXZvaWQgMCYmKGUuZGVsZXRlKGEpLGwuZGlzcG9zZSgpKX1mdW5jdGlvbiBzKCl7ZT1uZXcgV2Vha01hcH1yZXR1cm57Z2V0OmksZGlzcG9zZTpzfX1jbGFzcyByciBleHRlbmRzIEtye2NvbnN0cnVjdG9yKGU9LTEsdD0xLGk9MSxyPS0xLHM9LjEsbz0yZTMpe3N1cGVyKCksdGhpcy5pc09ydGhvZ3JhcGhpY0NhbWVyYT0hMCx0aGlzLnR5cGU9Ik9ydGhvZ3JhcGhpY0NhbWVyYSIsdGhpcy56b29tPTEsdGhpcy52aWV3PW51bGwsdGhpcy5sZWZ0PWUsdGhpcy5yaWdodD10LHRoaXMudG9wPWksdGhpcy5ib3R0b209cix0aGlzLm5lYXI9cyx0aGlzLmZhcj1vLHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfWNvcHkoZSx0KXtyZXR1cm4gc3VwZXIuY29weShlLHQpLHRoaXMubGVmdD1lLmxlZnQsdGhpcy5yaWdodD1lLnJpZ2h0LHRoaXMudG9wPWUudG9wLHRoaXMuYm90dG9tPWUuYm90dG9tLHRoaXMubmVhcj1lLm5lYXIsdGhpcy5mYXI9ZS5mYXIsdGhpcy56b29tPWUuem9vbSx0aGlzLnZpZXc9ZS52aWV3PT09bnVsbD9udWxsOk9iamVjdC5hc3NpZ24oe30sZS52aWV3KSx0aGlzfXNldFZpZXdPZmZzZXQoZSx0LGkscixzLG8pe3RoaXMudmlldz09PW51bGwmJih0aGlzLnZpZXc9e2VuYWJsZWQ6ITAsZnVsbFdpZHRoOjEsZnVsbEhlaWdodDoxLG9mZnNldFg6MCxvZmZzZXRZOjAsd2lkdGg6MSxoZWlnaHQ6MX0pLHRoaXMudmlldy5lbmFibGVkPSEwLHRoaXMudmlldy5mdWxsV2lkdGg9ZSx0aGlzLnZpZXcuZnVsbEhlaWdodD10LHRoaXMudmlldy5vZmZzZXRYPWksdGhpcy52aWV3Lm9mZnNldFk9cix0aGlzLnZpZXcud2lkdGg9cyx0aGlzLnZpZXcuaGVpZ2h0PW8sdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9Y2xlYXJWaWV3T2Zmc2V0KCl7dGhpcy52aWV3IT09bnVsbCYmKHRoaXMudmlldy5lbmFibGVkPSExKSx0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX11cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl7Y29uc3QgZT0odGhpcy5yaWdodC10aGlzLmxlZnQpLygyKnRoaXMuem9vbSksdD0odGhpcy50b3AtdGhpcy5ib3R0b20pLygyKnRoaXMuem9vbSksaT0odGhpcy5yaWdodCt0aGlzLmxlZnQpLzIscj0odGhpcy50b3ArdGhpcy5ib3R0b20pLzI7bGV0IHM9aS1lLG89aStlLGE9cit0LGw9ci10O2lmKHRoaXMudmlldyE9PW51bGwmJnRoaXMudmlldy5lbmFibGVkKXtjb25zdCBjPSh0aGlzLnJpZ2h0LXRoaXMubGVmdCkvdGhpcy52aWV3LmZ1bGxXaWR0aC90aGlzLnpvb20sdT0odGhpcy50b3AtdGhpcy5ib3R0b20pL3RoaXMudmlldy5mdWxsSGVpZ2h0L3RoaXMuem9vbTtzKz1jKnRoaXMudmlldy5vZmZzZXRYLG89cytjKnRoaXMudmlldy53aWR0aCxhLT11KnRoaXMudmlldy5vZmZzZXRZLGw9YS11KnRoaXMudmlldy5oZWlnaHR9dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VPcnRob2dyYXBoaWMocyxvLGEsbCx0aGlzLm5lYXIsdGhpcy5mYXIsdGhpcy5jb29yZGluYXRlU3lzdGVtKSx0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkodGhpcy5wcm9qZWN0aW9uTWF0cml4KS5pbnZlcnQoKX10b0pTT04oZSl7Y29uc3QgdD1zdXBlci50b0pTT04oZSk7cmV0dXJuIHQub2JqZWN0Lnpvb209dGhpcy56b29tLHQub2JqZWN0LmxlZnQ9dGhpcy5sZWZ0LHQub2JqZWN0LnJpZ2h0PXRoaXMucmlnaHQsdC5vYmplY3QudG9wPXRoaXMudG9wLHQub2JqZWN0LmJvdHRvbT10aGlzLmJvdHRvbSx0Lm9iamVjdC5uZWFyPXRoaXMubmVhcix0Lm9iamVjdC5mYXI9dGhpcy5mYXIsdGhpcy52aWV3IT09bnVsbCYmKHQub2JqZWN0LnZpZXc9T2JqZWN0LmFzc2lnbih7fSx0aGlzLnZpZXcpKSx0fX1jb25zdCBPbj00LHRzPVsuMTI1LC4yMTUsLjM1LC40NDYsLjUyNiwuNTgyXSxtbj0yMCxzcj1uZXcgcnIsbnM9bmV3IFZlO2xldCBhcj1udWxsLG9yPTAsbHI9MCxjcj0hMTtjb25zdCBnbj0oMStNYXRoLnNxcnQoNSkpLzIsQm49MS9nbixpcz1bbmV3IE8oLWduLEJuLDApLG5ldyBPKGduLEJuLDApLG5ldyBPKC1CbiwwLGduKSxuZXcgTyhCbiwwLGduKSxuZXcgTygwLGduLC1CbiksbmV3IE8oMCxnbixCbiksbmV3IE8oLTEsMSwtMSksbmV3IE8oMSwxLC0xKSxuZXcgTygtMSwxLDEpLG5ldyBPKDEsMSwxKV07Y2xhc3MgcnN7Y29uc3RydWN0b3IoZSl7dGhpcy5fcmVuZGVyZXI9ZSx0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldD1udWxsLHRoaXMuX2xvZE1heD0wLHRoaXMuX2N1YmVTaXplPTAsdGhpcy5fbG9kUGxhbmVzPVtdLHRoaXMuX3NpemVMb2RzPVtdLHRoaXMuX3NpZ21hcz1bXSx0aGlzLl9ibHVyTWF0ZXJpYWw9bnVsbCx0aGlzLl9jdWJlbWFwTWF0ZXJpYWw9bnVsbCx0aGlzLl9lcXVpcmVjdE1hdGVyaWFsPW51bGwsdGhpcy5fY29tcGlsZU1hdGVyaWFsKHRoaXMuX2JsdXJNYXRlcmlhbCl9ZnJvbVNjZW5lKGUsdD0wLGk9LjEscj0xMDApe2FyPXRoaXMuX3JlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpLG9yPXRoaXMuX3JlbmRlcmVyLmdldEFjdGl2ZUN1YmVGYWNlKCksbHI9dGhpcy5fcmVuZGVyZXIuZ2V0QWN0aXZlTWlwbWFwTGV2ZWwoKSxjcj10aGlzLl9yZW5kZXJlci54ci5lbmFibGVkLHRoaXMuX3JlbmRlcmVyLnhyLmVuYWJsZWQ9ITEsdGhpcy5fc2V0U2l6ZSgyNTYpO2NvbnN0IHM9dGhpcy5fYWxsb2NhdGVUYXJnZXRzKCk7cmV0dXJuIHMuZGVwdGhCdWZmZXI9ITAsdGhpcy5fc2NlbmVUb0N1YmVVVihlLGkscixzKSx0PjAmJnRoaXMuX2JsdXIocywwLDAsdCksdGhpcy5fYXBwbHlQTVJFTShzKSx0aGlzLl9jbGVhbnVwKHMpLHN9ZnJvbUVxdWlyZWN0YW5ndWxhcihlLHQ9bnVsbCl7cmV0dXJuIHRoaXMuX2Zyb21UZXh0dXJlKGUsdCl9ZnJvbUN1YmVtYXAoZSx0PW51bGwpe3JldHVybiB0aGlzLl9mcm9tVGV4dHVyZShlLHQpfWNvbXBpbGVDdWJlbWFwU2hhZGVyKCl7dGhpcy5fY3ViZW1hcE1hdGVyaWFsPT09bnVsbCYmKHRoaXMuX2N1YmVtYXBNYXRlcmlhbD1vcygpLHRoaXMuX2NvbXBpbGVNYXRlcmlhbCh0aGlzLl9jdWJlbWFwTWF0ZXJpYWwpKX1jb21waWxlRXF1aXJlY3Rhbmd1bGFyU2hhZGVyKCl7dGhpcy5fZXF1aXJlY3RNYXRlcmlhbD09PW51bGwmJih0aGlzLl9lcXVpcmVjdE1hdGVyaWFsPWFzKCksdGhpcy5fY29tcGlsZU1hdGVyaWFsKHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwpKX1kaXNwb3NlKCl7dGhpcy5fZGlzcG9zZSgpLHRoaXMuX2N1YmVtYXBNYXRlcmlhbCE9PW51bGwmJnRoaXMuX2N1YmVtYXBNYXRlcmlhbC5kaXNwb3NlKCksdGhpcy5fZXF1aXJlY3RNYXRlcmlhbCE9PW51bGwmJnRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwuZGlzcG9zZSgpfV9zZXRTaXplKGUpe3RoaXMuX2xvZE1heD1NYXRoLmZsb29yKE1hdGgubG9nMihlKSksdGhpcy5fY3ViZVNpemU9TWF0aC5wb3coMix0aGlzLl9sb2RNYXgpfV9kaXNwb3NlKCl7dGhpcy5fYmx1ck1hdGVyaWFsIT09bnVsbCYmdGhpcy5fYmx1ck1hdGVyaWFsLmRpc3Bvc2UoKSx0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCE9PW51bGwmJnRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0LmRpc3Bvc2UoKTtmb3IobGV0IGU9MDtlPHRoaXMuX2xvZFBsYW5lcy5sZW5ndGg7ZSsrKXRoaXMuX2xvZFBsYW5lc1tlXS5kaXNwb3NlKCl9X2NsZWFudXAoZSl7dGhpcy5fcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGFyLG9yLGxyKSx0aGlzLl9yZW5kZXJlci54ci5lbmFibGVkPWNyLGUuc2Npc3NvclRlc3Q9ITEsVGkoZSwwLDAsZS53aWR0aCxlLmhlaWdodCl9X2Zyb21UZXh0dXJlKGUsdCl7ZS5tYXBwaW5nPT09MzAxfHxlLm1hcHBpbmc9PT0zMDI/dGhpcy5fc2V0U2l6ZShlLmltYWdlLmxlbmd0aD09PTA/MTY6ZS5pbWFnZVswXS53aWR0aHx8ZS5pbWFnZVswXS5pbWFnZS53aWR0aCk6dGhpcy5fc2V0U2l6ZShlLmltYWdlLndpZHRoLzQpLGFyPXRoaXMuX3JlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpLG9yPXRoaXMuX3JlbmRlcmVyLmdldEFjdGl2ZUN1YmVGYWNlKCksbHI9dGhpcy5fcmVuZGVyZXIuZ2V0QWN0aXZlTWlwbWFwTGV2ZWwoKSxjcj10aGlzLl9yZW5kZXJlci54ci5lbmFibGVkLHRoaXMuX3JlbmRlcmVyLnhyLmVuYWJsZWQ9ITE7Y29uc3QgaT10fHx0aGlzLl9hbGxvY2F0ZVRhcmdldHMoKTtyZXR1cm4gdGhpcy5fdGV4dHVyZVRvQ3ViZVVWKGUsaSksdGhpcy5fYXBwbHlQTVJFTShpKSx0aGlzLl9jbGVhbnVwKGkpLGl9X2FsbG9jYXRlVGFyZ2V0cygpe2NvbnN0IGU9MypNYXRoLm1heCh0aGlzLl9jdWJlU2l6ZSwxMTIpLHQ9NCp0aGlzLl9jdWJlU2l6ZSxpPXttYWdGaWx0ZXI6MTAwNixtaW5GaWx0ZXI6MTAwNixnZW5lcmF0ZU1pcG1hcHM6ITEsdHlwZToxMDE2LGZvcm1hdDoxMDIzLGNvbG9yU3BhY2U6eG4sZGVwdGhCdWZmZXI6ITF9LHI9c3MoZSx0LGkpO2lmKHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0PT09bnVsbHx8dGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQud2lkdGghPT1lfHx0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldC5oZWlnaHQhPT10KXt0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCE9PW51bGwmJnRoaXMuX2Rpc3Bvc2UoKSx0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldD1zcyhlLHQsaSk7Y29uc3R7X2xvZE1heDpzfT10aGlzOyh7c2l6ZUxvZHM6dGhpcy5fc2l6ZUxvZHMsbG9kUGxhbmVzOnRoaXMuX2xvZFBsYW5lcyxzaWdtYXM6dGhpcy5fc2lnbWFzfT1xbChzKSksdGhpcy5fYmx1ck1hdGVyaWFsPVlsKHMsZSx0KX1yZXR1cm4gcn1fY29tcGlsZU1hdGVyaWFsKGUpe2NvbnN0IHQ9bmV3IHR0KHRoaXMuX2xvZFBsYW5lc1swXSxlKTt0aGlzLl9yZW5kZXJlci5jb21waWxlKHQsc3IpfV9zY2VuZVRvQ3ViZVVWKGUsdCxpLHIpe2NvbnN0IGE9bmV3IE50KDkwLDEsdCxpKSxsPVsxLC0xLDEsMSwxLDFdLGM9WzEsMSwxLC0xLC0xLC0xXSx1PXRoaXMuX3JlbmRlcmVyLGQ9dS5hdXRvQ2xlYXIsZj11LnRvbmVNYXBwaW5nO3UuZ2V0Q2xlYXJDb2xvcihucyksdS50b25lTWFwcGluZz0wLHUuYXV0b0NsZWFyPSExO2NvbnN0IHA9bmV3IGpuKHtuYW1lOiJQTVJFTS5CYWNrZ3JvdW5kIixzaWRlOjEsZGVwdGhXcml0ZTohMSxkZXB0aFRlc3Q6ITF9KSxnPW5ldyB0dChuZXcgUW4scCk7bGV0IHg9ITE7Y29uc3QgbT1lLmJhY2tncm91bmQ7bT9tLmlzQ29sb3ImJihwLmNvbG9yLmNvcHkobSksZS5iYWNrZ3JvdW5kPW51bGwseD0hMCk6KHAuY29sb3IuY29weShucykseD0hMCk7Zm9yKGxldCBoPTA7aDw2O2grKyl7Y29uc3QgVD1oJTM7VD09PTA/KGEudXAuc2V0KDAsbFtoXSwwKSxhLmxvb2tBdChjW2hdLDAsMCkpOlQ9PT0xPyhhLnVwLnNldCgwLDAsbFtoXSksYS5sb29rQXQoMCxjW2hdLDApKTooYS51cC5zZXQoMCxsW2hdLDApLGEubG9va0F0KDAsMCxjW2hdKSk7Y29uc3QgeT10aGlzLl9jdWJlU2l6ZTtUaShyLFQqeSxoPjI/eTowLHkseSksdS5zZXRSZW5kZXJUYXJnZXQocikseCYmdS5yZW5kZXIoZyxhKSx1LnJlbmRlcihlLGEpfWcuZ2VvbWV0cnkuZGlzcG9zZSgpLGcubWF0ZXJpYWwuZGlzcG9zZSgpLHUudG9uZU1hcHBpbmc9Zix1LmF1dG9DbGVhcj1kLGUuYmFja2dyb3VuZD1tfV90ZXh0dXJlVG9DdWJlVVYoZSx0KXtjb25zdCBpPXRoaXMuX3JlbmRlcmVyLHI9ZS5tYXBwaW5nPT09MzAxfHxlLm1hcHBpbmc9PT0zMDI7cj8odGhpcy5fY3ViZW1hcE1hdGVyaWFsPT09bnVsbCYmKHRoaXMuX2N1YmVtYXBNYXRlcmlhbD1vcygpKSx0aGlzLl9jdWJlbWFwTWF0ZXJpYWwudW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZT1lLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT09PSExPy0xOjEpOnRoaXMuX2VxdWlyZWN0TWF0ZXJpYWw9PT1udWxsJiYodGhpcy5fZXF1aXJlY3RNYXRlcmlhbD1hcygpKTtjb25zdCBzPXI/dGhpcy5fY3ViZW1hcE1hdGVyaWFsOnRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwsbz1uZXcgdHQodGhpcy5fbG9kUGxhbmVzWzBdLHMpLGE9cy51bmlmb3JtczthLmVudk1hcC52YWx1ZT1lO2NvbnN0IGw9dGhpcy5fY3ViZVNpemU7VGkodCwwLDAsMypsLDIqbCksaS5zZXRSZW5kZXJUYXJnZXQodCksaS5yZW5kZXIobyxzcil9X2FwcGx5UE1SRU0oZSl7Y29uc3QgdD10aGlzLl9yZW5kZXJlcixpPXQuYXV0b0NsZWFyO3QuYXV0b0NsZWFyPSExO2NvbnN0IHI9dGhpcy5fbG9kUGxhbmVzLmxlbmd0aDtmb3IobGV0IHM9MTtzPHI7cysrKXtjb25zdCBvPU1hdGguc3FydCh0aGlzLl9zaWdtYXNbc10qdGhpcy5fc2lnbWFzW3NdLXRoaXMuX3NpZ21hc1tzLTFdKnRoaXMuX3NpZ21hc1tzLTFdKSxhPWlzWyhyLXMtMSklaXMubGVuZ3RoXTt0aGlzLl9ibHVyKGUscy0xLHMsbyxhKX10LmF1dG9DbGVhcj1pfV9ibHVyKGUsdCxpLHIscyl7Y29uc3Qgbz10aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldDt0aGlzLl9oYWxmQmx1cihlLG8sdCxpLHIsImxhdGl0dWRpbmFsIixzKSx0aGlzLl9oYWxmQmx1cihvLGUsaSxpLHIsImxvbmdpdHVkaW5hbCIscyl9X2hhbGZCbHVyKGUsdCxpLHIscyxvLGEpe2NvbnN0IGw9dGhpcy5fcmVuZGVyZXIsYz10aGlzLl9ibHVyTWF0ZXJpYWw7byE9PSJsYXRpdHVkaW5hbCImJm8hPT0ibG9uZ2l0dWRpbmFsIiYmY29uc29sZS5lcnJvcigiYmx1ciBkaXJlY3Rpb24gbXVzdCBiZSBlaXRoZXIgbGF0aXR1ZGluYWwgb3IgbG9uZ2l0dWRpbmFsISIpO2NvbnN0IHU9MyxkPW5ldyB0dCh0aGlzLl9sb2RQbGFuZXNbcl0sYyksZj1jLnVuaWZvcm1zLHA9dGhpcy5fc2l6ZUxvZHNbaV0tMSxnPWlzRmluaXRlKHMpP01hdGguUEkvKDIqcCk6MipNYXRoLlBJLygyKm1uLTEpLHg9cy9nLG09aXNGaW5pdGUocyk/MStNYXRoLmZsb29yKHUqeCk6bW47bT5tbiYmY29uc29sZS53YXJuKGBzaWdtYVJhZGlhbnMsICR7c30sIGlzIHRvbyBsYXJnZSBhbmQgd2lsbCBjbGlwLCBhcyBpdCByZXF1ZXN0ZWQgJHttfSBzYW1wbGVzIHdoZW4gdGhlIG1heGltdW0gaXMgc2V0IHRvICR7bW59YCk7Y29uc3QgaD1bXTtsZXQgVD0wO2ZvcihsZXQgYj0wO2I8bW47KytiKXtjb25zdCBGPWIveCxFPU1hdGguZXhwKC1GKkYvMik7aC5wdXNoKEUpLGI9PT0wP1QrPUU6YjxtJiYoVCs9MipFKX1mb3IobGV0IGI9MDtiPGgubGVuZ3RoO2IrKyloW2JdPWhbYl0vVDtmLmVudk1hcC52YWx1ZT1lLnRleHR1cmUsZi5zYW1wbGVzLnZhbHVlPW0sZi53ZWlnaHRzLnZhbHVlPWgsZi5sYXRpdHVkaW5hbC52YWx1ZT1vPT09ImxhdGl0dWRpbmFsIixhJiYoZi5wb2xlQXhpcy52YWx1ZT1hKTtjb25zdHtfbG9kTWF4Onl9PXRoaXM7Zi5kVGhldGEudmFsdWU9ZyxmLm1pcEludC52YWx1ZT15LWk7Y29uc3QgXz10aGlzLl9zaXplTG9kc1tyXSxDPTMqXyoocj55LU9uP3IteStPbjowKSx3PTQqKHRoaXMuX2N1YmVTaXplLV8pO1RpKHQsQyx3LDMqXywyKl8pLGwuc2V0UmVuZGVyVGFyZ2V0KHQpLGwucmVuZGVyKGQsc3IpfX1mdW5jdGlvbiBxbChuKXtjb25zdCBlPVtdLHQ9W10saT1bXTtsZXQgcj1uO2NvbnN0IHM9bi1PbisxK3RzLmxlbmd0aDtmb3IobGV0IG89MDtvPHM7bysrKXtjb25zdCBhPU1hdGgucG93KDIscik7dC5wdXNoKGEpO2xldCBsPTEvYTtvPm4tT24/bD10c1tvLW4rT24tMV06bz09PTAmJihsPTApLGkucHVzaChsKTtjb25zdCBjPTEvKGEtMiksdT0tYyxkPTErYyxmPVt1LHUsZCx1LGQsZCx1LHUsZCxkLHUsZF0scD02LGc9Nix4PTMsbT0yLGg9MSxUPW5ldyBGbG9hdDMyQXJyYXkoeCpnKnApLHk9bmV3IEZsb2F0MzJBcnJheShtKmcqcCksXz1uZXcgRmxvYXQzMkFycmF5KGgqZypwKTtmb3IobGV0IHc9MDt3PHA7dysrKXtjb25zdCBiPXclMyoyLzMtMSxGPXc+Mj8wOi0xLEU9W2IsRiwwLGIrMi8zLEYsMCxiKzIvMyxGKzEsMCxiLEYsMCxiKzIvMyxGKzEsMCxiLEYrMSwwXTtULnNldChFLHgqZyp3KSx5LnNldChmLG0qZyp3KTtjb25zdCBTPVt3LHcsdyx3LHcsd107Xy5zZXQoUyxoKmcqdyl9Y29uc3QgQz1uZXcgQ3Q7Qy5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgU3QoVCx4KSksQy5zZXRBdHRyaWJ1dGUoInV2IixuZXcgU3QoeSxtKSksQy5zZXRBdHRyaWJ1dGUoImZhY2VJbmRleCIsbmV3IFN0KF8saCkpLGUucHVzaChDKSxyPk9uJiZyLS19cmV0dXJue2xvZFBsYW5lczplLHNpemVMb2RzOnQsc2lnbWFzOml9fWZ1bmN0aW9uIHNzKG4sZSx0KXtjb25zdCBpPW5ldyBKdChuLGUsdCk7cmV0dXJuIGkudGV4dHVyZS5tYXBwaW5nPTMwNixpLnRleHR1cmUubmFtZT0iUE1SRU0uY3ViZVV2IixpLnNjaXNzb3JUZXN0PSEwLGl9ZnVuY3Rpb24gVGkobixlLHQsaSxyKXtuLnZpZXdwb3J0LnNldChlLHQsaSxyKSxuLnNjaXNzb3Iuc2V0KGUsdCxpLHIpfWZ1bmN0aW9uIFlsKG4sZSx0KXtjb25zdCBpPW5ldyBGbG9hdDMyQXJyYXkobW4pLHI9bmV3IE8oMCwxLDApO3JldHVybiBuZXcgbHQoe25hbWU6IlNwaGVyaWNhbEdhdXNzaWFuQmx1ciIsZGVmaW5lczp7bjptbixDVUJFVVZfVEVYRUxfV0lEVEg6MS9lLENVQkVVVl9URVhFTF9IRUlHSFQ6MS90LENVQkVVVl9NQVhfTUlQOmAke259LjBgfSx1bmlmb3Jtczp7ZW52TWFwOnt2YWx1ZTpudWxsfSxzYW1wbGVzOnt2YWx1ZToxfSx3ZWlnaHRzOnt2YWx1ZTppfSxsYXRpdHVkaW5hbDp7dmFsdWU6ITF9LGRUaGV0YTp7dmFsdWU6MH0sbWlwSW50Ont2YWx1ZTowfSxwb2xlQXhpczp7dmFsdWU6cn19LHZlcnRleFNoYWRlcjp1cigpLGZyYWdtZW50U2hhZGVyOmAKCgkJCXByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwoJCQlwcmVjaXNpb24gbWVkaXVtcCBpbnQ7CgoJCQl2YXJ5aW5nIHZlYzMgdk91dHB1dERpcmVjdGlvbjsKCgkJCXVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDsKCQkJdW5pZm9ybSBpbnQgc2FtcGxlczsKCQkJdW5pZm9ybSBmbG9hdCB3ZWlnaHRzWyBuIF07CgkJCXVuaWZvcm0gYm9vbCBsYXRpdHVkaW5hbDsKCQkJdW5pZm9ybSBmbG9hdCBkVGhldGE7CgkJCXVuaWZvcm0gZmxvYXQgbWlwSW50OwoJCQl1bmlmb3JtIHZlYzMgcG9sZUF4aXM7CgoJCQkjZGVmaW5lIEVOVk1BUF9UWVBFX0NVQkVfVVYKCQkJI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD4KCgkJCXZlYzMgZ2V0U2FtcGxlKCBmbG9hdCB0aGV0YSwgdmVjMyBheGlzICkgewoKCQkJCWZsb2F0IGNvc1RoZXRhID0gY29zKCB0aGV0YSApOwoJCQkJLy8gUm9kcmlndWVzJyBheGlzLWFuZ2xlIHJvdGF0aW9uCgkJCQl2ZWMzIHNhbXBsZURpcmVjdGlvbiA9IHZPdXRwdXREaXJlY3Rpb24gKiBjb3NUaGV0YQoJCQkJCSsgY3Jvc3MoIGF4aXMsIHZPdXRwdXREaXJlY3Rpb24gKSAqIHNpbiggdGhldGEgKQoJCQkJCSsgYXhpcyAqIGRvdCggYXhpcywgdk91dHB1dERpcmVjdGlvbiApICogKCAxLjAgLSBjb3NUaGV0YSApOwoKCQkJCXJldHVybiBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXJlY3Rpb24sIG1pcEludCApOwoKCQkJfQoKCQkJdm9pZCBtYWluKCkgewoKCQkJCXZlYzMgYXhpcyA9IGxhdGl0dWRpbmFsID8gcG9sZUF4aXMgOiBjcm9zcyggcG9sZUF4aXMsIHZPdXRwdXREaXJlY3Rpb24gKTsKCgkJCQlpZiAoIGFsbCggZXF1YWwoIGF4aXMsIHZlYzMoIDAuMCApICkgKSApIHsKCgkJCQkJYXhpcyA9IHZlYzMoIHZPdXRwdXREaXJlY3Rpb24ueiwgMC4wLCAtIHZPdXRwdXREaXJlY3Rpb24ueCApOwoKCQkJCX0KCgkJCQlheGlzID0gbm9ybWFsaXplKCBheGlzICk7CgoJCQkJZ2xfRnJhZ0NvbG9yID0gdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7CgkJCQlnbF9GcmFnQ29sb3IucmdiICs9IHdlaWdodHNbIDAgXSAqIGdldFNhbXBsZSggMC4wLCBheGlzICk7CgoJCQkJZm9yICggaW50IGkgPSAxOyBpIDwgbjsgaSsrICkgewoKCQkJCQlpZiAoIGkgPj0gc2FtcGxlcyApIHsKCgkJCQkJCWJyZWFrOwoKCQkJCQl9CgoJCQkJCWZsb2F0IHRoZXRhID0gZFRoZXRhICogZmxvYXQoIGkgKTsKCQkJCQlnbF9GcmFnQ29sb3IucmdiICs9IHdlaWdodHNbIGkgXSAqIGdldFNhbXBsZSggLTEuMCAqIHRoZXRhLCBheGlzICk7CgkJCQkJZ2xfRnJhZ0NvbG9yLnJnYiArPSB3ZWlnaHRzWyBpIF0gKiBnZXRTYW1wbGUoIHRoZXRhLCBheGlzICk7CgoJCQkJfQoKCQkJfQoJCWAsYmxlbmRpbmc6MCxkZXB0aFRlc3Q6ITEsZGVwdGhXcml0ZTohMX0pfWZ1bmN0aW9uIGFzKCl7cmV0dXJuIG5ldyBsdCh7bmFtZToiRXF1aXJlY3Rhbmd1bGFyVG9DdWJlVVYiLHVuaWZvcm1zOntlbnZNYXA6e3ZhbHVlOm51bGx9fSx2ZXJ0ZXhTaGFkZXI6dXIoKSxmcmFnbWVudFNoYWRlcjpgCgoJCQlwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKCQkJcHJlY2lzaW9uIG1lZGl1bXAgaW50OwoKCQkJdmFyeWluZyB2ZWMzIHZPdXRwdXREaXJlY3Rpb247CgoJCQl1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7CgoJCQkjaW5jbHVkZSA8Y29tbW9uPgoKCQkJdm9pZCBtYWluKCkgewoKCQkJCXZlYzMgb3V0cHV0RGlyZWN0aW9uID0gbm9ybWFsaXplKCB2T3V0cHV0RGlyZWN0aW9uICk7CgkJCQl2ZWMyIHV2ID0gZXF1aXJlY3RVdiggb3V0cHV0RGlyZWN0aW9uICk7CgoJCQkJZ2xfRnJhZ0NvbG9yID0gdmVjNCggdGV4dHVyZTJEICggZW52TWFwLCB1diApLnJnYiwgMS4wICk7CgoJCQl9CgkJYCxibGVuZGluZzowLGRlcHRoVGVzdDohMSxkZXB0aFdyaXRlOiExfSl9ZnVuY3Rpb24gb3MoKXtyZXR1cm4gbmV3IGx0KHtuYW1lOiJDdWJlbWFwVG9DdWJlVVYiLHVuaWZvcm1zOntlbnZNYXA6e3ZhbHVlOm51bGx9LGZsaXBFbnZNYXA6e3ZhbHVlOi0xfX0sdmVydGV4U2hhZGVyOnVyKCksZnJhZ21lbnRTaGFkZXI6YAoKCQkJcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CgkJCXByZWNpc2lvbiBtZWRpdW1wIGludDsKCgkJCXVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDsKCgkJCXZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uOwoKCQkJdW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7CgoJCQl2b2lkIG1haW4oKSB7CgoJCQkJZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgdmVjMyggZmxpcEVudk1hcCAqIHZPdXRwdXREaXJlY3Rpb24ueCwgdk91dHB1dERpcmVjdGlvbi55eiApICk7CgoJCQl9CgkJYCxibGVuZGluZzowLGRlcHRoVGVzdDohMSxkZXB0aFdyaXRlOiExfSl9ZnVuY3Rpb24gdXIoKXtyZXR1cm5gCgoJCXByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwoJCXByZWNpc2lvbiBtZWRpdW1wIGludDsKCgkJYXR0cmlidXRlIGZsb2F0IGZhY2VJbmRleDsKCgkJdmFyeWluZyB2ZWMzIHZPdXRwdXREaXJlY3Rpb247CgoJCS8vIFJIIGNvb3JkaW5hdGUgc3lzdGVtOyBQTVJFTSBmYWNlLWluZGV4aW5nIGNvbnZlbnRpb24KCQl2ZWMzIGdldERpcmVjdGlvbiggdmVjMiB1diwgZmxvYXQgZmFjZSApIHsKCgkJCXV2ID0gMi4wICogdXYgLSAxLjA7CgoJCQl2ZWMzIGRpcmVjdGlvbiA9IHZlYzMoIHV2LCAxLjAgKTsKCgkJCWlmICggZmFjZSA9PSAwLjAgKSB7CgoJCQkJZGlyZWN0aW9uID0gZGlyZWN0aW9uLnp5eDsgLy8gKCAxLCB2LCB1ICkgcG9zIHgKCgkJCX0gZWxzZSBpZiAoIGZhY2UgPT0gMS4wICkgewoKCQkJCWRpcmVjdGlvbiA9IGRpcmVjdGlvbi54enk7CgkJCQlkaXJlY3Rpb24ueHogKj0gLTEuMDsgLy8gKCAtdSwgMSwgLXYgKSBwb3MgeQoKCQkJfSBlbHNlIGlmICggZmFjZSA9PSAyLjAgKSB7CgoJCQkJZGlyZWN0aW9uLnggKj0gLTEuMDsgLy8gKCAtdSwgdiwgMSApIHBvcyB6CgoJCQl9IGVsc2UgaWYgKCBmYWNlID09IDMuMCApIHsKCgkJCQlkaXJlY3Rpb24gPSBkaXJlY3Rpb24uenl4OwoJCQkJZGlyZWN0aW9uLnh6ICo9IC0xLjA7IC8vICggLTEsIHYsIC11ICkgbmVnIHgKCgkJCX0gZWxzZSBpZiAoIGZhY2UgPT0gNC4wICkgewoKCQkJCWRpcmVjdGlvbiA9IGRpcmVjdGlvbi54enk7CgkJCQlkaXJlY3Rpb24ueHkgKj0gLTEuMDsgLy8gKCAtdSwgLTEsIHYgKSBuZWcgeQoKCQkJfSBlbHNlIGlmICggZmFjZSA9PSA1LjAgKSB7CgoJCQkJZGlyZWN0aW9uLnogKj0gLTEuMDsgLy8gKCB1LCB2LCAtMSApIG5lZyB6CgoJCQl9CgoJCQlyZXR1cm4gZGlyZWN0aW9uOwoKCQl9CgoJCXZvaWQgbWFpbigpIHsKCgkJCXZPdXRwdXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oIHV2LCBmYWNlSW5kZXggKTsKCQkJZ2xfUG9zaXRpb24gPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7CgoJCX0KCWB9ZnVuY3Rpb24gJGwobil7bGV0IGU9bmV3IFdlYWtNYXAsdD1udWxsO2Z1bmN0aW9uIGkoYSl7aWYoYSYmYS5pc1RleHR1cmUpe2NvbnN0IGw9YS5tYXBwaW5nLGM9bD09PTMwM3x8bD09PTMwNCx1PWw9PT0zMDF8fGw9PT0zMDI7aWYoY3x8dSl7bGV0IGQ9ZS5nZXQoYSk7Y29uc3QgZj1kIT09dm9pZCAwP2QudGV4dHVyZS5wbXJlbVZlcnNpb246MDtpZihhLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSYmYS5wbXJlbVZlcnNpb24hPT1mKXJldHVybiB0PT09bnVsbCYmKHQ9bmV3IHJzKG4pKSxkPWM/dC5mcm9tRXF1aXJlY3Rhbmd1bGFyKGEsZCk6dC5mcm9tQ3ViZW1hcChhLGQpLGQudGV4dHVyZS5wbXJlbVZlcnNpb249YS5wbXJlbVZlcnNpb24sZS5zZXQoYSxkKSxkLnRleHR1cmU7aWYoZCE9PXZvaWQgMClyZXR1cm4gZC50ZXh0dXJlO3tjb25zdCBwPWEuaW1hZ2U7cmV0dXJuIGMmJnAmJnAuaGVpZ2h0PjB8fHUmJnAmJnIocCk/KHQ9PT1udWxsJiYodD1uZXcgcnMobikpLGQ9Yz90LmZyb21FcXVpcmVjdGFuZ3VsYXIoYSk6dC5mcm9tQ3ViZW1hcChhKSxkLnRleHR1cmUucG1yZW1WZXJzaW9uPWEucG1yZW1WZXJzaW9uLGUuc2V0KGEsZCksYS5hZGRFdmVudExpc3RlbmVyKCJkaXNwb3NlIixzKSxkLnRleHR1cmUpOm51bGx9fX1yZXR1cm4gYX1mdW5jdGlvbiByKGEpe2xldCBsPTA7Y29uc3QgYz02O2ZvcihsZXQgdT0wO3U8Yzt1KyspYVt1XSE9PXZvaWQgMCYmbCsrO3JldHVybiBsPT09Y31mdW5jdGlvbiBzKGEpe2NvbnN0IGw9YS50YXJnZXQ7bC5yZW1vdmVFdmVudExpc3RlbmVyKCJkaXNwb3NlIixzKTtjb25zdCBjPWUuZ2V0KGwpO2MhPT12b2lkIDAmJihlLmRlbGV0ZShsKSxjLmRpc3Bvc2UoKSl9ZnVuY3Rpb24gbygpe2U9bmV3IFdlYWtNYXAsdCE9PW51bGwmJih0LmRpc3Bvc2UoKSx0PW51bGwpfXJldHVybntnZXQ6aSxkaXNwb3NlOm99fWZ1bmN0aW9uIEtsKG4pe2NvbnN0IGU9e307ZnVuY3Rpb24gdChpKXtpZihlW2ldIT09dm9pZCAwKXJldHVybiBlW2ldO2xldCByO3N3aXRjaChpKXtjYXNlIldFQkdMX2RlcHRoX3RleHR1cmUiOnI9bi5nZXRFeHRlbnNpb24oIldFQkdMX2RlcHRoX3RleHR1cmUiKXx8bi5nZXRFeHRlbnNpb24oIk1PWl9XRUJHTF9kZXB0aF90ZXh0dXJlIil8fG4uZ2V0RXh0ZW5zaW9uKCJXRUJLSVRfV0VCR0xfZGVwdGhfdGV4dHVyZSIpO2JyZWFrO2Nhc2UiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljIjpyPW4uZ2V0RXh0ZW5zaW9uKCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMiKXx8bi5nZXRFeHRlbnNpb24oIk1PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMiKXx8bi5nZXRFeHRlbnNpb24oIldFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMiKTticmVhaztjYXNlIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjIjpyPW4uZ2V0RXh0ZW5zaW9uKCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YyIpfHxuLmdldEV4dGVuc2lvbigiTU9aX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjIil8fG4uZ2V0RXh0ZW5zaW9uKCJXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMiKTticmVhaztjYXNlIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YyI6cj1uLmdldEV4dGVuc2lvbigiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjIil8fG4uZ2V0RXh0ZW5zaW9uKCJXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjIik7YnJlYWs7ZGVmYXVsdDpyPW4uZ2V0RXh0ZW5zaW9uKGkpfXJldHVybiBlW2ldPXIscn1yZXR1cm57aGFzOmZ1bmN0aW9uKGkpe3JldHVybiB0KGkpIT09bnVsbH0saW5pdDpmdW5jdGlvbigpe3QoIkVYVF9jb2xvcl9idWZmZXJfZmxvYXQiKSx0KCJXRUJHTF9jbGlwX2N1bGxfZGlzdGFuY2UiKSx0KCJPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXIiKSx0KCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQiKSx0KCJXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUiKSx0KCJXRUJHTF9yZW5kZXJfc2hhcmVkX2V4cG9uZW50Iil9LGdldDpmdW5jdGlvbihpKXtjb25zdCByPXQoaSk7cmV0dXJuIHI9PT1udWxsJiZXbigiVEhSRUUuV2ViR0xSZW5kZXJlcjogIitpKyIgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQuIikscn19fWZ1bmN0aW9uIFpsKG4sZSx0LGkpe2NvbnN0IHI9e30scz1uZXcgV2Vha01hcDtmdW5jdGlvbiBvKGQpe2NvbnN0IGY9ZC50YXJnZXQ7Zi5pbmRleCE9PW51bGwmJmUucmVtb3ZlKGYuaW5kZXgpO2Zvcihjb25zdCBnIGluIGYuYXR0cmlidXRlcyllLnJlbW92ZShmLmF0dHJpYnV0ZXNbZ10pO2Zvcihjb25zdCBnIGluIGYubW9ycGhBdHRyaWJ1dGVzKXtjb25zdCB4PWYubW9ycGhBdHRyaWJ1dGVzW2ddO2ZvcihsZXQgbT0wLGg9eC5sZW5ndGg7bTxoO20rKyllLnJlbW92ZSh4W21dKX1mLnJlbW92ZUV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLG8pLGRlbGV0ZSByW2YuaWRdO2NvbnN0IHA9cy5nZXQoZik7cCYmKGUucmVtb3ZlKHApLHMuZGVsZXRlKGYpKSxpLnJlbGVhc2VTdGF0ZXNPZkdlb21ldHJ5KGYpLGYuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeT09PSEwJiZkZWxldGUgZi5fbWF4SW5zdGFuY2VDb3VudCx0Lm1lbW9yeS5nZW9tZXRyaWVzLS19ZnVuY3Rpb24gYShkLGYpe3JldHVybiByW2YuaWRdPT09ITB8fChmLmFkZEV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLG8pLHJbZi5pZF09ITAsdC5tZW1vcnkuZ2VvbWV0cmllcysrKSxmfWZ1bmN0aW9uIGwoZCl7Y29uc3QgZj1kLmF0dHJpYnV0ZXM7Zm9yKGNvbnN0IGcgaW4gZillLnVwZGF0ZShmW2ddLG4uQVJSQVlfQlVGRkVSKTtjb25zdCBwPWQubW9ycGhBdHRyaWJ1dGVzO2Zvcihjb25zdCBnIGluIHApe2NvbnN0IHg9cFtnXTtmb3IobGV0IG09MCxoPXgubGVuZ3RoO208aDttKyspZS51cGRhdGUoeFttXSxuLkFSUkFZX0JVRkZFUil9fWZ1bmN0aW9uIGMoZCl7Y29uc3QgZj1bXSxwPWQuaW5kZXgsZz1kLmF0dHJpYnV0ZXMucG9zaXRpb247bGV0IHg9MDtpZihwIT09bnVsbCl7Y29uc3QgVD1wLmFycmF5O3g9cC52ZXJzaW9uO2ZvcihsZXQgeT0wLF89VC5sZW5ndGg7eTxfO3krPTMpe2NvbnN0IEM9VFt5KzBdLHc9VFt5KzFdLGI9VFt5KzJdO2YucHVzaChDLHcsdyxiLGIsQyl9fWVsc2UgaWYoZyE9PXZvaWQgMCl7Y29uc3QgVD1nLmFycmF5O3g9Zy52ZXJzaW9uO2ZvcihsZXQgeT0wLF89VC5sZW5ndGgvMy0xO3k8Xzt5Kz0zKXtjb25zdCBDPXkrMCx3PXkrMSxiPXkrMjtmLnB1c2goQyx3LHcsYixiLEMpfX1lbHNlIHJldHVybjtjb25zdCBtPW5ldyhFcihmKT9XcjprcikoZiwxKTttLnZlcnNpb249eDtjb25zdCBoPXMuZ2V0KGQpO2gmJmUucmVtb3ZlKGgpLHMuc2V0KGQsbSl9ZnVuY3Rpb24gdShkKXtjb25zdCBmPXMuZ2V0KGQpO2lmKGYpe2NvbnN0IHA9ZC5pbmRleDtwIT09bnVsbCYmZi52ZXJzaW9uPHAudmVyc2lvbiYmYyhkKX1lbHNlIGMoZCk7cmV0dXJuIHMuZ2V0KGQpfXJldHVybntnZXQ6YSx1cGRhdGU6bCxnZXRXaXJlZnJhbWVBdHRyaWJ1dGU6dX19ZnVuY3Rpb24gamwobixlLHQpe2xldCBpO2Z1bmN0aW9uIHIoZil7aT1mfWxldCBzLG87ZnVuY3Rpb24gYShmKXtzPWYudHlwZSxvPWYuYnl0ZXNQZXJFbGVtZW50fWZ1bmN0aW9uIGwoZixwKXtuLmRyYXdFbGVtZW50cyhpLHAscyxmKm8pLHQudXBkYXRlKHAsaSwxKX1mdW5jdGlvbiBjKGYscCxnKXtnIT09MCYmKG4uZHJhd0VsZW1lbnRzSW5zdGFuY2VkKGkscCxzLGYqbyxnKSx0LnVwZGF0ZShwLGksZykpfWZ1bmN0aW9uIHUoZixwLGcpe2lmKGc9PT0wKXJldHVybjtlLmdldCgiV0VCR0xfbXVsdGlfZHJhdyIpLm11bHRpRHJhd0VsZW1lbnRzV0VCR0woaSxwLDAscyxmLDAsZyk7bGV0IG09MDtmb3IobGV0IGg9MDtoPGc7aCsrKW0rPXBbaF07dC51cGRhdGUobSxpLDEpfWZ1bmN0aW9uIGQoZixwLGcseCl7aWYoZz09PTApcmV0dXJuO2NvbnN0IG09ZS5nZXQoIldFQkdMX211bHRpX2RyYXciKTtpZihtPT09bnVsbClmb3IobGV0IGg9MDtoPGYubGVuZ3RoO2grKyljKGZbaF0vbyxwW2hdLHhbaF0pO2Vsc2V7bS5tdWx0aURyYXdFbGVtZW50c0luc3RhbmNlZFdFQkdMKGkscCwwLHMsZiwwLHgsMCxnKTtsZXQgaD0wO2ZvcihsZXQgVD0wO1Q8ZztUKyspaCs9cFtUXSp4W1RdO3QudXBkYXRlKGgsaSwxKX19dGhpcy5zZXRNb2RlPXIsdGhpcy5zZXRJbmRleD1hLHRoaXMucmVuZGVyPWwsdGhpcy5yZW5kZXJJbnN0YW5jZXM9Yyx0aGlzLnJlbmRlck11bHRpRHJhdz11LHRoaXMucmVuZGVyTXVsdGlEcmF3SW5zdGFuY2VzPWR9ZnVuY3Rpb24gSmwobil7Y29uc3QgZT17Z2VvbWV0cmllczowLHRleHR1cmVzOjB9LHQ9e2ZyYW1lOjAsY2FsbHM6MCx0cmlhbmdsZXM6MCxwb2ludHM6MCxsaW5lczowfTtmdW5jdGlvbiBpKHMsbyxhKXtzd2l0Y2godC5jYWxscysrLG8pe2Nhc2Ugbi5UUklBTkdMRVM6dC50cmlhbmdsZXMrPWEqKHMvMyk7YnJlYWs7Y2FzZSBuLkxJTkVTOnQubGluZXMrPWEqKHMvMik7YnJlYWs7Y2FzZSBuLkxJTkVfU1RSSVA6dC5saW5lcys9YSoocy0xKTticmVhaztjYXNlIG4uTElORV9MT09QOnQubGluZXMrPWEqczticmVhaztjYXNlIG4uUE9JTlRTOnQucG9pbnRzKz1hKnM7YnJlYWs7ZGVmYXVsdDpjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTEluZm86IFVua25vd24gZHJhdyBtb2RlOiIsbyk7YnJlYWt9fWZ1bmN0aW9uIHIoKXt0LmNhbGxzPTAsdC50cmlhbmdsZXM9MCx0LnBvaW50cz0wLHQubGluZXM9MH1yZXR1cm57bWVtb3J5OmUscmVuZGVyOnQscHJvZ3JhbXM6bnVsbCxhdXRvUmVzZXQ6ITAscmVzZXQ6cix1cGRhdGU6aX19ZnVuY3Rpb24gUWwobixlLHQpe2NvbnN0IGk9bmV3IFdlYWtNYXAscj1uZXcgcnQ7ZnVuY3Rpb24gcyhvLGEsbCl7Y29uc3QgYz1vLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyx1PWEubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9ufHxhLm1vcnBoQXR0cmlidXRlcy5ub3JtYWx8fGEubW9ycGhBdHRyaWJ1dGVzLmNvbG9yLGQ9dSE9PXZvaWQgMD91Lmxlbmd0aDowO2xldCBmPWkuZ2V0KGEpO2lmKGY9PT12b2lkIDB8fGYuY291bnQhPT1kKXtsZXQgRT1mdW5jdGlvbigpe2IuZGlzcG9zZSgpLGkuZGVsZXRlKGEpLGEucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsRSl9O2YhPT12b2lkIDAmJmYudGV4dHVyZS5kaXNwb3NlKCk7Y29uc3QgcD1hLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiE9PXZvaWQgMCxnPWEubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCE9PXZvaWQgMCx4PWEubW9ycGhBdHRyaWJ1dGVzLmNvbG9yIT09dm9pZCAwLG09YS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb258fFtdLGg9YS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsfHxbXSxUPWEubW9ycGhBdHRyaWJ1dGVzLmNvbG9yfHxbXTtsZXQgeT0wO3A9PT0hMCYmKHk9MSksZz09PSEwJiYoeT0yKSx4PT09ITAmJih5PTMpO2xldCBfPWEuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCp5LEM9MTtfPmUubWF4VGV4dHVyZVNpemUmJihDPU1hdGguY2VpbChfL2UubWF4VGV4dHVyZVNpemUpLF89ZS5tYXhUZXh0dXJlU2l6ZSk7Y29uc3Qgdz1uZXcgRmxvYXQzMkFycmF5KF8qQyo0KmQpLGI9bmV3IFByKHcsXyxDLGQpO2IudHlwZT0xMDE1LGIubmVlZHNVcGRhdGU9ITA7Y29uc3QgRj15KjQ7Zm9yKGxldCBTPTA7UzxkO1MrKyl7Y29uc3QgUj1tW1NdLHE9aFtTXSx6PVRbU10sVz1fKkMqNCpTO2ZvcihsZXQgWj0wO1o8Ui5jb3VudDtaKyspe2NvbnN0IFY9WipGO3A9PT0hMCYmKHIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShSLFopLHdbVytWKzBdPXIueCx3W1crVisxXT1yLnksd1tXK1YrMl09ci56LHdbVytWKzNdPTApLGc9PT0hMCYmKHIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShxLFopLHdbVytWKzRdPXIueCx3W1crVis1XT1yLnksd1tXK1YrNl09ci56LHdbVytWKzddPTApLHg9PT0hMCYmKHIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh6LFopLHdbVytWKzhdPXIueCx3W1crVis5XT1yLnksd1tXK1YrMTBdPXIueix3W1crVisxMV09ei5pdGVtU2l6ZT09PTQ/ci53OjEpfX1mPXtjb3VudDpkLHRleHR1cmU6YixzaXplOm5ldyBQZShfLEMpfSxpLnNldChhLGYpLGEuYWRkRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsRSl9aWYoby5pc0luc3RhbmNlZE1lc2g9PT0hMCYmby5tb3JwaFRleHR1cmUhPT1udWxsKWwuZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShuLCJtb3JwaFRleHR1cmUiLG8ubW9ycGhUZXh0dXJlLHQpO2Vsc2V7bGV0IHA9MDtmb3IobGV0IHg9MDt4PGMubGVuZ3RoO3grKylwKz1jW3hdO2NvbnN0IGc9YS5tb3JwaFRhcmdldHNSZWxhdGl2ZT8xOjEtcDtsLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUobiwibW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlIixnKSxsLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUobiwibW9ycGhUYXJnZXRJbmZsdWVuY2VzIixjKX1sLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUobiwibW9ycGhUYXJnZXRzVGV4dHVyZSIsZi50ZXh0dXJlLHQpLGwuZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShuLCJtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZSIsZi5zaXplKX1yZXR1cm57dXBkYXRlOnN9fWZ1bmN0aW9uIGVjKG4sZSx0LGkpe2xldCByPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIHMobCl7Y29uc3QgYz1pLnJlbmRlci5mcmFtZSx1PWwuZ2VvbWV0cnksZD1lLmdldChsLHUpO2lmKHIuZ2V0KGQpIT09YyYmKGUudXBkYXRlKGQpLHIuc2V0KGQsYykpLGwuaXNJbnN0YW5jZWRNZXNoJiYobC5oYXNFdmVudExpc3RlbmVyKCJkaXNwb3NlIixhKT09PSExJiZsLmFkZEV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLGEpLHIuZ2V0KGwpIT09YyYmKHQudXBkYXRlKGwuaW5zdGFuY2VNYXRyaXgsbi5BUlJBWV9CVUZGRVIpLGwuaW5zdGFuY2VDb2xvciE9PW51bGwmJnQudXBkYXRlKGwuaW5zdGFuY2VDb2xvcixuLkFSUkFZX0JVRkZFUiksci5zZXQobCxjKSkpLGwuaXNTa2lubmVkTWVzaCl7Y29uc3QgZj1sLnNrZWxldG9uO3IuZ2V0KGYpIT09YyYmKGYudXBkYXRlKCksci5zZXQoZixjKSl9cmV0dXJuIGR9ZnVuY3Rpb24gbygpe3I9bmV3IFdlYWtNYXB9ZnVuY3Rpb24gYShsKXtjb25zdCBjPWwudGFyZ2V0O2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsYSksdC5yZW1vdmUoYy5pbnN0YW5jZU1hdHJpeCksYy5pbnN0YW5jZUNvbG9yIT09bnVsbCYmdC5yZW1vdmUoYy5pbnN0YW5jZUNvbG9yKX1yZXR1cm57dXBkYXRlOnMsZGlzcG9zZTpvfX1jbGFzcyBscyBleHRlbmRzIHZ0e2NvbnN0cnVjdG9yKGUsdCxpLHIscyxvLGEsbCxjLHU9MTAyNil7aWYodSE9PTEwMjYmJnUhPT0xMDI3KXRocm93IG5ldyBFcnJvcigiRGVwdGhUZXh0dXJlIGZvcm1hdCBtdXN0IGJlIGVpdGhlciBUSFJFRS5EZXB0aEZvcm1hdCBvciBUSFJFRS5EZXB0aFN0ZW5jaWxGb3JtYXQiKTtpPT09dm9pZCAwJiZ1PT09MTAyNiYmKGk9MTAxNCksaT09PXZvaWQgMCYmdT09PTEwMjcmJihpPTEwMjApLHN1cGVyKG51bGwscixzLG8sYSxsLHUsaSxjKSx0aGlzLmlzRGVwdGhUZXh0dXJlPSEwLHRoaXMuaW1hZ2U9e3dpZHRoOmUsaGVpZ2h0OnR9LHRoaXMubWFnRmlsdGVyPWEhPT12b2lkIDA/YToxMDAzLHRoaXMubWluRmlsdGVyPWwhPT12b2lkIDA/bDoxMDAzLHRoaXMuZmxpcFk9ITEsdGhpcy5nZW5lcmF0ZU1pcG1hcHM9ITEsdGhpcy5jb21wYXJlRnVuY3Rpb249bnVsbH1jb3B5KGUpe3JldHVybiBzdXBlci5jb3B5KGUpLHRoaXMuY29tcGFyZUZ1bmN0aW9uPWUuY29tcGFyZUZ1bmN0aW9uLHRoaXN9dG9KU09OKGUpe2NvbnN0IHQ9c3VwZXIudG9KU09OKGUpO3JldHVybiB0aGlzLmNvbXBhcmVGdW5jdGlvbiE9PW51bGwmJih0LmNvbXBhcmVGdW5jdGlvbj10aGlzLmNvbXBhcmVGdW5jdGlvbiksdH19Y29uc3QgY3M9bmV3IHZ0LHVzPW5ldyBscygxLDEpLGhzPW5ldyBQcixkcz1uZXcgeGEsZnM9bmV3IEpyLHBzPVtdLG1zPVtdLGdzPW5ldyBGbG9hdDMyQXJyYXkoMTYpLF9zPW5ldyBGbG9hdDMyQXJyYXkoOSksdnM9bmV3IEZsb2F0MzJBcnJheSg0KTtmdW5jdGlvbiB6bihuLGUsdCl7Y29uc3QgaT1uWzBdO2lmKGk8PTB8fGk+MClyZXR1cm4gbjtjb25zdCByPWUqdDtsZXQgcz1wc1tyXTtpZihzPT09dm9pZCAwJiYocz1uZXcgRmxvYXQzMkFycmF5KHIpLHBzW3JdPXMpLGUhPT0wKXtpLnRvQXJyYXkocywwKTtmb3IobGV0IG89MSxhPTA7byE9PWU7KytvKWErPXQsbltvXS50b0FycmF5KHMsYSl9cmV0dXJuIHN9ZnVuY3Rpb24gY3QobixlKXtpZihuLmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgdD0wLGk9bi5sZW5ndGg7dDxpO3QrKylpZihuW3RdIT09ZVt0XSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiB1dChuLGUpe2ZvcihsZXQgdD0wLGk9ZS5sZW5ndGg7dDxpO3QrKyluW3RdPWVbdF19ZnVuY3Rpb24gQWkobixlKXtsZXQgdD1tc1tlXTt0PT09dm9pZCAwJiYodD1uZXcgSW50MzJBcnJheShlKSxtc1tlXT10KTtmb3IobGV0IGk9MDtpIT09ZTsrK2kpdFtpXT1uLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtyZXR1cm4gdH1mdW5jdGlvbiB0YyhuLGUpe2NvbnN0IHQ9dGhpcy5jYWNoZTt0WzBdIT09ZSYmKG4udW5pZm9ybTFmKHRoaXMuYWRkcixlKSx0WzBdPWUpfWZ1bmN0aW9uIG5jKG4sZSl7Y29uc3QgdD10aGlzLmNhY2hlO2lmKGUueCE9PXZvaWQgMCkodFswXSE9PWUueHx8dFsxXSE9PWUueSkmJihuLnVuaWZvcm0yZih0aGlzLmFkZHIsZS54LGUueSksdFswXT1lLngsdFsxXT1lLnkpO2Vsc2V7aWYoY3QodCxlKSlyZXR1cm47bi51bmlmb3JtMmZ2KHRoaXMuYWRkcixlKSx1dCh0LGUpfX1mdW5jdGlvbiBpYyhuLGUpe2NvbnN0IHQ9dGhpcy5jYWNoZTtpZihlLnghPT12b2lkIDApKHRbMF0hPT1lLnh8fHRbMV0hPT1lLnl8fHRbMl0hPT1lLnopJiYobi51bmlmb3JtM2YodGhpcy5hZGRyLGUueCxlLnksZS56KSx0WzBdPWUueCx0WzFdPWUueSx0WzJdPWUueik7ZWxzZSBpZihlLnIhPT12b2lkIDApKHRbMF0hPT1lLnJ8fHRbMV0hPT1lLmd8fHRbMl0hPT1lLmIpJiYobi51bmlmb3JtM2YodGhpcy5hZGRyLGUucixlLmcsZS5iKSx0WzBdPWUucix0WzFdPWUuZyx0WzJdPWUuYik7ZWxzZXtpZihjdCh0LGUpKXJldHVybjtuLnVuaWZvcm0zZnYodGhpcy5hZGRyLGUpLHV0KHQsZSl9fWZ1bmN0aW9uIHJjKG4sZSl7Y29uc3QgdD10aGlzLmNhY2hlO2lmKGUueCE9PXZvaWQgMCkodFswXSE9PWUueHx8dFsxXSE9PWUueXx8dFsyXSE9PWUuenx8dFszXSE9PWUudykmJihuLnVuaWZvcm00Zih0aGlzLmFkZHIsZS54LGUueSxlLnosZS53KSx0WzBdPWUueCx0WzFdPWUueSx0WzJdPWUueix0WzNdPWUudyk7ZWxzZXtpZihjdCh0LGUpKXJldHVybjtuLnVuaWZvcm00ZnYodGhpcy5hZGRyLGUpLHV0KHQsZSl9fWZ1bmN0aW9uIHNjKG4sZSl7Y29uc3QgdD10aGlzLmNhY2hlLGk9ZS5lbGVtZW50cztpZihpPT09dm9pZCAwKXtpZihjdCh0LGUpKXJldHVybjtuLnVuaWZvcm1NYXRyaXgyZnYodGhpcy5hZGRyLCExLGUpLHV0KHQsZSl9ZWxzZXtpZihjdCh0LGkpKXJldHVybjt2cy5zZXQoaSksbi51bmlmb3JtTWF0cml4MmZ2KHRoaXMuYWRkciwhMSx2cyksdXQodCxpKX19ZnVuY3Rpb24gYWMobixlKXtjb25zdCB0PXRoaXMuY2FjaGUsaT1lLmVsZW1lbnRzO2lmKGk9PT12b2lkIDApe2lmKGN0KHQsZSkpcmV0dXJuO24udW5pZm9ybU1hdHJpeDNmdih0aGlzLmFkZHIsITEsZSksdXQodCxlKX1lbHNle2lmKGN0KHQsaSkpcmV0dXJuO19zLnNldChpKSxuLnVuaWZvcm1NYXRyaXgzZnYodGhpcy5hZGRyLCExLF9zKSx1dCh0LGkpfX1mdW5jdGlvbiBvYyhuLGUpe2NvbnN0IHQ9dGhpcy5jYWNoZSxpPWUuZWxlbWVudHM7aWYoaT09PXZvaWQgMCl7aWYoY3QodCxlKSlyZXR1cm47bi51bmlmb3JtTWF0cml4NGZ2KHRoaXMuYWRkciwhMSxlKSx1dCh0LGUpfWVsc2V7aWYoY3QodCxpKSlyZXR1cm47Z3Muc2V0KGkpLG4udW5pZm9ybU1hdHJpeDRmdih0aGlzLmFkZHIsITEsZ3MpLHV0KHQsaSl9fWZ1bmN0aW9uIGxjKG4sZSl7Y29uc3QgdD10aGlzLmNhY2hlO3RbMF0hPT1lJiYobi51bmlmb3JtMWkodGhpcy5hZGRyLGUpLHRbMF09ZSl9ZnVuY3Rpb24gY2MobixlKXtjb25zdCB0PXRoaXMuY2FjaGU7aWYoZS54IT09dm9pZCAwKSh0WzBdIT09ZS54fHx0WzFdIT09ZS55KSYmKG4udW5pZm9ybTJpKHRoaXMuYWRkcixlLngsZS55KSx0WzBdPWUueCx0WzFdPWUueSk7ZWxzZXtpZihjdCh0LGUpKXJldHVybjtuLnVuaWZvcm0yaXYodGhpcy5hZGRyLGUpLHV0KHQsZSl9fWZ1bmN0aW9uIHVjKG4sZSl7Y29uc3QgdD10aGlzLmNhY2hlO2lmKGUueCE9PXZvaWQgMCkodFswXSE9PWUueHx8dFsxXSE9PWUueXx8dFsyXSE9PWUueikmJihuLnVuaWZvcm0zaSh0aGlzLmFkZHIsZS54LGUueSxlLnopLHRbMF09ZS54LHRbMV09ZS55LHRbMl09ZS56KTtlbHNle2lmKGN0KHQsZSkpcmV0dXJuO24udW5pZm9ybTNpdih0aGlzLmFkZHIsZSksdXQodCxlKX19ZnVuY3Rpb24gaGMobixlKXtjb25zdCB0PXRoaXMuY2FjaGU7aWYoZS54IT09dm9pZCAwKSh0WzBdIT09ZS54fHx0WzFdIT09ZS55fHx0WzJdIT09ZS56fHx0WzNdIT09ZS53KSYmKG4udW5pZm9ybTRpKHRoaXMuYWRkcixlLngsZS55LGUueixlLncpLHRbMF09ZS54LHRbMV09ZS55LHRbMl09ZS56LHRbM109ZS53KTtlbHNle2lmKGN0KHQsZSkpcmV0dXJuO24udW5pZm9ybTRpdih0aGlzLmFkZHIsZSksdXQodCxlKX19ZnVuY3Rpb24gZGMobixlKXtjb25zdCB0PXRoaXMuY2FjaGU7dFswXSE9PWUmJihuLnVuaWZvcm0xdWkodGhpcy5hZGRyLGUpLHRbMF09ZSl9ZnVuY3Rpb24gZmMobixlKXtjb25zdCB0PXRoaXMuY2FjaGU7aWYoZS54IT09dm9pZCAwKSh0WzBdIT09ZS54fHx0WzFdIT09ZS55KSYmKG4udW5pZm9ybTJ1aSh0aGlzLmFkZHIsZS54LGUueSksdFswXT1lLngsdFsxXT1lLnkpO2Vsc2V7aWYoY3QodCxlKSlyZXR1cm47bi51bmlmb3JtMnVpdih0aGlzLmFkZHIsZSksdXQodCxlKX19ZnVuY3Rpb24gcGMobixlKXtjb25zdCB0PXRoaXMuY2FjaGU7aWYoZS54IT09dm9pZCAwKSh0WzBdIT09ZS54fHx0WzFdIT09ZS55fHx0WzJdIT09ZS56KSYmKG4udW5pZm9ybTN1aSh0aGlzLmFkZHIsZS54LGUueSxlLnopLHRbMF09ZS54LHRbMV09ZS55LHRbMl09ZS56KTtlbHNle2lmKGN0KHQsZSkpcmV0dXJuO24udW5pZm9ybTN1aXYodGhpcy5hZGRyLGUpLHV0KHQsZSl9fWZ1bmN0aW9uIG1jKG4sZSl7Y29uc3QgdD10aGlzLmNhY2hlO2lmKGUueCE9PXZvaWQgMCkodFswXSE9PWUueHx8dFsxXSE9PWUueXx8dFsyXSE9PWUuenx8dFszXSE9PWUudykmJihuLnVuaWZvcm00dWkodGhpcy5hZGRyLGUueCxlLnksZS56LGUudyksdFswXT1lLngsdFsxXT1lLnksdFsyXT1lLnosdFszXT1lLncpO2Vsc2V7aWYoY3QodCxlKSlyZXR1cm47bi51bmlmb3JtNHVpdih0aGlzLmFkZHIsZSksdXQodCxlKX19ZnVuY3Rpb24gZ2MobixlLHQpe2NvbnN0IGk9dGhpcy5jYWNoZSxyPXQuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO2lbMF0hPT1yJiYobi51bmlmb3JtMWkodGhpcy5hZGRyLHIpLGlbMF09cik7bGV0IHM7dGhpcy50eXBlPT09bi5TQU1QTEVSXzJEX1NIQURPVz8odXMuY29tcGFyZUZ1bmN0aW9uPTUxNSxzPXVzKTpzPWNzLHQuc2V0VGV4dHVyZTJEKGV8fHMscil9ZnVuY3Rpb24gX2MobixlLHQpe2NvbnN0IGk9dGhpcy5jYWNoZSxyPXQuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO2lbMF0hPT1yJiYobi51bmlmb3JtMWkodGhpcy5hZGRyLHIpLGlbMF09ciksdC5zZXRUZXh0dXJlM0QoZXx8ZHMscil9ZnVuY3Rpb24gdmMobixlLHQpe2NvbnN0IGk9dGhpcy5jYWNoZSxyPXQuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO2lbMF0hPT1yJiYobi51bmlmb3JtMWkodGhpcy5hZGRyLHIpLGlbMF09ciksdC5zZXRUZXh0dXJlQ3ViZShlfHxmcyxyKX1mdW5jdGlvbiB4YyhuLGUsdCl7Y29uc3QgaT10aGlzLmNhY2hlLHI9dC5hbGxvY2F0ZVRleHR1cmVVbml0KCk7aVswXSE9PXImJihuLnVuaWZvcm0xaSh0aGlzLmFkZHIsciksaVswXT1yKSx0LnNldFRleHR1cmUyREFycmF5KGV8fGhzLHIpfWZ1bmN0aW9uIE1jKG4pe3N3aXRjaChuKXtjYXNlIDUxMjY6cmV0dXJuIHRjO2Nhc2UgMzU2NjQ6cmV0dXJuIG5jO2Nhc2UgMzU2NjU6cmV0dXJuIGljO2Nhc2UgMzU2NjY6cmV0dXJuIHJjO2Nhc2UgMzU2NzQ6cmV0dXJuIHNjO2Nhc2UgMzU2NzU6cmV0dXJuIGFjO2Nhc2UgMzU2NzY6cmV0dXJuIG9jO2Nhc2UgNTEyNDpjYXNlIDM1NjcwOnJldHVybiBsYztjYXNlIDM1NjY3OmNhc2UgMzU2NzE6cmV0dXJuIGNjO2Nhc2UgMzU2Njg6Y2FzZSAzNTY3MjpyZXR1cm4gdWM7Y2FzZSAzNTY2OTpjYXNlIDM1NjczOnJldHVybiBoYztjYXNlIDUxMjU6cmV0dXJuIGRjO2Nhc2UgMzYyOTQ6cmV0dXJuIGZjO2Nhc2UgMzYyOTU6cmV0dXJuIHBjO2Nhc2UgMzYyOTY6cmV0dXJuIG1jO2Nhc2UgMzU2Nzg6Y2FzZSAzNjE5ODpjYXNlIDM2Mjk4OmNhc2UgMzYzMDY6Y2FzZSAzNTY4MjpyZXR1cm4gZ2M7Y2FzZSAzNTY3OTpjYXNlIDM2Mjk5OmNhc2UgMzYzMDc6cmV0dXJuIF9jO2Nhc2UgMzU2ODA6Y2FzZSAzNjMwMDpjYXNlIDM2MzA4OmNhc2UgMzYyOTM6cmV0dXJuIHZjO2Nhc2UgMzYyODk6Y2FzZSAzNjMwMzpjYXNlIDM2MzExOmNhc2UgMzYyOTI6cmV0dXJuIHhjfX1mdW5jdGlvbiBTYyhuLGUpe24udW5pZm9ybTFmdih0aGlzLmFkZHIsZSl9ZnVuY3Rpb24gRWMobixlKXtjb25zdCB0PXpuKGUsdGhpcy5zaXplLDIpO24udW5pZm9ybTJmdih0aGlzLmFkZHIsdCl9ZnVuY3Rpb24geWMobixlKXtjb25zdCB0PXpuKGUsdGhpcy5zaXplLDMpO24udW5pZm9ybTNmdih0aGlzLmFkZHIsdCl9ZnVuY3Rpb24gVGMobixlKXtjb25zdCB0PXpuKGUsdGhpcy5zaXplLDQpO24udW5pZm9ybTRmdih0aGlzLmFkZHIsdCl9ZnVuY3Rpb24gQWMobixlKXtjb25zdCB0PXpuKGUsdGhpcy5zaXplLDQpO24udW5pZm9ybU1hdHJpeDJmdih0aGlzLmFkZHIsITEsdCl9ZnVuY3Rpb24gd2MobixlKXtjb25zdCB0PXpuKGUsdGhpcy5zaXplLDkpO24udW5pZm9ybU1hdHJpeDNmdih0aGlzLmFkZHIsITEsdCl9ZnVuY3Rpb24gYmMobixlKXtjb25zdCB0PXpuKGUsdGhpcy5zaXplLDE2KTtuLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5hZGRyLCExLHQpfWZ1bmN0aW9uIFJjKG4sZSl7bi51bmlmb3JtMWl2KHRoaXMuYWRkcixlKX1mdW5jdGlvbiBDYyhuLGUpe24udW5pZm9ybTJpdih0aGlzLmFkZHIsZSl9ZnVuY3Rpb24gUGMobixlKXtuLnVuaWZvcm0zaXYodGhpcy5hZGRyLGUpfWZ1bmN0aW9uIERjKG4sZSl7bi51bmlmb3JtNGl2KHRoaXMuYWRkcixlKX1mdW5jdGlvbiBMYyhuLGUpe24udW5pZm9ybTF1aXYodGhpcy5hZGRyLGUpfWZ1bmN0aW9uIFVjKG4sZSl7bi51bmlmb3JtMnVpdih0aGlzLmFkZHIsZSl9ZnVuY3Rpb24gRmMobixlKXtuLnVuaWZvcm0zdWl2KHRoaXMuYWRkcixlKX1mdW5jdGlvbiBJYyhuLGUpe24udW5pZm9ybTR1aXYodGhpcy5hZGRyLGUpfWZ1bmN0aW9uIE5jKG4sZSx0KXtjb25zdCBpPXRoaXMuY2FjaGUscj1lLmxlbmd0aCxzPUFpKHQscik7Y3QoaSxzKXx8KG4udW5pZm9ybTFpdih0aGlzLmFkZHIscyksdXQoaSxzKSk7Zm9yKGxldCBvPTA7byE9PXI7KytvKXQuc2V0VGV4dHVyZTJEKGVbb118fGNzLHNbb10pfWZ1bmN0aW9uIE9jKG4sZSx0KXtjb25zdCBpPXRoaXMuY2FjaGUscj1lLmxlbmd0aCxzPUFpKHQscik7Y3QoaSxzKXx8KG4udW5pZm9ybTFpdih0aGlzLmFkZHIscyksdXQoaSxzKSk7Zm9yKGxldCBvPTA7byE9PXI7KytvKXQuc2V0VGV4dHVyZTNEKGVbb118fGRzLHNbb10pfWZ1bmN0aW9uIEJjKG4sZSx0KXtjb25zdCBpPXRoaXMuY2FjaGUscj1lLmxlbmd0aCxzPUFpKHQscik7Y3QoaSxzKXx8KG4udW5pZm9ybTFpdih0aGlzLmFkZHIscyksdXQoaSxzKSk7Zm9yKGxldCBvPTA7byE9PXI7KytvKXQuc2V0VGV4dHVyZUN1YmUoZVtvXXx8ZnMsc1tvXSl9ZnVuY3Rpb24gemMobixlLHQpe2NvbnN0IGk9dGhpcy5jYWNoZSxyPWUubGVuZ3RoLHM9QWkodCxyKTtjdChpLHMpfHwobi51bmlmb3JtMWl2KHRoaXMuYWRkcixzKSx1dChpLHMpKTtmb3IobGV0IG89MDtvIT09cjsrK28pdC5zZXRUZXh0dXJlMkRBcnJheShlW29dfHxocyxzW29dKX1mdW5jdGlvbiBHYyhuKXtzd2l0Y2gobil7Y2FzZSA1MTI2OnJldHVybiBTYztjYXNlIDM1NjY0OnJldHVybiBFYztjYXNlIDM1NjY1OnJldHVybiB5YztjYXNlIDM1NjY2OnJldHVybiBUYztjYXNlIDM1Njc0OnJldHVybiBBYztjYXNlIDM1Njc1OnJldHVybiB3YztjYXNlIDM1Njc2OnJldHVybiBiYztjYXNlIDUxMjQ6Y2FzZSAzNTY3MDpyZXR1cm4gUmM7Y2FzZSAzNTY2NzpjYXNlIDM1NjcxOnJldHVybiBDYztjYXNlIDM1NjY4OmNhc2UgMzU2NzI6cmV0dXJuIFBjO2Nhc2UgMzU2Njk6Y2FzZSAzNTY3MzpyZXR1cm4gRGM7Y2FzZSA1MTI1OnJldHVybiBMYztjYXNlIDM2Mjk0OnJldHVybiBVYztjYXNlIDM2Mjk1OnJldHVybiBGYztjYXNlIDM2Mjk2OnJldHVybiBJYztjYXNlIDM1Njc4OmNhc2UgMzYxOTg6Y2FzZSAzNjI5ODpjYXNlIDM2MzA2OmNhc2UgMzU2ODI6cmV0dXJuIE5jO2Nhc2UgMzU2Nzk6Y2FzZSAzNjI5OTpjYXNlIDM2MzA3OnJldHVybiBPYztjYXNlIDM1NjgwOmNhc2UgMzYzMDA6Y2FzZSAzNjMwODpjYXNlIDM2MjkzOnJldHVybiBCYztjYXNlIDM2Mjg5OmNhc2UgMzYzMDM6Y2FzZSAzNjMxMTpjYXNlIDM2MjkyOnJldHVybiB6Y319Y2xhc3MgSGN7Y29uc3RydWN0b3IoZSx0LGkpe3RoaXMuaWQ9ZSx0aGlzLmFkZHI9aSx0aGlzLmNhY2hlPVtdLHRoaXMudHlwZT10LnR5cGUsdGhpcy5zZXRWYWx1ZT1NYyh0LnR5cGUpfX1jbGFzcyBWY3tjb25zdHJ1Y3RvcihlLHQsaSl7dGhpcy5pZD1lLHRoaXMuYWRkcj1pLHRoaXMuY2FjaGU9W10sdGhpcy50eXBlPXQudHlwZSx0aGlzLnNpemU9dC5zaXplLHRoaXMuc2V0VmFsdWU9R2ModC50eXBlKX19Y2xhc3Mga2N7Y29uc3RydWN0b3IoZSl7dGhpcy5pZD1lLHRoaXMuc2VxPVtdLHRoaXMubWFwPXt9fXNldFZhbHVlKGUsdCxpKXtjb25zdCByPXRoaXMuc2VxO2ZvcihsZXQgcz0wLG89ci5sZW5ndGg7cyE9PW87KytzKXtjb25zdCBhPXJbc107YS5zZXRWYWx1ZShlLHRbYS5pZF0saSl9fX1jb25zdCBocj0vKFx3KykoXF0pPyhcW3xcLik/L2c7ZnVuY3Rpb24geHMobixlKXtuLnNlcS5wdXNoKGUpLG4ubWFwW2UuaWRdPWV9ZnVuY3Rpb24gV2MobixlLHQpe2NvbnN0IGk9bi5uYW1lLHI9aS5sZW5ndGg7Zm9yKGhyLmxhc3RJbmRleD0wOzspe2NvbnN0IHM9aHIuZXhlYyhpKSxvPWhyLmxhc3RJbmRleDtsZXQgYT1zWzFdO2NvbnN0IGw9c1syXT09PSJdIixjPXNbM107aWYobCYmKGE9YXwwKSxjPT09dm9pZCAwfHxjPT09IlsiJiZvKzI9PT1yKXt4cyh0LGM9PT12b2lkIDA/bmV3IEhjKGEsbixlKTpuZXcgVmMoYSxuLGUpKTticmVha31lbHNle2xldCBkPXQubWFwW2FdO2Q9PT12b2lkIDAmJihkPW5ldyBrYyhhKSx4cyh0LGQpKSx0PWR9fX1jbGFzcyB3aXtjb25zdHJ1Y3RvcihlLHQpe3RoaXMuc2VxPVtdLHRoaXMubWFwPXt9O2NvbnN0IGk9ZS5nZXRQcm9ncmFtUGFyYW1ldGVyKHQsZS5BQ1RJVkVfVU5JRk9STVMpO2ZvcihsZXQgcj0wO3I8aTsrK3Ipe2NvbnN0IHM9ZS5nZXRBY3RpdmVVbmlmb3JtKHQsciksbz1lLmdldFVuaWZvcm1Mb2NhdGlvbih0LHMubmFtZSk7V2MocyxvLHRoaXMpfX1zZXRWYWx1ZShlLHQsaSxyKXtjb25zdCBzPXRoaXMubWFwW3RdO3MhPT12b2lkIDAmJnMuc2V0VmFsdWUoZSxpLHIpfXNldE9wdGlvbmFsKGUsdCxpKXtjb25zdCByPXRbaV07ciE9PXZvaWQgMCYmdGhpcy5zZXRWYWx1ZShlLGkscil9c3RhdGljIHVwbG9hZChlLHQsaSxyKXtmb3IobGV0IHM9MCxvPXQubGVuZ3RoO3MhPT1vOysrcyl7Y29uc3QgYT10W3NdLGw9aVthLmlkXTtsLm5lZWRzVXBkYXRlIT09ITEmJmEuc2V0VmFsdWUoZSxsLnZhbHVlLHIpfX1zdGF0aWMgc2VxV2l0aFZhbHVlKGUsdCl7Y29uc3QgaT1bXTtmb3IobGV0IHI9MCxzPWUubGVuZ3RoO3IhPT1zOysrcil7Y29uc3Qgbz1lW3JdO28uaWQgaW4gdCYmaS5wdXNoKG8pfXJldHVybiBpfX1mdW5jdGlvbiBNcyhuLGUsdCl7Y29uc3QgaT1uLmNyZWF0ZVNoYWRlcihlKTtyZXR1cm4gbi5zaGFkZXJTb3VyY2UoaSx0KSxuLmNvbXBpbGVTaGFkZXIoaSksaX1jb25zdCBYYz0zNzI5NztsZXQgcWM9MDtmdW5jdGlvbiBZYyhuLGUpe2NvbnN0IHQ9bi5zcGxpdChgCmApLGk9W10scj1NYXRoLm1heChlLTYsMCkscz1NYXRoLm1pbihlKzYsdC5sZW5ndGgpO2ZvcihsZXQgbz1yO288cztvKyspe2NvbnN0IGE9bysxO2kucHVzaChgJHthPT09ZT8iPiI6IiAifSAke2F9OiAke3Rbb119YCl9cmV0dXJuIGkuam9pbihgCmApfWNvbnN0IFNzPW5ldyBiZTtmdW5jdGlvbiAkYyhuKXtCZS5fZ2V0TWF0cml4KFNzLEJlLndvcmtpbmdDb2xvclNwYWNlLG4pO2NvbnN0IGU9YG1hdDMoICR7U3MuZWxlbWVudHMubWFwKHQ9PnQudG9GaXhlZCg0KSl9IClgO3N3aXRjaChCZS5nZXRUcmFuc2ZlcihuKSl7Y2FzZSBpaTpyZXR1cm5bZSwiTGluZWFyVHJhbnNmZXJPRVRGIl07Y2FzZSBxZTpyZXR1cm5bZSwic1JHQlRyYW5zZmVyT0VURiJdO2RlZmF1bHQ6cmV0dXJuIGNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xQcm9ncmFtOiBVbnN1cHBvcnRlZCBjb2xvciBzcGFjZTogIixuKSxbZSwiTGluZWFyVHJhbnNmZXJPRVRGIl19fWZ1bmN0aW9uIEVzKG4sZSx0KXtjb25zdCBpPW4uZ2V0U2hhZGVyUGFyYW1ldGVyKGUsbi5DT01QSUxFX1NUQVRVUykscj1uLmdldFNoYWRlckluZm9Mb2coZSkudHJpbSgpO2lmKGkmJnI9PT0iIilyZXR1cm4iIjtjb25zdCBzPS9FUlJPUjogMDooXGQrKS8uZXhlYyhyKTtpZihzKXtjb25zdCBvPXBhcnNlSW50KHNbMV0pO3JldHVybiB0LnRvVXBwZXJDYXNlKCkrYAoKYCtyK2AKCmArWWMobi5nZXRTaGFkZXJTb3VyY2UoZSksbyl9ZWxzZSByZXR1cm4gcn1mdW5jdGlvbiBLYyhuLGUpe2NvbnN0IHQ9JGMoZSk7cmV0dXJuW2B2ZWM0ICR7bn0oIHZlYzQgdmFsdWUgKSB7YCxgCXJldHVybiAke3RbMV19KCB2ZWM0KCB2YWx1ZS5yZ2IgKiAke3RbMF19LCB2YWx1ZS5hICkgKTtgLCJ9Il0uam9pbihgCmApfWZ1bmN0aW9uIFpjKG4sZSl7bGV0IHQ7c3dpdGNoKGUpe2Nhc2UgMTp0PSJMaW5lYXIiO2JyZWFrO2Nhc2UgMjp0PSJSZWluaGFyZCI7YnJlYWs7Y2FzZSAzOnQ9IkNpbmVvbiI7YnJlYWs7Y2FzZSA0OnQ9IkFDRVNGaWxtaWMiO2JyZWFrO2Nhc2UgNjp0PSJBZ1giO2JyZWFrO2Nhc2UgNzp0PSJOZXV0cmFsIjticmVhaztjYXNlIDU6dD0iQ3VzdG9tIjticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xQcm9ncmFtOiBVbnN1cHBvcnRlZCB0b25lTWFwcGluZzoiLGUpLHQ9IkxpbmVhciJ9cmV0dXJuInZlYzMgIituKyIoIHZlYzMgY29sb3IgKSB7IHJldHVybiAiK3QrIlRvbmVNYXBwaW5nKCBjb2xvciApOyB9In1jb25zdCBiaT1uZXcgTztmdW5jdGlvbiBqYygpe0JlLmdldEx1bWluYW5jZUNvZWZmaWNpZW50cyhiaSk7Y29uc3Qgbj1iaS54LnRvRml4ZWQoNCksZT1iaS55LnRvRml4ZWQoNCksdD1iaS56LnRvRml4ZWQoNCk7cmV0dXJuWyJmbG9hdCBsdW1pbmFuY2UoIGNvbnN0IGluIHZlYzMgcmdiICkgeyIsYAljb25zdCB2ZWMzIHdlaWdodHMgPSB2ZWMzKCAke259LCAke2V9LCAke3R9ICk7YCwiCXJldHVybiBkb3QoIHdlaWdodHMsIHJnYiApOyIsIn0iXS5qb2luKGAKYCl9ZnVuY3Rpb24gSmMobil7cmV0dXJuW24uZXh0ZW5zaW9uQ2xpcEN1bGxEaXN0YW5jZT8iI2V4dGVuc2lvbiBHTF9BTkdMRV9jbGlwX2N1bGxfZGlzdGFuY2UgOiByZXF1aXJlIjoiIixuLmV4dGVuc2lvbk11bHRpRHJhdz8iI2V4dGVuc2lvbiBHTF9BTkdMRV9tdWx0aV9kcmF3IDogcmVxdWlyZSI6IiJdLmZpbHRlcihlaSkuam9pbihgCmApfWZ1bmN0aW9uIFFjKG4pe2NvbnN0IGU9W107Zm9yKGNvbnN0IHQgaW4gbil7Y29uc3QgaT1uW3RdO2khPT0hMSYmZS5wdXNoKCIjZGVmaW5lICIrdCsiICIraSl9cmV0dXJuIGUuam9pbihgCmApfWZ1bmN0aW9uIGV1KG4sZSl7Y29uc3QgdD17fSxpPW4uZ2V0UHJvZ3JhbVBhcmFtZXRlcihlLG4uQUNUSVZFX0FUVFJJQlVURVMpO2ZvcihsZXQgcj0wO3I8aTtyKyspe2NvbnN0IHM9bi5nZXRBY3RpdmVBdHRyaWIoZSxyKSxvPXMubmFtZTtsZXQgYT0xO3MudHlwZT09PW4uRkxPQVRfTUFUMiYmKGE9Mikscy50eXBlPT09bi5GTE9BVF9NQVQzJiYoYT0zKSxzLnR5cGU9PT1uLkZMT0FUX01BVDQmJihhPTQpLHRbb109e3R5cGU6cy50eXBlLGxvY2F0aW9uOm4uZ2V0QXR0cmliTG9jYXRpb24oZSxvKSxsb2NhdGlvblNpemU6YX19cmV0dXJuIHR9ZnVuY3Rpb24gZWkobil7cmV0dXJuIG4hPT0iIn1mdW5jdGlvbiB5cyhuLGUpe2NvbnN0IHQ9ZS5udW1TcG90TGlnaHRTaGFkb3dzK2UubnVtU3BvdExpZ2h0TWFwcy1lLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcztyZXR1cm4gbi5yZXBsYWNlKC9OVU1fRElSX0xJR0hUUy9nLGUubnVtRGlyTGlnaHRzKS5yZXBsYWNlKC9OVU1fU1BPVF9MSUdIVFMvZyxlLm51bVNwb3RMaWdodHMpLnJlcGxhY2UoL05VTV9TUE9UX0xJR0hUX01BUFMvZyxlLm51bVNwb3RMaWdodE1hcHMpLnJlcGxhY2UoL05VTV9TUE9UX0xJR0hUX0NPT1JEUy9nLHQpLnJlcGxhY2UoL05VTV9SRUNUX0FSRUFfTElHSFRTL2csZS5udW1SZWN0QXJlYUxpZ2h0cykucmVwbGFjZSgvTlVNX1BPSU5UX0xJR0hUUy9nLGUubnVtUG9pbnRMaWdodHMpLnJlcGxhY2UoL05VTV9IRU1JX0xJR0hUUy9nLGUubnVtSGVtaUxpZ2h0cykucmVwbGFjZSgvTlVNX0RJUl9MSUdIVF9TSEFET1dTL2csZS5udW1EaXJMaWdodFNoYWRvd3MpLnJlcGxhY2UoL05VTV9TUE9UX0xJR0hUX1NIQURPV1NfV0lUSF9NQVBTL2csZS5udW1TcG90TGlnaHRTaGFkb3dzV2l0aE1hcHMpLnJlcGxhY2UoL05VTV9TUE9UX0xJR0hUX1NIQURPV1MvZyxlLm51bVNwb3RMaWdodFNoYWRvd3MpLnJlcGxhY2UoL05VTV9QT0lOVF9MSUdIVF9TSEFET1dTL2csZS5udW1Qb2ludExpZ2h0U2hhZG93cyl9ZnVuY3Rpb24gVHMobixlKXtyZXR1cm4gbi5yZXBsYWNlKC9OVU1fQ0xJUFBJTkdfUExBTkVTL2csZS5udW1DbGlwcGluZ1BsYW5lcykucmVwbGFjZSgvVU5JT05fQ0xJUFBJTkdfUExBTkVTL2csZS5udW1DbGlwcGluZ1BsYW5lcy1lLm51bUNsaXBJbnRlcnNlY3Rpb24pfWNvbnN0IHR1PS9eWyBcdF0qI2luY2x1ZGUgKzwoW1x3XGQuL10rKT4vZ207ZnVuY3Rpb24gZHIobil7cmV0dXJuIG4ucmVwbGFjZSh0dSxpdSl9Y29uc3QgbnU9bmV3IE1hcDtmdW5jdGlvbiBpdShuLGUpe2xldCB0PURlW2VdO2lmKHQ9PT12b2lkIDApe2NvbnN0IGk9bnUuZ2V0KGUpO2lmKGkhPT12b2lkIDApdD1EZVtpXSxjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFNoYWRlciBjaHVuayAiJXMiIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAiJXMiIGluc3RlYWQuJyxlLGkpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJDYW4gbm90IHJlc29sdmUgI2luY2x1ZGUgPCIrZSsiPiIpfXJldHVybiBkcih0KX1jb25zdCBydT0vI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxzK2ZvclxzKlwoXHMqaW50XHMraVxzKj1ccyooXGQrKVxzKjtccyppXHMqPFxzKihcZCspXHMqO1xzKmlccypcK1wrXHMqXClccyp7KFtcc1xTXSs/KX1ccysjcHJhZ21hIHVucm9sbF9sb29wX2VuZC9nO2Z1bmN0aW9uIEFzKG4pe3JldHVybiBuLnJlcGxhY2UocnUsc3UpfWZ1bmN0aW9uIHN1KG4sZSx0LGkpe2xldCByPSIiO2ZvcihsZXQgcz1wYXJzZUludChlKTtzPHBhcnNlSW50KHQpO3MrKylyKz1pLnJlcGxhY2UoL1xbXHMqaVxzKlxdL2csIlsgIitzKyIgXSIpLnJlcGxhY2UoL1VOUk9MTEVEX0xPT1BfSU5ERVgvZyxzKTtyZXR1cm4gcn1mdW5jdGlvbiB3cyhuKXtsZXQgZT1gcHJlY2lzaW9uICR7bi5wcmVjaXNpb259IGZsb2F0OwoJcHJlY2lzaW9uICR7bi5wcmVjaXNpb259IGludDsKCXByZWNpc2lvbiAke24ucHJlY2lzaW9ufSBzYW1wbGVyMkQ7CglwcmVjaXNpb24gJHtuLnByZWNpc2lvbn0gc2FtcGxlckN1YmU7CglwcmVjaXNpb24gJHtuLnByZWNpc2lvbn0gc2FtcGxlcjNEOwoJcHJlY2lzaW9uICR7bi5wcmVjaXNpb259IHNhbXBsZXIyREFycmF5OwoJcHJlY2lzaW9uICR7bi5wcmVjaXNpb259IHNhbXBsZXIyRFNoYWRvdzsKCXByZWNpc2lvbiAke24ucHJlY2lzaW9ufSBzYW1wbGVyQ3ViZVNoYWRvdzsKCXByZWNpc2lvbiAke24ucHJlY2lzaW9ufSBzYW1wbGVyMkRBcnJheVNoYWRvdzsKCXByZWNpc2lvbiAke24ucHJlY2lzaW9ufSBpc2FtcGxlcjJEOwoJcHJlY2lzaW9uICR7bi5wcmVjaXNpb259IGlzYW1wbGVyM0Q7CglwcmVjaXNpb24gJHtuLnByZWNpc2lvbn0gaXNhbXBsZXJDdWJlOwoJcHJlY2lzaW9uICR7bi5wcmVjaXNpb259IGlzYW1wbGVyMkRBcnJheTsKCXByZWNpc2lvbiAke24ucHJlY2lzaW9ufSB1c2FtcGxlcjJEOwoJcHJlY2lzaW9uICR7bi5wcmVjaXNpb259IHVzYW1wbGVyM0Q7CglwcmVjaXNpb24gJHtuLnByZWNpc2lvbn0gdXNhbXBsZXJDdWJlOwoJcHJlY2lzaW9uICR7bi5wcmVjaXNpb259IHVzYW1wbGVyMkRBcnJheTsKCWA7cmV0dXJuIG4ucHJlY2lzaW9uPT09ImhpZ2hwIj9lKz1gCiNkZWZpbmUgSElHSF9QUkVDSVNJT05gOm4ucHJlY2lzaW9uPT09Im1lZGl1bXAiP2UrPWAKI2RlZmluZSBNRURJVU1fUFJFQ0lTSU9OYDpuLnByZWNpc2lvbj09PSJsb3dwIiYmKGUrPWAKI2RlZmluZSBMT1dfUFJFQ0lTSU9OYCksZX1mdW5jdGlvbiBhdShuKXtsZXQgZT0iU0hBRE9XTUFQX1RZUEVfQkFTSUMiO3JldHVybiBuLnNoYWRvd01hcFR5cGU9PT0xP2U9IlNIQURPV01BUF9UWVBFX1BDRiI6bi5zaGFkb3dNYXBUeXBlPT09Mj9lPSJTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCI6bi5zaGFkb3dNYXBUeXBlPT09MyYmKGU9IlNIQURPV01BUF9UWVBFX1ZTTSIpLGV9ZnVuY3Rpb24gb3Uobil7bGV0IGU9IkVOVk1BUF9UWVBFX0NVQkUiO2lmKG4uZW52TWFwKXN3aXRjaChuLmVudk1hcE1vZGUpe2Nhc2UgMzAxOmNhc2UgMzAyOmU9IkVOVk1BUF9UWVBFX0NVQkUiO2JyZWFrO2Nhc2UgMzA2OmU9IkVOVk1BUF9UWVBFX0NVQkVfVVYiO2JyZWFrfXJldHVybiBlfWZ1bmN0aW9uIGx1KG4pe2xldCBlPSJFTlZNQVBfTU9ERV9SRUZMRUNUSU9OIjtpZihuLmVudk1hcClzd2l0Y2gobi5lbnZNYXBNb2RlKXtjYXNlIDMwMjplPSJFTlZNQVBfTU9ERV9SRUZSQUNUSU9OIjticmVha31yZXR1cm4gZX1mdW5jdGlvbiBjdShuKXtsZXQgZT0iRU5WTUFQX0JMRU5ESU5HX05PTkUiO2lmKG4uZW52TWFwKXN3aXRjaChuLmNvbWJpbmUpe2Nhc2UgMDplPSJFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFkiO2JyZWFrO2Nhc2UgMTplPSJFTlZNQVBfQkxFTkRJTkdfTUlYIjticmVhaztjYXNlIDI6ZT0iRU5WTUFQX0JMRU5ESU5HX0FERCI7YnJlYWt9cmV0dXJuIGV9ZnVuY3Rpb24gdXUobil7Y29uc3QgZT1uLmVudk1hcEN1YmVVVkhlaWdodDtpZihlPT09bnVsbClyZXR1cm4gbnVsbDtjb25zdCB0PU1hdGgubG9nMihlKS0yLGk9MS9lO3JldHVybnt0ZXhlbFdpZHRoOjEvKDMqTWF0aC5tYXgoTWF0aC5wb3coMix0KSw3KjE2KSksdGV4ZWxIZWlnaHQ6aSxtYXhNaXA6dH19ZnVuY3Rpb24gaHUobixlLHQsaSl7Y29uc3Qgcj1uLmdldENvbnRleHQoKSxzPXQuZGVmaW5lcztsZXQgbz10LnZlcnRleFNoYWRlcixhPXQuZnJhZ21lbnRTaGFkZXI7Y29uc3QgbD1hdSh0KSxjPW91KHQpLHU9bHUodCksZD1jdSh0KSxmPXV1KHQpLHA9SmModCksZz1RYyhzKSx4PXIuY3JlYXRlUHJvZ3JhbSgpO2xldCBtLGgsVD10Lmdsc2xWZXJzaW9uPyIjdmVyc2lvbiAiK3QuZ2xzbFZlcnNpb24rYApgOiIiO3QuaXNSYXdTaGFkZXJNYXRlcmlhbD8obT1bIiNkZWZpbmUgU0hBREVSX1RZUEUgIit0LnNoYWRlclR5cGUsIiNkZWZpbmUgU0hBREVSX05BTUUgIit0LnNoYWRlck5hbWUsZ10uZmlsdGVyKGVpKS5qb2luKGAKYCksbS5sZW5ndGg+MCYmKG0rPWAKYCksaD1bIiNkZWZpbmUgU0hBREVSX1RZUEUgIit0LnNoYWRlclR5cGUsIiNkZWZpbmUgU0hBREVSX05BTUUgIit0LnNoYWRlck5hbWUsZ10uZmlsdGVyKGVpKS5qb2luKGAKYCksaC5sZW5ndGg+MCYmKGgrPWAKYCkpOihtPVt3cyh0KSwiI2RlZmluZSBTSEFERVJfVFlQRSAiK3Quc2hhZGVyVHlwZSwiI2RlZmluZSBTSEFERVJfTkFNRSAiK3Quc2hhZGVyTmFtZSxnLHQuZXh0ZW5zaW9uQ2xpcEN1bGxEaXN0YW5jZT8iI2RlZmluZSBVU0VfQ0xJUF9ESVNUQU5DRSI6IiIsdC5iYXRjaGluZz8iI2RlZmluZSBVU0VfQkFUQ0hJTkciOiIiLHQuYmF0Y2hpbmdDb2xvcj8iI2RlZmluZSBVU0VfQkFUQ0hJTkdfQ09MT1IiOiIiLHQuaW5zdGFuY2luZz8iI2RlZmluZSBVU0VfSU5TVEFOQ0lORyI6IiIsdC5pbnN0YW5jaW5nQ29sb3I/IiNkZWZpbmUgVVNFX0lOU1RBTkNJTkdfQ09MT1IiOiIiLHQuaW5zdGFuY2luZ01vcnBoPyIjZGVmaW5lIFVTRV9JTlNUQU5DSU5HX01PUlBIIjoiIix0LnVzZUZvZyYmdC5mb2c/IiNkZWZpbmUgVVNFX0ZPRyI6IiIsdC51c2VGb2cmJnQuZm9nRXhwMj8iI2RlZmluZSBGT0dfRVhQMiI6IiIsdC5tYXA/IiNkZWZpbmUgVVNFX01BUCI6IiIsdC5lbnZNYXA/IiNkZWZpbmUgVVNFX0VOVk1BUCI6IiIsdC5lbnZNYXA/IiNkZWZpbmUgIit1OiIiLHQubGlnaHRNYXA/IiNkZWZpbmUgVVNFX0xJR0hUTUFQIjoiIix0LmFvTWFwPyIjZGVmaW5lIFVTRV9BT01BUCI6IiIsdC5idW1wTWFwPyIjZGVmaW5lIFVTRV9CVU1QTUFQIjoiIix0Lm5vcm1hbE1hcD8iI2RlZmluZSBVU0VfTk9STUFMTUFQIjoiIix0Lm5vcm1hbE1hcE9iamVjdFNwYWNlPyIjZGVmaW5lIFVTRV9OT1JNQUxNQVBfT0JKRUNUU1BBQ0UiOiIiLHQubm9ybWFsTWFwVGFuZ2VudFNwYWNlPyIjZGVmaW5lIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFIjoiIix0LmRpc3BsYWNlbWVudE1hcD8iI2RlZmluZSBVU0VfRElTUExBQ0VNRU5UTUFQIjoiIix0LmVtaXNzaXZlTWFwPyIjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCI6IiIsdC5hbmlzb3Ryb3B5PyIjZGVmaW5lIFVTRV9BTklTT1RST1BZIjoiIix0LmFuaXNvdHJvcHlNYXA/IiNkZWZpbmUgVVNFX0FOSVNPVFJPUFlNQVAiOiIiLHQuY2xlYXJjb2F0TWFwPyIjZGVmaW5lIFVTRV9DTEVBUkNPQVRNQVAiOiIiLHQuY2xlYXJjb2F0Um91Z2huZXNzTWFwPyIjZGVmaW5lIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTTUFQIjoiIix0LmNsZWFyY29hdE5vcm1hbE1hcD8iI2RlZmluZSBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUCI6IiIsdC5pcmlkZXNjZW5jZU1hcD8iI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0VNQVAiOiIiLHQuaXJpZGVzY2VuY2VUaGlja25lc3NNYXA/IiNkZWZpbmUgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUCI6IiIsdC5zcGVjdWxhck1hcD8iI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAiOiIiLHQuc3BlY3VsYXJDb2xvck1hcD8iI2RlZmluZSBVU0VfU1BFQ1VMQVJfQ09MT1JNQVAiOiIiLHQuc3BlY3VsYXJJbnRlbnNpdHlNYXA/IiNkZWZpbmUgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUCI6IiIsdC5yb3VnaG5lc3NNYXA/IiNkZWZpbmUgVVNFX1JPVUdITkVTU01BUCI6IiIsdC5tZXRhbG5lc3NNYXA/IiNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCI6IiIsdC5hbHBoYU1hcD8iI2RlZmluZSBVU0VfQUxQSEFNQVAiOiIiLHQuYWxwaGFIYXNoPyIjZGVmaW5lIFVTRV9BTFBIQUhBU0giOiIiLHQudHJhbnNtaXNzaW9uPyIjZGVmaW5lIFVTRV9UUkFOU01JU1NJT04iOiIiLHQudHJhbnNtaXNzaW9uTWFwPyIjZGVmaW5lIFVTRV9UUkFOU01JU1NJT05NQVAiOiIiLHQudGhpY2tuZXNzTWFwPyIjZGVmaW5lIFVTRV9USElDS05FU1NNQVAiOiIiLHQuc2hlZW5Db2xvck1hcD8iI2RlZmluZSBVU0VfU0hFRU5fQ09MT1JNQVAiOiIiLHQuc2hlZW5Sb3VnaG5lc3NNYXA/IiNkZWZpbmUgVVNFX1NIRUVOX1JPVUdITkVTU01BUCI6IiIsdC5tYXBVdj8iI2RlZmluZSBNQVBfVVYgIit0Lm1hcFV2OiIiLHQuYWxwaGFNYXBVdj8iI2RlZmluZSBBTFBIQU1BUF9VViAiK3QuYWxwaGFNYXBVdjoiIix0LmxpZ2h0TWFwVXY/IiNkZWZpbmUgTElHSFRNQVBfVVYgIit0LmxpZ2h0TWFwVXY6IiIsdC5hb01hcFV2PyIjZGVmaW5lIEFPTUFQX1VWICIrdC5hb01hcFV2OiIiLHQuZW1pc3NpdmVNYXBVdj8iI2RlZmluZSBFTUlTU0lWRU1BUF9VViAiK3QuZW1pc3NpdmVNYXBVdjoiIix0LmJ1bXBNYXBVdj8iI2RlZmluZSBCVU1QTUFQX1VWICIrdC5idW1wTWFwVXY6IiIsdC5ub3JtYWxNYXBVdj8iI2RlZmluZSBOT1JNQUxNQVBfVVYgIit0Lm5vcm1hbE1hcFV2OiIiLHQuZGlzcGxhY2VtZW50TWFwVXY/IiNkZWZpbmUgRElTUExBQ0VNRU5UTUFQX1VWICIrdC5kaXNwbGFjZW1lbnRNYXBVdjoiIix0Lm1ldGFsbmVzc01hcFV2PyIjZGVmaW5lIE1FVEFMTkVTU01BUF9VViAiK3QubWV0YWxuZXNzTWFwVXY6IiIsdC5yb3VnaG5lc3NNYXBVdj8iI2RlZmluZSBST1VHSE5FU1NNQVBfVVYgIit0LnJvdWdobmVzc01hcFV2OiIiLHQuYW5pc290cm9weU1hcFV2PyIjZGVmaW5lIEFOSVNPVFJPUFlNQVBfVVYgIit0LmFuaXNvdHJvcHlNYXBVdjoiIix0LmNsZWFyY29hdE1hcFV2PyIjZGVmaW5lIENMRUFSQ09BVE1BUF9VViAiK3QuY2xlYXJjb2F0TWFwVXY6IiIsdC5jbGVhcmNvYXROb3JtYWxNYXBVdj8iI2RlZmluZSBDTEVBUkNPQVRfTk9STUFMTUFQX1VWICIrdC5jbGVhcmNvYXROb3JtYWxNYXBVdjoiIix0LmNsZWFyY29hdFJvdWdobmVzc01hcFV2PyIjZGVmaW5lIENMRUFSQ09BVF9ST1VHSE5FU1NNQVBfVVYgIit0LmNsZWFyY29hdFJvdWdobmVzc01hcFV2OiIiLHQuaXJpZGVzY2VuY2VNYXBVdj8iI2RlZmluZSBJUklERVNDRU5DRU1BUF9VViAiK3QuaXJpZGVzY2VuY2VNYXBVdjoiIix0LmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXY/IiNkZWZpbmUgSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQX1VWICIrdC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2OiIiLHQuc2hlZW5Db2xvck1hcFV2PyIjZGVmaW5lIFNIRUVOX0NPTE9STUFQX1VWICIrdC5zaGVlbkNvbG9yTWFwVXY6IiIsdC5zaGVlblJvdWdobmVzc01hcFV2PyIjZGVmaW5lIFNIRUVOX1JPVUdITkVTU01BUF9VViAiK3Quc2hlZW5Sb3VnaG5lc3NNYXBVdjoiIix0LnNwZWN1bGFyTWFwVXY/IiNkZWZpbmUgU1BFQ1VMQVJNQVBfVVYgIit0LnNwZWN1bGFyTWFwVXY6IiIsdC5zcGVjdWxhckNvbG9yTWFwVXY/IiNkZWZpbmUgU1BFQ1VMQVJfQ09MT1JNQVBfVVYgIit0LnNwZWN1bGFyQ29sb3JNYXBVdjoiIix0LnNwZWN1bGFySW50ZW5zaXR5TWFwVXY/IiNkZWZpbmUgU1BFQ1VMQVJfSU5URU5TSVRZTUFQX1VWICIrdC5zcGVjdWxhckludGVuc2l0eU1hcFV2OiIiLHQudHJhbnNtaXNzaW9uTWFwVXY/IiNkZWZpbmUgVFJBTlNNSVNTSU9OTUFQX1VWICIrdC50cmFuc21pc3Npb25NYXBVdjoiIix0LnRoaWNrbmVzc01hcFV2PyIjZGVmaW5lIFRISUNLTkVTU01BUF9VViAiK3QudGhpY2tuZXNzTWFwVXY6IiIsdC52ZXJ0ZXhUYW5nZW50cyYmdC5mbGF0U2hhZGluZz09PSExPyIjZGVmaW5lIFVTRV9UQU5HRU5UIjoiIix0LnZlcnRleENvbG9ycz8iI2RlZmluZSBVU0VfQ09MT1IiOiIiLHQudmVydGV4QWxwaGFzPyIjZGVmaW5lIFVTRV9DT0xPUl9BTFBIQSI6IiIsdC52ZXJ0ZXhVdjFzPyIjZGVmaW5lIFVTRV9VVjEiOiIiLHQudmVydGV4VXYycz8iI2RlZmluZSBVU0VfVVYyIjoiIix0LnZlcnRleFV2M3M/IiNkZWZpbmUgVVNFX1VWMyI6IiIsdC5wb2ludHNVdnM/IiNkZWZpbmUgVVNFX1BPSU5UU19VViI6IiIsdC5mbGF0U2hhZGluZz8iI2RlZmluZSBGTEFUX1NIQURFRCI6IiIsdC5za2lubmluZz8iI2RlZmluZSBVU0VfU0tJTk5JTkciOiIiLHQubW9ycGhUYXJnZXRzPyIjZGVmaW5lIFVTRV9NT1JQSFRBUkdFVFMiOiIiLHQubW9ycGhOb3JtYWxzJiZ0LmZsYXRTaGFkaW5nPT09ITE/IiNkZWZpbmUgVVNFX01PUlBITk9STUFMUyI6IiIsdC5tb3JwaENvbG9ycz8iI2RlZmluZSBVU0VfTU9SUEhDT0xPUlMiOiIiLHQubW9ycGhUYXJnZXRzQ291bnQ+MD8iI2RlZmluZSBNT1JQSFRBUkdFVFNfVEVYVFVSRV9TVFJJREUgIit0Lm1vcnBoVGV4dHVyZVN0cmlkZToiIix0Lm1vcnBoVGFyZ2V0c0NvdW50PjA/IiNkZWZpbmUgTU9SUEhUQVJHRVRTX0NPVU5UICIrdC5tb3JwaFRhcmdldHNDb3VudDoiIix0LmRvdWJsZVNpZGVkPyIjZGVmaW5lIERPVUJMRV9TSURFRCI6IiIsdC5mbGlwU2lkZWQ/IiNkZWZpbmUgRkxJUF9TSURFRCI6IiIsdC5zaGFkb3dNYXBFbmFibGVkPyIjZGVmaW5lIFVTRV9TSEFET1dNQVAiOiIiLHQuc2hhZG93TWFwRW5hYmxlZD8iI2RlZmluZSAiK2w6IiIsdC5zaXplQXR0ZW51YXRpb24/IiNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTiI6IiIsdC5udW1MaWdodFByb2Jlcz4wPyIjZGVmaW5lIFVTRV9MSUdIVF9QUk9CRVMiOiIiLHQubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcj8iI2RlZmluZSBVU0VfTE9HREVQVEhCVUYiOiIiLHQucmV2ZXJzZURlcHRoQnVmZmVyPyIjZGVmaW5lIFVTRV9SRVZFUlNFREVQVEhCVUYiOiIiLCJ1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7IiwidW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsiLCJ1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsiLCJ1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsiLCJ1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4OyIsInVuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsiLCJ1bmlmb3JtIGJvb2wgaXNPcnRob2dyYXBoaWM7IiwiI2lmZGVmIFVTRV9JTlNUQU5DSU5HIiwiCWF0dHJpYnV0ZSBtYXQ0IGluc3RhbmNlTWF0cml4OyIsIiNlbmRpZiIsIiNpZmRlZiBVU0VfSU5TVEFOQ0lOR19DT0xPUiIsIglhdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZUNvbG9yOyIsIiNlbmRpZiIsIiNpZmRlZiBVU0VfSU5TVEFOQ0lOR19NT1JQSCIsIgl1bmlmb3JtIHNhbXBsZXIyRCBtb3JwaFRleHR1cmU7IiwiI2VuZGlmIiwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247IiwiYXR0cmlidXRlIHZlYzMgbm9ybWFsOyIsImF0dHJpYnV0ZSB2ZWMyIHV2OyIsIiNpZmRlZiBVU0VfVVYxIiwiCWF0dHJpYnV0ZSB2ZWMyIHV2MTsiLCIjZW5kaWYiLCIjaWZkZWYgVVNFX1VWMiIsIglhdHRyaWJ1dGUgdmVjMiB1djI7IiwiI2VuZGlmIiwiI2lmZGVmIFVTRV9VVjMiLCIJYXR0cmlidXRlIHZlYzIgdXYzOyIsIiNlbmRpZiIsIiNpZmRlZiBVU0VfVEFOR0VOVCIsIglhdHRyaWJ1dGUgdmVjNCB0YW5nZW50OyIsIiNlbmRpZiIsIiNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKSIsIglhdHRyaWJ1dGUgdmVjNCBjb2xvcjsiLCIjZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSIsIglhdHRyaWJ1dGUgdmVjMyBjb2xvcjsiLCIjZW5kaWYiLCIjaWZkZWYgVVNFX1NLSU5OSU5HIiwiCWF0dHJpYnV0ZSB2ZWM0IHNraW5JbmRleDsiLCIJYXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDsiLCIjZW5kaWYiLGAKYF0uZmlsdGVyKGVpKS5qb2luKGAKYCksaD1bd3ModCksIiNkZWZpbmUgU0hBREVSX1RZUEUgIit0LnNoYWRlclR5cGUsIiNkZWZpbmUgU0hBREVSX05BTUUgIit0LnNoYWRlck5hbWUsZyx0LnVzZUZvZyYmdC5mb2c/IiNkZWZpbmUgVVNFX0ZPRyI6IiIsdC51c2VGb2cmJnQuZm9nRXhwMj8iI2RlZmluZSBGT0dfRVhQMiI6IiIsdC5hbHBoYVRvQ292ZXJhZ2U/IiNkZWZpbmUgQUxQSEFfVE9fQ09WRVJBR0UiOiIiLHQubWFwPyIjZGVmaW5lIFVTRV9NQVAiOiIiLHQubWF0Y2FwPyIjZGVmaW5lIFVTRV9NQVRDQVAiOiIiLHQuZW52TWFwPyIjZGVmaW5lIFVTRV9FTlZNQVAiOiIiLHQuZW52TWFwPyIjZGVmaW5lICIrYzoiIix0LmVudk1hcD8iI2RlZmluZSAiK3U6IiIsdC5lbnZNYXA/IiNkZWZpbmUgIitkOiIiLGY/IiNkZWZpbmUgQ1VCRVVWX1RFWEVMX1dJRFRIICIrZi50ZXhlbFdpZHRoOiIiLGY/IiNkZWZpbmUgQ1VCRVVWX1RFWEVMX0hFSUdIVCAiK2YudGV4ZWxIZWlnaHQ6IiIsZj8iI2RlZmluZSBDVUJFVVZfTUFYX01JUCAiK2YubWF4TWlwKyIuMCI6IiIsdC5saWdodE1hcD8iI2RlZmluZSBVU0VfTElHSFRNQVAiOiIiLHQuYW9NYXA/IiNkZWZpbmUgVVNFX0FPTUFQIjoiIix0LmJ1bXBNYXA/IiNkZWZpbmUgVVNFX0JVTVBNQVAiOiIiLHQubm9ybWFsTWFwPyIjZGVmaW5lIFVTRV9OT1JNQUxNQVAiOiIiLHQubm9ybWFsTWFwT2JqZWN0U3BhY2U/IiNkZWZpbmUgVVNFX05PUk1BTE1BUF9PQkpFQ1RTUEFDRSI6IiIsdC5ub3JtYWxNYXBUYW5nZW50U3BhY2U/IiNkZWZpbmUgVVNFX05PUk1BTE1BUF9UQU5HRU5UU1BBQ0UiOiIiLHQuZW1pc3NpdmVNYXA/IiNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQIjoiIix0LmFuaXNvdHJvcHk/IiNkZWZpbmUgVVNFX0FOSVNPVFJPUFkiOiIiLHQuYW5pc290cm9weU1hcD8iI2RlZmluZSBVU0VfQU5JU09UUk9QWU1BUCI6IiIsdC5jbGVhcmNvYXQ/IiNkZWZpbmUgVVNFX0NMRUFSQ09BVCI6IiIsdC5jbGVhcmNvYXRNYXA/IiNkZWZpbmUgVVNFX0NMRUFSQ09BVE1BUCI6IiIsdC5jbGVhcmNvYXRSb3VnaG5lc3NNYXA/IiNkZWZpbmUgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAiOiIiLHQuY2xlYXJjb2F0Tm9ybWFsTWFwPyIjZGVmaW5lIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQIjoiIix0LmRpc3BlcnNpb24/IiNkZWZpbmUgVVNFX0RJU1BFUlNJT04iOiIiLHQuaXJpZGVzY2VuY2U/IiNkZWZpbmUgVVNFX0lSSURFU0NFTkNFIjoiIix0LmlyaWRlc2NlbmNlTWFwPyIjZGVmaW5lIFVTRV9JUklERVNDRU5DRU1BUCI6IiIsdC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcD8iI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQIjoiIix0LnNwZWN1bGFyTWFwPyIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCI6IiIsdC5zcGVjdWxhckNvbG9yTWFwPyIjZGVmaW5lIFVTRV9TUEVDVUxBUl9DT0xPUk1BUCI6IiIsdC5zcGVjdWxhckludGVuc2l0eU1hcD8iI2RlZmluZSBVU0VfU1BFQ1VMQVJfSU5URU5TSVRZTUFQIjoiIix0LnJvdWdobmVzc01hcD8iI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQIjoiIix0Lm1ldGFsbmVzc01hcD8iI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQIjoiIix0LmFscGhhTWFwPyIjZGVmaW5lIFVTRV9BTFBIQU1BUCI6IiIsdC5hbHBoYVRlc3Q/IiNkZWZpbmUgVVNFX0FMUEhBVEVTVCI6IiIsdC5hbHBoYUhhc2g/IiNkZWZpbmUgVVNFX0FMUEhBSEFTSCI6IiIsdC5zaGVlbj8iI2RlZmluZSBVU0VfU0hFRU4iOiIiLHQuc2hlZW5Db2xvck1hcD8iI2RlZmluZSBVU0VfU0hFRU5fQ09MT1JNQVAiOiIiLHQuc2hlZW5Sb3VnaG5lc3NNYXA/IiNkZWZpbmUgVVNFX1NIRUVOX1JPVUdITkVTU01BUCI6IiIsdC50cmFuc21pc3Npb24/IiNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTiI6IiIsdC50cmFuc21pc3Npb25NYXA/IiNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTk1BUCI6IiIsdC50aGlja25lc3NNYXA/IiNkZWZpbmUgVVNFX1RISUNLTkVTU01BUCI6IiIsdC52ZXJ0ZXhUYW5nZW50cyYmdC5mbGF0U2hhZGluZz09PSExPyIjZGVmaW5lIFVTRV9UQU5HRU5UIjoiIix0LnZlcnRleENvbG9yc3x8dC5pbnN0YW5jaW5nQ29sb3J8fHQuYmF0Y2hpbmdDb2xvcj8iI2RlZmluZSBVU0VfQ09MT1IiOiIiLHQudmVydGV4QWxwaGFzPyIjZGVmaW5lIFVTRV9DT0xPUl9BTFBIQSI6IiIsdC52ZXJ0ZXhVdjFzPyIjZGVmaW5lIFVTRV9VVjEiOiIiLHQudmVydGV4VXYycz8iI2RlZmluZSBVU0VfVVYyIjoiIix0LnZlcnRleFV2M3M/IiNkZWZpbmUgVVNFX1VWMyI6IiIsdC5wb2ludHNVdnM/IiNkZWZpbmUgVVNFX1BPSU5UU19VViI6IiIsdC5ncmFkaWVudE1hcD8iI2RlZmluZSBVU0VfR1JBRElFTlRNQVAiOiIiLHQuZmxhdFNoYWRpbmc/IiNkZWZpbmUgRkxBVF9TSEFERUQiOiIiLHQuZG91YmxlU2lkZWQ/IiNkZWZpbmUgRE9VQkxFX1NJREVEIjoiIix0LmZsaXBTaWRlZD8iI2RlZmluZSBGTElQX1NJREVEIjoiIix0LnNoYWRvd01hcEVuYWJsZWQ/IiNkZWZpbmUgVVNFX1NIQURPV01BUCI6IiIsdC5zaGFkb3dNYXBFbmFibGVkPyIjZGVmaW5lICIrbDoiIix0LnByZW11bHRpcGxpZWRBbHBoYT8iI2RlZmluZSBQUkVNVUxUSVBMSUVEX0FMUEhBIjoiIix0Lm51bUxpZ2h0UHJvYmVzPjA/IiNkZWZpbmUgVVNFX0xJR0hUX1BST0JFUyI6IiIsdC5kZWNvZGVWaWRlb1RleHR1cmU/IiNkZWZpbmUgREVDT0RFX1ZJREVPX1RFWFRVUkUiOiIiLHQuZGVjb2RlVmlkZW9UZXh0dXJlRW1pc3NpdmU/IiNkZWZpbmUgREVDT0RFX1ZJREVPX1RFWFRVUkVfRU1JU1NJVkUiOiIiLHQubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcj8iI2RlZmluZSBVU0VfTE9HREVQVEhCVUYiOiIiLHQucmV2ZXJzZURlcHRoQnVmZmVyPyIjZGVmaW5lIFVTRV9SRVZFUlNFREVQVEhCVUYiOiIiLCJ1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsiLCJ1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247IiwidW5pZm9ybSBib29sIGlzT3J0aG9ncmFwaGljOyIsdC50b25lTWFwcGluZyE9PTA/IiNkZWZpbmUgVE9ORV9NQVBQSU5HIjoiIix0LnRvbmVNYXBwaW5nIT09MD9EZS50b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50OiIiLHQudG9uZU1hcHBpbmchPT0wP1pjKCJ0b25lTWFwcGluZyIsdC50b25lTWFwcGluZyk6IiIsdC5kaXRoZXJpbmc/IiNkZWZpbmUgRElUSEVSSU5HIjoiIix0Lm9wYXF1ZT8iI2RlZmluZSBPUEFRVUUiOiIiLERlLmNvbG9yc3BhY2VfcGFyc19mcmFnbWVudCxLYygibGluZWFyVG9PdXRwdXRUZXhlbCIsdC5vdXRwdXRDb2xvclNwYWNlKSxqYygpLHQudXNlRGVwdGhQYWNraW5nPyIjZGVmaW5lIERFUFRIX1BBQ0tJTkcgIit0LmRlcHRoUGFja2luZzoiIixgCmBdLmZpbHRlcihlaSkuam9pbihgCmApKSxvPWRyKG8pLG89eXMobyx0KSxvPVRzKG8sdCksYT1kcihhKSxhPXlzKGEsdCksYT1UcyhhLHQpLG89QXMobyksYT1BcyhhKSx0LmlzUmF3U2hhZGVyTWF0ZXJpYWwhPT0hMCYmKFQ9YCN2ZXJzaW9uIDMwMCBlcwpgLG09W3AsIiNkZWZpbmUgYXR0cmlidXRlIGluIiwiI2RlZmluZSB2YXJ5aW5nIG91dCIsIiNkZWZpbmUgdGV4dHVyZTJEIHRleHR1cmUiXS5qb2luKGAKYCkrYApgK20saD1bIiNkZWZpbmUgdmFyeWluZyBpbiIsdC5nbHNsVmVyc2lvbj09PU1yPyIiOiJsYXlvdXQobG9jYXRpb24gPSAwKSBvdXQgaGlnaHAgdmVjNCBwY19mcmFnQ29sb3I7Iix0Lmdsc2xWZXJzaW9uPT09TXI/IiI6IiNkZWZpbmUgZ2xfRnJhZ0NvbG9yIHBjX2ZyYWdDb2xvciIsIiNkZWZpbmUgZ2xfRnJhZ0RlcHRoRVhUIGdsX0ZyYWdEZXB0aCIsIiNkZWZpbmUgdGV4dHVyZTJEIHRleHR1cmUiLCIjZGVmaW5lIHRleHR1cmVDdWJlIHRleHR1cmUiLCIjZGVmaW5lIHRleHR1cmUyRFByb2ogdGV4dHVyZVByb2oiLCIjZGVmaW5lIHRleHR1cmUyRExvZEVYVCB0ZXh0dXJlTG9kIiwiI2RlZmluZSB0ZXh0dXJlMkRQcm9qTG9kRVhUIHRleHR1cmVQcm9qTG9kIiwiI2RlZmluZSB0ZXh0dXJlQ3ViZUxvZEVYVCB0ZXh0dXJlTG9kIiwiI2RlZmluZSB0ZXh0dXJlMkRHcmFkRVhUIHRleHR1cmVHcmFkIiwiI2RlZmluZSB0ZXh0dXJlMkRQcm9qR3JhZEVYVCB0ZXh0dXJlUHJvakdyYWQiLCIjZGVmaW5lIHRleHR1cmVDdWJlR3JhZEVYVCB0ZXh0dXJlR3JhZCJdLmpvaW4oYApgKStgCmAraCk7Y29uc3QgeT1UK20rbyxfPVQraCthLEM9TXMocixyLlZFUlRFWF9TSEFERVIseSksdz1NcyhyLHIuRlJBR01FTlRfU0hBREVSLF8pO3IuYXR0YWNoU2hhZGVyKHgsQyksci5hdHRhY2hTaGFkZXIoeCx3KSx0LmluZGV4MEF0dHJpYnV0ZU5hbWUhPT12b2lkIDA/ci5iaW5kQXR0cmliTG9jYXRpb24oeCwwLHQuaW5kZXgwQXR0cmlidXRlTmFtZSk6dC5tb3JwaFRhcmdldHM9PT0hMCYmci5iaW5kQXR0cmliTG9jYXRpb24oeCwwLCJwb3NpdGlvbiIpLHIubGlua1Byb2dyYW0oeCk7ZnVuY3Rpb24gYihSKXtpZihuLmRlYnVnLmNoZWNrU2hhZGVyRXJyb3JzKXtjb25zdCBxPXIuZ2V0UHJvZ3JhbUluZm9Mb2coeCkudHJpbSgpLHo9ci5nZXRTaGFkZXJJbmZvTG9nKEMpLnRyaW0oKSxXPXIuZ2V0U2hhZGVySW5mb0xvZyh3KS50cmltKCk7bGV0IFo9ITAsVj0hMDtpZihyLmdldFByb2dyYW1QYXJhbWV0ZXIoeCxyLkxJTktfU1RBVFVTKT09PSExKWlmKFo9ITEsdHlwZW9mIG4uZGVidWcub25TaGFkZXJFcnJvcj09ImZ1bmN0aW9uIiluLmRlYnVnLm9uU2hhZGVyRXJyb3Iocix4LEMsdyk7ZWxzZXtjb25zdCBRPUVzKHIsQywidmVydGV4IiksSD1FcyhyLHcsImZyYWdtZW50Iik7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xQcm9ncmFtOiBTaGFkZXIgRXJyb3IgIityLmdldEVycm9yKCkrIiAtIFZBTElEQVRFX1NUQVRVUyAiK3IuZ2V0UHJvZ3JhbVBhcmFtZXRlcih4LHIuVkFMSURBVEVfU1RBVFVTKStgCgpNYXRlcmlhbCBOYW1lOiBgK1IubmFtZStgCk1hdGVyaWFsIFR5cGU6IGArUi50eXBlK2AKClByb2dyYW0gSW5mbyBMb2c6IGArcStgCmArUStgCmArSCl9ZWxzZSBxIT09IiI/Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFByb2dyYW06IFByb2dyYW0gSW5mbyBMb2c6IixxKTooej09PSIifHxXPT09IiIpJiYoVj0hMSk7ViYmKFIuZGlhZ25vc3RpY3M9e3J1bm5hYmxlOloscHJvZ3JhbUxvZzpxLHZlcnRleFNoYWRlcjp7bG9nOnoscHJlZml4Om19LGZyYWdtZW50U2hhZGVyOntsb2c6VyxwcmVmaXg6aH19KX1yLmRlbGV0ZVNoYWRlcihDKSxyLmRlbGV0ZVNoYWRlcih3KSxGPW5ldyB3aShyLHgpLEU9ZXUocix4KX1sZXQgRjt0aGlzLmdldFVuaWZvcm1zPWZ1bmN0aW9uKCl7cmV0dXJuIEY9PT12b2lkIDAmJmIodGhpcyksRn07bGV0IEU7dGhpcy5nZXRBdHRyaWJ1dGVzPWZ1bmN0aW9uKCl7cmV0dXJuIEU9PT12b2lkIDAmJmIodGhpcyksRX07bGV0IFM9dC5yZW5kZXJlckV4dGVuc2lvblBhcmFsbGVsU2hhZGVyQ29tcGlsZT09PSExO3JldHVybiB0aGlzLmlzUmVhZHk9ZnVuY3Rpb24oKXtyZXR1cm4gUz09PSExJiYoUz1yLmdldFByb2dyYW1QYXJhbWV0ZXIoeCxYYykpLFN9LHRoaXMuZGVzdHJveT1mdW5jdGlvbigpe2kucmVsZWFzZVN0YXRlc09mUHJvZ3JhbSh0aGlzKSxyLmRlbGV0ZVByb2dyYW0oeCksdGhpcy5wcm9ncmFtPXZvaWQgMH0sdGhpcy50eXBlPXQuc2hhZGVyVHlwZSx0aGlzLm5hbWU9dC5zaGFkZXJOYW1lLHRoaXMuaWQ9cWMrKyx0aGlzLmNhY2hlS2V5PWUsdGhpcy51c2VkVGltZXM9MSx0aGlzLnByb2dyYW09eCx0aGlzLnZlcnRleFNoYWRlcj1DLHRoaXMuZnJhZ21lbnRTaGFkZXI9dyx0aGlzfWxldCBkdT0wO2NsYXNzIGZ1e2NvbnN0cnVjdG9yKCl7dGhpcy5zaGFkZXJDYWNoZT1uZXcgTWFwLHRoaXMubWF0ZXJpYWxDYWNoZT1uZXcgTWFwfXVwZGF0ZShlKXtjb25zdCB0PWUudmVydGV4U2hhZGVyLGk9ZS5mcmFnbWVudFNoYWRlcixyPXRoaXMuX2dldFNoYWRlclN0YWdlKHQpLHM9dGhpcy5fZ2V0U2hhZGVyU3RhZ2UoaSksbz10aGlzLl9nZXRTaGFkZXJDYWNoZUZvck1hdGVyaWFsKGUpO3JldHVybiBvLmhhcyhyKT09PSExJiYoby5hZGQociksci51c2VkVGltZXMrKyksby5oYXMocyk9PT0hMSYmKG8uYWRkKHMpLHMudXNlZFRpbWVzKyspLHRoaXN9cmVtb3ZlKGUpe2NvbnN0IHQ9dGhpcy5tYXRlcmlhbENhY2hlLmdldChlKTtmb3IoY29uc3QgaSBvZiB0KWkudXNlZFRpbWVzLS0saS51c2VkVGltZXM9PT0wJiZ0aGlzLnNoYWRlckNhY2hlLmRlbGV0ZShpLmNvZGUpO3JldHVybiB0aGlzLm1hdGVyaWFsQ2FjaGUuZGVsZXRlKGUpLHRoaXN9Z2V0VmVydGV4U2hhZGVySUQoZSl7cmV0dXJuIHRoaXMuX2dldFNoYWRlclN0YWdlKGUudmVydGV4U2hhZGVyKS5pZH1nZXRGcmFnbWVudFNoYWRlcklEKGUpe3JldHVybiB0aGlzLl9nZXRTaGFkZXJTdGFnZShlLmZyYWdtZW50U2hhZGVyKS5pZH1kaXNwb3NlKCl7dGhpcy5zaGFkZXJDYWNoZS5jbGVhcigpLHRoaXMubWF0ZXJpYWxDYWNoZS5jbGVhcigpfV9nZXRTaGFkZXJDYWNoZUZvck1hdGVyaWFsKGUpe2NvbnN0IHQ9dGhpcy5tYXRlcmlhbENhY2hlO2xldCBpPXQuZ2V0KGUpO3JldHVybiBpPT09dm9pZCAwJiYoaT1uZXcgU2V0LHQuc2V0KGUsaSkpLGl9X2dldFNoYWRlclN0YWdlKGUpe2NvbnN0IHQ9dGhpcy5zaGFkZXJDYWNoZTtsZXQgaT10LmdldChlKTtyZXR1cm4gaT09PXZvaWQgMCYmKGk9bmV3IHB1KGUpLHQuc2V0KGUsaSkpLGl9fWNsYXNzIHB1e2NvbnN0cnVjdG9yKGUpe3RoaXMuaWQ9ZHUrKyx0aGlzLmNvZGU9ZSx0aGlzLnVzZWRUaW1lcz0wfX1mdW5jdGlvbiBtdShuLGUsdCxpLHIscyxvKXtjb25zdCBhPW5ldyBJcixsPW5ldyBmdSxjPW5ldyBTZXQsdT1bXSxkPXIubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixmPXIudmVydGV4VGV4dHVyZXM7bGV0IHA9ci5wcmVjaXNpb247Y29uc3QgZz17TWVzaERlcHRoTWF0ZXJpYWw6ImRlcHRoIixNZXNoRGlzdGFuY2VNYXRlcmlhbDoiZGlzdGFuY2VSR0JBIixNZXNoTm9ybWFsTWF0ZXJpYWw6Im5vcm1hbCIsTWVzaEJhc2ljTWF0ZXJpYWw6ImJhc2ljIixNZXNoTGFtYmVydE1hdGVyaWFsOiJsYW1iZXJ0IixNZXNoUGhvbmdNYXRlcmlhbDoicGhvbmciLE1lc2hUb29uTWF0ZXJpYWw6InRvb24iLE1lc2hTdGFuZGFyZE1hdGVyaWFsOiJwaHlzaWNhbCIsTWVzaFBoeXNpY2FsTWF0ZXJpYWw6InBoeXNpY2FsIixNZXNoTWF0Y2FwTWF0ZXJpYWw6Im1hdGNhcCIsTGluZUJhc2ljTWF0ZXJpYWw6ImJhc2ljIixMaW5lRGFzaGVkTWF0ZXJpYWw6ImRhc2hlZCIsUG9pbnRzTWF0ZXJpYWw6InBvaW50cyIsU2hhZG93TWF0ZXJpYWw6InNoYWRvdyIsU3ByaXRlTWF0ZXJpYWw6InNwcml0ZSJ9O2Z1bmN0aW9uIHgoRSl7cmV0dXJuIGMuYWRkKEUpLEU9PT0wPyJ1diI6YHV2JHtFfWB9ZnVuY3Rpb24gbShFLFMsUixxLHope2NvbnN0IFc9cS5mb2csWj16Lmdlb21ldHJ5LFY9RS5pc01lc2hTdGFuZGFyZE1hdGVyaWFsP3EuZW52aXJvbm1lbnQ6bnVsbCxRPShFLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWw/dDplKS5nZXQoRS5lbnZNYXB8fFYpLEg9USYmUS5tYXBwaW5nPT09MzA2P1EuaW1hZ2UuaGVpZ2h0Om51bGwsaWU9Z1tFLnR5cGVdO0UucHJlY2lzaW9uIT09bnVsbCYmKHA9ci5nZXRNYXhQcmVjaXNpb24oRS5wcmVjaXNpb24pLHAhPT1FLnByZWNpc2lvbiYmY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFByb2dyYW0uZ2V0UGFyYW1ldGVyczoiLEUucHJlY2lzaW9uLCJub3Qgc3VwcG9ydGVkLCB1c2luZyIscCwiaW5zdGVhZC4iKSk7Y29uc3QgY2U9Wi5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb258fFoubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbHx8Wi5tb3JwaEF0dHJpYnV0ZXMuY29sb3IseGU9Y2UhPT12b2lkIDA/Y2UubGVuZ3RoOjA7bGV0IFVlPTA7Wi5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24hPT12b2lkIDAmJihVZT0xKSxaLm1vcnBoQXR0cmlidXRlcy5ub3JtYWwhPT12b2lkIDAmJihVZT0yKSxaLm1vcnBoQXR0cmlidXRlcy5jb2xvciE9PXZvaWQgMCYmKFVlPTMpO2xldCBZZSxYLGVlLGdlO2lmKGllKXtjb25zdCBYZT16dFtpZV07WWU9WGUudmVydGV4U2hhZGVyLFg9WGUuZnJhZ21lbnRTaGFkZXJ9ZWxzZSBZZT1FLnZlcnRleFNoYWRlcixYPUUuZnJhZ21lbnRTaGFkZXIsbC51cGRhdGUoRSksZWU9bC5nZXRWZXJ0ZXhTaGFkZXJJRChFKSxnZT1sLmdldEZyYWdtZW50U2hhZGVySUQoRSk7Y29uc3QgcmU9bi5nZXRSZW5kZXJUYXJnZXQoKSx5ZT1uLnN0YXRlLmJ1ZmZlcnMuZGVwdGguZ2V0UmV2ZXJzZWQoKSx3ZT16LmlzSW5zdGFuY2VkTWVzaD09PSEwLEZlPXouaXNCYXRjaGVkTWVzaD09PSEwLG50PSEhRS5tYXAsemU9ISFFLm1hdGNhcCxhdD0hIVEsVT0hIUUuYW9NYXAsUHQ9ISFFLmxpZ2h0TWFwLEllPSEhRS5idW1wTWFwLE5lPSEhRS5ub3JtYWxNYXAsU2U9ISFFLmRpc3BsYWNlbWVudE1hcCxqZT0hIUUuZW1pc3NpdmVNYXAsTWU9ISFFLm1ldGFsbmVzc01hcCxBPSEhRS5yb3VnaG5lc3NNYXAsdj1FLmFuaXNvdHJvcHk+MCxJPUUuY2xlYXJjb2F0PjAsWT1FLmRpc3BlcnNpb24+MCxLPUUuaXJpZGVzY2VuY2U+MCxrPUUuc2hlZW4+MCxfZT1FLnRyYW5zbWlzc2lvbj4wLHNlPXYmJiEhRS5hbmlzb3Ryb3B5TWFwLHVlPUkmJiEhRS5jbGVhcmNvYXRNYXAsR2U9SSYmISFFLmNsZWFyY29hdE5vcm1hbE1hcCxqPUkmJiEhRS5jbGVhcmNvYXRSb3VnaG5lc3NNYXAsaGU9SyYmISFFLmlyaWRlc2NlbmNlTWFwLEVlPUsmJiEhRS5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCxUZT1rJiYhIUUuc2hlZW5Db2xvck1hcCxkZT1rJiYhIUUuc2hlZW5Sb3VnaG5lc3NNYXAsT2U9ISFFLnNwZWN1bGFyTWFwLExlPSEhRS5zcGVjdWxhckNvbG9yTWFwLEtlPSEhRS5zcGVjdWxhckludGVuc2l0eU1hcCxQPV9lJiYhIUUudHJhbnNtaXNzaW9uTWFwLG5lPV9lJiYhIUUudGhpY2tuZXNzTWFwLEc9ISFFLmdyYWRpZW50TWFwLCQ9ISFFLmFscGhhTWFwLGxlPUUuYWxwaGFUZXN0PjAsYWU9ISFFLmFscGhhSGFzaCxSZT0hIUUuZXh0ZW5zaW9ucztsZXQgaXQ9MDtFLnRvbmVNYXBwZWQmJihyZT09PW51bGx8fHJlLmlzWFJSZW5kZXJUYXJnZXQ9PT0hMCkmJihpdD1uLnRvbmVNYXBwaW5nKTtjb25zdCBtdD17c2hhZGVySUQ6aWUsc2hhZGVyVHlwZTpFLnR5cGUsc2hhZGVyTmFtZTpFLm5hbWUsdmVydGV4U2hhZGVyOlllLGZyYWdtZW50U2hhZGVyOlgsZGVmaW5lczpFLmRlZmluZXMsY3VzdG9tVmVydGV4U2hhZGVySUQ6ZWUsY3VzdG9tRnJhZ21lbnRTaGFkZXJJRDpnZSxpc1Jhd1NoYWRlck1hdGVyaWFsOkUuaXNSYXdTaGFkZXJNYXRlcmlhbD09PSEwLGdsc2xWZXJzaW9uOkUuZ2xzbFZlcnNpb24scHJlY2lzaW9uOnAsYmF0Y2hpbmc6RmUsYmF0Y2hpbmdDb2xvcjpGZSYmei5fY29sb3JzVGV4dHVyZSE9PW51bGwsaW5zdGFuY2luZzp3ZSxpbnN0YW5jaW5nQ29sb3I6d2UmJnouaW5zdGFuY2VDb2xvciE9PW51bGwsaW5zdGFuY2luZ01vcnBoOndlJiZ6Lm1vcnBoVGV4dHVyZSE9PW51bGwsc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczpmLG91dHB1dENvbG9yU3BhY2U6cmU9PT1udWxsP24ub3V0cHV0Q29sb3JTcGFjZTpyZS5pc1hSUmVuZGVyVGFyZ2V0PT09ITA/cmUudGV4dHVyZS5jb2xvclNwYWNlOnhuLGFscGhhVG9Db3ZlcmFnZTohIUUuYWxwaGFUb0NvdmVyYWdlLG1hcDpudCxtYXRjYXA6emUsZW52TWFwOmF0LGVudk1hcE1vZGU6YXQmJlEubWFwcGluZyxlbnZNYXBDdWJlVVZIZWlnaHQ6SCxhb01hcDpVLGxpZ2h0TWFwOlB0LGJ1bXBNYXA6SWUsbm9ybWFsTWFwOk5lLGRpc3BsYWNlbWVudE1hcDpmJiZTZSxlbWlzc2l2ZU1hcDpqZSxub3JtYWxNYXBPYmplY3RTcGFjZTpOZSYmRS5ub3JtYWxNYXBUeXBlPT09MSxub3JtYWxNYXBUYW5nZW50U3BhY2U6TmUmJkUubm9ybWFsTWFwVHlwZT09PTAsbWV0YWxuZXNzTWFwOk1lLHJvdWdobmVzc01hcDpBLGFuaXNvdHJvcHk6dixhbmlzb3Ryb3B5TWFwOnNlLGNsZWFyY29hdDpJLGNsZWFyY29hdE1hcDp1ZSxjbGVhcmNvYXROb3JtYWxNYXA6R2UsY2xlYXJjb2F0Um91Z2huZXNzTWFwOmosZGlzcGVyc2lvbjpZLGlyaWRlc2NlbmNlOkssaXJpZGVzY2VuY2VNYXA6aGUsaXJpZGVzY2VuY2VUaGlja25lc3NNYXA6RWUsc2hlZW46ayxzaGVlbkNvbG9yTWFwOlRlLHNoZWVuUm91Z2huZXNzTWFwOmRlLHNwZWN1bGFyTWFwOk9lLHNwZWN1bGFyQ29sb3JNYXA6TGUsc3BlY3VsYXJJbnRlbnNpdHlNYXA6S2UsdHJhbnNtaXNzaW9uOl9lLHRyYW5zbWlzc2lvbk1hcDpQLHRoaWNrbmVzc01hcDpuZSxncmFkaWVudE1hcDpHLG9wYXF1ZTpFLnRyYW5zcGFyZW50PT09ITEmJkUuYmxlbmRpbmc9PT0xJiZFLmFscGhhVG9Db3ZlcmFnZT09PSExLGFscGhhTWFwOiQsYWxwaGFUZXN0OmxlLGFscGhhSGFzaDphZSxjb21iaW5lOkUuY29tYmluZSxtYXBVdjpudCYmeChFLm1hcC5jaGFubmVsKSxhb01hcFV2OlUmJngoRS5hb01hcC5jaGFubmVsKSxsaWdodE1hcFV2OlB0JiZ4KEUubGlnaHRNYXAuY2hhbm5lbCksYnVtcE1hcFV2OkllJiZ4KEUuYnVtcE1hcC5jaGFubmVsKSxub3JtYWxNYXBVdjpOZSYmeChFLm5vcm1hbE1hcC5jaGFubmVsKSxkaXNwbGFjZW1lbnRNYXBVdjpTZSYmeChFLmRpc3BsYWNlbWVudE1hcC5jaGFubmVsKSxlbWlzc2l2ZU1hcFV2OmplJiZ4KEUuZW1pc3NpdmVNYXAuY2hhbm5lbCksbWV0YWxuZXNzTWFwVXY6TWUmJngoRS5tZXRhbG5lc3NNYXAuY2hhbm5lbCkscm91Z2huZXNzTWFwVXY6QSYmeChFLnJvdWdobmVzc01hcC5jaGFubmVsKSxhbmlzb3Ryb3B5TWFwVXY6c2UmJngoRS5hbmlzb3Ryb3B5TWFwLmNoYW5uZWwpLGNsZWFyY29hdE1hcFV2OnVlJiZ4KEUuY2xlYXJjb2F0TWFwLmNoYW5uZWwpLGNsZWFyY29hdE5vcm1hbE1hcFV2OkdlJiZ4KEUuY2xlYXJjb2F0Tm9ybWFsTWFwLmNoYW5uZWwpLGNsZWFyY29hdFJvdWdobmVzc01hcFV2OmomJngoRS5jbGVhcmNvYXRSb3VnaG5lc3NNYXAuY2hhbm5lbCksaXJpZGVzY2VuY2VNYXBVdjpoZSYmeChFLmlyaWRlc2NlbmNlTWFwLmNoYW5uZWwpLGlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXY6RWUmJngoRS5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcC5jaGFubmVsKSxzaGVlbkNvbG9yTWFwVXY6VGUmJngoRS5zaGVlbkNvbG9yTWFwLmNoYW5uZWwpLHNoZWVuUm91Z2huZXNzTWFwVXY6ZGUmJngoRS5zaGVlblJvdWdobmVzc01hcC5jaGFubmVsKSxzcGVjdWxhck1hcFV2Ok9lJiZ4KEUuc3BlY3VsYXJNYXAuY2hhbm5lbCksc3BlY3VsYXJDb2xvck1hcFV2OkxlJiZ4KEUuc3BlY3VsYXJDb2xvck1hcC5jaGFubmVsKSxzcGVjdWxhckludGVuc2l0eU1hcFV2OktlJiZ4KEUuc3BlY3VsYXJJbnRlbnNpdHlNYXAuY2hhbm5lbCksdHJhbnNtaXNzaW9uTWFwVXY6UCYmeChFLnRyYW5zbWlzc2lvbk1hcC5jaGFubmVsKSx0aGlja25lc3NNYXBVdjpuZSYmeChFLnRoaWNrbmVzc01hcC5jaGFubmVsKSxhbHBoYU1hcFV2OiQmJngoRS5hbHBoYU1hcC5jaGFubmVsKSx2ZXJ0ZXhUYW5nZW50czohIVouYXR0cmlidXRlcy50YW5nZW50JiYoTmV8fHYpLHZlcnRleENvbG9yczpFLnZlcnRleENvbG9ycyx2ZXJ0ZXhBbHBoYXM6RS52ZXJ0ZXhDb2xvcnM9PT0hMCYmISFaLmF0dHJpYnV0ZXMuY29sb3ImJlouYXR0cmlidXRlcy5jb2xvci5pdGVtU2l6ZT09PTQscG9pbnRzVXZzOnouaXNQb2ludHM9PT0hMCYmISFaLmF0dHJpYnV0ZXMudXYmJihudHx8JCksZm9nOiEhVyx1c2VGb2c6RS5mb2c9PT0hMCxmb2dFeHAyOiEhVyYmVy5pc0ZvZ0V4cDIsZmxhdFNoYWRpbmc6RS5mbGF0U2hhZGluZz09PSEwLHNpemVBdHRlbnVhdGlvbjpFLnNpemVBdHRlbnVhdGlvbj09PSEwLGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6ZCxyZXZlcnNlRGVwdGhCdWZmZXI6eWUsc2tpbm5pbmc6ei5pc1NraW5uZWRNZXNoPT09ITAsbW9ycGhUYXJnZXRzOloubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uIT09dm9pZCAwLG1vcnBoTm9ybWFsczpaLm1vcnBoQXR0cmlidXRlcy5ub3JtYWwhPT12b2lkIDAsbW9ycGhDb2xvcnM6Wi5tb3JwaEF0dHJpYnV0ZXMuY29sb3IhPT12b2lkIDAsbW9ycGhUYXJnZXRzQ291bnQ6eGUsbW9ycGhUZXh0dXJlU3RyaWRlOlVlLG51bURpckxpZ2h0czpTLmRpcmVjdGlvbmFsLmxlbmd0aCxudW1Qb2ludExpZ2h0czpTLnBvaW50Lmxlbmd0aCxudW1TcG90TGlnaHRzOlMuc3BvdC5sZW5ndGgsbnVtU3BvdExpZ2h0TWFwczpTLnNwb3RMaWdodE1hcC5sZW5ndGgsbnVtUmVjdEFyZWFMaWdodHM6Uy5yZWN0QXJlYS5sZW5ndGgsbnVtSGVtaUxpZ2h0czpTLmhlbWkubGVuZ3RoLG51bURpckxpZ2h0U2hhZG93czpTLmRpcmVjdGlvbmFsU2hhZG93TWFwLmxlbmd0aCxudW1Qb2ludExpZ2h0U2hhZG93czpTLnBvaW50U2hhZG93TWFwLmxlbmd0aCxudW1TcG90TGlnaHRTaGFkb3dzOlMuc3BvdFNoYWRvd01hcC5sZW5ndGgsbnVtU3BvdExpZ2h0U2hhZG93c1dpdGhNYXBzOlMubnVtU3BvdExpZ2h0U2hhZG93c1dpdGhNYXBzLG51bUxpZ2h0UHJvYmVzOlMubnVtTGlnaHRQcm9iZXMsbnVtQ2xpcHBpbmdQbGFuZXM6by5udW1QbGFuZXMsbnVtQ2xpcEludGVyc2VjdGlvbjpvLm51bUludGVyc2VjdGlvbixkaXRoZXJpbmc6RS5kaXRoZXJpbmcsc2hhZG93TWFwRW5hYmxlZDpuLnNoYWRvd01hcC5lbmFibGVkJiZSLmxlbmd0aD4wLHNoYWRvd01hcFR5cGU6bi5zaGFkb3dNYXAudHlwZSx0b25lTWFwcGluZzppdCxkZWNvZGVWaWRlb1RleHR1cmU6bnQmJkUubWFwLmlzVmlkZW9UZXh0dXJlPT09ITAmJkJlLmdldFRyYW5zZmVyKEUubWFwLmNvbG9yU3BhY2UpPT09cWUsZGVjb2RlVmlkZW9UZXh0dXJlRW1pc3NpdmU6amUmJkUuZW1pc3NpdmVNYXAuaXNWaWRlb1RleHR1cmU9PT0hMCYmQmUuZ2V0VHJhbnNmZXIoRS5lbWlzc2l2ZU1hcC5jb2xvclNwYWNlKT09PXFlLHByZW11bHRpcGxpZWRBbHBoYTpFLnByZW11bHRpcGxpZWRBbHBoYSxkb3VibGVTaWRlZDpFLnNpZGU9PT0yLGZsaXBTaWRlZDpFLnNpZGU9PT0xLHVzZURlcHRoUGFja2luZzpFLmRlcHRoUGFja2luZz49MCxkZXB0aFBhY2tpbmc6RS5kZXB0aFBhY2tpbmd8fDAsaW5kZXgwQXR0cmlidXRlTmFtZTpFLmluZGV4MEF0dHJpYnV0ZU5hbWUsZXh0ZW5zaW9uQ2xpcEN1bGxEaXN0YW5jZTpSZSYmRS5leHRlbnNpb25zLmNsaXBDdWxsRGlzdGFuY2U9PT0hMCYmaS5oYXMoIldFQkdMX2NsaXBfY3VsbF9kaXN0YW5jZSIpLGV4dGVuc2lvbk11bHRpRHJhdzooUmUmJkUuZXh0ZW5zaW9ucy5tdWx0aURyYXc9PT0hMHx8RmUpJiZpLmhhcygiV0VCR0xfbXVsdGlfZHJhdyIpLHJlbmRlcmVyRXh0ZW5zaW9uUGFyYWxsZWxTaGFkZXJDb21waWxlOmkuaGFzKCJLSFJfcGFyYWxsZWxfc2hhZGVyX2NvbXBpbGUiKSxjdXN0b21Qcm9ncmFtQ2FjaGVLZXk6RS5jdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKX07cmV0dXJuIG10LnZlcnRleFV2MXM9Yy5oYXMoMSksbXQudmVydGV4VXYycz1jLmhhcygyKSxtdC52ZXJ0ZXhVdjNzPWMuaGFzKDMpLGMuY2xlYXIoKSxtdH1mdW5jdGlvbiBoKEUpe2NvbnN0IFM9W107aWYoRS5zaGFkZXJJRD9TLnB1c2goRS5zaGFkZXJJRCk6KFMucHVzaChFLmN1c3RvbVZlcnRleFNoYWRlcklEKSxTLnB1c2goRS5jdXN0b21GcmFnbWVudFNoYWRlcklEKSksRS5kZWZpbmVzIT09dm9pZCAwKWZvcihjb25zdCBSIGluIEUuZGVmaW5lcylTLnB1c2goUiksUy5wdXNoKEUuZGVmaW5lc1tSXSk7cmV0dXJuIEUuaXNSYXdTaGFkZXJNYXRlcmlhbD09PSExJiYoVChTLEUpLHkoUyxFKSxTLnB1c2gobi5vdXRwdXRDb2xvclNwYWNlKSksUy5wdXNoKEUuY3VzdG9tUHJvZ3JhbUNhY2hlS2V5KSxTLmpvaW4oKX1mdW5jdGlvbiBUKEUsUyl7RS5wdXNoKFMucHJlY2lzaW9uKSxFLnB1c2goUy5vdXRwdXRDb2xvclNwYWNlKSxFLnB1c2goUy5lbnZNYXBNb2RlKSxFLnB1c2goUy5lbnZNYXBDdWJlVVZIZWlnaHQpLEUucHVzaChTLm1hcFV2KSxFLnB1c2goUy5hbHBoYU1hcFV2KSxFLnB1c2goUy5saWdodE1hcFV2KSxFLnB1c2goUy5hb01hcFV2KSxFLnB1c2goUy5idW1wTWFwVXYpLEUucHVzaChTLm5vcm1hbE1hcFV2KSxFLnB1c2goUy5kaXNwbGFjZW1lbnRNYXBVdiksRS5wdXNoKFMuZW1pc3NpdmVNYXBVdiksRS5wdXNoKFMubWV0YWxuZXNzTWFwVXYpLEUucHVzaChTLnJvdWdobmVzc01hcFV2KSxFLnB1c2goUy5hbmlzb3Ryb3B5TWFwVXYpLEUucHVzaChTLmNsZWFyY29hdE1hcFV2KSxFLnB1c2goUy5jbGVhcmNvYXROb3JtYWxNYXBVdiksRS5wdXNoKFMuY2xlYXJjb2F0Um91Z2huZXNzTWFwVXYpLEUucHVzaChTLmlyaWRlc2NlbmNlTWFwVXYpLEUucHVzaChTLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXYpLEUucHVzaChTLnNoZWVuQ29sb3JNYXBVdiksRS5wdXNoKFMuc2hlZW5Sb3VnaG5lc3NNYXBVdiksRS5wdXNoKFMuc3BlY3VsYXJNYXBVdiksRS5wdXNoKFMuc3BlY3VsYXJDb2xvck1hcFV2KSxFLnB1c2goUy5zcGVjdWxhckludGVuc2l0eU1hcFV2KSxFLnB1c2goUy50cmFuc21pc3Npb25NYXBVdiksRS5wdXNoKFMudGhpY2tuZXNzTWFwVXYpLEUucHVzaChTLmNvbWJpbmUpLEUucHVzaChTLmZvZ0V4cDIpLEUucHVzaChTLnNpemVBdHRlbnVhdGlvbiksRS5wdXNoKFMubW9ycGhUYXJnZXRzQ291bnQpLEUucHVzaChTLm1vcnBoQXR0cmlidXRlQ291bnQpLEUucHVzaChTLm51bURpckxpZ2h0cyksRS5wdXNoKFMubnVtUG9pbnRMaWdodHMpLEUucHVzaChTLm51bVNwb3RMaWdodHMpLEUucHVzaChTLm51bVNwb3RMaWdodE1hcHMpLEUucHVzaChTLm51bUhlbWlMaWdodHMpLEUucHVzaChTLm51bVJlY3RBcmVhTGlnaHRzKSxFLnB1c2goUy5udW1EaXJMaWdodFNoYWRvd3MpLEUucHVzaChTLm51bVBvaW50TGlnaHRTaGFkb3dzKSxFLnB1c2goUy5udW1TcG90TGlnaHRTaGFkb3dzKSxFLnB1c2goUy5udW1TcG90TGlnaHRTaGFkb3dzV2l0aE1hcHMpLEUucHVzaChTLm51bUxpZ2h0UHJvYmVzKSxFLnB1c2goUy5zaGFkb3dNYXBUeXBlKSxFLnB1c2goUy50b25lTWFwcGluZyksRS5wdXNoKFMubnVtQ2xpcHBpbmdQbGFuZXMpLEUucHVzaChTLm51bUNsaXBJbnRlcnNlY3Rpb24pLEUucHVzaChTLmRlcHRoUGFja2luZyl9ZnVuY3Rpb24geShFLFMpe2EuZGlzYWJsZUFsbCgpLFMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyYmYS5lbmFibGUoMCksUy5pbnN0YW5jaW5nJiZhLmVuYWJsZSgxKSxTLmluc3RhbmNpbmdDb2xvciYmYS5lbmFibGUoMiksUy5pbnN0YW5jaW5nTW9ycGgmJmEuZW5hYmxlKDMpLFMubWF0Y2FwJiZhLmVuYWJsZSg0KSxTLmVudk1hcCYmYS5lbmFibGUoNSksUy5ub3JtYWxNYXBPYmplY3RTcGFjZSYmYS5lbmFibGUoNiksUy5ub3JtYWxNYXBUYW5nZW50U3BhY2UmJmEuZW5hYmxlKDcpLFMuY2xlYXJjb2F0JiZhLmVuYWJsZSg4KSxTLmlyaWRlc2NlbmNlJiZhLmVuYWJsZSg5KSxTLmFscGhhVGVzdCYmYS5lbmFibGUoMTApLFMudmVydGV4Q29sb3JzJiZhLmVuYWJsZSgxMSksUy52ZXJ0ZXhBbHBoYXMmJmEuZW5hYmxlKDEyKSxTLnZlcnRleFV2MXMmJmEuZW5hYmxlKDEzKSxTLnZlcnRleFV2MnMmJmEuZW5hYmxlKDE0KSxTLnZlcnRleFV2M3MmJmEuZW5hYmxlKDE1KSxTLnZlcnRleFRhbmdlbnRzJiZhLmVuYWJsZSgxNiksUy5hbmlzb3Ryb3B5JiZhLmVuYWJsZSgxNyksUy5hbHBoYUhhc2gmJmEuZW5hYmxlKDE4KSxTLmJhdGNoaW5nJiZhLmVuYWJsZSgxOSksUy5kaXNwZXJzaW9uJiZhLmVuYWJsZSgyMCksUy5iYXRjaGluZ0NvbG9yJiZhLmVuYWJsZSgyMSksRS5wdXNoKGEubWFzayksYS5kaXNhYmxlQWxsKCksUy5mb2cmJmEuZW5hYmxlKDApLFMudXNlRm9nJiZhLmVuYWJsZSgxKSxTLmZsYXRTaGFkaW5nJiZhLmVuYWJsZSgyKSxTLmxvZ2FyaXRobWljRGVwdGhCdWZmZXImJmEuZW5hYmxlKDMpLFMucmV2ZXJzZURlcHRoQnVmZmVyJiZhLmVuYWJsZSg0KSxTLnNraW5uaW5nJiZhLmVuYWJsZSg1KSxTLm1vcnBoVGFyZ2V0cyYmYS5lbmFibGUoNiksUy5tb3JwaE5vcm1hbHMmJmEuZW5hYmxlKDcpLFMubW9ycGhDb2xvcnMmJmEuZW5hYmxlKDgpLFMucHJlbXVsdGlwbGllZEFscGhhJiZhLmVuYWJsZSg5KSxTLnNoYWRvd01hcEVuYWJsZWQmJmEuZW5hYmxlKDEwKSxTLmRvdWJsZVNpZGVkJiZhLmVuYWJsZSgxMSksUy5mbGlwU2lkZWQmJmEuZW5hYmxlKDEyKSxTLnVzZURlcHRoUGFja2luZyYmYS5lbmFibGUoMTMpLFMuZGl0aGVyaW5nJiZhLmVuYWJsZSgxNCksUy50cmFuc21pc3Npb24mJmEuZW5hYmxlKDE1KSxTLnNoZWVuJiZhLmVuYWJsZSgxNiksUy5vcGFxdWUmJmEuZW5hYmxlKDE3KSxTLnBvaW50c1V2cyYmYS5lbmFibGUoMTgpLFMuZGVjb2RlVmlkZW9UZXh0dXJlJiZhLmVuYWJsZSgxOSksUy5kZWNvZGVWaWRlb1RleHR1cmVFbWlzc2l2ZSYmYS5lbmFibGUoMjApLFMuYWxwaGFUb0NvdmVyYWdlJiZhLmVuYWJsZSgyMSksRS5wdXNoKGEubWFzayl9ZnVuY3Rpb24gXyhFKXtjb25zdCBTPWdbRS50eXBlXTtsZXQgUjtpZihTKXtjb25zdCBxPXp0W1NdO1I9RGEuY2xvbmUocS51bmlmb3Jtcyl9ZWxzZSBSPUUudW5pZm9ybXM7cmV0dXJuIFJ9ZnVuY3Rpb24gQyhFLFMpe2xldCBSO2ZvcihsZXQgcT0wLHo9dS5sZW5ndGg7cTx6O3ErKyl7Y29uc3QgVz11W3FdO2lmKFcuY2FjaGVLZXk9PT1TKXtSPVcsKytSLnVzZWRUaW1lczticmVha319cmV0dXJuIFI9PT12b2lkIDAmJihSPW5ldyBodShuLFMsRSxzKSx1LnB1c2goUikpLFJ9ZnVuY3Rpb24gdyhFKXtpZigtLUUudXNlZFRpbWVzPT09MCl7Y29uc3QgUz11LmluZGV4T2YoRSk7dVtTXT11W3UubGVuZ3RoLTFdLHUucG9wKCksRS5kZXN0cm95KCl9fWZ1bmN0aW9uIGIoRSl7bC5yZW1vdmUoRSl9ZnVuY3Rpb24gRigpe2wuZGlzcG9zZSgpfXJldHVybntnZXRQYXJhbWV0ZXJzOm0sZ2V0UHJvZ3JhbUNhY2hlS2V5OmgsZ2V0VW5pZm9ybXM6XyxhY3F1aXJlUHJvZ3JhbTpDLHJlbGVhc2VQcm9ncmFtOncscmVsZWFzZVNoYWRlckNhY2hlOmIscHJvZ3JhbXM6dSxkaXNwb3NlOkZ9fWZ1bmN0aW9uIGd1KCl7bGV0IG49bmV3IFdlYWtNYXA7ZnVuY3Rpb24gZShvKXtyZXR1cm4gbi5oYXMobyl9ZnVuY3Rpb24gdChvKXtsZXQgYT1uLmdldChvKTtyZXR1cm4gYT09PXZvaWQgMCYmKGE9e30sbi5zZXQobyxhKSksYX1mdW5jdGlvbiBpKG8pe24uZGVsZXRlKG8pfWZ1bmN0aW9uIHIobyxhLGwpe24uZ2V0KG8pW2FdPWx9ZnVuY3Rpb24gcygpe249bmV3IFdlYWtNYXB9cmV0dXJue2hhczplLGdldDp0LHJlbW92ZTppLHVwZGF0ZTpyLGRpc3Bvc2U6c319ZnVuY3Rpb24gX3UobixlKXtyZXR1cm4gbi5ncm91cE9yZGVyIT09ZS5ncm91cE9yZGVyP24uZ3JvdXBPcmRlci1lLmdyb3VwT3JkZXI6bi5yZW5kZXJPcmRlciE9PWUucmVuZGVyT3JkZXI/bi5yZW5kZXJPcmRlci1lLnJlbmRlck9yZGVyOm4ubWF0ZXJpYWwuaWQhPT1lLm1hdGVyaWFsLmlkP24ubWF0ZXJpYWwuaWQtZS5tYXRlcmlhbC5pZDpuLnohPT1lLno/bi56LWUuejpuLmlkLWUuaWR9ZnVuY3Rpb24gYnMobixlKXtyZXR1cm4gbi5ncm91cE9yZGVyIT09ZS5ncm91cE9yZGVyP24uZ3JvdXBPcmRlci1lLmdyb3VwT3JkZXI6bi5yZW5kZXJPcmRlciE9PWUucmVuZGVyT3JkZXI/bi5yZW5kZXJPcmRlci1lLnJlbmRlck9yZGVyOm4ueiE9PWUuej9lLnotbi56Om4uaWQtZS5pZH1mdW5jdGlvbiBScygpe2NvbnN0IG49W107bGV0IGU9MDtjb25zdCB0PVtdLGk9W10scj1bXTtmdW5jdGlvbiBzKCl7ZT0wLHQubGVuZ3RoPTAsaS5sZW5ndGg9MCxyLmxlbmd0aD0wfWZ1bmN0aW9uIG8oZCxmLHAsZyx4LG0pe2xldCBoPW5bZV07cmV0dXJuIGg9PT12b2lkIDA/KGg9e2lkOmQuaWQsb2JqZWN0OmQsZ2VvbWV0cnk6ZixtYXRlcmlhbDpwLGdyb3VwT3JkZXI6ZyxyZW5kZXJPcmRlcjpkLnJlbmRlck9yZGVyLHo6eCxncm91cDptfSxuW2VdPWgpOihoLmlkPWQuaWQsaC5vYmplY3Q9ZCxoLmdlb21ldHJ5PWYsaC5tYXRlcmlhbD1wLGguZ3JvdXBPcmRlcj1nLGgucmVuZGVyT3JkZXI9ZC5yZW5kZXJPcmRlcixoLno9eCxoLmdyb3VwPW0pLGUrKyxofWZ1bmN0aW9uIGEoZCxmLHAsZyx4LG0pe2NvbnN0IGg9byhkLGYscCxnLHgsbSk7cC50cmFuc21pc3Npb24+MD9pLnB1c2goaCk6cC50cmFuc3BhcmVudD09PSEwP3IucHVzaChoKTp0LnB1c2goaCl9ZnVuY3Rpb24gbChkLGYscCxnLHgsbSl7Y29uc3QgaD1vKGQsZixwLGcseCxtKTtwLnRyYW5zbWlzc2lvbj4wP2kudW5zaGlmdChoKTpwLnRyYW5zcGFyZW50PT09ITA/ci51bnNoaWZ0KGgpOnQudW5zaGlmdChoKX1mdW5jdGlvbiBjKGQsZil7dC5sZW5ndGg+MSYmdC5zb3J0KGR8fF91KSxpLmxlbmd0aD4xJiZpLnNvcnQoZnx8YnMpLHIubGVuZ3RoPjEmJnIuc29ydChmfHxicyl9ZnVuY3Rpb24gdSgpe2ZvcihsZXQgZD1lLGY9bi5sZW5ndGg7ZDxmO2QrKyl7Y29uc3QgcD1uW2RdO2lmKHAuaWQ9PT1udWxsKWJyZWFrO3AuaWQ9bnVsbCxwLm9iamVjdD1udWxsLHAuZ2VvbWV0cnk9bnVsbCxwLm1hdGVyaWFsPW51bGwscC5ncm91cD1udWxsfX1yZXR1cm57b3BhcXVlOnQsdHJhbnNtaXNzaXZlOmksdHJhbnNwYXJlbnQ6cixpbml0OnMscHVzaDphLHVuc2hpZnQ6bCxmaW5pc2g6dSxzb3J0OmN9fWZ1bmN0aW9uIHZ1KCl7bGV0IG49bmV3IFdlYWtNYXA7ZnVuY3Rpb24gZShpLHIpe2NvbnN0IHM9bi5nZXQoaSk7bGV0IG87cmV0dXJuIHM9PT12b2lkIDA/KG89bmV3IFJzLG4uc2V0KGksW29dKSk6cj49cy5sZW5ndGg/KG89bmV3IFJzLHMucHVzaChvKSk6bz1zW3JdLG99ZnVuY3Rpb24gdCgpe249bmV3IFdlYWtNYXB9cmV0dXJue2dldDplLGRpc3Bvc2U6dH19ZnVuY3Rpb24geHUoKXtjb25zdCBuPXt9O3JldHVybntnZXQ6ZnVuY3Rpb24oZSl7aWYobltlLmlkXSE9PXZvaWQgMClyZXR1cm4gbltlLmlkXTtsZXQgdDtzd2l0Y2goZS50eXBlKXtjYXNlIkRpcmVjdGlvbmFsTGlnaHQiOnQ9e2RpcmVjdGlvbjpuZXcgTyxjb2xvcjpuZXcgVmV9O2JyZWFrO2Nhc2UiU3BvdExpZ2h0Ijp0PXtwb3NpdGlvbjpuZXcgTyxkaXJlY3Rpb246bmV3IE8sY29sb3I6bmV3IFZlLGRpc3RhbmNlOjAsY29uZUNvczowLHBlbnVtYnJhQ29zOjAsZGVjYXk6MH07YnJlYWs7Y2FzZSJQb2ludExpZ2h0Ijp0PXtwb3NpdGlvbjpuZXcgTyxjb2xvcjpuZXcgVmUsZGlzdGFuY2U6MCxkZWNheTowfTticmVhaztjYXNlIkhlbWlzcGhlcmVMaWdodCI6dD17ZGlyZWN0aW9uOm5ldyBPLHNreUNvbG9yOm5ldyBWZSxncm91bmRDb2xvcjpuZXcgVmV9O2JyZWFrO2Nhc2UiUmVjdEFyZWFMaWdodCI6dD17Y29sb3I6bmV3IFZlLHBvc2l0aW9uOm5ldyBPLGhhbGZXaWR0aDpuZXcgTyxoYWxmSGVpZ2h0Om5ldyBPfTticmVha31yZXR1cm4gbltlLmlkXT10LHR9fX1mdW5jdGlvbiBNdSgpe2NvbnN0IG49e307cmV0dXJue2dldDpmdW5jdGlvbihlKXtpZihuW2UuaWRdIT09dm9pZCAwKXJldHVybiBuW2UuaWRdO2xldCB0O3N3aXRjaChlLnR5cGUpe2Nhc2UiRGlyZWN0aW9uYWxMaWdodCI6dD17c2hhZG93SW50ZW5zaXR5OjEsc2hhZG93QmlhczowLHNoYWRvd05vcm1hbEJpYXM6MCxzaGFkb3dSYWRpdXM6MSxzaGFkb3dNYXBTaXplOm5ldyBQZX07YnJlYWs7Y2FzZSJTcG90TGlnaHQiOnQ9e3NoYWRvd0ludGVuc2l0eToxLHNoYWRvd0JpYXM6MCxzaGFkb3dOb3JtYWxCaWFzOjAsc2hhZG93UmFkaXVzOjEsc2hhZG93TWFwU2l6ZTpuZXcgUGV9O2JyZWFrO2Nhc2UiUG9pbnRMaWdodCI6dD17c2hhZG93SW50ZW5zaXR5OjEsc2hhZG93QmlhczowLHNoYWRvd05vcm1hbEJpYXM6MCxzaGFkb3dSYWRpdXM6MSxzaGFkb3dNYXBTaXplOm5ldyBQZSxzaGFkb3dDYW1lcmFOZWFyOjEsc2hhZG93Q2FtZXJhRmFyOjFlM307YnJlYWt9cmV0dXJuIG5bZS5pZF09dCx0fX19bGV0IFN1PTA7ZnVuY3Rpb24gRXUobixlKXtyZXR1cm4oZS5jYXN0U2hhZG93PzI6MCktKG4uY2FzdFNoYWRvdz8yOjApKyhlLm1hcD8xOjApLShuLm1hcD8xOjApfWZ1bmN0aW9uIHl1KG4pe2NvbnN0IGU9bmV3IHh1LHQ9TXUoKSxpPXt2ZXJzaW9uOjAsaGFzaDp7ZGlyZWN0aW9uYWxMZW5ndGg6LTEscG9pbnRMZW5ndGg6LTEsc3BvdExlbmd0aDotMSxyZWN0QXJlYUxlbmd0aDotMSxoZW1pTGVuZ3RoOi0xLG51bURpcmVjdGlvbmFsU2hhZG93czotMSxudW1Qb2ludFNoYWRvd3M6LTEsbnVtU3BvdFNoYWRvd3M6LTEsbnVtU3BvdE1hcHM6LTEsbnVtTGlnaHRQcm9iZXM6LTF9LGFtYmllbnQ6WzAsMCwwXSxwcm9iZTpbXSxkaXJlY3Rpb25hbDpbXSxkaXJlY3Rpb25hbFNoYWRvdzpbXSxkaXJlY3Rpb25hbFNoYWRvd01hcDpbXSxkaXJlY3Rpb25hbFNoYWRvd01hdHJpeDpbXSxzcG90OltdLHNwb3RMaWdodE1hcDpbXSxzcG90U2hhZG93OltdLHNwb3RTaGFkb3dNYXA6W10sc3BvdExpZ2h0TWF0cml4OltdLHJlY3RBcmVhOltdLHJlY3RBcmVhTFRDMTpudWxsLHJlY3RBcmVhTFRDMjpudWxsLHBvaW50OltdLHBvaW50U2hhZG93OltdLHBvaW50U2hhZG93TWFwOltdLHBvaW50U2hhZG93TWF0cml4OltdLGhlbWk6W10sbnVtU3BvdExpZ2h0U2hhZG93c1dpdGhNYXBzOjAsbnVtTGlnaHRQcm9iZXM6MH07Zm9yKGxldCBjPTA7Yzw5O2MrKylpLnByb2JlLnB1c2gobmV3IE8pO2NvbnN0IHI9bmV3IE8scz1uZXcgc3Qsbz1uZXcgc3Q7ZnVuY3Rpb24gYShjKXtsZXQgdT0wLGQ9MCxmPTA7Zm9yKGxldCBFPTA7RTw5O0UrKylpLnByb2JlW0VdLnNldCgwLDAsMCk7bGV0IHA9MCxnPTAseD0wLG09MCxoPTAsVD0wLHk9MCxfPTAsQz0wLHc9MCxiPTA7Yy5zb3J0KEV1KTtmb3IobGV0IEU9MCxTPWMubGVuZ3RoO0U8UztFKyspe2NvbnN0IFI9Y1tFXSxxPVIuY29sb3Isej1SLmludGVuc2l0eSxXPVIuZGlzdGFuY2UsWj1SLnNoYWRvdyYmUi5zaGFkb3cubWFwP1Iuc2hhZG93Lm1hcC50ZXh0dXJlOm51bGw7aWYoUi5pc0FtYmllbnRMaWdodCl1Kz1xLnIqeixkKz1xLmcqeixmKz1xLmIqejtlbHNlIGlmKFIuaXNMaWdodFByb2JlKXtmb3IobGV0IFY9MDtWPDk7VisrKWkucHJvYmVbVl0uYWRkU2NhbGVkVmVjdG9yKFIuc2guY29lZmZpY2llbnRzW1ZdLHopO2IrK31lbHNlIGlmKFIuaXNEaXJlY3Rpb25hbExpZ2h0KXtjb25zdCBWPWUuZ2V0KFIpO2lmKFYuY29sb3IuY29weShSLmNvbG9yKS5tdWx0aXBseVNjYWxhcihSLmludGVuc2l0eSksUi5jYXN0U2hhZG93KXtjb25zdCBRPVIuc2hhZG93LEg9dC5nZXQoUik7SC5zaGFkb3dJbnRlbnNpdHk9US5pbnRlbnNpdHksSC5zaGFkb3dCaWFzPVEuYmlhcyxILnNoYWRvd05vcm1hbEJpYXM9US5ub3JtYWxCaWFzLEguc2hhZG93UmFkaXVzPVEucmFkaXVzLEguc2hhZG93TWFwU2l6ZT1RLm1hcFNpemUsaS5kaXJlY3Rpb25hbFNoYWRvd1twXT1ILGkuZGlyZWN0aW9uYWxTaGFkb3dNYXBbcF09WixpLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4W3BdPVIuc2hhZG93Lm1hdHJpeCxUKyt9aS5kaXJlY3Rpb25hbFtwXT1WLHArK31lbHNlIGlmKFIuaXNTcG90TGlnaHQpe2NvbnN0IFY9ZS5nZXQoUik7Vi5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oUi5tYXRyaXhXb3JsZCksVi5jb2xvci5jb3B5KHEpLm11bHRpcGx5U2NhbGFyKHopLFYuZGlzdGFuY2U9VyxWLmNvbmVDb3M9TWF0aC5jb3MoUi5hbmdsZSksVi5wZW51bWJyYUNvcz1NYXRoLmNvcyhSLmFuZ2xlKigxLVIucGVudW1icmEpKSxWLmRlY2F5PVIuZGVjYXksaS5zcG90W3hdPVY7Y29uc3QgUT1SLnNoYWRvdztpZihSLm1hcCYmKGkuc3BvdExpZ2h0TWFwW0NdPVIubWFwLEMrKyxRLnVwZGF0ZU1hdHJpY2VzKFIpLFIuY2FzdFNoYWRvdyYmdysrKSxpLnNwb3RMaWdodE1hdHJpeFt4XT1RLm1hdHJpeCxSLmNhc3RTaGFkb3cpe2NvbnN0IEg9dC5nZXQoUik7SC5zaGFkb3dJbnRlbnNpdHk9US5pbnRlbnNpdHksSC5zaGFkb3dCaWFzPVEuYmlhcyxILnNoYWRvd05vcm1hbEJpYXM9US5ub3JtYWxCaWFzLEguc2hhZG93UmFkaXVzPVEucmFkaXVzLEguc2hhZG93TWFwU2l6ZT1RLm1hcFNpemUsaS5zcG90U2hhZG93W3hdPUgsaS5zcG90U2hhZG93TWFwW3hdPVosXysrfXgrK31lbHNlIGlmKFIuaXNSZWN0QXJlYUxpZ2h0KXtjb25zdCBWPWUuZ2V0KFIpO1YuY29sb3IuY29weShxKS5tdWx0aXBseVNjYWxhcih6KSxWLmhhbGZXaWR0aC5zZXQoUi53aWR0aCouNSwwLDApLFYuaGFsZkhlaWdodC5zZXQoMCxSLmhlaWdodCouNSwwKSxpLnJlY3RBcmVhW21dPVYsbSsrfWVsc2UgaWYoUi5pc1BvaW50TGlnaHQpe2NvbnN0IFY9ZS5nZXQoUik7aWYoVi5jb2xvci5jb3B5KFIuY29sb3IpLm11bHRpcGx5U2NhbGFyKFIuaW50ZW5zaXR5KSxWLmRpc3RhbmNlPVIuZGlzdGFuY2UsVi5kZWNheT1SLmRlY2F5LFIuY2FzdFNoYWRvdyl7Y29uc3QgUT1SLnNoYWRvdyxIPXQuZ2V0KFIpO0guc2hhZG93SW50ZW5zaXR5PVEuaW50ZW5zaXR5LEguc2hhZG93Qmlhcz1RLmJpYXMsSC5zaGFkb3dOb3JtYWxCaWFzPVEubm9ybWFsQmlhcyxILnNoYWRvd1JhZGl1cz1RLnJhZGl1cyxILnNoYWRvd01hcFNpemU9US5tYXBTaXplLEguc2hhZG93Q2FtZXJhTmVhcj1RLmNhbWVyYS5uZWFyLEguc2hhZG93Q2FtZXJhRmFyPVEuY2FtZXJhLmZhcixpLnBvaW50U2hhZG93W2ddPUgsaS5wb2ludFNoYWRvd01hcFtnXT1aLGkucG9pbnRTaGFkb3dNYXRyaXhbZ109Ui5zaGFkb3cubWF0cml4LHkrK31pLnBvaW50W2ddPVYsZysrfWVsc2UgaWYoUi5pc0hlbWlzcGhlcmVMaWdodCl7Y29uc3QgVj1lLmdldChSKTtWLnNreUNvbG9yLmNvcHkoUi5jb2xvcikubXVsdGlwbHlTY2FsYXIoeiksVi5ncm91bmRDb2xvci5jb3B5KFIuZ3JvdW5kQ29sb3IpLm11bHRpcGx5U2NhbGFyKHopLGkuaGVtaVtoXT1WLGgrK319bT4wJiYobi5oYXMoIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhciIpPT09ITA/KGkucmVjdEFyZWFMVEMxPXRlLkxUQ19GTE9BVF8xLGkucmVjdEFyZWFMVEMyPXRlLkxUQ19GTE9BVF8yKTooaS5yZWN0QXJlYUxUQzE9dGUuTFRDX0hBTEZfMSxpLnJlY3RBcmVhTFRDMj10ZS5MVENfSEFMRl8yKSksaS5hbWJpZW50WzBdPXUsaS5hbWJpZW50WzFdPWQsaS5hbWJpZW50WzJdPWY7Y29uc3QgRj1pLmhhc2g7KEYuZGlyZWN0aW9uYWxMZW5ndGghPT1wfHxGLnBvaW50TGVuZ3RoIT09Z3x8Ri5zcG90TGVuZ3RoIT09eHx8Ri5yZWN0QXJlYUxlbmd0aCE9PW18fEYuaGVtaUxlbmd0aCE9PWh8fEYubnVtRGlyZWN0aW9uYWxTaGFkb3dzIT09VHx8Ri5udW1Qb2ludFNoYWRvd3MhPT15fHxGLm51bVNwb3RTaGFkb3dzIT09X3x8Ri5udW1TcG90TWFwcyE9PUN8fEYubnVtTGlnaHRQcm9iZXMhPT1iKSYmKGkuZGlyZWN0aW9uYWwubGVuZ3RoPXAsaS5zcG90Lmxlbmd0aD14LGkucmVjdEFyZWEubGVuZ3RoPW0saS5wb2ludC5sZW5ndGg9ZyxpLmhlbWkubGVuZ3RoPWgsaS5kaXJlY3Rpb25hbFNoYWRvdy5sZW5ndGg9VCxpLmRpcmVjdGlvbmFsU2hhZG93TWFwLmxlbmd0aD1ULGkucG9pbnRTaGFkb3cubGVuZ3RoPXksaS5wb2ludFNoYWRvd01hcC5sZW5ndGg9eSxpLnNwb3RTaGFkb3cubGVuZ3RoPV8saS5zcG90U2hhZG93TWFwLmxlbmd0aD1fLGkuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXgubGVuZ3RoPVQsaS5wb2ludFNoYWRvd01hdHJpeC5sZW5ndGg9eSxpLnNwb3RMaWdodE1hdHJpeC5sZW5ndGg9XytDLXcsaS5zcG90TGlnaHRNYXAubGVuZ3RoPUMsaS5udW1TcG90TGlnaHRTaGFkb3dzV2l0aE1hcHM9dyxpLm51bUxpZ2h0UHJvYmVzPWIsRi5kaXJlY3Rpb25hbExlbmd0aD1wLEYucG9pbnRMZW5ndGg9ZyxGLnNwb3RMZW5ndGg9eCxGLnJlY3RBcmVhTGVuZ3RoPW0sRi5oZW1pTGVuZ3RoPWgsRi5udW1EaXJlY3Rpb25hbFNoYWRvd3M9VCxGLm51bVBvaW50U2hhZG93cz15LEYubnVtU3BvdFNoYWRvd3M9XyxGLm51bVNwb3RNYXBzPUMsRi5udW1MaWdodFByb2Jlcz1iLGkudmVyc2lvbj1TdSsrKX1mdW5jdGlvbiBsKGMsdSl7bGV0IGQ9MCxmPTAscD0wLGc9MCx4PTA7Y29uc3QgbT11Lm1hdHJpeFdvcmxkSW52ZXJzZTtmb3IobGV0IGg9MCxUPWMubGVuZ3RoO2g8VDtoKyspe2NvbnN0IHk9Y1toXTtpZih5LmlzRGlyZWN0aW9uYWxMaWdodCl7Y29uc3QgXz1pLmRpcmVjdGlvbmFsW2RdO18uZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbih5Lm1hdHJpeFdvcmxkKSxyLnNldEZyb21NYXRyaXhQb3NpdGlvbih5LnRhcmdldC5tYXRyaXhXb3JsZCksXy5kaXJlY3Rpb24uc3ViKHIpLF8uZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbihtKSxkKyt9ZWxzZSBpZih5LmlzU3BvdExpZ2h0KXtjb25zdCBfPWkuc3BvdFtwXTtfLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbih5Lm1hdHJpeFdvcmxkKSxfLnBvc2l0aW9uLmFwcGx5TWF0cml4NChtKSxfLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oeS5tYXRyaXhXb3JsZCksci5zZXRGcm9tTWF0cml4UG9zaXRpb24oeS50YXJnZXQubWF0cml4V29ybGQpLF8uZGlyZWN0aW9uLnN1YihyKSxfLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24obSkscCsrfWVsc2UgaWYoeS5pc1JlY3RBcmVhTGlnaHQpe2NvbnN0IF89aS5yZWN0QXJlYVtnXTtfLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbih5Lm1hdHJpeFdvcmxkKSxfLnBvc2l0aW9uLmFwcGx5TWF0cml4NChtKSxvLmlkZW50aXR5KCkscy5jb3B5KHkubWF0cml4V29ybGQpLHMucHJlbXVsdGlwbHkobSksby5leHRyYWN0Um90YXRpb24ocyksXy5oYWxmV2lkdGguc2V0KHkud2lkdGgqLjUsMCwwKSxfLmhhbGZIZWlnaHQuc2V0KDAseS5oZWlnaHQqLjUsMCksXy5oYWxmV2lkdGguYXBwbHlNYXRyaXg0KG8pLF8uaGFsZkhlaWdodC5hcHBseU1hdHJpeDQobyksZysrfWVsc2UgaWYoeS5pc1BvaW50TGlnaHQpe2NvbnN0IF89aS5wb2ludFtmXTtfLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbih5Lm1hdHJpeFdvcmxkKSxfLnBvc2l0aW9uLmFwcGx5TWF0cml4NChtKSxmKyt9ZWxzZSBpZih5LmlzSGVtaXNwaGVyZUxpZ2h0KXtjb25zdCBfPWkuaGVtaVt4XTtfLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oeS5tYXRyaXhXb3JsZCksXy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKG0pLHgrK319fXJldHVybntzZXR1cDphLHNldHVwVmlldzpsLHN0YXRlOml9fWZ1bmN0aW9uIENzKG4pe2NvbnN0IGU9bmV3IHl1KG4pLHQ9W10saT1bXTtmdW5jdGlvbiByKHUpe2MuY2FtZXJhPXUsdC5sZW5ndGg9MCxpLmxlbmd0aD0wfWZ1bmN0aW9uIHModSl7dC5wdXNoKHUpfWZ1bmN0aW9uIG8odSl7aS5wdXNoKHUpfWZ1bmN0aW9uIGEoKXtlLnNldHVwKHQpfWZ1bmN0aW9uIGwodSl7ZS5zZXR1cFZpZXcodCx1KX1jb25zdCBjPXtsaWdodHNBcnJheTp0LHNoYWRvd3NBcnJheTppLGNhbWVyYTpudWxsLGxpZ2h0czplLHRyYW5zbWlzc2lvblJlbmRlclRhcmdldDp7fX07cmV0dXJue2luaXQ6cixzdGF0ZTpjLHNldHVwTGlnaHRzOmEsc2V0dXBMaWdodHNWaWV3OmwscHVzaExpZ2h0OnMscHVzaFNoYWRvdzpvfX1mdW5jdGlvbiBUdShuKXtsZXQgZT1uZXcgV2Vha01hcDtmdW5jdGlvbiB0KHIscz0wKXtjb25zdCBvPWUuZ2V0KHIpO2xldCBhO3JldHVybiBvPT09dm9pZCAwPyhhPW5ldyBDcyhuKSxlLnNldChyLFthXSkpOnM+PW8ubGVuZ3RoPyhhPW5ldyBDcyhuKSxvLnB1c2goYSkpOmE9b1tzXSxhfWZ1bmN0aW9uIGkoKXtlPW5ldyBXZWFrTWFwfXJldHVybntnZXQ6dCxkaXNwb3NlOml9fWNsYXNzIEF1IGV4dGVuZHMgWm57c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIk1lc2hEZXB0aE1hdGVyaWFsIn1jb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuaXNNZXNoRGVwdGhNYXRlcmlhbD0hMCx0aGlzLmRlcHRoUGFja2luZz0zMjAwLHRoaXMubWFwPW51bGwsdGhpcy5hbHBoYU1hcD1udWxsLHRoaXMuZGlzcGxhY2VtZW50TWFwPW51bGwsdGhpcy5kaXNwbGFjZW1lbnRTY2FsZT0xLHRoaXMuZGlzcGxhY2VtZW50Qmlhcz0wLHRoaXMud2lyZWZyYW1lPSExLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPTEsdGhpcy5zZXRWYWx1ZXMoZSl9Y29weShlKXtyZXR1cm4gc3VwZXIuY29weShlKSx0aGlzLmRlcHRoUGFja2luZz1lLmRlcHRoUGFja2luZyx0aGlzLm1hcD1lLm1hcCx0aGlzLmFscGhhTWFwPWUuYWxwaGFNYXAsdGhpcy5kaXNwbGFjZW1lbnRNYXA9ZS5kaXNwbGFjZW1lbnRNYXAsdGhpcy5kaXNwbGFjZW1lbnRTY2FsZT1lLmRpc3BsYWNlbWVudFNjYWxlLHRoaXMuZGlzcGxhY2VtZW50Qmlhcz1lLmRpc3BsYWNlbWVudEJpYXMsdGhpcy53aXJlZnJhbWU9ZS53aXJlZnJhbWUsdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9ZS53aXJlZnJhbWVMaW5ld2lkdGgsdGhpc319Y2xhc3Mgd3UgZXh0ZW5kcyBabntzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iTWVzaERpc3RhbmNlTWF0ZXJpYWwifWNvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5pc01lc2hEaXN0YW5jZU1hdGVyaWFsPSEwLHRoaXMubWFwPW51bGwsdGhpcy5hbHBoYU1hcD1udWxsLHRoaXMuZGlzcGxhY2VtZW50TWFwPW51bGwsdGhpcy5kaXNwbGFjZW1lbnRTY2FsZT0xLHRoaXMuZGlzcGxhY2VtZW50Qmlhcz0wLHRoaXMuc2V0VmFsdWVzKGUpfWNvcHkoZSl7cmV0dXJuIHN1cGVyLmNvcHkoZSksdGhpcy5tYXA9ZS5tYXAsdGhpcy5hbHBoYU1hcD1lLmFscGhhTWFwLHRoaXMuZGlzcGxhY2VtZW50TWFwPWUuZGlzcGxhY2VtZW50TWFwLHRoaXMuZGlzcGxhY2VtZW50U2NhbGU9ZS5kaXNwbGFjZW1lbnRTY2FsZSx0aGlzLmRpc3BsYWNlbWVudEJpYXM9ZS5kaXNwbGFjZW1lbnRCaWFzLHRoaXN9fWNvbnN0IGJ1PWB2b2lkIG1haW4oKSB7CglnbF9Qb3NpdGlvbiA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTsKfWAsUnU9YHVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd19wYXNzOwp1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjsKdW5pZm9ybSBmbG9hdCByYWRpdXM7CiNpbmNsdWRlIDxwYWNraW5nPgp2b2lkIG1haW4oKSB7Cgljb25zdCBmbG9hdCBzYW1wbGVzID0gZmxvYXQoIFZTTV9TQU1QTEVTICk7CglmbG9hdCBtZWFuID0gMC4wOwoJZmxvYXQgc3F1YXJlZF9tZWFuID0gMC4wOwoJZmxvYXQgdXZTdHJpZGUgPSBzYW1wbGVzIDw9IDEuMCA/IDAuMCA6IDIuMCAvICggc2FtcGxlcyAtIDEuMCApOwoJZmxvYXQgdXZTdGFydCA9IHNhbXBsZXMgPD0gMS4wID8gMC4wIDogLSAxLjA7Cglmb3IgKCBmbG9hdCBpID0gMC4wOyBpIDwgc2FtcGxlczsgaSArKyApIHsKCQlmbG9hdCB1dk9mZnNldCA9IHV2U3RhcnQgKyBpICogdXZTdHJpZGU7CgkJI2lmZGVmIEhPUklaT05UQUxfUEFTUwoJCQl2ZWMyIGRpc3RyaWJ1dGlvbiA9IHVucGFja1JHQkFUbzJIYWxmKCB0ZXh0dXJlMkQoIHNoYWRvd19wYXNzLCAoIGdsX0ZyYWdDb29yZC54eSArIHZlYzIoIHV2T2Zmc2V0LCAwLjAgKSAqIHJhZGl1cyApIC8gcmVzb2x1dGlvbiApICk7CgkJCW1lYW4gKz0gZGlzdHJpYnV0aW9uLng7CgkJCXNxdWFyZWRfbWVhbiArPSBkaXN0cmlidXRpb24ueSAqIGRpc3RyaWJ1dGlvbi55ICsgZGlzdHJpYnV0aW9uLnggKiBkaXN0cmlidXRpb24ueDsKCQkjZWxzZQoJCQlmbG9hdCBkZXB0aCA9IHVucGFja1JHQkFUb0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd19wYXNzLCAoIGdsX0ZyYWdDb29yZC54eSArIHZlYzIoIDAuMCwgdXZPZmZzZXQgKSAqIHJhZGl1cyApIC8gcmVzb2x1dGlvbiApICk7CgkJCW1lYW4gKz0gZGVwdGg7CgkJCXNxdWFyZWRfbWVhbiArPSBkZXB0aCAqIGRlcHRoOwoJCSNlbmRpZgoJfQoJbWVhbiA9IG1lYW4gLyBzYW1wbGVzOwoJc3F1YXJlZF9tZWFuID0gc3F1YXJlZF9tZWFuIC8gc2FtcGxlczsKCWZsb2F0IHN0ZF9kZXYgPSBzcXJ0KCBzcXVhcmVkX21lYW4gLSBtZWFuICogbWVhbiApOwoJZ2xfRnJhZ0NvbG9yID0gcGFjazJIYWxmVG9SR0JBKCB2ZWMyKCBtZWFuLCBzdGRfZGV2ICkgKTsKfWA7ZnVuY3Rpb24gQ3UobixlLHQpe2xldCBpPW5ldyBRcjtjb25zdCByPW5ldyBQZSxzPW5ldyBQZSxvPW5ldyBydCxhPW5ldyBBdSh7ZGVwdGhQYWNraW5nOjMyMDF9KSxsPW5ldyB3dSxjPXt9LHU9dC5tYXhUZXh0dXJlU2l6ZSxkPXswOjEsMTowLDI6Mn0sZj1uZXcgbHQoe2RlZmluZXM6e1ZTTV9TQU1QTEVTOjh9LHVuaWZvcm1zOntzaGFkb3dfcGFzczp7dmFsdWU6bnVsbH0scmVzb2x1dGlvbjp7dmFsdWU6bmV3IFBlfSxyYWRpdXM6e3ZhbHVlOjR9fSx2ZXJ0ZXhTaGFkZXI6YnUsZnJhZ21lbnRTaGFkZXI6UnV9KSxwPWYuY2xvbmUoKTtwLmRlZmluZXMuSE9SSVpPTlRBTF9QQVNTPTE7Y29uc3QgZz1uZXcgQ3Q7Zy5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgU3QobmV3IEZsb2F0MzJBcnJheShbLTEsLTEsLjUsMywtMSwuNSwtMSwzLC41XSksMykpO2NvbnN0IHg9bmV3IHR0KGcsZiksbT10aGlzO3RoaXMuZW5hYmxlZD0hMSx0aGlzLmF1dG9VcGRhdGU9ITAsdGhpcy5uZWVkc1VwZGF0ZT0hMSx0aGlzLnR5cGU9MTtsZXQgaD10aGlzLnR5cGU7dGhpcy5yZW5kZXI9ZnVuY3Rpb24odyxiLEYpe2lmKG0uZW5hYmxlZD09PSExfHxtLmF1dG9VcGRhdGU9PT0hMSYmbS5uZWVkc1VwZGF0ZT09PSExfHx3Lmxlbmd0aD09PTApcmV0dXJuO2NvbnN0IEU9bi5nZXRSZW5kZXJUYXJnZXQoKSxTPW4uZ2V0QWN0aXZlQ3ViZUZhY2UoKSxSPW4uZ2V0QWN0aXZlTWlwbWFwTGV2ZWwoKSxxPW4uc3RhdGU7cS5zZXRCbGVuZGluZygwKSxxLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoMSwxLDEsMSkscS5idWZmZXJzLmRlcHRoLnNldFRlc3QoITApLHEuc2V0U2Npc3NvclRlc3QoITEpO2NvbnN0IHo9aCE9PTMmJnRoaXMudHlwZT09PTMsVz1oPT09MyYmdGhpcy50eXBlIT09Mztmb3IobGV0IFo9MCxWPXcubGVuZ3RoO1o8VjtaKyspe2NvbnN0IFE9d1taXSxIPVEuc2hhZG93O2lmKEg9PT12b2lkIDApe2NvbnNvbGUud2FybigiVEhSRUUuV2ViR0xTaGFkb3dNYXA6IixRLCJoYXMgbm8gc2hhZG93LiIpO2NvbnRpbnVlfWlmKEguYXV0b1VwZGF0ZT09PSExJiZILm5lZWRzVXBkYXRlPT09ITEpY29udGludWU7ci5jb3B5KEgubWFwU2l6ZSk7Y29uc3QgaWU9SC5nZXRGcmFtZUV4dGVudHMoKTtpZihyLm11bHRpcGx5KGllKSxzLmNvcHkoSC5tYXBTaXplKSwoci54PnV8fHIueT51KSYmKHIueD51JiYocy54PU1hdGguZmxvb3IodS9pZS54KSxyLng9cy54KmllLngsSC5tYXBTaXplLng9cy54KSxyLnk+dSYmKHMueT1NYXRoLmZsb29yKHUvaWUueSksci55PXMueSppZS55LEgubWFwU2l6ZS55PXMueSkpLEgubWFwPT09bnVsbHx8ej09PSEwfHxXPT09ITApe2NvbnN0IHhlPXRoaXMudHlwZSE9PTM/e21pbkZpbHRlcjoxMDAzLG1hZ0ZpbHRlcjoxMDAzfTp7fTtILm1hcCE9PW51bGwmJkgubWFwLmRpc3Bvc2UoKSxILm1hcD1uZXcgSnQoci54LHIueSx4ZSksSC5tYXAudGV4dHVyZS5uYW1lPVEubmFtZSsiLnNoYWRvd01hcCIsSC5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfW4uc2V0UmVuZGVyVGFyZ2V0KEgubWFwKSxuLmNsZWFyKCk7Y29uc3QgY2U9SC5nZXRWaWV3cG9ydENvdW50KCk7Zm9yKGxldCB4ZT0wO3hlPGNlO3hlKyspe2NvbnN0IFVlPUguZ2V0Vmlld3BvcnQoeGUpO28uc2V0KHMueCpVZS54LHMueSpVZS55LHMueCpVZS56LHMueSpVZS53KSxxLnZpZXdwb3J0KG8pLEgudXBkYXRlTWF0cmljZXMoUSx4ZSksaT1ILmdldEZydXN0dW0oKSxfKGIsRixILmNhbWVyYSxRLHRoaXMudHlwZSl9SC5pc1BvaW50TGlnaHRTaGFkb3chPT0hMCYmdGhpcy50eXBlPT09MyYmVChILEYpLEgubmVlZHNVcGRhdGU9ITF9aD10aGlzLnR5cGUsbS5uZWVkc1VwZGF0ZT0hMSxuLnNldFJlbmRlclRhcmdldChFLFMsUil9O2Z1bmN0aW9uIFQodyxiKXtjb25zdCBGPWUudXBkYXRlKHgpO2YuZGVmaW5lcy5WU01fU0FNUExFUyE9PXcuYmx1clNhbXBsZXMmJihmLmRlZmluZXMuVlNNX1NBTVBMRVM9dy5ibHVyU2FtcGxlcyxwLmRlZmluZXMuVlNNX1NBTVBMRVM9dy5ibHVyU2FtcGxlcyxmLm5lZWRzVXBkYXRlPSEwLHAubmVlZHNVcGRhdGU9ITApLHcubWFwUGFzcz09PW51bGwmJih3Lm1hcFBhc3M9bmV3IEp0KHIueCxyLnkpKSxmLnVuaWZvcm1zLnNoYWRvd19wYXNzLnZhbHVlPXcubWFwLnRleHR1cmUsZi51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlPXcubWFwU2l6ZSxmLnVuaWZvcm1zLnJhZGl1cy52YWx1ZT13LnJhZGl1cyxuLnNldFJlbmRlclRhcmdldCh3Lm1hcFBhc3MpLG4uY2xlYXIoKSxuLnJlbmRlckJ1ZmZlckRpcmVjdChiLG51bGwsRixmLHgsbnVsbCkscC51bmlmb3Jtcy5zaGFkb3dfcGFzcy52YWx1ZT13Lm1hcFBhc3MudGV4dHVyZSxwLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWU9dy5tYXBTaXplLHAudW5pZm9ybXMucmFkaXVzLnZhbHVlPXcucmFkaXVzLG4uc2V0UmVuZGVyVGFyZ2V0KHcubWFwKSxuLmNsZWFyKCksbi5yZW5kZXJCdWZmZXJEaXJlY3QoYixudWxsLEYscCx4LG51bGwpfWZ1bmN0aW9uIHkodyxiLEYsRSl7bGV0IFM9bnVsbDtjb25zdCBSPUYuaXNQb2ludExpZ2h0PT09ITA/dy5jdXN0b21EaXN0YW5jZU1hdGVyaWFsOncuY3VzdG9tRGVwdGhNYXRlcmlhbDtpZihSIT09dm9pZCAwKVM9UjtlbHNlIGlmKFM9Ri5pc1BvaW50TGlnaHQ9PT0hMD9sOmEsbi5sb2NhbENsaXBwaW5nRW5hYmxlZCYmYi5jbGlwU2hhZG93cz09PSEwJiZBcnJheS5pc0FycmF5KGIuY2xpcHBpbmdQbGFuZXMpJiZiLmNsaXBwaW5nUGxhbmVzLmxlbmd0aCE9PTB8fGIuZGlzcGxhY2VtZW50TWFwJiZiLmRpc3BsYWNlbWVudFNjYWxlIT09MHx8Yi5hbHBoYU1hcCYmYi5hbHBoYVRlc3Q+MHx8Yi5tYXAmJmIuYWxwaGFUZXN0PjApe2NvbnN0IHE9Uy51dWlkLHo9Yi51dWlkO2xldCBXPWNbcV07Vz09PXZvaWQgMCYmKFc9e30sY1txXT1XKTtsZXQgWj1XW3pdO1o9PT12b2lkIDAmJihaPVMuY2xvbmUoKSxXW3pdPVosYi5hZGRFdmVudExpc3RlbmVyKCJkaXNwb3NlIixDKSksUz1afWlmKFMudmlzaWJsZT1iLnZpc2libGUsUy53aXJlZnJhbWU9Yi53aXJlZnJhbWUsRT09PTM/Uy5zaWRlPWIuc2hhZG93U2lkZSE9PW51bGw/Yi5zaGFkb3dTaWRlOmIuc2lkZTpTLnNpZGU9Yi5zaGFkb3dTaWRlIT09bnVsbD9iLnNoYWRvd1NpZGU6ZFtiLnNpZGVdLFMuYWxwaGFNYXA9Yi5hbHBoYU1hcCxTLmFscGhhVGVzdD1iLmFscGhhVGVzdCxTLm1hcD1iLm1hcCxTLmNsaXBTaGFkb3dzPWIuY2xpcFNoYWRvd3MsUy5jbGlwcGluZ1BsYW5lcz1iLmNsaXBwaW5nUGxhbmVzLFMuY2xpcEludGVyc2VjdGlvbj1iLmNsaXBJbnRlcnNlY3Rpb24sUy5kaXNwbGFjZW1lbnRNYXA9Yi5kaXNwbGFjZW1lbnRNYXAsUy5kaXNwbGFjZW1lbnRTY2FsZT1iLmRpc3BsYWNlbWVudFNjYWxlLFMuZGlzcGxhY2VtZW50Qmlhcz1iLmRpc3BsYWNlbWVudEJpYXMsUy53aXJlZnJhbWVMaW5ld2lkdGg9Yi53aXJlZnJhbWVMaW5ld2lkdGgsUy5saW5ld2lkdGg9Yi5saW5ld2lkdGgsRi5pc1BvaW50TGlnaHQ9PT0hMCYmUy5pc01lc2hEaXN0YW5jZU1hdGVyaWFsPT09ITApe2NvbnN0IHE9bi5wcm9wZXJ0aWVzLmdldChTKTtxLmxpZ2h0PUZ9cmV0dXJuIFN9ZnVuY3Rpb24gXyh3LGIsRixFLFMpe2lmKHcudmlzaWJsZT09PSExKXJldHVybjtpZih3LmxheWVycy50ZXN0KGIubGF5ZXJzKSYmKHcuaXNNZXNofHx3LmlzTGluZXx8dy5pc1BvaW50cykmJih3LmNhc3RTaGFkb3d8fHcucmVjZWl2ZVNoYWRvdyYmUz09PTMpJiYoIXcuZnJ1c3R1bUN1bGxlZHx8aS5pbnRlcnNlY3RzT2JqZWN0KHcpKSl7dy5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhGLm1hdHJpeFdvcmxkSW52ZXJzZSx3Lm1hdHJpeFdvcmxkKTtjb25zdCB6PWUudXBkYXRlKHcpLFc9dy5tYXRlcmlhbDtpZihBcnJheS5pc0FycmF5KFcpKXtjb25zdCBaPXouZ3JvdXBzO2ZvcihsZXQgVj0wLFE9Wi5sZW5ndGg7VjxRO1YrKyl7Y29uc3QgSD1aW1ZdLGllPVdbSC5tYXRlcmlhbEluZGV4XTtpZihpZSYmaWUudmlzaWJsZSl7Y29uc3QgY2U9eSh3LGllLEUsUyk7dy5vbkJlZm9yZVNoYWRvdyhuLHcsYixGLHosY2UsSCksbi5yZW5kZXJCdWZmZXJEaXJlY3QoRixudWxsLHosY2UsdyxIKSx3Lm9uQWZ0ZXJTaGFkb3cobix3LGIsRix6LGNlLEgpfX19ZWxzZSBpZihXLnZpc2libGUpe2NvbnN0IFo9eSh3LFcsRSxTKTt3Lm9uQmVmb3JlU2hhZG93KG4sdyxiLEYseixaLG51bGwpLG4ucmVuZGVyQnVmZmVyRGlyZWN0KEYsbnVsbCx6LFosdyxudWxsKSx3Lm9uQWZ0ZXJTaGFkb3cobix3LGIsRix6LFosbnVsbCl9fWNvbnN0IHE9dy5jaGlsZHJlbjtmb3IobGV0IHo9MCxXPXEubGVuZ3RoO3o8Vzt6KyspXyhxW3pdLGIsRixFLFMpfWZ1bmN0aW9uIEModyl7dy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsQyk7Zm9yKGNvbnN0IEYgaW4gYyl7Y29uc3QgRT1jW0ZdLFM9dy50YXJnZXQudXVpZDtTIGluIEUmJihFW1NdLmRpc3Bvc2UoKSxkZWxldGUgRVtTXSl9fX1jb25zdCBQdT17MDoxLDI6Niw0OjcsMzo1LDE6MCw2OjIsNzo0LDU6M307ZnVuY3Rpb24gRHUobixlKXtmdW5jdGlvbiB0KCl7bGV0IFA9ITE7Y29uc3QgbmU9bmV3IHJ0O2xldCBHPW51bGw7Y29uc3QgJD1uZXcgcnQoMCwwLDAsMCk7cmV0dXJue3NldE1hc2s6ZnVuY3Rpb24obGUpe0chPT1sZSYmIVAmJihuLmNvbG9yTWFzayhsZSxsZSxsZSxsZSksRz1sZSl9LHNldExvY2tlZDpmdW5jdGlvbihsZSl7UD1sZX0sc2V0Q2xlYXI6ZnVuY3Rpb24obGUsYWUsUmUsaXQsbXQpe210PT09ITAmJihsZSo9aXQsYWUqPWl0LFJlKj1pdCksbmUuc2V0KGxlLGFlLFJlLGl0KSwkLmVxdWFscyhuZSk9PT0hMSYmKG4uY2xlYXJDb2xvcihsZSxhZSxSZSxpdCksJC5jb3B5KG5lKSl9LHJlc2V0OmZ1bmN0aW9uKCl7UD0hMSxHPW51bGwsJC5zZXQoLTEsMCwwLDApfX19ZnVuY3Rpb24gaSgpe2xldCBQPSExLG5lPSExLEc9bnVsbCwkPW51bGwsbGU9bnVsbDtyZXR1cm57c2V0UmV2ZXJzZWQ6ZnVuY3Rpb24oYWUpe2lmKG5lIT09YWUpe2NvbnN0IFJlPWUuZ2V0KCJFWFRfY2xpcF9jb250cm9sIik7bmU/UmUuY2xpcENvbnRyb2xFWFQoUmUuTE9XRVJfTEVGVF9FWFQsUmUuWkVST19UT19PTkVfRVhUKTpSZS5jbGlwQ29udHJvbEVYVChSZS5MT1dFUl9MRUZUX0VYVCxSZS5ORUdBVElWRV9PTkVfVE9fT05FX0VYVCk7Y29uc3QgaXQ9bGU7bGU9bnVsbCx0aGlzLnNldENsZWFyKGl0KX1uZT1hZX0sZ2V0UmV2ZXJzZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gbmV9LHNldFRlc3Q6ZnVuY3Rpb24oYWUpe2FlP3JlKG4uREVQVEhfVEVTVCk6eWUobi5ERVBUSF9URVNUKX0sc2V0TWFzazpmdW5jdGlvbihhZSl7RyE9PWFlJiYhUCYmKG4uZGVwdGhNYXNrKGFlKSxHPWFlKX0sc2V0RnVuYzpmdW5jdGlvbihhZSl7aWYobmUmJihhZT1QdVthZV0pLCQhPT1hZSl7c3dpdGNoKGFlKXtjYXNlIDA6bi5kZXB0aEZ1bmMobi5ORVZFUik7YnJlYWs7Y2FzZSAxOm4uZGVwdGhGdW5jKG4uQUxXQVlTKTticmVhaztjYXNlIDI6bi5kZXB0aEZ1bmMobi5MRVNTKTticmVhaztjYXNlIDM6bi5kZXB0aEZ1bmMobi5MRVFVQUwpO2JyZWFrO2Nhc2UgNDpuLmRlcHRoRnVuYyhuLkVRVUFMKTticmVhaztjYXNlIDU6bi5kZXB0aEZ1bmMobi5HRVFVQUwpO2JyZWFrO2Nhc2UgNjpuLmRlcHRoRnVuYyhuLkdSRUFURVIpO2JyZWFrO2Nhc2UgNzpuLmRlcHRoRnVuYyhuLk5PVEVRVUFMKTticmVhaztkZWZhdWx0Om4uZGVwdGhGdW5jKG4uTEVRVUFMKX0kPWFlfX0sc2V0TG9ja2VkOmZ1bmN0aW9uKGFlKXtQPWFlfSxzZXRDbGVhcjpmdW5jdGlvbihhZSl7bGUhPT1hZSYmKG5lJiYoYWU9MS1hZSksbi5jbGVhckRlcHRoKGFlKSxsZT1hZSl9LHJlc2V0OmZ1bmN0aW9uKCl7UD0hMSxHPW51bGwsJD1udWxsLGxlPW51bGwsbmU9ITF9fX1mdW5jdGlvbiByKCl7bGV0IFA9ITEsbmU9bnVsbCxHPW51bGwsJD1udWxsLGxlPW51bGwsYWU9bnVsbCxSZT1udWxsLGl0PW51bGwsbXQ9bnVsbDtyZXR1cm57c2V0VGVzdDpmdW5jdGlvbihYZSl7UHx8KFhlP3JlKG4uU1RFTkNJTF9URVNUKTp5ZShuLlNURU5DSUxfVEVTVCkpfSxzZXRNYXNrOmZ1bmN0aW9uKFhlKXtuZSE9PVhlJiYhUCYmKG4uc3RlbmNpbE1hc2soWGUpLG5lPVhlKX0sc2V0RnVuYzpmdW5jdGlvbihYZSxPdCxLdCl7KEchPT1YZXx8JCE9PU90fHxsZSE9PUt0KSYmKG4uc3RlbmNpbEZ1bmMoWGUsT3QsS3QpLEc9WGUsJD1PdCxsZT1LdCl9LHNldE9wOmZ1bmN0aW9uKFhlLE90LEt0KXsoYWUhPT1YZXx8UmUhPT1PdHx8aXQhPT1LdCkmJihuLnN0ZW5jaWxPcChYZSxPdCxLdCksYWU9WGUsUmU9T3QsaXQ9S3QpfSxzZXRMb2NrZWQ6ZnVuY3Rpb24oWGUpe1A9WGV9LHNldENsZWFyOmZ1bmN0aW9uKFhlKXttdCE9PVhlJiYobi5jbGVhclN0ZW5jaWwoWGUpLG10PVhlKX0scmVzZXQ6ZnVuY3Rpb24oKXtQPSExLG5lPW51bGwsRz1udWxsLCQ9bnVsbCxsZT1udWxsLGFlPW51bGwsUmU9bnVsbCxpdD1udWxsLG10PW51bGx9fX1jb25zdCBzPW5ldyB0LG89bmV3IGksYT1uZXcgcixsPW5ldyBXZWFrTWFwLGM9bmV3IFdlYWtNYXA7bGV0IHU9e30sZD17fSxmPW5ldyBXZWFrTWFwLHA9W10sZz1udWxsLHg9ITEsbT1udWxsLGg9bnVsbCxUPW51bGwseT1udWxsLF89bnVsbCxDPW51bGwsdz1udWxsLGI9bmV3IFZlKDAsMCwwKSxGPTAsRT0hMSxTPW51bGwsUj1udWxsLHE9bnVsbCx6PW51bGwsVz1udWxsO2NvbnN0IFo9bi5nZXRQYXJhbWV0ZXIobi5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyk7bGV0IFY9ITEsUT0wO2NvbnN0IEg9bi5nZXRQYXJhbWV0ZXIobi5WRVJTSU9OKTtILmluZGV4T2YoIldlYkdMIikhPT0tMT8oUT1wYXJzZUZsb2F0KC9eV2ViR0wgKFxkKS8uZXhlYyhIKVsxXSksVj1RPj0xKTpILmluZGV4T2YoIk9wZW5HTCBFUyIpIT09LTEmJihRPXBhcnNlRmxvYXQoL15PcGVuR0wgRVMgKFxkKS8uZXhlYyhIKVsxXSksVj1RPj0yKTtsZXQgaWU9bnVsbCxjZT17fTtjb25zdCB4ZT1uLmdldFBhcmFtZXRlcihuLlNDSVNTT1JfQk9YKSxVZT1uLmdldFBhcmFtZXRlcihuLlZJRVdQT1JUKSxZZT1uZXcgcnQoKS5mcm9tQXJyYXkoeGUpLFg9bmV3IHJ0KCkuZnJvbUFycmF5KFVlKTtmdW5jdGlvbiBlZShQLG5lLEcsJCl7Y29uc3QgbGU9bmV3IFVpbnQ4QXJyYXkoNCksYWU9bi5jcmVhdGVUZXh0dXJlKCk7bi5iaW5kVGV4dHVyZShQLGFlKSxuLnRleFBhcmFtZXRlcmkoUCxuLlRFWFRVUkVfTUlOX0ZJTFRFUixuLk5FQVJFU1QpLG4udGV4UGFyYW1ldGVyaShQLG4uVEVYVFVSRV9NQUdfRklMVEVSLG4uTkVBUkVTVCk7Zm9yKGxldCBSZT0wO1JlPEc7UmUrKylQPT09bi5URVhUVVJFXzNEfHxQPT09bi5URVhUVVJFXzJEX0FSUkFZP24udGV4SW1hZ2UzRChuZSwwLG4uUkdCQSwxLDEsJCwwLG4uUkdCQSxuLlVOU0lHTkVEX0JZVEUsbGUpOm4udGV4SW1hZ2UyRChuZStSZSwwLG4uUkdCQSwxLDEsMCxuLlJHQkEsbi5VTlNJR05FRF9CWVRFLGxlKTtyZXR1cm4gYWV9Y29uc3QgZ2U9e307Z2Vbbi5URVhUVVJFXzJEXT1lZShuLlRFWFRVUkVfMkQsbi5URVhUVVJFXzJELDEpLGdlW24uVEVYVFVSRV9DVUJFX01BUF09ZWUobi5URVhUVVJFX0NVQkVfTUFQLG4uVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLDYpLGdlW24uVEVYVFVSRV8yRF9BUlJBWV09ZWUobi5URVhUVVJFXzJEX0FSUkFZLG4uVEVYVFVSRV8yRF9BUlJBWSwxLDEpLGdlW24uVEVYVFVSRV8zRF09ZWUobi5URVhUVVJFXzNELG4uVEVYVFVSRV8zRCwxLDEpLHMuc2V0Q2xlYXIoMCwwLDAsMSksby5zZXRDbGVhcigxKSxhLnNldENsZWFyKDApLHJlKG4uREVQVEhfVEVTVCksby5zZXRGdW5jKDMpLEllKCExKSxOZSgxKSxyZShuLkNVTExfRkFDRSksVSgwKTtmdW5jdGlvbiByZShQKXt1W1BdIT09ITAmJihuLmVuYWJsZShQKSx1W1BdPSEwKX1mdW5jdGlvbiB5ZShQKXt1W1BdIT09ITEmJihuLmRpc2FibGUoUCksdVtQXT0hMSl9ZnVuY3Rpb24gd2UoUCxuZSl7cmV0dXJuIGRbUF0hPT1uZT8obi5iaW5kRnJhbWVidWZmZXIoUCxuZSksZFtQXT1uZSxQPT09bi5EUkFXX0ZSQU1FQlVGRkVSJiYoZFtuLkZSQU1FQlVGRkVSXT1uZSksUD09PW4uRlJBTUVCVUZGRVImJihkW24uRFJBV19GUkFNRUJVRkZFUl09bmUpLCEwKTohMX1mdW5jdGlvbiBGZShQLG5lKXtsZXQgRz1wLCQ9ITE7aWYoUCl7Rz1mLmdldChuZSksRz09PXZvaWQgMCYmKEc9W10sZi5zZXQobmUsRykpO2NvbnN0IGxlPVAudGV4dHVyZXM7aWYoRy5sZW5ndGghPT1sZS5sZW5ndGh8fEdbMF0hPT1uLkNPTE9SX0FUVEFDSE1FTlQwKXtmb3IobGV0IGFlPTAsUmU9bGUubGVuZ3RoO2FlPFJlO2FlKyspR1thZV09bi5DT0xPUl9BVFRBQ0hNRU5UMCthZTtHLmxlbmd0aD1sZS5sZW5ndGgsJD0hMH19ZWxzZSBHWzBdIT09bi5CQUNLJiYoR1swXT1uLkJBQ0ssJD0hMCk7JCYmbi5kcmF3QnVmZmVycyhHKX1mdW5jdGlvbiBudChQKXtyZXR1cm4gZyE9PVA/KG4udXNlUHJvZ3JhbShQKSxnPVAsITApOiExfWNvbnN0IHplPXsxMDA6bi5GVU5DX0FERCwxMDE6bi5GVU5DX1NVQlRSQUNULDEwMjpuLkZVTkNfUkVWRVJTRV9TVUJUUkFDVH07emVbMTAzXT1uLk1JTix6ZVsxMDRdPW4uTUFYO2NvbnN0IGF0PXsyMDA6bi5aRVJPLDIwMTpuLk9ORSwyMDI6bi5TUkNfQ09MT1IsMjA0Om4uU1JDX0FMUEhBLDIxMDpuLlNSQ19BTFBIQV9TQVRVUkFURSwyMDg6bi5EU1RfQ09MT1IsMjA2Om4uRFNUX0FMUEhBLDIwMzpuLk9ORV9NSU5VU19TUkNfQ09MT1IsMjA1Om4uT05FX01JTlVTX1NSQ19BTFBIQSwyMDk6bi5PTkVfTUlOVVNfRFNUX0NPTE9SLDIwNzpuLk9ORV9NSU5VU19EU1RfQUxQSEEsMjExOm4uQ09OU1RBTlRfQ09MT1IsMjEyOm4uT05FX01JTlVTX0NPTlNUQU5UX0NPTE9SLDIxMzpuLkNPTlNUQU5UX0FMUEhBLDIxNDpuLk9ORV9NSU5VU19DT05TVEFOVF9BTFBIQX07ZnVuY3Rpb24gVShQLG5lLEcsJCxsZSxhZSxSZSxpdCxtdCxYZSl7aWYoUD09PTApe3g9PT0hMCYmKHllKG4uQkxFTkQpLHg9ITEpO3JldHVybn1pZih4PT09ITEmJihyZShuLkJMRU5EKSx4PSEwKSxQIT09NSl7aWYoUCE9PW18fFhlIT09RSl7aWYoKGghPT0xMDB8fF8hPT0xMDApJiYobi5ibGVuZEVxdWF0aW9uKG4uRlVOQ19BREQpLGg9MTAwLF89MTAwKSxYZSlzd2l0Y2goUCl7Y2FzZSAxOm4uYmxlbmRGdW5jU2VwYXJhdGUobi5PTkUsbi5PTkVfTUlOVVNfU1JDX0FMUEhBLG4uT05FLG4uT05FX01JTlVTX1NSQ19BTFBIQSk7YnJlYWs7Y2FzZSAyOm4uYmxlbmRGdW5jKG4uT05FLG4uT05FKTticmVhaztjYXNlIDM6bi5ibGVuZEZ1bmNTZXBhcmF0ZShuLlpFUk8sbi5PTkVfTUlOVVNfU1JDX0NPTE9SLG4uWkVSTyxuLk9ORSk7YnJlYWs7Y2FzZSA0Om4uYmxlbmRGdW5jU2VwYXJhdGUobi5aRVJPLG4uU1JDX0NPTE9SLG4uWkVSTyxuLlNSQ19BTFBIQSk7YnJlYWs7ZGVmYXVsdDpjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFN0YXRlOiBJbnZhbGlkIGJsZW5kaW5nOiAiLFApO2JyZWFrfWVsc2Ugc3dpdGNoKFApe2Nhc2UgMTpuLmJsZW5kRnVuY1NlcGFyYXRlKG4uU1JDX0FMUEhBLG4uT05FX01JTlVTX1NSQ19BTFBIQSxuLk9ORSxuLk9ORV9NSU5VU19TUkNfQUxQSEEpO2JyZWFrO2Nhc2UgMjpuLmJsZW5kRnVuYyhuLlNSQ19BTFBIQSxuLk9ORSk7YnJlYWs7Y2FzZSAzOm4uYmxlbmRGdW5jU2VwYXJhdGUobi5aRVJPLG4uT05FX01JTlVTX1NSQ19DT0xPUixuLlpFUk8sbi5PTkUpO2JyZWFrO2Nhc2UgNDpuLmJsZW5kRnVuYyhuLlpFUk8sbi5TUkNfQ09MT1IpO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZTogSW52YWxpZCBibGVuZGluZzogIixQKTticmVha31UPW51bGwseT1udWxsLEM9bnVsbCx3PW51bGwsYi5zZXQoMCwwLDApLEY9MCxtPVAsRT1YZX1yZXR1cm59bGU9bGV8fG5lLGFlPWFlfHxHLFJlPVJlfHwkLChuZSE9PWh8fGxlIT09XykmJihuLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSh6ZVtuZV0semVbbGVdKSxoPW5lLF89bGUpLChHIT09VHx8JCE9PXl8fGFlIT09Q3x8UmUhPT13KSYmKG4uYmxlbmRGdW5jU2VwYXJhdGUoYXRbR10sYXRbJF0sYXRbYWVdLGF0W1JlXSksVD1HLHk9JCxDPWFlLHc9UmUpLChpdC5lcXVhbHMoYik9PT0hMXx8bXQhPT1GKSYmKG4uYmxlbmRDb2xvcihpdC5yLGl0LmcsaXQuYixtdCksYi5jb3B5KGl0KSxGPW10KSxtPVAsRT0hMX1mdW5jdGlvbiBQdChQLG5lKXtQLnNpZGU9PT0yP3llKG4uQ1VMTF9GQUNFKTpyZShuLkNVTExfRkFDRSk7bGV0IEc9UC5zaWRlPT09MTtuZSYmKEc9IUcpLEllKEcpLFAuYmxlbmRpbmc9PT0xJiZQLnRyYW5zcGFyZW50PT09ITE/VSgwKTpVKFAuYmxlbmRpbmcsUC5ibGVuZEVxdWF0aW9uLFAuYmxlbmRTcmMsUC5ibGVuZERzdCxQLmJsZW5kRXF1YXRpb25BbHBoYSxQLmJsZW5kU3JjQWxwaGEsUC5ibGVuZERzdEFscGhhLFAuYmxlbmRDb2xvcixQLmJsZW5kQWxwaGEsUC5wcmVtdWx0aXBsaWVkQWxwaGEpLG8uc2V0RnVuYyhQLmRlcHRoRnVuYyksby5zZXRUZXN0KFAuZGVwdGhUZXN0KSxvLnNldE1hc2soUC5kZXB0aFdyaXRlKSxzLnNldE1hc2soUC5jb2xvcldyaXRlKTtjb25zdCAkPVAuc3RlbmNpbFdyaXRlO2Euc2V0VGVzdCgkKSwkJiYoYS5zZXRNYXNrKFAuc3RlbmNpbFdyaXRlTWFzayksYS5zZXRGdW5jKFAuc3RlbmNpbEZ1bmMsUC5zdGVuY2lsUmVmLFAuc3RlbmNpbEZ1bmNNYXNrKSxhLnNldE9wKFAuc3RlbmNpbEZhaWwsUC5zdGVuY2lsWkZhaWwsUC5zdGVuY2lsWlBhc3MpKSxqZShQLnBvbHlnb25PZmZzZXQsUC5wb2x5Z29uT2Zmc2V0RmFjdG9yLFAucG9seWdvbk9mZnNldFVuaXRzKSxQLmFscGhhVG9Db3ZlcmFnZT09PSEwP3JlKG4uU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFKTp5ZShuLlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSl9ZnVuY3Rpb24gSWUoUCl7UyE9PVAmJihQP24uZnJvbnRGYWNlKG4uQ1cpOm4uZnJvbnRGYWNlKG4uQ0NXKSxTPVApfWZ1bmN0aW9uIE5lKFApe1AhPT0wPyhyZShuLkNVTExfRkFDRSksUCE9PVImJihQPT09MT9uLmN1bGxGYWNlKG4uQkFDSyk6UD09PTI/bi5jdWxsRmFjZShuLkZST05UKTpuLmN1bGxGYWNlKG4uRlJPTlRfQU5EX0JBQ0spKSk6eWUobi5DVUxMX0ZBQ0UpLFI9UH1mdW5jdGlvbiBTZShQKXtQIT09cSYmKFYmJm4ubGluZVdpZHRoKFApLHE9UCl9ZnVuY3Rpb24gamUoUCxuZSxHKXtQPyhyZShuLlBPTFlHT05fT0ZGU0VUX0ZJTEwpLCh6IT09bmV8fFchPT1HKSYmKG4ucG9seWdvbk9mZnNldChuZSxHKSx6PW5lLFc9RykpOnllKG4uUE9MWUdPTl9PRkZTRVRfRklMTCl9ZnVuY3Rpb24gTWUoUCl7UD9yZShuLlNDSVNTT1JfVEVTVCk6eWUobi5TQ0lTU09SX1RFU1QpfWZ1bmN0aW9uIEEoUCl7UD09PXZvaWQgMCYmKFA9bi5URVhUVVJFMCtaLTEpLGllIT09UCYmKG4uYWN0aXZlVGV4dHVyZShQKSxpZT1QKX1mdW5jdGlvbiB2KFAsbmUsRyl7Rz09PXZvaWQgMCYmKGllPT09bnVsbD9HPW4uVEVYVFVSRTArWi0xOkc9aWUpO2xldCAkPWNlW0ddOyQ9PT12b2lkIDAmJigkPXt0eXBlOnZvaWQgMCx0ZXh0dXJlOnZvaWQgMH0sY2VbR109JCksKCQudHlwZSE9PVB8fCQudGV4dHVyZSE9PW5lKSYmKGllIT09RyYmKG4uYWN0aXZlVGV4dHVyZShHKSxpZT1HKSxuLmJpbmRUZXh0dXJlKFAsbmV8fGdlW1BdKSwkLnR5cGU9UCwkLnRleHR1cmU9bmUpfWZ1bmN0aW9uIEkoKXtjb25zdCBQPWNlW2llXTtQIT09dm9pZCAwJiZQLnR5cGUhPT12b2lkIDAmJihuLmJpbmRUZXh0dXJlKFAudHlwZSxudWxsKSxQLnR5cGU9dm9pZCAwLFAudGV4dHVyZT12b2lkIDApfWZ1bmN0aW9uIFkoKXt0cnl7bi5jb21wcmVzc2VkVGV4SW1hZ2UyRC5hcHBseShuLGFyZ3VtZW50cyl9Y2F0Y2goUCl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZToiLFApfX1mdW5jdGlvbiBLKCl7dHJ5e24uY29tcHJlc3NlZFRleEltYWdlM0QuYXBwbHkobixhcmd1bWVudHMpfWNhdGNoKFApe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMU3RhdGU6IixQKX19ZnVuY3Rpb24gaygpe3RyeXtuLnRleFN1YkltYWdlMkQuYXBwbHkobixhcmd1bWVudHMpfWNhdGNoKFApe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMU3RhdGU6IixQKX19ZnVuY3Rpb24gX2UoKXt0cnl7bi50ZXhTdWJJbWFnZTNELmFwcGx5KG4sYXJndW1lbnRzKX1jYXRjaChQKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFN0YXRlOiIsUCl9fWZ1bmN0aW9uIHNlKCl7dHJ5e24uY29tcHJlc3NlZFRleFN1YkltYWdlMkQuYXBwbHkobixhcmd1bWVudHMpfWNhdGNoKFApe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMU3RhdGU6IixQKX19ZnVuY3Rpb24gdWUoKXt0cnl7bi5jb21wcmVzc2VkVGV4U3ViSW1hZ2UzRC5hcHBseShuLGFyZ3VtZW50cyl9Y2F0Y2goUCl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZToiLFApfX1mdW5jdGlvbiBHZSgpe3RyeXtuLnRleFN0b3JhZ2UyRC5hcHBseShuLGFyZ3VtZW50cyl9Y2F0Y2goUCl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZToiLFApfX1mdW5jdGlvbiBqKCl7dHJ5e24udGV4U3RvcmFnZTNELmFwcGx5KG4sYXJndW1lbnRzKX1jYXRjaChQKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFN0YXRlOiIsUCl9fWZ1bmN0aW9uIGhlKCl7dHJ5e24udGV4SW1hZ2UyRC5hcHBseShuLGFyZ3VtZW50cyl9Y2F0Y2goUCl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZToiLFApfX1mdW5jdGlvbiBFZSgpe3RyeXtuLnRleEltYWdlM0QuYXBwbHkobixhcmd1bWVudHMpfWNhdGNoKFApe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMU3RhdGU6IixQKX19ZnVuY3Rpb24gVGUoUCl7WWUuZXF1YWxzKFApPT09ITEmJihuLnNjaXNzb3IoUC54LFAueSxQLnosUC53KSxZZS5jb3B5KFApKX1mdW5jdGlvbiBkZShQKXtYLmVxdWFscyhQKT09PSExJiYobi52aWV3cG9ydChQLngsUC55LFAueixQLncpLFguY29weShQKSl9ZnVuY3Rpb24gT2UoUCxuZSl7bGV0IEc9Yy5nZXQobmUpO0c9PT12b2lkIDAmJihHPW5ldyBXZWFrTWFwLGMuc2V0KG5lLEcpKTtsZXQgJD1HLmdldChQKTskPT09dm9pZCAwJiYoJD1uLmdldFVuaWZvcm1CbG9ja0luZGV4KG5lLFAubmFtZSksRy5zZXQoUCwkKSl9ZnVuY3Rpb24gTGUoUCxuZSl7Y29uc3QgJD1jLmdldChuZSkuZ2V0KFApO2wuZ2V0KG5lKSE9PSQmJihuLnVuaWZvcm1CbG9ja0JpbmRpbmcobmUsJCxQLl9fYmluZGluZ1BvaW50SW5kZXgpLGwuc2V0KG5lLCQpKX1mdW5jdGlvbiBLZSgpe24uZGlzYWJsZShuLkJMRU5EKSxuLmRpc2FibGUobi5DVUxMX0ZBQ0UpLG4uZGlzYWJsZShuLkRFUFRIX1RFU1QpLG4uZGlzYWJsZShuLlBPTFlHT05fT0ZGU0VUX0ZJTEwpLG4uZGlzYWJsZShuLlNDSVNTT1JfVEVTVCksbi5kaXNhYmxlKG4uU1RFTkNJTF9URVNUKSxuLmRpc2FibGUobi5TQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UpLG4uYmxlbmRFcXVhdGlvbihuLkZVTkNfQUREKSxuLmJsZW5kRnVuYyhuLk9ORSxuLlpFUk8pLG4uYmxlbmRGdW5jU2VwYXJhdGUobi5PTkUsbi5aRVJPLG4uT05FLG4uWkVSTyksbi5ibGVuZENvbG9yKDAsMCwwLDApLG4uY29sb3JNYXNrKCEwLCEwLCEwLCEwKSxuLmNsZWFyQ29sb3IoMCwwLDAsMCksbi5kZXB0aE1hc2soITApLG4uZGVwdGhGdW5jKG4uTEVTUyksby5zZXRSZXZlcnNlZCghMSksbi5jbGVhckRlcHRoKDEpLG4uc3RlbmNpbE1hc2soNDI5NDk2NzI5NSksbi5zdGVuY2lsRnVuYyhuLkFMV0FZUywwLDQyOTQ5NjcyOTUpLG4uc3RlbmNpbE9wKG4uS0VFUCxuLktFRVAsbi5LRUVQKSxuLmNsZWFyU3RlbmNpbCgwKSxuLmN1bGxGYWNlKG4uQkFDSyksbi5mcm9udEZhY2Uobi5DQ1cpLG4ucG9seWdvbk9mZnNldCgwLDApLG4uYWN0aXZlVGV4dHVyZShuLlRFWFRVUkUwKSxuLmJpbmRGcmFtZWJ1ZmZlcihuLkZSQU1FQlVGRkVSLG51bGwpLG4uYmluZEZyYW1lYnVmZmVyKG4uRFJBV19GUkFNRUJVRkZFUixudWxsKSxuLmJpbmRGcmFtZWJ1ZmZlcihuLlJFQURfRlJBTUVCVUZGRVIsbnVsbCksbi51c2VQcm9ncmFtKG51bGwpLG4ubGluZVdpZHRoKDEpLG4uc2Npc3NvcigwLDAsbi5jYW52YXMud2lkdGgsbi5jYW52YXMuaGVpZ2h0KSxuLnZpZXdwb3J0KDAsMCxuLmNhbnZhcy53aWR0aCxuLmNhbnZhcy5oZWlnaHQpLHU9e30saWU9bnVsbCxjZT17fSxkPXt9LGY9bmV3IFdlYWtNYXAscD1bXSxnPW51bGwseD0hMSxtPW51bGwsaD1udWxsLFQ9bnVsbCx5PW51bGwsXz1udWxsLEM9bnVsbCx3PW51bGwsYj1uZXcgVmUoMCwwLDApLEY9MCxFPSExLFM9bnVsbCxSPW51bGwscT1udWxsLHo9bnVsbCxXPW51bGwsWWUuc2V0KDAsMCxuLmNhbnZhcy53aWR0aCxuLmNhbnZhcy5oZWlnaHQpLFguc2V0KDAsMCxuLmNhbnZhcy53aWR0aCxuLmNhbnZhcy5oZWlnaHQpLHMucmVzZXQoKSxvLnJlc2V0KCksYS5yZXNldCgpfXJldHVybntidWZmZXJzOntjb2xvcjpzLGRlcHRoOm8sc3RlbmNpbDphfSxlbmFibGU6cmUsZGlzYWJsZTp5ZSxiaW5kRnJhbWVidWZmZXI6d2UsZHJhd0J1ZmZlcnM6RmUsdXNlUHJvZ3JhbTpudCxzZXRCbGVuZGluZzpVLHNldE1hdGVyaWFsOlB0LHNldEZsaXBTaWRlZDpJZSxzZXRDdWxsRmFjZTpOZSxzZXRMaW5lV2lkdGg6U2Usc2V0UG9seWdvbk9mZnNldDpqZSxzZXRTY2lzc29yVGVzdDpNZSxhY3RpdmVUZXh0dXJlOkEsYmluZFRleHR1cmU6dix1bmJpbmRUZXh0dXJlOkksY29tcHJlc3NlZFRleEltYWdlMkQ6WSxjb21wcmVzc2VkVGV4SW1hZ2UzRDpLLHRleEltYWdlMkQ6aGUsdGV4SW1hZ2UzRDpFZSx1cGRhdGVVQk9NYXBwaW5nOk9lLHVuaWZvcm1CbG9ja0JpbmRpbmc6TGUsdGV4U3RvcmFnZTJEOkdlLHRleFN0b3JhZ2UzRDpqLHRleFN1YkltYWdlMkQ6ayx0ZXhTdWJJbWFnZTNEOl9lLGNvbXByZXNzZWRUZXhTdWJJbWFnZTJEOnNlLGNvbXByZXNzZWRUZXhTdWJJbWFnZTNEOnVlLHNjaXNzb3I6VGUsdmlld3BvcnQ6ZGUscmVzZXQ6S2V9fWZ1bmN0aW9uIFBzKG4sZSx0LGkpe2NvbnN0IHI9THUoaSk7c3dpdGNoKHQpe2Nhc2UgMTAyMTpyZXR1cm4gbiplO2Nhc2UgMTAyNDpyZXR1cm4gbiplO2Nhc2UgMTAyNTpyZXR1cm4gbiplKjI7Y2FzZSAxMDI4OnJldHVybiBuKmUvci5jb21wb25lbnRzKnIuYnl0ZUxlbmd0aDtjYXNlIDEwMjk6cmV0dXJuIG4qZS9yLmNvbXBvbmVudHMqci5ieXRlTGVuZ3RoO2Nhc2UgMTAzMDpyZXR1cm4gbiplKjIvci5jb21wb25lbnRzKnIuYnl0ZUxlbmd0aDtjYXNlIDEwMzE6cmV0dXJuIG4qZSoyL3IuY29tcG9uZW50cypyLmJ5dGVMZW5ndGg7Y2FzZSAxMDIyOnJldHVybiBuKmUqMy9yLmNvbXBvbmVudHMqci5ieXRlTGVuZ3RoO2Nhc2UgMTAyMzpyZXR1cm4gbiplKjQvci5jb21wb25lbnRzKnIuYnl0ZUxlbmd0aDtjYXNlIDEwMzM6cmV0dXJuIG4qZSo0L3IuY29tcG9uZW50cypyLmJ5dGVMZW5ndGg7Y2FzZSAzMzc3NjpjYXNlIDMzNzc3OnJldHVybiBNYXRoLmZsb29yKChuKzMpLzQpKk1hdGguZmxvb3IoKGUrMykvNCkqODtjYXNlIDMzNzc4OmNhc2UgMzM3Nzk6cmV0dXJuIE1hdGguZmxvb3IoKG4rMykvNCkqTWF0aC5mbG9vcigoZSszKS80KSoxNjtjYXNlIDM1ODQxOmNhc2UgMzU4NDM6cmV0dXJuIE1hdGgubWF4KG4sMTYpKk1hdGgubWF4KGUsOCkvNDtjYXNlIDM1ODQwOmNhc2UgMzU4NDI6cmV0dXJuIE1hdGgubWF4KG4sOCkqTWF0aC5tYXgoZSw4KS8yO2Nhc2UgMzYxOTY6Y2FzZSAzNzQ5MjpyZXR1cm4gTWF0aC5mbG9vcigobiszKS80KSpNYXRoLmZsb29yKChlKzMpLzQpKjg7Y2FzZSAzNzQ5NjpyZXR1cm4gTWF0aC5mbG9vcigobiszKS80KSpNYXRoLmZsb29yKChlKzMpLzQpKjE2O2Nhc2UgMzc4MDg6cmV0dXJuIE1hdGguZmxvb3IoKG4rMykvNCkqTWF0aC5mbG9vcigoZSszKS80KSoxNjtjYXNlIDM3ODA5OnJldHVybiBNYXRoLmZsb29yKChuKzQpLzUpKk1hdGguZmxvb3IoKGUrMykvNCkqMTY7Y2FzZSAzNzgxMDpyZXR1cm4gTWF0aC5mbG9vcigobis0KS81KSpNYXRoLmZsb29yKChlKzQpLzUpKjE2O2Nhc2UgMzc4MTE6cmV0dXJuIE1hdGguZmxvb3IoKG4rNSkvNikqTWF0aC5mbG9vcigoZSs0KS81KSoxNjtjYXNlIDM3ODEyOnJldHVybiBNYXRoLmZsb29yKChuKzUpLzYpKk1hdGguZmxvb3IoKGUrNSkvNikqMTY7Y2FzZSAzNzgxMzpyZXR1cm4gTWF0aC5mbG9vcigobis3KS84KSpNYXRoLmZsb29yKChlKzQpLzUpKjE2O2Nhc2UgMzc4MTQ6cmV0dXJuIE1hdGguZmxvb3IoKG4rNykvOCkqTWF0aC5mbG9vcigoZSs1KS82KSoxNjtjYXNlIDM3ODE1OnJldHVybiBNYXRoLmZsb29yKChuKzcpLzgpKk1hdGguZmxvb3IoKGUrNykvOCkqMTY7Y2FzZSAzNzgxNjpyZXR1cm4gTWF0aC5mbG9vcigobis5KS8xMCkqTWF0aC5mbG9vcigoZSs0KS81KSoxNjtjYXNlIDM3ODE3OnJldHVybiBNYXRoLmZsb29yKChuKzkpLzEwKSpNYXRoLmZsb29yKChlKzUpLzYpKjE2O2Nhc2UgMzc4MTg6cmV0dXJuIE1hdGguZmxvb3IoKG4rOSkvMTApKk1hdGguZmxvb3IoKGUrNykvOCkqMTY7Y2FzZSAzNzgxOTpyZXR1cm4gTWF0aC5mbG9vcigobis5KS8xMCkqTWF0aC5mbG9vcigoZSs5KS8xMCkqMTY7Y2FzZSAzNzgyMDpyZXR1cm4gTWF0aC5mbG9vcigobisxMSkvMTIpKk1hdGguZmxvb3IoKGUrOSkvMTApKjE2O2Nhc2UgMzc4MjE6cmV0dXJuIE1hdGguZmxvb3IoKG4rMTEpLzEyKSpNYXRoLmZsb29yKChlKzExKS8xMikqMTY7Y2FzZSAzNjQ5MjpjYXNlIDM2NDk0OmNhc2UgMzY0OTU6cmV0dXJuIE1hdGguY2VpbChuLzQpKk1hdGguY2VpbChlLzQpKjE2O2Nhc2UgMzYyODM6Y2FzZSAzNjI4NDpyZXR1cm4gTWF0aC5jZWlsKG4vNCkqTWF0aC5jZWlsKGUvNCkqODtjYXNlIDM2Mjg1OmNhc2UgMzYyODY6cmV0dXJuIE1hdGguY2VpbChuLzQpKk1hdGguY2VpbChlLzQpKjE2fXRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGRldGVybWluZSB0ZXh0dXJlIGJ5dGUgbGVuZ3RoIGZvciAke3R9IGZvcm1hdC5gKX1mdW5jdGlvbiBMdShuKXtzd2l0Y2gobil7Y2FzZSAxMDA5OmNhc2UgMTAxMDpyZXR1cm57Ynl0ZUxlbmd0aDoxLGNvbXBvbmVudHM6MX07Y2FzZSAxMDEyOmNhc2UgMTAxMTpjYXNlIDEwMTY6cmV0dXJue2J5dGVMZW5ndGg6Mixjb21wb25lbnRzOjF9O2Nhc2UgMTAxNzpjYXNlIDEwMTg6cmV0dXJue2J5dGVMZW5ndGg6Mixjb21wb25lbnRzOjR9O2Nhc2UgMTAxNDpjYXNlIDEwMTM6Y2FzZSAxMDE1OnJldHVybntieXRlTGVuZ3RoOjQsY29tcG9uZW50czoxfTtjYXNlIDM1OTAyOnJldHVybntieXRlTGVuZ3RoOjQsY29tcG9uZW50czozfX10aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdGV4dHVyZSB0eXBlICR7bn0uYCl9ZnVuY3Rpb24gVXUobixlLHQsaSxyLHMsbyl7Y29uc3QgYT1lLmhhcygiV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlIik/ZS5nZXQoIldFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZSIpOm51bGwsbD10eXBlb2YgbmF2aWdhdG9yPiJ1Ij8hMTovT2N1bHVzQnJvd3Nlci9nLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksYz1uZXcgUGUsdT1uZXcgV2Vha01hcDtsZXQgZDtjb25zdCBmPW5ldyBXZWFrTWFwO2xldCBwPSExO3RyeXtwPXR5cGVvZiBPZmZzY3JlZW5DYW52YXM8InUiJiZuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSkuZ2V0Q29udGV4dCgiMmQiKSE9PW51bGx9Y2F0Y2h7fWZ1bmN0aW9uIGcoQSx2KXtyZXR1cm4gcD9uZXcgT2Zmc2NyZWVuQ2FudmFzKEEsdik6cmkoImNhbnZhcyIpfWZ1bmN0aW9uIHgoQSx2LEkpe2xldCBZPTE7Y29uc3QgSz1NZShBKTtpZigoSy53aWR0aD5JfHxLLmhlaWdodD5JKSYmKFk9SS9NYXRoLm1heChLLndpZHRoLEsuaGVpZ2h0KSksWTwxKWlmKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50PCJ1IiYmQSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnR8fHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudDwidSImJkEgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudHx8dHlwZW9mIEltYWdlQml0bWFwPCJ1IiYmQSBpbnN0YW5jZW9mIEltYWdlQml0bWFwfHx0eXBlb2YgVmlkZW9GcmFtZTwidSImJkEgaW5zdGFuY2VvZiBWaWRlb0ZyYW1lKXtjb25zdCBrPU1hdGguZmxvb3IoWSpLLndpZHRoKSxfZT1NYXRoLmZsb29yKFkqSy5oZWlnaHQpO2Q9PT12b2lkIDAmJihkPWcoayxfZSkpO2NvbnN0IHNlPXY/ZyhrLF9lKTpkO3JldHVybiBzZS53aWR0aD1rLHNlLmhlaWdodD1fZSxzZS5nZXRDb250ZXh0KCIyZCIpLmRyYXdJbWFnZShBLDAsMCxrLF9lKSxjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaGFzIGJlZW4gcmVzaXplZCBmcm9tICgiK0sud2lkdGgrIngiK0suaGVpZ2h0KyIpIHRvICgiK2srIngiK19lKyIpLiIpLHNlfWVsc2UgcmV0dXJuImRhdGEiaW4gQSYmY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBJbWFnZSBpbiBEYXRhVGV4dHVyZSBpcyB0b28gYmlnICgiK0sud2lkdGgrIngiK0suaGVpZ2h0KyIpLiIpLEE7cmV0dXJuIEF9ZnVuY3Rpb24gbShBKXtyZXR1cm4gQS5nZW5lcmF0ZU1pcG1hcHN9ZnVuY3Rpb24gaChBKXtuLmdlbmVyYXRlTWlwbWFwKEEpfWZ1bmN0aW9uIFQoQSl7cmV0dXJuIEEuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQ/bi5URVhUVVJFX0NVQkVfTUFQOkEuaXNXZWJHTDNEUmVuZGVyVGFyZ2V0P24uVEVYVFVSRV8zRDpBLmlzV2ViR0xBcnJheVJlbmRlclRhcmdldHx8QS5pc0NvbXByZXNzZWRBcnJheVRleHR1cmU/bi5URVhUVVJFXzJEX0FSUkFZOm4uVEVYVFVSRV8yRH1mdW5jdGlvbiB5KEEsdixJLFksSz0hMSl7aWYoQSE9PW51bGwpe2lmKG5bQV0hPT12b2lkIDApcmV0dXJuIG5bQV07Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIHVzZSBub24tZXhpc3RpbmcgV2ViR0wgaW50ZXJuYWwgZm9ybWF0ICciK0ErIiciKX1sZXQgaz12O2lmKHY9PT1uLlJFRCYmKEk9PT1uLkZMT0FUJiYoaz1uLlIzMkYpLEk9PT1uLkhBTEZfRkxPQVQmJihrPW4uUjE2RiksST09PW4uVU5TSUdORURfQllURSYmKGs9bi5SOCkpLHY9PT1uLlJFRF9JTlRFR0VSJiYoST09PW4uVU5TSUdORURfQllURSYmKGs9bi5SOFVJKSxJPT09bi5VTlNJR05FRF9TSE9SVCYmKGs9bi5SMTZVSSksST09PW4uVU5TSUdORURfSU5UJiYoaz1uLlIzMlVJKSxJPT09bi5CWVRFJiYoaz1uLlI4SSksST09PW4uU0hPUlQmJihrPW4uUjE2SSksST09PW4uSU5UJiYoaz1uLlIzMkkpKSx2PT09bi5SRyYmKEk9PT1uLkZMT0FUJiYoaz1uLlJHMzJGKSxJPT09bi5IQUxGX0ZMT0FUJiYoaz1uLlJHMTZGKSxJPT09bi5VTlNJR05FRF9CWVRFJiYoaz1uLlJHOCkpLHY9PT1uLlJHX0lOVEVHRVImJihJPT09bi5VTlNJR05FRF9CWVRFJiYoaz1uLlJHOFVJKSxJPT09bi5VTlNJR05FRF9TSE9SVCYmKGs9bi5SRzE2VUkpLEk9PT1uLlVOU0lHTkVEX0lOVCYmKGs9bi5SRzMyVUkpLEk9PT1uLkJZVEUmJihrPW4uUkc4SSksST09PW4uU0hPUlQmJihrPW4uUkcxNkkpLEk9PT1uLklOVCYmKGs9bi5SRzMySSkpLHY9PT1uLlJHQl9JTlRFR0VSJiYoST09PW4uVU5TSUdORURfQllURSYmKGs9bi5SR0I4VUkpLEk9PT1uLlVOU0lHTkVEX1NIT1JUJiYoaz1uLlJHQjE2VUkpLEk9PT1uLlVOU0lHTkVEX0lOVCYmKGs9bi5SR0IzMlVJKSxJPT09bi5CWVRFJiYoaz1uLlJHQjhJKSxJPT09bi5TSE9SVCYmKGs9bi5SR0IxNkkpLEk9PT1uLklOVCYmKGs9bi5SR0IzMkkpKSx2PT09bi5SR0JBX0lOVEVHRVImJihJPT09bi5VTlNJR05FRF9CWVRFJiYoaz1uLlJHQkE4VUkpLEk9PT1uLlVOU0lHTkVEX1NIT1JUJiYoaz1uLlJHQkExNlVJKSxJPT09bi5VTlNJR05FRF9JTlQmJihrPW4uUkdCQTMyVUkpLEk9PT1uLkJZVEUmJihrPW4uUkdCQThJKSxJPT09bi5TSE9SVCYmKGs9bi5SR0JBMTZJKSxJPT09bi5JTlQmJihrPW4uUkdCQTMySSkpLHY9PT1uLlJHQiYmST09PW4uVU5TSUdORURfSU5UXzVfOV85XzlfUkVWJiYoaz1uLlJHQjlfRTUpLHY9PT1uLlJHQkEpe2NvbnN0IF9lPUs/aWk6QmUuZ2V0VHJhbnNmZXIoWSk7ST09PW4uRkxPQVQmJihrPW4uUkdCQTMyRiksST09PW4uSEFMRl9GTE9BVCYmKGs9bi5SR0JBMTZGKSxJPT09bi5VTlNJR05FRF9CWVRFJiYoaz1fZT09PXFlP24uU1JHQjhfQUxQSEE4Om4uUkdCQTgpLEk9PT1uLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQmJihrPW4uUkdCQTQpLEk9PT1uLlVOU0lHTkVEX1NIT1JUXzVfNV81XzEmJihrPW4uUkdCNV9BMSl9cmV0dXJuKGs9PT1uLlIxNkZ8fGs9PT1uLlIzMkZ8fGs9PT1uLlJHMTZGfHxrPT09bi5SRzMyRnx8az09PW4uUkdCQTE2Rnx8az09PW4uUkdCQTMyRikmJmUuZ2V0KCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0Iiksa31mdW5jdGlvbiBfKEEsdil7bGV0IEk7cmV0dXJuIEE/dj09PW51bGx8fHY9PT0xMDE0fHx2PT09MTAyMD9JPW4uREVQVEgyNF9TVEVOQ0lMODp2PT09MTAxNT9JPW4uREVQVEgzMkZfU1RFTkNJTDg6dj09PTEwMTImJihJPW4uREVQVEgyNF9TVEVOQ0lMOCxjb25zb2xlLndhcm4oIkRlcHRoVGV4dHVyZTogMTYgYml0IGRlcHRoIGF0dGFjaG1lbnQgaXMgbm90IHN1cHBvcnRlZCB3aXRoIHN0ZW5jaWwuIFVzaW5nIDI0LWJpdCBhdHRhY2htZW50LiIpKTp2PT09bnVsbHx8dj09PTEwMTR8fHY9PT0xMDIwP0k9bi5ERVBUSF9DT01QT05FTlQyNDp2PT09MTAxNT9JPW4uREVQVEhfQ09NUE9ORU5UMzJGOnY9PT0xMDEyJiYoST1uLkRFUFRIX0NPTVBPTkVOVDE2KSxJfWZ1bmN0aW9uIEMoQSx2KXtyZXR1cm4gbShBKT09PSEwfHxBLmlzRnJhbWVidWZmZXJUZXh0dXJlJiZBLm1pbkZpbHRlciE9PTEwMDMmJkEubWluRmlsdGVyIT09MTAwNj9NYXRoLmxvZzIoTWF0aC5tYXgodi53aWR0aCx2LmhlaWdodCkpKzE6QS5taXBtYXBzIT09dm9pZCAwJiZBLm1pcG1hcHMubGVuZ3RoPjA/QS5taXBtYXBzLmxlbmd0aDpBLmlzQ29tcHJlc3NlZFRleHR1cmUmJkFycmF5LmlzQXJyYXkoQS5pbWFnZSk/di5taXBtYXBzLmxlbmd0aDoxfWZ1bmN0aW9uIHcoQSl7Y29uc3Qgdj1BLnRhcmdldDt2LnJlbW92ZUV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLHcpLEYodiksdi5pc1ZpZGVvVGV4dHVyZSYmdS5kZWxldGUodil9ZnVuY3Rpb24gYihBKXtjb25zdCB2PUEudGFyZ2V0O3YucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsYiksUyh2KX1mdW5jdGlvbiBGKEEpe2NvbnN0IHY9aS5nZXQoQSk7aWYodi5fX3dlYmdsSW5pdD09PXZvaWQgMClyZXR1cm47Y29uc3QgST1BLnNvdXJjZSxZPWYuZ2V0KEkpO2lmKFkpe2NvbnN0IEs9WVt2Ll9fY2FjaGVLZXldO0sudXNlZFRpbWVzLS0sSy51c2VkVGltZXM9PT0wJiZFKEEpLE9iamVjdC5rZXlzKFkpLmxlbmd0aD09PTAmJmYuZGVsZXRlKEkpfWkucmVtb3ZlKEEpfWZ1bmN0aW9uIEUoQSl7Y29uc3Qgdj1pLmdldChBKTtuLmRlbGV0ZVRleHR1cmUodi5fX3dlYmdsVGV4dHVyZSk7Y29uc3QgST1BLnNvdXJjZSxZPWYuZ2V0KEkpO2RlbGV0ZSBZW3YuX19jYWNoZUtleV0sby5tZW1vcnkudGV4dHVyZXMtLX1mdW5jdGlvbiBTKEEpe2NvbnN0IHY9aS5nZXQoQSk7aWYoQS5kZXB0aFRleHR1cmUmJihBLmRlcHRoVGV4dHVyZS5kaXNwb3NlKCksaS5yZW1vdmUoQS5kZXB0aFRleHR1cmUpKSxBLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KWZvcihsZXQgWT0wO1k8NjtZKyspe2lmKEFycmF5LmlzQXJyYXkodi5fX3dlYmdsRnJhbWVidWZmZXJbWV0pKWZvcihsZXQgSz0wO0s8di5fX3dlYmdsRnJhbWVidWZmZXJbWV0ubGVuZ3RoO0srKyluLmRlbGV0ZUZyYW1lYnVmZmVyKHYuX193ZWJnbEZyYW1lYnVmZmVyW1ldW0tdKTtlbHNlIG4uZGVsZXRlRnJhbWVidWZmZXIodi5fX3dlYmdsRnJhbWVidWZmZXJbWV0pO3YuX193ZWJnbERlcHRoYnVmZmVyJiZuLmRlbGV0ZVJlbmRlcmJ1ZmZlcih2Ll9fd2ViZ2xEZXB0aGJ1ZmZlcltZXSl9ZWxzZXtpZihBcnJheS5pc0FycmF5KHYuX193ZWJnbEZyYW1lYnVmZmVyKSlmb3IobGV0IFk9MDtZPHYuX193ZWJnbEZyYW1lYnVmZmVyLmxlbmd0aDtZKyspbi5kZWxldGVGcmFtZWJ1ZmZlcih2Ll9fd2ViZ2xGcmFtZWJ1ZmZlcltZXSk7ZWxzZSBuLmRlbGV0ZUZyYW1lYnVmZmVyKHYuX193ZWJnbEZyYW1lYnVmZmVyKTtpZih2Ll9fd2ViZ2xEZXB0aGJ1ZmZlciYmbi5kZWxldGVSZW5kZXJidWZmZXIodi5fX3dlYmdsRGVwdGhidWZmZXIpLHYuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyJiZuLmRlbGV0ZUZyYW1lYnVmZmVyKHYuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKSx2Ll9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcilmb3IobGV0IFk9MDtZPHYuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyLmxlbmd0aDtZKyspdi5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbWV0mJm4uZGVsZXRlUmVuZGVyYnVmZmVyKHYuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyW1ldKTt2Ll9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlciYmbi5kZWxldGVSZW5kZXJidWZmZXIodi5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIpfWNvbnN0IEk9QS50ZXh0dXJlcztmb3IobGV0IFk9MCxLPUkubGVuZ3RoO1k8SztZKyspe2NvbnN0IGs9aS5nZXQoSVtZXSk7ay5fX3dlYmdsVGV4dHVyZSYmKG4uZGVsZXRlVGV4dHVyZShrLl9fd2ViZ2xUZXh0dXJlKSxvLm1lbW9yeS50ZXh0dXJlcy0tKSxpLnJlbW92ZShJW1ldKX1pLnJlbW92ZShBKX1sZXQgUj0wO2Z1bmN0aW9uIHEoKXtSPTB9ZnVuY3Rpb24geigpe2NvbnN0IEE9UjtyZXR1cm4gQT49ci5tYXhUZXh0dXJlcyYmY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFRleHR1cmVzOiBUcnlpbmcgdG8gdXNlICIrQSsiIHRleHR1cmUgdW5pdHMgd2hpbGUgdGhpcyBHUFUgc3VwcG9ydHMgb25seSAiK3IubWF4VGV4dHVyZXMpLFIrPTEsQX1mdW5jdGlvbiBXKEEpe2NvbnN0IHY9W107cmV0dXJuIHYucHVzaChBLndyYXBTKSx2LnB1c2goQS53cmFwVCksdi5wdXNoKEEud3JhcFJ8fDApLHYucHVzaChBLm1hZ0ZpbHRlciksdi5wdXNoKEEubWluRmlsdGVyKSx2LnB1c2goQS5hbmlzb3Ryb3B5KSx2LnB1c2goQS5pbnRlcm5hbEZvcm1hdCksdi5wdXNoKEEuZm9ybWF0KSx2LnB1c2goQS50eXBlKSx2LnB1c2goQS5nZW5lcmF0ZU1pcG1hcHMpLHYucHVzaChBLnByZW11bHRpcGx5QWxwaGEpLHYucHVzaChBLmZsaXBZKSx2LnB1c2goQS51bnBhY2tBbGlnbm1lbnQpLHYucHVzaChBLmNvbG9yU3BhY2UpLHYuam9pbigpfWZ1bmN0aW9uIFooQSx2KXtjb25zdCBJPWkuZ2V0KEEpO2lmKEEuaXNWaWRlb1RleHR1cmUmJlNlKEEpLEEuaXNSZW5kZXJUYXJnZXRUZXh0dXJlPT09ITEmJkEudmVyc2lvbj4wJiZJLl9fdmVyc2lvbiE9PUEudmVyc2lvbil7Y29uc3QgWT1BLmltYWdlO2lmKFk9PT1udWxsKWNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgbm8gaW1hZ2UgZGF0YSBmb3VuZC4iKTtlbHNlIGlmKFkuY29tcGxldGU9PT0hMSljb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIGluY29tcGxldGUiKTtlbHNle1goSSxBLHYpO3JldHVybn19dC5iaW5kVGV4dHVyZShuLlRFWFRVUkVfMkQsSS5fX3dlYmdsVGV4dHVyZSxuLlRFWFRVUkUwK3YpfWZ1bmN0aW9uIFYoQSx2KXtjb25zdCBJPWkuZ2V0KEEpO2lmKEEudmVyc2lvbj4wJiZJLl9fdmVyc2lvbiE9PUEudmVyc2lvbil7WChJLEEsdik7cmV0dXJufXQuYmluZFRleHR1cmUobi5URVhUVVJFXzJEX0FSUkFZLEkuX193ZWJnbFRleHR1cmUsbi5URVhUVVJFMCt2KX1mdW5jdGlvbiBRKEEsdil7Y29uc3QgST1pLmdldChBKTtpZihBLnZlcnNpb24+MCYmSS5fX3ZlcnNpb24hPT1BLnZlcnNpb24pe1goSSxBLHYpO3JldHVybn10LmJpbmRUZXh0dXJlKG4uVEVYVFVSRV8zRCxJLl9fd2ViZ2xUZXh0dXJlLG4uVEVYVFVSRTArdil9ZnVuY3Rpb24gSChBLHYpe2NvbnN0IEk9aS5nZXQoQSk7aWYoQS52ZXJzaW9uPjAmJkkuX192ZXJzaW9uIT09QS52ZXJzaW9uKXtlZShJLEEsdik7cmV0dXJufXQuYmluZFRleHR1cmUobi5URVhUVVJFX0NVQkVfTUFQLEkuX193ZWJnbFRleHR1cmUsbi5URVhUVVJFMCt2KX1jb25zdCBpZT17MWUzOm4uUkVQRUFULDEwMDE6bi5DTEFNUF9UT19FREdFLDEwMDI6bi5NSVJST1JFRF9SRVBFQVR9LGNlPXsxMDAzOm4uTkVBUkVTVCwxMDA0Om4uTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCwxMDA1Om4uTkVBUkVTVF9NSVBNQVBfTElORUFSLDEwMDY6bi5MSU5FQVIsMTAwNzpuLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCwxMDA4Om4uTElORUFSX01JUE1BUF9MSU5FQVJ9LHhlPXs1MTI6bi5ORVZFUiw1MTk6bi5BTFdBWVMsNTEzOm4uTEVTUyw1MTU6bi5MRVFVQUwsNTE0Om4uRVFVQUwsNTE4Om4uR0VRVUFMLDUxNjpuLkdSRUFURVIsNTE3Om4uTk9URVFVQUx9O2Z1bmN0aW9uIFVlKEEsdil7aWYodi50eXBlPT09MTAxNSYmZS5oYXMoIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhciIpPT09ITEmJih2Lm1hZ0ZpbHRlcj09PTEwMDZ8fHYubWFnRmlsdGVyPT09MTAwN3x8di5tYWdGaWx0ZXI9PT0xMDA1fHx2Lm1hZ0ZpbHRlcj09PTEwMDh8fHYubWluRmlsdGVyPT09MTAwNnx8di5taW5GaWx0ZXI9PT0xMDA3fHx2Lm1pbkZpbHRlcj09PTEwMDV8fHYubWluRmlsdGVyPT09MTAwOCkmJmNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5hYmxlIHRvIHVzZSBsaW5lYXIgZmlsdGVyaW5nIHdpdGggZmxvYXRpbmcgcG9pbnQgdGV4dHVyZXMuIE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhciBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlLiIpLG4udGV4UGFyYW1ldGVyaShBLG4uVEVYVFVSRV9XUkFQX1MsaWVbdi53cmFwU10pLG4udGV4UGFyYW1ldGVyaShBLG4uVEVYVFVSRV9XUkFQX1QsaWVbdi53cmFwVF0pLChBPT09bi5URVhUVVJFXzNEfHxBPT09bi5URVhUVVJFXzJEX0FSUkFZKSYmbi50ZXhQYXJhbWV0ZXJpKEEsbi5URVhUVVJFX1dSQVBfUixpZVt2LndyYXBSXSksbi50ZXhQYXJhbWV0ZXJpKEEsbi5URVhUVVJFX01BR19GSUxURVIsY2Vbdi5tYWdGaWx0ZXJdKSxuLnRleFBhcmFtZXRlcmkoQSxuLlRFWFRVUkVfTUlOX0ZJTFRFUixjZVt2Lm1pbkZpbHRlcl0pLHYuY29tcGFyZUZ1bmN0aW9uJiYobi50ZXhQYXJhbWV0ZXJpKEEsbi5URVhUVVJFX0NPTVBBUkVfTU9ERSxuLkNPTVBBUkVfUkVGX1RPX1RFWFRVUkUpLG4udGV4UGFyYW1ldGVyaShBLG4uVEVYVFVSRV9DT01QQVJFX0ZVTkMseGVbdi5jb21wYXJlRnVuY3Rpb25dKSksZS5oYXMoIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyIpPT09ITApe2lmKHYubWFnRmlsdGVyPT09MTAwM3x8di5taW5GaWx0ZXIhPT0xMDA1JiZ2Lm1pbkZpbHRlciE9PTEwMDh8fHYudHlwZT09PTEwMTUmJmUuaGFzKCJPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXIiKT09PSExKXJldHVybjtpZih2LmFuaXNvdHJvcHk+MXx8aS5nZXQodikuX19jdXJyZW50QW5pc290cm9weSl7Y29uc3QgST1lLmdldCgiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljIik7bi50ZXhQYXJhbWV0ZXJmKEEsSS5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCxNYXRoLm1pbih2LmFuaXNvdHJvcHksci5nZXRNYXhBbmlzb3Ryb3B5KCkpKSxpLmdldCh2KS5fX2N1cnJlbnRBbmlzb3Ryb3B5PXYuYW5pc290cm9weX19fWZ1bmN0aW9uIFllKEEsdil7bGV0IEk9ITE7QS5fX3dlYmdsSW5pdD09PXZvaWQgMCYmKEEuX193ZWJnbEluaXQ9ITAsdi5hZGRFdmVudExpc3RlbmVyKCJkaXNwb3NlIix3KSk7Y29uc3QgWT12LnNvdXJjZTtsZXQgSz1mLmdldChZKTtLPT09dm9pZCAwJiYoSz17fSxmLnNldChZLEspKTtjb25zdCBrPVcodik7aWYoayE9PUEuX19jYWNoZUtleSl7S1trXT09PXZvaWQgMCYmKEtba109e3RleHR1cmU6bi5jcmVhdGVUZXh0dXJlKCksdXNlZFRpbWVzOjB9LG8ubWVtb3J5LnRleHR1cmVzKyssST0hMCksS1trXS51c2VkVGltZXMrKztjb25zdCBfZT1LW0EuX19jYWNoZUtleV07X2UhPT12b2lkIDAmJihLW0EuX19jYWNoZUtleV0udXNlZFRpbWVzLS0sX2UudXNlZFRpbWVzPT09MCYmRSh2KSksQS5fX2NhY2hlS2V5PWssQS5fX3dlYmdsVGV4dHVyZT1LW2tdLnRleHR1cmV9cmV0dXJuIEl9ZnVuY3Rpb24gWChBLHYsSSl7bGV0IFk9bi5URVhUVVJFXzJEOyh2LmlzRGF0YUFycmF5VGV4dHVyZXx8di5pc0NvbXByZXNzZWRBcnJheVRleHR1cmUpJiYoWT1uLlRFWFRVUkVfMkRfQVJSQVkpLHYuaXNEYXRhM0RUZXh0dXJlJiYoWT1uLlRFWFRVUkVfM0QpO2NvbnN0IEs9WWUoQSx2KSxrPXYuc291cmNlO3QuYmluZFRleHR1cmUoWSxBLl9fd2ViZ2xUZXh0dXJlLG4uVEVYVFVSRTArSSk7Y29uc3QgX2U9aS5nZXQoayk7aWYoay52ZXJzaW9uIT09X2UuX192ZXJzaW9ufHxLPT09ITApe3QuYWN0aXZlVGV4dHVyZShuLlRFWFRVUkUwK0kpO2NvbnN0IHNlPUJlLmdldFByaW1hcmllcyhCZS53b3JraW5nQ29sb3JTcGFjZSksdWU9di5jb2xvclNwYWNlPT09anQ/bnVsbDpCZS5nZXRQcmltYXJpZXModi5jb2xvclNwYWNlKSxHZT12LmNvbG9yU3BhY2U9PT1qdHx8c2U9PT11ZT9uLk5PTkU6bi5CUk9XU0VSX0RFRkFVTFRfV0VCR0w7bi5waXhlbFN0b3JlaShuLlVOUEFDS19GTElQX1lfV0VCR0wsdi5mbGlwWSksbi5waXhlbFN0b3JlaShuLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCx2LnByZW11bHRpcGx5QWxwaGEpLG4ucGl4ZWxTdG9yZWkobi5VTlBBQ0tfQUxJR05NRU5ULHYudW5wYWNrQWxpZ25tZW50KSxuLnBpeGVsU3RvcmVpKG4uVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCxHZSk7bGV0IGo9eCh2LmltYWdlLCExLHIubWF4VGV4dHVyZVNpemUpO2o9amUodixqKTtjb25zdCBoZT1zLmNvbnZlcnQodi5mb3JtYXQsdi5jb2xvclNwYWNlKSxFZT1zLmNvbnZlcnQodi50eXBlKTtsZXQgVGU9eSh2LmludGVybmFsRm9ybWF0LGhlLEVlLHYuY29sb3JTcGFjZSx2LmlzVmlkZW9UZXh0dXJlKTtVZShZLHYpO2xldCBkZTtjb25zdCBPZT12Lm1pcG1hcHMsTGU9di5pc1ZpZGVvVGV4dHVyZSE9PSEwLEtlPV9lLl9fdmVyc2lvbj09PXZvaWQgMHx8Sz09PSEwLFA9ay5kYXRhUmVhZHksbmU9Qyh2LGopO2lmKHYuaXNEZXB0aFRleHR1cmUpVGU9Xyh2LmZvcm1hdD09PTEwMjcsdi50eXBlKSxLZSYmKExlP3QudGV4U3RvcmFnZTJEKG4uVEVYVFVSRV8yRCwxLFRlLGoud2lkdGgsai5oZWlnaHQpOnQudGV4SW1hZ2UyRChuLlRFWFRVUkVfMkQsMCxUZSxqLndpZHRoLGouaGVpZ2h0LDAsaGUsRWUsbnVsbCkpO2Vsc2UgaWYodi5pc0RhdGFUZXh0dXJlKWlmKE9lLmxlbmd0aD4wKXtMZSYmS2UmJnQudGV4U3RvcmFnZTJEKG4uVEVYVFVSRV8yRCxuZSxUZSxPZVswXS53aWR0aCxPZVswXS5oZWlnaHQpO2ZvcihsZXQgRz0wLCQ9T2UubGVuZ3RoO0c8JDtHKyspZGU9T2VbR10sTGU/UCYmdC50ZXhTdWJJbWFnZTJEKG4uVEVYVFVSRV8yRCxHLDAsMCxkZS53aWR0aCxkZS5oZWlnaHQsaGUsRWUsZGUuZGF0YSk6dC50ZXhJbWFnZTJEKG4uVEVYVFVSRV8yRCxHLFRlLGRlLndpZHRoLGRlLmhlaWdodCwwLGhlLEVlLGRlLmRhdGEpO3YuZ2VuZXJhdGVNaXBtYXBzPSExfWVsc2UgTGU/KEtlJiZ0LnRleFN0b3JhZ2UyRChuLlRFWFRVUkVfMkQsbmUsVGUsai53aWR0aCxqLmhlaWdodCksUCYmdC50ZXhTdWJJbWFnZTJEKG4uVEVYVFVSRV8yRCwwLDAsMCxqLndpZHRoLGouaGVpZ2h0LGhlLEVlLGouZGF0YSkpOnQudGV4SW1hZ2UyRChuLlRFWFRVUkVfMkQsMCxUZSxqLndpZHRoLGouaGVpZ2h0LDAsaGUsRWUsai5kYXRhKTtlbHNlIGlmKHYuaXNDb21wcmVzc2VkVGV4dHVyZSlpZih2LmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSl7TGUmJktlJiZ0LnRleFN0b3JhZ2UzRChuLlRFWFRVUkVfMkRfQVJSQVksbmUsVGUsT2VbMF0ud2lkdGgsT2VbMF0uaGVpZ2h0LGouZGVwdGgpO2ZvcihsZXQgRz0wLCQ9T2UubGVuZ3RoO0c8JDtHKyspaWYoZGU9T2VbR10sdi5mb3JtYXQhPT0xMDIzKWlmKGhlIT09bnVsbClpZihMZSl7aWYoUClpZih2LmxheWVyVXBkYXRlcy5zaXplPjApe2NvbnN0IGxlPVBzKGRlLndpZHRoLGRlLmhlaWdodCx2LmZvcm1hdCx2LnR5cGUpO2Zvcihjb25zdCBhZSBvZiB2LmxheWVyVXBkYXRlcyl7Y29uc3QgUmU9ZGUuZGF0YS5zdWJhcnJheShhZSpsZS9kZS5kYXRhLkJZVEVTX1BFUl9FTEVNRU5ULChhZSsxKSpsZS9kZS5kYXRhLkJZVEVTX1BFUl9FTEVNRU5UKTt0LmNvbXByZXNzZWRUZXhTdWJJbWFnZTNEKG4uVEVYVFVSRV8yRF9BUlJBWSxHLDAsMCxhZSxkZS53aWR0aCxkZS5oZWlnaHQsMSxoZSxSZSl9di5jbGVhckxheWVyVXBkYXRlcygpfWVsc2UgdC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UzRChuLlRFWFRVUkVfMkRfQVJSQVksRywwLDAsMCxkZS53aWR0aCxkZS5oZWlnaHQsai5kZXB0aCxoZSxkZS5kYXRhKX1lbHNlIHQuY29tcHJlc3NlZFRleEltYWdlM0Qobi5URVhUVVJFXzJEX0FSUkFZLEcsVGUsZGUud2lkdGgsZGUuaGVpZ2h0LGouZGVwdGgsMCxkZS5kYXRhLDAsMCk7ZWxzZSBjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC51cGxvYWRUZXh0dXJlKCkiKTtlbHNlIExlP1AmJnQudGV4U3ViSW1hZ2UzRChuLlRFWFRVUkVfMkRfQVJSQVksRywwLDAsMCxkZS53aWR0aCxkZS5oZWlnaHQsai5kZXB0aCxoZSxFZSxkZS5kYXRhKTp0LnRleEltYWdlM0Qobi5URVhUVVJFXzJEX0FSUkFZLEcsVGUsZGUud2lkdGgsZGUuaGVpZ2h0LGouZGVwdGgsMCxoZSxFZSxkZS5kYXRhKX1lbHNle0xlJiZLZSYmdC50ZXhTdG9yYWdlMkQobi5URVhUVVJFXzJELG5lLFRlLE9lWzBdLndpZHRoLE9lWzBdLmhlaWdodCk7Zm9yKGxldCBHPTAsJD1PZS5sZW5ndGg7RzwkO0crKylkZT1PZVtHXSx2LmZvcm1hdCE9PTEwMjM/aGUhPT1udWxsP0xlP1AmJnQuY29tcHJlc3NlZFRleFN1YkltYWdlMkQobi5URVhUVVJFXzJELEcsMCwwLGRlLndpZHRoLGRlLmhlaWdodCxoZSxkZS5kYXRhKTp0LmNvbXByZXNzZWRUZXhJbWFnZTJEKG4uVEVYVFVSRV8yRCxHLFRlLGRlLndpZHRoLGRlLmhlaWdodCwwLGRlLmRhdGEpOmNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnVwbG9hZFRleHR1cmUoKSIpOkxlP1AmJnQudGV4U3ViSW1hZ2UyRChuLlRFWFRVUkVfMkQsRywwLDAsZGUud2lkdGgsZGUuaGVpZ2h0LGhlLEVlLGRlLmRhdGEpOnQudGV4SW1hZ2UyRChuLlRFWFRVUkVfMkQsRyxUZSxkZS53aWR0aCxkZS5oZWlnaHQsMCxoZSxFZSxkZS5kYXRhKX1lbHNlIGlmKHYuaXNEYXRhQXJyYXlUZXh0dXJlKWlmKExlKXtpZihLZSYmdC50ZXhTdG9yYWdlM0Qobi5URVhUVVJFXzJEX0FSUkFZLG5lLFRlLGoud2lkdGgsai5oZWlnaHQsai5kZXB0aCksUClpZih2LmxheWVyVXBkYXRlcy5zaXplPjApe2NvbnN0IEc9UHMoai53aWR0aCxqLmhlaWdodCx2LmZvcm1hdCx2LnR5cGUpO2Zvcihjb25zdCAkIG9mIHYubGF5ZXJVcGRhdGVzKXtjb25zdCBsZT1qLmRhdGEuc3ViYXJyYXkoJCpHL2ouZGF0YS5CWVRFU19QRVJfRUxFTUVOVCwoJCsxKSpHL2ouZGF0YS5CWVRFU19QRVJfRUxFTUVOVCk7dC50ZXhTdWJJbWFnZTNEKG4uVEVYVFVSRV8yRF9BUlJBWSwwLDAsMCwkLGoud2lkdGgsai5oZWlnaHQsMSxoZSxFZSxsZSl9di5jbGVhckxheWVyVXBkYXRlcygpfWVsc2UgdC50ZXhTdWJJbWFnZTNEKG4uVEVYVFVSRV8yRF9BUlJBWSwwLDAsMCwwLGoud2lkdGgsai5oZWlnaHQsai5kZXB0aCxoZSxFZSxqLmRhdGEpfWVsc2UgdC50ZXhJbWFnZTNEKG4uVEVYVFVSRV8yRF9BUlJBWSwwLFRlLGoud2lkdGgsai5oZWlnaHQsai5kZXB0aCwwLGhlLEVlLGouZGF0YSk7ZWxzZSBpZih2LmlzRGF0YTNEVGV4dHVyZSlMZT8oS2UmJnQudGV4U3RvcmFnZTNEKG4uVEVYVFVSRV8zRCxuZSxUZSxqLndpZHRoLGouaGVpZ2h0LGouZGVwdGgpLFAmJnQudGV4U3ViSW1hZ2UzRChuLlRFWFRVUkVfM0QsMCwwLDAsMCxqLndpZHRoLGouaGVpZ2h0LGouZGVwdGgsaGUsRWUsai5kYXRhKSk6dC50ZXhJbWFnZTNEKG4uVEVYVFVSRV8zRCwwLFRlLGoud2lkdGgsai5oZWlnaHQsai5kZXB0aCwwLGhlLEVlLGouZGF0YSk7ZWxzZSBpZih2LmlzRnJhbWVidWZmZXJUZXh0dXJlKXtpZihLZSlpZihMZSl0LnRleFN0b3JhZ2UyRChuLlRFWFRVUkVfMkQsbmUsVGUsai53aWR0aCxqLmhlaWdodCk7ZWxzZXtsZXQgRz1qLndpZHRoLCQ9ai5oZWlnaHQ7Zm9yKGxldCBsZT0wO2xlPG5lO2xlKyspdC50ZXhJbWFnZTJEKG4uVEVYVFVSRV8yRCxsZSxUZSxHLCQsMCxoZSxFZSxudWxsKSxHPj49MSwkPj49MX19ZWxzZSBpZihPZS5sZW5ndGg+MCl7aWYoTGUmJktlKXtjb25zdCBHPU1lKE9lWzBdKTt0LnRleFN0b3JhZ2UyRChuLlRFWFRVUkVfMkQsbmUsVGUsRy53aWR0aCxHLmhlaWdodCl9Zm9yKGxldCBHPTAsJD1PZS5sZW5ndGg7RzwkO0crKylkZT1PZVtHXSxMZT9QJiZ0LnRleFN1YkltYWdlMkQobi5URVhUVVJFXzJELEcsMCwwLGhlLEVlLGRlKTp0LnRleEltYWdlMkQobi5URVhUVVJFXzJELEcsVGUsaGUsRWUsZGUpO3YuZ2VuZXJhdGVNaXBtYXBzPSExfWVsc2UgaWYoTGUpe2lmKEtlKXtjb25zdCBHPU1lKGopO3QudGV4U3RvcmFnZTJEKG4uVEVYVFVSRV8yRCxuZSxUZSxHLndpZHRoLEcuaGVpZ2h0KX1QJiZ0LnRleFN1YkltYWdlMkQobi5URVhUVVJFXzJELDAsMCwwLGhlLEVlLGopfWVsc2UgdC50ZXhJbWFnZTJEKG4uVEVYVFVSRV8yRCwwLFRlLGhlLEVlLGopO20odikmJmgoWSksX2UuX192ZXJzaW9uPWsudmVyc2lvbix2Lm9uVXBkYXRlJiZ2Lm9uVXBkYXRlKHYpfUEuX192ZXJzaW9uPXYudmVyc2lvbn1mdW5jdGlvbiBlZShBLHYsSSl7aWYodi5pbWFnZS5sZW5ndGghPT02KXJldHVybjtjb25zdCBZPVllKEEsdiksSz12LnNvdXJjZTt0LmJpbmRUZXh0dXJlKG4uVEVYVFVSRV9DVUJFX01BUCxBLl9fd2ViZ2xUZXh0dXJlLG4uVEVYVFVSRTArSSk7Y29uc3Qgaz1pLmdldChLKTtpZihLLnZlcnNpb24hPT1rLl9fdmVyc2lvbnx8WT09PSEwKXt0LmFjdGl2ZVRleHR1cmUobi5URVhUVVJFMCtJKTtjb25zdCBfZT1CZS5nZXRQcmltYXJpZXMoQmUud29ya2luZ0NvbG9yU3BhY2UpLHNlPXYuY29sb3JTcGFjZT09PWp0P251bGw6QmUuZ2V0UHJpbWFyaWVzKHYuY29sb3JTcGFjZSksdWU9di5jb2xvclNwYWNlPT09anR8fF9lPT09c2U/bi5OT05FOm4uQlJPV1NFUl9ERUZBVUxUX1dFQkdMO24ucGl4ZWxTdG9yZWkobi5VTlBBQ0tfRkxJUF9ZX1dFQkdMLHYuZmxpcFkpLG4ucGl4ZWxTdG9yZWkobi5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsdi5wcmVtdWx0aXBseUFscGhhKSxuLnBpeGVsU3RvcmVpKG4uVU5QQUNLX0FMSUdOTUVOVCx2LnVucGFja0FsaWdubWVudCksbi5waXhlbFN0b3JlaShuLlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wsdWUpO2NvbnN0IEdlPXYuaXNDb21wcmVzc2VkVGV4dHVyZXx8di5pbWFnZVswXS5pc0NvbXByZXNzZWRUZXh0dXJlLGo9di5pbWFnZVswXSYmdi5pbWFnZVswXS5pc0RhdGFUZXh0dXJlLGhlPVtdO2ZvcihsZXQgJD0wOyQ8NjskKyspIUdlJiYhaj9oZVskXT14KHYuaW1hZ2VbJF0sITAsci5tYXhDdWJlbWFwU2l6ZSk6aGVbJF09aj92LmltYWdlWyRdLmltYWdlOnYuaW1hZ2VbJF0saGVbJF09amUodixoZVskXSk7Y29uc3QgRWU9aGVbMF0sVGU9cy5jb252ZXJ0KHYuZm9ybWF0LHYuY29sb3JTcGFjZSksZGU9cy5jb252ZXJ0KHYudHlwZSksT2U9eSh2LmludGVybmFsRm9ybWF0LFRlLGRlLHYuY29sb3JTcGFjZSksTGU9di5pc1ZpZGVvVGV4dHVyZSE9PSEwLEtlPWsuX192ZXJzaW9uPT09dm9pZCAwfHxZPT09ITAsUD1LLmRhdGFSZWFkeTtsZXQgbmU9Qyh2LEVlKTtVZShuLlRFWFRVUkVfQ1VCRV9NQVAsdik7bGV0IEc7aWYoR2Upe0xlJiZLZSYmdC50ZXhTdG9yYWdlMkQobi5URVhUVVJFX0NVQkVfTUFQLG5lLE9lLEVlLndpZHRoLEVlLmhlaWdodCk7Zm9yKGxldCAkPTA7JDw2OyQrKyl7Rz1oZVskXS5taXBtYXBzO2ZvcihsZXQgbGU9MDtsZTxHLmxlbmd0aDtsZSsrKXtjb25zdCBhZT1HW2xlXTt2LmZvcm1hdCE9PTEwMjM/VGUhPT1udWxsP0xlP1AmJnQuY29tcHJlc3NlZFRleFN1YkltYWdlMkQobi5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grJCxsZSwwLDAsYWUud2lkdGgsYWUuaGVpZ2h0LFRlLGFlLmRhdGEpOnQuY29tcHJlc3NlZFRleEltYWdlMkQobi5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grJCxsZSxPZSxhZS53aWR0aCxhZS5oZWlnaHQsMCxhZS5kYXRhKTpjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC5zZXRUZXh0dXJlQ3ViZSgpIik6TGU/UCYmdC50ZXhTdWJJbWFnZTJEKG4uVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YKyQsbGUsMCwwLGFlLndpZHRoLGFlLmhlaWdodCxUZSxkZSxhZS5kYXRhKTp0LnRleEltYWdlMkQobi5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grJCxsZSxPZSxhZS53aWR0aCxhZS5oZWlnaHQsMCxUZSxkZSxhZS5kYXRhKX19fWVsc2V7aWYoRz12Lm1pcG1hcHMsTGUmJktlKXtHLmxlbmd0aD4wJiZuZSsrO2NvbnN0ICQ9TWUoaGVbMF0pO3QudGV4U3RvcmFnZTJEKG4uVEVYVFVSRV9DVUJFX01BUCxuZSxPZSwkLndpZHRoLCQuaGVpZ2h0KX1mb3IobGV0ICQ9MDskPDY7JCsrKWlmKGope0xlP1AmJnQudGV4U3ViSW1hZ2UyRChuLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCskLDAsMCwwLGhlWyRdLndpZHRoLGhlWyRdLmhlaWdodCxUZSxkZSxoZVskXS5kYXRhKTp0LnRleEltYWdlMkQobi5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grJCwwLE9lLGhlWyRdLndpZHRoLGhlWyRdLmhlaWdodCwwLFRlLGRlLGhlWyRdLmRhdGEpO2ZvcihsZXQgbGU9MDtsZTxHLmxlbmd0aDtsZSsrKXtjb25zdCBSZT1HW2xlXS5pbWFnZVskXS5pbWFnZTtMZT9QJiZ0LnRleFN1YkltYWdlMkQobi5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grJCxsZSsxLDAsMCxSZS53aWR0aCxSZS5oZWlnaHQsVGUsZGUsUmUuZGF0YSk6dC50ZXhJbWFnZTJEKG4uVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YKyQsbGUrMSxPZSxSZS53aWR0aCxSZS5oZWlnaHQsMCxUZSxkZSxSZS5kYXRhKX19ZWxzZXtMZT9QJiZ0LnRleFN1YkltYWdlMkQobi5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grJCwwLDAsMCxUZSxkZSxoZVskXSk6dC50ZXhJbWFnZTJEKG4uVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YKyQsMCxPZSxUZSxkZSxoZVskXSk7Zm9yKGxldCBsZT0wO2xlPEcubGVuZ3RoO2xlKyspe2NvbnN0IGFlPUdbbGVdO0xlP1AmJnQudGV4U3ViSW1hZ2UyRChuLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCskLGxlKzEsMCwwLFRlLGRlLGFlLmltYWdlWyRdKTp0LnRleEltYWdlMkQobi5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grJCxsZSsxLE9lLFRlLGRlLGFlLmltYWdlWyRdKX19fW0odikmJmgobi5URVhUVVJFX0NVQkVfTUFQKSxrLl9fdmVyc2lvbj1LLnZlcnNpb24sdi5vblVwZGF0ZSYmdi5vblVwZGF0ZSh2KX1BLl9fdmVyc2lvbj12LnZlcnNpb259ZnVuY3Rpb24gZ2UoQSx2LEksWSxLLGspe2NvbnN0IF9lPXMuY29udmVydChJLmZvcm1hdCxJLmNvbG9yU3BhY2UpLHNlPXMuY29udmVydChJLnR5cGUpLHVlPXkoSS5pbnRlcm5hbEZvcm1hdCxfZSxzZSxJLmNvbG9yU3BhY2UpLEdlPWkuZ2V0KHYpLGo9aS5nZXQoSSk7aWYoai5fX3JlbmRlclRhcmdldD12LCFHZS5fX2hhc0V4dGVybmFsVGV4dHVyZXMpe2NvbnN0IGhlPU1hdGgubWF4KDEsdi53aWR0aD4+ayksRWU9TWF0aC5tYXgoMSx2LmhlaWdodD4+ayk7Sz09PW4uVEVYVFVSRV8zRHx8Sz09PW4uVEVYVFVSRV8yRF9BUlJBWT90LnRleEltYWdlM0QoSyxrLHVlLGhlLEVlLHYuZGVwdGgsMCxfZSxzZSxudWxsKTp0LnRleEltYWdlMkQoSyxrLHVlLGhlLEVlLDAsX2Usc2UsbnVsbCl9dC5iaW5kRnJhbWVidWZmZXIobi5GUkFNRUJVRkZFUixBKSxOZSh2KT9hLmZyYW1lYnVmZmVyVGV4dHVyZTJETXVsdGlzYW1wbGVFWFQobi5GUkFNRUJVRkZFUixZLEssai5fX3dlYmdsVGV4dHVyZSwwLEllKHYpKTooSz09PW4uVEVYVFVSRV8yRHx8Sz49bi5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gmJks8PW4uVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aKSYmbi5mcmFtZWJ1ZmZlclRleHR1cmUyRChuLkZSQU1FQlVGRkVSLFksSyxqLl9fd2ViZ2xUZXh0dXJlLGspLHQuYmluZEZyYW1lYnVmZmVyKG4uRlJBTUVCVUZGRVIsbnVsbCl9ZnVuY3Rpb24gcmUoQSx2LEkpe2lmKG4uYmluZFJlbmRlcmJ1ZmZlcihuLlJFTkRFUkJVRkZFUixBKSx2LmRlcHRoQnVmZmVyKXtjb25zdCBZPXYuZGVwdGhUZXh0dXJlLEs9WSYmWS5pc0RlcHRoVGV4dHVyZT9ZLnR5cGU6bnVsbCxrPV8odi5zdGVuY2lsQnVmZmVyLEspLF9lPXYuc3RlbmNpbEJ1ZmZlcj9uLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVDpuLkRFUFRIX0FUVEFDSE1FTlQsc2U9SWUodik7TmUodik/YS5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGVFWFQobi5SRU5ERVJCVUZGRVIsc2Usayx2LndpZHRoLHYuaGVpZ2h0KTpJP24ucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKG4uUkVOREVSQlVGRkVSLHNlLGssdi53aWR0aCx2LmhlaWdodCk6bi5yZW5kZXJidWZmZXJTdG9yYWdlKG4uUkVOREVSQlVGRkVSLGssdi53aWR0aCx2LmhlaWdodCksbi5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihuLkZSQU1FQlVGRkVSLF9lLG4uUkVOREVSQlVGRkVSLEEpfWVsc2V7Y29uc3QgWT12LnRleHR1cmVzO2ZvcihsZXQgSz0wO0s8WS5sZW5ndGg7SysrKXtjb25zdCBrPVlbS10sX2U9cy5jb252ZXJ0KGsuZm9ybWF0LGsuY29sb3JTcGFjZSksc2U9cy5jb252ZXJ0KGsudHlwZSksdWU9eShrLmludGVybmFsRm9ybWF0LF9lLHNlLGsuY29sb3JTcGFjZSksR2U9SWUodik7SSYmTmUodik9PT0hMT9uLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShuLlJFTkRFUkJVRkZFUixHZSx1ZSx2LndpZHRoLHYuaGVpZ2h0KTpOZSh2KT9hLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZUVYVChuLlJFTkRFUkJVRkZFUixHZSx1ZSx2LndpZHRoLHYuaGVpZ2h0KTpuLnJlbmRlcmJ1ZmZlclN0b3JhZ2Uobi5SRU5ERVJCVUZGRVIsdWUsdi53aWR0aCx2LmhlaWdodCl9fW4uYmluZFJlbmRlcmJ1ZmZlcihuLlJFTkRFUkJVRkZFUixudWxsKX1mdW5jdGlvbiB5ZShBLHYpe2lmKHYmJnYuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQpdGhyb3cgbmV3IEVycm9yKCJEZXB0aCBUZXh0dXJlIHdpdGggY3ViZSByZW5kZXIgdGFyZ2V0cyBpcyBub3Qgc3VwcG9ydGVkIik7aWYodC5iaW5kRnJhbWVidWZmZXIobi5GUkFNRUJVRkZFUixBKSwhKHYuZGVwdGhUZXh0dXJlJiZ2LmRlcHRoVGV4dHVyZS5pc0RlcHRoVGV4dHVyZSkpdGhyb3cgbmV3IEVycm9yKCJyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuRGVwdGhUZXh0dXJlIik7Y29uc3QgWT1pLmdldCh2LmRlcHRoVGV4dHVyZSk7WS5fX3JlbmRlclRhcmdldD12LCghWS5fX3dlYmdsVGV4dHVyZXx8di5kZXB0aFRleHR1cmUuaW1hZ2Uud2lkdGghPT12LndpZHRofHx2LmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQhPT12LmhlaWdodCkmJih2LmRlcHRoVGV4dHVyZS5pbWFnZS53aWR0aD12LndpZHRoLHYuZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodD12LmhlaWdodCx2LmRlcHRoVGV4dHVyZS5uZWVkc1VwZGF0ZT0hMCksWih2LmRlcHRoVGV4dHVyZSwwKTtjb25zdCBLPVkuX193ZWJnbFRleHR1cmUsaz1JZSh2KTtpZih2LmRlcHRoVGV4dHVyZS5mb3JtYXQ9PT0xMDI2KU5lKHYpP2EuZnJhbWVidWZmZXJUZXh0dXJlMkRNdWx0aXNhbXBsZUVYVChuLkZSQU1FQlVGRkVSLG4uREVQVEhfQVRUQUNITUVOVCxuLlRFWFRVUkVfMkQsSywwLGspOm4uZnJhbWVidWZmZXJUZXh0dXJlMkQobi5GUkFNRUJVRkZFUixuLkRFUFRIX0FUVEFDSE1FTlQsbi5URVhUVVJFXzJELEssMCk7ZWxzZSBpZih2LmRlcHRoVGV4dHVyZS5mb3JtYXQ9PT0xMDI3KU5lKHYpP2EuZnJhbWVidWZmZXJUZXh0dXJlMkRNdWx0aXNhbXBsZUVYVChuLkZSQU1FQlVGRkVSLG4uREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULG4uVEVYVFVSRV8yRCxLLDAsayk6bi5mcmFtZWJ1ZmZlclRleHR1cmUyRChuLkZSQU1FQlVGRkVSLG4uREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULG4uVEVYVFVSRV8yRCxLLDApO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJVbmtub3duIGRlcHRoVGV4dHVyZSBmb3JtYXQiKX1mdW5jdGlvbiB3ZShBKXtjb25zdCB2PWkuZ2V0KEEpLEk9QS5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldD09PSEwO2lmKHYuX19ib3VuZERlcHRoVGV4dHVyZSE9PUEuZGVwdGhUZXh0dXJlKXtjb25zdCBZPUEuZGVwdGhUZXh0dXJlO2lmKHYuX19kZXB0aERpc3Bvc2VDYWxsYmFjayYmdi5fX2RlcHRoRGlzcG9zZUNhbGxiYWNrKCksWSl7Y29uc3QgSz0oKT0+e2RlbGV0ZSB2Ll9fYm91bmREZXB0aFRleHR1cmUsZGVsZXRlIHYuX19kZXB0aERpc3Bvc2VDYWxsYmFjayxZLnJlbW92ZUV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLEspfTtZLmFkZEV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLEspLHYuX19kZXB0aERpc3Bvc2VDYWxsYmFjaz1LfXYuX19ib3VuZERlcHRoVGV4dHVyZT1ZfWlmKEEuZGVwdGhUZXh0dXJlJiYhdi5fX2F1dG9BbGxvY2F0ZURlcHRoQnVmZmVyKXtpZihJKXRocm93IG5ldyBFcnJvcigidGFyZ2V0LmRlcHRoVGV4dHVyZSBub3Qgc3VwcG9ydGVkIGluIEN1YmUgcmVuZGVyIHRhcmdldHMiKTt5ZSh2Ll9fd2ViZ2xGcmFtZWJ1ZmZlcixBKX1lbHNlIGlmKEkpe3YuX193ZWJnbERlcHRoYnVmZmVyPVtdO2ZvcihsZXQgWT0wO1k8NjtZKyspaWYodC5iaW5kRnJhbWVidWZmZXIobi5GUkFNRUJVRkZFUix2Ll9fd2ViZ2xGcmFtZWJ1ZmZlcltZXSksdi5fX3dlYmdsRGVwdGhidWZmZXJbWV09PT12b2lkIDApdi5fX3dlYmdsRGVwdGhidWZmZXJbWV09bi5jcmVhdGVSZW5kZXJidWZmZXIoKSxyZSh2Ll9fd2ViZ2xEZXB0aGJ1ZmZlcltZXSxBLCExKTtlbHNle2NvbnN0IEs9QS5zdGVuY2lsQnVmZmVyP24uREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UOm4uREVQVEhfQVRUQUNITUVOVCxrPXYuX193ZWJnbERlcHRoYnVmZmVyW1ldO24uYmluZFJlbmRlcmJ1ZmZlcihuLlJFTkRFUkJVRkZFUixrKSxuLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKG4uRlJBTUVCVUZGRVIsSyxuLlJFTkRFUkJVRkZFUixrKX19ZWxzZSBpZih0LmJpbmRGcmFtZWJ1ZmZlcihuLkZSQU1FQlVGRkVSLHYuX193ZWJnbEZyYW1lYnVmZmVyKSx2Ll9fd2ViZ2xEZXB0aGJ1ZmZlcj09PXZvaWQgMCl2Ll9fd2ViZ2xEZXB0aGJ1ZmZlcj1uLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLHJlKHYuX193ZWJnbERlcHRoYnVmZmVyLEEsITEpO2Vsc2V7Y29uc3QgWT1BLnN0ZW5jaWxCdWZmZXI/bi5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQ6bi5ERVBUSF9BVFRBQ0hNRU5ULEs9di5fX3dlYmdsRGVwdGhidWZmZXI7bi5iaW5kUmVuZGVyYnVmZmVyKG4uUkVOREVSQlVGRkVSLEspLG4uZnJhbWVidWZmZXJSZW5kZXJidWZmZXIobi5GUkFNRUJVRkZFUixZLG4uUkVOREVSQlVGRkVSLEspfXQuYmluZEZyYW1lYnVmZmVyKG4uRlJBTUVCVUZGRVIsbnVsbCl9ZnVuY3Rpb24gRmUoQSx2LEkpe2NvbnN0IFk9aS5nZXQoQSk7diE9PXZvaWQgMCYmZ2UoWS5fX3dlYmdsRnJhbWVidWZmZXIsQSxBLnRleHR1cmUsbi5DT0xPUl9BVFRBQ0hNRU5UMCxuLlRFWFRVUkVfMkQsMCksSSE9PXZvaWQgMCYmd2UoQSl9ZnVuY3Rpb24gbnQoQSl7Y29uc3Qgdj1BLnRleHR1cmUsST1pLmdldChBKSxZPWkuZ2V0KHYpO0EuYWRkRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsYik7Y29uc3QgSz1BLnRleHR1cmVzLGs9QS5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldD09PSEwLF9lPUsubGVuZ3RoPjE7aWYoX2V8fChZLl9fd2ViZ2xUZXh0dXJlPT09dm9pZCAwJiYoWS5fX3dlYmdsVGV4dHVyZT1uLmNyZWF0ZVRleHR1cmUoKSksWS5fX3ZlcnNpb249di52ZXJzaW9uLG8ubWVtb3J5LnRleHR1cmVzKyspLGspe0kuX193ZWJnbEZyYW1lYnVmZmVyPVtdO2ZvcihsZXQgc2U9MDtzZTw2O3NlKyspaWYodi5taXBtYXBzJiZ2Lm1pcG1hcHMubGVuZ3RoPjApe0kuX193ZWJnbEZyYW1lYnVmZmVyW3NlXT1bXTtmb3IobGV0IHVlPTA7dWU8di5taXBtYXBzLmxlbmd0aDt1ZSsrKUkuX193ZWJnbEZyYW1lYnVmZmVyW3NlXVt1ZV09bi5jcmVhdGVGcmFtZWJ1ZmZlcigpfWVsc2UgSS5fX3dlYmdsRnJhbWVidWZmZXJbc2VdPW4uY3JlYXRlRnJhbWVidWZmZXIoKX1lbHNle2lmKHYubWlwbWFwcyYmdi5taXBtYXBzLmxlbmd0aD4wKXtJLl9fd2ViZ2xGcmFtZWJ1ZmZlcj1bXTtmb3IobGV0IHNlPTA7c2U8di5taXBtYXBzLmxlbmd0aDtzZSsrKUkuX193ZWJnbEZyYW1lYnVmZmVyW3NlXT1uLmNyZWF0ZUZyYW1lYnVmZmVyKCl9ZWxzZSBJLl9fd2ViZ2xGcmFtZWJ1ZmZlcj1uLmNyZWF0ZUZyYW1lYnVmZmVyKCk7aWYoX2UpZm9yKGxldCBzZT0wLHVlPUsubGVuZ3RoO3NlPHVlO3NlKyspe2NvbnN0IEdlPWkuZ2V0KEtbc2VdKTtHZS5fX3dlYmdsVGV4dHVyZT09PXZvaWQgMCYmKEdlLl9fd2ViZ2xUZXh0dXJlPW4uY3JlYXRlVGV4dHVyZSgpLG8ubWVtb3J5LnRleHR1cmVzKyspfWlmKEEuc2FtcGxlcz4wJiZOZShBKT09PSExKXtJLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcj1uLmNyZWF0ZUZyYW1lYnVmZmVyKCksSS5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXI9W10sdC5iaW5kRnJhbWVidWZmZXIobi5GUkFNRUJVRkZFUixJLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcik7Zm9yKGxldCBzZT0wO3NlPEsubGVuZ3RoO3NlKyspe2NvbnN0IHVlPUtbc2VdO0kuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyW3NlXT1uLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLG4uYmluZFJlbmRlcmJ1ZmZlcihuLlJFTkRFUkJVRkZFUixJLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcltzZV0pO2NvbnN0IEdlPXMuY29udmVydCh1ZS5mb3JtYXQsdWUuY29sb3JTcGFjZSksaj1zLmNvbnZlcnQodWUudHlwZSksaGU9eSh1ZS5pbnRlcm5hbEZvcm1hdCxHZSxqLHVlLmNvbG9yU3BhY2UsQS5pc1hSUmVuZGVyVGFyZ2V0PT09ITApLEVlPUllKEEpO24ucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKG4uUkVOREVSQlVGRkVSLEVlLGhlLEEud2lkdGgsQS5oZWlnaHQpLG4uZnJhbWVidWZmZXJSZW5kZXJidWZmZXIobi5GUkFNRUJVRkZFUixuLkNPTE9SX0FUVEFDSE1FTlQwK3NlLG4uUkVOREVSQlVGRkVSLEkuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyW3NlXSl9bi5iaW5kUmVuZGVyYnVmZmVyKG4uUkVOREVSQlVGRkVSLG51bGwpLEEuZGVwdGhCdWZmZXImJihJLl9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlcj1uLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLHJlKEkuX193ZWJnbERlcHRoUmVuZGVyYnVmZmVyLEEsITApKSx0LmJpbmRGcmFtZWJ1ZmZlcihuLkZSQU1FQlVGRkVSLG51bGwpfX1pZihrKXt0LmJpbmRUZXh0dXJlKG4uVEVYVFVSRV9DVUJFX01BUCxZLl9fd2ViZ2xUZXh0dXJlKSxVZShuLlRFWFRVUkVfQ1VCRV9NQVAsdik7Zm9yKGxldCBzZT0wO3NlPDY7c2UrKylpZih2Lm1pcG1hcHMmJnYubWlwbWFwcy5sZW5ndGg+MClmb3IobGV0IHVlPTA7dWU8di5taXBtYXBzLmxlbmd0aDt1ZSsrKWdlKEkuX193ZWJnbEZyYW1lYnVmZmVyW3NlXVt1ZV0sQSx2LG4uQ09MT1JfQVRUQUNITUVOVDAsbi5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grc2UsdWUpO2Vsc2UgZ2UoSS5fX3dlYmdsRnJhbWVidWZmZXJbc2VdLEEsdixuLkNPTE9SX0FUVEFDSE1FTlQwLG4uVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YK3NlLDApO20odikmJmgobi5URVhUVVJFX0NVQkVfTUFQKSx0LnVuYmluZFRleHR1cmUoKX1lbHNlIGlmKF9lKXtmb3IobGV0IHNlPTAsdWU9Sy5sZW5ndGg7c2U8dWU7c2UrKyl7Y29uc3QgR2U9S1tzZV0saj1pLmdldChHZSk7dC5iaW5kVGV4dHVyZShuLlRFWFRVUkVfMkQsai5fX3dlYmdsVGV4dHVyZSksVWUobi5URVhUVVJFXzJELEdlKSxnZShJLl9fd2ViZ2xGcmFtZWJ1ZmZlcixBLEdlLG4uQ09MT1JfQVRUQUNITUVOVDArc2Usbi5URVhUVVJFXzJELDApLG0oR2UpJiZoKG4uVEVYVFVSRV8yRCl9dC51bmJpbmRUZXh0dXJlKCl9ZWxzZXtsZXQgc2U9bi5URVhUVVJFXzJEO2lmKChBLmlzV2ViR0wzRFJlbmRlclRhcmdldHx8QS5pc1dlYkdMQXJyYXlSZW5kZXJUYXJnZXQpJiYoc2U9QS5pc1dlYkdMM0RSZW5kZXJUYXJnZXQ/bi5URVhUVVJFXzNEOm4uVEVYVFVSRV8yRF9BUlJBWSksdC5iaW5kVGV4dHVyZShzZSxZLl9fd2ViZ2xUZXh0dXJlKSxVZShzZSx2KSx2Lm1pcG1hcHMmJnYubWlwbWFwcy5sZW5ndGg+MClmb3IobGV0IHVlPTA7dWU8di5taXBtYXBzLmxlbmd0aDt1ZSsrKWdlKEkuX193ZWJnbEZyYW1lYnVmZmVyW3VlXSxBLHYsbi5DT0xPUl9BVFRBQ0hNRU5UMCxzZSx1ZSk7ZWxzZSBnZShJLl9fd2ViZ2xGcmFtZWJ1ZmZlcixBLHYsbi5DT0xPUl9BVFRBQ0hNRU5UMCxzZSwwKTttKHYpJiZoKHNlKSx0LnVuYmluZFRleHR1cmUoKX1BLmRlcHRoQnVmZmVyJiZ3ZShBKX1mdW5jdGlvbiB6ZShBKXtjb25zdCB2PUEudGV4dHVyZXM7Zm9yKGxldCBJPTAsWT12Lmxlbmd0aDtJPFk7SSsrKXtjb25zdCBLPXZbSV07aWYobShLKSl7Y29uc3Qgaz1UKEEpLF9lPWkuZ2V0KEspLl9fd2ViZ2xUZXh0dXJlO3QuYmluZFRleHR1cmUoayxfZSksaChrKSx0LnVuYmluZFRleHR1cmUoKX19fWNvbnN0IGF0PVtdLFU9W107ZnVuY3Rpb24gUHQoQSl7aWYoQS5zYW1wbGVzPjApe2lmKE5lKEEpPT09ITEpe2NvbnN0IHY9QS50ZXh0dXJlcyxJPUEud2lkdGgsWT1BLmhlaWdodDtsZXQgSz1uLkNPTE9SX0JVRkZFUl9CSVQ7Y29uc3Qgaz1BLnN0ZW5jaWxCdWZmZXI/bi5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQ6bi5ERVBUSF9BVFRBQ0hNRU5ULF9lPWkuZ2V0KEEpLHNlPXYubGVuZ3RoPjE7aWYoc2UpZm9yKGxldCB1ZT0wO3VlPHYubGVuZ3RoO3VlKyspdC5iaW5kRnJhbWVidWZmZXIobi5GUkFNRUJVRkZFUixfZS5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpLG4uZnJhbWVidWZmZXJSZW5kZXJidWZmZXIobi5GUkFNRUJVRkZFUixuLkNPTE9SX0FUVEFDSE1FTlQwK3VlLG4uUkVOREVSQlVGRkVSLG51bGwpLHQuYmluZEZyYW1lYnVmZmVyKG4uRlJBTUVCVUZGRVIsX2UuX193ZWJnbEZyYW1lYnVmZmVyKSxuLmZyYW1lYnVmZmVyVGV4dHVyZTJEKG4uRFJBV19GUkFNRUJVRkZFUixuLkNPTE9SX0FUVEFDSE1FTlQwK3VlLG4uVEVYVFVSRV8yRCxudWxsLDApO3QuYmluZEZyYW1lYnVmZmVyKG4uUkVBRF9GUkFNRUJVRkZFUixfZS5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpLHQuYmluZEZyYW1lYnVmZmVyKG4uRFJBV19GUkFNRUJVRkZFUixfZS5fX3dlYmdsRnJhbWVidWZmZXIpO2ZvcihsZXQgdWU9MDt1ZTx2Lmxlbmd0aDt1ZSsrKXtpZihBLnJlc29sdmVEZXB0aEJ1ZmZlciYmKEEuZGVwdGhCdWZmZXImJihLfD1uLkRFUFRIX0JVRkZFUl9CSVQpLEEuc3RlbmNpbEJ1ZmZlciYmQS5yZXNvbHZlU3RlbmNpbEJ1ZmZlciYmKEt8PW4uU1RFTkNJTF9CVUZGRVJfQklUKSksc2Upe24uZnJhbWVidWZmZXJSZW5kZXJidWZmZXIobi5SRUFEX0ZSQU1FQlVGRkVSLG4uQ09MT1JfQVRUQUNITUVOVDAsbi5SRU5ERVJCVUZGRVIsX2UuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyW3VlXSk7Y29uc3QgR2U9aS5nZXQodlt1ZV0pLl9fd2ViZ2xUZXh0dXJlO24uZnJhbWVidWZmZXJUZXh0dXJlMkQobi5EUkFXX0ZSQU1FQlVGRkVSLG4uQ09MT1JfQVRUQUNITUVOVDAsbi5URVhUVVJFXzJELEdlLDApfW4uYmxpdEZyYW1lYnVmZmVyKDAsMCxJLFksMCwwLEksWSxLLG4uTkVBUkVTVCksbD09PSEwJiYoYXQubGVuZ3RoPTAsVS5sZW5ndGg9MCxhdC5wdXNoKG4uQ09MT1JfQVRUQUNITUVOVDArdWUpLEEuZGVwdGhCdWZmZXImJkEucmVzb2x2ZURlcHRoQnVmZmVyPT09ITEmJihhdC5wdXNoKGspLFUucHVzaChrKSxuLmludmFsaWRhdGVGcmFtZWJ1ZmZlcihuLkRSQVdfRlJBTUVCVUZGRVIsVSkpLG4uaW52YWxpZGF0ZUZyYW1lYnVmZmVyKG4uUkVBRF9GUkFNRUJVRkZFUixhdCkpfWlmKHQuYmluZEZyYW1lYnVmZmVyKG4uUkVBRF9GUkFNRUJVRkZFUixudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcihuLkRSQVdfRlJBTUVCVUZGRVIsbnVsbCksc2UpZm9yKGxldCB1ZT0wO3VlPHYubGVuZ3RoO3VlKyspe3QuYmluZEZyYW1lYnVmZmVyKG4uRlJBTUVCVUZGRVIsX2UuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKSxuLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKG4uRlJBTUVCVUZGRVIsbi5DT0xPUl9BVFRBQ0hNRU5UMCt1ZSxuLlJFTkRFUkJVRkZFUixfZS5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbdWVdKTtjb25zdCBHZT1pLmdldCh2W3VlXSkuX193ZWJnbFRleHR1cmU7dC5iaW5kRnJhbWVidWZmZXIobi5GUkFNRUJVRkZFUixfZS5fX3dlYmdsRnJhbWVidWZmZXIpLG4uZnJhbWVidWZmZXJUZXh0dXJlMkQobi5EUkFXX0ZSQU1FQlVGRkVSLG4uQ09MT1JfQVRUQUNITUVOVDArdWUsbi5URVhUVVJFXzJELEdlLDApfXQuYmluZEZyYW1lYnVmZmVyKG4uRFJBV19GUkFNRUJVRkZFUixfZS5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpfWVsc2UgaWYoQS5kZXB0aEJ1ZmZlciYmQS5yZXNvbHZlRGVwdGhCdWZmZXI9PT0hMSYmbCl7Y29uc3Qgdj1BLnN0ZW5jaWxCdWZmZXI/bi5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQ6bi5ERVBUSF9BVFRBQ0hNRU5UO24uaW52YWxpZGF0ZUZyYW1lYnVmZmVyKG4uRFJBV19GUkFNRUJVRkZFUixbdl0pfX19ZnVuY3Rpb24gSWUoQSl7cmV0dXJuIE1hdGgubWluKHIubWF4U2FtcGxlcyxBLnNhbXBsZXMpfWZ1bmN0aW9uIE5lKEEpe2NvbnN0IHY9aS5nZXQoQSk7cmV0dXJuIEEuc2FtcGxlcz4wJiZlLmhhcygiV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlIik9PT0hMCYmdi5fX3VzZVJlbmRlclRvVGV4dHVyZSE9PSExfWZ1bmN0aW9uIFNlKEEpe2NvbnN0IHY9by5yZW5kZXIuZnJhbWU7dS5nZXQoQSkhPT12JiYodS5zZXQoQSx2KSxBLnVwZGF0ZSgpKX1mdW5jdGlvbiBqZShBLHYpe2NvbnN0IEk9QS5jb2xvclNwYWNlLFk9QS5mb3JtYXQsSz1BLnR5cGU7cmV0dXJuIEEuaXNDb21wcmVzc2VkVGV4dHVyZT09PSEwfHxBLmlzVmlkZW9UZXh0dXJlPT09ITB8fEkhPT14biYmSSE9PWp0JiYoQmUuZ2V0VHJhbnNmZXIoSSk9PT1xZT8oWSE9PTEwMjN8fEshPT0xMDA5KSYmY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFRleHR1cmVzOiBzUkdCIGVuY29kZWQgdGV4dHVyZXMgaGF2ZSB0byB1c2UgUkdCQUZvcm1hdCBhbmQgVW5zaWduZWRCeXRlVHlwZS4iKTpjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFRleHR1cmVzOiBVbnN1cHBvcnRlZCB0ZXh0dXJlIGNvbG9yIHNwYWNlOiIsSSkpLHZ9ZnVuY3Rpb24gTWUoQSl7cmV0dXJuIHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50PCJ1IiYmQSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQ/KGMud2lkdGg9QS5uYXR1cmFsV2lkdGh8fEEud2lkdGgsYy5oZWlnaHQ9QS5uYXR1cmFsSGVpZ2h0fHxBLmhlaWdodCk6dHlwZW9mIFZpZGVvRnJhbWU8InUiJiZBIGluc3RhbmNlb2YgVmlkZW9GcmFtZT8oYy53aWR0aD1BLmRpc3BsYXlXaWR0aCxjLmhlaWdodD1BLmRpc3BsYXlIZWlnaHQpOihjLndpZHRoPUEud2lkdGgsYy5oZWlnaHQ9QS5oZWlnaHQpLGN9dGhpcy5hbGxvY2F0ZVRleHR1cmVVbml0PXosdGhpcy5yZXNldFRleHR1cmVVbml0cz1xLHRoaXMuc2V0VGV4dHVyZTJEPVosdGhpcy5zZXRUZXh0dXJlMkRBcnJheT1WLHRoaXMuc2V0VGV4dHVyZTNEPVEsdGhpcy5zZXRUZXh0dXJlQ3ViZT1ILHRoaXMucmViaW5kVGV4dHVyZXM9RmUsdGhpcy5zZXR1cFJlbmRlclRhcmdldD1udCx0aGlzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcD16ZSx0aGlzLnVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0PVB0LHRoaXMuc2V0dXBEZXB0aFJlbmRlcmJ1ZmZlcj13ZSx0aGlzLnNldHVwRnJhbWVCdWZmZXJUZXh0dXJlPWdlLHRoaXMudXNlTXVsdGlzYW1wbGVkUlRUPU5lfWZ1bmN0aW9uIEZ1KG4sZSl7ZnVuY3Rpb24gdChpLHI9anQpe2xldCBzO2NvbnN0IG89QmUuZ2V0VHJhbnNmZXIocik7aWYoaT09PTEwMDkpcmV0dXJuIG4uVU5TSUdORURfQllURTtpZihpPT09MTAxNylyZXR1cm4gbi5VTlNJR05FRF9TSE9SVF80XzRfNF80O2lmKGk9PT0xMDE4KXJldHVybiBuLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7aWYoaT09PTM1OTAyKXJldHVybiBuLlVOU0lHTkVEX0lOVF81XzlfOV85X1JFVjtpZihpPT09MTAxMClyZXR1cm4gbi5CWVRFO2lmKGk9PT0xMDExKXJldHVybiBuLlNIT1JUO2lmKGk9PT0xMDEyKXJldHVybiBuLlVOU0lHTkVEX1NIT1JUO2lmKGk9PT0xMDEzKXJldHVybiBuLklOVDtpZihpPT09MTAxNClyZXR1cm4gbi5VTlNJR05FRF9JTlQ7aWYoaT09PTEwMTUpcmV0dXJuIG4uRkxPQVQ7aWYoaT09PTEwMTYpcmV0dXJuIG4uSEFMRl9GTE9BVDtpZihpPT09MTAyMSlyZXR1cm4gbi5BTFBIQTtpZihpPT09MTAyMilyZXR1cm4gbi5SR0I7aWYoaT09PTEwMjMpcmV0dXJuIG4uUkdCQTtpZihpPT09MTAyNClyZXR1cm4gbi5MVU1JTkFOQ0U7aWYoaT09PTEwMjUpcmV0dXJuIG4uTFVNSU5BTkNFX0FMUEhBO2lmKGk9PT0xMDI2KXJldHVybiBuLkRFUFRIX0NPTVBPTkVOVDtpZihpPT09MTAyNylyZXR1cm4gbi5ERVBUSF9TVEVOQ0lMO2lmKGk9PT0xMDI4KXJldHVybiBuLlJFRDtpZihpPT09MTAyOSlyZXR1cm4gbi5SRURfSU5URUdFUjtpZihpPT09MTAzMClyZXR1cm4gbi5SRztpZihpPT09MTAzMSlyZXR1cm4gbi5SR19JTlRFR0VSO2lmKGk9PT0xMDMzKXJldHVybiBuLlJHQkFfSU5URUdFUjtpZihpPT09MzM3NzZ8fGk9PT0zMzc3N3x8aT09PTMzNzc4fHxpPT09MzM3NzkpaWYobz09PXFlKWlmKHM9ZS5nZXQoIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2IiKSxzIT09bnVsbCl7aWYoaT09PTMzNzc2KXJldHVybiBzLkNPTVBSRVNTRURfU1JHQl9TM1RDX0RYVDFfRVhUO2lmKGk9PT0zMzc3NylyZXR1cm4gcy5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQxX0VYVDtpZihpPT09MzM3NzgpcmV0dXJuIHMuQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUM19FWFQ7aWYoaT09PTMzNzc5KXJldHVybiBzLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDVfRVhUfWVsc2UgcmV0dXJuIG51bGw7ZWxzZSBpZihzPWUuZ2V0KCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YyIpLHMhPT1udWxsKXtpZihpPT09MzM3NzYpcmV0dXJuIHMuQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtpZihpPT09MzM3NzcpcmV0dXJuIHMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQ7aWYoaT09PTMzNzc4KXJldHVybiBzLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUO2lmKGk9PT0zMzc3OSlyZXR1cm4gcy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVH1lbHNlIHJldHVybiBudWxsO2lmKGk9PT0zNTg0MHx8aT09PTM1ODQxfHxpPT09MzU4NDJ8fGk9PT0zNTg0MylpZihzPWUuZ2V0KCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMiKSxzIT09bnVsbCl7aWYoaT09PTM1ODQwKXJldHVybiBzLkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUc7aWYoaT09PTM1ODQxKXJldHVybiBzLkNPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUc7aWYoaT09PTM1ODQyKXJldHVybiBzLkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HO2lmKGk9PT0zNTg0MylyZXR1cm4gcy5DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNR31lbHNlIHJldHVybiBudWxsO2lmKGk9PT0zNjE5Nnx8aT09PTM3NDkyfHxpPT09Mzc0OTYpaWYocz1lLmdldCgiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YyIpLHMhPT1udWxsKXtpZihpPT09MzYxOTZ8fGk9PT0zNzQ5MilyZXR1cm4gbz09PXFlP3MuQ09NUFJFU1NFRF9TUkdCOF9FVEMyOnMuQ09NUFJFU1NFRF9SR0I4X0VUQzI7aWYoaT09PTM3NDk2KXJldHVybiBvPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9FVEMyX0VBQzpzLkNPTVBSRVNTRURfUkdCQThfRVRDMl9FQUN9ZWxzZSByZXR1cm4gbnVsbDtpZihpPT09Mzc4MDh8fGk9PT0zNzgwOXx8aT09PTM3ODEwfHxpPT09Mzc4MTF8fGk9PT0zNzgxMnx8aT09PTM3ODEzfHxpPT09Mzc4MTR8fGk9PT0zNzgxNXx8aT09PTM3ODE2fHxpPT09Mzc4MTd8fGk9PT0zNzgxOHx8aT09PTM3ODE5fHxpPT09Mzc4MjB8fGk9PT0zNzgyMSlpZihzPWUuZ2V0KCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXN0YyIpLHMhPT1udWxsKXtpZihpPT09Mzc4MDgpcmV0dXJuIG89PT1xZT9zLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNHg0X0tIUjpzLkNPTVBSRVNTRURfUkdCQV9BU1RDXzR4NF9LSFI7aWYoaT09PTM3ODA5KXJldHVybiBvPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzV4NF9LSFI6cy5DT01QUkVTU0VEX1JHQkFfQVNUQ181eDRfS0hSO2lmKGk9PT0zNzgxMClyZXR1cm4gbz09PXFlP3MuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ181eDVfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfNXg1X0tIUjtpZihpPT09Mzc4MTEpcmV0dXJuIG89PT1xZT9zLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNng1X0tIUjpzLkNPTVBSRVNTRURfUkdCQV9BU1RDXzZ4NV9LSFI7aWYoaT09PTM3ODEyKXJldHVybiBvPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzZ4Nl9LSFI6cy5DT01QUkVTU0VEX1JHQkFfQVNUQ182eDZfS0hSO2lmKGk9PT0zNzgxMylyZXR1cm4gbz09PXFlP3MuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDVfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfOHg1X0tIUjtpZihpPT09Mzc4MTQpcmV0dXJuIG89PT1xZT9zLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfOHg2X0tIUjpzLkNPTVBSRVNTRURfUkdCQV9BU1RDXzh4Nl9LSFI7aWYoaT09PTM3ODE1KXJldHVybiBvPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzh4OF9LSFI6cy5DT01QUkVTU0VEX1JHQkFfQVNUQ184eDhfS0hSO2lmKGk9PT0zNzgxNilyZXR1cm4gbz09PXFlP3MuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMHg1X0tIUjpzLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDVfS0hSO2lmKGk9PT0zNzgxNylyZXR1cm4gbz09PXFlP3MuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMHg2X0tIUjpzLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDZfS0hSO2lmKGk9PT0zNzgxOClyZXR1cm4gbz09PXFlP3MuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMHg4X0tIUjpzLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDhfS0hSO2lmKGk9PT0zNzgxOSlyZXR1cm4gbz09PXFlP3MuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMHgxMF9LSFI6cy5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMHgxMF9LSFI7aWYoaT09PTM3ODIwKXJldHVybiBvPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEyeDEwX0tIUjpzLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEyeDEwX0tIUjtpZihpPT09Mzc4MjEpcmV0dXJuIG89PT1xZT9zLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTJ4MTJfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfMTJ4MTJfS0hSfWVsc2UgcmV0dXJuIG51bGw7aWYoaT09PTM2NDkyfHxpPT09MzY0OTR8fGk9PT0zNjQ5NSlpZihzPWUuZ2V0KCJFWFRfdGV4dHVyZV9jb21wcmVzc2lvbl9icHRjIikscyE9PW51bGwpe2lmKGk9PT0zNjQ5MilyZXR1cm4gbz09PXFlP3MuQ09NUFJFU1NFRF9TUkdCX0FMUEhBX0JQVENfVU5PUk1fRVhUOnMuQ09NUFJFU1NFRF9SR0JBX0JQVENfVU5PUk1fRVhUO2lmKGk9PT0zNjQ5NClyZXR1cm4gcy5DT01QUkVTU0VEX1JHQl9CUFRDX1NJR05FRF9GTE9BVF9FWFQ7aWYoaT09PTM2NDk1KXJldHVybiBzLkNPTVBSRVNTRURfUkdCX0JQVENfVU5TSUdORURfRkxPQVRfRVhUfWVsc2UgcmV0dXJuIG51bGw7aWYoaT09PTM2MjgzfHxpPT09MzYyODR8fGk9PT0zNjI4NXx8aT09PTM2Mjg2KWlmKHM9ZS5nZXQoIkVYVF90ZXh0dXJlX2NvbXByZXNzaW9uX3JndGMiKSxzIT09bnVsbCl7aWYoaT09PTM2NDkyKXJldHVybiBzLkNPTVBSRVNTRURfUkVEX1JHVEMxX0VYVDtpZihpPT09MzYyODQpcmV0dXJuIHMuQ09NUFJFU1NFRF9TSUdORURfUkVEX1JHVEMxX0VYVDtpZihpPT09MzYyODUpcmV0dXJuIHMuQ09NUFJFU1NFRF9SRURfR1JFRU5fUkdUQzJfRVhUO2lmKGk9PT0zNjI4NilyZXR1cm4gcy5DT01QUkVTU0VEX1NJR05FRF9SRURfR1JFRU5fUkdUQzJfRVhUfWVsc2UgcmV0dXJuIG51bGw7cmV0dXJuIGk9PT0xMDIwP24uVU5TSUdORURfSU5UXzI0Xzg6bltpXSE9PXZvaWQgMD9uW2ldOm51bGx9cmV0dXJue2NvbnZlcnQ6dH19Y2xhc3MgSXUgZXh0ZW5kcyBOdHtjb25zdHJ1Y3RvcihlPVtdKXtzdXBlcigpLHRoaXMuaXNBcnJheUNhbWVyYT0hMCx0aGlzLmNhbWVyYXM9ZX19Y2xhc3MgZHQgZXh0ZW5kcyBNdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5pc0dyb3VwPSEwLHRoaXMudHlwZT0iR3JvdXAifX1jb25zdCBOdT17dHlwZToibW92ZSJ9O2NsYXNzIGZye2NvbnN0cnVjdG9yKCl7dGhpcy5fdGFyZ2V0UmF5PW51bGwsdGhpcy5fZ3JpcD1udWxsLHRoaXMuX2hhbmQ9bnVsbH1nZXRIYW5kU3BhY2UoKXtyZXR1cm4gdGhpcy5faGFuZD09PW51bGwmJih0aGlzLl9oYW5kPW5ldyBkdCx0aGlzLl9oYW5kLm1hdHJpeEF1dG9VcGRhdGU9ITEsdGhpcy5faGFuZC52aXNpYmxlPSExLHRoaXMuX2hhbmQuam9pbnRzPXt9LHRoaXMuX2hhbmQuaW5wdXRTdGF0ZT17cGluY2hpbmc6ITF9KSx0aGlzLl9oYW5kfWdldFRhcmdldFJheVNwYWNlKCl7cmV0dXJuIHRoaXMuX3RhcmdldFJheT09PW51bGwmJih0aGlzLl90YXJnZXRSYXk9bmV3IGR0LHRoaXMuX3RhcmdldFJheS5tYXRyaXhBdXRvVXBkYXRlPSExLHRoaXMuX3RhcmdldFJheS52aXNpYmxlPSExLHRoaXMuX3RhcmdldFJheS5oYXNMaW5lYXJWZWxvY2l0eT0hMSx0aGlzLl90YXJnZXRSYXkubGluZWFyVmVsb2NpdHk9bmV3IE8sdGhpcy5fdGFyZ2V0UmF5Lmhhc0FuZ3VsYXJWZWxvY2l0eT0hMSx0aGlzLl90YXJnZXRSYXkuYW5ndWxhclZlbG9jaXR5PW5ldyBPKSx0aGlzLl90YXJnZXRSYXl9Z2V0R3JpcFNwYWNlKCl7cmV0dXJuIHRoaXMuX2dyaXA9PT1udWxsJiYodGhpcy5fZ3JpcD1uZXcgZHQsdGhpcy5fZ3JpcC5tYXRyaXhBdXRvVXBkYXRlPSExLHRoaXMuX2dyaXAudmlzaWJsZT0hMSx0aGlzLl9ncmlwLmhhc0xpbmVhclZlbG9jaXR5PSExLHRoaXMuX2dyaXAubGluZWFyVmVsb2NpdHk9bmV3IE8sdGhpcy5fZ3JpcC5oYXNBbmd1bGFyVmVsb2NpdHk9ITEsdGhpcy5fZ3JpcC5hbmd1bGFyVmVsb2NpdHk9bmV3IE8pLHRoaXMuX2dyaXB9ZGlzcGF0Y2hFdmVudChlKXtyZXR1cm4gdGhpcy5fdGFyZ2V0UmF5IT09bnVsbCYmdGhpcy5fdGFyZ2V0UmF5LmRpc3BhdGNoRXZlbnQoZSksdGhpcy5fZ3JpcCE9PW51bGwmJnRoaXMuX2dyaXAuZGlzcGF0Y2hFdmVudChlKSx0aGlzLl9oYW5kIT09bnVsbCYmdGhpcy5faGFuZC5kaXNwYXRjaEV2ZW50KGUpLHRoaXN9Y29ubmVjdChlKXtpZihlJiZlLmhhbmQpe2NvbnN0IHQ9dGhpcy5faGFuZDtpZih0KWZvcihjb25zdCBpIG9mIGUuaGFuZC52YWx1ZXMoKSl0aGlzLl9nZXRIYW5kSm9pbnQodCxpKX1yZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJjb25uZWN0ZWQiLGRhdGE6ZX0pLHRoaXN9ZGlzY29ubmVjdChlKXtyZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJkaXNjb25uZWN0ZWQiLGRhdGE6ZX0pLHRoaXMuX3RhcmdldFJheSE9PW51bGwmJih0aGlzLl90YXJnZXRSYXkudmlzaWJsZT0hMSksdGhpcy5fZ3JpcCE9PW51bGwmJih0aGlzLl9ncmlwLnZpc2libGU9ITEpLHRoaXMuX2hhbmQhPT1udWxsJiYodGhpcy5faGFuZC52aXNpYmxlPSExKSx0aGlzfXVwZGF0ZShlLHQsaSl7bGV0IHI9bnVsbCxzPW51bGwsbz1udWxsO2NvbnN0IGE9dGhpcy5fdGFyZ2V0UmF5LGw9dGhpcy5fZ3JpcCxjPXRoaXMuX2hhbmQ7aWYoZSYmdC5zZXNzaW9uLnZpc2liaWxpdHlTdGF0ZSE9PSJ2aXNpYmxlLWJsdXJyZWQiKXtpZihjJiZlLmhhbmQpe289ITA7Zm9yKGNvbnN0IHggb2YgZS5oYW5kLnZhbHVlcygpKXtjb25zdCBtPXQuZ2V0Sm9pbnRQb3NlKHgsaSksaD10aGlzLl9nZXRIYW5kSm9pbnQoYyx4KTttIT09bnVsbCYmKGgubWF0cml4LmZyb21BcnJheShtLnRyYW5zZm9ybS5tYXRyaXgpLGgubWF0cml4LmRlY29tcG9zZShoLnBvc2l0aW9uLGgucm90YXRpb24saC5zY2FsZSksaC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSEwLGguam9pbnRSYWRpdXM9bS5yYWRpdXMpLGgudmlzaWJsZT1tIT09bnVsbH1jb25zdCB1PWMuam9pbnRzWyJpbmRleC1maW5nZXItdGlwIl0sZD1jLmpvaW50c1sidGh1bWItdGlwIl0sZj11LnBvc2l0aW9uLmRpc3RhbmNlVG8oZC5wb3NpdGlvbikscD0uMDIsZz0uMDA1O2MuaW5wdXRTdGF0ZS5waW5jaGluZyYmZj5wK2c/KGMuaW5wdXRTdGF0ZS5waW5jaGluZz0hMSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6InBpbmNoZW5kIixoYW5kZWRuZXNzOmUuaGFuZGVkbmVzcyx0YXJnZXQ6dGhpc30pKTohYy5pbnB1dFN0YXRlLnBpbmNoaW5nJiZmPD1wLWcmJihjLmlucHV0U3RhdGUucGluY2hpbmc9ITAsdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJwaW5jaHN0YXJ0IixoYW5kZWRuZXNzOmUuaGFuZGVkbmVzcyx0YXJnZXQ6dGhpc30pKX1lbHNlIGwhPT1udWxsJiZlLmdyaXBTcGFjZSYmKHM9dC5nZXRQb3NlKGUuZ3JpcFNwYWNlLGkpLHMhPT1udWxsJiYobC5tYXRyaXguZnJvbUFycmF5KHMudHJhbnNmb3JtLm1hdHJpeCksbC5tYXRyaXguZGVjb21wb3NlKGwucG9zaXRpb24sbC5yb3RhdGlvbixsLnNjYWxlKSxsLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITAscy5saW5lYXJWZWxvY2l0eT8obC5oYXNMaW5lYXJWZWxvY2l0eT0hMCxsLmxpbmVhclZlbG9jaXR5LmNvcHkocy5saW5lYXJWZWxvY2l0eSkpOmwuaGFzTGluZWFyVmVsb2NpdHk9ITEscy5hbmd1bGFyVmVsb2NpdHk/KGwuaGFzQW5ndWxhclZlbG9jaXR5PSEwLGwuYW5ndWxhclZlbG9jaXR5LmNvcHkocy5hbmd1bGFyVmVsb2NpdHkpKTpsLmhhc0FuZ3VsYXJWZWxvY2l0eT0hMSkpO2EhPT1udWxsJiYocj10LmdldFBvc2UoZS50YXJnZXRSYXlTcGFjZSxpKSxyPT09bnVsbCYmcyE9PW51bGwmJihyPXMpLHIhPT1udWxsJiYoYS5tYXRyaXguZnJvbUFycmF5KHIudHJhbnNmb3JtLm1hdHJpeCksYS5tYXRyaXguZGVjb21wb3NlKGEucG9zaXRpb24sYS5yb3RhdGlvbixhLnNjYWxlKSxhLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITAsci5saW5lYXJWZWxvY2l0eT8oYS5oYXNMaW5lYXJWZWxvY2l0eT0hMCxhLmxpbmVhclZlbG9jaXR5LmNvcHkoci5saW5lYXJWZWxvY2l0eSkpOmEuaGFzTGluZWFyVmVsb2NpdHk9ITEsci5hbmd1bGFyVmVsb2NpdHk/KGEuaGFzQW5ndWxhclZlbG9jaXR5PSEwLGEuYW5ndWxhclZlbG9jaXR5LmNvcHkoci5hbmd1bGFyVmVsb2NpdHkpKTphLmhhc0FuZ3VsYXJWZWxvY2l0eT0hMSx0aGlzLmRpc3BhdGNoRXZlbnQoTnUpKSl9cmV0dXJuIGEhPT1udWxsJiYoYS52aXNpYmxlPXIhPT1udWxsKSxsIT09bnVsbCYmKGwudmlzaWJsZT1zIT09bnVsbCksYyE9PW51bGwmJihjLnZpc2libGU9byE9PW51bGwpLHRoaXN9X2dldEhhbmRKb2ludChlLHQpe2lmKGUuam9pbnRzW3Quam9pbnROYW1lXT09PXZvaWQgMCl7Y29uc3QgaT1uZXcgZHQ7aS5tYXRyaXhBdXRvVXBkYXRlPSExLGkudmlzaWJsZT0hMSxlLmpvaW50c1t0LmpvaW50TmFtZV09aSxlLmFkZChpKX1yZXR1cm4gZS5qb2ludHNbdC5qb2ludE5hbWVdfX1jb25zdCBPdT1gCnZvaWQgbWFpbigpIHsKCglnbF9Qb3NpdGlvbiA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTsKCn1gLEJ1PWAKdW5pZm9ybSBzYW1wbGVyMkRBcnJheSBkZXB0aENvbG9yOwp1bmlmb3JtIGZsb2F0IGRlcHRoV2lkdGg7CnVuaWZvcm0gZmxvYXQgZGVwdGhIZWlnaHQ7Cgp2b2lkIG1haW4oKSB7CgoJdmVjMiBjb29yZCA9IHZlYzIoIGdsX0ZyYWdDb29yZC54IC8gZGVwdGhXaWR0aCwgZ2xfRnJhZ0Nvb3JkLnkgLyBkZXB0aEhlaWdodCApOwoKCWlmICggY29vcmQueCA+PSAxLjAgKSB7CgoJCWdsX0ZyYWdEZXB0aCA9IHRleHR1cmUoIGRlcHRoQ29sb3IsIHZlYzMoIGNvb3JkLnggLSAxLjAsIGNvb3JkLnksIDEgKSApLnI7CgoJfSBlbHNlIHsKCgkJZ2xfRnJhZ0RlcHRoID0gdGV4dHVyZSggZGVwdGhDb2xvciwgdmVjMyggY29vcmQueCwgY29vcmQueSwgMCApICkucjsKCgl9Cgp9YDtjbGFzcyB6dXtjb25zdHJ1Y3Rvcigpe3RoaXMudGV4dHVyZT1udWxsLHRoaXMubWVzaD1udWxsLHRoaXMuZGVwdGhOZWFyPTAsdGhpcy5kZXB0aEZhcj0wfWluaXQoZSx0LGkpe2lmKHRoaXMudGV4dHVyZT09PW51bGwpe2NvbnN0IHI9bmV3IHZ0LHM9ZS5wcm9wZXJ0aWVzLmdldChyKTtzLl9fd2ViZ2xUZXh0dXJlPXQudGV4dHVyZSwodC5kZXB0aE5lYXIhPWkuZGVwdGhOZWFyfHx0LmRlcHRoRmFyIT1pLmRlcHRoRmFyKSYmKHRoaXMuZGVwdGhOZWFyPXQuZGVwdGhOZWFyLHRoaXMuZGVwdGhGYXI9dC5kZXB0aEZhciksdGhpcy50ZXh0dXJlPXJ9fWdldE1lc2goZSl7aWYodGhpcy50ZXh0dXJlIT09bnVsbCYmdGhpcy5tZXNoPT09bnVsbCl7Y29uc3QgdD1lLmNhbWVyYXNbMF0udmlld3BvcnQsaT1uZXcgbHQoe3ZlcnRleFNoYWRlcjpPdSxmcmFnbWVudFNoYWRlcjpCdSx1bmlmb3Jtczp7ZGVwdGhDb2xvcjp7dmFsdWU6dGhpcy50ZXh0dXJlfSxkZXB0aFdpZHRoOnt2YWx1ZTp0Lnp9LGRlcHRoSGVpZ2h0Ont2YWx1ZTp0Lnd9fX0pO3RoaXMubWVzaD1uZXcgdHQobmV3IGV0KDIwLDIwKSxpKX1yZXR1cm4gdGhpcy5tZXNofXJlc2V0KCl7dGhpcy50ZXh0dXJlPW51bGwsdGhpcy5tZXNoPW51bGx9Z2V0RGVwdGhUZXh0dXJlKCl7cmV0dXJuIHRoaXMudGV4dHVyZX19Y2xhc3MgR3UgZXh0ZW5kcyBNbntjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKCk7Y29uc3QgaT10aGlzO2xldCByPW51bGwscz0xLG89bnVsbCxhPSJsb2NhbC1mbG9vciIsbD0xLGM9bnVsbCx1PW51bGwsZD1udWxsLGY9bnVsbCxwPW51bGwsZz1udWxsO2NvbnN0IHg9bmV3IHp1LG09dC5nZXRDb250ZXh0QXR0cmlidXRlcygpO2xldCBoPW51bGwsVD1udWxsO2NvbnN0IHk9W10sXz1bXSxDPW5ldyBQZTtsZXQgdz1udWxsO2NvbnN0IGI9bmV3IE50O2Iudmlld3BvcnQ9bmV3IHJ0O2NvbnN0IEY9bmV3IE50O0Yudmlld3BvcnQ9bmV3IHJ0O2NvbnN0IEU9W2IsRl0sUz1uZXcgSXU7bGV0IFI9bnVsbCxxPW51bGw7dGhpcy5jYW1lcmFBdXRvVXBkYXRlPSEwLHRoaXMuZW5hYmxlZD0hMSx0aGlzLmlzUHJlc2VudGluZz0hMSx0aGlzLmdldENvbnRyb2xsZXI9ZnVuY3Rpb24oWCl7bGV0IGVlPXlbWF07cmV0dXJuIGVlPT09dm9pZCAwJiYoZWU9bmV3IGZyLHlbWF09ZWUpLGVlLmdldFRhcmdldFJheVNwYWNlKCl9LHRoaXMuZ2V0Q29udHJvbGxlckdyaXA9ZnVuY3Rpb24oWCl7bGV0IGVlPXlbWF07cmV0dXJuIGVlPT09dm9pZCAwJiYoZWU9bmV3IGZyLHlbWF09ZWUpLGVlLmdldEdyaXBTcGFjZSgpfSx0aGlzLmdldEhhbmQ9ZnVuY3Rpb24oWCl7bGV0IGVlPXlbWF07cmV0dXJuIGVlPT09dm9pZCAwJiYoZWU9bmV3IGZyLHlbWF09ZWUpLGVlLmdldEhhbmRTcGFjZSgpfTtmdW5jdGlvbiB6KFgpe2NvbnN0IGVlPV8uaW5kZXhPZihYLmlucHV0U291cmNlKTtpZihlZT09PS0xKXJldHVybjtjb25zdCBnZT15W2VlXTtnZSE9PXZvaWQgMCYmKGdlLnVwZGF0ZShYLmlucHV0U291cmNlLFguZnJhbWUsY3x8byksZ2UuZGlzcGF0Y2hFdmVudCh7dHlwZTpYLnR5cGUsZGF0YTpYLmlucHV0U291cmNlfSkpfWZ1bmN0aW9uIFcoKXtyLnJlbW92ZUV2ZW50TGlzdGVuZXIoInNlbGVjdCIseiksci5yZW1vdmVFdmVudExpc3RlbmVyKCJzZWxlY3RzdGFydCIseiksci5yZW1vdmVFdmVudExpc3RlbmVyKCJzZWxlY3RlbmQiLHopLHIucmVtb3ZlRXZlbnRMaXN0ZW5lcigic3F1ZWV6ZSIseiksci5yZW1vdmVFdmVudExpc3RlbmVyKCJzcXVlZXplc3RhcnQiLHopLHIucmVtb3ZlRXZlbnRMaXN0ZW5lcigic3F1ZWV6ZWVuZCIseiksci5yZW1vdmVFdmVudExpc3RlbmVyKCJlbmQiLFcpLHIucmVtb3ZlRXZlbnRMaXN0ZW5lcigiaW5wdXRzb3VyY2VzY2hhbmdlIixaKTtmb3IobGV0IFg9MDtYPHkubGVuZ3RoO1grKyl7Y29uc3QgZWU9X1tYXTtlZSE9PW51bGwmJihfW1hdPW51bGwseVtYXS5kaXNjb25uZWN0KGVlKSl9Uj1udWxsLHE9bnVsbCx4LnJlc2V0KCksZS5zZXRSZW5kZXJUYXJnZXQoaCkscD1udWxsLGY9bnVsbCxkPW51bGwscj1udWxsLFQ9bnVsbCxZZS5zdG9wKCksaS5pc1ByZXNlbnRpbmc9ITEsZS5zZXRQaXhlbFJhdGlvKHcpLGUuc2V0U2l6ZShDLndpZHRoLEMuaGVpZ2h0LCExKSxpLmRpc3BhdGNoRXZlbnQoe3R5cGU6InNlc3Npb25lbmQifSl9dGhpcy5zZXRGcmFtZWJ1ZmZlclNjYWxlRmFjdG9yPWZ1bmN0aW9uKFgpe3M9WCxpLmlzUHJlc2VudGluZz09PSEwJiZjb25zb2xlLndhcm4oIlRIUkVFLldlYlhSTWFuYWdlcjogQ2Fubm90IGNoYW5nZSBmcmFtZWJ1ZmZlciBzY2FsZSB3aGlsZSBwcmVzZW50aW5nLiIpfSx0aGlzLnNldFJlZmVyZW5jZVNwYWNlVHlwZT1mdW5jdGlvbihYKXthPVgsaS5pc1ByZXNlbnRpbmc9PT0hMCYmY29uc29sZS53YXJuKCJUSFJFRS5XZWJYUk1hbmFnZXI6IENhbm5vdCBjaGFuZ2UgcmVmZXJlbmNlIHNwYWNlIHR5cGUgd2hpbGUgcHJlc2VudGluZy4iKX0sdGhpcy5nZXRSZWZlcmVuY2VTcGFjZT1mdW5jdGlvbigpe3JldHVybiBjfHxvfSx0aGlzLnNldFJlZmVyZW5jZVNwYWNlPWZ1bmN0aW9uKFgpe2M9WH0sdGhpcy5nZXRCYXNlTGF5ZXI9ZnVuY3Rpb24oKXtyZXR1cm4gZiE9PW51bGw/ZjpwfSx0aGlzLmdldEJpbmRpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gZH0sdGhpcy5nZXRGcmFtZT1mdW5jdGlvbigpe3JldHVybiBnfSx0aGlzLmdldFNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4gcn0sdGhpcy5zZXRTZXNzaW9uPWFzeW5jIGZ1bmN0aW9uKFgpe2lmKHI9WCxyIT09bnVsbCl7aWYoaD1lLmdldFJlbmRlclRhcmdldCgpLHIuYWRkRXZlbnRMaXN0ZW5lcigic2VsZWN0Iix6KSxyLmFkZEV2ZW50TGlzdGVuZXIoInNlbGVjdHN0YXJ0Iix6KSxyLmFkZEV2ZW50TGlzdGVuZXIoInNlbGVjdGVuZCIseiksci5hZGRFdmVudExpc3RlbmVyKCJzcXVlZXplIix6KSxyLmFkZEV2ZW50TGlzdGVuZXIoInNxdWVlemVzdGFydCIseiksci5hZGRFdmVudExpc3RlbmVyKCJzcXVlZXplZW5kIix6KSxyLmFkZEV2ZW50TGlzdGVuZXIoImVuZCIsVyksci5hZGRFdmVudExpc3RlbmVyKCJpbnB1dHNvdXJjZXNjaGFuZ2UiLFopLG0ueHJDb21wYXRpYmxlIT09ITAmJmF3YWl0IHQubWFrZVhSQ29tcGF0aWJsZSgpLHc9ZS5nZXRQaXhlbFJhdGlvKCksZS5nZXRTaXplKEMpLHIucmVuZGVyU3RhdGUubGF5ZXJzPT09dm9pZCAwKXtjb25zdCBlZT17YW50aWFsaWFzOm0uYW50aWFsaWFzLGFscGhhOiEwLGRlcHRoOm0uZGVwdGgsc3RlbmNpbDptLnN0ZW5jaWwsZnJhbWVidWZmZXJTY2FsZUZhY3RvcjpzfTtwPW5ldyBYUldlYkdMTGF5ZXIocix0LGVlKSxyLnVwZGF0ZVJlbmRlclN0YXRlKHtiYXNlTGF5ZXI6cH0pLGUuc2V0UGl4ZWxSYXRpbygxKSxlLnNldFNpemUocC5mcmFtZWJ1ZmZlcldpZHRoLHAuZnJhbWVidWZmZXJIZWlnaHQsITEpLFQ9bmV3IEp0KHAuZnJhbWVidWZmZXJXaWR0aCxwLmZyYW1lYnVmZmVySGVpZ2h0LHtmb3JtYXQ6MTAyMyx0eXBlOjEwMDksY29sb3JTcGFjZTplLm91dHB1dENvbG9yU3BhY2Usc3RlbmNpbEJ1ZmZlcjptLnN0ZW5jaWx9KX1lbHNle2xldCBlZT1udWxsLGdlPW51bGwscmU9bnVsbDttLmRlcHRoJiYocmU9bS5zdGVuY2lsP3QuREVQVEgyNF9TVEVOQ0lMODp0LkRFUFRIX0NPTVBPTkVOVDI0LGVlPW0uc3RlbmNpbD8xMDI3OjEwMjYsZ2U9bS5zdGVuY2lsPzEwMjA6MTAxNCk7Y29uc3QgeWU9e2NvbG9yRm9ybWF0OnQuUkdCQTgsZGVwdGhGb3JtYXQ6cmUsc2NhbGVGYWN0b3I6c307ZD1uZXcgWFJXZWJHTEJpbmRpbmcocix0KSxmPWQuY3JlYXRlUHJvamVjdGlvbkxheWVyKHllKSxyLnVwZGF0ZVJlbmRlclN0YXRlKHtsYXllcnM6W2ZdfSksZS5zZXRQaXhlbFJhdGlvKDEpLGUuc2V0U2l6ZShmLnRleHR1cmVXaWR0aCxmLnRleHR1cmVIZWlnaHQsITEpLFQ9bmV3IEp0KGYudGV4dHVyZVdpZHRoLGYudGV4dHVyZUhlaWdodCx7Zm9ybWF0OjEwMjMsdHlwZToxMDA5LGRlcHRoVGV4dHVyZTpuZXcgbHMoZi50ZXh0dXJlV2lkdGgsZi50ZXh0dXJlSGVpZ2h0LGdlLHZvaWQgMCx2b2lkIDAsdm9pZCAwLHZvaWQgMCx2b2lkIDAsdm9pZCAwLGVlKSxzdGVuY2lsQnVmZmVyOm0uc3RlbmNpbCxjb2xvclNwYWNlOmUub3V0cHV0Q29sb3JTcGFjZSxzYW1wbGVzOm0uYW50aWFsaWFzPzQ6MCxyZXNvbHZlRGVwdGhCdWZmZXI6Zi5pZ25vcmVEZXB0aFZhbHVlcz09PSExfSl9VC5pc1hSUmVuZGVyVGFyZ2V0PSEwLHRoaXMuc2V0Rm92ZWF0aW9uKGwpLGM9bnVsbCxvPWF3YWl0IHIucmVxdWVzdFJlZmVyZW5jZVNwYWNlKGEpLFllLnNldENvbnRleHQociksWWUuc3RhcnQoKSxpLmlzUHJlc2VudGluZz0hMCxpLmRpc3BhdGNoRXZlbnQoe3R5cGU6InNlc3Npb25zdGFydCJ9KX19LHRoaXMuZ2V0RW52aXJvbm1lbnRCbGVuZE1vZGU9ZnVuY3Rpb24oKXtpZihyIT09bnVsbClyZXR1cm4gci5lbnZpcm9ubWVudEJsZW5kTW9kZX0sdGhpcy5nZXREZXB0aFRleHR1cmU9ZnVuY3Rpb24oKXtyZXR1cm4geC5nZXREZXB0aFRleHR1cmUoKX07ZnVuY3Rpb24gWihYKXtmb3IobGV0IGVlPTA7ZWU8WC5yZW1vdmVkLmxlbmd0aDtlZSsrKXtjb25zdCBnZT1YLnJlbW92ZWRbZWVdLHJlPV8uaW5kZXhPZihnZSk7cmU+PTAmJihfW3JlXT1udWxsLHlbcmVdLmRpc2Nvbm5lY3QoZ2UpKX1mb3IobGV0IGVlPTA7ZWU8WC5hZGRlZC5sZW5ndGg7ZWUrKyl7Y29uc3QgZ2U9WC5hZGRlZFtlZV07bGV0IHJlPV8uaW5kZXhPZihnZSk7aWYocmU9PT0tMSl7Zm9yKGxldCB3ZT0wO3dlPHkubGVuZ3RoO3dlKyspaWYod2U+PV8ubGVuZ3RoKXtfLnB1c2goZ2UpLHJlPXdlO2JyZWFrfWVsc2UgaWYoX1t3ZV09PT1udWxsKXtfW3dlXT1nZSxyZT13ZTticmVha31pZihyZT09PS0xKWJyZWFrfWNvbnN0IHllPXlbcmVdO3llJiZ5ZS5jb25uZWN0KGdlKX19Y29uc3QgVj1uZXcgTyxRPW5ldyBPO2Z1bmN0aW9uIEgoWCxlZSxnZSl7Vi5zZXRGcm9tTWF0cml4UG9zaXRpb24oZWUubWF0cml4V29ybGQpLFEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGdlLm1hdHJpeFdvcmxkKTtjb25zdCByZT1WLmRpc3RhbmNlVG8oUSkseWU9ZWUucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cyx3ZT1nZS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzLEZlPXllWzE0XS8oeWVbMTBdLTEpLG50PXllWzE0XS8oeWVbMTBdKzEpLHplPSh5ZVs5XSsxKS95ZVs1XSxhdD0oeWVbOV0tMSkveWVbNV0sVT0oeWVbOF0tMSkveWVbMF0sUHQ9KHdlWzhdKzEpL3dlWzBdLEllPUZlKlUsTmU9RmUqUHQsU2U9cmUvKC1VK1B0KSxqZT1TZSotVTtpZihlZS5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoWC5wb3NpdGlvbixYLnF1YXRlcm5pb24sWC5zY2FsZSksWC50cmFuc2xhdGVYKGplKSxYLnRyYW5zbGF0ZVooU2UpLFgubWF0cml4V29ybGQuY29tcG9zZShYLnBvc2l0aW9uLFgucXVhdGVybmlvbixYLnNjYWxlKSxYLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KFgubWF0cml4V29ybGQpLmludmVydCgpLHllWzEwXT09PS0xKVgucHJvamVjdGlvbk1hdHJpeC5jb3B5KGVlLnByb2plY3Rpb25NYXRyaXgpLFgucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weShlZS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSk7ZWxzZXtjb25zdCBNZT1GZStTZSxBPW50K1NlLHY9SWUtamUsST1OZSsocmUtamUpLFk9emUqbnQvQSpNZSxLPWF0Km50L0EqTWU7WC5wcm9qZWN0aW9uTWF0cml4Lm1ha2VQZXJzcGVjdGl2ZSh2LEksWSxLLE1lLEEpLFgucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weShYLnByb2plY3Rpb25NYXRyaXgpLmludmVydCgpfX1mdW5jdGlvbiBpZShYLGVlKXtlZT09PW51bGw/WC5tYXRyaXhXb3JsZC5jb3B5KFgubWF0cml4KTpYLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoZWUubWF0cml4V29ybGQsWC5tYXRyaXgpLFgubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoWC5tYXRyaXhXb3JsZCkuaW52ZXJ0KCl9dGhpcy51cGRhdGVDYW1lcmE9ZnVuY3Rpb24oWCl7aWYocj09PW51bGwpcmV0dXJuO2xldCBlZT1YLm5lYXIsZ2U9WC5mYXI7eC50ZXh0dXJlIT09bnVsbCYmKHguZGVwdGhOZWFyPjAmJihlZT14LmRlcHRoTmVhcikseC5kZXB0aEZhcj4wJiYoZ2U9eC5kZXB0aEZhcikpLFMubmVhcj1GLm5lYXI9Yi5uZWFyPWVlLFMuZmFyPUYuZmFyPWIuZmFyPWdlLChSIT09Uy5uZWFyfHxxIT09Uy5mYXIpJiYoci51cGRhdGVSZW5kZXJTdGF0ZSh7ZGVwdGhOZWFyOlMubmVhcixkZXB0aEZhcjpTLmZhcn0pLFI9Uy5uZWFyLHE9Uy5mYXIpLGIubGF5ZXJzLm1hc2s9WC5sYXllcnMubWFza3wyLEYubGF5ZXJzLm1hc2s9WC5sYXllcnMubWFza3w0LFMubGF5ZXJzLm1hc2s9Yi5sYXllcnMubWFza3xGLmxheWVycy5tYXNrO2NvbnN0IHJlPVgucGFyZW50LHllPVMuY2FtZXJhcztpZShTLHJlKTtmb3IobGV0IHdlPTA7d2U8eWUubGVuZ3RoO3dlKyspaWUoeWVbd2VdLHJlKTt5ZS5sZW5ndGg9PT0yP0goUyxiLEYpOlMucHJvamVjdGlvbk1hdHJpeC5jb3B5KGIucHJvamVjdGlvbk1hdHJpeCksY2UoWCxTLHJlKX07ZnVuY3Rpb24gY2UoWCxlZSxnZSl7Z2U9PT1udWxsP1gubWF0cml4LmNvcHkoZWUubWF0cml4V29ybGQpOihYLm1hdHJpeC5jb3B5KGdlLm1hdHJpeFdvcmxkKSxYLm1hdHJpeC5pbnZlcnQoKSxYLm1hdHJpeC5tdWx0aXBseShlZS5tYXRyaXhXb3JsZCkpLFgubWF0cml4LmRlY29tcG9zZShYLnBvc2l0aW9uLFgucXVhdGVybmlvbixYLnNjYWxlKSxYLnVwZGF0ZU1hdHJpeFdvcmxkKCEwKSxYLnByb2plY3Rpb25NYXRyaXguY29weShlZS5wcm9qZWN0aW9uTWF0cml4KSxYLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkoZWUucHJvamVjdGlvbk1hdHJpeEludmVyc2UpLFguaXNQZXJzcGVjdGl2ZUNhbWVyYSYmKFguZm92PVZuKjIqTWF0aC5hdGFuKDEvWC5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWzVdKSxYLnpvb209MSl9dGhpcy5nZXRDYW1lcmE9ZnVuY3Rpb24oKXtyZXR1cm4gU30sdGhpcy5nZXRGb3ZlYXRpb249ZnVuY3Rpb24oKXtpZighKGY9PT1udWxsJiZwPT09bnVsbCkpcmV0dXJuIGx9LHRoaXMuc2V0Rm92ZWF0aW9uPWZ1bmN0aW9uKFgpe2w9WCxmIT09bnVsbCYmKGYuZml4ZWRGb3ZlYXRpb249WCkscCE9PW51bGwmJnAuZml4ZWRGb3ZlYXRpb24hPT12b2lkIDAmJihwLmZpeGVkRm92ZWF0aW9uPVgpfSx0aGlzLmhhc0RlcHRoU2Vuc2luZz1mdW5jdGlvbigpe3JldHVybiB4LnRleHR1cmUhPT1udWxsfSx0aGlzLmdldERlcHRoU2Vuc2luZ01lc2g9ZnVuY3Rpb24oKXtyZXR1cm4geC5nZXRNZXNoKFMpfTtsZXQgeGU9bnVsbDtmdW5jdGlvbiBVZShYLGVlKXtpZih1PWVlLmdldFZpZXdlclBvc2UoY3x8byksZz1lZSx1IT09bnVsbCl7Y29uc3QgZ2U9dS52aWV3cztwIT09bnVsbCYmKGUuc2V0UmVuZGVyVGFyZ2V0RnJhbWVidWZmZXIoVCxwLmZyYW1lYnVmZmVyKSxlLnNldFJlbmRlclRhcmdldChUKSk7bGV0IHJlPSExO2dlLmxlbmd0aCE9PVMuY2FtZXJhcy5sZW5ndGgmJihTLmNhbWVyYXMubGVuZ3RoPTAscmU9ITApO2ZvcihsZXQgd2U9MDt3ZTxnZS5sZW5ndGg7d2UrKyl7Y29uc3QgRmU9Z2Vbd2VdO2xldCBudD1udWxsO2lmKHAhPT1udWxsKW50PXAuZ2V0Vmlld3BvcnQoRmUpO2Vsc2V7Y29uc3QgYXQ9ZC5nZXRWaWV3U3ViSW1hZ2UoZixGZSk7bnQ9YXQudmlld3BvcnQsd2U9PT0wJiYoZS5zZXRSZW5kZXJUYXJnZXRUZXh0dXJlcyhULGF0LmNvbG9yVGV4dHVyZSxmLmlnbm9yZURlcHRoVmFsdWVzP3ZvaWQgMDphdC5kZXB0aFN0ZW5jaWxUZXh0dXJlKSxlLnNldFJlbmRlclRhcmdldChUKSl9bGV0IHplPUVbd2VdO3plPT09dm9pZCAwJiYoemU9bmV3IE50LHplLmxheWVycy5lbmFibGUod2UpLHplLnZpZXdwb3J0PW5ldyBydCxFW3dlXT16ZSksemUubWF0cml4LmZyb21BcnJheShGZS50cmFuc2Zvcm0ubWF0cml4KSx6ZS5tYXRyaXguZGVjb21wb3NlKHplLnBvc2l0aW9uLHplLnF1YXRlcm5pb24semUuc2NhbGUpLHplLnByb2plY3Rpb25NYXRyaXguZnJvbUFycmF5KEZlLnByb2plY3Rpb25NYXRyaXgpLHplLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkoemUucHJvamVjdGlvbk1hdHJpeCkuaW52ZXJ0KCksemUudmlld3BvcnQuc2V0KG50LngsbnQueSxudC53aWR0aCxudC5oZWlnaHQpLHdlPT09MCYmKFMubWF0cml4LmNvcHkoemUubWF0cml4KSxTLm1hdHJpeC5kZWNvbXBvc2UoUy5wb3NpdGlvbixTLnF1YXRlcm5pb24sUy5zY2FsZSkpLHJlPT09ITAmJlMuY2FtZXJhcy5wdXNoKHplKX1jb25zdCB5ZT1yLmVuYWJsZWRGZWF0dXJlcztpZih5ZSYmeWUuaW5jbHVkZXMoImRlcHRoLXNlbnNpbmciKSl7Y29uc3Qgd2U9ZC5nZXREZXB0aEluZm9ybWF0aW9uKGdlWzBdKTt3ZSYmd2UuaXNWYWxpZCYmd2UudGV4dHVyZSYmeC5pbml0KGUsd2Usci5yZW5kZXJTdGF0ZSl9fWZvcihsZXQgZ2U9MDtnZTx5Lmxlbmd0aDtnZSsrKXtjb25zdCByZT1fW2dlXSx5ZT15W2dlXTtyZSE9PW51bGwmJnllIT09dm9pZCAwJiZ5ZS51cGRhdGUocmUsZWUsY3x8byl9eGUmJnhlKFgsZWUpLGVlLmRldGVjdGVkUGxhbmVzJiZpLmRpc3BhdGNoRXZlbnQoe3R5cGU6InBsYW5lc2RldGVjdGVkIixkYXRhOmVlfSksZz1udWxsfWNvbnN0IFllPW5ldyBlcztZZS5zZXRBbmltYXRpb25Mb29wKFVlKSx0aGlzLnNldEFuaW1hdGlvbkxvb3A9ZnVuY3Rpb24oWCl7eGU9WH0sdGhpcy5kaXNwb3NlPWZ1bmN0aW9uKCl7fX19Y29uc3QgX249bmV3IFh0LEh1PW5ldyBzdDtmdW5jdGlvbiBWdShuLGUpe2Z1bmN0aW9uIHQobSxoKXttLm1hdHJpeEF1dG9VcGRhdGU9PT0hMCYmbS51cGRhdGVNYXRyaXgoKSxoLnZhbHVlLmNvcHkobS5tYXRyaXgpfWZ1bmN0aW9uIGkobSxoKXtoLmNvbG9yLmdldFJHQihtLmZvZ0NvbG9yLnZhbHVlLCRyKG4pKSxoLmlzRm9nPyhtLmZvZ05lYXIudmFsdWU9aC5uZWFyLG0uZm9nRmFyLnZhbHVlPWguZmFyKTpoLmlzRm9nRXhwMiYmKG0uZm9nRGVuc2l0eS52YWx1ZT1oLmRlbnNpdHkpfWZ1bmN0aW9uIHIobSxoLFQseSxfKXtoLmlzTWVzaEJhc2ljTWF0ZXJpYWx8fGguaXNNZXNoTGFtYmVydE1hdGVyaWFsP3MobSxoKTpoLmlzTWVzaFRvb25NYXRlcmlhbD8ocyhtLGgpLGQobSxoKSk6aC5pc01lc2hQaG9uZ01hdGVyaWFsPyhzKG0saCksdShtLGgpKTpoLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWw/KHMobSxoKSxmKG0saCksaC5pc01lc2hQaHlzaWNhbE1hdGVyaWFsJiZwKG0saCxfKSk6aC5pc01lc2hNYXRjYXBNYXRlcmlhbD8ocyhtLGgpLGcobSxoKSk6aC5pc01lc2hEZXB0aE1hdGVyaWFsP3MobSxoKTpoLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWw/KHMobSxoKSx4KG0saCkpOmguaXNNZXNoTm9ybWFsTWF0ZXJpYWw/cyhtLGgpOmguaXNMaW5lQmFzaWNNYXRlcmlhbD8obyhtLGgpLGguaXNMaW5lRGFzaGVkTWF0ZXJpYWwmJmEobSxoKSk6aC5pc1BvaW50c01hdGVyaWFsP2wobSxoLFQseSk6aC5pc1Nwcml0ZU1hdGVyaWFsP2MobSxoKTpoLmlzU2hhZG93TWF0ZXJpYWw/KG0uY29sb3IudmFsdWUuY29weShoLmNvbG9yKSxtLm9wYWNpdHkudmFsdWU9aC5vcGFjaXR5KTpoLmlzU2hhZGVyTWF0ZXJpYWwmJihoLnVuaWZvcm1zTmVlZFVwZGF0ZT0hMSl9ZnVuY3Rpb24gcyhtLGgpe20ub3BhY2l0eS52YWx1ZT1oLm9wYWNpdHksaC5jb2xvciYmbS5kaWZmdXNlLnZhbHVlLmNvcHkoaC5jb2xvciksaC5lbWlzc2l2ZSYmbS5lbWlzc2l2ZS52YWx1ZS5jb3B5KGguZW1pc3NpdmUpLm11bHRpcGx5U2NhbGFyKGguZW1pc3NpdmVJbnRlbnNpdHkpLGgubWFwJiYobS5tYXAudmFsdWU9aC5tYXAsdChoLm1hcCxtLm1hcFRyYW5zZm9ybSkpLGguYWxwaGFNYXAmJihtLmFscGhhTWFwLnZhbHVlPWguYWxwaGFNYXAsdChoLmFscGhhTWFwLG0uYWxwaGFNYXBUcmFuc2Zvcm0pKSxoLmJ1bXBNYXAmJihtLmJ1bXBNYXAudmFsdWU9aC5idW1wTWFwLHQoaC5idW1wTWFwLG0uYnVtcE1hcFRyYW5zZm9ybSksbS5idW1wU2NhbGUudmFsdWU9aC5idW1wU2NhbGUsaC5zaWRlPT09MSYmKG0uYnVtcFNjYWxlLnZhbHVlKj0tMSkpLGgubm9ybWFsTWFwJiYobS5ub3JtYWxNYXAudmFsdWU9aC5ub3JtYWxNYXAsdChoLm5vcm1hbE1hcCxtLm5vcm1hbE1hcFRyYW5zZm9ybSksbS5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KGgubm9ybWFsU2NhbGUpLGguc2lkZT09PTEmJm0ubm9ybWFsU2NhbGUudmFsdWUubmVnYXRlKCkpLGguZGlzcGxhY2VtZW50TWFwJiYobS5kaXNwbGFjZW1lbnRNYXAudmFsdWU9aC5kaXNwbGFjZW1lbnRNYXAsdChoLmRpc3BsYWNlbWVudE1hcCxtLmRpc3BsYWNlbWVudE1hcFRyYW5zZm9ybSksbS5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZT1oLmRpc3BsYWNlbWVudFNjYWxlLG0uZGlzcGxhY2VtZW50Qmlhcy52YWx1ZT1oLmRpc3BsYWNlbWVudEJpYXMpLGguZW1pc3NpdmVNYXAmJihtLmVtaXNzaXZlTWFwLnZhbHVlPWguZW1pc3NpdmVNYXAsdChoLmVtaXNzaXZlTWFwLG0uZW1pc3NpdmVNYXBUcmFuc2Zvcm0pKSxoLnNwZWN1bGFyTWFwJiYobS5zcGVjdWxhck1hcC52YWx1ZT1oLnNwZWN1bGFyTWFwLHQoaC5zcGVjdWxhck1hcCxtLnNwZWN1bGFyTWFwVHJhbnNmb3JtKSksaC5hbHBoYVRlc3Q+MCYmKG0uYWxwaGFUZXN0LnZhbHVlPWguYWxwaGFUZXN0KTtjb25zdCBUPWUuZ2V0KGgpLHk9VC5lbnZNYXAsXz1ULmVudk1hcFJvdGF0aW9uO3kmJihtLmVudk1hcC52YWx1ZT15LF9uLmNvcHkoXyksX24ueCo9LTEsX24ueSo9LTEsX24ueio9LTEseS5pc0N1YmVUZXh0dXJlJiZ5LmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT09PSExJiYoX24ueSo9LTEsX24ueio9LTEpLG0uZW52TWFwUm90YXRpb24udmFsdWUuc2V0RnJvbU1hdHJpeDQoSHUubWFrZVJvdGF0aW9uRnJvbUV1bGVyKF9uKSksbS5mbGlwRW52TWFwLnZhbHVlPXkuaXNDdWJlVGV4dHVyZSYmeS5pc1JlbmRlclRhcmdldFRleHR1cmU9PT0hMT8tMToxLG0ucmVmbGVjdGl2aXR5LnZhbHVlPWgucmVmbGVjdGl2aXR5LG0uaW9yLnZhbHVlPWguaW9yLG0ucmVmcmFjdGlvblJhdGlvLnZhbHVlPWgucmVmcmFjdGlvblJhdGlvKSxoLmxpZ2h0TWFwJiYobS5saWdodE1hcC52YWx1ZT1oLmxpZ2h0TWFwLG0ubGlnaHRNYXBJbnRlbnNpdHkudmFsdWU9aC5saWdodE1hcEludGVuc2l0eSx0KGgubGlnaHRNYXAsbS5saWdodE1hcFRyYW5zZm9ybSkpLGguYW9NYXAmJihtLmFvTWFwLnZhbHVlPWguYW9NYXAsbS5hb01hcEludGVuc2l0eS52YWx1ZT1oLmFvTWFwSW50ZW5zaXR5LHQoaC5hb01hcCxtLmFvTWFwVHJhbnNmb3JtKSl9ZnVuY3Rpb24gbyhtLGgpe20uZGlmZnVzZS52YWx1ZS5jb3B5KGguY29sb3IpLG0ub3BhY2l0eS52YWx1ZT1oLm9wYWNpdHksaC5tYXAmJihtLm1hcC52YWx1ZT1oLm1hcCx0KGgubWFwLG0ubWFwVHJhbnNmb3JtKSl9ZnVuY3Rpb24gYShtLGgpe20uZGFzaFNpemUudmFsdWU9aC5kYXNoU2l6ZSxtLnRvdGFsU2l6ZS52YWx1ZT1oLmRhc2hTaXplK2guZ2FwU2l6ZSxtLnNjYWxlLnZhbHVlPWguc2NhbGV9ZnVuY3Rpb24gbChtLGgsVCx5KXttLmRpZmZ1c2UudmFsdWUuY29weShoLmNvbG9yKSxtLm9wYWNpdHkudmFsdWU9aC5vcGFjaXR5LG0uc2l6ZS52YWx1ZT1oLnNpemUqVCxtLnNjYWxlLnZhbHVlPXkqLjUsaC5tYXAmJihtLm1hcC52YWx1ZT1oLm1hcCx0KGgubWFwLG0udXZUcmFuc2Zvcm0pKSxoLmFscGhhTWFwJiYobS5hbHBoYU1hcC52YWx1ZT1oLmFscGhhTWFwLHQoaC5hbHBoYU1hcCxtLmFscGhhTWFwVHJhbnNmb3JtKSksaC5hbHBoYVRlc3Q+MCYmKG0uYWxwaGFUZXN0LnZhbHVlPWguYWxwaGFUZXN0KX1mdW5jdGlvbiBjKG0saCl7bS5kaWZmdXNlLnZhbHVlLmNvcHkoaC5jb2xvciksbS5vcGFjaXR5LnZhbHVlPWgub3BhY2l0eSxtLnJvdGF0aW9uLnZhbHVlPWgucm90YXRpb24saC5tYXAmJihtLm1hcC52YWx1ZT1oLm1hcCx0KGgubWFwLG0ubWFwVHJhbnNmb3JtKSksaC5hbHBoYU1hcCYmKG0uYWxwaGFNYXAudmFsdWU9aC5hbHBoYU1hcCx0KGguYWxwaGFNYXAsbS5hbHBoYU1hcFRyYW5zZm9ybSkpLGguYWxwaGFUZXN0PjAmJihtLmFscGhhVGVzdC52YWx1ZT1oLmFscGhhVGVzdCl9ZnVuY3Rpb24gdShtLGgpe20uc3BlY3VsYXIudmFsdWUuY29weShoLnNwZWN1bGFyKSxtLnNoaW5pbmVzcy52YWx1ZT1NYXRoLm1heChoLnNoaW5pbmVzcywxZS00KX1mdW5jdGlvbiBkKG0saCl7aC5ncmFkaWVudE1hcCYmKG0uZ3JhZGllbnRNYXAudmFsdWU9aC5ncmFkaWVudE1hcCl9ZnVuY3Rpb24gZihtLGgpe20ubWV0YWxuZXNzLnZhbHVlPWgubWV0YWxuZXNzLGgubWV0YWxuZXNzTWFwJiYobS5tZXRhbG5lc3NNYXAudmFsdWU9aC5tZXRhbG5lc3NNYXAsdChoLm1ldGFsbmVzc01hcCxtLm1ldGFsbmVzc01hcFRyYW5zZm9ybSkpLG0ucm91Z2huZXNzLnZhbHVlPWgucm91Z2huZXNzLGgucm91Z2huZXNzTWFwJiYobS5yb3VnaG5lc3NNYXAudmFsdWU9aC5yb3VnaG5lc3NNYXAsdChoLnJvdWdobmVzc01hcCxtLnJvdWdobmVzc01hcFRyYW5zZm9ybSkpLGguZW52TWFwJiYobS5lbnZNYXBJbnRlbnNpdHkudmFsdWU9aC5lbnZNYXBJbnRlbnNpdHkpfWZ1bmN0aW9uIHAobSxoLFQpe20uaW9yLnZhbHVlPWguaW9yLGguc2hlZW4+MCYmKG0uc2hlZW5Db2xvci52YWx1ZS5jb3B5KGguc2hlZW5Db2xvcikubXVsdGlwbHlTY2FsYXIoaC5zaGVlbiksbS5zaGVlblJvdWdobmVzcy52YWx1ZT1oLnNoZWVuUm91Z2huZXNzLGguc2hlZW5Db2xvck1hcCYmKG0uc2hlZW5Db2xvck1hcC52YWx1ZT1oLnNoZWVuQ29sb3JNYXAsdChoLnNoZWVuQ29sb3JNYXAsbS5zaGVlbkNvbG9yTWFwVHJhbnNmb3JtKSksaC5zaGVlblJvdWdobmVzc01hcCYmKG0uc2hlZW5Sb3VnaG5lc3NNYXAudmFsdWU9aC5zaGVlblJvdWdobmVzc01hcCx0KGguc2hlZW5Sb3VnaG5lc3NNYXAsbS5zaGVlblJvdWdobmVzc01hcFRyYW5zZm9ybSkpKSxoLmNsZWFyY29hdD4wJiYobS5jbGVhcmNvYXQudmFsdWU9aC5jbGVhcmNvYXQsbS5jbGVhcmNvYXRSb3VnaG5lc3MudmFsdWU9aC5jbGVhcmNvYXRSb3VnaG5lc3MsaC5jbGVhcmNvYXRNYXAmJihtLmNsZWFyY29hdE1hcC52YWx1ZT1oLmNsZWFyY29hdE1hcCx0KGguY2xlYXJjb2F0TWFwLG0uY2xlYXJjb2F0TWFwVHJhbnNmb3JtKSksaC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAmJihtLmNsZWFyY29hdFJvdWdobmVzc01hcC52YWx1ZT1oLmNsZWFyY29hdFJvdWdobmVzc01hcCx0KGguY2xlYXJjb2F0Um91Z2huZXNzTWFwLG0uY2xlYXJjb2F0Um91Z2huZXNzTWFwVHJhbnNmb3JtKSksaC5jbGVhcmNvYXROb3JtYWxNYXAmJihtLmNsZWFyY29hdE5vcm1hbE1hcC52YWx1ZT1oLmNsZWFyY29hdE5vcm1hbE1hcCx0KGguY2xlYXJjb2F0Tm9ybWFsTWFwLG0uY2xlYXJjb2F0Tm9ybWFsTWFwVHJhbnNmb3JtKSxtLmNsZWFyY29hdE5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoaC5jbGVhcmNvYXROb3JtYWxTY2FsZSksaC5zaWRlPT09MSYmbS5jbGVhcmNvYXROb3JtYWxTY2FsZS52YWx1ZS5uZWdhdGUoKSkpLGguZGlzcGVyc2lvbj4wJiYobS5kaXNwZXJzaW9uLnZhbHVlPWguZGlzcGVyc2lvbiksaC5pcmlkZXNjZW5jZT4wJiYobS5pcmlkZXNjZW5jZS52YWx1ZT1oLmlyaWRlc2NlbmNlLG0uaXJpZGVzY2VuY2VJT1IudmFsdWU9aC5pcmlkZXNjZW5jZUlPUixtLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bS52YWx1ZT1oLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbMF0sbS5pcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0udmFsdWU9aC5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlWzFdLGguaXJpZGVzY2VuY2VNYXAmJihtLmlyaWRlc2NlbmNlTWFwLnZhbHVlPWguaXJpZGVzY2VuY2VNYXAsdChoLmlyaWRlc2NlbmNlTWFwLG0uaXJpZGVzY2VuY2VNYXBUcmFuc2Zvcm0pKSxoLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwJiYobS5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcC52YWx1ZT1oLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLHQoaC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCxtLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVHJhbnNmb3JtKSkpLGgudHJhbnNtaXNzaW9uPjAmJihtLnRyYW5zbWlzc2lvbi52YWx1ZT1oLnRyYW5zbWlzc2lvbixtLnRyYW5zbWlzc2lvblNhbXBsZXJNYXAudmFsdWU9VC50ZXh0dXJlLG0udHJhbnNtaXNzaW9uU2FtcGxlclNpemUudmFsdWUuc2V0KFQud2lkdGgsVC5oZWlnaHQpLGgudHJhbnNtaXNzaW9uTWFwJiYobS50cmFuc21pc3Npb25NYXAudmFsdWU9aC50cmFuc21pc3Npb25NYXAsdChoLnRyYW5zbWlzc2lvbk1hcCxtLnRyYW5zbWlzc2lvbk1hcFRyYW5zZm9ybSkpLG0udGhpY2tuZXNzLnZhbHVlPWgudGhpY2tuZXNzLGgudGhpY2tuZXNzTWFwJiYobS50aGlja25lc3NNYXAudmFsdWU9aC50aGlja25lc3NNYXAsdChoLnRoaWNrbmVzc01hcCxtLnRoaWNrbmVzc01hcFRyYW5zZm9ybSkpLG0uYXR0ZW51YXRpb25EaXN0YW5jZS52YWx1ZT1oLmF0dGVudWF0aW9uRGlzdGFuY2UsbS5hdHRlbnVhdGlvbkNvbG9yLnZhbHVlLmNvcHkoaC5hdHRlbnVhdGlvbkNvbG9yKSksaC5hbmlzb3Ryb3B5PjAmJihtLmFuaXNvdHJvcHlWZWN0b3IudmFsdWUuc2V0KGguYW5pc290cm9weSpNYXRoLmNvcyhoLmFuaXNvdHJvcHlSb3RhdGlvbiksaC5hbmlzb3Ryb3B5Kk1hdGguc2luKGguYW5pc290cm9weVJvdGF0aW9uKSksaC5hbmlzb3Ryb3B5TWFwJiYobS5hbmlzb3Ryb3B5TWFwLnZhbHVlPWguYW5pc290cm9weU1hcCx0KGguYW5pc290cm9weU1hcCxtLmFuaXNvdHJvcHlNYXBUcmFuc2Zvcm0pKSksbS5zcGVjdWxhckludGVuc2l0eS52YWx1ZT1oLnNwZWN1bGFySW50ZW5zaXR5LG0uc3BlY3VsYXJDb2xvci52YWx1ZS5jb3B5KGguc3BlY3VsYXJDb2xvciksaC5zcGVjdWxhckNvbG9yTWFwJiYobS5zcGVjdWxhckNvbG9yTWFwLnZhbHVlPWguc3BlY3VsYXJDb2xvck1hcCx0KGguc3BlY3VsYXJDb2xvck1hcCxtLnNwZWN1bGFyQ29sb3JNYXBUcmFuc2Zvcm0pKSxoLnNwZWN1bGFySW50ZW5zaXR5TWFwJiYobS5zcGVjdWxhckludGVuc2l0eU1hcC52YWx1ZT1oLnNwZWN1bGFySW50ZW5zaXR5TWFwLHQoaC5zcGVjdWxhckludGVuc2l0eU1hcCxtLnNwZWN1bGFySW50ZW5zaXR5TWFwVHJhbnNmb3JtKSl9ZnVuY3Rpb24gZyhtLGgpe2gubWF0Y2FwJiYobS5tYXRjYXAudmFsdWU9aC5tYXRjYXApfWZ1bmN0aW9uIHgobSxoKXtjb25zdCBUPWUuZ2V0KGgpLmxpZ2h0O20ucmVmZXJlbmNlUG9zaXRpb24udmFsdWUuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKFQubWF0cml4V29ybGQpLG0ubmVhckRpc3RhbmNlLnZhbHVlPVQuc2hhZG93LmNhbWVyYS5uZWFyLG0uZmFyRGlzdGFuY2UudmFsdWU9VC5zaGFkb3cuY2FtZXJhLmZhcn1yZXR1cm57cmVmcmVzaEZvZ1VuaWZvcm1zOmkscmVmcmVzaE1hdGVyaWFsVW5pZm9ybXM6cn19ZnVuY3Rpb24ga3UobixlLHQsaSl7bGV0IHI9e30scz17fSxvPVtdO2NvbnN0IGE9bi5nZXRQYXJhbWV0ZXIobi5NQVhfVU5JRk9STV9CVUZGRVJfQklORElOR1MpO2Z1bmN0aW9uIGwoVCx5KXtjb25zdCBfPXkucHJvZ3JhbTtpLnVuaWZvcm1CbG9ja0JpbmRpbmcoVCxfKX1mdW5jdGlvbiBjKFQseSl7bGV0IF89cltULmlkXTtfPT09dm9pZCAwJiYoZyhUKSxfPXUoVCkscltULmlkXT1fLFQuYWRkRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsbSkpO2NvbnN0IEM9eS5wcm9ncmFtO2kudXBkYXRlVUJPTWFwcGluZyhULEMpO2NvbnN0IHc9ZS5yZW5kZXIuZnJhbWU7c1tULmlkXSE9PXcmJihmKFQpLHNbVC5pZF09dyl9ZnVuY3Rpb24gdShUKXtjb25zdCB5PWQoKTtULl9fYmluZGluZ1BvaW50SW5kZXg9eTtjb25zdCBfPW4uY3JlYXRlQnVmZmVyKCksQz1ULl9fc2l6ZSx3PVQudXNhZ2U7cmV0dXJuIG4uYmluZEJ1ZmZlcihuLlVOSUZPUk1fQlVGRkVSLF8pLG4uYnVmZmVyRGF0YShuLlVOSUZPUk1fQlVGRkVSLEMsdyksbi5iaW5kQnVmZmVyKG4uVU5JRk9STV9CVUZGRVIsbnVsbCksbi5iaW5kQnVmZmVyQmFzZShuLlVOSUZPUk1fQlVGRkVSLHksXyksX31mdW5jdGlvbiBkKCl7Zm9yKGxldCBUPTA7VDxhO1QrKylpZihvLmluZGV4T2YoVCk9PT0tMSlyZXR1cm4gby5wdXNoKFQpLFQ7cmV0dXJuIGNvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXI6IE1heGltdW0gbnVtYmVyIG9mIHNpbXVsdGFuZW91c2x5IHVzYWJsZSB1bmlmb3JtcyBncm91cHMgcmVhY2hlZC4iKSwwfWZ1bmN0aW9uIGYoVCl7Y29uc3QgeT1yW1QuaWRdLF89VC51bmlmb3JtcyxDPVQuX19jYWNoZTtuLmJpbmRCdWZmZXIobi5VTklGT1JNX0JVRkZFUix5KTtmb3IobGV0IHc9MCxiPV8ubGVuZ3RoO3c8Yjt3Kyspe2NvbnN0IEY9QXJyYXkuaXNBcnJheShfW3ddKT9fW3ddOltfW3ddXTtmb3IobGV0IEU9MCxTPUYubGVuZ3RoO0U8UztFKyspe2NvbnN0IFI9RltFXTtpZihwKFIsdyxFLEMpPT09ITApe2NvbnN0IHE9Ui5fX29mZnNldCx6PUFycmF5LmlzQXJyYXkoUi52YWx1ZSk/Ui52YWx1ZTpbUi52YWx1ZV07bGV0IFc9MDtmb3IobGV0IFo9MDtaPHoubGVuZ3RoO1orKyl7Y29uc3QgVj16W1pdLFE9eChWKTt0eXBlb2YgVj09Im51bWJlciJ8fHR5cGVvZiBWPT0iYm9vbGVhbiI/KFIuX19kYXRhWzBdPVYsbi5idWZmZXJTdWJEYXRhKG4uVU5JRk9STV9CVUZGRVIscStXLFIuX19kYXRhKSk6Vi5pc01hdHJpeDM/KFIuX19kYXRhWzBdPVYuZWxlbWVudHNbMF0sUi5fX2RhdGFbMV09Vi5lbGVtZW50c1sxXSxSLl9fZGF0YVsyXT1WLmVsZW1lbnRzWzJdLFIuX19kYXRhWzNdPTAsUi5fX2RhdGFbNF09Vi5lbGVtZW50c1szXSxSLl9fZGF0YVs1XT1WLmVsZW1lbnRzWzRdLFIuX19kYXRhWzZdPVYuZWxlbWVudHNbNV0sUi5fX2RhdGFbN109MCxSLl9fZGF0YVs4XT1WLmVsZW1lbnRzWzZdLFIuX19kYXRhWzldPVYuZWxlbWVudHNbN10sUi5fX2RhdGFbMTBdPVYuZWxlbWVudHNbOF0sUi5fX2RhdGFbMTFdPTApOihWLnRvQXJyYXkoUi5fX2RhdGEsVyksVys9US5zdG9yYWdlL0Zsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCl9bi5idWZmZXJTdWJEYXRhKG4uVU5JRk9STV9CVUZGRVIscSxSLl9fZGF0YSl9fX1uLmJpbmRCdWZmZXIobi5VTklGT1JNX0JVRkZFUixudWxsKX1mdW5jdGlvbiBwKFQseSxfLEMpe2NvbnN0IHc9VC52YWx1ZSxiPXkrIl8iK187aWYoQ1tiXT09PXZvaWQgMClyZXR1cm4gdHlwZW9mIHc9PSJudW1iZXIifHx0eXBlb2Ygdz09ImJvb2xlYW4iP0NbYl09dzpDW2JdPXcuY2xvbmUoKSwhMDt7Y29uc3QgRj1DW2JdO2lmKHR5cGVvZiB3PT0ibnVtYmVyInx8dHlwZW9mIHc9PSJib29sZWFuIil7aWYoRiE9PXcpcmV0dXJuIENbYl09dywhMH1lbHNlIGlmKEYuZXF1YWxzKHcpPT09ITEpcmV0dXJuIEYuY29weSh3KSwhMH1yZXR1cm4hMX1mdW5jdGlvbiBnKFQpe2NvbnN0IHk9VC51bmlmb3JtcztsZXQgXz0wO2NvbnN0IEM9MTY7Zm9yKGxldCBiPTAsRj15Lmxlbmd0aDtiPEY7YisrKXtjb25zdCBFPUFycmF5LmlzQXJyYXkoeVtiXSk/eVtiXTpbeVtiXV07Zm9yKGxldCBTPTAsUj1FLmxlbmd0aDtTPFI7UysrKXtjb25zdCBxPUVbU10sej1BcnJheS5pc0FycmF5KHEudmFsdWUpP3EudmFsdWU6W3EudmFsdWVdO2ZvcihsZXQgVz0wLFo9ei5sZW5ndGg7VzxaO1crKyl7Y29uc3QgVj16W1ddLFE9eChWKSxIPV8lQyxpZT1IJVEuYm91bmRhcnksY2U9SCtpZTtfKz1pZSxjZSE9PTAmJkMtY2U8US5zdG9yYWdlJiYoXys9Qy1jZSkscS5fX2RhdGE9bmV3IEZsb2F0MzJBcnJheShRLnN0b3JhZ2UvRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKSxxLl9fb2Zmc2V0PV8sXys9US5zdG9yYWdlfX19Y29uc3Qgdz1fJUM7cmV0dXJuIHc+MCYmKF8rPUMtdyksVC5fX3NpemU9XyxULl9fY2FjaGU9e30sdGhpc31mdW5jdGlvbiB4KFQpe2NvbnN0IHk9e2JvdW5kYXJ5OjAsc3RvcmFnZTowfTtyZXR1cm4gdHlwZW9mIFQ9PSJudW1iZXIifHx0eXBlb2YgVD09ImJvb2xlYW4iPyh5LmJvdW5kYXJ5PTQseS5zdG9yYWdlPTQpOlQuaXNWZWN0b3IyPyh5LmJvdW5kYXJ5PTgseS5zdG9yYWdlPTgpOlQuaXNWZWN0b3IzfHxULmlzQ29sb3I/KHkuYm91bmRhcnk9MTYseS5zdG9yYWdlPTEyKTpULmlzVmVjdG9yND8oeS5ib3VuZGFyeT0xNix5LnN0b3JhZ2U9MTYpOlQuaXNNYXRyaXgzPyh5LmJvdW5kYXJ5PTQ4LHkuc3RvcmFnZT00OCk6VC5pc01hdHJpeDQ/KHkuYm91bmRhcnk9NjQseS5zdG9yYWdlPTY0KTpULmlzVGV4dHVyZT9jb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgc2FtcGxlcnMgY2FuIG5vdCBiZSBwYXJ0IG9mIGFuIHVuaWZvcm1zIGdyb3VwLiIpOmNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5zdXBwb3J0ZWQgdW5pZm9ybSB2YWx1ZSB0eXBlLiIsVCkseX1mdW5jdGlvbiBtKFQpe2NvbnN0IHk9VC50YXJnZXQ7eS5yZW1vdmVFdmVudExpc3RlbmVyKCJkaXNwb3NlIixtKTtjb25zdCBfPW8uaW5kZXhPZih5Ll9fYmluZGluZ1BvaW50SW5kZXgpO28uc3BsaWNlKF8sMSksbi5kZWxldGVCdWZmZXIoclt5LmlkXSksZGVsZXRlIHJbeS5pZF0sZGVsZXRlIHNbeS5pZF19ZnVuY3Rpb24gaCgpe2Zvcihjb25zdCBUIGluIHIpbi5kZWxldGVCdWZmZXIocltUXSk7bz1bXSxyPXt9LHM9e319cmV0dXJue2JpbmQ6bCx1cGRhdGU6YyxkaXNwb3NlOmh9fWNsYXNzIFd1e2NvbnN0cnVjdG9yKGU9e30pe2NvbnN0e2NhbnZhczp0PWhhKCksY29udGV4dDppPW51bGwsZGVwdGg6cj0hMCxzdGVuY2lsOnM9ITEsYWxwaGE6bz0hMSxhbnRpYWxpYXM6YT0hMSxwcmVtdWx0aXBsaWVkQWxwaGE6bD0hMCxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6Yz0hMSxwb3dlclByZWZlcmVuY2U6dT0iZGVmYXVsdCIsZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDpkPSExLHJldmVyc2VEZXB0aEJ1ZmZlcjpmPSExfT1lO3RoaXMuaXNXZWJHTFJlbmRlcmVyPSEwO2xldCBwO2lmKGkhPT1udWxsKXtpZih0eXBlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0PCJ1IiYmaSBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCl0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXI6IFdlYkdMIDEgaXMgbm90IHN1cHBvcnRlZCBzaW5jZSByMTYzLiIpO3A9aS5nZXRDb250ZXh0QXR0cmlidXRlcygpLmFscGhhfWVsc2UgcD1vO2NvbnN0IGc9bmV3IFVpbnQzMkFycmF5KDQpLHg9bmV3IEludDMyQXJyYXkoNCk7bGV0IG09bnVsbCxoPW51bGw7Y29uc3QgVD1bXSx5PVtdO3RoaXMuZG9tRWxlbWVudD10LHRoaXMuZGVidWc9e2NoZWNrU2hhZGVyRXJyb3JzOiEwLG9uU2hhZGVyRXJyb3I6bnVsbH0sdGhpcy5hdXRvQ2xlYXI9ITAsdGhpcy5hdXRvQ2xlYXJDb2xvcj0hMCx0aGlzLmF1dG9DbGVhckRlcHRoPSEwLHRoaXMuYXV0b0NsZWFyU3RlbmNpbD0hMCx0aGlzLnNvcnRPYmplY3RzPSEwLHRoaXMuY2xpcHBpbmdQbGFuZXM9W10sdGhpcy5sb2NhbENsaXBwaW5nRW5hYmxlZD0hMSx0aGlzLl9vdXRwdXRDb2xvclNwYWNlPWJ0LHRoaXMudG9uZU1hcHBpbmc9MCx0aGlzLnRvbmVNYXBwaW5nRXhwb3N1cmU9MTtjb25zdCBfPXRoaXM7bGV0IEM9ITEsdz0wLGI9MCxGPW51bGwsRT0tMSxTPW51bGw7Y29uc3QgUj1uZXcgcnQscT1uZXcgcnQ7bGV0IHo9bnVsbDtjb25zdCBXPW5ldyBWZSgwKTtsZXQgWj0wLFY9dC53aWR0aCxRPXQuaGVpZ2h0LEg9MSxpZT1udWxsLGNlPW51bGw7Y29uc3QgeGU9bmV3IHJ0KDAsMCxWLFEpLFVlPW5ldyBydCgwLDAsVixRKTtsZXQgWWU9ITE7Y29uc3QgWD1uZXcgUXI7bGV0IGVlPSExLGdlPSExO2NvbnN0IHJlPW5ldyBzdCx5ZT1uZXcgc3Qsd2U9bmV3IE8sRmU9bmV3IHJ0LG50PXtiYWNrZ3JvdW5kOm51bGwsZm9nOm51bGwsZW52aXJvbm1lbnQ6bnVsbCxvdmVycmlkZU1hdGVyaWFsOm51bGwsaXNTY2VuZTohMH07bGV0IHplPSExO2Z1bmN0aW9uIGF0KCl7cmV0dXJuIEY9PT1udWxsP0g6MX1sZXQgVT1pO2Z1bmN0aW9uIFB0KE0sRCl7cmV0dXJuIHQuZ2V0Q29udGV4dChNLEQpfXRyeXtjb25zdCBNPXthbHBoYTohMCxkZXB0aDpyLHN0ZW5jaWw6cyxhbnRpYWxpYXM6YSxwcmVtdWx0aXBsaWVkQWxwaGE6bCxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6Yyxwb3dlclByZWZlcmVuY2U6dSxmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OmR9O2lmKCJzZXRBdHRyaWJ1dGUiaW4gdCYmdC5zZXRBdHRyaWJ1dGUoImRhdGEtZW5naW5lIixgdGhyZWUuanMgciR7Tml9YCksdC5hZGRFdmVudExpc3RlbmVyKCJ3ZWJnbGNvbnRleHRsb3N0IiwkLCExKSx0LmFkZEV2ZW50TGlzdGVuZXIoIndlYmdsY29udGV4dHJlc3RvcmVkIixsZSwhMSksdC5hZGRFdmVudExpc3RlbmVyKCJ3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yIixhZSwhMSksVT09PW51bGwpe2NvbnN0IEQ9IndlYmdsMiI7aWYoVT1QdChELE0pLFU9PT1udWxsKXRocm93IFB0KEQpP25ldyBFcnJvcigiRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dCB3aXRoIHlvdXIgc2VsZWN0ZWQgYXR0cmlidXRlcy4iKTpuZXcgRXJyb3IoIkVycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQuIil9fWNhdGNoKE0pe3Rocm93IGNvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXI6ICIrTS5tZXNzYWdlKSxNfWxldCBJZSxOZSxTZSxqZSxNZSxBLHYsSSxZLEssayxfZSxzZSx1ZSxHZSxqLGhlLEVlLFRlLGRlLE9lLExlLEtlLFA7ZnVuY3Rpb24gbmUoKXtJZT1uZXcgS2woVSksSWUuaW5pdCgpLExlPW5ldyBGdShVLEllKSxOZT1uZXcga2woVSxJZSxlLExlKSxTZT1uZXcgRHUoVSxJZSksTmUucmV2ZXJzZURlcHRoQnVmZmVyJiZmJiZTZS5idWZmZXJzLmRlcHRoLnNldFJldmVyc2VkKCEwKSxqZT1uZXcgSmwoVSksTWU9bmV3IGd1LEE9bmV3IFV1KFUsSWUsU2UsTWUsTmUsTGUsamUpLHY9bmV3IFhsKF8pLEk9bmV3ICRsKF8pLFk9bmV3IEJhKFUpLEtlPW5ldyBIbChVLFkpLEs9bmV3IFpsKFUsWSxqZSxLZSksaz1uZXcgZWMoVSxLLFksamUpLFRlPW5ldyBRbChVLE5lLEEpLGo9bmV3IFdsKE1lKSxfZT1uZXcgbXUoXyx2LEksSWUsTmUsS2Usaiksc2U9bmV3IFZ1KF8sTWUpLHVlPW5ldyB2dSxHZT1uZXcgVHUoSWUpLEVlPW5ldyBHbChfLHYsSSxTZSxrLHAsbCksaGU9bmV3IEN1KF8sayxOZSksUD1uZXcga3UoVSxqZSxOZSxTZSksZGU9bmV3IFZsKFUsSWUsamUpLE9lPW5ldyBqbChVLEllLGplKSxqZS5wcm9ncmFtcz1fZS5wcm9ncmFtcyxfLmNhcGFiaWxpdGllcz1OZSxfLmV4dGVuc2lvbnM9SWUsXy5wcm9wZXJ0aWVzPU1lLF8ucmVuZGVyTGlzdHM9dWUsXy5zaGFkb3dNYXA9aGUsXy5zdGF0ZT1TZSxfLmluZm89amV9bmUoKTtjb25zdCBHPW5ldyBHdShfLFUpO3RoaXMueHI9Ryx0aGlzLmdldENvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gVX0sdGhpcy5nZXRDb250ZXh0QXR0cmlidXRlcz1mdW5jdGlvbigpe3JldHVybiBVLmdldENvbnRleHRBdHRyaWJ1dGVzKCl9LHRoaXMuZm9yY2VDb250ZXh0TG9zcz1mdW5jdGlvbigpe2NvbnN0IE09SWUuZ2V0KCJXRUJHTF9sb3NlX2NvbnRleHQiKTtNJiZNLmxvc2VDb250ZXh0KCl9LHRoaXMuZm9yY2VDb250ZXh0UmVzdG9yZT1mdW5jdGlvbigpe2NvbnN0IE09SWUuZ2V0KCJXRUJHTF9sb3NlX2NvbnRleHQiKTtNJiZNLnJlc3RvcmVDb250ZXh0KCl9LHRoaXMuZ2V0UGl4ZWxSYXRpbz1mdW5jdGlvbigpe3JldHVybiBIfSx0aGlzLnNldFBpeGVsUmF0aW89ZnVuY3Rpb24oTSl7TSE9PXZvaWQgMCYmKEg9TSx0aGlzLnNldFNpemUoVixRLCExKSl9LHRoaXMuZ2V0U2l6ZT1mdW5jdGlvbihNKXtyZXR1cm4gTS5zZXQoVixRKX0sdGhpcy5zZXRTaXplPWZ1bmN0aW9uKE0sRCxOPSEwKXtpZihHLmlzUHJlc2VudGluZyl7Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBDYW4ndCBjaGFuZ2Ugc2l6ZSB3aGlsZSBWUiBkZXZpY2UgaXMgcHJlc2VudGluZy4iKTtyZXR1cm59Vj1NLFE9RCx0LndpZHRoPU1hdGguZmxvb3IoTSpIKSx0LmhlaWdodD1NYXRoLmZsb29yKEQqSCksTj09PSEwJiYodC5zdHlsZS53aWR0aD1NKyJweCIsdC5zdHlsZS5oZWlnaHQ9RCsicHgiKSx0aGlzLnNldFZpZXdwb3J0KDAsMCxNLEQpfSx0aGlzLmdldERyYXdpbmdCdWZmZXJTaXplPWZ1bmN0aW9uKE0pe3JldHVybiBNLnNldChWKkgsUSpIKS5mbG9vcigpfSx0aGlzLnNldERyYXdpbmdCdWZmZXJTaXplPWZ1bmN0aW9uKE0sRCxOKXtWPU0sUT1ELEg9Tix0LndpZHRoPU1hdGguZmxvb3IoTSpOKSx0LmhlaWdodD1NYXRoLmZsb29yKEQqTiksdGhpcy5zZXRWaWV3cG9ydCgwLDAsTSxEKX0sdGhpcy5nZXRDdXJyZW50Vmlld3BvcnQ9ZnVuY3Rpb24oTSl7cmV0dXJuIE0uY29weShSKX0sdGhpcy5nZXRWaWV3cG9ydD1mdW5jdGlvbihNKXtyZXR1cm4gTS5jb3B5KHhlKX0sdGhpcy5zZXRWaWV3cG9ydD1mdW5jdGlvbihNLEQsTixCKXtNLmlzVmVjdG9yND94ZS5zZXQoTS54LE0ueSxNLnosTS53KTp4ZS5zZXQoTSxELE4sQiksU2Uudmlld3BvcnQoUi5jb3B5KHhlKS5tdWx0aXBseVNjYWxhcihIKS5yb3VuZCgpKX0sdGhpcy5nZXRTY2lzc29yPWZ1bmN0aW9uKE0pe3JldHVybiBNLmNvcHkoVWUpfSx0aGlzLnNldFNjaXNzb3I9ZnVuY3Rpb24oTSxELE4sQil7TS5pc1ZlY3RvcjQ/VWUuc2V0KE0ueCxNLnksTS56LE0udyk6VWUuc2V0KE0sRCxOLEIpLFNlLnNjaXNzb3IocS5jb3B5KFVlKS5tdWx0aXBseVNjYWxhcihIKS5yb3VuZCgpKX0sdGhpcy5nZXRTY2lzc29yVGVzdD1mdW5jdGlvbigpe3JldHVybiBZZX0sdGhpcy5zZXRTY2lzc29yVGVzdD1mdW5jdGlvbihNKXtTZS5zZXRTY2lzc29yVGVzdChZZT1NKX0sdGhpcy5zZXRPcGFxdWVTb3J0PWZ1bmN0aW9uKE0pe2llPU19LHRoaXMuc2V0VHJhbnNwYXJlbnRTb3J0PWZ1bmN0aW9uKE0pe2NlPU19LHRoaXMuZ2V0Q2xlYXJDb2xvcj1mdW5jdGlvbihNKXtyZXR1cm4gTS5jb3B5KEVlLmdldENsZWFyQ29sb3IoKSl9LHRoaXMuc2V0Q2xlYXJDb2xvcj1mdW5jdGlvbigpe0VlLnNldENsZWFyQ29sb3IuYXBwbHkoRWUsYXJndW1lbnRzKX0sdGhpcy5nZXRDbGVhckFscGhhPWZ1bmN0aW9uKCl7cmV0dXJuIEVlLmdldENsZWFyQWxwaGEoKX0sdGhpcy5zZXRDbGVhckFscGhhPWZ1bmN0aW9uKCl7RWUuc2V0Q2xlYXJBbHBoYS5hcHBseShFZSxhcmd1bWVudHMpfSx0aGlzLmNsZWFyPWZ1bmN0aW9uKE09ITAsRD0hMCxOPSEwKXtsZXQgQj0wO2lmKE0pe2xldCBMPSExO2lmKEYhPT1udWxsKXtjb25zdCBKPUYudGV4dHVyZS5mb3JtYXQ7TD1KPT09MTAzM3x8Sj09PTEwMzF8fEo9PT0xMDI5fWlmKEwpe2NvbnN0IEo9Ri50ZXh0dXJlLnR5cGUsb2U9Sj09PTEwMDl8fEo9PT0xMDE0fHxKPT09MTAxMnx8Sj09PTEwMjB8fEo9PT0xMDE3fHxKPT09MTAxOCxmZT1FZS5nZXRDbGVhckNvbG9yKCkscGU9RWUuZ2V0Q2xlYXJBbHBoYSgpLEFlPWZlLnIsQ2U9ZmUuZyxtZT1mZS5iO29lPyhnWzBdPUFlLGdbMV09Q2UsZ1syXT1tZSxnWzNdPXBlLFUuY2xlYXJCdWZmZXJ1aXYoVS5DT0xPUiwwLGcpKTooeFswXT1BZSx4WzFdPUNlLHhbMl09bWUseFszXT1wZSxVLmNsZWFyQnVmZmVyaXYoVS5DT0xPUiwwLHgpKX1lbHNlIEJ8PVUuQ09MT1JfQlVGRkVSX0JJVH1EJiYoQnw9VS5ERVBUSF9CVUZGRVJfQklUKSxOJiYoQnw9VS5TVEVOQ0lMX0JVRkZFUl9CSVQsdGhpcy5zdGF0ZS5idWZmZXJzLnN0ZW5jaWwuc2V0TWFzayg0Mjk0OTY3Mjk1KSksVS5jbGVhcihCKX0sdGhpcy5jbGVhckNvbG9yPWZ1bmN0aW9uKCl7dGhpcy5jbGVhcighMCwhMSwhMSl9LHRoaXMuY2xlYXJEZXB0aD1mdW5jdGlvbigpe3RoaXMuY2xlYXIoITEsITAsITEpfSx0aGlzLmNsZWFyU3RlbmNpbD1mdW5jdGlvbigpe3RoaXMuY2xlYXIoITEsITEsITApfSx0aGlzLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoIndlYmdsY29udGV4dGxvc3QiLCQsITEpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcigid2ViZ2xjb250ZXh0cmVzdG9yZWQiLGxlLCExKSx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoIndlYmdsY29udGV4dGNyZWF0aW9uZXJyb3IiLGFlLCExKSx1ZS5kaXNwb3NlKCksR2UuZGlzcG9zZSgpLE1lLmRpc3Bvc2UoKSx2LmRpc3Bvc2UoKSxJLmRpc3Bvc2UoKSxrLmRpc3Bvc2UoKSxLZS5kaXNwb3NlKCksUC5kaXNwb3NlKCksX2UuZGlzcG9zZSgpLEcuZGlzcG9zZSgpLEcucmVtb3ZlRXZlbnRMaXN0ZW5lcigic2Vzc2lvbnN0YXJ0IixIcyksRy5yZW1vdmVFdmVudExpc3RlbmVyKCJzZXNzaW9uZW5kIixWcyksdm4uc3RvcCgpfTtmdW5jdGlvbiAkKE0pe00ucHJldmVudERlZmF1bHQoKSxjb25zb2xlLmxvZygiVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBMb3N0LiIpLEM9ITB9ZnVuY3Rpb24gbGUoKXtjb25zb2xlLmxvZygiVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBSZXN0b3JlZC4iKSxDPSExO2NvbnN0IE09amUuYXV0b1Jlc2V0LEQ9aGUuZW5hYmxlZCxOPWhlLmF1dG9VcGRhdGUsQj1oZS5uZWVkc1VwZGF0ZSxMPWhlLnR5cGU7bmUoKSxqZS5hdXRvUmVzZXQ9TSxoZS5lbmFibGVkPUQsaGUuYXV0b1VwZGF0ZT1OLGhlLm5lZWRzVXBkYXRlPUIsaGUudHlwZT1MfWZ1bmN0aW9uIGFlKE0pe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXI6IEEgV2ViR0wgY29udGV4dCBjb3VsZCBub3QgYmUgY3JlYXRlZC4gUmVhc29uOiAiLE0uc3RhdHVzTWVzc2FnZSl9ZnVuY3Rpb24gUmUoTSl7Y29uc3QgRD1NLnRhcmdldDtELnJlbW92ZUV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLFJlKSxpdChEKX1mdW5jdGlvbiBpdChNKXttdChNKSxNZS5yZW1vdmUoTSl9ZnVuY3Rpb24gbXQoTSl7Y29uc3QgRD1NZS5nZXQoTSkucHJvZ3JhbXM7RCE9PXZvaWQgMCYmKEQuZm9yRWFjaChmdW5jdGlvbihOKXtfZS5yZWxlYXNlUHJvZ3JhbShOKX0pLE0uaXNTaGFkZXJNYXRlcmlhbCYmX2UucmVsZWFzZVNoYWRlckNhY2hlKE0pKX10aGlzLnJlbmRlckJ1ZmZlckRpcmVjdD1mdW5jdGlvbihNLEQsTixCLEwsSil7RD09PW51bGwmJihEPW50KTtjb25zdCBvZT1MLmlzTWVzaCYmTC5tYXRyaXhXb3JsZC5kZXRlcm1pbmFudCgpPDAsZmU9eGgoTSxELE4sQixMKTtTZS5zZXRNYXRlcmlhbChCLG9lKTtsZXQgcGU9Ti5pbmRleCxBZT0xO2lmKEIud2lyZWZyYW1lPT09ITApe2lmKHBlPUsuZ2V0V2lyZWZyYW1lQXR0cmlidXRlKE4pLHBlPT09dm9pZCAwKXJldHVybjtBZT0yfWNvbnN0IENlPU4uZHJhd1JhbmdlLG1lPU4uYXR0cmlidXRlcy5wb3NpdGlvbjtsZXQgSGU9Q2Uuc3RhcnQqQWUsWmU9KENlLnN0YXJ0K0NlLmNvdW50KSpBZTtKIT09bnVsbCYmKEhlPU1hdGgubWF4KEhlLEouc3RhcnQqQWUpLFplPU1hdGgubWluKFplLChKLnN0YXJ0K0ouY291bnQpKkFlKSkscGUhPT1udWxsPyhIZT1NYXRoLm1heChIZSwwKSxaZT1NYXRoLm1pbihaZSxwZS5jb3VudCkpOm1lIT1udWxsJiYoSGU9TWF0aC5tYXgoSGUsMCksWmU9TWF0aC5taW4oWmUsbWUuY291bnQpKTtjb25zdCBKZT1aZS1IZTtpZihKZTwwfHxKZT09PTEvMClyZXR1cm47S2Uuc2V0dXAoTCxCLGZlLE4scGUpO2xldCBFdCxrZT1kZTtpZihwZSE9PW51bGwmJihFdD1ZLmdldChwZSksa2U9T2Usa2Uuc2V0SW5kZXgoRXQpKSxMLmlzTWVzaClCLndpcmVmcmFtZT09PSEwPyhTZS5zZXRMaW5lV2lkdGgoQi53aXJlZnJhbWVMaW5ld2lkdGgqYXQoKSksa2Uuc2V0TW9kZShVLkxJTkVTKSk6a2Uuc2V0TW9kZShVLlRSSUFOR0xFUyk7ZWxzZSBpZihMLmlzTGluZSl7bGV0IHZlPUIubGluZXdpZHRoO3ZlPT09dm9pZCAwJiYodmU9MSksU2Uuc2V0TGluZVdpZHRoKHZlKmF0KCkpLEwuaXNMaW5lU2VnbWVudHM/a2Uuc2V0TW9kZShVLkxJTkVTKTpMLmlzTGluZUxvb3A/a2Uuc2V0TW9kZShVLkxJTkVfTE9PUCk6a2Uuc2V0TW9kZShVLkxJTkVfU1RSSVApfWVsc2UgTC5pc1BvaW50cz9rZS5zZXRNb2RlKFUuUE9JTlRTKTpMLmlzU3ByaXRlJiZrZS5zZXRNb2RlKFUuVFJJQU5HTEVTKTtpZihMLmlzQmF0Y2hlZE1lc2gpaWYoTC5fbXVsdGlEcmF3SW5zdGFuY2VzIT09bnVsbClrZS5yZW5kZXJNdWx0aURyYXdJbnN0YW5jZXMoTC5fbXVsdGlEcmF3U3RhcnRzLEwuX211bHRpRHJhd0NvdW50cyxMLl9tdWx0aURyYXdDb3VudCxMLl9tdWx0aURyYXdJbnN0YW5jZXMpO2Vsc2UgaWYoSWUuZ2V0KCJXRUJHTF9tdWx0aV9kcmF3Iikpa2UucmVuZGVyTXVsdGlEcmF3KEwuX211bHRpRHJhd1N0YXJ0cyxMLl9tdWx0aURyYXdDb3VudHMsTC5fbXVsdGlEcmF3Q291bnQpO2Vsc2V7Y29uc3QgdmU9TC5fbXVsdGlEcmF3U3RhcnRzLFp0PUwuX211bHRpRHJhd0NvdW50cyxXZT1MLl9tdWx0aURyYXdDb3VudCxCdD1wZT9ZLmdldChwZSkuYnl0ZXNQZXJFbGVtZW50OjEsR249TWUuZ2V0KEIpLmN1cnJlbnRQcm9ncmFtLmdldFVuaWZvcm1zKCk7Zm9yKGxldCB3dD0wO3d0PFdlO3d0KyspR24uc2V0VmFsdWUoVSwiX2dsX0RyYXdJRCIsd3QpLGtlLnJlbmRlcih2ZVt3dF0vQnQsWnRbd3RdKX1lbHNlIGlmKEwuaXNJbnN0YW5jZWRNZXNoKWtlLnJlbmRlckluc3RhbmNlcyhIZSxKZSxMLmNvdW50KTtlbHNlIGlmKE4uaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSl7Y29uc3QgdmU9Ti5fbWF4SW5zdGFuY2VDb3VudCE9PXZvaWQgMD9OLl9tYXhJbnN0YW5jZUNvdW50OjEvMCxadD1NYXRoLm1pbihOLmluc3RhbmNlQ291bnQsdmUpO2tlLnJlbmRlckluc3RhbmNlcyhIZSxKZSxadCl9ZWxzZSBrZS5yZW5kZXIoSGUsSmUpfTtmdW5jdGlvbiBYZShNLEQsTil7TS50cmFuc3BhcmVudD09PSEwJiZNLnNpZGU9PT0yJiZNLmZvcmNlU2luZ2xlUGFzcz09PSExPyhNLnNpZGU9MSxNLm5lZWRzVXBkYXRlPSEwLElpKE0sRCxOKSxNLnNpZGU9MCxNLm5lZWRzVXBkYXRlPSEwLElpKE0sRCxOKSxNLnNpZGU9Mik6SWkoTSxELE4pfXRoaXMuY29tcGlsZT1mdW5jdGlvbihNLEQsTj1udWxsKXtOPT09bnVsbCYmKE49TSksaD1HZS5nZXQoTiksaC5pbml0KEQpLHkucHVzaChoKSxOLnRyYXZlcnNlVmlzaWJsZShmdW5jdGlvbihMKXtMLmlzTGlnaHQmJkwubGF5ZXJzLnRlc3QoRC5sYXllcnMpJiYoaC5wdXNoTGlnaHQoTCksTC5jYXN0U2hhZG93JiZoLnB1c2hTaGFkb3coTCkpfSksTSE9PU4mJk0udHJhdmVyc2VWaXNpYmxlKGZ1bmN0aW9uKEwpe0wuaXNMaWdodCYmTC5sYXllcnMudGVzdChELmxheWVycykmJihoLnB1c2hMaWdodChMKSxMLmNhc3RTaGFkb3cmJmgucHVzaFNoYWRvdyhMKSl9KSxoLnNldHVwTGlnaHRzKCk7Y29uc3QgQj1uZXcgU2V0O3JldHVybiBNLnRyYXZlcnNlKGZ1bmN0aW9uKEwpe2lmKCEoTC5pc01lc2h8fEwuaXNQb2ludHN8fEwuaXNMaW5lfHxMLmlzU3ByaXRlKSlyZXR1cm47Y29uc3QgSj1MLm1hdGVyaWFsO2lmKEopaWYoQXJyYXkuaXNBcnJheShKKSlmb3IobGV0IG9lPTA7b2U8Si5sZW5ndGg7b2UrKyl7Y29uc3QgZmU9SltvZV07WGUoZmUsTixMKSxCLmFkZChmZSl9ZWxzZSBYZShKLE4sTCksQi5hZGQoSil9KSx5LnBvcCgpLGg9bnVsbCxCfSx0aGlzLmNvbXBpbGVBc3luYz1mdW5jdGlvbihNLEQsTj1udWxsKXtjb25zdCBCPXRoaXMuY29tcGlsZShNLEQsTik7cmV0dXJuIG5ldyBQcm9taXNlKEw9PntmdW5jdGlvbiBKKCl7aWYoQi5mb3JFYWNoKGZ1bmN0aW9uKG9lKXtNZS5nZXQob2UpLmN1cnJlbnRQcm9ncmFtLmlzUmVhZHkoKSYmQi5kZWxldGUob2UpfSksQi5zaXplPT09MCl7TChNKTtyZXR1cm59c2V0VGltZW91dChKLDEwKX1JZS5nZXQoIktIUl9wYXJhbGxlbF9zaGFkZXJfY29tcGlsZSIpIT09bnVsbD9KKCk6c2V0VGltZW91dChKLDEwKX0pfTtsZXQgT3Q9bnVsbDtmdW5jdGlvbiBLdChNKXtPdCYmT3QoTSl9ZnVuY3Rpb24gSHMoKXt2bi5zdG9wKCl9ZnVuY3Rpb24gVnMoKXt2bi5zdGFydCgpfWNvbnN0IHZuPW5ldyBlczt2bi5zZXRBbmltYXRpb25Mb29wKEt0KSx0eXBlb2Ygc2VsZjwidSImJnZuLnNldENvbnRleHQoc2VsZiksdGhpcy5zZXRBbmltYXRpb25Mb29wPWZ1bmN0aW9uKE0pe090PU0sRy5zZXRBbmltYXRpb25Mb29wKE0pLE09PT1udWxsP3ZuLnN0b3AoKTp2bi5zdGFydCgpfSxHLmFkZEV2ZW50TGlzdGVuZXIoInNlc3Npb25zdGFydCIsSHMpLEcuYWRkRXZlbnRMaXN0ZW5lcigic2Vzc2lvbmVuZCIsVnMpLHRoaXMucmVuZGVyPWZ1bmN0aW9uKE0sRCl7aWYoRCE9PXZvaWQgMCYmRC5pc0NhbWVyYSE9PSEwKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuIik7cmV0dXJufWlmKEM9PT0hMClyZXR1cm47aWYoTS5tYXRyaXhXb3JsZEF1dG9VcGRhdGU9PT0hMCYmTS51cGRhdGVNYXRyaXhXb3JsZCgpLEQucGFyZW50PT09bnVsbCYmRC5tYXRyaXhXb3JsZEF1dG9VcGRhdGU9PT0hMCYmRC51cGRhdGVNYXRyaXhXb3JsZCgpLEcuZW5hYmxlZD09PSEwJiZHLmlzUHJlc2VudGluZz09PSEwJiYoRy5jYW1lcmFBdXRvVXBkYXRlPT09ITAmJkcudXBkYXRlQ2FtZXJhKEQpLEQ9Ry5nZXRDYW1lcmEoKSksTS5pc1NjZW5lPT09ITAmJk0ub25CZWZvcmVSZW5kZXIoXyxNLEQsRiksaD1HZS5nZXQoTSx5Lmxlbmd0aCksaC5pbml0KEQpLHkucHVzaChoKSx5ZS5tdWx0aXBseU1hdHJpY2VzKEQucHJvamVjdGlvbk1hdHJpeCxELm1hdHJpeFdvcmxkSW52ZXJzZSksWC5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeCh5ZSksZ2U9dGhpcy5sb2NhbENsaXBwaW5nRW5hYmxlZCxlZT1qLmluaXQodGhpcy5jbGlwcGluZ1BsYW5lcyxnZSksbT11ZS5nZXQoTSxULmxlbmd0aCksbS5pbml0KCksVC5wdXNoKG0pLEcuZW5hYmxlZD09PSEwJiZHLmlzUHJlc2VudGluZz09PSEwKXtjb25zdCBKPV8ueHIuZ2V0RGVwdGhTZW5zaW5nTWVzaCgpO0ohPT1udWxsJiZ4cihKLEQsLTEvMCxfLnNvcnRPYmplY3RzKX14cihNLEQsMCxfLnNvcnRPYmplY3RzKSxtLmZpbmlzaCgpLF8uc29ydE9iamVjdHM9PT0hMCYmbS5zb3J0KGllLGNlKSx6ZT1HLmVuYWJsZWQ9PT0hMXx8Ry5pc1ByZXNlbnRpbmc9PT0hMXx8Ry5oYXNEZXB0aFNlbnNpbmcoKT09PSExLHplJiZFZS5hZGRUb1JlbmRlckxpc3QobSxNKSx0aGlzLmluZm8ucmVuZGVyLmZyYW1lKyssZWU9PT0hMCYmai5iZWdpblNoYWRvd3MoKTtjb25zdCBOPWguc3RhdGUuc2hhZG93c0FycmF5O2hlLnJlbmRlcihOLE0sRCksZWU9PT0hMCYmai5lbmRTaGFkb3dzKCksdGhpcy5pbmZvLmF1dG9SZXNldD09PSEwJiZ0aGlzLmluZm8ucmVzZXQoKTtjb25zdCBCPW0ub3BhcXVlLEw9bS50cmFuc21pc3NpdmU7aWYoaC5zZXR1cExpZ2h0cygpLEQuaXNBcnJheUNhbWVyYSl7Y29uc3QgSj1ELmNhbWVyYXM7aWYoTC5sZW5ndGg+MClmb3IobGV0IG9lPTAsZmU9Si5sZW5ndGg7b2U8ZmU7b2UrKyl7Y29uc3QgcGU9SltvZV07V3MoQixMLE0scGUpfXplJiZFZS5yZW5kZXIoTSk7Zm9yKGxldCBvZT0wLGZlPUoubGVuZ3RoO29lPGZlO29lKyspe2NvbnN0IHBlPUpbb2VdO2tzKG0sTSxwZSxwZS52aWV3cG9ydCl9fWVsc2UgTC5sZW5ndGg+MCYmV3MoQixMLE0sRCksemUmJkVlLnJlbmRlcihNKSxrcyhtLE0sRCk7RiE9PW51bGwmJihBLnVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0KEYpLEEudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKEYpKSxNLmlzU2NlbmU9PT0hMCYmTS5vbkFmdGVyUmVuZGVyKF8sTSxEKSxLZS5yZXNldERlZmF1bHRTdGF0ZSgpLEU9LTEsUz1udWxsLHkucG9wKCkseS5sZW5ndGg+MD8oaD15W3kubGVuZ3RoLTFdLGVlPT09ITAmJmouc2V0R2xvYmFsU3RhdGUoXy5jbGlwcGluZ1BsYW5lcyxoLnN0YXRlLmNhbWVyYSkpOmg9bnVsbCxULnBvcCgpLFQubGVuZ3RoPjA/bT1UW1QubGVuZ3RoLTFdOm09bnVsbH07ZnVuY3Rpb24geHIoTSxELE4sQil7aWYoTS52aXNpYmxlPT09ITEpcmV0dXJuO2lmKE0ubGF5ZXJzLnRlc3QoRC5sYXllcnMpKXtpZihNLmlzR3JvdXApTj1NLnJlbmRlck9yZGVyO2Vsc2UgaWYoTS5pc0xPRClNLmF1dG9VcGRhdGU9PT0hMCYmTS51cGRhdGUoRCk7ZWxzZSBpZihNLmlzTGlnaHQpaC5wdXNoTGlnaHQoTSksTS5jYXN0U2hhZG93JiZoLnB1c2hTaGFkb3coTSk7ZWxzZSBpZihNLmlzU3ByaXRlKXtpZighTS5mcnVzdHVtQ3VsbGVkfHxYLmludGVyc2VjdHNTcHJpdGUoTSkpe0ImJkZlLnNldEZyb21NYXRyaXhQb3NpdGlvbihNLm1hdHJpeFdvcmxkKS5hcHBseU1hdHJpeDQoeWUpO2NvbnN0IG9lPWsudXBkYXRlKE0pLGZlPU0ubWF0ZXJpYWw7ZmUudmlzaWJsZSYmbS5wdXNoKE0sb2UsZmUsTixGZS56LG51bGwpfX1lbHNlIGlmKChNLmlzTWVzaHx8TS5pc0xpbmV8fE0uaXNQb2ludHMpJiYoIU0uZnJ1c3R1bUN1bGxlZHx8WC5pbnRlcnNlY3RzT2JqZWN0KE0pKSl7Y29uc3Qgb2U9ay51cGRhdGUoTSksZmU9TS5tYXRlcmlhbDtpZihCJiYoTS5ib3VuZGluZ1NwaGVyZSE9PXZvaWQgMD8oTS5ib3VuZGluZ1NwaGVyZT09PW51bGwmJk0uY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksRmUuY29weShNLmJvdW5kaW5nU3BoZXJlLmNlbnRlcikpOihvZS5ib3VuZGluZ1NwaGVyZT09PW51bGwmJm9lLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLEZlLmNvcHkob2UuYm91bmRpbmdTcGhlcmUuY2VudGVyKSksRmUuYXBwbHlNYXRyaXg0KE0ubWF0cml4V29ybGQpLmFwcGx5TWF0cml4NCh5ZSkpLEFycmF5LmlzQXJyYXkoZmUpKXtjb25zdCBwZT1vZS5ncm91cHM7Zm9yKGxldCBBZT0wLENlPXBlLmxlbmd0aDtBZTxDZTtBZSsrKXtjb25zdCBtZT1wZVtBZV0sSGU9ZmVbbWUubWF0ZXJpYWxJbmRleF07SGUmJkhlLnZpc2libGUmJm0ucHVzaChNLG9lLEhlLE4sRmUueixtZSl9fWVsc2UgZmUudmlzaWJsZSYmbS5wdXNoKE0sb2UsZmUsTixGZS56LG51bGwpfX1jb25zdCBKPU0uY2hpbGRyZW47Zm9yKGxldCBvZT0wLGZlPUoubGVuZ3RoO29lPGZlO29lKyspeHIoSltvZV0sRCxOLEIpfWZ1bmN0aW9uIGtzKE0sRCxOLEIpe2NvbnN0IEw9TS5vcGFxdWUsSj1NLnRyYW5zbWlzc2l2ZSxvZT1NLnRyYW5zcGFyZW50O2guc2V0dXBMaWdodHNWaWV3KE4pLGVlPT09ITAmJmouc2V0R2xvYmFsU3RhdGUoXy5jbGlwcGluZ1BsYW5lcyxOKSxCJiZTZS52aWV3cG9ydChSLmNvcHkoQikpLEwubGVuZ3RoPjAmJkZpKEwsRCxOKSxKLmxlbmd0aD4wJiZGaShKLEQsTiksb2UubGVuZ3RoPjAmJkZpKG9lLEQsTiksU2UuYnVmZmVycy5kZXB0aC5zZXRUZXN0KCEwKSxTZS5idWZmZXJzLmRlcHRoLnNldE1hc2soITApLFNlLmJ1ZmZlcnMuY29sb3Iuc2V0TWFzayghMCksU2Uuc2V0UG9seWdvbk9mZnNldCghMSl9ZnVuY3Rpb24gV3MoTSxELE4sQil7aWYoKE4uaXNTY2VuZT09PSEwP04ub3ZlcnJpZGVNYXRlcmlhbDpudWxsKSE9PW51bGwpcmV0dXJuO2guc3RhdGUudHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0W0IuaWRdPT09dm9pZCAwJiYoaC5zdGF0ZS50cmFuc21pc3Npb25SZW5kZXJUYXJnZXRbQi5pZF09bmV3IEp0KDEsMSx7Z2VuZXJhdGVNaXBtYXBzOiEwLHR5cGU6SWUuaGFzKCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQiKXx8SWUuaGFzKCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0Iik/MTAxNjoxMDA5LG1pbkZpbHRlcjoxMDA4LHNhbXBsZXM6NCxzdGVuY2lsQnVmZmVyOnMscmVzb2x2ZURlcHRoQnVmZmVyOiExLHJlc29sdmVTdGVuY2lsQnVmZmVyOiExLGNvbG9yU3BhY2U6QmUud29ya2luZ0NvbG9yU3BhY2V9KSk7Y29uc3QgSj1oLnN0YXRlLnRyYW5zbWlzc2lvblJlbmRlclRhcmdldFtCLmlkXSxvZT1CLnZpZXdwb3J0fHxSO0ouc2V0U2l6ZShvZS56LG9lLncpO2NvbnN0IGZlPV8uZ2V0UmVuZGVyVGFyZ2V0KCk7Xy5zZXRSZW5kZXJUYXJnZXQoSiksXy5nZXRDbGVhckNvbG9yKFcpLFo9Xy5nZXRDbGVhckFscGhhKCksWjwxJiZfLnNldENsZWFyQ29sb3IoMTY3NzcyMTUsLjUpLF8uY2xlYXIoKSx6ZSYmRWUucmVuZGVyKE4pO2NvbnN0IHBlPV8udG9uZU1hcHBpbmc7Xy50b25lTWFwcGluZz0wO2NvbnN0IEFlPUIudmlld3BvcnQ7aWYoQi52aWV3cG9ydCE9PXZvaWQgMCYmKEIudmlld3BvcnQ9dm9pZCAwKSxoLnNldHVwTGlnaHRzVmlldyhCKSxlZT09PSEwJiZqLnNldEdsb2JhbFN0YXRlKF8uY2xpcHBpbmdQbGFuZXMsQiksRmkoTSxOLEIpLEEudXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQoSiksQS51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoSiksSWUuaGFzKCJXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUiKT09PSExKXtsZXQgQ2U9ITE7Zm9yKGxldCBtZT0wLEhlPUQubGVuZ3RoO21lPEhlO21lKyspe2NvbnN0IFplPURbbWVdLEplPVplLm9iamVjdCxFdD1aZS5nZW9tZXRyeSxrZT1aZS5tYXRlcmlhbCx2ZT1aZS5ncm91cDtpZihrZS5zaWRlPT09MiYmSmUubGF5ZXJzLnRlc3QoQi5sYXllcnMpKXtjb25zdCBadD1rZS5zaWRlO2tlLnNpZGU9MSxrZS5uZWVkc1VwZGF0ZT0hMCxYcyhKZSxOLEIsRXQsa2UsdmUpLGtlLnNpZGU9WnQsa2UubmVlZHNVcGRhdGU9ITAsQ2U9ITB9fUNlPT09ITAmJihBLnVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0KEopLEEudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKEopKX1fLnNldFJlbmRlclRhcmdldChmZSksXy5zZXRDbGVhckNvbG9yKFcsWiksQWUhPT12b2lkIDAmJihCLnZpZXdwb3J0PUFlKSxfLnRvbmVNYXBwaW5nPXBlfWZ1bmN0aW9uIEZpKE0sRCxOKXtjb25zdCBCPUQuaXNTY2VuZT09PSEwP0Qub3ZlcnJpZGVNYXRlcmlhbDpudWxsO2ZvcihsZXQgTD0wLEo9TS5sZW5ndGg7TDxKO0wrKyl7Y29uc3Qgb2U9TVtMXSxmZT1vZS5vYmplY3QscGU9b2UuZ2VvbWV0cnksQWU9Qj09PW51bGw/b2UubWF0ZXJpYWw6QixDZT1vZS5ncm91cDtmZS5sYXllcnMudGVzdChOLmxheWVycykmJlhzKGZlLEQsTixwZSxBZSxDZSl9fWZ1bmN0aW9uIFhzKE0sRCxOLEIsTCxKKXtNLm9uQmVmb3JlUmVuZGVyKF8sRCxOLEIsTCxKKSxNLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKE4ubWF0cml4V29ybGRJbnZlcnNlLE0ubWF0cml4V29ybGQpLE0ubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeChNLm1vZGVsVmlld01hdHJpeCksTC5vbkJlZm9yZVJlbmRlcihfLEQsTixCLE0sSiksTC50cmFuc3BhcmVudD09PSEwJiZMLnNpZGU9PT0yJiZMLmZvcmNlU2luZ2xlUGFzcz09PSExPyhMLnNpZGU9MSxMLm5lZWRzVXBkYXRlPSEwLF8ucmVuZGVyQnVmZmVyRGlyZWN0KE4sRCxCLEwsTSxKKSxMLnNpZGU9MCxMLm5lZWRzVXBkYXRlPSEwLF8ucmVuZGVyQnVmZmVyRGlyZWN0KE4sRCxCLEwsTSxKKSxMLnNpZGU9Mik6Xy5yZW5kZXJCdWZmZXJEaXJlY3QoTixELEIsTCxNLEopLE0ub25BZnRlclJlbmRlcihfLEQsTixCLEwsSil9ZnVuY3Rpb24gSWkoTSxELE4pe0QuaXNTY2VuZSE9PSEwJiYoRD1udCk7Y29uc3QgQj1NZS5nZXQoTSksTD1oLnN0YXRlLmxpZ2h0cyxKPWguc3RhdGUuc2hhZG93c0FycmF5LG9lPUwuc3RhdGUudmVyc2lvbixmZT1fZS5nZXRQYXJhbWV0ZXJzKE0sTC5zdGF0ZSxKLEQsTikscGU9X2UuZ2V0UHJvZ3JhbUNhY2hlS2V5KGZlKTtsZXQgQWU9Qi5wcm9ncmFtcztCLmVudmlyb25tZW50PU0uaXNNZXNoU3RhbmRhcmRNYXRlcmlhbD9ELmVudmlyb25tZW50Om51bGwsQi5mb2c9RC5mb2csQi5lbnZNYXA9KE0uaXNNZXNoU3RhbmRhcmRNYXRlcmlhbD9JOnYpLmdldChNLmVudk1hcHx8Qi5lbnZpcm9ubWVudCksQi5lbnZNYXBSb3RhdGlvbj1CLmVudmlyb25tZW50IT09bnVsbCYmTS5lbnZNYXA9PT1udWxsP0QuZW52aXJvbm1lbnRSb3RhdGlvbjpNLmVudk1hcFJvdGF0aW9uLEFlPT09dm9pZCAwJiYoTS5hZGRFdmVudExpc3RlbmVyKCJkaXNwb3NlIixSZSksQWU9bmV3IE1hcCxCLnByb2dyYW1zPUFlKTtsZXQgQ2U9QWUuZ2V0KHBlKTtpZihDZSE9PXZvaWQgMCl7aWYoQi5jdXJyZW50UHJvZ3JhbT09PUNlJiZCLmxpZ2h0c1N0YXRlVmVyc2lvbj09PW9lKXJldHVybiBZcyhNLGZlKSxDZX1lbHNlIGZlLnVuaWZvcm1zPV9lLmdldFVuaWZvcm1zKE0pLE0ub25CZWZvcmVDb21waWxlKGZlLF8pLENlPV9lLmFjcXVpcmVQcm9ncmFtKGZlLHBlKSxBZS5zZXQocGUsQ2UpLEIudW5pZm9ybXM9ZmUudW5pZm9ybXM7Y29uc3QgbWU9Qi51bmlmb3JtcztyZXR1cm4oIU0uaXNTaGFkZXJNYXRlcmlhbCYmIU0uaXNSYXdTaGFkZXJNYXRlcmlhbHx8TS5jbGlwcGluZz09PSEwKSYmKG1lLmNsaXBwaW5nUGxhbmVzPWoudW5pZm9ybSksWXMoTSxmZSksQi5uZWVkc0xpZ2h0cz1TaChNKSxCLmxpZ2h0c1N0YXRlVmVyc2lvbj1vZSxCLm5lZWRzTGlnaHRzJiYobWUuYW1iaWVudExpZ2h0Q29sb3IudmFsdWU9TC5zdGF0ZS5hbWJpZW50LG1lLmxpZ2h0UHJvYmUudmFsdWU9TC5zdGF0ZS5wcm9iZSxtZS5kaXJlY3Rpb25hbExpZ2h0cy52YWx1ZT1MLnN0YXRlLmRpcmVjdGlvbmFsLG1lLmRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzLnZhbHVlPUwuc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3csbWUuc3BvdExpZ2h0cy52YWx1ZT1MLnN0YXRlLnNwb3QsbWUuc3BvdExpZ2h0U2hhZG93cy52YWx1ZT1MLnN0YXRlLnNwb3RTaGFkb3csbWUucmVjdEFyZWFMaWdodHMudmFsdWU9TC5zdGF0ZS5yZWN0QXJlYSxtZS5sdGNfMS52YWx1ZT1MLnN0YXRlLnJlY3RBcmVhTFRDMSxtZS5sdGNfMi52YWx1ZT1MLnN0YXRlLnJlY3RBcmVhTFRDMixtZS5wb2ludExpZ2h0cy52YWx1ZT1MLnN0YXRlLnBvaW50LG1lLnBvaW50TGlnaHRTaGFkb3dzLnZhbHVlPUwuc3RhdGUucG9pbnRTaGFkb3csbWUuaGVtaXNwaGVyZUxpZ2h0cy52YWx1ZT1MLnN0YXRlLmhlbWksbWUuZGlyZWN0aW9uYWxTaGFkb3dNYXAudmFsdWU9TC5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcCxtZS5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeC52YWx1ZT1MLnN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4LG1lLnNwb3RTaGFkb3dNYXAudmFsdWU9TC5zdGF0ZS5zcG90U2hhZG93TWFwLG1lLnNwb3RMaWdodE1hdHJpeC52YWx1ZT1MLnN0YXRlLnNwb3RMaWdodE1hdHJpeCxtZS5zcG90TGlnaHRNYXAudmFsdWU9TC5zdGF0ZS5zcG90TGlnaHRNYXAsbWUucG9pbnRTaGFkb3dNYXAudmFsdWU9TC5zdGF0ZS5wb2ludFNoYWRvd01hcCxtZS5wb2ludFNoYWRvd01hdHJpeC52YWx1ZT1MLnN0YXRlLnBvaW50U2hhZG93TWF0cml4KSxCLmN1cnJlbnRQcm9ncmFtPUNlLEIudW5pZm9ybXNMaXN0PW51bGwsQ2V9ZnVuY3Rpb24gcXMoTSl7aWYoTS51bmlmb3Jtc0xpc3Q9PT1udWxsKXtjb25zdCBEPU0uY3VycmVudFByb2dyYW0uZ2V0VW5pZm9ybXMoKTtNLnVuaWZvcm1zTGlzdD13aS5zZXFXaXRoVmFsdWUoRC5zZXEsTS51bmlmb3Jtcyl9cmV0dXJuIE0udW5pZm9ybXNMaXN0fWZ1bmN0aW9uIFlzKE0sRCl7Y29uc3QgTj1NZS5nZXQoTSk7Ti5vdXRwdXRDb2xvclNwYWNlPUQub3V0cHV0Q29sb3JTcGFjZSxOLmJhdGNoaW5nPUQuYmF0Y2hpbmcsTi5iYXRjaGluZ0NvbG9yPUQuYmF0Y2hpbmdDb2xvcixOLmluc3RhbmNpbmc9RC5pbnN0YW5jaW5nLE4uaW5zdGFuY2luZ0NvbG9yPUQuaW5zdGFuY2luZ0NvbG9yLE4uaW5zdGFuY2luZ01vcnBoPUQuaW5zdGFuY2luZ01vcnBoLE4uc2tpbm5pbmc9RC5za2lubmluZyxOLm1vcnBoVGFyZ2V0cz1ELm1vcnBoVGFyZ2V0cyxOLm1vcnBoTm9ybWFscz1ELm1vcnBoTm9ybWFscyxOLm1vcnBoQ29sb3JzPUQubW9ycGhDb2xvcnMsTi5tb3JwaFRhcmdldHNDb3VudD1ELm1vcnBoVGFyZ2V0c0NvdW50LE4ubnVtQ2xpcHBpbmdQbGFuZXM9RC5udW1DbGlwcGluZ1BsYW5lcyxOLm51bUludGVyc2VjdGlvbj1ELm51bUNsaXBJbnRlcnNlY3Rpb24sTi52ZXJ0ZXhBbHBoYXM9RC52ZXJ0ZXhBbHBoYXMsTi52ZXJ0ZXhUYW5nZW50cz1ELnZlcnRleFRhbmdlbnRzLE4udG9uZU1hcHBpbmc9RC50b25lTWFwcGluZ31mdW5jdGlvbiB4aChNLEQsTixCLEwpe0QuaXNTY2VuZSE9PSEwJiYoRD1udCksQS5yZXNldFRleHR1cmVVbml0cygpO2NvbnN0IEo9RC5mb2csb2U9Qi5pc01lc2hTdGFuZGFyZE1hdGVyaWFsP0QuZW52aXJvbm1lbnQ6bnVsbCxmZT1GPT09bnVsbD9fLm91dHB1dENvbG9yU3BhY2U6Ri5pc1hSUmVuZGVyVGFyZ2V0PT09ITA/Ri50ZXh0dXJlLmNvbG9yU3BhY2U6eG4scGU9KEIuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbD9JOnYpLmdldChCLmVudk1hcHx8b2UpLEFlPUIudmVydGV4Q29sb3JzPT09ITAmJiEhTi5hdHRyaWJ1dGVzLmNvbG9yJiZOLmF0dHJpYnV0ZXMuY29sb3IuaXRlbVNpemU9PT00LENlPSEhTi5hdHRyaWJ1dGVzLnRhbmdlbnQmJighIUIubm9ybWFsTWFwfHxCLmFuaXNvdHJvcHk+MCksbWU9ISFOLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbixIZT0hIU4ubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCxaZT0hIU4ubW9ycGhBdHRyaWJ1dGVzLmNvbG9yO2xldCBKZT0wO0IudG9uZU1hcHBlZCYmKEY9PT1udWxsfHxGLmlzWFJSZW5kZXJUYXJnZXQ9PT0hMCkmJihKZT1fLnRvbmVNYXBwaW5nKTtjb25zdCBFdD1OLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbnx8Ti5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsfHxOLm1vcnBoQXR0cmlidXRlcy5jb2xvcixrZT1FdCE9PXZvaWQgMD9FdC5sZW5ndGg6MCx2ZT1NZS5nZXQoQiksWnQ9aC5zdGF0ZS5saWdodHM7aWYoZWU9PT0hMCYmKGdlPT09ITB8fE0hPT1TKSl7Y29uc3QgRHQ9TT09PVMmJkIuaWQ9PT1FO2ouc2V0U3RhdGUoQixNLER0KX1sZXQgV2U9ITE7Qi52ZXJzaW9uPT09dmUuX192ZXJzaW9uPyh2ZS5uZWVkc0xpZ2h0cyYmdmUubGlnaHRzU3RhdGVWZXJzaW9uIT09WnQuc3RhdGUudmVyc2lvbnx8dmUub3V0cHV0Q29sb3JTcGFjZSE9PWZlfHxMLmlzQmF0Y2hlZE1lc2gmJnZlLmJhdGNoaW5nPT09ITF8fCFMLmlzQmF0Y2hlZE1lc2gmJnZlLmJhdGNoaW5nPT09ITB8fEwuaXNCYXRjaGVkTWVzaCYmdmUuYmF0Y2hpbmdDb2xvcj09PSEwJiZMLmNvbG9yVGV4dHVyZT09PW51bGx8fEwuaXNCYXRjaGVkTWVzaCYmdmUuYmF0Y2hpbmdDb2xvcj09PSExJiZMLmNvbG9yVGV4dHVyZSE9PW51bGx8fEwuaXNJbnN0YW5jZWRNZXNoJiZ2ZS5pbnN0YW5jaW5nPT09ITF8fCFMLmlzSW5zdGFuY2VkTWVzaCYmdmUuaW5zdGFuY2luZz09PSEwfHxMLmlzU2tpbm5lZE1lc2gmJnZlLnNraW5uaW5nPT09ITF8fCFMLmlzU2tpbm5lZE1lc2gmJnZlLnNraW5uaW5nPT09ITB8fEwuaXNJbnN0YW5jZWRNZXNoJiZ2ZS5pbnN0YW5jaW5nQ29sb3I9PT0hMCYmTC5pbnN0YW5jZUNvbG9yPT09bnVsbHx8TC5pc0luc3RhbmNlZE1lc2gmJnZlLmluc3RhbmNpbmdDb2xvcj09PSExJiZMLmluc3RhbmNlQ29sb3IhPT1udWxsfHxMLmlzSW5zdGFuY2VkTWVzaCYmdmUuaW5zdGFuY2luZ01vcnBoPT09ITAmJkwubW9ycGhUZXh0dXJlPT09bnVsbHx8TC5pc0luc3RhbmNlZE1lc2gmJnZlLmluc3RhbmNpbmdNb3JwaD09PSExJiZMLm1vcnBoVGV4dHVyZSE9PW51bGx8fHZlLmVudk1hcCE9PXBlfHxCLmZvZz09PSEwJiZ2ZS5mb2chPT1KfHx2ZS5udW1DbGlwcGluZ1BsYW5lcyE9PXZvaWQgMCYmKHZlLm51bUNsaXBwaW5nUGxhbmVzIT09ai5udW1QbGFuZXN8fHZlLm51bUludGVyc2VjdGlvbiE9PWoubnVtSW50ZXJzZWN0aW9uKXx8dmUudmVydGV4QWxwaGFzIT09QWV8fHZlLnZlcnRleFRhbmdlbnRzIT09Q2V8fHZlLm1vcnBoVGFyZ2V0cyE9PW1lfHx2ZS5tb3JwaE5vcm1hbHMhPT1IZXx8dmUubW9ycGhDb2xvcnMhPT1aZXx8dmUudG9uZU1hcHBpbmchPT1KZXx8dmUubW9ycGhUYXJnZXRzQ291bnQhPT1rZSkmJihXZT0hMCk6KFdlPSEwLHZlLl9fdmVyc2lvbj1CLnZlcnNpb24pO2xldCBCdD12ZS5jdXJyZW50UHJvZ3JhbTtXZT09PSEwJiYoQnQ9SWkoQixELEwpKTtsZXQgR249ITEsd3Q9ITEsdGk9ITE7Y29uc3QgUWU9QnQuZ2V0VW5pZm9ybXMoKSxIdD12ZS51bmlmb3JtcztpZihTZS51c2VQcm9ncmFtKEJ0LnByb2dyYW0pJiYoR249ITAsd3Q9ITAsdGk9ITApLEIuaWQhPT1FJiYoRT1CLmlkLHd0PSEwKSxHbnx8UyE9PU0pe1NlLmJ1ZmZlcnMuZGVwdGguZ2V0UmV2ZXJzZWQoKT8ocmUuY29weShNLnByb2plY3Rpb25NYXRyaXgpLGZhKHJlKSxwYShyZSksUWUuc2V0VmFsdWUoVSwicHJvamVjdGlvbk1hdHJpeCIscmUpKTpRZS5zZXRWYWx1ZShVLCJwcm9qZWN0aW9uTWF0cml4IixNLnByb2plY3Rpb25NYXRyaXgpLFFlLnNldFZhbHVlKFUsInZpZXdNYXRyaXgiLE0ubWF0cml4V29ybGRJbnZlcnNlKTtjb25zdCBhbj1RZS5tYXAuY2FtZXJhUG9zaXRpb247YW4hPT12b2lkIDAmJmFuLnNldFZhbHVlKFUsd2Uuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKE0ubWF0cml4V29ybGQpKSxOZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyJiZRZS5zZXRWYWx1ZShVLCJsb2dEZXB0aEJ1ZkZDIiwyLyhNYXRoLmxvZyhNLmZhcisxKS9NYXRoLkxOMikpLChCLmlzTWVzaFBob25nTWF0ZXJpYWx8fEIuaXNNZXNoVG9vbk1hdGVyaWFsfHxCLmlzTWVzaExhbWJlcnRNYXRlcmlhbHx8Qi5pc01lc2hCYXNpY01hdGVyaWFsfHxCLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWx8fEIuaXNTaGFkZXJNYXRlcmlhbCkmJlFlLnNldFZhbHVlKFUsImlzT3J0aG9ncmFwaGljIixNLmlzT3J0aG9ncmFwaGljQ2FtZXJhPT09ITApLFMhPT1NJiYoUz1NLHd0PSEwLHRpPSEwKX1pZihMLmlzU2tpbm5lZE1lc2gpe1FlLnNldE9wdGlvbmFsKFUsTCwiYmluZE1hdHJpeCIpLFFlLnNldE9wdGlvbmFsKFUsTCwiYmluZE1hdHJpeEludmVyc2UiKTtjb25zdCBEdD1MLnNrZWxldG9uO0R0JiYoRHQuYm9uZVRleHR1cmU9PT1udWxsJiZEdC5jb21wdXRlQm9uZVRleHR1cmUoKSxRZS5zZXRWYWx1ZShVLCJib25lVGV4dHVyZSIsRHQuYm9uZVRleHR1cmUsQSkpfUwuaXNCYXRjaGVkTWVzaCYmKFFlLnNldE9wdGlvbmFsKFUsTCwiYmF0Y2hpbmdUZXh0dXJlIiksUWUuc2V0VmFsdWUoVSwiYmF0Y2hpbmdUZXh0dXJlIixMLl9tYXRyaWNlc1RleHR1cmUsQSksUWUuc2V0T3B0aW9uYWwoVSxMLCJiYXRjaGluZ0lkVGV4dHVyZSIpLFFlLnNldFZhbHVlKFUsImJhdGNoaW5nSWRUZXh0dXJlIixMLl9pbmRpcmVjdFRleHR1cmUsQSksUWUuc2V0T3B0aW9uYWwoVSxMLCJiYXRjaGluZ0NvbG9yVGV4dHVyZSIpLEwuX2NvbG9yc1RleHR1cmUhPT1udWxsJiZRZS5zZXRWYWx1ZShVLCJiYXRjaGluZ0NvbG9yVGV4dHVyZSIsTC5fY29sb3JzVGV4dHVyZSxBKSk7Y29uc3Qgbmk9Ti5tb3JwaEF0dHJpYnV0ZXM7aWYoKG5pLnBvc2l0aW9uIT09dm9pZCAwfHxuaS5ub3JtYWwhPT12b2lkIDB8fG5pLmNvbG9yIT09dm9pZCAwKSYmVGUudXBkYXRlKEwsTixCdCksKHd0fHx2ZS5yZWNlaXZlU2hhZG93IT09TC5yZWNlaXZlU2hhZG93KSYmKHZlLnJlY2VpdmVTaGFkb3c9TC5yZWNlaXZlU2hhZG93LFFlLnNldFZhbHVlKFUsInJlY2VpdmVTaGFkb3ciLEwucmVjZWl2ZVNoYWRvdykpLEIuaXNNZXNoR291cmF1ZE1hdGVyaWFsJiZCLmVudk1hcCE9PW51bGwmJihIdC5lbnZNYXAudmFsdWU9cGUsSHQuZmxpcEVudk1hcC52YWx1ZT1wZS5pc0N1YmVUZXh0dXJlJiZwZS5pc1JlbmRlclRhcmdldFRleHR1cmU9PT0hMT8tMToxKSxCLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwmJkIuZW52TWFwPT09bnVsbCYmRC5lbnZpcm9ubWVudCE9PW51bGwmJihIdC5lbnZNYXBJbnRlbnNpdHkudmFsdWU9RC5lbnZpcm9ubWVudEludGVuc2l0eSksd3QmJihRZS5zZXRWYWx1ZShVLCJ0b25lTWFwcGluZ0V4cG9zdXJlIixfLnRvbmVNYXBwaW5nRXhwb3N1cmUpLHZlLm5lZWRzTGlnaHRzJiZNaChIdCx0aSksSiYmQi5mb2c9PT0hMCYmc2UucmVmcmVzaEZvZ1VuaWZvcm1zKEh0LEopLHNlLnJlZnJlc2hNYXRlcmlhbFVuaWZvcm1zKEh0LEIsSCxRLGguc3RhdGUudHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0W00uaWRdKSx3aS51cGxvYWQoVSxxcyh2ZSksSHQsQSkpLEIuaXNTaGFkZXJNYXRlcmlhbCYmQi51bmlmb3Jtc05lZWRVcGRhdGU9PT0hMCYmKHdpLnVwbG9hZChVLHFzKHZlKSxIdCxBKSxCLnVuaWZvcm1zTmVlZFVwZGF0ZT0hMSksQi5pc1Nwcml0ZU1hdGVyaWFsJiZRZS5zZXRWYWx1ZShVLCJjZW50ZXIiLEwuY2VudGVyKSxRZS5zZXRWYWx1ZShVLCJtb2RlbFZpZXdNYXRyaXgiLEwubW9kZWxWaWV3TWF0cml4KSxRZS5zZXRWYWx1ZShVLCJub3JtYWxNYXRyaXgiLEwubm9ybWFsTWF0cml4KSxRZS5zZXRWYWx1ZShVLCJtb2RlbE1hdHJpeCIsTC5tYXRyaXhXb3JsZCksQi5pc1NoYWRlck1hdGVyaWFsfHxCLmlzUmF3U2hhZGVyTWF0ZXJpYWwpe2NvbnN0IER0PUIudW5pZm9ybXNHcm91cHM7Zm9yKGxldCBhbj0wLG9uPUR0Lmxlbmd0aDthbjxvbjthbisrKXtjb25zdCAkcz1EdFthbl07UC51cGRhdGUoJHMsQnQpLFAuYmluZCgkcyxCdCl9fXJldHVybiBCdH1mdW5jdGlvbiBNaChNLEQpe00uYW1iaWVudExpZ2h0Q29sb3IubmVlZHNVcGRhdGU9RCxNLmxpZ2h0UHJvYmUubmVlZHNVcGRhdGU9RCxNLmRpcmVjdGlvbmFsTGlnaHRzLm5lZWRzVXBkYXRlPUQsTS5kaXJlY3Rpb25hbExpZ2h0U2hhZG93cy5uZWVkc1VwZGF0ZT1ELE0ucG9pbnRMaWdodHMubmVlZHNVcGRhdGU9RCxNLnBvaW50TGlnaHRTaGFkb3dzLm5lZWRzVXBkYXRlPUQsTS5zcG90TGlnaHRzLm5lZWRzVXBkYXRlPUQsTS5zcG90TGlnaHRTaGFkb3dzLm5lZWRzVXBkYXRlPUQsTS5yZWN0QXJlYUxpZ2h0cy5uZWVkc1VwZGF0ZT1ELE0uaGVtaXNwaGVyZUxpZ2h0cy5uZWVkc1VwZGF0ZT1EfWZ1bmN0aW9uIFNoKE0pe3JldHVybiBNLmlzTWVzaExhbWJlcnRNYXRlcmlhbHx8TS5pc01lc2hUb29uTWF0ZXJpYWx8fE0uaXNNZXNoUGhvbmdNYXRlcmlhbHx8TS5pc01lc2hTdGFuZGFyZE1hdGVyaWFsfHxNLmlzU2hhZG93TWF0ZXJpYWx8fE0uaXNTaGFkZXJNYXRlcmlhbCYmTS5saWdodHM9PT0hMH10aGlzLmdldEFjdGl2ZUN1YmVGYWNlPWZ1bmN0aW9uKCl7cmV0dXJuIHd9LHRoaXMuZ2V0QWN0aXZlTWlwbWFwTGV2ZWw9ZnVuY3Rpb24oKXtyZXR1cm4gYn0sdGhpcy5nZXRSZW5kZXJUYXJnZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gRn0sdGhpcy5zZXRSZW5kZXJUYXJnZXRUZXh0dXJlcz1mdW5jdGlvbihNLEQsTil7TWUuZ2V0KE0udGV4dHVyZSkuX193ZWJnbFRleHR1cmU9RCxNZS5nZXQoTS5kZXB0aFRleHR1cmUpLl9fd2ViZ2xUZXh0dXJlPU47Y29uc3QgQj1NZS5nZXQoTSk7Qi5fX2hhc0V4dGVybmFsVGV4dHVyZXM9ITAsQi5fX2F1dG9BbGxvY2F0ZURlcHRoQnVmZmVyPU49PT12b2lkIDAsQi5fX2F1dG9BbGxvY2F0ZURlcHRoQnVmZmVyfHxJZS5oYXMoIldFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZSIpPT09ITAmJihjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IFJlbmRlci10by10ZXh0dXJlIGV4dGVuc2lvbiB3YXMgZGlzYWJsZWQgYmVjYXVzZSBhbiBleHRlcm5hbCB0ZXh0dXJlIHdhcyBwcm92aWRlZCIpLEIuX191c2VSZW5kZXJUb1RleHR1cmU9ITEpfSx0aGlzLnNldFJlbmRlclRhcmdldEZyYW1lYnVmZmVyPWZ1bmN0aW9uKE0sRCl7Y29uc3QgTj1NZS5nZXQoTSk7Ti5fX3dlYmdsRnJhbWVidWZmZXI9RCxOLl9fdXNlRGVmYXVsdEZyYW1lYnVmZmVyPUQ9PT12b2lkIDB9LHRoaXMuc2V0UmVuZGVyVGFyZ2V0PWZ1bmN0aW9uKE0sRD0wLE49MCl7Rj1NLHc9RCxiPU47bGV0IEI9ITAsTD1udWxsLEo9ITEsb2U9ITE7aWYoTSl7Y29uc3QgcGU9TWUuZ2V0KE0pO2lmKHBlLl9fdXNlRGVmYXVsdEZyYW1lYnVmZmVyIT09dm9pZCAwKVNlLmJpbmRGcmFtZWJ1ZmZlcihVLkZSQU1FQlVGRkVSLG51bGwpLEI9ITE7ZWxzZSBpZihwZS5fX3dlYmdsRnJhbWVidWZmZXI9PT12b2lkIDApQS5zZXR1cFJlbmRlclRhcmdldChNKTtlbHNlIGlmKHBlLl9faGFzRXh0ZXJuYWxUZXh0dXJlcylBLnJlYmluZFRleHR1cmVzKE0sTWUuZ2V0KE0udGV4dHVyZSkuX193ZWJnbFRleHR1cmUsTWUuZ2V0KE0uZGVwdGhUZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSk7ZWxzZSBpZihNLmRlcHRoQnVmZmVyKXtjb25zdCBtZT1NLmRlcHRoVGV4dHVyZTtpZihwZS5fX2JvdW5kRGVwdGhUZXh0dXJlIT09bWUpe2lmKG1lIT09bnVsbCYmTWUuaGFzKG1lKSYmKE0ud2lkdGghPT1tZS5pbWFnZS53aWR0aHx8TS5oZWlnaHQhPT1tZS5pbWFnZS5oZWlnaHQpKXRocm93IG5ldyBFcnJvcigiV2ViR0xSZW5kZXJUYXJnZXQ6IEF0dGFjaGVkIERlcHRoVGV4dHVyZSBpcyBpbml0aWFsaXplZCB0byB0aGUgaW5jb3JyZWN0IHNpemUuIik7QS5zZXR1cERlcHRoUmVuZGVyYnVmZmVyKE0pfX1jb25zdCBBZT1NLnRleHR1cmU7KEFlLmlzRGF0YTNEVGV4dHVyZXx8QWUuaXNEYXRhQXJyYXlUZXh0dXJlfHxBZS5pc0NvbXByZXNzZWRBcnJheVRleHR1cmUpJiYob2U9ITApO2NvbnN0IENlPU1lLmdldChNKS5fX3dlYmdsRnJhbWVidWZmZXI7TS5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldD8oQXJyYXkuaXNBcnJheShDZVtEXSk/TD1DZVtEXVtOXTpMPUNlW0RdLEo9ITApOk0uc2FtcGxlcz4wJiZBLnVzZU11bHRpc2FtcGxlZFJUVChNKT09PSExP0w9TWUuZ2V0KE0pLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcjpBcnJheS5pc0FycmF5KENlKT9MPUNlW05dOkw9Q2UsUi5jb3B5KE0udmlld3BvcnQpLHEuY29weShNLnNjaXNzb3IpLHo9TS5zY2lzc29yVGVzdH1lbHNlIFIuY29weSh4ZSkubXVsdGlwbHlTY2FsYXIoSCkuZmxvb3IoKSxxLmNvcHkoVWUpLm11bHRpcGx5U2NhbGFyKEgpLmZsb29yKCksej1ZZTtpZihTZS5iaW5kRnJhbWVidWZmZXIoVS5GUkFNRUJVRkZFUixMKSYmQiYmU2UuZHJhd0J1ZmZlcnMoTSxMKSxTZS52aWV3cG9ydChSKSxTZS5zY2lzc29yKHEpLFNlLnNldFNjaXNzb3JUZXN0KHopLEope2NvbnN0IHBlPU1lLmdldChNLnRleHR1cmUpO1UuZnJhbWVidWZmZXJUZXh0dXJlMkQoVS5GUkFNRUJVRkZFUixVLkNPTE9SX0FUVEFDSE1FTlQwLFUuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YK0QscGUuX193ZWJnbFRleHR1cmUsTil9ZWxzZSBpZihvZSl7Y29uc3QgcGU9TWUuZ2V0KE0udGV4dHVyZSksQWU9RHx8MDtVLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyKFUuRlJBTUVCVUZGRVIsVS5DT0xPUl9BVFRBQ0hNRU5UMCxwZS5fX3dlYmdsVGV4dHVyZSxOfHwwLEFlKX1FPS0xfSx0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM9ZnVuY3Rpb24oTSxELE4sQixMLEosb2Upe2lmKCEoTSYmTS5pc1dlYkdMUmVuZGVyVGFyZ2V0KSl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LiIpO3JldHVybn1sZXQgZmU9TWUuZ2V0KE0pLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtpZihNLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0JiZvZSE9PXZvaWQgMCYmKGZlPWZlW29lXSksZmUpe1NlLmJpbmRGcmFtZWJ1ZmZlcihVLkZSQU1FQlVGRkVSLGZlKTt0cnl7Y29uc3QgcGU9TS50ZXh0dXJlLEFlPXBlLmZvcm1hdCxDZT1wZS50eXBlO2lmKCFOZS50ZXh0dXJlRm9ybWF0UmVhZGFibGUoQWUpKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gUkdCQSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIGZvcm1hdC4iKTtyZXR1cm59aWYoIU5lLnRleHR1cmVUeXBlUmVhZGFibGUoQ2UpKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gVW5zaWduZWRCeXRlVHlwZSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIHR5cGUuIik7cmV0dXJufUQ+PTAmJkQ8PU0ud2lkdGgtQiYmTj49MCYmTjw9TS5oZWlnaHQtTCYmVS5yZWFkUGl4ZWxzKEQsTixCLEwsTGUuY29udmVydChBZSksTGUuY29udmVydChDZSksSil9ZmluYWxseXtjb25zdCBwZT1GIT09bnVsbD9NZS5nZXQoRikuX193ZWJnbEZyYW1lYnVmZmVyOm51bGw7U2UuYmluZEZyYW1lYnVmZmVyKFUuRlJBTUVCVUZGRVIscGUpfX19LHRoaXMucmVhZFJlbmRlclRhcmdldFBpeGVsc0FzeW5jPWFzeW5jIGZ1bmN0aW9uKE0sRCxOLEIsTCxKLG9lKXtpZighKE0mJk0uaXNXZWJHTFJlbmRlclRhcmdldCkpdGhyb3cgbmV3IEVycm9yKCJUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuIik7bGV0IGZlPU1lLmdldChNKS5fX3dlYmdsRnJhbWVidWZmZXI7aWYoTS5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCYmb2UhPT12b2lkIDAmJihmZT1mZVtvZV0pLGZlKXtjb25zdCBwZT1NLnRleHR1cmUsQWU9cGUuZm9ybWF0LENlPXBlLnR5cGU7aWYoIU5lLnRleHR1cmVGb3JtYXRSZWFkYWJsZShBZSkpdGhyb3cgbmV3IEVycm9yKCJUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHNBc3luYzogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBSR0JBIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgZm9ybWF0LiIpO2lmKCFOZS50ZXh0dXJlVHlwZVJlYWRhYmxlKENlKSl0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsc0FzeW5jOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFVuc2lnbmVkQnl0ZVR5cGUgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCB0eXBlLiIpO2lmKEQ+PTAmJkQ8PU0ud2lkdGgtQiYmTj49MCYmTjw9TS5oZWlnaHQtTCl7U2UuYmluZEZyYW1lYnVmZmVyKFUuRlJBTUVCVUZGRVIsZmUpO2NvbnN0IG1lPVUuY3JlYXRlQnVmZmVyKCk7VS5iaW5kQnVmZmVyKFUuUElYRUxfUEFDS19CVUZGRVIsbWUpLFUuYnVmZmVyRGF0YShVLlBJWEVMX1BBQ0tfQlVGRkVSLEouYnl0ZUxlbmd0aCxVLlNUUkVBTV9SRUFEKSxVLnJlYWRQaXhlbHMoRCxOLEIsTCxMZS5jb252ZXJ0KEFlKSxMZS5jb252ZXJ0KENlKSwwKTtjb25zdCBIZT1GIT09bnVsbD9NZS5nZXQoRikuX193ZWJnbEZyYW1lYnVmZmVyOm51bGw7U2UuYmluZEZyYW1lYnVmZmVyKFUuRlJBTUVCVUZGRVIsSGUpO2NvbnN0IFplPVUuZmVuY2VTeW5jKFUuU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsMCk7cmV0dXJuIFUuZmx1c2goKSxhd2FpdCBkYShVLFplLDQpLFUuYmluZEJ1ZmZlcihVLlBJWEVMX1BBQ0tfQlVGRkVSLG1lKSxVLmdldEJ1ZmZlclN1YkRhdGEoVS5QSVhFTF9QQUNLX0JVRkZFUiwwLEopLFUuZGVsZXRlQnVmZmVyKG1lKSxVLmRlbGV0ZVN5bmMoWmUpLEp9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsc0FzeW5jOiByZXF1ZXN0ZWQgcmVhZCBib3VuZHMgYXJlIG91dCBvZiByYW5nZS4iKX19LHRoaXMuY29weUZyYW1lYnVmZmVyVG9UZXh0dXJlPWZ1bmN0aW9uKE0sRD1udWxsLE49MCl7TS5pc1RleHR1cmUhPT0hMCYmKFduKCJXZWJHTFJlbmRlcmVyOiBjb3B5RnJhbWVidWZmZXJUb1RleHR1cmUgZnVuY3Rpb24gc2lnbmF0dXJlIGhhcyBjaGFuZ2VkLiIpLEQ9YXJndW1lbnRzWzBdfHxudWxsLE09YXJndW1lbnRzWzFdKTtjb25zdCBCPU1hdGgucG93KDIsLU4pLEw9TWF0aC5mbG9vcihNLmltYWdlLndpZHRoKkIpLEo9TWF0aC5mbG9vcihNLmltYWdlLmhlaWdodCpCKSxvZT1EIT09bnVsbD9ELng6MCxmZT1EIT09bnVsbD9ELnk6MDtBLnNldFRleHR1cmUyRChNLDApLFUuY29weVRleFN1YkltYWdlMkQoVS5URVhUVVJFXzJELE4sMCwwLG9lLGZlLEwsSiksU2UudW5iaW5kVGV4dHVyZSgpfSx0aGlzLmNvcHlUZXh0dXJlVG9UZXh0dXJlPWZ1bmN0aW9uKE0sRCxOPW51bGwsQj1udWxsLEw9MCl7TS5pc1RleHR1cmUhPT0hMCYmKFduKCJXZWJHTFJlbmRlcmVyOiBjb3B5VGV4dHVyZVRvVGV4dHVyZSBmdW5jdGlvbiBzaWduYXR1cmUgaGFzIGNoYW5nZWQuIiksQj1hcmd1bWVudHNbMF18fG51bGwsTT1hcmd1bWVudHNbMV0sRD1hcmd1bWVudHNbMl0sTD1hcmd1bWVudHNbM118fDAsTj1udWxsKTtsZXQgSixvZSxmZSxwZSxBZSxDZSxtZSxIZSxaZTtjb25zdCBKZT1NLmlzQ29tcHJlc3NlZFRleHR1cmU/TS5taXBtYXBzW0xdOk0uaW1hZ2U7TiE9PW51bGw/KEo9Ti5tYXgueC1OLm1pbi54LG9lPU4ubWF4LnktTi5taW4ueSxmZT1OLmlzQm94Mz9OLm1heC56LU4ubWluLno6MSxwZT1OLm1pbi54LEFlPU4ubWluLnksQ2U9Ti5pc0JveDM/Ti5taW4uejowKTooSj1KZS53aWR0aCxvZT1KZS5oZWlnaHQsZmU9SmUuZGVwdGh8fDEscGU9MCxBZT0wLENlPTApLEIhPT1udWxsPyhtZT1CLngsSGU9Qi55LFplPUIueik6KG1lPTAsSGU9MCxaZT0wKTtjb25zdCBFdD1MZS5jb252ZXJ0KEQuZm9ybWF0KSxrZT1MZS5jb252ZXJ0KEQudHlwZSk7bGV0IHZlO0QuaXNEYXRhM0RUZXh0dXJlPyhBLnNldFRleHR1cmUzRChELDApLHZlPVUuVEVYVFVSRV8zRCk6RC5pc0RhdGFBcnJheVRleHR1cmV8fEQuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlPyhBLnNldFRleHR1cmUyREFycmF5KEQsMCksdmU9VS5URVhUVVJFXzJEX0FSUkFZKTooQS5zZXRUZXh0dXJlMkQoRCwwKSx2ZT1VLlRFWFRVUkVfMkQpLFUucGl4ZWxTdG9yZWkoVS5VTlBBQ0tfRkxJUF9ZX1dFQkdMLEQuZmxpcFkpLFUucGl4ZWxTdG9yZWkoVS5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsRC5wcmVtdWx0aXBseUFscGhhKSxVLnBpeGVsU3RvcmVpKFUuVU5QQUNLX0FMSUdOTUVOVCxELnVucGFja0FsaWdubWVudCk7Y29uc3QgWnQ9VS5nZXRQYXJhbWV0ZXIoVS5VTlBBQ0tfUk9XX0xFTkdUSCksV2U9VS5nZXRQYXJhbWV0ZXIoVS5VTlBBQ0tfSU1BR0VfSEVJR0hUKSxCdD1VLmdldFBhcmFtZXRlcihVLlVOUEFDS19TS0lQX1BJWEVMUyksR249VS5nZXRQYXJhbWV0ZXIoVS5VTlBBQ0tfU0tJUF9ST1dTKSx3dD1VLmdldFBhcmFtZXRlcihVLlVOUEFDS19TS0lQX0lNQUdFUyk7VS5waXhlbFN0b3JlaShVLlVOUEFDS19ST1dfTEVOR1RILEplLndpZHRoKSxVLnBpeGVsU3RvcmVpKFUuVU5QQUNLX0lNQUdFX0hFSUdIVCxKZS5oZWlnaHQpLFUucGl4ZWxTdG9yZWkoVS5VTlBBQ0tfU0tJUF9QSVhFTFMscGUpLFUucGl4ZWxTdG9yZWkoVS5VTlBBQ0tfU0tJUF9ST1dTLEFlKSxVLnBpeGVsU3RvcmVpKFUuVU5QQUNLX1NLSVBfSU1BR0VTLENlKTtjb25zdCB0aT1NLmlzRGF0YUFycmF5VGV4dHVyZXx8TS5pc0RhdGEzRFRleHR1cmUsUWU9RC5pc0RhdGFBcnJheVRleHR1cmV8fEQuaXNEYXRhM0RUZXh0dXJlO2lmKE0uaXNSZW5kZXJUYXJnZXRUZXh0dXJlfHxNLmlzRGVwdGhUZXh0dXJlKXtjb25zdCBIdD1NZS5nZXQoTSksbmk9TWUuZ2V0KEQpLER0PU1lLmdldChIdC5fX3JlbmRlclRhcmdldCksYW49TWUuZ2V0KG5pLl9fcmVuZGVyVGFyZ2V0KTtTZS5iaW5kRnJhbWVidWZmZXIoVS5SRUFEX0ZSQU1FQlVGRkVSLER0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciksU2UuYmluZEZyYW1lYnVmZmVyKFUuRFJBV19GUkFNRUJVRkZFUixhbi5fX3dlYmdsRnJhbWVidWZmZXIpO2ZvcihsZXQgb249MDtvbjxmZTtvbisrKXRpJiZVLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyKFUuUkVBRF9GUkFNRUJVRkZFUixVLkNPTE9SX0FUVEFDSE1FTlQwLE1lLmdldChNKS5fX3dlYmdsVGV4dHVyZSxMLENlK29uKSxNLmlzRGVwdGhUZXh0dXJlPyhRZSYmVS5mcmFtZWJ1ZmZlclRleHR1cmVMYXllcihVLkRSQVdfRlJBTUVCVUZGRVIsVS5DT0xPUl9BVFRBQ0hNRU5UMCxNZS5nZXQoRCkuX193ZWJnbFRleHR1cmUsTCxaZStvbiksVS5ibGl0RnJhbWVidWZmZXIocGUsQWUsSixvZSxtZSxIZSxKLG9lLFUuREVQVEhfQlVGRkVSX0JJVCxVLk5FQVJFU1QpKTpRZT9VLmNvcHlUZXhTdWJJbWFnZTNEKHZlLEwsbWUsSGUsWmUrb24scGUsQWUsSixvZSk6VS5jb3B5VGV4U3ViSW1hZ2UyRCh2ZSxMLG1lLEhlLFplK29uLHBlLEFlLEosb2UpO1NlLmJpbmRGcmFtZWJ1ZmZlcihVLlJFQURfRlJBTUVCVUZGRVIsbnVsbCksU2UuYmluZEZyYW1lYnVmZmVyKFUuRFJBV19GUkFNRUJVRkZFUixudWxsKX1lbHNlIFFlP00uaXNEYXRhVGV4dHVyZXx8TS5pc0RhdGEzRFRleHR1cmU/VS50ZXhTdWJJbWFnZTNEKHZlLEwsbWUsSGUsWmUsSixvZSxmZSxFdCxrZSxKZS5kYXRhKTpELmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZT9VLmNvbXByZXNzZWRUZXhTdWJJbWFnZTNEKHZlLEwsbWUsSGUsWmUsSixvZSxmZSxFdCxKZS5kYXRhKTpVLnRleFN1YkltYWdlM0QodmUsTCxtZSxIZSxaZSxKLG9lLGZlLEV0LGtlLEplKTpNLmlzRGF0YVRleHR1cmU/VS50ZXhTdWJJbWFnZTJEKFUuVEVYVFVSRV8yRCxMLG1lLEhlLEosb2UsRXQsa2UsSmUuZGF0YSk6TS5pc0NvbXByZXNzZWRUZXh0dXJlP1UuY29tcHJlc3NlZFRleFN1YkltYWdlMkQoVS5URVhUVVJFXzJELEwsbWUsSGUsSmUud2lkdGgsSmUuaGVpZ2h0LEV0LEplLmRhdGEpOlUudGV4U3ViSW1hZ2UyRChVLlRFWFRVUkVfMkQsTCxtZSxIZSxKLG9lLEV0LGtlLEplKTtVLnBpeGVsU3RvcmVpKFUuVU5QQUNLX1JPV19MRU5HVEgsWnQpLFUucGl4ZWxTdG9yZWkoVS5VTlBBQ0tfSU1BR0VfSEVJR0hULFdlKSxVLnBpeGVsU3RvcmVpKFUuVU5QQUNLX1NLSVBfUElYRUxTLEJ0KSxVLnBpeGVsU3RvcmVpKFUuVU5QQUNLX1NLSVBfUk9XUyxHbiksVS5waXhlbFN0b3JlaShVLlVOUEFDS19TS0lQX0lNQUdFUyx3dCksTD09PTAmJkQuZ2VuZXJhdGVNaXBtYXBzJiZVLmdlbmVyYXRlTWlwbWFwKHZlKSxTZS51bmJpbmRUZXh0dXJlKCl9LHRoaXMuY29weVRleHR1cmVUb1RleHR1cmUzRD1mdW5jdGlvbihNLEQsTj1udWxsLEI9bnVsbCxMPTApe3JldHVybiBNLmlzVGV4dHVyZSE9PSEwJiYoV24oIldlYkdMUmVuZGVyZXI6IGNvcHlUZXh0dXJlVG9UZXh0dXJlM0QgZnVuY3Rpb24gc2lnbmF0dXJlIGhhcyBjaGFuZ2VkLiIpLE49YXJndW1lbnRzWzBdfHxudWxsLEI9YXJndW1lbnRzWzFdfHxudWxsLE09YXJndW1lbnRzWzJdLEQ9YXJndW1lbnRzWzNdLEw9YXJndW1lbnRzWzRdfHwwKSxXbignV2ViR0xSZW5kZXJlcjogY29weVRleHR1cmVUb1RleHR1cmUzRCBmdW5jdGlvbiBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgImNvcHlUZXh0dXJlVG9UZXh0dXJlIiBpbnN0ZWFkLicpLHRoaXMuY29weVRleHR1cmVUb1RleHR1cmUoTSxELE4sQixMKX0sdGhpcy5pbml0UmVuZGVyVGFyZ2V0PWZ1bmN0aW9uKE0pe01lLmdldChNKS5fX3dlYmdsRnJhbWVidWZmZXI9PT12b2lkIDAmJkEuc2V0dXBSZW5kZXJUYXJnZXQoTSl9LHRoaXMuaW5pdFRleHR1cmU9ZnVuY3Rpb24oTSl7TS5pc0N1YmVUZXh0dXJlP0Euc2V0VGV4dHVyZUN1YmUoTSwwKTpNLmlzRGF0YTNEVGV4dHVyZT9BLnNldFRleHR1cmUzRChNLDApOk0uaXNEYXRhQXJyYXlUZXh0dXJlfHxNLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZT9BLnNldFRleHR1cmUyREFycmF5KE0sMCk6QS5zZXRUZXh0dXJlMkQoTSwwKSxTZS51bmJpbmRUZXh0dXJlKCl9LHRoaXMucmVzZXRTdGF0ZT1mdW5jdGlvbigpe3c9MCxiPTAsRj1udWxsLFNlLnJlc2V0KCksS2UucmVzZXQoKX0sdHlwZW9mIF9fVEhSRUVfREVWVE9PTFNfXzwidSImJl9fVEhSRUVfREVWVE9PTFNfXy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgib2JzZXJ2ZSIse2RldGFpbDp0aGlzfSkpfWdldCBjb29yZGluYXRlU3lzdGVtKCl7cmV0dXJuIDJlM31nZXQgb3V0cHV0Q29sb3JTcGFjZSgpe3JldHVybiB0aGlzLl9vdXRwdXRDb2xvclNwYWNlfXNldCBvdXRwdXRDb2xvclNwYWNlKGUpe3RoaXMuX291dHB1dENvbG9yU3BhY2U9ZTtjb25zdCB0PXRoaXMuZ2V0Q29udGV4dCgpO3QuZHJhd2luZ0J1ZmZlckNvbG9yc3BhY2U9QmUuX2dldERyYXdpbmdCdWZmZXJDb2xvclNwYWNlKGUpLHQudW5wYWNrQ29sb3JTcGFjZT1CZS5fZ2V0VW5wYWNrQ29sb3JTcGFjZSgpfX1jbGFzcyBEcyBleHRlbmRzIE10e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmlzU2NlbmU9ITAsdGhpcy50eXBlPSJTY2VuZSIsdGhpcy5iYWNrZ3JvdW5kPW51bGwsdGhpcy5lbnZpcm9ubWVudD1udWxsLHRoaXMuZm9nPW51bGwsdGhpcy5iYWNrZ3JvdW5kQmx1cnJpbmVzcz0wLHRoaXMuYmFja2dyb3VuZEludGVuc2l0eT0xLHRoaXMuYmFja2dyb3VuZFJvdGF0aW9uPW5ldyBYdCx0aGlzLmVudmlyb25tZW50SW50ZW5zaXR5PTEsdGhpcy5lbnZpcm9ubWVudFJvdGF0aW9uPW5ldyBYdCx0aGlzLm92ZXJyaWRlTWF0ZXJpYWw9bnVsbCx0eXBlb2YgX19USFJFRV9ERVZUT09MU19fPCJ1IiYmX19USFJFRV9ERVZUT09MU19fLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCJvYnNlcnZlIix7ZGV0YWlsOnRoaXN9KSl9Y29weShlLHQpe3JldHVybiBzdXBlci5jb3B5KGUsdCksZS5iYWNrZ3JvdW5kIT09bnVsbCYmKHRoaXMuYmFja2dyb3VuZD1lLmJhY2tncm91bmQuY2xvbmUoKSksZS5lbnZpcm9ubWVudCE9PW51bGwmJih0aGlzLmVudmlyb25tZW50PWUuZW52aXJvbm1lbnQuY2xvbmUoKSksZS5mb2chPT1udWxsJiYodGhpcy5mb2c9ZS5mb2cuY2xvbmUoKSksdGhpcy5iYWNrZ3JvdW5kQmx1cnJpbmVzcz1lLmJhY2tncm91bmRCbHVycmluZXNzLHRoaXMuYmFja2dyb3VuZEludGVuc2l0eT1lLmJhY2tncm91bmRJbnRlbnNpdHksdGhpcy5iYWNrZ3JvdW5kUm90YXRpb24uY29weShlLmJhY2tncm91bmRSb3RhdGlvbiksdGhpcy5lbnZpcm9ubWVudEludGVuc2l0eT1lLmVudmlyb25tZW50SW50ZW5zaXR5LHRoaXMuZW52aXJvbm1lbnRSb3RhdGlvbi5jb3B5KGUuZW52aXJvbm1lbnRSb3RhdGlvbiksZS5vdmVycmlkZU1hdGVyaWFsIT09bnVsbCYmKHRoaXMub3ZlcnJpZGVNYXRlcmlhbD1lLm92ZXJyaWRlTWF0ZXJpYWwuY2xvbmUoKSksdGhpcy5tYXRyaXhBdXRvVXBkYXRlPWUubWF0cml4QXV0b1VwZGF0ZSx0aGlzfXRvSlNPTihlKXtjb25zdCB0PXN1cGVyLnRvSlNPTihlKTtyZXR1cm4gdGhpcy5mb2chPT1udWxsJiYodC5vYmplY3QuZm9nPXRoaXMuZm9nLnRvSlNPTigpKSx0aGlzLmJhY2tncm91bmRCbHVycmluZXNzPjAmJih0Lm9iamVjdC5iYWNrZ3JvdW5kQmx1cnJpbmVzcz10aGlzLmJhY2tncm91bmRCbHVycmluZXNzKSx0aGlzLmJhY2tncm91bmRJbnRlbnNpdHkhPT0xJiYodC5vYmplY3QuYmFja2dyb3VuZEludGVuc2l0eT10aGlzLmJhY2tncm91bmRJbnRlbnNpdHkpLHQub2JqZWN0LmJhY2tncm91bmRSb3RhdGlvbj10aGlzLmJhY2tncm91bmRSb3RhdGlvbi50b0FycmF5KCksdGhpcy5lbnZpcm9ubWVudEludGVuc2l0eSE9PTEmJih0Lm9iamVjdC5lbnZpcm9ubWVudEludGVuc2l0eT10aGlzLmVudmlyb25tZW50SW50ZW5zaXR5KSx0Lm9iamVjdC5lbnZpcm9ubWVudFJvdGF0aW9uPXRoaXMuZW52aXJvbm1lbnRSb3RhdGlvbi50b0FycmF5KCksdH19Y2xhc3MgR3QgZXh0ZW5kcyBTdHtjb25zdHJ1Y3RvcihlLHQsaSxyPTEpe3N1cGVyKGUsdCxpKSx0aGlzLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlPSEwLHRoaXMubWVzaFBlckF0dHJpYnV0ZT1yfWNvcHkoZSl7cmV0dXJuIHN1cGVyLmNvcHkoZSksdGhpcy5tZXNoUGVyQXR0cmlidXRlPWUubWVzaFBlckF0dHJpYnV0ZSx0aGlzfXRvSlNPTigpe2NvbnN0IGU9c3VwZXIudG9KU09OKCk7cmV0dXJuIGUubWVzaFBlckF0dHJpYnV0ZT10aGlzLm1lc2hQZXJBdHRyaWJ1dGUsZS5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZT0hMCxlfX1jbGFzcyBSaSBleHRlbmRzIFpue3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJQb2ludHNNYXRlcmlhbCJ9Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLmlzUG9pbnRzTWF0ZXJpYWw9ITAsdGhpcy5jb2xvcj1uZXcgVmUoMTY3NzcyMTUpLHRoaXMubWFwPW51bGwsdGhpcy5hbHBoYU1hcD1udWxsLHRoaXMuc2l6ZT0xLHRoaXMuc2l6ZUF0dGVudWF0aW9uPSEwLHRoaXMuZm9nPSEwLHRoaXMuc2V0VmFsdWVzKGUpfWNvcHkoZSl7cmV0dXJuIHN1cGVyLmNvcHkoZSksdGhpcy5jb2xvci5jb3B5KGUuY29sb3IpLHRoaXMubWFwPWUubWFwLHRoaXMuYWxwaGFNYXA9ZS5hbHBoYU1hcCx0aGlzLnNpemU9ZS5zaXplLHRoaXMuc2l6ZUF0dGVudWF0aW9uPWUuc2l6ZUF0dGVudWF0aW9uLHRoaXMuZm9nPWUuZm9nLHRoaXN9fWNvbnN0IExzPW5ldyBzdCxwcj1uZXcgTHIsQ2k9bmV3IGxpLFBpPW5ldyBPO2NsYXNzIG1yIGV4dGVuZHMgTXR7Y29uc3RydWN0b3IoZT1uZXcgQ3QsdD1uZXcgUmkpe3N1cGVyKCksdGhpcy5pc1BvaW50cz0hMCx0aGlzLnR5cGU9IlBvaW50cyIsdGhpcy5nZW9tZXRyeT1lLHRoaXMubWF0ZXJpYWw9dCx0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpfWNvcHkoZSx0KXtyZXR1cm4gc3VwZXIuY29weShlLHQpLHRoaXMubWF0ZXJpYWw9QXJyYXkuaXNBcnJheShlLm1hdGVyaWFsKT9lLm1hdGVyaWFsLnNsaWNlKCk6ZS5tYXRlcmlhbCx0aGlzLmdlb21ldHJ5PWUuZ2VvbWV0cnksdGhpc31yYXljYXN0KGUsdCl7Y29uc3QgaT10aGlzLmdlb21ldHJ5LHI9dGhpcy5tYXRyaXhXb3JsZCxzPWUucGFyYW1zLlBvaW50cy50aHJlc2hvbGQsbz1pLmRyYXdSYW5nZTtpZihpLmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmaS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKSxDaS5jb3B5KGkuYm91bmRpbmdTcGhlcmUpLENpLmFwcGx5TWF0cml4NChyKSxDaS5yYWRpdXMrPXMsZS5yYXkuaW50ZXJzZWN0c1NwaGVyZShDaSk9PT0hMSlyZXR1cm47THMuY29weShyKS5pbnZlcnQoKSxwci5jb3B5KGUucmF5KS5hcHBseU1hdHJpeDQoTHMpO2NvbnN0IGE9cy8oKHRoaXMuc2NhbGUueCt0aGlzLnNjYWxlLnkrdGhpcy5zY2FsZS56KS8zKSxsPWEqYSxjPWkuaW5kZXgsZD1pLmF0dHJpYnV0ZXMucG9zaXRpb247aWYoYyE9PW51bGwpe2NvbnN0IGY9TWF0aC5tYXgoMCxvLnN0YXJ0KSxwPU1hdGgubWluKGMuY291bnQsby5zdGFydCtvLmNvdW50KTtmb3IobGV0IGc9Zix4PXA7Zzx4O2crKyl7Y29uc3QgbT1jLmdldFgoZyk7UGkuZnJvbUJ1ZmZlckF0dHJpYnV0ZShkLG0pLFVzKFBpLG0sbCxyLGUsdCx0aGlzKX19ZWxzZXtjb25zdCBmPU1hdGgubWF4KDAsby5zdGFydCkscD1NYXRoLm1pbihkLmNvdW50LG8uc3RhcnQrby5jb3VudCk7Zm9yKGxldCBnPWYseD1wO2c8eDtnKyspUGkuZnJvbUJ1ZmZlckF0dHJpYnV0ZShkLGcpLFVzKFBpLGcsbCxyLGUsdCx0aGlzKX19dXBkYXRlTW9ycGhUYXJnZXRzKCl7Y29uc3QgdD10aGlzLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyxpPU9iamVjdC5rZXlzKHQpO2lmKGkubGVuZ3RoPjApe2NvbnN0IHI9dFtpWzBdXTtpZihyIT09dm9pZCAwKXt0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcz1bXSx0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeT17fTtmb3IobGV0IHM9MCxvPXIubGVuZ3RoO3M8bztzKyspe2NvbnN0IGE9cltzXS5uYW1lfHxTdHJpbmcocyk7dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCgwKSx0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVthXT1zfX19fX1mdW5jdGlvbiBVcyhuLGUsdCxpLHIscyxvKXtjb25zdCBhPXByLmRpc3RhbmNlU3FUb1BvaW50KG4pO2lmKGE8dCl7Y29uc3QgbD1uZXcgTztwci5jbG9zZXN0UG9pbnRUb1BvaW50KG4sbCksbC5hcHBseU1hdHJpeDQoaSk7Y29uc3QgYz1yLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhsKTtpZihjPHIubmVhcnx8Yz5yLmZhcilyZXR1cm47cy5wdXNoKHtkaXN0YW5jZTpjLGRpc3RhbmNlVG9SYXk6TWF0aC5zcXJ0KGEpLHBvaW50OmwsaW5kZXg6ZSxmYWNlOm51bGwsZmFjZUluZGV4Om51bGwsYmFyeWNvb3JkOm51bGwsb2JqZWN0Om99KX19Y2xhc3MgWHUgZXh0ZW5kcyB2dHtjb25zdHJ1Y3RvcihlLHQsaSxyLHMsbyxhLGwsYyl7c3VwZXIoZSx0LGkscixzLG8sYSxsLGMpLHRoaXMuaXNDYW52YXNUZXh0dXJlPSEwLHRoaXMubmVlZHNVcGRhdGU9ITB9fWNsYXNzIEZzIGV4dGVuZHMgQ3R7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeT0hMCx0aGlzLnR5cGU9Ikluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5Iix0aGlzLmluc3RhbmNlQ291bnQ9MS8wfWNvcHkoZSl7cmV0dXJuIHN1cGVyLmNvcHkoZSksdGhpcy5pbnN0YW5jZUNvdW50PWUuaW5zdGFuY2VDb3VudCx0aGlzfXRvSlNPTigpe2NvbnN0IGU9c3VwZXIudG9KU09OKCk7cmV0dXJuIGUuaW5zdGFuY2VDb3VudD10aGlzLmluc3RhbmNlQ291bnQsZS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5PSEwLGV9fXR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX188InUiJiZfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoInJlZ2lzdGVyIix7ZGV0YWlsOntyZXZpc2lvbjpOaX19KSksdHlwZW9mIHdpbmRvdzwidSImJih3aW5kb3cuX19USFJFRV9fP2NvbnNvbGUud2FybigiV0FSTklORzogTXVsdGlwbGUgaW5zdGFuY2VzIG9mIFRocmVlLmpzIGJlaW5nIGltcG9ydGVkLiIpOndpbmRvdy5fX1RIUkVFX189TmkpO2NvbnN0IGdyPTEwMCxEaT1uZXcgTWFwO2xldCBxdT0wO2NvbnN0IElzPXR5cGVvZiBnbG9iYWxUaGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZT09ImZ1bmN0aW9uIj9uPT5nbG9iYWxUaGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZShuKTpuPT57Y29uc3QgZT0rK3F1LHQ9c2V0VGltZW91dCgoKT0+e0RpLmRlbGV0ZShlKSxuKHBlcmZvcm1hbmNlLm5vdygpKX0sMTYpO3JldHVybiBEaS5zZXQoZSx0KSxlfSxZdT10eXBlb2YgZ2xvYmFsVGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZT09ImZ1bmN0aW9uIj9uPT5nbG9iYWxUaGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lKG4pOm49Pntjb25zdCBlPURpLmdldChuKTtlJiYoY2xlYXJUaW1lb3V0KGUpLERpLmRlbGV0ZShuKSl9O2Z1bmN0aW9uIExpKG4sZT1uKXtpZih0eXBlb2YgZG9jdW1lbnQ8InUiJiZkb2N1bWVudC5jcmVhdGVFbGVtZW50KXtjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpO3Qud2lkdGg9bix0LmhlaWdodD1lO2NvbnN0IGk9dC5nZXRDb250ZXh0KCIyZCIpO2lmKCFpKXRocm93IG5ldyBFcnJvcigiVW5hYmxlIHRvIGdldCAyRCBjb250ZXh0Iik7cmV0dXJue2NhbnZhczp0LGN0eDppfX1pZih0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzPCJ1Iil7Y29uc3QgdD1uZXcgT2Zmc2NyZWVuQ2FudmFzKG4sZSksaT10LmdldENvbnRleHQoIjJkIik7aWYoIWkpdGhyb3cgbmV3IEVycm9yKCJVbmFibGUgdG8gZ2V0IDJEIGNvbnRleHQiKTtyZXR1cm57Y2FudmFzOnQsY3R4Oml9fXRocm93IG5ldyBFcnJvcigiQ2FudmFzIG5vdCBzdXBwb3J0ZWQiKX1mdW5jdGlvbiBVaShuKXtyZXR1cm4gbmV3IFh1KG4pfWZ1bmN0aW9uIE5zKCl7Y29uc3R7Y2FudmFzOmUsY3R4OnR9PUxpKDMyLDMyKSxpPXQuY3JlYXRlUmFkaWFsR3JhZGllbnQoMzIvMiwzMi8yLDAsMzIvMiwzMi8yLDMyLzIpO2kuYWRkQ29sb3JTdG9wKDAsInJnYmEoMjU1LCAyNTUsIDI1NSwgMSkiKSxpLmFkZENvbG9yU3RvcCguNCwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpIiksaS5hZGRDb2xvclN0b3AoMSwicmdiYSgyNTUsIDI1NSwgMjU1LCAwKSIpLHQuZmlsbFN0eWxlPWksdC5maWxsUmVjdCgwLDAsMzIsMzIpO2NvbnN0IHI9VWkoZSk7cmV0dXJuIHIubmVlZHNVcGRhdGU9ITAscn1mdW5jdGlvbiAkdSgpe2NvbnN0e2NhbnZhczplLGN0eDp0fT1MaSgxNiwxNiksaT10LmNyZWF0ZVJhZGlhbEdyYWRpZW50KDE2LzIsMTYvMiwwLDE2LzIsMTYvMiwxNi8yKTtpLmFkZENvbG9yU3RvcCgwLCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNTUpIiksaS5hZGRDb2xvclN0b3AoLjQsInJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zNSkiKSxpLmFkZENvbG9yU3RvcCgxLCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDApIiksdC5maWxsU3R5bGU9aSx0LmZpbGxSZWN0KDAsMCwxNiwxNik7Y29uc3Qgcj1VaShlKTtyZXR1cm4gci5uZWVkc1VwZGF0ZT0hMCxyfWNvbnN0IF9yPWAKICB2YXJ5aW5nIHZlYzIgdlV2OwogIHZvaWQgbWFpbigpIHsKICAgIHZVdiA9IHV2OwogICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTsKICB9CmA7Y2xhc3MgS3V7Y29uc3RydWN0b3IoZSl7dGhpcy5jYW52YXM9ZS5jYW52YXMsdGhpcy52aWV3cG9ydFdpZHRoPWUudmlld3BvcnRXaWR0aCx0aGlzLnZpZXdwb3J0SGVpZ2h0PWUudmlld3BvcnRIZWlnaHQsdGhpcy5kZXZpY2VQaXhlbFJhdGlvPWUuZGV2aWNlUGl4ZWxSYXRpbz8/MSx0aGlzLmlzTW9iaWxlPWUuaXNNb2JpbGU/PyExLHRoaXMudmlld1dpZHRoPXRoaXMuY29tcHV0ZVZpZXdXaWR0aChnciksdGhpcy52aWV3SGVpZ2h0PWdyLHRoaXMuY2FtZXJhPXRoaXMuY3JlYXRlQ2FtZXJhKCksdGhpcy5yZW5kZXJlcj10aGlzLmNyZWF0ZVJlbmRlcmVyKCksdGhpcy5zY2VuZT1uZXcgRHMsdGhpcy5hbmltYXRpb25GcmFtZT1udWxsLHRoaXMubGFzdFRpbWVzdGFtcD0wLHRoaXMuY3VycmVudEVmZmVjdD0ibm9uZSIsdGhpcy5hY3RpdmVFZmZlY3Q9bnVsbCx0aGlzLm9wYWNpdHk9MTAwLHRoaXMuZWZmZWN0RXh0cmFzPXt9LHRoaXMubGFzdEFwcGxpZWRFeHRyYXM9e30sdGhpcy5zbm93U3VyZmFjZXM9W10sdGhpcy5zbW9nT3ZlcmxheT1udWxsLHRoaXMud2luZG93RHJvcGxldHNPdmVybGF5PW51bGwsdGhpcy5saWdodG5pbmdPdmVybGF5PW51bGwsdGhpcy5hdXJvcmFPdmVybGF5PW51bGwsdGhpcy5yZW5kZXJUYXJnZXQ9bnVsbCx0aGlzLm1hc2tTY2VuZT1udWxsLHRoaXMubWFza0NhbWVyYT1udWxsLHRoaXMubWFza1F1YWQ9bnVsbCx0aGlzLnJlbmRlckxvb3A9dD0+dGhpcy5yZW5kZXJGcmFtZSh0KX1jb21wdXRlVmlld1dpZHRoKGUpe3JldHVybiBlKih0aGlzLnZpZXdwb3J0V2lkdGgvTWF0aC5tYXgoMSx0aGlzLnZpZXdwb3J0SGVpZ2h0KSl9Y3JlYXRlQ2FtZXJhKCl7Y29uc3QgZT10aGlzLnZpZXdXaWR0aC8yLHQ9dGhpcy52aWV3SGVpZ2h0LzIsaT1uZXcgcnIoLWUsZSx0LC10LC0xZTMsMWUzKTtyZXR1cm4gaS5wb3NpdGlvbi56PTEwLGl9Y3JlYXRlUmVuZGVyZXIoKXtjb25zdCBlPW5ldyBXdSh7Y2FudmFzOnRoaXMuY2FudmFzLGFscGhhOiEwLGFudGlhbGlhczohdGhpcy5pc01vYmlsZSxwb3dlclByZWZlcmVuY2U6ImhpZ2gtcGVyZm9ybWFuY2UiLHN0ZW5jaWw6ITEsZGVwdGg6ITEscHJlc2VydmVEcmF3aW5nQnVmZmVyOiExfSk7cmV0dXJuIGUuc2V0UGl4ZWxSYXRpbyhNYXRoLm1pbih0aGlzLmRldmljZVBpeGVsUmF0aW98fDEsdGhpcy5pc01vYmlsZT8xOjEuNSkpLGUuc2V0U2l6ZSh0aGlzLnZpZXdwb3J0V2lkdGgsdGhpcy52aWV3cG9ydEhlaWdodCwhMSksZX1zdGFydChlLHQsaT17fSl7dGhpcy5vcGFjaXR5PU1hdGgubWF4KDAsTWF0aC5taW4oMTAwLHQpKSx0aGlzLmVmZmVjdEV4dHJhcz1pO2NvbnN0IHI9dGhpcy5lZmZlY3RFeHRyYXMubW9vblBvc2l0aW9uLHM9dGhpcy5sYXN0QXBwbGllZEV4dHJhcy5tb29uUG9zaXRpb24sbz1yPy54IT09cz8ueHx8cj8ueSE9PXM/LnksYT10aGlzLmxhc3RBcHBsaWVkRXh0cmFzLndpbmRCZWFyaW5nIT09dGhpcy5lZmZlY3RFeHRyYXMud2luZEJlYXJpbmd8fHRoaXMubGFzdEFwcGxpZWRFeHRyYXMud2luZFNwZWVkS21oIT09dGhpcy5lZmZlY3RFeHRyYXMud2luZFNwZWVkS21oLGw9dGhpcy5sYXN0QXBwbGllZEV4dHJhcy5zbm93QWNjdW11bGF0aW9uIT09dGhpcy5lZmZlY3RFeHRyYXMuc25vd0FjY3VtdWxhdGlvbnx8dGhpcy5sYXN0QXBwbGllZEV4dHJhcy5tYXRyaXhSYWluQ29sb3IhPT10aGlzLmVmZmVjdEV4dHJhcy5tYXRyaXhSYWluQ29sb3J8fHRoaXMubGFzdEFwcGxpZWRFeHRyYXMuc21vZ0FjdGl2ZSE9PXRoaXMuZWZmZWN0RXh0cmFzLnNtb2dBY3RpdmV8fHRoaXMubGFzdEFwcGxpZWRFeHRyYXMud2luZG93RHJvcGxldHMhPT10aGlzLmVmZmVjdEV4dHJhcy53aW5kb3dEcm9wbGV0c3x8dGhpcy5sYXN0QXBwbGllZEV4dHJhcy5saWdodG5pbmdPdmVybGF5IT09dGhpcy5lZmZlY3RFeHRyYXMubGlnaHRuaW5nT3ZlcmxheXx8dGhpcy5sYXN0QXBwbGllZEV4dHJhcy5jbG91ZENvdmVyYWdlIT09dGhpcy5lZmZlY3RFeHRyYXMuY2xvdWRDb3ZlcmFnZXx8dGhpcy5sYXN0QXBwbGllZEV4dHJhcy50aGVtZU1vZGUhPT10aGlzLmVmZmVjdEV4dHJhcy50aGVtZU1vZGV8fHRoaXMubGFzdEFwcGxpZWRFeHRyYXMuY2xvdWRTcGVlZE11bHRpcGxpZXIhPT10aGlzLmVmZmVjdEV4dHJhcy5jbG91ZFNwZWVkTXVsdGlwbGllcnx8dGhpcy5sYXN0QXBwbGllZEV4dHJhcy5hdXJvcmFPdmVybGF5IT09dGhpcy5lZmZlY3RFeHRyYXMuYXVyb3JhT3ZlcmxheXx8dGhpcy5sYXN0QXBwbGllZEV4dHJhcy5hdXJvcmFWaXNpYmlsaXR5U2NvcmUhPT10aGlzLmVmZmVjdEV4dHJhcy5hdXJvcmFWaXNpYmlsaXR5U2NvcmV8fHRoaXMubGFzdEFwcGxpZWRFeHRyYXMuYXVyb3JhVmFyaWFudCE9PXRoaXMuZWZmZWN0RXh0cmFzLmF1cm9yYVZhcmlhbnR8fEpTT04uc3RyaW5naWZ5KHRoaXMubGFzdEFwcGxpZWRFeHRyYXMuZWZmZWN0T3BhY2l0eXx8e30pIT09SlNPTi5zdHJpbmdpZnkodGhpcy5lZmZlY3RFeHRyYXMuZWZmZWN0T3BhY2l0eXx8e30pfHxvfHxhO2lmKHRoaXMuY3VycmVudEVmZmVjdD09PWUmJnRoaXMuYWN0aXZlRWZmZWN0JiYhbCl7dGhpcy5hY3RpdmVFZmZlY3Quc2V0T3BhY2l0eSh0aGlzLm9wYWNpdHkpLHRoaXMudXBkYXRlU21vZ092ZXJsYXkoKSx0aGlzLnVwZGF0ZVdpbmRvd0Ryb3BsZXRzT3ZlcmxheSgpLHRoaXMudXBkYXRlTGlnaHRuaW5nT3ZlcmxheSgpLHRoaXMudXBkYXRlQXVyb3JhT3ZlcmxheSgpLHRoaXMuc3RhcnRMb29wKCk7cmV0dXJufXRoaXMuc2V0RWZmZWN0KGUpfXN0b3AoKXt0aGlzLmRpc3Bvc2VTbW9nT3ZlcmxheSgpLHRoaXMuZGlzcG9zZVdpbmRvd0Ryb3BsZXRzT3ZlcmxheSgpLHRoaXMuZGlzcG9zZUxpZ2h0bmluZ092ZXJsYXkoKSx0aGlzLmRpc3Bvc2VBdXJvcmFPdmVybGF5KCksdGhpcy5kaXNwb3NlQWN0aXZlRWZmZWN0KCksdGhpcy5jdXJyZW50RWZmZWN0PSJub25lIix0aGlzLnN0b3BMb29wKCksdGhpcy5sYXN0QXBwbGllZEV4dHJhcz17fX11cGRhdGVTbW9nT3ZlcmxheSgpe2NvbnN0IGU9ISF0aGlzLmVmZmVjdEV4dHJhcy5zbW9nQWN0aXZlO2UmJiF0aGlzLnNtb2dPdmVybGF5Pyh0aGlzLnNtb2dPdmVybGF5PWNoKHRoaXMpLHRoaXMuc2NlbmUuYWRkKHRoaXMuc21vZ092ZXJsYXkuZ3JvdXApKTohZSYmdGhpcy5zbW9nT3ZlcmxheT90aGlzLmRpc3Bvc2VTbW9nT3ZlcmxheSgpOnRoaXMuc21vZ092ZXJsYXkmJnRoaXMuc21vZ092ZXJsYXkuc2V0T3BhY2l0eSh0aGlzLm9wYWNpdHkpfWRpc3Bvc2VTbW9nT3ZlcmxheSgpe3RoaXMuc21vZ092ZXJsYXkmJih0aGlzLnNjZW5lLnJlbW92ZSh0aGlzLnNtb2dPdmVybGF5Lmdyb3VwKSx0aGlzLnNtb2dPdmVybGF5LmRpc3Bvc2UoKSx0aGlzLnNtb2dPdmVybGF5PW51bGwpfXVwZGF0ZVdpbmRvd0Ryb3BsZXRzT3ZlcmxheSgpe2NvbnN0IGU9ISF0aGlzLmVmZmVjdEV4dHJhcy53aW5kb3dEcm9wbGV0cztlJiYhdGhpcy53aW5kb3dEcm9wbGV0c092ZXJsYXk/KHRoaXMud2luZG93RHJvcGxldHNPdmVybGF5PWxoKHRoaXMpLHRoaXMuc2NlbmUuYWRkKHRoaXMud2luZG93RHJvcGxldHNPdmVybGF5Lmdyb3VwKSk6IWUmJnRoaXMud2luZG93RHJvcGxldHNPdmVybGF5P3RoaXMuZGlzcG9zZVdpbmRvd0Ryb3BsZXRzT3ZlcmxheSgpOnRoaXMud2luZG93RHJvcGxldHNPdmVybGF5JiZ0aGlzLndpbmRvd0Ryb3BsZXRzT3ZlcmxheS5zZXRPcGFjaXR5KHRoaXMub3BhY2l0eSl9ZGlzcG9zZVdpbmRvd0Ryb3BsZXRzT3ZlcmxheSgpe3RoaXMud2luZG93RHJvcGxldHNPdmVybGF5JiYodGhpcy5zY2VuZS5yZW1vdmUodGhpcy53aW5kb3dEcm9wbGV0c092ZXJsYXkuZ3JvdXApLHRoaXMud2luZG93RHJvcGxldHNPdmVybGF5LmRpc3Bvc2UoKSx0aGlzLndpbmRvd0Ryb3BsZXRzT3ZlcmxheT1udWxsKX11cGRhdGVMaWdodG5pbmdPdmVybGF5KCl7Y29uc3QgZT10aGlzLmN1cnJlbnRFZmZlY3Q9PT0icmFpbl9zdG9ybSImJiEhdGhpcy5lZmZlY3RFeHRyYXMubGlnaHRuaW5nRGF0YTtlJiYhdGhpcy5saWdodG5pbmdPdmVybGF5Pyh0aGlzLmxpZ2h0bmluZ092ZXJsYXk9R3Moe3ZpZXdXaWR0aDp0aGlzLnZpZXdXaWR0aCx2aWV3SGVpZ2h0OnRoaXMudmlld0hlaWdodCxvcGFjaXR5OnRoaXMub3BhY2l0eSxpc01vYmlsZTp0aGlzLmlzTW9iaWxlfSksdGhpcy5zY2VuZS5hZGQodGhpcy5saWdodG5pbmdPdmVybGF5Lmdyb3VwKSk6IWUmJnRoaXMubGlnaHRuaW5nT3ZlcmxheT90aGlzLmRpc3Bvc2VMaWdodG5pbmdPdmVybGF5KCk6dGhpcy5saWdodG5pbmdPdmVybGF5JiZ0aGlzLmxpZ2h0bmluZ092ZXJsYXkuc2V0T3BhY2l0eSh0aGlzLm9wYWNpdHkpfWRpc3Bvc2VMaWdodG5pbmdPdmVybGF5KCl7dGhpcy5saWdodG5pbmdPdmVybGF5JiYodGhpcy5zY2VuZS5yZW1vdmUodGhpcy5saWdodG5pbmdPdmVybGF5Lmdyb3VwKSx0aGlzLmxpZ2h0bmluZ092ZXJsYXkuZGlzcG9zZSgpLHRoaXMubGlnaHRuaW5nT3ZlcmxheT1udWxsKX11cGRhdGVBdXJvcmFPdmVybGF5KCl7Y29uc3QgZT10aGlzLmN1cnJlbnRFZmZlY3Q9PT0ic3RhcnMiJiYhIXRoaXMuZWZmZWN0RXh0cmFzLmF1cm9yYU92ZXJsYXksdD1NYXRoLm1heCgwLE1hdGgubWluKDEsdGhpcy5lZmZlY3RFeHRyYXMuYXVyb3JhVmlzaWJpbGl0eVNjb3JlPz8wKSksaT10aGlzLmVmZmVjdEV4dHJhcy5hdXJvcmFWYXJpYW50fHwiYmFuZHMiLHI9dGhpcy5hdXJvcmFPdmVybGF5JiZ0aGlzLmxhc3RBcHBsaWVkRXh0cmFzLmF1cm9yYVZhcmlhbnQhPT1pO2UmJighdGhpcy5hdXJvcmFPdmVybGF5fHxyKT8odGhpcy5hdXJvcmFPdmVybGF5JiZ0aGlzLmRpc3Bvc2VBdXJvcmFPdmVybGF5KCksdGhpcy5hdXJvcmFPdmVybGF5PWhoKHRoaXMsdCxpKSx0aGlzLnNjZW5lLmFkZCh0aGlzLmF1cm9yYU92ZXJsYXkuZ3JvdXApKTohZSYmdGhpcy5hdXJvcmFPdmVybGF5P3RoaXMuZGlzcG9zZUF1cm9yYU92ZXJsYXkoKTp0aGlzLmF1cm9yYU92ZXJsYXkmJih0aGlzLmF1cm9yYU92ZXJsYXkuc2V0T3BhY2l0eSh0aGlzLm9wYWNpdHkpLHRoaXMuYXVyb3JhT3ZlcmxheS5zZXRWaXNpYmlsaXR5U2NvcmU/Lih0KSl9ZGlzcG9zZUF1cm9yYU92ZXJsYXkoKXt0aGlzLmF1cm9yYU92ZXJsYXkmJih0aGlzLnNjZW5lLnJlbW92ZSh0aGlzLmF1cm9yYU92ZXJsYXkuZ3JvdXApLHRoaXMuYXVyb3JhT3ZlcmxheS5kaXNwb3NlKCksdGhpcy5hdXJvcmFPdmVybGF5PW51bGwpfXNldE9wYWNpdHkoZSl7dGhpcy5vcGFjaXR5PU1hdGgubWF4KDAsTWF0aC5taW4oMTAwLGUpKSx0aGlzLmFjdGl2ZUVmZmVjdD8uc2V0T3BhY2l0eSh0aGlzLm9wYWNpdHkpfXNldFNub3dTdXJmYWNlcyhlKXt0aGlzLnNub3dTdXJmYWNlcz1lfHxbXSx0aGlzLmFjdGl2ZUVmZmVjdD8uc2V0U25vd1N1cmZhY2VzPy4odGhpcy5zbm93U3VyZmFjZXMpfWdldExhc3RBcHBsaWVkRXh0cmFzKCl7cmV0dXJuey4uLnRoaXMubGFzdEFwcGxpZWRFeHRyYXN9fXJlc2l6ZShlKXtpZih0aGlzLnZpZXdwb3J0V2lkdGg9ZS52aWV3cG9ydFdpZHRoLHRoaXMudmlld3BvcnRIZWlnaHQ9ZS52aWV3cG9ydEhlaWdodCx0aGlzLnJlbmRlclRhcmdldCYmdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZSh0aGlzLnZpZXdwb3J0V2lkdGgsdGhpcy52aWV3cG9ydEhlaWdodCksdGhpcy5kZXZpY2VQaXhlbFJhdGlvPWUuZGV2aWNlUGl4ZWxSYXRpbz8/MSx0aGlzLmlzTW9iaWxlPWUuaXNNb2JpbGU/PyExLHRoaXMudmlld1dpZHRoPXRoaXMuY29tcHV0ZVZpZXdXaWR0aChnciksdGhpcy5jYW1lcmE9dGhpcy5jcmVhdGVDYW1lcmEoKSx0aGlzLnJlbmRlcmVyLnNldFBpeGVsUmF0aW8oTWF0aC5taW4odGhpcy5kZXZpY2VQaXhlbFJhdGlvfHwxLHRoaXMuaXNNb2JpbGU/MToxLjUpKSx0aGlzLnJlbmRlcmVyLnNldFNpemUodGhpcy52aWV3cG9ydFdpZHRoLHRoaXMudmlld3BvcnRIZWlnaHQsITEpLHRoaXMuYWN0aXZlRWZmZWN0Py5vblJlc2l6ZSl0aGlzLmFjdGl2ZUVmZmVjdC5vblJlc2l6ZSh0aGlzLnZpZXdXaWR0aCx0aGlzLnZpZXdIZWlnaHQsdGhpcy5pc01vYmlsZSx0aGlzLnZpZXdwb3J0V2lkdGgsdGhpcy52aWV3cG9ydEhlaWdodCksdGhpcy5hY3RpdmVFZmZlY3Quc2V0U25vd1N1cmZhY2VzPy4odGhpcy5zbm93U3VyZmFjZXMpO2Vsc2UgaWYodGhpcy5jdXJyZW50RWZmZWN0IT09Im5vbmUiKXtjb25zdCB0PXRoaXMuY3VycmVudEVmZmVjdDt0aGlzLmN1cnJlbnRFZmZlY3Q9Im5vbmUiLHRoaXMuc2V0RWZmZWN0KHQpfX1kZXN0cm95KCl7dGhpcy5zdG9wKCksdGhpcy5yZW5kZXJUYXJnZXQmJih0aGlzLnJlbmRlclRhcmdldC5kaXNwb3NlKCksdGhpcy5yZW5kZXJUYXJnZXQ9bnVsbCksdGhpcy5tYXNrUXVhZD8ubWF0ZXJpYWwmJnRoaXMubWFza1F1YWQubWF0ZXJpYWwuZGlzcG9zZSgpLHRoaXMubWFza1NjZW5lPy5jbGVhcigpLHRoaXMucmVuZGVyZXIuZGlzcG9zZSgpLHRoaXMuc2NlbmUuY2xlYXIoKX1zdGFydExvb3AoKXt0aGlzLmFuaW1hdGlvbkZyYW1lPT1udWxsJiYodGhpcy5sYXN0VGltZXN0YW1wPTAsdGhpcy5hbmltYXRpb25GcmFtZT1Jcyh0aGlzLnJlbmRlckxvb3ApKX1zdG9wTG9vcCgpe3RoaXMuYW5pbWF0aW9uRnJhbWUhPW51bGwmJihZdSh0aGlzLmFuaW1hdGlvbkZyYW1lKSx0aGlzLmFuaW1hdGlvbkZyYW1lPW51bGwpfXJlbmRlckZyYW1lKGUpe3RoaXMubGFzdFRpbWVzdGFtcD09PTAmJih0aGlzLmxhc3RUaW1lc3RhbXA9ZSk7Y29uc3QgdD1NYXRoLm1pbigoZS10aGlzLmxhc3RUaW1lc3RhbXApLzFlMywuMDUpO3RoaXMubGFzdFRpbWVzdGFtcD1lLHRoaXMuYWN0aXZlRWZmZWN0Py51cGRhdGUodCxlLzFlMyx0aGlzLmVmZmVjdEV4dHJhcyksdGhpcy5zbW9nT3ZlcmxheT8udXBkYXRlKHQpLHRoaXMud2luZG93RHJvcGxldHNPdmVybGF5Py51cGRhdGUodCksdGhpcy5saWdodG5pbmdPdmVybGF5Py51cGRhdGUodCxlLzFlMyx0aGlzLmVmZmVjdEV4dHJhcyksdGhpcy5hdXJvcmFPdmVybGF5Py51cGRhdGUodCk7Y29uc3QgaT10aGlzLmVmZmVjdEV4dHJhcy5zcGF0aWFsTW9kZT09PSJncmFkaWVudC1tYXNrIjtpJiYodGhpcy5lbnN1cmVHcmFkaWVudE1hc2tQYXNzKCksdGhpcy5yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUYXJnZXQpKSx0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLHRoaXMuY2FtZXJhKSxpJiYodGhpcy5yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCksdGhpcy5tYXNrUXVhZC5tYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZT10aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMubWFza1NjZW5lLHRoaXMubWFza0NhbWVyYSkpLHRoaXMuYW5pbWF0aW9uRnJhbWU9SXModGhpcy5yZW5kZXJMb29wKX1lbnN1cmVHcmFkaWVudE1hc2tQYXNzKCl7aWYodGhpcy5yZW5kZXJUYXJnZXQpcmV0dXJuO3RoaXMucmVuZGVyVGFyZ2V0PW5ldyBKdCh0aGlzLnZpZXdwb3J0V2lkdGgsdGhpcy52aWV3cG9ydEhlaWdodCx7bWluRmlsdGVyOjEwMDYsbWFnRmlsdGVyOjEwMDYsZm9ybWF0OjEwMjMsdHlwZToxMDA5LHN0ZW5jaWxCdWZmZXI6ITF9KSx0aGlzLm1hc2tDYW1lcmE9bmV3IHJyKC0xLDEsMSwtMSwwLDEpLHRoaXMubWFza1NjZW5lPW5ldyBEcztjb25zdCBlPW5ldyBldCgyLDIpLHQ9bmV3IGx0KHt1bmlmb3Jtczp7dERpZmZ1c2U6e3ZhbHVlOm51bGx9LHVJbm5lcjp7dmFsdWU6LjMyfSx1T3V0ZXI6e3ZhbHVlOi44NX19LHZlcnRleFNoYWRlcjoidmFyeWluZyB2ZWMyIHZVdjsgdm9pZCBtYWluKCkgeyB2VXYgPSB1djsgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTsgfSIsZnJhZ21lbnRTaGFkZXI6YAogICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlOwogICAgICAgIHVuaWZvcm0gZmxvYXQgdUlubmVyOwogICAgICAgIHVuaWZvcm0gZmxvYXQgdU91dGVyOwogICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7CiAgICAgICAgdm9pZCBtYWluKCkgewogICAgICAgICAgdmVjNCB0ZXggPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdik7CiAgICAgICAgICB2ZWMyIGMgPSB2VXYgLSAwLjU7CiAgICAgICAgICBmbG9hdCBkID0gbGVuZ3RoKGMpICogMi4wOwogICAgICAgICAgZmxvYXQgbWFzayA9IHNtb290aHN0ZXAodUlubmVyLCB1T3V0ZXIsIGQpOwogICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh0ZXgucmdiLCB0ZXguYSAqIG1hc2spOwogICAgICAgIH0KICAgICAgYCx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExfSk7dGhpcy5tYXNrUXVhZD1uZXcgdHQoZSx0KSx0aGlzLm1hc2tTY2VuZS5hZGQodGhpcy5tYXNrUXVhZCl9c2V0RWZmZWN0KGUpe2lmKHRoaXMuZGlzcG9zZUFjdGl2ZUVmZmVjdCgpLHRoaXMuY3VycmVudEVmZmVjdD1lLGU9PT0ibm9uZSIpe3RoaXMuc3RvcExvb3AoKTtyZXR1cm59Y29uc3QgdD10aGlzLmNyZWF0ZUVmZmVjdEluc3RhbmNlKGUpO2lmKCF0KXt0aGlzLnN0b3BMb29wKCksdGhpcy5jdXJyZW50RWZmZWN0PSJub25lIjtyZXR1cm59dGhpcy5hY3RpdmVFZmZlY3Q9dCx0aGlzLmFjdGl2ZUVmZmVjdC5zZXRPcGFjaXR5KHRoaXMub3BhY2l0eSksdGhpcy5zbm93U3VyZmFjZXMubGVuZ3RoJiZ0aGlzLmFjdGl2ZUVmZmVjdC5zZXRTbm93U3VyZmFjZXMmJnRoaXMuYWN0aXZlRWZmZWN0LnNldFNub3dTdXJmYWNlcyh0aGlzLnNub3dTdXJmYWNlcyksdGhpcy5zY2VuZS5hZGQodC5ncm91cCksdGhpcy5sYXN0QXBwbGllZEV4dHJhcz17Li4udGhpcy5lZmZlY3RFeHRyYXN9LHRoaXMudXBkYXRlU21vZ092ZXJsYXkoKSx0aGlzLnVwZGF0ZVdpbmRvd0Ryb3BsZXRzT3ZlcmxheSgpLHRoaXMudXBkYXRlTGlnaHRuaW5nT3ZlcmxheSgpLHRoaXMudXBkYXRlQXVyb3JhT3ZlcmxheSgpLHRoaXMuc3RhcnRMb29wKCl9ZGlzcG9zZUFjdGl2ZUVmZmVjdCgpe3RoaXMuYWN0aXZlRWZmZWN0JiYodGhpcy5zY2VuZS5yZW1vdmUodGhpcy5hY3RpdmVFZmZlY3QuZ3JvdXApLHRoaXMuYWN0aXZlRWZmZWN0LmRpc3Bvc2UoKSx0aGlzLmFjdGl2ZUVmZmVjdD1udWxsKX1jcmVhdGVFZmZlY3RJbnN0YW5jZShlKXtjb25zdCB0PXt2aWV3V2lkdGg6dGhpcy52aWV3V2lkdGgsdmlld0hlaWdodDp0aGlzLnZpZXdIZWlnaHQsdmlld3BvcnRXaWR0aDp0aGlzLnZpZXdwb3J0V2lkdGgsdmlld3BvcnRIZWlnaHQ6dGhpcy52aWV3cG9ydEhlaWdodCxpc01vYmlsZTp0aGlzLmlzTW9iaWxlLGVmZmVjdDplLG9wYWNpdHk6dGhpcy5vcGFjaXR5LHNub3dBY2N1bXVsYXRpb246ISF0aGlzLmVmZmVjdEV4dHJhcy5zbm93QWNjdW11bGF0aW9uLHNub3dTdXJmYWNlczp0aGlzLnNub3dTdXJmYWNlcyxtYXRyaXhSYWluQ29sb3I6dGhpcy5lZmZlY3RFeHRyYXMubWF0cml4UmFpbkNvbG9yLG1vb25Qb3NpdGlvbjp0aGlzLmVmZmVjdEV4dHJhcy5tb29uUG9zaXRpb24sd2luZEJlYXJpbmc6dGhpcy5lZmZlY3RFeHRyYXMud2luZEJlYXJpbmcsd2luZFNwZWVkS21oOnRoaXMuZWZmZWN0RXh0cmFzLndpbmRTcGVlZEttaCx3aW5kU3dheUZhY3Rvcjp0aGlzLmVmZmVjdEV4dHJhcy53aW5kU3dheUZhY3RvcixyYWluTWF4VGlsdERlZzp0aGlzLmVmZmVjdEV4dHJhcy5yYWluTWF4VGlsdERlZyxyYWluV2luZE1pbkttaDp0aGlzLmVmZmVjdEV4dHJhcy5yYWluV2luZE1pbkttaCxzdW5Qb3NpdGlvbjp0aGlzLmVmZmVjdEV4dHJhcy5zdW5Qb3NpdGlvbixjbG91ZENvdmVyYWdlOnRoaXMuZWZmZWN0RXh0cmFzLmNsb3VkQ292ZXJhZ2UscHJlY2lwaXRhdGlvbk11bHRpcGxpZXI6dGhpcy5lZmZlY3RFeHRyYXMucHJlY2lwaXRhdGlvbk11bHRpcGxpZXI/PzEsdGhlbWVNb2RlOnRoaXMuZWZmZWN0RXh0cmFzLnRoZW1lTW9kZT8/ImRhcmsiLGNsb3VkU3BlZWRNdWx0aXBsaWVyOnRoaXMuZWZmZWN0RXh0cmFzLmNsb3VkU3BlZWRNdWx0aXBsaWVyPz8xLGVmZmVjdE9wYWNpdHk6dGhpcy5lZmZlY3RFeHRyYXMuZWZmZWN0T3BhY2l0eXx8e319O3JldHVybiBlPT09ImxpZ2h0bmluZyI/R3ModCk6ZT09PSJzdW5fYmVhbXMiP21oKHQpOmU9PT0ic3RhcnMiP2FoKHQpOmU9PT0ibWF0cml4Ij9yaCh0KTplPT09ImNsb3VkcyI/Z2godCk6ZT09PSJoYWlsIj9faCh0KTplLnN0YXJ0c1dpdGgoInJhaW4iKT9qdSh0KTplPT09InNub3dfbGF5ZXJlZCI/ZWgodCk6ZS5zdGFydHNXaXRoKCJzbm93Iik/UXUodCk6ZS5zdGFydHNXaXRoKCJmb2ciKT9waCh0KTpudWxsfX1mdW5jdGlvbiBadShuLGUpe2NvbnN0IHQ9ZT8uNjoxO3JldHVybiBuPT09InJhaW5fc3Rvcm0iP3tjb3VudDpNYXRoLmZsb29yKDYwMCp0KSxsZW5ndGg6e21pbjoxLjEsbWF4OjEuNX0sc3BlZWQ6e21pbjoxLjQsbWF4OjEuOX0sdGltZVNjYWxlOjEuMixsaWdodG5pbmc6ITAsbGlnaHRuaW5nT25seTohMX06bj09PSJyYWluX2RyaXp6bGUiP3tjb3VudDpNYXRoLmZsb29yKDI1MCp0KSxsZW5ndGg6e21pbjouNixtYXg6Ljl9LHNwZWVkOnttaW46LjMsbWF4Oi42fSx0aW1lU2NhbGU6LjYsbGlnaHRuaW5nOiExLGxpZ2h0bmluZ09ubHk6ITF9Ontjb3VudDpNYXRoLmZsb29yKDQ4MCp0KSxsZW5ndGg6e21pbjouOSxtYXg6MS4yfSxzcGVlZDp7bWluOjEsbWF4OjEuM30sdGltZVNjYWxlOjEsbGlnaHRuaW5nOiExLGxpZ2h0bmluZ09ubHk6ITF9fWZ1bmN0aW9uIGp1KG4pe2NvbnN0IGU9bmV3IGR0LHQ9WnUobi5lZmZlY3Qsbi5pc01vYmlsZSksaT10LmNvdW50LHI9bmV3IGV0KC4wNiwxKSxzPW5ldyBGcztzLmluZGV4PXIuaW5kZXgscy5hdHRyaWJ1dGVzLnBvc2l0aW9uPXIuYXR0cmlidXRlcy5wb3NpdGlvbixzLmF0dHJpYnV0ZXMudXY9ci5hdHRyaWJ1dGVzLnV2LHMuaW5zdGFuY2VDb3VudD1pO2NvbnN0IG89bmV3IEZsb2F0MzJBcnJheShpKjMpLGE9bmV3IEZsb2F0MzJBcnJheShpKSxsPW5ldyBGbG9hdDMyQXJyYXkoaSksYz1uZXcgRmxvYXQzMkFycmF5KGkpLHU9bmV3IEZsb2F0MzJBcnJheShpKTtmb3IobGV0IF89MDtfPGk7XysrKXtjb25zdCBDPV8qMztvW0NdPSRlLnJhbmRGbG9hdFNwcmVhZChuLnZpZXdXaWR0aCsxMCksb1tDKzFdPSRlLnJhbmRGbG9hdFNwcmVhZChuLnZpZXdIZWlnaHQpLG9bQysyXT1NYXRoLnJhbmRvbSgpKi41LGFbX109JGUucmFuZEZsb2F0KHQuc3BlZWQubWluLHQuc3BlZWQubWF4KSxsW19dPSRlLnJhbmRGbG9hdCh0Lmxlbmd0aC5taW4sdC5sZW5ndGgubWF4KSxjW19dPSRlLnJhbmRGbG9hdCguNSwxLjUpLHVbX109TWF0aC5yYW5kb20oKX1zLnNldEF0dHJpYnV0ZSgiaW5zdGFuY2VPZmZzZXQiLG5ldyBHdChvLDMpKSxzLnNldEF0dHJpYnV0ZSgiaW5zdGFuY2VTcGVlZCIsbmV3IEd0KGEsMSkpLHMuc2V0QXR0cmlidXRlKCJpbnN0YW5jZUxlbmd0aCIsbmV3IEd0KGwsMSkpLHMuc2V0QXR0cmlidXRlKCJpbnN0YW5jZVN3YXkiLG5ldyBHdChjLDEpKSxzLnNldEF0dHJpYnV0ZSgiaW5zdGFuY2VQaGFzZSIsbmV3IEd0KHUsMSkpO2NvbnN0IGQ9bi5yYWluV2luZE1pbkttaD8/MyxmPW4ud2luZFN3YXlGYWN0b3I/Py43LHA9bi53aW5kU3BlZWRLbWg/PzUsZz0obi53aW5kQmVhcmluZz8/MjcwKSpNYXRoLlBJLzE4MDtsZXQgeD0wO3A+PWQmJih4PS1NYXRoLnNpbihnKSpwKi4wNipmKTtjb25zdCBtPXgqLjE1LGg9e3VUaW1lOnt2YWx1ZTowfSx1T3BhY2l0eTp7dmFsdWU6bi5vcGFjaXR5LzEwMH0sdVZpZXdTaXplOnt2YWx1ZTpuZXcgUGUobi52aWV3V2lkdGgsbi52aWV3SGVpZ2h0KX0sdVdpbmRTd2F5Ont2YWx1ZTptfX0sVD1uZXcgbHQoe3VuaWZvcm1zOmgsdmVydGV4U2hhZGVyOmAKICAgICAgYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VPZmZzZXQ7CiAgICAgIGF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVNwZWVkOwogICAgICBhdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VMZW5ndGg7CiAgICAgIGF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVN3YXk7CiAgICAgIGF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVBoYXNlOwogICAgICB1bmlmb3JtIGZsb2F0IHVUaW1lOwogICAgICB1bmlmb3JtIHZlYzIgdVZpZXdTaXplOwogICAgICB1bmlmb3JtIGZsb2F0IHVXaW5kU3dheTsKICAgICAgdmFyeWluZyBmbG9hdCB2QWxwaGE7CiAgICAgIHZvaWQgbWFpbigpIHsKICAgICAgICBmbG9hdCBwcm9ncmVzcyA9IGZyYWN0KHVUaW1lICogaW5zdGFuY2VTcGVlZCArIGluc3RhbmNlUGhhc2UpOwogICAgICAgIGZsb2F0IHRyYXZlbCA9ICh1Vmlld1NpemUueSAqIDAuNSkgLSBwcm9ncmVzcyAqICh1Vmlld1NpemUueSArIDIwLjApOwogICAgICAgIHZlYzMgdHJhbnNmb3JtZWQgPSBwb3NpdGlvbjsKICAgICAgICB0cmFuc2Zvcm1lZC55ICo9IGluc3RhbmNlTGVuZ3RoOwogICAgICAgIHRyYW5zZm9ybWVkLnggKz0gaW5zdGFuY2VPZmZzZXQueCArIHNpbihwcm9ncmVzcyAqIDYuMjgzMTggKyBpbnN0YW5jZVBoYXNlKSAqIGluc3RhbmNlU3dheSArIHVXaW5kU3dheSAqIHByb2dyZXNzICogdVZpZXdTaXplLnk7CiAgICAgICAgdHJhbnNmb3JtZWQueSArPSB0cmF2ZWwgKyBpbnN0YW5jZU9mZnNldC55OwogICAgICAgIHRyYW5zZm9ybWVkLnogKz0gLTUuMCArIGluc3RhbmNlT2Zmc2V0Lno7CiAgICAgICAgdkFscGhhID0gMS4wIC0gcHJvZ3Jlc3M7CiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCh0cmFuc2Zvcm1lZCwgMS4wKTsKICAgICAgfQogICAgYCxmcmFnbWVudFNoYWRlcjpgCiAgICAgIHVuaWZvcm0gZmxvYXQgdU9wYWNpdHk7CiAgICAgIHZhcnlpbmcgZmxvYXQgdkFscGhhOwogICAgICB2b2lkIG1haW4oKSB7CiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjY1LCAwLjc1LCAwLjksIGNsYW1wKHZBbHBoYSAqIDAuODUgKiB1T3BhY2l0eSwgMC4wLCAxLjApKTsKICAgICAgfQogICAgYCx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExLGJsZW5kaW5nOjJ9KSx5PW5ldyB0dChzLFQpO3JldHVybiB5LmZydXN0dW1DdWxsZWQ9ITEsZS5hZGQoeSkse2dyb3VwOmUsdXBkYXRlKF8sQyx3KXtjb25zdCBiPXc/LnByZWNpcGl0YXRpb25NdWx0aXBsaWVyPz8xO2gudVRpbWUudmFsdWUrPV8qdC50aW1lU2NhbGUqYixoLnVWaWV3U2l6ZS52YWx1ZS5zZXQobi52aWV3V2lkdGgsbi52aWV3SGVpZ2h0KX0sc2V0T3BhY2l0eShfKXtoLnVPcGFjaXR5LnZhbHVlPU1hdGgubWF4KDAsTWF0aC5taW4oMSxfLzEwMCkpfSxvblJlc2l6ZShfLEMpe24udmlld1dpZHRoPV8sbi52aWV3SGVpZ2h0PUMsaC51Vmlld1NpemUudmFsdWUuc2V0KF8sQyl9LGRpc3Bvc2UoKXtzLmRpc3Bvc2UoKSxULmRpc3Bvc2UoKX19fWZ1bmN0aW9uIEp1KG4sZSl7Y29uc3QgdD1lPy42OjE7cmV0dXJuIE1hdGguZmxvb3Iobj09PSJzbm93X3N0b3JtIj8xZTMqdDo2MDAqdCl9ZnVuY3Rpb24gUXUobil7Y29uc3QgZT1uZXcgZHQsdD1KdShuLmVmZmVjdCxuLmlzTW9iaWxlKSxpPW5ldyBGbG9hdDMyQXJyYXkodCozKSxyPW5ldyBGbG9hdDMyQXJyYXkodCozKSxzPW4ucmFpbldpbmRNaW5LbWg/PzMsbz1uLndpbmRTd2F5RmFjdG9yPz8uNyxhPW4ud2luZFNwZWVkS21oPz81LGw9KG4ud2luZEJlYXJpbmc/PzI3MCkqTWF0aC5QSS8xODAsYz1hPj1zPy1NYXRoLnNpbihsKSphKi4wNipvKi44OjA7Zm9yKGxldCBoPTA7aDx0O2grKyl7Y29uc3QgVD1oKjM7aVtUXT0kZS5yYW5kRmxvYXRTcHJlYWQobi52aWV3V2lkdGgrMzApLGlbVCsxXT0kZS5yYW5kRmxvYXRTcHJlYWQobi52aWV3SGVpZ2h0KzMwKSxpW1QrMl09TWF0aC5yYW5kb20oKSo0LTIscltUXT0kZS5yYW5kRmxvYXQoLS4yLC4yKStjLHJbVCsxXT1uLmVmZmVjdD09PSJzbm93X3N0b3JtIj8kZS5yYW5kRmxvYXQoLTEuNCwtLjkpOiRlLnJhbmRGbG9hdCgtLjgsLS40KSxyW1QrMl09JGUucmFuZEZsb2F0KC0uMDUsLjA1KX1jb25zdCB1PW5ldyBDdDt1LnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBTdChpLDMpKTtjb25zdCBkPU5zKCksZj1uLmVmZmVjdD09PSJzbm93X3N0b3JtIj8uOTouNzUsZz1uLnRoZW1lTW9kZT09PSJsaWdodCI/MTY3NzcyMTU6MTUyNjcwNzEseD1uZXcgUmkoe21hcDpkLHRyYW5zcGFyZW50OiEwLG9wYWNpdHk6Zioobi5vcGFjaXR5LzEwMCksc2l6ZUF0dGVudWF0aW9uOiExLHNpemU6bi5lZmZlY3Q9PT0ic25vd19zdG9ybSI/My40OjIuNixjb2xvcjpnLGRlcHRoV3JpdGU6ITEsZGVwdGhUZXN0OiExLGJsZW5kaW5nOjJ9KSxtPW5ldyBtcih1LHgpO3JldHVybiBtLmZydXN0dW1DdWxsZWQ9ITEsZS5hZGQobSkse2dyb3VwOmUsdXBkYXRlKGgpe2NvbnN0IFQ9dS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O2ZvcihsZXQgeT0wO3k8VC5sZW5ndGg7eSs9Myl7VFt5XSs9clt5XSpoKjI1LFRbeSsxXSs9clt5KzFdKmgqMjUsVFt5KzJdKz1yW3krMl0qaCoxMDtjb25zdCBfPW4udmlld1dpZHRoLzIrMTUsQz1uLnZpZXdIZWlnaHQvMisxNTtUW3krMV08LUMmJihUW3krMV09QyxUW3ldPSRlLnJhbmRGbG9hdFNwcmVhZChuLnZpZXdXaWR0aCszMCkpLFRbeV08LV8mJihUW3ldPV8pLFRbeV0+XyYmKFRbeV09LV8pfXUuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZT0hMH0sc2V0T3BhY2l0eShoKXt4Lm9wYWNpdHk9ZipNYXRoLm1heCgwLE1hdGgubWluKDEsaC8xMDApKX0sb25SZXNpemUoaCxUKXtuLnZpZXdXaWR0aD1oLG4udmlld0hlaWdodD1UfSxkaXNwb3NlKCl7dS5kaXNwb3NlKCkseC5kaXNwb3NlKCksZC5kaXNwb3NlKCl9fX1jb25zdCBPcz1be3NpemVNaW46MjQsc2l6ZU1heDo0MCxzcGVlZEZhY3RvcjouMTIsc3dheUFtcE1pbjoxMCxzd2F5QW1wTWF4OjMwLG9wYWNpdHk6MSxjb2xvck1pbjoyNTUsY29sb3JNYXg6MjU1fSx7c2l6ZU1pbjoyMCxzaXplTWF4OjI4LHNwZWVkRmFjdG9yOi4wOSxzd2F5QW1wTWluOjEwLHN3YXlBbXBNYXg6MjUsb3BhY2l0eTouODUsY29sb3JNaW46MjU1LGNvbG9yTWF4OjI1NX0se3NpemVNaW46MTYsc2l6ZU1heDoyNCxzcGVlZEZhY3RvcjouMDcsc3dheUFtcE1pbjoxMCxzd2F5QW1wTWF4OjIwLG9wYWNpdHk6Ljc1LGNvbG9yTWluOjI1NSxjb2xvck1heDoyNTV9LHtzaXplTWluOjEyLHNpemVNYXg6MTgsc3BlZWRGYWN0b3I6LjA1LHN3YXlBbXBNaW46MTAsc3dheUFtcE1heDoyMCxvcGFjaXR5Oi42NSxjb2xvck1pbjoyMjAsY29sb3JNYXg6MjI5fSx7c2l6ZU1pbjoxMCxzaXplTWF4OjE0LHNwZWVkRmFjdG9yOi4wMyxzd2F5QW1wTWluOjEwLHN3YXlBbXBNYXg6MjAsb3BhY2l0eTouNTUsY29sb3JNaW46MjEwLGNvbG9yTWF4OjIxOX0se3NpemVNaW46OCxzaXplTWF4OjEyLHNwZWVkRmFjdG9yOi4wMSxzd2F5QW1wTWluOjEwLHN3YXlBbXBNYXg6MjAsb3BhY2l0eTouNCxjb2xvck1pbjoyMDAsY29sb3JNYXg6MjA5fV07ZnVuY3Rpb24gZWgobil7Y29uc3QgZT1uZXcgZHQ7bGV0IHQ9bi5pc01vYmlsZT8xODA6MzAwO2NvbnN0IGk9TWF0aC5mbG9vcih0L09zLmxlbmd0aCkscj1OcygpLHM9bi5yYWluV2luZE1pbkttaD8/MyxvPW4ud2luZFN3YXlGYWN0b3I/Py43LGE9bi53aW5kU3BlZWRLbWg/PzUsbD0obi53aW5kQmVhcmluZz8/MjcwKSpNYXRoLlBJLzE4MCxjPWE+PXM/LU1hdGguc2luKGwpKmEqLjA2Km8qLjEyOjAsdT1Pcy5tYXAoZD0+e2NvbnN0IGY9bmV3IEZsb2F0MzJBcnJheShpKjMpLHA9bmV3IEZsb2F0MzJBcnJheShpKSxnPW5ldyBGbG9hdDMyQXJyYXkoaSkseD1uZXcgRmxvYXQzMkFycmF5KGkpLG09bmV3IEZsb2F0MzJBcnJheShpKTtmb3IobGV0IEM9MDtDPGk7QysrKXtjb25zdCB3PUMqMyxiPWQuc2l6ZU1pbitNYXRoLnJhbmRvbSgpKihkLnNpemVNYXgtZC5zaXplTWluKTtmW3ddPSRlLnJhbmRGbG9hdFNwcmVhZChuLnZpZXdXaWR0aCsyMCksZlt3KzFdPSRlLnJhbmRGbG9hdFNwcmVhZChuLnZpZXdIZWlnaHQrMjApLGZbdysyXT1NYXRoLnJhbmRvbSgpKjItMSxwW0NdPWIqZC5zcGVlZEZhY3RvciouMTUrTWF0aC5yYW5kb20oKSouMDIsZ1tDXT1kLnN3YXlBbXBNaW4rTWF0aC5yYW5kb20oKSooZC5zd2F5QW1wTWF4LWQuc3dheUFtcE1pbikseFtDXT1NYXRoLnJhbmRvbSgpKk1hdGguUEkqMixtW0NdPS4wMStNYXRoLnJhbmRvbSgpKi4wMn1jb25zdCBoPW5ldyBDdDtoLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBTdChmLDMpKTtjb25zdCBUPShkLnNpemVNaW4rZC5zaXplTWF4KS8yLHk9bmV3IFJpKHttYXA6cix0cmFuc3BhcmVudDohMCxvcGFjaXR5OmQub3BhY2l0eSoobi5vcGFjaXR5LzEwMCksc2l6ZUF0dGVudWF0aW9uOiExLHNpemU6VCouMTUsY29sb3I6MTY3NzcyMTUsZGVwdGhXcml0ZTohMSxkZXB0aFRlc3Q6ITEsYmxlbmRpbmc6Mn0pLF89bmV3IG1yKGgseSk7cmV0dXJuIF8uZnJ1c3R1bUN1bGxlZD0hMSxlLmFkZChfKSx7Z2VvOmgsbWF0OnksZmFsbFNwZWVkczpwLHN3YXlBbXBzOmcsc3dheU9mZnNldHM6eCxzd2F5U3BlZWRzOm0sYmFzZU9wYWNpdHk6ZC5vcGFjaXR5fX0pO3JldHVybntncm91cDplLHVwZGF0ZShkKXt1LmZvckVhY2goZj0+e2NvbnN0IHA9Zi5nZW8uYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheSxnPWQqNjA7Zm9yKGxldCB4PTA7eDxwLmxlbmd0aC8zO3grKyl7Y29uc3QgbT14KjM7Zi5zd2F5T2Zmc2V0c1t4XSs9Zi5zd2F5U3BlZWRzW3hdO2NvbnN0IGg9TWF0aC5zaW4oZi5zd2F5T2Zmc2V0c1t4XSkqZi5zd2F5QW1wc1t4XSouMDg7cFttXSs9KGgrYykqZyxwW20rMV0tPWYuZmFsbFNwZWVkc1t4XSpnO2NvbnN0IFQ9bi52aWV3V2lkdGgvMisxNSx5PW4udmlld0hlaWdodC8yKzE1O3BbbSsxXTwteSYmKHBbbSsxXT15LHBbbV09JGUucmFuZEZsb2F0U3ByZWFkKG4udmlld1dpZHRoKzIwKSkscFttXTwtVCYmKHBbbV09VCkscFttXT5UJiYocFttXT0tVCl9Zi5nZW8uYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZT0hMH0pfSxzZXRPcGFjaXR5KGQpe2NvbnN0IGY9TWF0aC5tYXgoMCxNYXRoLm1pbigxLGQvMTAwKSk7dS5mb3JFYWNoKHA9PntwLm1hdC5vcGFjaXR5PXAuYmFzZU9wYWNpdHkqZn0pfSxvblJlc2l6ZShkLGYpe24udmlld1dpZHRoPWQsbi52aWV3SGVpZ2h0PWZ9LGRpc3Bvc2UoKXt1LmZvckVhY2goZD0+e2QuZ2VvLmRpc3Bvc2UoKSxkLm1hdC5kaXNwb3NlKCl9KSxyLmRpc3Bvc2UoKX19fWNvbnN0IEJzPVsi5ZySIiwi6L+OIiwi57ChIiwi55uKIiwi5aSnIiwi6K+2Iiwi5q+UIiwi6KW/Iiwi6L+qIiwi5LyKIiwi5byXIiwi5ZCJIiwi5bC6Iiwi5p2wIiwi5byAIiwi6Im+Iiwi5YuSIiwi6amsIiwi5aicIl0sdGg9IiMwMGZmNDEiLG5oPSIjMDBjYzMzIixpaD04NTtmdW5jdGlvbiByaChuKXtjb25zdCBlPW5ldyBkdCx0PU1hdGgubWF4KDI1NixNYXRoLmZsb29yKG4udmlld3BvcnRXaWR0aC8yKSksaT1NYXRoLm1heCgyNTYsTWF0aC5mbG9vcihuLnZpZXdwb3J0SGVpZ2h0LzIpKSx7Y2FudmFzOnIsY3R4OnN9PUxpKHQsaSksbz1VaShyKTtvLm1pbkZpbHRlcj0xMDA2LG8ubWFnRmlsdGVyPTEwMDY7Y29uc3QgYT1uZXcgZXQobi52aWV3V2lkdGgsbi52aWV3SGVpZ2h0KSxsPW5ldyBqbih7bWFwOm8sdHJhbnNwYXJlbnQ6ITAsb3BhY2l0eTouOSoobi5vcGFjaXR5LzEwMCksZGVwdGhXcml0ZTohMX0pLGM9bmV3IHR0KGEsbCk7ZS5hZGQoYyk7Y29uc3QgdT1bXTtsZXQgZD0wO3JldHVybntncm91cDplLHVwZGF0ZShmKXtjb25zdCBwPXIud2lkdGgsZz1yLmhlaWdodCx4PXAvbi52aWV3cG9ydFdpZHRoO2QrPWYqMWUzO2NvbnN0IG09Zy8zLGg9dS5zb21lKF89Pl8ueT5tKTtpZigodS5sZW5ndGg9PT0wfHxoKSYmZD49LjgmJnUubGVuZ3RoPDYpe2Q9MDtjb25zdCBfPXAqLjI4LEM9cCouNzI7bGV0IHc9MTUsYjtkb3tiPU1hdGgucmFuZG9tKCk8LjU/MzArTWF0aC5yYW5kb20oKSooXy02MCk6QyszMCtNYXRoLnJhbmRvbSgpKihwLUMtNjApO2NvbnN0IEU9aWgqKHAvbi52aWV3cG9ydFdpZHRoKTtpZighdS5zb21lKFI9Pk1hdGguYWJzKFIueC1iKTxFKSlicmVha313aGlsZSgtLXc+MCk7aWYodz4wKXtjb25zdCBGPTQrTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjgpO3UucHVzaCh7eDpiLHk6LTgwLGNoYXJzOkFycmF5LmZyb20oe2xlbmd0aDpGfSwoKT0+QnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKkJzLmxlbmd0aCldKSxzcGVlZDooLjE1K01hdGgucmFuZG9tKCkqLjEyKSp4fSl9fXMuZmlsbFN0eWxlPSJyZ2JhKDAsMCwwLDAuMDgpIixzLmZpbGxSZWN0KDAsMCxwLGcpLHMuZm9udD1gJHtNYXRoLm1heCgxMiwxNip4KX1weCBtb25vc3BhY2VgLHMudGV4dEFsaWduPSJjZW50ZXIiLHMudGV4dEJhc2VsaW5lPSJ0b3AiO2NvbnN0IHk9cC8yO2ZvcihsZXQgXz11Lmxlbmd0aC0xO18+PTA7Xy0tKXtjb25zdCBDPXVbX107aWYoQy55Kz1DLnNwZWVkLEMueT5nKzE1MCl7dS5zcGxpY2UoXywxKTtjb250aW51ZX1jb25zdCB3PU1hdGguYWJzKEMueC15KSxiPXc8cCouMj8uNSt3LyhwKi4yKSouNDouOSxGPTE2Kng7Zm9yKGxldCBFPTA7RTxDLmNoYXJzLmxlbmd0aDtFKyspe2NvbnN0IFM9MS1FL0MuY2hhcnMubGVuZ3RoKi41O3MuZ2xvYmFsQWxwaGE9UypiLHMuZmlsbFN0eWxlPUU9PT0wP3RoOm5oLHMuZmlsbFRleHQoQy5jaGFyc1tFXSxDLngsQy55K0UqRil9cy5nbG9iYWxBbHBoYT0xfW8ubmVlZHNVcGRhdGU9ITB9LHNldE9wYWNpdHkoZil7bC5vcGFjaXR5PS45Kk1hdGgubWF4KDAsTWF0aC5taW4oMSxmLzEwMCkpfSxvblJlc2l6ZShmLHApe24udmlld1dpZHRoPWYsbi52aWV3SGVpZ2h0PXAsYy5nZW9tZXRyeS5kaXNwb3NlKCksYy5nZW9tZXRyeT1uZXcgZXQoZixwKX0sZGlzcG9zZSgpe2EuZGlzcG9zZSgpLGwuZGlzcG9zZSgpLG8uZGlzcG9zZSgpfX19ZnVuY3Rpb24gc2gobil7cmV0dXJuIE1hdGguZmxvb3Iobj80MDAqLjY6NDAwKX1mdW5jdGlvbiBhaChuKXtjb25zdCBlPW4uZWZmZWN0T3BhY2l0eT8ubW9vbj8/MSx0PW4uZWZmZWN0T3BhY2l0eT8uc3RhcnM/PzEsaT1uZXcgZHQscj1zaChuLmlzTW9iaWxlKSxzPW5ldyBGbG9hdDMyQXJyYXkociozKSxvPW4ubW9vblBvc2l0aW9uO2ZvcihsZXQgcD0wO3A8cjtwKyspe2NvbnN0IGc9cCozO3NbZ109JGUucmFuZEZsb2F0U3ByZWFkKG4udmlld1dpZHRoKzIwKSxzW2crMV09JGUucmFuZEZsb2F0U3ByZWFkKG4udmlld0hlaWdodCsyMCksc1tnKzJdPU1hdGgucmFuZG9tKCkqMi0xfWNvbnN0IGE9bmV3IEN0O2Euc2V0QXR0cmlidXRlKCJwb3NpdGlvbiIsbmV3IFN0KHMsMykpO2NvbnN0IGw9JHUoKSxjPW5ldyBSaSh7bWFwOmwsdHJhbnNwYXJlbnQ6ITAsb3BhY2l0eTouODUqKG4ub3BhY2l0eS8xMDApKnQsc2l6ZUF0dGVudWF0aW9uOiExLHNpemU6Mixjb2xvcjoxNTI2NzA3MSxkZXB0aFdyaXRlOiExLGRlcHRoVGVzdDohMSxibGVuZGluZzoyfSksdT1uZXcgbXIoYSxjKTt1LmZydXN0dW1DdWxsZWQ9ITEsaS5hZGQodSk7bGV0IGQ9bnVsbDtpZihvJiZ0eXBlb2Ygby54PT0ibnVtYmVyIiYmdHlwZW9mIG8ueT09Im51bWJlciIpe2NvbnN0IHA9KG8ueC0uNSkqbi52aWV3V2lkdGgsZz0oLjUtby55KSpuLnZpZXdIZWlnaHQseD1NYXRoLm1heChuLnZpZXdXaWR0aCxuLnZpZXdIZWlnaHQpKi4yLG09bmV3IGV0KHgseCksaD1uZXcgbHQoe3VuaWZvcm1zOnt1T3BhY2l0eTp7dmFsdWU6LjE4KihuLm9wYWNpdHkvMTAwKSplfX0sdmVydGV4U2hhZGVyOiJ2YXJ5aW5nIHZlYzIgdlV2OyB2b2lkIG1haW4oKSB7IHZVdiA9IHV2OyBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApOyB9IixmcmFnbWVudFNoYWRlcjpgCiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjsKICAgICAgICB1bmlmb3JtIGZsb2F0IHVPcGFjaXR5OwogICAgICAgIHZvaWQgbWFpbigpIHsKICAgICAgICAgIHZlYzIgYyA9IHZVdiAtIDAuNTsKICAgICAgICAgIGZsb2F0IGQgPSBsZW5ndGgoYykgKiAyLjA7CiAgICAgICAgICBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAoMS41LCAwLjEsIGQpICogdU9wYWNpdHk7CiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuOTYsIDAuOTcsIDEuMCwgYWxwaGEpOwogICAgICAgIH0KICAgICAgYCx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExLGJsZW5kaW5nOjJ9KTtkPW5ldyB0dChtLGgpLGQucG9zaXRpb24uc2V0KHAsZywtMSksZC5yZW5kZXJPcmRlcj0xLGkuYWRkKGQpfWxldCBmPTA7cmV0dXJue2dyb3VwOmksdXBkYXRlKHApe2YrPXAqMS4yLGMub3BhY2l0eT0uODUqKG4ub3BhY2l0eS8xMDApKnQqKC44Ky4yKk1hdGguc2luKGYpKX0sc2V0T3BhY2l0eShwKXtjb25zdCBnPU1hdGgubWF4KDAsTWF0aC5taW4oMSxwLzEwMCkpO2Mub3BhY2l0eT0uODUqZyp0LGQmJihkLm1hdGVyaWFsLnVuaWZvcm1zLnVPcGFjaXR5LnZhbHVlPS4xOCpnKmUpfSxvblJlc2l6ZShwLGcpe24udmlld1dpZHRoPXAsbi52aWV3SGVpZ2h0PWd9LGRpc3Bvc2UoKXthLmRpc3Bvc2UoKSxjLmRpc3Bvc2UoKSxsLmRpc3Bvc2UoKSxkJiYoZC5nZW9tZXRyeS5kaXNwb3NlKCksZC5tYXRlcmlhbC5kaXNwb3NlKCkpfX19Y29uc3Qgb2g9NTU7ZnVuY3Rpb24gbGgobil7Y29uc3QgZT1uLnZpZXdXaWR0aCx0PW4udmlld0hlaWdodCx7Y2FudmFzOmksY3R4OnJ9PUxpKE1hdGgubWF4KDI1NixNYXRoLmZsb29yKG4udmlld3BvcnRXaWR0aC8yKSksTWF0aC5tYXgoMjU2LE1hdGguZmxvb3Iobi52aWV3cG9ydEhlaWdodC8yKSkpLHM9VWkoaSk7cy5taW5GaWx0ZXI9MTAwNixzLm1hZ0ZpbHRlcj0xMDA2O2NvbnN0IG89bmV3IGV0KGUsdCksYT1uZXcgam4oe21hcDpzLHRyYW5zcGFyZW50OiEwLG9wYWNpdHk6Ljk1KihuLm9wYWNpdHkvMTAwKSxkZXB0aFdyaXRlOiExfSksbD1uZXcgdHQobyxhKTtsLnJlbmRlck9yZGVyPTU7Y29uc3QgYz1uZXcgZHQ7Yy5hZGQobCk7Y29uc3QgdT1bXTtsZXQgZD0wLGY9MDtmdW5jdGlvbiBwKHgsbSxoKXtmb3IoY29uc3QgVCBvZiB1KXtjb25zdCB5PXgtVC54LF89bS1ULnksQz1vaCsoaCtULnNpemUpKi41O2lmKHkqeStfKl88QypDKXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIGcoKXtyZXR1cm4gMjIwMCtNYXRoLnJhbmRvbSgpKjI4MDB9cmV0dXJue2dyb3VwOmMsdXBkYXRlKHgpe2NvbnN0IG09aS53aWR0aCxoPWkuaGVpZ2h0LFQ9TWF0aC5taW4oeCoxZTMsNTApO2lmKGQrPVQsZjw9MCYmKGY9ZygpKSxkPj1mKXtkPTAsZj1nKCk7Y29uc3QgeT0uMTgsXz1tKnksQz1tKigxLXkpLHc9TWF0aC5yYW5kb20oKTwuNT8ibGVmdCI6InJpZ2h0IixiPTQrTWF0aC5yYW5kb20oKSo2O2xldCBGLEUsUz0xMjtkbyBGPXc9PT0ibGVmdCI/TWF0aC5yYW5kb20oKSpfOkMrTWF0aC5yYW5kb20oKSoobS1DKSxFPU1hdGgucmFuZG9tKCkqaCouNTU7d2hpbGUoLS1TPjAmJnAoRixFLGIpKTtTPjAmJnUucHVzaCh7eDpGLHk6RSxzaXplOmIscGhhc2U6ImFwcGVhciIsb3BhY2l0eTowLGxpZmU6MCxhcHBlYXJEdXI6MzAwLHJlc3REdXI6MmUzK01hdGgucmFuZG9tKCkqMjUwMCxzbGlkZVZlbDo4K01hdGgucmFuZG9tKCkqNixzbGlkZUFjY2VsOi44K01hdGgucmFuZG9tKCkqLjZ9KX1yLmNsZWFyUmVjdCgwLDAsbSxoKTtmb3IobGV0IHk9dS5sZW5ndGgtMTt5Pj0wO3ktLSl7Y29uc3QgXz11W3ldO2lmKF8ubGlmZSs9VCxfLnBoYXNlPT09ImFwcGVhciIpXy5vcGFjaXR5PU1hdGgubWluKDEsXy5saWZlL18uYXBwZWFyRHVyKjEuOCksXy5saWZlPj1fLmFwcGVhckR1ciYmKF8ucGhhc2U9InJlc3QiLF8ubGlmZT0wLF8ub3BhY2l0eT0xKTtlbHNlIGlmKF8ucGhhc2U9PT0icmVzdCIpXy5saWZlPj1fLnJlc3REdXImJihfLnBoYXNlPSJzbGlkZSIsXy5saWZlPTApO2Vsc2V7Y29uc3QgQz1ULzFlMztfLnNsaWRlVmVsPShfLnNsaWRlVmVsfHw4KStfLnNsaWRlQWNjZWwqQyo2MCxfLnkrPV8uc2xpZGVWZWwqQztjb25zdCB3PV8ueS9oO2lmKF8ub3BhY2l0eT13PC44NT8xOk1hdGgubWF4KDAsKDEtdykvLjE1KSxfLnk+aCtfLnNpemUqMil7dS5zcGxpY2UoeSwxKTtjb250aW51ZX19aWYoXy55PD1oK18uc2l6ZSoyKXtyLnNhdmUoKSxyLmdsb2JhbEFscGhhPV8ub3BhY2l0eTtjb25zdCBDPXIuY3JlYXRlUmFkaWFsR3JhZGllbnQoXy54LV8uc2l6ZSouMyxfLnktXy5zaXplKi4zLDAsXy54LF8ueSxfLnNpemUqMS41KTtDLmFkZENvbG9yU3RvcCgwLCJyZ2JhKDIzMCwgMjQwLCAyNTUsIDAuNDIpIiksQy5hZGRDb2xvclN0b3AoLjQsInJnYmEoMjAwLCAyMTgsIDI0MiwgMC4yOCkiKSxDLmFkZENvbG9yU3RvcCguNzUsInJnYmEoMTcwLCAxOTAsIDIxNSwgMC4xMikiKSxDLmFkZENvbG9yU3RvcCgxLCJyZ2JhKDE1MCwgMTcwLCAxOTUsIDApIiksci5maWxsU3R5bGU9QyxyLmJlZ2luUGF0aCgpLHIuZWxsaXBzZShfLngsXy55LF8uc2l6ZSouNSxfLnNpemUqMS4xLDAsMCxNYXRoLlBJKjIpLHIuZmlsbCgpO2NvbnN0IHc9ci5jcmVhdGVSYWRpYWxHcmFkaWVudChfLngtXy5zaXplKi4yNSxfLnktXy5zaXplKi40LDAsXy54LV8uc2l6ZSouMjUsXy55LV8uc2l6ZSouNCxfLnNpemUqLjYpO3cuYWRkQ29sb3JTdG9wKDAsYHJnYmEoMjU1LDI1NSwyNTUsJHsuMzIqXy5vcGFjaXR5fSlgKSx3LmFkZENvbG9yU3RvcCguNTUsYHJnYmEoMjU1LDI1NSwyNTUsJHsuMSpfLm9wYWNpdHl9KWApLHcuYWRkQ29sb3JTdG9wKDEsInJnYmEoMjU1LDI1NSwyNTUsMCkiKSxyLmZpbGxTdHlsZT13LHIuYmVnaW5QYXRoKCksci5lbGxpcHNlKF8ueC1fLnNpemUqLjIsXy55LV8uc2l6ZSouMzUsXy5zaXplKi4zNSxfLnNpemUqLjQsMCwwLE1hdGguUEkqMiksci5maWxsKCksci5yZXN0b3JlKCl9fXMubmVlZHNVcGRhdGU9ITB9LHNldE9wYWNpdHkoeCl7Y29uc3QgbT1uLmVmZmVjdEV4dHJhcz8uZWZmZWN0T3BhY2l0eT8uZHJvcGxldHM/PzE7YS5vcGFjaXR5PS45NSpNYXRoLm1heCgwLE1hdGgubWluKDEseC8xMDApKSptfSxkaXNwb3NlKCl7by5kaXNwb3NlKCksYS5kaXNwb3NlKCkscy5kaXNwb3NlKCl9fX1mdW5jdGlvbiBjaChuKXtjb25zdCBlPW4udmlld1dpZHRoLHQ9bi52aWV3SGVpZ2h0LGk9bi5lZmZlY3RFeHRyYXM/LmVmZmVjdE9wYWNpdHk/LnNtb2c/PzEscj1uZXcgZXQoZSx0KSxzPXt1VGltZTp7dmFsdWU6MH0sdU9wYWNpdHk6e3ZhbHVlOi4xOCoobi5vcGFjaXR5LzEwMCkqaX0sdVNjYWxlOnt2YWx1ZToxLjR9LHVSZXNvbHV0aW9uOnt2YWx1ZTpuZXcgUGUoZSx0KX19LG89bmV3IGx0KHt1bmlmb3JtczpzLHZlcnRleFNoYWRlcjpfcixmcmFnbWVudFNoYWRlcjpgCiAgICAgIHZhcnlpbmcgdmVjMiB2VXY7CiAgICAgIHVuaWZvcm0gZmxvYXQgdVRpbWU7CiAgICAgIHVuaWZvcm0gZmxvYXQgdU9wYWNpdHk7CiAgICAgIHVuaWZvcm0gZmxvYXQgdVNjYWxlOwogICAgICB1bmlmb3JtIHZlYzIgdVJlc29sdXRpb247CiAgICAgIGZsb2F0IGhhc2godmVjMiBwKSB7IHJldHVybiBmcmFjdChzaW4oZG90KHAsIHZlYzIoMTI3LjEsIDMxMS43KSkpICogNDM3NTguNTQ1Myk7IH0KICAgICAgZmxvYXQgbm9pc2UodmVjMiBwKSB7CiAgICAgICAgdmVjMiBpID0gZmxvb3IocCk7CiAgICAgICAgdmVjMiBmID0gZnJhY3QocCk7CiAgICAgICAgdmVjMiB1ID0gZiAqIGYgKiAoMy4wIC0gMi4wICogZik7CiAgICAgICAgcmV0dXJuIG1peChtaXgoaGFzaChpKSwgaGFzaChpICsgdmVjMigxLDApKSwgdS54KSwgbWl4KGhhc2goaSArIHZlYzIoMCwxKSksIGhhc2goaSArIHZlYzIoMSwxKSksIHUueCksIHUueSk7CiAgICAgIH0KICAgICAgZmxvYXQgZmJtKHZlYzIgcCkgewogICAgICAgIGZsb2F0IHYgPSAwLjAsIGFtcCA9IDAuNTsKICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDQ7IGkrKykgewogICAgICAgICAgdiArPSBhbXAgKiBub2lzZShwKTsKICAgICAgICAgIHAgKj0gMi4wOwogICAgICAgICAgYW1wICo9IDAuNTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHY7CiAgICAgIH0KICAgICAgdm9pZCBtYWluKCkgewogICAgICAgIHZlYzIgYXNwZWN0ID0gdmVjMih1UmVzb2x1dGlvbi54IC8gbWF4KHVSZXNvbHV0aW9uLnksIDAuMDAwMSksIDEuMCk7CiAgICAgICAgdmVjMiB1diA9ICh2VXYgLSAwLjUpICogYXNwZWN0ICsgMC41OwogICAgICAgIHV2ICo9IHVTY2FsZTsKICAgICAgICB1diArPSB2ZWMyKDAuMDE1LCAwLjA2KSAqIHVUaW1lOwogICAgICAgIGZsb2F0IGQgPSBmYm0odXYpOwogICAgICAgIGQgPSBzbW9vdGhzdGVwKDAuMiwgMC42NSwgZCk7CiAgICAgICAgZmxvYXQgdk1hc2sgPSBzbW9vdGhzdGVwKDAuODUsIDAuMjUsIHZVdi55KTsKICAgICAgICB2ZWMzIGNvbG9yID0gdmVjMygwLjU1LCAwLjUyLCAwLjQ4KTsKICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCBkICogdk1hc2sgKiB1T3BhY2l0eSk7CiAgICAgIH0KICAgIGAsdHJhbnNwYXJlbnQ6ITAsZGVwdGhXcml0ZTohMSxibGVuZGluZzoxfSksYT1uZXcgdHQocixvKTthLnJlbmRlck9yZGVyPTEwO2NvbnN0IGw9bmV3IGR0O3JldHVybiBsLmFkZChhKSx7Z3JvdXA6bCx1cGRhdGUoYyl7cy51VGltZS52YWx1ZSs9YyouMTV9LHNldE9wYWNpdHkoYyl7Y29uc3QgdT1uLmVmZmVjdEV4dHJhcz8uZWZmZWN0T3BhY2l0eT8uc21vZz8/MTtzLnVPcGFjaXR5LnZhbHVlPS4xOCpNYXRoLm1heCgwLE1hdGgubWluKDEsYy8xMDApKSp1fSxkaXNwb3NlKCl7ci5kaXNwb3NlKCksby5kaXNwb3NlKCl9fX1mdW5jdGlvbiB1aChuLGUpe2NvbnN0IHQ9bi52aWV3V2lkdGgsaT1uLnZpZXdIZWlnaHQscj1uLmVmZmVjdEV4dHJhcz8uZWZmZWN0T3BhY2l0eT8uYXVyb3JhPz8xLHM9bmV3IGV0KHQqMS4yLGkqMS4yKSxvPXt1VGltZTp7dmFsdWU6MH0sdU9wYWNpdHk6e3ZhbHVlOi41KihlfHwuNSkqKG4ub3BhY2l0eS8xMDApKnJ9LHVSZXNvbHV0aW9uOnt2YWx1ZTpuZXcgUGUodCxpKX19LGE9bmV3IGx0KHt1bmlmb3JtczpvLHZlcnRleFNoYWRlcjpgCiAgICAgIHZhcnlpbmcgdmVjMiB2VXY7CiAgICAgIHZvaWQgbWFpbigpIHsKICAgICAgICB2VXYgPSB1djsKICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApOwogICAgICB9CiAgICBgLGZyYWdtZW50U2hhZGVyOmAKICAgICAgdmFyeWluZyB2ZWMyIHZVdjsKICAgICAgdW5pZm9ybSBmbG9hdCB1VGltZTsKICAgICAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTsKICAgICAgdW5pZm9ybSB2ZWMyIHVSZXNvbHV0aW9uOwogICAgICBmbG9hdCBoYXNoKHZlYzIgcCkgeyByZXR1cm4gZnJhY3Qoc2luKGRvdChwLCB2ZWMyKDEyNy4xLCAzMTEuNykpKSAqIDQzNzU4LjU0NTMpOyB9CiAgICAgIGZsb2F0IG5vaXNlKHZlYzIgcCkgewogICAgICAgIHZlYzIgaSA9IGZsb29yKHApOyB2ZWMyIGYgPSBmcmFjdChwKTsKICAgICAgICB2ZWMyIHUgPSBmICogZiAqICgzLjAgLSAyLjAgKiBmKTsKICAgICAgICByZXR1cm4gbWl4KG1peChoYXNoKGkpLCBoYXNoKGkrdmVjMigxLDApKSwgdS54KSwgbWl4KGhhc2goaSt2ZWMyKDAsMSkpLCBoYXNoKGkrdmVjMigxLDEpKSwgdS54KSwgdS55KTsKICAgICAgfQogICAgICBmbG9hdCBmYm0odmVjMiBwKSB7CiAgICAgICAgZmxvYXQgdiA9IDAuMCwgYW1wID0gMC41OwogICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgNDsgaSsrKSB7IHYgKz0gYW1wICogbm9pc2UocCk7IHAgKj0gMi4wOyBhbXAgKj0gMC41OyB9CiAgICAgICAgcmV0dXJuIHY7CiAgICAgIH0KICAgICAgdmVjMyBncmFkaWVudChmbG9hdCB0KSB7CiAgICAgICAgdmVjMyBhID0gdmVjMygwLjM4LCAwLjY1LCAwLjk4KTsKICAgICAgICB2ZWMzIGIgPSB2ZWMzKDAuOTEsIDAuNDcsIDAuOTgpOwogICAgICAgIHZlYzMgYyA9IHZlYzMoMC4zNywgMC45MiwgMC44Myk7CiAgICAgICAgaWYgKHQgPCAwLjIpIHJldHVybiBtaXgoYSwgYiwgc21vb3Roc3RlcCgwLjAsIDAuMiwgdCkpOwogICAgICAgIGlmICh0IDwgMC40KSByZXR1cm4gbWl4KGIsIGEsIHNtb290aHN0ZXAoMC4yLCAwLjQsIHQpKTsKICAgICAgICBpZiAodCA8IDAuNikgcmV0dXJuIG1peChhLCBjLCBzbW9vdGhzdGVwKDAuNCwgMC42LCB0KSk7CiAgICAgICAgaWYgKHQgPCAwLjgpIHJldHVybiBtaXgoYywgYSwgc21vb3Roc3RlcCgwLjYsIDAuOCwgdCkpOwogICAgICAgIHJldHVybiBtaXgoYSwgYiwgc21vb3Roc3RlcCgwLjgsIDEuMCwgdCkpOwogICAgICB9CiAgICAgIHZvaWQgbWFpbigpIHsKICAgICAgICB2ZWMyIHV2ID0gdlV2OwogICAgICAgIGZsb2F0IG4gPSBmYm0odXYgKiAyLjUgKyB1VGltZSAqIDAuMDIpICogMC4wNjsKICAgICAgICBmbG9hdCB0ID0gZnJhY3QodXYueCAqIDAuNSArICgxLjAgLSB1di55KSAqIDAuNSArIHVUaW1lICogMC4wMSArIG4pOwogICAgICAgIHZlYzMgY29sID0gZ3JhZGllbnQodCk7CiAgICAgICAgdmVjMiBmcm9tVG9wID0gdXYgLSB2ZWMyKDAuNSwgMS4wKTsKICAgICAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGZyb21Ub3ApICogMS42OwogICAgICAgIGZsb2F0IG1hc2sgPSAxLjAgLSBzbW9vdGhzdGVwKDAuMTUsIDEuMCwgZGlzdCk7CiAgICAgICAgbWFzayA9IG1hc2sgKiBtYXNrOwogICAgICAgIGZsb2F0IGFscGhhID0gbWFzayAqIHVPcGFjaXR5ICogKDAuOTQgKyAwLjA2ICogZmJtKHV2ICogNC4wKSk7CiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2wsIGFscGhhKTsKICAgICAgfQogICAgYCx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExLGJsZW5kaW5nOjJ9KSxsPW5ldyB0dChzLGEpO2wucG9zaXRpb24uc2V0KDAsMCwtOSksbC5yZW5kZXJPcmRlcj05O2NvbnN0IGM9bmV3IGR0O2MuYWRkKGwpO2xldCB1PWV8fC41O2NvbnN0IGQ9KCk9Pntjb25zdCBmPW4uZWZmZWN0RXh0cmFzPy5lZmZlY3RPcGFjaXR5Py5hdXJvcmE/PzEscD0uNSp1Kk1hdGgubWF4KDAsTWF0aC5taW4oMSxuLm9wYWNpdHkvMTAwKSkqZjtvLnVPcGFjaXR5LnZhbHVlPXB9O3JldHVybntncm91cDpjLHVwZGF0ZShmKXtvLnVUaW1lLnZhbHVlKz1mfSxzZXRPcGFjaXR5KCl7ZCgpfSxzZXRWaXNpYmlsaXR5U2NvcmUoZil7dT1mfHwuNSxkKCl9LGRpc3Bvc2UoKXtzLmRpc3Bvc2UoKSxhLmRpc3Bvc2UoKX19fWNvbnN0IHZyPVt7d2lkdGg6MSxjb2xvckE6WzcxLzI1NSw2MC8yNTUsMTIwLzI1NV0sY29sb3JCOlsyNDcvMjU1LDQyLzI1NSw1OS8yNTVdLHNwZWVkOjEuMjZ9LHt3aWR0aDouOSxjb2xvckE6WzI0LzI1NSwxOTYvMjU1LDE1My8yNTVdLGNvbG9yQjpbMjE2LzI1NSwyNDAvMjU1LDk0LzI1NV0sc3BlZWQ6MS41N30se3dpZHRoOi44LGNvbG9yQTpbMjU1LzI1NSwyMjEvMjU1LDAvMjU1XSxjb2xvckI6WzYyLzI1NSw1MS8yNTUsMjU1LzI1NV0sc3BlZWQ6Mi4wOX0se3dpZHRoOi43LGNvbG9yQTpbMTIwLzI1NSwyNC8yNTUsNzIvMjU1XSxjb2xvckI6WzI0Mi8yNTUsMTg3LzI1NSwyMzMvMjU1XSxzcGVlZDozLjE0fSx7d2lkdGg6LjYsY29sb3JBOls2Ni8yNTUsMjQyLzI1NSwxNjEvMjU1XSxjb2xvckI6WzI0NC8yNTUsMjQ2LzI1NSwxNzMvMjU1XSxzcGVlZDo2LjI4fV07ZnVuY3Rpb24gaGgobixlLHQpe2lmKHQ9PT0ibm9ydGhlcm4tZ3JhZGllbnRzIilyZXR1cm4gdWgobixlKTtjb25zdCBpPW4udmlld1dpZHRoLHI9bi52aWV3SGVpZ2h0LHM9bi5lZmZlY3RFeHRyYXM/LmVmZmVjdE9wYWNpdHk/LmF1cm9yYT8/MSxvPTI4LGE9ci8yLTgsbD1uZXcgZHQsYz1gCiAgICB2YXJ5aW5nIHZlYzIgdlV2OwogICAgdm9pZCBtYWluKCkgewogICAgICB2VXYgPSB1djsKICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTsKICAgIH0KICBgLHU9YAogICAgdmFyeWluZyB2ZWMyIHZVdjsKICAgIHVuaWZvcm0gZmxvYXQgdVRpbWU7CiAgICB1bmlmb3JtIGZsb2F0IHVPcGFjaXR5OwogICAgdW5pZm9ybSB2ZWMzIHVDb2xvckE7CiAgICB1bmlmb3JtIHZlYzMgdUNvbG9yQjsKICAgIHVuaWZvcm0gZmxvYXQgdVNwZWVkOwogICAgdW5pZm9ybSBmbG9hdCB1UHVsc2VQaGFzZTsKICAgIHZvaWQgbWFpbigpIHsKICAgICAgZmxvYXQgdCA9IDAuNSArIDAuNSAqIHNpbih1VGltZSAqIHVTcGVlZCk7CiAgICAgIHZlYzMgY29sID0gbWl4KHVDb2xvckEsIHVDb2xvckIsIHQpOwogICAgICBmbG9hdCBmcm9tVG9wID0gMS4wIC0gdlV2Lnk7CiAgICAgIGZsb2F0IGZhZGUgPSBzbW9vdGhzdGVwKDAuMCwgMC40LCBmcm9tVG9wKSAqIHNtb290aHN0ZXAoMS4xNSwgMC4zNSwgZnJvbVRvcCk7CiAgICAgIGZsb2F0IHB1bHNlID0gMC45NiArIDAuMDQgKiBzaW4odVRpbWUgKiAwLjggKyB1UHVsc2VQaGFzZSk7CiAgICAgIGZsb2F0IGFscGhhID0gZmFkZSAqIHVPcGFjaXR5ICogcHVsc2U7CiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sLCBhbHBoYSk7CiAgICB9CiAgYDtmb3IobGV0IGc9MDtnPHZyLmxlbmd0aDtnKyspe2NvbnN0IHg9dnJbZ10sbT1pKjEuMDUsaD1vLFQ9bmV3IGV0KG0saCkseT1nL3ZyLmxlbmd0aCo2LjI4LF89e3VUaW1lOnt2YWx1ZTowfSx1T3BhY2l0eTp7dmFsdWU6LjI4KihlfHwuNSkqKG4ub3BhY2l0eS8xMDApKnN9LHVDb2xvckE6e3ZhbHVlOm5ldyBPKCkuZnJvbUFycmF5KHguY29sb3JBKX0sdUNvbG9yQjp7dmFsdWU6bmV3IE8oKS5mcm9tQXJyYXkoeC5jb2xvckIpfSx1U3BlZWQ6e3ZhbHVlOnguc3BlZWQqLjR9LHVQdWxzZVBoYXNlOnt2YWx1ZTp5fX0sQz1uZXcgbHQoe3VuaWZvcm1zOl8sdmVydGV4U2hhZGVyOmMsZnJhZ21lbnRTaGFkZXI6dSx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExLGJsZW5kaW5nOjJ9KSx3PW5ldyB0dChULEMpO3cucG9zaXRpb24uc2V0KDAsYS1nKihvKzYpLC04KSx3LnJlbmRlck9yZGVyPTksbC5hZGQodyl9bGV0IGQ9ZXx8LjU7Y29uc3QgZj1sLmNoaWxkcmVuLHA9KCk9Pntjb25zdCBnPW4uZWZmZWN0RXh0cmFzPy5lZmZlY3RPcGFjaXR5Py5hdXJvcmE/PzEseD0uMjgqZCpNYXRoLm1heCgwLE1hdGgubWluKDEsbi5vcGFjaXR5LzEwMCkpKmc7Zm9yKGNvbnN0IG0gb2YgZiltLm1hdGVyaWFsLnVuaWZvcm1zLnVPcGFjaXR5LnZhbHVlPXh9O3JldHVybntncm91cDpsLHVwZGF0ZShnKXtmb3IoY29uc3QgeCBvZiBmKXgubWF0ZXJpYWwudW5pZm9ybXMudVRpbWUudmFsdWUrPWd9LHNldE9wYWNpdHkoKXtwKCl9LHNldFZpc2liaWxpdHlTY29yZShnKXtkPWd8fC41LHAoKX0sZGlzcG9zZSgpe2Zvcihjb25zdCBnIG9mIGYpZy5nZW9tZXRyeS5kaXNwb3NlKCksZy5tYXRlcmlhbC5kaXNwb3NlKCl9fX1jb25zdCB6cz0yMDA7ZnVuY3Rpb24gZGgobixlKXtjb25zdCB0PW49PT0iZm9nX2RlbnNlIixpPXQ/LjMyOi4yMixyPWU/Ljg1OjEscz10P1t7c2NhbGU6Mi4yKnIsc3BlZWQ6LjI4LGludGVuc2l0eToxLGZsb3c6bmV3IFBlKC4wOCwuMDIpLGxvdzouMjUsaGlnaDouNzgsY29udHJhc3Q6MS4xLGNvbG9yOlsuODYsLjg5LC45NV19LHtzY2FsZToyLjgqcixzcGVlZDouMzYsaW50ZW5zaXR5Oi44NSxmbG93Om5ldyBQZSgtLjA1LC4wMjUpLGxvdzouMixoaWdoOi43LGNvbnRyYXN0OjEuMjIsY29sb3I6Wy45LC45MiwuOTddfV06W3tzY2FsZToyLjUqcixzcGVlZDouMjIsaW50ZW5zaXR5Oi43NSxmbG93Om5ldyBQZSguMDUsLjAxNSksbG93Oi4zLGhpZ2g6LjgyLGNvbnRyYXN0OjEuMTUsY29sb3I6Wy44OCwuOTEsLjk2XX0se3NjYWxlOjMuMipyLHNwZWVkOi4zLGludGVuc2l0eTouNTUsZmxvdzpuZXcgUGUoLS4wMywuMDEyKSxsb3c6LjI1LGhpZ2g6Ljc1LGNvbnRyYXN0OjEuMjIsY29sb3I6Wy44LC44NCwuOTJdfV07cmV0dXJue2Jhc2VPcGFjaXR5OmksbGF5ZXJzOnN9fWNvbnN0IGZoPWAKICB2YXJ5aW5nIHZlYzIgdlV2OwogIHVuaWZvcm0gZmxvYXQgdVRpbWU7CiAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTsKICB1bmlmb3JtIGZsb2F0IHVTY2FsZTsKICB1bmlmb3JtIHZlYzIgdUZsb3c7CiAgdW5pZm9ybSB2ZWMyIHVSZXNvbHV0aW9uOwogIHVuaWZvcm0gZmxvYXQgdUxvdzsKICB1bmlmb3JtIGZsb2F0IHVIaWdoOwogIHVuaWZvcm0gZmxvYXQgdUNvbnRyYXN0OwogIHVuaWZvcm0gdmVjMyB1Q29sb3I7CiAgZmxvYXQgaGFzaCh2ZWMyIHApIHsgcmV0dXJuIGZyYWN0KHNpbihkb3QocCwgdmVjMigxMjcuMSwgMzExLjcpKSkgKiA0Mzc1OC41NDUzMTIzKTsgfQogIGZsb2F0IG5vaXNlKHZlYzIgcCkgewogICAgdmVjMiBpID0gZmxvb3IocCk7CiAgICB2ZWMyIGYgPSBmcmFjdChwKTsKICAgIHZlYzIgdSA9IGYgKiBmICogKDMuMCAtIDIuMCAqIGYpOwogICAgcmV0dXJuIG1peCgKICAgICAgbWl4KGhhc2goaSksIGhhc2goaSArIHZlYzIoMSwwKSksIHUueCksCiAgICAgIG1peChoYXNoKGkgKyB2ZWMyKDAsMSkpLCBoYXNoKGkgKyB2ZWMyKDEsMSkpLCB1LngpLCB1LnkpOwogIH0KICBmbG9hdCBmYm0odmVjMiBwKSB7CiAgICBmbG9hdCB2ID0gMC4wLCBhbXAgPSAwLjU7CiAgICBmb3IgKGludCBpID0gMDsgaSA8IDU7IGkrKykgewogICAgICB2ICs9IGFtcCAqIG5vaXNlKHApOwogICAgICBwICo9IDIuMDsKICAgICAgYW1wICo9IDAuNTsKICAgIH0KICAgIHJldHVybiB2OwogIH0KICB2b2lkIG1haW4oKSB7CiAgICB2ZWMyIGFzcGVjdCA9IHZlYzIodVJlc29sdXRpb24ueCAvIG1heCh1UmVzb2x1dGlvbi55LCAwLjAwMDEpLCAxLjApOwogICAgdmVjMiB1diA9ICh2VXYgLSAwLjUpICogYXNwZWN0ICsgMC41OwogICAgdXYgKj0gdVNjYWxlOwogICAgdXYgKz0gdUZsb3cgKiB1VGltZTsKICAgIGZsb2F0IHByaW1hcnkgPSBmYm0odXYpOwogICAgZmxvYXQgZGV0YWlsID0gZmJtKHV2ICogMS44IC0gdUZsb3cueXggKiAodVRpbWUgKiAwLjM1KSk7CiAgICBmbG9hdCBkZW5zaXR5ID0gbWl4KHByaW1hcnksIGRldGFpbCwgMC4zNSk7CiAgICBkZW5zaXR5ID0gc21vb3Roc3RlcCh1TG93LCB1SGlnaCwgZGVuc2l0eSk7CiAgICBkZW5zaXR5ID0gcG93KGRlbnNpdHksIHVDb250cmFzdCk7CiAgICBmbG9hdCB2TWFzayA9IDEuMCAtIHNtb290aHN0ZXAoMC4wLCAxLjAsIHZVdi55KTsKICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodUNvbG9yLCBkZW5zaXR5ICogdk1hc2sgKiB1T3BhY2l0eSk7CiAgfQpgO2Z1bmN0aW9uIHBoKG4pe2NvbnN0IGU9bmV3IGR0LHQ9ZGgobi5lZmZlY3Qsbi5pc01vYmlsZSksaT1uLmNsb3VkQ292ZXJhZ2Uscj1pIT1udWxsPy42K2kvMTAwKi41OjEscz1uLmVmZmVjdE9wYWNpdHk/LmZvZz8/MSxvPU1hdGgubWluKHpzLG4udmlld0hlaWdodCouMjUpLGE9LW4udmlld0hlaWdodC8yK28vMixsPXQubGF5ZXJzLm1hcChjPT57Y29uc3QgdT1uZXcgZXQobi52aWV3V2lkdGgsbyksZD17dVRpbWU6e3ZhbHVlOjB9LHVPcGFjaXR5Ont2YWx1ZTp0LmJhc2VPcGFjaXR5KmMuaW50ZW5zaXR5KihuLm9wYWNpdHkvMTAwKSpyKnN9LHVTY2FsZTp7dmFsdWU6Yy5zY2FsZX0sdUZsb3c6e3ZhbHVlOmMuZmxvdy5jbG9uZSgpfSx1UmVzb2x1dGlvbjp7dmFsdWU6bmV3IFBlKG4udmlld1dpZHRoLG4udmlld0hlaWdodCl9LHVMb3c6e3ZhbHVlOmMubG93fSx1SGlnaDp7dmFsdWU6Yy5oaWdofSx1Q29udHJhc3Q6e3ZhbHVlOmMuY29udHJhc3R9LHVDb2xvcjp7dmFsdWU6bmV3IFZlKGMuY29sb3JbMF0sYy5jb2xvclsxXSxjLmNvbG9yWzJdKX19LGY9bmV3IGx0KHt1bmlmb3JtczpkLHZlcnRleFNoYWRlcjpfcixmcmFnbWVudFNoYWRlcjpmaCx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExLGJsZW5kaW5nOjF9KSxwPW5ldyB0dCh1LGYpO3JldHVybiBwLnBvc2l0aW9uLnNldCgwLGEsMCkscC5yZW5kZXJPcmRlcj0tMyxlLmFkZChwKSx7bWVzaDpwLHVuaWZvcm1zOmQsY29uZmlnOmN9fSk7cmV0dXJue2dyb3VwOmUsdXBkYXRlKGMpe2wuZm9yRWFjaCh1PT57dS51bmlmb3Jtcy51VGltZS52YWx1ZSs9Yyp1LmNvbmZpZy5zcGVlZH0pfSxzZXRPcGFjaXR5KGMpe2NvbnN0IHU9TWF0aC5tYXgoMCxNYXRoLm1pbigxLGMvMTAwKSksZD1uLmlzTW9iaWxlPy43NToxO2wuZm9yRWFjaChmPT57Zi51bmlmb3Jtcy51T3BhY2l0eS52YWx1ZT10LmJhc2VPcGFjaXR5KmYuY29uZmlnLmludGVuc2l0eSp1KmQqcipzfSl9LG9uUmVzaXplKGMsdSl7bi52aWV3V2lkdGg9YyxuLnZpZXdIZWlnaHQ9dTtjb25zdCBkPU1hdGgubWluKHpzLHUqLjI1KSxmPS11LzIrZC8yO2wuZm9yRWFjaChwPT57cC51bmlmb3Jtcy51UmVzb2x1dGlvbi52YWx1ZS5zZXQoYyx1KSxwLm1lc2guZ2VvbWV0cnkuZGlzcG9zZSgpLHAubWVzaC5nZW9tZXRyeT1uZXcgZXQoYyxkKSxwLm1lc2gucG9zaXRpb24ueT1mfSl9LGRpc3Bvc2UoKXtsLmZvckVhY2goYz0+e2MubWVzaC5nZW9tZXRyeS5kaXNwb3NlKCksYy5tZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKX0pfX19ZnVuY3Rpb24gbWgobil7Y29uc3QgZT1uZXcgZHQsdD1uLmVmZmVjdE9wYWNpdHk/LnN1bj8/MTtsZXQgaT1uZXcgZXQobi52aWV3V2lkdGgsbi52aWV3SGVpZ2h0KTtjb25zdCByPW4uc3VuUG9zaXRpb258fHthemltdXRoOjE4MCxlbGV2YXRpb246NDUsdXZJbmRleDozfSxzPU1hdGgubWF4KDAsTWF0aC5taW4oMSwoci5hemltdXRoLTkwKS8xODApKSxvPS4wOCsuMzUqKDEtTWF0aC5taW4oOTAsTWF0aC5tYXgoMCxyLmVsZXZhdGlvbikpLzkwKSxhPXt1T3BhY2l0eTp7dmFsdWU6bi5vcGFjaXR5LzEwMCp0fSx1Vmlld1NpemU6e3ZhbHVlOm5ldyBQZShuLnZpZXdXaWR0aCxuLnZpZXdIZWlnaHQpfSx1T3JpZ2luOnt2YWx1ZTpuZXcgUGUocyxvKX0sdVV2SW5kZXg6e3ZhbHVlOnIudXZJbmRleH19LGw9bmV3IGx0KHt1bmlmb3JtczphLHZlcnRleFNoYWRlcjoidmFyeWluZyB2ZWMzIHZQb3NpdGlvbjsgdm9pZCBtYWluKCkgeyB2UG9zaXRpb24gPSBwb3NpdGlvbjsgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTsgfSIsZnJhZ21lbnRTaGFkZXI6YAogICAgICB2YXJ5aW5nIHZlYzMgdlBvc2l0aW9uOwogICAgICB1bmlmb3JtIHZlYzIgdVZpZXdTaXplOwogICAgICB1bmlmb3JtIHZlYzIgdU9yaWdpbjsKICAgICAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTsKICAgICAgdW5pZm9ybSBmbG9hdCB1VXZJbmRleDsKICAgICAgdm9pZCBtYWluKCkgewogICAgICAgIHZlYzIgdXYgPSB2ZWMyKCh2UG9zaXRpb24ueCAvIHVWaWV3U2l6ZS54KSArIDAuNSwgKHZQb3NpdGlvbi55IC8gdVZpZXdTaXplLnkpICsgMC41KTsKICAgICAgICB2ZWMyIGRpciA9IHVPcmlnaW4gLSB1djsKICAgICAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGRpcik7CiAgICAgICAgZmxvYXQgaW50ZW5zaXR5ID0gc21vb3Roc3RlcCgwLjg1LCAwLjE1LCBkaXN0KTsKICAgICAgICBmbG9hdCBhbHBoYSA9IGludGVuc2l0eSAqIDAuMjggKiB1T3BhY2l0eTsKICAgICAgICB2ZWMzIGNvbG9yOwogICAgICAgIGlmICh1VXZJbmRleCA+PSA2LjApIHsKICAgICAgICAgIGNvbG9yID0gbWl4KHZlYzMoMS4wLCAwLjUsIDAuMTUpLCB2ZWMzKDEuMCwgMC4zNSwgMC4xKSwgZGlzdCk7CiAgICAgICAgfSBlbHNlIGlmICh1VXZJbmRleCA+PSA0LjApIHsKICAgICAgICAgIGNvbG9yID0gbWl4KHZlYzMoMS4wLCAwLjc1LCAwLjM1KSwgdmVjMygxLjAsIDAuNTUsIDAuMiksIGRpc3QpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb2xvciA9IG1peCh2ZWMzKDEuMCwgMC45NSwgMC44KSwgdmVjMygxLjAsIDAuODUsIDAuNCksIGRpc3QpOwogICAgICAgIH0KICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCBhbHBoYSk7CiAgICAgIH0KICAgIGAsdHJhbnNwYXJlbnQ6ITAsZGVwdGhXcml0ZTohMSxibGVuZGluZzoyfSksYz1uZXcgdHQoaSxsKTtyZXR1cm4gYy5wb3NpdGlvbi5zZXQoMCwwLC0yKSxlLmFkZChjKSx7Z3JvdXA6ZSx1cGRhdGUodSxkLGYpe2lmKGY/LnN1blBvc2l0aW9uKXtjb25zdCBwPWYuc3VuUG9zaXRpb247YS51T3JpZ2luLnZhbHVlLnNldChNYXRoLm1heCgwLE1hdGgubWluKDEsKHAuYXppbXV0aC05MCkvMTgwKSksLjA4Ky4zNSooMS1NYXRoLm1pbig5MCxNYXRoLm1heCgwLHAuZWxldmF0aW9uKSkvOTApKSxhLnVVdkluZGV4LnZhbHVlPXAudXZJbmRleD8/M319LHNldE9wYWNpdHkodSl7YS51T3BhY2l0eS52YWx1ZT1NYXRoLm1heCgwLE1hdGgubWluKDEsdS8xMDApKSp0fSxvblJlc2l6ZSh1LGQpe24udmlld1dpZHRoPXUsbi52aWV3SGVpZ2h0PWQsYS51Vmlld1NpemUudmFsdWUuc2V0KHUsZCksaS5kaXNwb3NlKCksaT1uZXcgZXQodSxkKSxjLmdlb21ldHJ5PWl9LGRpc3Bvc2UoKXtpLmRpc3Bvc2UoKSxsLmRpc3Bvc2UoKX19fWZ1bmN0aW9uIGdoKG4pe2NvbnN0IGU9bmV3IGR0LHQ9LjYsaT1uLmNsb3VkQ292ZXJhZ2Uscj1pIT1udWxsPy41K2kvMTAwKi41OjEscz1uLmVmZmVjdE9wYWNpdHk/LmNsb3Vkcz8/MSxvPW4uY2xvdWRTcGVlZE11bHRpcGxpZXI/PzE7bGV0IGE9bmV3IGV0KG4udmlld1dpZHRoLG4udmlld0hlaWdodCp0KTtjb25zdCBsPXt1VGltZTp7dmFsdWU6MH0sdU9wYWNpdHk6e3ZhbHVlOm4ub3BhY2l0eS8xMDAqLjE0KnIqc30sdVZpZXdTaXplOnt2YWx1ZTpuZXcgUGUobi52aWV3V2lkdGgsbi52aWV3SGVpZ2h0KX0sdVNjYWxlOnt2YWx1ZTpuLmlzTW9iaWxlPzEuNToxfX0sYz1gCiAgICB2YXJ5aW5nIHZlYzIgdlV2OwogICAgdW5pZm9ybSBmbG9hdCB1VGltZTsKICAgIHVuaWZvcm0gZmxvYXQgdU9wYWNpdHk7CiAgICB1bmlmb3JtIGZsb2F0IHVTY2FsZTsKICAgIGZsb2F0IGhhc2godmVjMiBwKSB7IHJldHVybiBmcmFjdChzaW4oZG90KHAsIHZlYzIoMTIuOTg5OCwgNzguMjMzKSkpICogNDM3NTguNTQ1Myk7IH0KICAgIGZsb2F0IG5vaXNlKHZlYzIgcCkgewogICAgICB2ZWMyIGkgPSBmbG9vcihwKTsKICAgICAgdmVjMiBmID0gZnJhY3QocCk7CiAgICAgIHZlYzIgdSA9IGYgKiBmICogKDMuMCAtIDIuMCAqIGYpOwogICAgICByZXR1cm4gbWl4KG1peChoYXNoKGkpLCBoYXNoKGkrdmVjMigxLDApKSwgdS54KSwgbWl4KGhhc2goaSt2ZWMyKDAsMSkpLCBoYXNoKGkrdmVjMigxLDEpKSwgdS54KSwgdS55KTsKICAgIH0KICAgIGZsb2F0IGZibSh2ZWMyIHApIHsKICAgICAgZmxvYXQgdiA9IDAuMCwgYW1wID0gMC41LCBmcmVxID0gMS4wOwogICAgICBmb3IgKGludCBpID0gMDsgaSA8IDY7IGkrKykgewogICAgICAgIHYgKz0gYW1wICogbm9pc2UocCAqIGZyZXEpOwogICAgICAgIGFtcCAqPSAwLjU7CiAgICAgICAgZnJlcSAqPSAyLjA7CiAgICAgIH0KICAgICAgcmV0dXJuIHY7CiAgICB9CiAgICB2b2lkIG1haW4oKSB7CiAgICAgIHZlYzIgdXYgPSB2VXYgKiB1U2NhbGU7CiAgICAgIGZsb2F0IHRpbWUgPSB1VGltZSAqIDAuMDU7CiAgICAgIHZlYzIgcSA9IHZlYzIoZmJtKHV2ICsgdmVjMih0aW1lICogMC41LCB0aW1lICogMC4yKSksIGZibSh1diArIHZlYzIoMS4wKSkpOwogICAgICB2ZWMyIHIgPSB2ZWMyKGZibSh1diArIHEgKyB2ZWMyKDEuNywgOS4yKSArIDAuMTUgKiB0aW1lKSwgZmJtKHV2ICsgcSArIHZlYzIoOC4zLCAyLjgpICsgMC4xMjYgKiB0aW1lKSk7CiAgICAgIGZsb2F0IGYgPSBmYm0odXYgKyByKTsKICAgICAgZmxvYXQgY2xvdWQgPSBzbW9vdGhzdGVwKDAuMiwgMC43LCBmKTsKICAgICAgY2xvdWQgKj0gc21vb3Roc3RlcCgwLjAsIDAuMywgdlV2LnkpOwogICAgICBjbG91ZCAqPSBzbW9vdGhzdGVwKDEuMCwgMC44LCB2VXYueSk7CiAgICAgIGZsb2F0IHNoYWRvdyA9IHNtb290aHN0ZXAoMC4zLCAwLjYsIGZibSh1diAqIDIuMCArIHIgKyB2ZWMyKDAuNSkpKTsKICAgICAgdmVjMyBjb2xvciA9IG1peCh2ZWMzKDAuODEsIDAuODIsIDAuODkpLCB2ZWMzKDEuMCksIHNoYWRvdyAqIDAuOCArIDAuMik7CiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIGNsb3VkICogdU9wYWNpdHkpOwogICAgfQogIGAsdT1uZXcgbHQoe3VuaWZvcm1zOmwsdmVydGV4U2hhZGVyOiJ2YXJ5aW5nIHZlYzIgdlV2OyB2b2lkIG1haW4oKSB7IHZVdiA9IHV2OyBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApOyB9IixmcmFnbWVudFNoYWRlcjpjLHRyYW5zcGFyZW50OiEwLGRlcHRoV3JpdGU6ITEsYmxlbmRpbmc6MX0pLGQ9bmV3IHR0KGEsdSk7cmV0dXJuIGQucG9zaXRpb24uc2V0KDAsbi52aWV3SGVpZ2h0Ki4yNSwtNiksZC5yZW5kZXJPcmRlcj0tMixlLmFkZChkKSx7Z3JvdXA6ZSx1cGRhdGUoZil7bC51VGltZS52YWx1ZSs9ZipvfSxzZXRPcGFjaXR5KGYpe2wudU9wYWNpdHkudmFsdWU9TWF0aC5tYXgoMCxNYXRoLm1pbigxLGYvMTAwKSkqLjE0KnIqc30sb25SZXNpemUoZixwLGcpe2EuZGlzcG9zZSgpLGE9bmV3IGV0KGYscCp0KSxkLmdlb21ldHJ5PWEsbC51Vmlld1NpemUudmFsdWUuc2V0KGYscCksbC51U2NhbGUudmFsdWU9Zz8xLjU6MSxkLnBvc2l0aW9uLnNldCgwLHAqLjI1LC02KX0sZGlzcG9zZSgpe2EuZGlzcG9zZSgpLHUuZGlzcG9zZSgpfX19ZnVuY3Rpb24gR3Mobil7Y29uc3QgZT1uZXcgZHQsdD1gCiAgICB2YXJ5aW5nIHZlYzIgdlV2OwogICAgdW5pZm9ybSBmbG9hdCB1Rmxhc2g7CiAgICB1bmlmb3JtIHZlYzIgdU9yaWdpbjsKICAgIHVuaWZvcm0gZmxvYXQgdVRpbWU7CiAgICBmbG9hdCBoYXNoKGZsb2F0IG4pIHsgcmV0dXJuIGZyYWN0KHNpbihuKSAqIDQzNzU4LjU0NTMpOyB9CiAgICBmbG9hdCBqYWdnZWRMaW5lKHZlYzIgdXYsIGZsb2F0IGFuY2hvciwgZmxvYXQgc2VlZCkgewogICAgICBmbG9hdCBzZWdtZW50cyA9IDguMDsKICAgICAgZmxvYXQgcHJvZ3Jlc3MgPSBjbGFtcCgxLjAgLSB1di55LCAwLjAsIDAuOTk5KSAqIHNlZ21lbnRzOwogICAgICBmbG9hdCBpZHggPSBmbG9vcihwcm9ncmVzcyk7CiAgICAgIGZsb2F0IGZyYWMgPSBmcmFjdChwcm9ncmVzcyk7CiAgICAgIGZsb2F0IG9mZnNldEEgPSBoYXNoKHNlZWQgKyBpZHgpICogMC4yNCAtIDAuMTI7CiAgICAgIGZsb2F0IG9mZnNldEIgPSBoYXNoKHNlZWQgKyBpZHggKyAxLjApICogMC4yNCAtIDAuMTI7CiAgICAgIGZsb2F0IG9mZnNldCA9IG1peChvZmZzZXRBLCBvZmZzZXRCLCBzbW9vdGhzdGVwKDAuMCwgMS4wLCBmcmFjKSk7CiAgICAgIGZsb2F0IHdpZHRoID0gbWl4KDAuMDA2LCAwLjAyLCBoYXNoKHNlZWQgKyBpZHggKiAxLjcpKTsKICAgICAgZmxvYXQgdGFyZ2V0ID0gYW5jaG9yICsgb2Zmc2V0OwogICAgICBmbG9hdCBkaXN0ID0gYWJzKHV2LnggLSB0YXJnZXQpOwogICAgICBmbG9hdCBpbnRlbnNpdHkgPSBzbW9vdGhzdGVwKHdpZHRoLCAwLjAsIGRpc3QpOwogICAgICBmbG9hdCBmYWRlID0gc21vb3Roc3RlcCgwLjAsIDAuOSwgMS4wIC0gdXYueSk7CiAgICAgIHJldHVybiBpbnRlbnNpdHkgKiBmYWRlOwogICAgfQogICAgdm9pZCBtYWluKCkgewogICAgICBmbG9hdCBzZWVkID0gZmxvb3IodVRpbWUgKiAxMS4wKTsKICAgICAgZmxvYXQgY29yZSA9IGphZ2dlZExpbmUodlV2LCB1T3JpZ2luLngsIHNlZWQpOwogICAgICBmbG9hdCBoYWxvID0gamFnZ2VkTGluZSh2VXYsIHVPcmlnaW4ueCArIDAuMDA4LCBzZWVkICsgMi4wKSAqIDAuNDsKICAgICAgZmxvYXQgYWxwaGEgPSBjbGFtcCgoY29yZSArIGhhbG8pICogdUZsYXNoLCAwLjAsIDEuMCk7CiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjk4LCAwLjksIGFscGhhKTsKICAgIH0KICBgLGk9e3VGbGFzaDp7dmFsdWU6MH0sdU9yaWdpbjp7dmFsdWU6bmV3IFBlKC44NSwxLjA1KX0sdVRpbWU6e3ZhbHVlOjB9fTtsZXQgcj1uZXcgZXQobi52aWV3V2lkdGgsbi52aWV3SGVpZ2h0KTtjb25zdCBzPW5ldyBsdCh7dW5pZm9ybXM6aSx2ZXJ0ZXhTaGFkZXI6X3IsZnJhZ21lbnRTaGFkZXI6dCx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExLGRlcHRoVGVzdDohMSxibGVuZGluZzoyfSksbz1uZXcgdHQocixzKTtvLnBvc2l0aW9uLnNldCgwLDAsLTYpLG8ucmVuZGVyT3JkZXI9MjUsZS5hZGQobyk7bGV0IGE9bmV3IGV0KG4udmlld1dpZHRoLG4udmlld0hlaWdodCk7Y29uc3QgbD1uZXcgam4oe2NvbG9yOjE2Nzc3MjE1LHRyYW5zcGFyZW50OiEwLG9wYWNpdHk6MCxkZXB0aFdyaXRlOiExLGRlcHRoVGVzdDohMSxibGVuZGluZzoyfSksYz1uZXcgdHQoYSxsKTtjLnBvc2l0aW9uLnNldCgwLDAsLTgpLGMucmVuZGVyT3JkZXI9MzAsZS5hZGQoYyk7Y29uc3QgdT0yMDtsZXQgZD0kZS5yYW5kRmxvYXQoMSwzKSxmPTAscD0uMjUsZz0wLHg9LTE7Y29uc3QgbT1NYXRoLm1heCgwLE1hdGgubWluKDEsbi5vcGFjaXR5LzEwMCkpLGg9KCk9PntwPSRlLnJhbmRGbG9hdCguMTgsLjMyKSxmPXAsaS51Rmxhc2gudmFsdWU9MSxpLnVPcmlnaW4udmFsdWUuc2V0KCRlLnJhbmRGbG9hdCguNiwuOTUpLCRlLnJhbmRGbG9hdCguODUsMS4wNSkpLGwub3BhY2l0eT1NYXRoLm1heChsLm9wYWNpdHksLjU1Km0rLjE1KX07cmV0dXJue2dyb3VwOmUsdXBkYXRlKFQseSxfKXtjb25zdCBDPV8/LmxpZ2h0bmluZ0RhdGEsdz10eXBlb2YgXz8uc3BlZWRfZmFjdG9yX2xpZ2h0bmluZz09Im51bWJlciI/Xy5zcGVlZF9mYWN0b3JfbGlnaHRuaW5nOjE7aWYoQyYmKEMuc3RyaWtlc1RvVHJpZ2dlcj4wfHxDLmRpc3RhbmNlS20+MCkpe2lmKEMuc3RyaWtlc1RvVHJpZ2dlcj4wJiZnPD0wKXtjb25zdCBiPUMuZGlzdGFuY2VLbSozO3g9eStiLGc9dX14PjAmJnk+PXgmJih4PS0xLGgoKSksZz1NYXRoLm1heCgwLGctVCp3KX1lbHNlIGQtPVQqdyxkPD0wJiYoZD0kZS5yYW5kRmxvYXQoMS41LDQpLGgoKSk7aWYoaS51VGltZS52YWx1ZSs9VCxmPjApe2YtPVQ7Y29uc3QgYj1NYXRoLm1heCgwLGYvTWF0aC5tYXgocCwuMDAxKSk7aS51Rmxhc2gudmFsdWU9TWF0aC5wb3coYiwxLjQpKm19ZWxzZSBpLnVGbGFzaC52YWx1ZT4wJiYoaS51Rmxhc2gudmFsdWU9TWF0aC5tYXgoMCxpLnVGbGFzaC52YWx1ZS1UKjgpKTtsLm9wYWNpdHk9TWF0aC5tYXgoMCxsLm9wYWNpdHktVCo2KX0sc2V0T3BhY2l0eShUKXtjb25zdCB5PU1hdGgubWF4KDAsTWF0aC5taW4oMSxULzEwMCkpO2kudUZsYXNoLnZhbHVlKj15L219LG9uUmVzaXplKFQseSl7bi52aWV3V2lkdGg9VCxuLnZpZXdIZWlnaHQ9eSxyLmRpc3Bvc2UoKSxyPW5ldyBldChULHkpLG8uZ2VvbWV0cnk9cixhLmRpc3Bvc2UoKSxhPW5ldyBldChULHkpLGMuZ2VvbWV0cnk9YX0sZGlzcG9zZSgpe3IuZGlzcG9zZSgpLHMuZGlzcG9zZSgpLGEuZGlzcG9zZSgpLGwuZGlzcG9zZSgpfX19ZnVuY3Rpb24gX2gobil7Y29uc3QgZT1uZXcgZHQsdD1uLmlzTW9iaWxlPzEwOjE1LGk9bmV3IGV0KC4yNSwuMjUpLHI9bmV3IEZzO3IuaW5kZXg9aS5pbmRleCxyLmF0dHJpYnV0ZXMucG9zaXRpb249aS5hdHRyaWJ1dGVzLnBvc2l0aW9uLHIuYXR0cmlidXRlcy51dj1pLmF0dHJpYnV0ZXMudXYsci5pbnN0YW5jZUNvdW50PXQ7Y29uc3Qgcz1uZXcgRmxvYXQzMkFycmF5KHQqMyksbz1uZXcgRmxvYXQzMkFycmF5KHQpLGE9bmV3IEZsb2F0MzJBcnJheSh0KSxsPW5ldyBGbG9hdDMyQXJyYXkodCksYz1uZXcgRmxvYXQzMkFycmF5KHQpO2ZvcihsZXQgcD0wO3A8dDtwKyspe2NvbnN0IGc9cCozO3NbZ109JGUucmFuZEZsb2F0U3ByZWFkKG4udmlld1dpZHRoKzEwKSxzW2crMV09JGUucmFuZEZsb2F0U3ByZWFkKG4udmlld0hlaWdodCksc1tnKzJdPU1hdGgucmFuZG9tKCkqMixvW3BdPSRlLnJhbmRGbG9hdCgyLjgsNCksYVtwXT0kZS5yYW5kRmxvYXQoMS44LDIuOCksbFtwXT1NYXRoLnJhbmRvbSgpKk1hdGguUEkqMixjW3BdPU1hdGgucmFuZG9tKCl9ci5zZXRBdHRyaWJ1dGUoImluc3RhbmNlT2Zmc2V0IixuZXcgR3QocywzKSksci5zZXRBdHRyaWJ1dGUoImluc3RhbmNlU3BlZWQiLG5ldyBHdChvLDEpKSxyLnNldEF0dHJpYnV0ZSgiaW5zdGFuY2VTaXplIixuZXcgR3QoYSwxKSksci5zZXRBdHRyaWJ1dGUoImluc3RhbmNlUm90YXRpb24iLG5ldyBHdChsLDEpKSxyLnNldEF0dHJpYnV0ZSgiaW5zdGFuY2VQaGFzZSIsbmV3IEd0KGMsMSkpO2NvbnN0IHU9e3VUaW1lOnt2YWx1ZTowfSx1T3BhY2l0eTp7dmFsdWU6bi5vcGFjaXR5LzEwMH0sdVZpZXdTaXplOnt2YWx1ZTpuZXcgUGUobi52aWV3V2lkdGgsbi52aWV3SGVpZ2h0KX19LGQ9bmV3IGx0KHt1bmlmb3Jtczp1LHZlcnRleFNoYWRlcjpgCiAgICAgIGF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlT2Zmc2V0OwogICAgICBhdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VTcGVlZDsKICAgICAgYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlU2l6ZTsKICAgICAgYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlUm90YXRpb247CiAgICAgIGF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVBoYXNlOwogICAgICB1bmlmb3JtIGZsb2F0IHVUaW1lOwogICAgICB1bmlmb3JtIHZlYzIgdVZpZXdTaXplOwogICAgICB2YXJ5aW5nIGZsb2F0IHZBbHBoYTsKICAgICAgdm9pZCBtYWluKCkgewogICAgICAgIGZsb2F0IHByb2dyZXNzID0gZnJhY3QodVRpbWUgKiBpbnN0YW5jZVNwZWVkICsgaW5zdGFuY2VQaGFzZSk7CiAgICAgICAgZmxvYXQgdHJhdmVsID0gKHVWaWV3U2l6ZS55ICogMC41KSAtIHByb2dyZXNzICogKHVWaWV3U2l6ZS55ICsgMjAuMCk7CiAgICAgICAgZmxvYXQgYW5nbGUgPSBpbnN0YW5jZVJvdGF0aW9uICsgdVRpbWUgKiBpbnN0YW5jZVNwZWVkICogMy4wOwogICAgICAgIHZlYzIgcm90YXRlZCA9IHZlYzIocG9zaXRpb24ueCAqIGNvcyhhbmdsZSkgLSBwb3NpdGlvbi55ICogc2luKGFuZ2xlKSwgcG9zaXRpb24ueCAqIHNpbihhbmdsZSkgKyBwb3NpdGlvbi55ICogY29zKGFuZ2xlKSk7CiAgICAgICAgdmVjMyB0cmFuc2Zvcm1lZCA9IHZlYzMocm90YXRlZCAqIGluc3RhbmNlU2l6ZSwgcG9zaXRpb24ueik7CiAgICAgICAgdHJhbnNmb3JtZWQueCArPSBpbnN0YW5jZU9mZnNldC54OwogICAgICAgIHRyYW5zZm9ybWVkLnkgKz0gdHJhdmVsICsgaW5zdGFuY2VPZmZzZXQueTsKICAgICAgICB0cmFuc2Zvcm1lZC56ICs9IC01LjAgKyBpbnN0YW5jZU9mZnNldC56OwogICAgICAgIHZBbHBoYSA9IDEuMDsKICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHRyYW5zZm9ybWVkLCAxLjApOwogICAgICB9CiAgICBgLGZyYWdtZW50U2hhZGVyOmAKICAgICAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTsKICAgICAgdmFyeWluZyBmbG9hdCB2QWxwaGE7CiAgICAgIHZvaWQgbWFpbigpIHsKICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuOTUsIDAuOTgsIDEuMCwgdkFscGhhICogdU9wYWNpdHkpOwogICAgICB9CiAgICBgLHRyYW5zcGFyZW50OiEwLGRlcHRoV3JpdGU6ITEsYmxlbmRpbmc6MX0pLGY9bmV3IHR0KHIsZCk7cmV0dXJuIGYuZnJ1c3R1bUN1bGxlZD0hMSxlLmFkZChmKSx7Z3JvdXA6ZSx1cGRhdGUocCl7dS51VGltZS52YWx1ZSs9cCx1LnVWaWV3U2l6ZS52YWx1ZS5zZXQobi52aWV3V2lkdGgsbi52aWV3SGVpZ2h0KX0sc2V0T3BhY2l0eShwKXt1LnVPcGFjaXR5LnZhbHVlPU1hdGgubWF4KDAsTWF0aC5taW4oMSxwLzEwMCkpfSxvblJlc2l6ZShwLGcpe24udmlld1dpZHRoPXAsbi52aWV3SGVpZ2h0PWcsdS51Vmlld1NpemUudmFsdWUuc2V0KHAsZyl9LGRpc3Bvc2UoKXtyLmRpc3Bvc2UoKSxkLmRpc3Bvc2UoKX19fWxldCBBdD1udWxsO3NlbGYuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsbj0+e2NvbnN0IGU9bi5kYXRhO3N3aXRjaChlLnR5cGUpe2Nhc2UiSU5JVCI6dmgoZSk7YnJlYWs7Y2FzZSJTVEFSVCI6QXQ/LnN0YXJ0KGUuZWZmZWN0LGUub3BhY2l0eSxlLm9wdGlvbnN8fHt9KTticmVhaztjYXNlIlNFVF9PUEFDSVRZIjpBdD8uc2V0T3BhY2l0eShlLm9wYWNpdHkpO2JyZWFrO2Nhc2UiUkVTSVpFIjpBdCYmQXQucmVzaXplKHt2aWV3cG9ydFdpZHRoOmUudmlld3BvcnRXaWR0aCx2aWV3cG9ydEhlaWdodDplLnZpZXdwb3J0SGVpZ2h0LGRldmljZVBpeGVsUmF0aW86ZS5kZXZpY2VQaXhlbFJhdGlvLGlzTW9iaWxlOmUuaXNNb2JpbGV9KTticmVhaztjYXNlIlNFVF9TTk9XX1NVUkZBQ0VTIjpBdD8uc2V0U25vd1N1cmZhY2VzKGUuc3VyZmFjZXN8fFtdKTticmVhaztjYXNlIlNUT1AiOkF0Py5zdG9wKCk7YnJlYWs7Y2FzZSJESVNQT1NFIjpBdCYmKEF0LmRlc3Ryb3koKSxBdD1udWxsKTticmVha319KTtmdW5jdGlvbiB2aChuKXt0cnl7QXQmJihBdC5kZXN0cm95KCksQXQ9bnVsbCksQXQ9bmV3IEt1KHtjYW52YXM6bi5jYW52YXMsdmlld3BvcnRXaWR0aDpuLnZpZXdwb3J0V2lkdGgsdmlld3BvcnRIZWlnaHQ6bi52aWV3cG9ydEhlaWdodCxkZXZpY2VQaXhlbFJhdGlvOm4uZGV2aWNlUGl4ZWxSYXRpbz8/MSxpc01vYmlsZTpuLmlzTW9iaWxlPz8hMX0pLHNlbGYucG9zdE1lc3NhZ2Uoe3R5cGU6IlJFQURZIn0pfWNhdGNoKGUpe3NlbGYucG9zdE1lc3NhZ2Uoe3R5cGU6IkVSUk9SIixlcnJvcjplIGluc3RhbmNlb2YgRXJyb3I/ZS5tZXNzYWdlOlN0cmluZyhlKX0pfX19KSgpOwo=",Ub=l=>Uint8Array.from(atob(l),t=>t.charCodeAt(0)),Od=typeof self<"u"&&self.Blob&&new Blob([Ub(Dd)],{type:"text/javascript;charset=utf-8"});function Tb(l){let t;try{if(t=Od&&(self.URL||self.webkitURL).createObjectURL(Od),!t)throw"";const e=new Worker(t,{name:l?.name});return e.addEventListener("error",()=>{(self.URL||self.webkitURL).revokeObjectURL(t)}),e}catch{return new Worker("data:text/javascript;base64,"+Dd,{name:l?.name})}finally{t&&(self.URL||self.webkitURL).revokeObjectURL(t)}}const Ri=typeof window<"u"&&typeof Worker<"u"&&typeof HTMLCanvasElement<"u"&&"transferControlToOffscreen"in HTMLCanvasElement.prototype;class vb{constructor(t,e={}){this.container=t,this.canvas=document.createElement("canvas"),this.canvas.style.cssText="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--weather-overlay-z,9998);",this.container.appendChild(this.canvas),this.viewportWidth=e.viewportWidth??window.innerWidth,this.viewportHeight=e.viewportHeight??window.innerHeight,this.isMobile=e.isMobile??(window.innerWidth<600||"ontouchstart"in window),this.devicePixelRatio=e.devicePixelRatio??this.effectiveDpr(),this.worker=null,this.workerState="idle",this.workerQueue=[],this.fallbackCore=null,this.currentEffect="none",this.opacity=100,this.effectOptions={},this.resizeHandler=()=>this.handleResize(),window.addEventListener("resize",this.resizeHandler),Ri?this.initWorker():this.ensureFallbackCore()}effectiveDpr(){const t=window.ForkUWeatherAwareConfig||{};let e=window.devicePixelRatio||1;return this.isMobile&&t.mobile_limit_dpr&&(e=Math.min(e,2)),e}useWorkerPath(){return Ri&&this.workerState==="ready"}shouldUseWorkerOrQueue(){return Ri&&this.workerState!=="failed"}shouldUseFallbackCore(){return!Ri||this.workerState==="failed"}initWorker(){if(!this.worker)try{this.worker=new Tb,this.worker.onmessage=e=>{e.data?.type==="READY"?(this.workerState="ready",this.flushWorkerQueue(),this.currentEffect!=="none"&&this.postWorkerMessage({type:"START",effect:this.currentEffect,opacity:this.opacity,options:this.effectOptions})):e.data?.type==="ERROR"&&(console.error("[Weather Overlay] Worker error:",e.data.error),this.handleWorkerFailure())},this.worker.onerror=e=>{console.error("[Weather Overlay] Worker init failed:",e),this.handleWorkerFailure()};const t=this.canvas.transferControlToOffscreen();this.workerState="pending",this.worker.postMessage({type:"INIT",canvas:t,viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile},[t])}catch(t){console.error("[Weather Overlay] Worker creation failed:",t),this.handleWorkerFailure()}}handleWorkerFailure(){this.workerState="failed",this.worker&&(this.worker.terminate(),this.worker=null),this.flushWorkerQueue(!0),this.recreateCanvas(),this.fallbackCore&&(this.fallbackCore.destroy(),this.fallbackCore=null),this.ensureFallbackCore(),this.currentEffect!=="none"&&this.fallbackCore?.start(this.currentEffect,this.opacity,this.effectOptions)}recreateCanvas(){this.canvas?.parentElement&&this.canvas.parentElement.removeChild(this.canvas),this.canvas=document.createElement("canvas"),this.canvas.style.cssText="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--weather-overlay-z,9998);",this.container.appendChild(this.canvas)}ensureFallbackCore(){this.fallbackCore||(this.fallbackCore=new Zb({canvas:this.canvas,viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile}))}postWorkerMessage(t){this.workerState==="ready"&&this.worker?this.worker.postMessage(t):this.workerQueue.push(t)}flushWorkerQueue(t=!1){if(t||!this.worker){this.workerQueue=[];return}for(const e of this.workerQueue)this.worker.postMessage(e);this.workerQueue=[]}handleResize(){this.viewportWidth=window.innerWidth,this.viewportHeight=window.innerHeight,this.isMobile=window.innerWidth<600||"ontouchstart"in window,this.devicePixelRatio=this.effectiveDpr(),this.shouldUseWorkerOrQueue()?this.postWorkerMessage({type:"RESIZE",viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile}):this.shouldUseFallbackCore()&&this.fallbackCore&&this.fallbackCore.resize({viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile})}start(t,e=100,n={}){if(this.opacity=Math.max(0,Math.min(100,e)),this.effectOptions=n,t==="none"){this.stop();return}this.currentEffect=t,this.shouldUseWorkerOrQueue()?this.postWorkerMessage({type:"START",effect:t,opacity:this.opacity,options:this.effectOptions}):this.shouldUseFallbackCore()&&(this.ensureFallbackCore(),this.fallbackCore?.start(t,this.opacity,this.effectOptions))}stop(){this.currentEffect="none",this.shouldUseWorkerOrQueue()?this.postWorkerMessage({type:"STOP"}):this.fallbackCore&&this.fallbackCore.stop()}setOpacity(t){this.opacity=Math.max(0,Math.min(100,t)),this.shouldUseWorkerOrQueue()?this.postWorkerMessage({type:"SET_OPACITY",opacity:this.opacity}):this.fallbackCore&&this.fallbackCore.setOpacity(this.opacity)}resize(t={}){this.viewportWidth=t.viewportWidth??window.innerWidth,this.viewportHeight=t.viewportHeight??window.innerHeight,this.isMobile=t.isMobile??(window.innerWidth<600||"ontouchstart"in window),this.devicePixelRatio=t.devicePixelRatio??this.effectiveDpr(),this.shouldUseWorkerOrQueue()?this.postWorkerMessage({type:"RESIZE",viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile}):this.shouldUseFallbackCore()&&(this.ensureFallbackCore(),this.fallbackCore?.resize({viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile}))}setStyle(t){t&&typeof t=="object"&&Object.assign(this.canvas.style,t)}destroy(){this.stop(),window.removeEventListener("resize",this.resizeHandler),this.worker&&(this.worker.postMessage({type:"DISPOSE"}),this.worker.terminate(),this.worker=null),this.workerState="idle",this.workerQueue=[],this.fallbackCore&&(this.fallbackCore.destroy(),this.fallbackCore=null),this.canvas?.parentNode&&this.canvas.parentNode.removeChild(this.canvas)}}function qd(l){if(!l)return"none";const t=String(l).toLowerCase().replace(/_/g,"-");return t==="lightning-rainy"||t==="lightning_rainy"||t==="pouring"?"rain_storm":t==="rainy-drizzle"||t==="rainy_drizzle"?"rain_drizzle":t==="rainy"?"rain":t==="hail"?"hail":t==="lightning"?"lightning":t==="snowy"||t==="snow"?"snow_gentle":t==="snowy-rainy"||t==="snowy_rainy"?"snow_storm":t==="snowy2"?"snow_layered":t==="snowy3"?"snow_gentle":t==="fog"||t==="foggy"?"fog_light":t==="sunny"||t==="clear"||t==="sunny2"?"sun_beams":t==="clear-night"||t==="clear_night"?"stars":t==="cloudy"||t==="partlycloudy"||t==="partly-cloudy"||t==="partly_cloudy"||t==="windy-variant"||t==="windy_variant"||t==="windy"?"clouds":"none"}const rn=[],$d="",Jb="",kb=!1;function Mr(l,t=null){}function wb(l,t=null){console.warn("[Weather Overlay] ⚠️",l,t??"")}function Mn(l,t=null){console.error("[Weather Overlay] ❌",l,t??"")}function Ge(){const l=document.querySelector("home-assistant");return l?.hass?l:null}function Un(){return(window.ForkUWeatherAwareConfig||{}).weather_entity||"weather.openweathermap"}function tc(){try{const l=Ge();if(!l)return null;const t=window.ForkUWeatherAwareConfig||{},e=Un();if(t.development_mode&&t.test_effect&&t.test_effect!=="Use Real Weather"){let a=t.test_effect;return a==="snowy"&&t.snowy_variant==="snowy2"&&(a="snowy2"),a}const n=l.hass.states[e];if(!n)return Mn(`Weather entity '${e}' not found`),null;let i=(n.state||"").toLowerCase().replace(/_/g,"-");const s=parseFloat(t.drizzle_precipitation_max)||2.5;if(i==="rainy"){const a=n.attributes?.precipitation!=null?parseFloat(n.attributes.precipitation):n.attributes?.precipitation_1h!=null?parseFloat(n.attributes.precipitation_1h):NaN;!isNaN(a)&&a>0&&a<=s&&(i="rainy-drizzle")}return i}catch(l){return Mn("Error getting weather state:",l),null}}function ec(){try{if((window.ForkUWeatherAwareConfig||{}).enabled===!1)return!1;if(!$d)return!0;const t=Ge();if(!t)return!0;const e=t.hass.states[$d];return e?e.state==="on":!0}catch(l){return Mn("Error checking overlay:",l),!0}}function lc(){if(!rn?.length)return!0;const t=window.location.pathname.split("/").filter(Boolean);if(t.length===0)return rn.includes("lovelace")||rn.includes("home");if(t[0]==="lovelace"){const e=t.length===1?"lovelace":t[1];return rn.includes(e)}for(const e of t)if(rn.includes(e))return!0;return rn.includes(t[t.length-1])}function ls(){return window.innerWidth<600||"ontouchstart"in window}function zb(){try{const l=document.createElement("canvas");return!!(l.getContext("webgl2")||l.getContext("webgl")||l.getContext("experimental-webgl"))}catch{return!1}}function nc(){const l=window.ForkUWeatherAwareConfig||{};let t=window.devicePixelRatio||1;return ls()&&l.mobile_limit_dpr&&(t=Math.min(t,2)),t}function ic(){const l=window.ForkUWeatherAwareConfig||{},t=l.pm25_entity,e=l.pm4_entity,n=l.pm10_entity,i=l.smog_threshold_pm25??35,s=l.smog_threshold_pm4??50,a=l.smog_threshold_pm10??50,d=Ge();if(!d?.hass)return!1;if(t){const c=d.hass.states[t];if(c&&c.state!=="unavailable"&&c.state!=="unknown"){const o=parseFloat(c.state);if(!isNaN(o)&&o>=i)return!0}}if(e){const c=d.hass.states[e];if(c&&c.state!=="unavailable"&&c.state!=="unknown"){const o=parseFloat(c.state);if(!isNaN(o)&&o>=s)return!0}}if(n){const c=d.hass.states[n];if(c&&c.state!=="unavailable"&&c.state!=="unknown"){const o=parseFloat(c.state);if(!isNaN(o)&&o>=a)return!0}}return!1}function gl(l){return(window.ForkUWeatherAwareConfig||{})[l]!==!1}function Hb(){const t=(window.ForkUWeatherAwareConfig||{}).gaming_mode_entity;if(!t||typeof t!="string"||!t.trim())return!1;const e=Ge();if(!e?.hass?.states)return!1;const n=e.hass.states[t];return!!(n&&String(n.state).toLowerCase()==="on")}let yi=null,ac=0;const Kb=3e3;function sc(){const l=Date.now();if(l-ac<Kb&&yi)return yi;ac=l;try{const t=window.ForkUWeatherAwareConfig||{},e=Ge();if(!e?.hass)return{x:.75,y:.12};const n=t.moon_position_entity,i=t.moon_phase_entity,s=t.moon_azimuth_entity,a=t.moon_altitude_entity;let d={x:.75,y:.12};for(const c of[n,i].filter(Boolean)){const o=e.hass.states[c];if(!o?.attributes)continue;const Z=o.attributes,m=parseFloat(Z.azimuth??Z.moon_azimuth_deg),b=parseFloat(Z.elevation??Z.altitude??Z.moon_altitude_deg);if(!isNaN(m)&&!isNaN(b)&&b>0){d.x=Math.max(0,Math.min(1,(m-90)/180)),d.y=.08+.22*(1-Math.min(90,b)/90);break}}if(s||a){const c=s?e.hass.states[s]:null,o=a?e.hass.states[a]:null,Z=c?parseFloat(c.state):NaN,m=o?parseFloat(o.state):NaN;!isNaN(Z)&&!isNaN(m)&&m>0&&(d.x=Math.max(0,Math.min(1,(Z-90)/180)),d.y=.08+.22*(1-Math.min(90,m)/90))}return yi=d,d}catch{return yi||{x:.75,y:.12}}}const ns={N:0,NE:45,E:90,SE:135,S:180,SW:225,W:270,NW:315};let Rl=-1;function dc(){const l=window.ForkUWeatherAwareConfig||{},t=Ge();let e=0,n=0;if(l.development_mode&&(l.debug_lightning_counter!=null||l.debug_lightning_distance!=null))e=l.debug_lightning_counter!=null&&l.debug_lightning_counter!==""?parseInt(l.debug_lightning_counter,10)||0:Rl>=0?Rl:0,n=l.debug_lightning_distance!=null&&l.debug_lightning_distance!==""?parseFloat(l.debug_lightning_distance)||0:5,l.debug_lightning_counter!=null&&l.debug_lightning_counter!==""&&(Rl=e);else if(t?.hass?.states){const s=l.lightning_counter_entity,a=l.lightning_distance_entity;if(s){const d=t.hass.states[s];if(d?.state!=="unavailable"&&d?.state!=="unknown"){const c=parseInt(d.state,10);isNaN(c)||(e=c)}}if(a){const d=t.hass.states[a];if(d?.state!=="unavailable"&&d?.state!=="unknown"){const c=parseFloat(d.state);!isNaN(c)&&c>=0&&(n=c)}}Rl<0&&(Rl=e)}const i=e>Rl?Math.min(e-Rl,5):0;return i>0&&(Rl=e),{count:e,distanceKm:n,strikesToTrigger:i}}function is(){const l=window.ForkUWeatherAwareConfig||{},t=Ge(),e=Un();if(l.development_mode&&l.debug_cloud_coverage!=null&&String(l.debug_cloud_coverage).trim()!==""){const i=parseFloat(l.debug_cloud_coverage);if(!isNaN(i))return Math.max(0,Math.min(100,i))}if(!t?.hass)return null;if(l.cloud_coverage_entity){const i=t.hass.states[l.cloud_coverage_entity];if(i?.state&&i.state!=="unavailable"&&i.state!=="unknown"){const s=parseFloat(i.state);if(!isNaN(s))return Math.max(0,Math.min(100,s))}}const n=t.hass.states[e];if(n?.attributes?.cloud_coverage!=null){const i=parseFloat(n.attributes.cloud_coverage);if(!isNaN(i))return Math.max(0,Math.min(100,i))}return null}function cc(){const l=window.ForkUWeatherAwareConfig||{},t=Ge(),e=Un();if(l.development_mode&&l.debug_precipitation&&l.debug_precipitation!=="Use sensors"){const a={light:.35,medium:.65,heavy:1.2}[l.debug_precipitation];if(a!==void 0)return a}if(!t?.hass)return 1;if(l.precipitation_entity){const a=t.hass.states[l.precipitation_entity];if(a?.state!=="unavailable"&&a?.state!=="unknown"){const d=parseFloat(a.state);if(!isNaN(d))return Math.max(.2,Math.min(1.5,.2+d/10))}}const n=t.hass.states[e];if(!n?.attributes)return 1;const i=n.attributes.precipitation??n.attributes.precipitation_1h??n.attributes.precipitation_probability;if(i==null)return 1;const s=parseFloat(i);return isNaN(s)?1:Math.max(.2,Math.min(1.5,.2+s/10))}function Bb(){const l=window.ForkUWeatherAwareConfig||{},t=Ge();if(!t?.hass?.states)return 0;const e=l.aurora_chance_entity;if(!e)return 0;const n=t.hass.states[e];if(!n?.state||n.state==="unavailable"||n.state==="unknown")return 0;const i=parseFloat(n.state);return isNaN(i)?0:Math.max(0,Math.min(100,i))/100}function Eb(){const l=window.ForkUWeatherAwareConfig||{},t=Ge();if(!t?.hass?.states)return null;const e=l.k_index_entity;if(!e)return null;const n=t.hass.states[e];if(!n?.state||n.state==="unavailable"||n.state==="unknown")return null;const i=parseFloat(n.state);return isNaN(i)?null:Math.max(0,Math.min(9,i))}function Ab(){const t=(window.ForkUWeatherAwareConfig||{}).aurora_visibility_alert_entity;if(!t)return!1;const e=Ge();if(!e?.hass?.states)return!1;const n=e.hass.states[t];return!!(n&&String(n.state).toLowerCase()==="on")}function Ci(){const l=window.ForkUWeatherAwareConfig||{};if(!gl("enable_aurora_effect"))return 0;if(l.development_mode&&l.debug_aurora_score!=null&&String(l.debug_aurora_score).trim()!==""){const Z=parseFloat(l.debug_aurora_score);if(!isNaN(Z))return Math.max(0,Math.min(1,Z))}const t=Bb()||(Ab()?.7:0),n=1-(is()??50)/100,s=as()?.elevation??0,a=Math.max(0,Math.min(1,1-(s+6)/6));let d=t*n*a;const c=Eb();c!=null&&c>=0&&(d*=Math.min(1.5,1+.05*c));const o=l.aurora_visibility_min!=null&&!isNaN(parseFloat(l.aurora_visibility_min))?Math.max(0,Math.min(1,parseFloat(l.aurora_visibility_min))):.15;return d>=o?d:0}function oc(){const l=window.ForkUWeatherAwareConfig||{};if(l.theme_mode==="dark"||l.theme_mode==="light")return l.theme_mode;const t=document.documentElement;return t?.classList&&(t.classList.contains("dark")||t.getAttribute("theme")==="dark")?"dark":t?.classList?.contains("light")?"light":typeof window.matchMedia<"u"&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"}function as(){const l=window.ForkUWeatherAwareConfig||{},t=Ge(),e=l.sun_entity||"sun.sun";let n=180,i=45,s=3;if(t?.hass?.states){const a=t.hass.states[e];if(a?.attributes){const d=a.attributes;n=parseFloat(d.azimuth)||180,i=parseFloat(d.elevation)||45}if(l.uv_index_entity){const d=t.hass.states[l.uv_index_entity];if(d?.state!=="unavailable"&&d?.state!=="unknown"){const c=parseFloat(d.state);!isNaN(c)&&c>=0&&(s=c)}}else{const d=t.hass.states[Un()];d?.attributes?.uv_index!=null&&(s=parseFloat(d.attributes.uv_index)||3)}}return{azimuth:n,elevation:i,uvIndex:s}}function mc(){const l=window.ForkUWeatherAwareConfig||{},t=Un();if(l.development_mode&&(l.debug_wind_speed||l.debug_wind_direction)){let s=5;if(l.debug_wind_speed&&l.debug_wind_speed!=="Use sensors")s={none:0,light:10,medium:25,strong:45}[l.debug_wind_speed]??5;else{const d=Ge();if(d?.hass&&l.wind_speed_entity){const c=d.hass.states[l.wind_speed_entity];c?.state!=="unavailable"&&(s=parseFloat(c.state)||5)}}let a=270;if(l.debug_wind_direction&&l.debug_wind_direction!=="Use sensors"){const d=l.debug_wind_direction;a=(ns[d]??parseFloat(d))||270}else{const d=Ge();if(d?.hass&&l.wind_direction_entity){const c=d.hass.states[l.wind_direction_entity];c?.state!=="unavailable"&&(a=parseFloat(c.state)||270)}}return{speed:s,bearing:a}}const e=Ge();if(!e?.hass)return{speed:5,bearing:270};let n=5,i=270;if(l.wind_speed_entity){const s=e.hass.states[l.wind_speed_entity];if(s?.state!=="unavailable"&&s?.state!=="unknown"){const a=parseFloat(s.state);isNaN(a)||(n=a)}}if(n===5){const s=e.hass.states[t],a=s?.attributes?.wind_speed!=null?parseFloat(s.attributes.wind_speed):NaN;isNaN(a)||(n=a)}if(l.wind_direction_entity){const s=e.hass.states[l.wind_direction_entity];if(s?.state!=="unavailable"&&s?.state!=="unknown"){const a=parseFloat(s.state);isNaN(a)?typeof s.state=="string"&&ns[s.state]!=null&&(i=ns[s.state]):i=a}}if(i===270){const s=e.hass.states[t],a=s?.attributes?.wind_bearing!=null?parseFloat(s.attributes.wind_bearing):NaN;isNaN(a)||(i=a)}return{speed:n,bearing:i}}function Pb(){const l=(window.ForkUWeatherAwareConfig||{}).spatial_mode||"foreground";return{foreground:9998,background:-1,bubble:3,"gradient-mask":9997}[l]??9998}function Zc(l){const t=window.ForkUWeatherAwareConfig||{},e={rain:t.enable_rain,rain_storm:t.enable_rain&&t.enable_lightning_effect,rain_drizzle:t.enable_rain,snow_gentle:t.enable_snow,snow_storm:t.enable_snow,snow_layered:t.enable_snow,fog_light:t.enable_fog,fog_dense:t.enable_fog,sun_beams:t.enable_sun_glow,clouds:t.enable_clouds,hail:t.enable_hail,lightning:t.enable_lightning_effect,stars:t.enable_stars,matrix:t.enable_matrix};return l&&l!=="none"&&e[l]===!1?"none":l}let Be=null,ue=null,ss=null,ds=0,hc=window.location.pathname;function Qb(){ue&&ue.style.setProperty("--weather-overlay-z",String(Pb()))}function uc(){const l=Date.now();if(l-ds<1e3)return;const t=ec(),e=lc();if(!t||!e){Be&&Be.stop(),ue&&(ue.style.display="none");return}if(ds=l,ue&&(ue.style.display="block"),window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches){Be&&Be.stop(),ue&&(ue.style.display="none");return}const n=window.ForkUWeatherAwareConfig||{},i=n.gaming_matrix_only&&Hb()&&gl("enable_matrix"),s=i?null:tc(),a=i?"matrix":Zc(qd(s));(s!==ss||!Be)&&(ss=s);const d=gl("enable_smog_effect")&&ic(),c=a==="stars"&&gl("enable_moon_glow")?sc():null,o=a==="stars"?Ci():0,Z=a==="stars"&&o>0,b=["rain","rain_storm","rain_drizzle","snow_storm"].includes(a)&&gl("enable_window_droplets"),h=(window.ForkUWeatherAwareConfig||{}).spatial_mode||"foreground",{speed:p,bearing:V}=mc(),r=n.wind_sway_factor!=null&&!isNaN(parseFloat(n.wind_sway_factor))?Math.max(0,Math.min(2,parseFloat(n.wind_sway_factor))):.7,u=n.rain_max_tilt_deg!=null&&!isNaN(parseFloat(n.rain_max_tilt_deg))?parseFloat(n.rain_max_tilt_deg):30,C=n.rain_wind_min_kmh!=null&&!isNaN(parseFloat(n.rain_wind_min_kmh))?parseFloat(n.rain_wind_min_kmh):3,y=a==="lightning"||a==="rain_storm"?dc():null,G=a==="rain_storm"?y:null,N=a==="sun_beams"?as():null,I=n.speed_factor_lightning!=null&&!isNaN(parseFloat(n.speed_factor_lightning))?parseFloat(n.speed_factor_lightning):1,x=is(),U=cc(),R=oc(),g=n.cloud_speed_multiplier!=null&&!isNaN(parseFloat(n.cloud_speed_multiplier))?Math.max(.1,Math.min(3,parseFloat(n.cloud_speed_multiplier))):1,Y={moon:Math.max(0,Math.min(1,(n.opacity_moon??100)/100)),clouds:Math.max(0,Math.min(1,(n.opacity_clouds??100)/100)),aurora:Math.max(0,Math.min(1,(n.opacity_aurora??100)/100)),stars:Math.max(0,Math.min(1,(n.opacity_stars??100)/100)),droplets:Math.max(0,Math.min(1,(n.opacity_droplets??100)/100)),sun:Math.max(0,Math.min(1,(n.opacity_sun??100)/100)),fog:Math.max(0,Math.min(1,(n.opacity_fog??100)/100)),smog:Math.max(0,Math.min(1,(n.opacity_smog??100)/100))};Be&&Be.start(a,100,{smogActive:d,effectOpacity:Y,moonPosition:c,windowDroplets:b,spatialMode:h,windBearing:V,windSpeedKmh:p,windSwayFactor:r,rainMaxTiltDeg:u,rainWindMinKmh:C,lightningData:y,lightningOverlay:G,sunPosition:N,speed_factor_lightning:I,cloudCoverage:x,precipitationMultiplier:U,themeMode:R,cloudSpeedMultiplier:g,auroraOverlay:Z,auroraVisibilityScore:o,auroraVariant:(window.ForkUWeatherAwareConfig||{}).aurora_variant||"bands"})}function jb(){Be&&Be.resize({viewportWidth:window.innerWidth,viewportHeight:window.innerHeight,isMobile:ls(),devicePixelRatio:nc()})}function _b(){if(!ue){if(!zb()){wb("WebGL not supported - weather overlay disabled");return}ue=document.createElement("div"),ue.id="fork-u-weather-overlay",ue.style.cssText="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--weather-overlay-z,9998);",Qb(),document.body.appendChild(ue);try{if(Be=new vb(ue,{viewportWidth:window.innerWidth,viewportHeight:window.innerHeight,isMobile:ls(),devicePixelRatio:nc()}),!ec()||!lc())ue.style.display="none";else{const l=tc(),t=Zc(qd(l));ss=l;const e=gl("enable_smog_effect")&&ic(),n=t==="stars"&&gl("enable_moon_glow")?sc():null,i=t==="stars"?Ci():0,s=t==="stars"&&i>0,d=["rain","rain_storm","rain_drizzle","snow_storm"].includes(t)&&gl("enable_window_droplets"),c=(window.ForkUWeatherAwareConfig||{}).spatial_mode||"foreground",{speed:o,bearing:Z}=mc(),m=window.ForkUWeatherAwareConfig||{},b=m.wind_sway_factor!=null&&!isNaN(parseFloat(m.wind_sway_factor))?Math.max(0,Math.min(2,parseFloat(m.wind_sway_factor))):.7,h=m.rain_max_tilt_deg!=null&&!isNaN(parseFloat(m.rain_max_tilt_deg))?parseFloat(m.rain_max_tilt_deg):30,p=m.rain_wind_min_kmh!=null&&!isNaN(parseFloat(m.rain_wind_min_kmh))?parseFloat(m.rain_wind_min_kmh):3,V=t==="lightning"||t==="rain_storm"?dc():null,r=t==="sun_beams"?as():null,u={moon:Math.max(0,Math.min(1,(m.opacity_moon??100)/100)),clouds:Math.max(0,Math.min(1,(m.opacity_clouds??100)/100)),aurora:Math.max(0,Math.min(1,(m.opacity_aurora??100)/100)),stars:Math.max(0,Math.min(1,(m.opacity_stars??100)/100)),droplets:Math.max(0,Math.min(1,(m.opacity_droplets??100)/100)),sun:Math.max(0,Math.min(1,(m.opacity_sun??100)/100)),fog:Math.max(0,Math.min(1,(m.opacity_fog??100)/100)),smog:Math.max(0,Math.min(1,(m.opacity_smog??100)/100))};Be.start(t,100,{smogActive:e,effectOpacity:u,moonPosition:n,windowDroplets:d,spatialMode:c,windBearing:Z,windSpeedKmh:o,windSwayFactor:b,rainMaxTiltDeg:h,rainWindMinKmh:p,lightningData:V,lightningOverlay:t==="rain_storm"?V:null,sunPosition:r,speed_factor_lightning:m.speed_factor_lightning!=null&&!isNaN(parseFloat(m.speed_factor_lightning))?parseFloat(m.speed_factor_lightning):1,cloudCoverage:is(),precipitationMultiplier:cc(),themeMode:oc(),cloudSpeedMultiplier:m.cloud_speed_multiplier!=null&&!isNaN(parseFloat(m.cloud_speed_multiplier))?Math.max(.1,Math.min(3,parseFloat(m.cloud_speed_multiplier))):1,auroraOverlay:t==="stars"&&Ci()>0,auroraVisibilityScore:t==="stars"?Ci():0,auroraVariant:(window.ForkUWeatherAwareConfig||{}).aurora_variant||"bands"})}}catch(l){Mn("Weather overlay init failed:",l),ue?.parentNode&&ue.parentNode.removeChild(ue);return}setInterval(uc,1e3),window.addEventListener("resize",jb),setInterval(()=>{window.location.pathname!==hc&&(hc=window.location.pathname,ds=0,uc())},500)}}function bc(){let l=0;const t=setInterval(()=>{l++,Ge()?(clearInterval(t),_b()):l>=60&&(clearInterval(t),Mn("Home Assistant not found after 30s"))},500)}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",bc):bc(),function(){const l=window.ForkUWeatherAwareDefaultConfig||{enabled:!0,weather_entity:"weather.openweathermap",development_mode:!1,test_effect:"Use Real Weather",sun_entity:"sun.sun",moon_phase_entity:null,uv_index_entity:null,moon_position_entity:null,moon_azimuth_entity:null,moon_altitude_entity:null,moon_distance_entity:null,gaming_mode_entity:null,pm25_entity:null,pm4_entity:null,pm10_entity:null,smog_threshold_pm25:35,smog_threshold_pm4:50,smog_threshold_pm10:50,cloud_coverage_entity:null,wind_speed_entity:null,wind_direction_entity:null,precipitation_entity:null,lightning_counter_entity:null,lightning_distance_entity:null,debug_precipitation:null,debug_wind_speed:null,debug_wind_direction:null,debug_lightning_distance:null,debug_lightning_counter:null,debug_cloud_coverage:null,cloud_speed_multiplier:1,wind_sway_factor:.7,spatial_mode:"foreground",enable_rain:!0,enable_snow:!0,enable_clouds:!0,enable_fog:!0,enable_smog_effect:!0,enable_sun_glow:!0,enable_moon_glow:!0,enable_stars:!0,enable_hail:!0,enable_lightning_effect:!0,enable_matrix:!0,enable_window_droplets:!0,stars_require_moon:!1,mobile_limit_dpr:!0,mobile_reduce_particles:!0,mobile_snowy2_light:!0,mobile_smog_simple:!1,mobile_30fps:!1,gaming_matrix_only:!1,snowy_variant:"snowy2",enable_aurora_effect:!0,aurora_variant:"bands",aurora_chance_entity:null,aurora_visibility_alert_entity:null,aurora_visibility_min:.15,k_index_entity:null,debug_aurora_score:null,opacity_moon:100,opacity_clouds:100,opacity_aurora:100,opacity_stars:100,opacity_droplets:100,opacity_sun:100,opacity_fog:100,opacity_smog:100};class t extends HTMLElement{connectedCallback(){super.connectedCallback&&super.connectedCallback(),this._scheduleEditorCheck()}_scheduleEditorCheck(){this._editorCheckScheduled||(this._editorCheckScheduled=!0,requestAnimationFrame(()=>{this._editorCheckScheduled=!1,this._config&&this._render()}))}setConfig(a){const d=Object.assign({},l,a||{});window.ForkUWeatherAwareConfig=d,this._config=d,this._render()}set hass(a){if(this._hass=a,this._config&&!window.ForkUWeatherAwareConfig&&(window.ForkUWeatherAwareConfig=this._config),a?.themes?.darkMode!==void 0){const d=window.ForkUWeatherAwareConfig||{},c=d.theme_mode,o=a.themes.darkMode?"dark":"light";window.ForkUWeatherAwareConfig=Object.assign({},d,{theme_mode:c==="light"||c==="dark"?c:o})}}_isInEditorPreview(){let a=this;for(;a;){if(a.nodeType===1&&a.classList&&(a.classList.contains("element-preview")||a.tagName&&a.tagName.toLowerCase().includes("hui-dialog-edit-card")))return!0;const d=a.getRootNode?a.getRootNode():a;a=(d instanceof ShadowRoot?d.host:a.parentNode)||null}return!1}_render(){this.shadowRoot||this.attachShadow({mode:"open"});const a=this._config||window.ForkUWeatherAwareConfig||l,d=this._isInEditorPreview(),c=!a.development_mode&&!d;this.style.display=c?"none":"",this.shadowRoot.innerHTML=`
        <ha-card header="Fork U - Weather Aware" style="${c?"display:none":""}">
          <div class="card-content">
            <p>Fullscreen, smooth weather overlay running on this dashboard.</p>
            <p><strong>Weather entity:</strong> ${a.weather_entity||"not set"}</p>
            <p><strong>Development mode:</strong> ${a.development_mode?"on":"off"}</p>
          </div>
        </ha-card>
      `}getCardSize(){const a=this._config||window.ForkUWeatherAwareConfig||{},d=this._isInEditorPreview&&this._isInEditorPreview();return!a.development_mode&&!d?0:1}static getConfigElement(){return document.createElement("fork-u-weather-aware-editor")}static getStubConfig(){return{enabled:!0,weather_entity:"weather.openweathermap",development_mode:!1,test_effect:"Use Real Weather"}}}typeof window.customCards>"u"&&(window.customCards=[]),window.customCards.push({type:"fork-u-weather-aware-card",name:"Fork U - Weather Aware",description:"Fullscreen weather overlay with rain, snow, lightning, fog and more.",preview:!1});function e(s){return s==null?"":String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;")}function n(s,a,d){const c={value:"",label:"— None —"};if(!s||!s.states)return d?[c,{value:d,label:"Current: "+d}]:[c];const o=Object.keys(s.states).filter(m=>a.some(b=>m.startsWith(b+"."))).sort(),Z=[c];return o.forEach(m=>Z.push({value:m,label:m})),d&&d.trim()&&!o.includes(d)&&Z.splice(1,0,{value:d,label:"Current: "+d}),Z}class i extends HTMLElement{setConfig(a){this._config=Object.assign({},l,a||{}),this._config&&(window.ForkUWeatherAwareConfig=this._config),this.shadowRoot?this._updateFormValues(this._config):(this.attachShadow({mode:"open"}),this._render())}set hass(a){this._hass=a,a&&this.shadowRoot&&this._config&&!this._entitySelectsPopulated&&this._populateEntitySelects()}_populateEntitySelects(){const a=this.shadowRoot,d=this._hass,c=this._config||{};if(!a||!d)return;this._entitySelectsPopulated=!0,[{id:"weather_entity",domains:["weather"]},{id:"sun_entity",domains:["sun"]},{id:"moon_phase_entity",domains:["sensor"]},{id:"uv_index_entity",domains:["sensor"]},{id:"moon_position_entity",domains:["sensor"]},{id:"moon_azimuth_entity",domains:["sensor"]},{id:"moon_altitude_entity",domains:["sensor"]},{id:"moon_distance_entity",domains:["sensor"]},{id:"wind_speed_entity",domains:["sensor"]},{id:"wind_direction_entity",domains:["sensor"]},{id:"cloud_coverage_entity",domains:["sensor"]},{id:"precipitation_entity",domains:["sensor"]},{id:"pm25_entity",domains:["sensor"]},{id:"pm4_entity",domains:["sensor"]},{id:"pm10_entity",domains:["sensor"]},{id:"gaming_mode_entity",domains:["input_boolean","binary_sensor"]},{id:"lightning_counter_entity",domains:["sensor"]},{id:"lightning_distance_entity",domains:["sensor"]},{id:"aurora_chance_entity",domains:["sensor"]},{id:"aurora_visibility_alert_entity",domains:["binary_sensor"]},{id:"k_index_entity",domains:["sensor"]}].forEach(({id:Z,domains:m})=>{const b=a.getElementById(Z+"_list");if(!b)return;const h=c[Z]||"",p=n(d,m,h);b.innerHTML=p.filter(V=>V.value).map(V=>`<option value="${e(V.value)}">${e(V.label)}</option>`).join("")})}_updateFormValues(a){const d=this.shadowRoot;if(!d||!a)return;const c=(Z,m)=>{const b=d.getElementById(Z);b&&(b.type==="checkbox"?b.checked=!!m:b.value=m!=null?String(m):"")};c("enabled",a.enabled),c("weather_entity",a.weather_entity),c("sun_entity",a.sun_entity),c("moon_phase_entity",a.moon_phase_entity),c("uv_index_entity",a.uv_index_entity),c("moon_position_entity",a.moon_position_entity),c("moon_azimuth_entity",a.moon_azimuth_entity),c("moon_altitude_entity",a.moon_altitude_entity),c("moon_distance_entity",a.moon_distance_entity),c("gaming_mode_entity",a.gaming_mode_entity),c("pm25_entity",a.pm25_entity),c("pm4_entity",a.pm4_entity),c("pm10_entity",a.pm10_entity),c("smog_threshold_pm25",a.smog_threshold_pm25),c("smog_threshold_pm4",a.smog_threshold_pm4),c("smog_threshold_pm10",a.smog_threshold_pm10),c("cloud_coverage_entity",a.cloud_coverage_entity),c("wind_speed_entity",a.wind_speed_entity),c("wind_direction_entity",a.wind_direction_entity),c("precipitation_entity",a.precipitation_entity),c("lightning_counter_entity",a.lightning_counter_entity),c("lightning_distance_entity",a.lightning_distance_entity),c("aurora_variant",a.aurora_variant||"bands"),c("aurora_chance_entity",a.aurora_chance_entity),c("aurora_visibility_alert_entity",a.aurora_visibility_alert_entity),c("aurora_visibility_min",a.aurora_visibility_min),c("k_index_entity",a.k_index_entity),c("enable_aurora_effect",a.enable_aurora_effect),c("debug_aurora_score",a.debug_aurora_score),c("cloud_speed_multiplier",a.cloud_speed_multiplier),c("wind_sway_factor",a.wind_sway_factor),c("rain_max_tilt_deg",a.rain_max_tilt_deg),c("rain_wind_min_kmh",a.rain_wind_min_kmh),c("enable_rain",a.enable_rain),c("enable_snow",a.enable_snow),c("enable_clouds",a.enable_clouds),c("enable_fog",a.enable_fog),c("enable_smog_effect",a.enable_smog_effect),c("enable_sun_glow",a.enable_sun_glow),c("enable_moon_glow",a.enable_moon_glow),c("enable_stars",a.enable_stars),c("enable_hail",a.enable_hail),c("enable_lightning_effect",a.enable_lightning_effect),c("enable_matrix",a.enable_matrix),c("enable_window_droplets",a.enable_window_droplets),c("stars_require_moon",a.stars_require_moon),["moon","clouds","aurora","stars","droplets","sun","fog","smog"].forEach(Z=>c("opacity_"+Z,a["opacity_"+Z]??100)),c("drizzle_precipitation_max",a.drizzle_precipitation_max),["rain","snow","clouds","fog","smog","hail","lightning","stars","matrix"].forEach(Z=>c("speed_factor_"+Z,a["speed_factor_"+Z])),c("development_mode",a.development_mode),c("debug_precipitation",a.debug_precipitation),c("debug_wind_speed",a.debug_wind_speed),c("debug_wind_direction",a.debug_wind_direction),c("debug_lightning_distance",a.debug_lightning_distance),c("debug_lightning_counter",a.debug_lightning_counter),c("debug_cloud_coverage",a.debug_cloud_coverage),c("mobile_limit_dpr",a.mobile_limit_dpr),c("mobile_reduce_particles",a.mobile_reduce_particles),c("mobile_snowy2_light",a.mobile_snowy2_light),c("mobile_smog_simple",a.mobile_smog_simple),c("mobile_30fps",a.mobile_30fps),c("gaming_matrix_only",a.gaming_matrix_only),c("snowy_variant",a.snowy_variant||"snowy2"),c("theme_mode",a.theme_mode||""),c("spatial_mode",a.spatial_mode||"foreground");const o=a.test_effect||"Use Real Weather";d.querySelectorAll('input[name="test_effect"]').forEach(Z=>{Z.checked=Z.value===o})}_render(){this.shadowRoot||this.attachShadow({mode:"open"});const a=this._config||l,d=this._hass,c=["Use Real Weather","rainy","pouring","cloudy","partlycloudy","fog","lightning","lightning-rainy","snowy","snowy-rainy","clear-night","sunny","hail"],o=n(d,["weather"],a.weather_entity),Z=n(d,["sun"],a.sun_entity),m=h=>n(d,["sensor"],h),b=n(d,["input_boolean","binary_sensor"],a.gaming_mode_entity);this.shadowRoot.innerHTML=`
        <style>
          :host { display: block; }
          .editor { padding: 16px; max-width: 560px; }
          ha-expansion-panel { margin-bottom: 8px; --expansion-panel-content-padding: 12px 16px; }
          ha-expansion-panel .content { padding: 12px 16px; }
          .section { margin-bottom: 16px; }
          .section-title { font-size: 0.9em; font-weight: 600; margin-bottom: 10px; color: var(--primary-text-color); }
          .form-row { margin-bottom: 16px; display: flex; flex-wrap: wrap; align-items: center; gap: 12px; }
          .form-row label { font-size: 14px; color: var(--secondary-text-color); min-width: 140px; }
          .entity-select, input[type="text"], input[type="number"], select {
            min-width: 220px; max-width: 100%;
            padding: 8px 12px;
            border-radius: var(--mdc-shape-small, 8px);
            border: 1px solid var(--divider-color, rgba(0,0,0,0.12));
            background: var(--ha-card-background, var(--card-background-color));
            color: var(--primary-text-color);
            font-size: 14px;
            font-family: var(--mdc-typography-font-family, Roboto, sans-serif);
          }
          .entity-select:focus, input:focus, select:focus { outline: none; border-color: var(--primary-color); }
          input[type="number"] { min-width: 72px; width: 72px; }
          .radio-group { display: flex; flex-wrap: wrap; gap: 12px; }
          .radio-group label { min-width: auto; cursor: pointer; }
          input[type="checkbox"] { cursor: pointer; width: 18px; height: 18px; accent-color: var(--primary-color); }
        </style>
        <div class="editor">
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:cog"></ha-icon> General</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">General</div>
            <div class="form-row">
              <label><input type="checkbox" id="enabled" ${a.enabled?"checked":""}> Enable overlay</label>
            </div>
            <div class="form-row">
              <label>Weather entity</label>
              <input id="weather_entity" type="text" class="entity-select" list="weather_entity_list" value="${a.weather_entity||""}" placeholder="np. weather.openweathermap">
              <datalist id="weather_entity_list">
                ${o.map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Sun entity</label>
              <input id="sun_entity" type="text" class="entity-select" list="sun_entity_list" value="${a.sun_entity||""}" placeholder="sun.sun">
              <datalist id="sun_entity_list">
                ${Z.map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:weather-night"></ha-icon> Moon &amp; UV</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Moon &amp; UV</div>
            <div class="form-row">
              <label>Moon phase</label>
              <input id="moon_phase_entity" type="text" class="entity-select" list="moon_phase_entity_list" value="${a.moon_phase_entity||""}" placeholder="sensor.moon_phase">
              <datalist id="moon_phase_entity_list">
                ${m(a.moon_phase_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>UV index</label>
              <input id="uv_index_entity" type="text" class="entity-select" list="uv_index_entity_list" value="${a.uv_index_entity||""}" placeholder="sensor.uv_index">
              <datalist id="uv_index_entity_list">
                ${m(a.uv_index_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Moon position (single)</label>
              <input id="moon_position_entity" type="text" class="entity-select" list="moon_position_entity_list" value="${a.moon_position_entity||""}" placeholder="sensor.moon_position">
              <datalist id="moon_position_entity_list">
                ${m(a.moon_position_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row"><label>Lunar Phase (3 sensors)</label></div>
            <div class="form-row">
              <label>Azimuth</label>
              <input id="moon_azimuth_entity" type="text" class="entity-select" list="moon_azimuth_entity_list" value="${a.moon_azimuth_entity||""}" placeholder="sensor.moon_azimuth">
              <datalist id="moon_azimuth_entity_list">
                ${m(a.moon_azimuth_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Altitude</label>
              <input id="moon_altitude_entity" type="text" class="entity-select" list="moon_altitude_entity_list" value="${a.moon_altitude_entity||""}" placeholder="sensor.moon_altitude">
              <datalist id="moon_altitude_entity_list">
                ${m(a.moon_altitude_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Distance</label>
              <input id="moon_distance_entity" type="text" class="entity-select" list="moon_distance_entity_list" value="${a.moon_distance_entity||""}" placeholder="sensor.moon_distance">
              <datalist id="moon_distance_entity_list">
                ${m(a.moon_distance_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:weather-windy"></ha-icon> Wind, clouds, precipitation</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Wind, clouds, precipitation</div>
            <div class="form-row">
              <label>Wind speed</label>
              <input id="wind_speed_entity" type="text" class="entity-select" list="wind_speed_entity_list" value="${a.wind_speed_entity||""}" placeholder="sensor.wind_speed">
              <datalist id="wind_speed_entity_list">
                ${m(a.wind_speed_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Wind direction</label>
              <input id="wind_direction_entity" type="text" class="entity-select" list="wind_direction_entity_list" value="${a.wind_direction_entity||""}" placeholder="sensor.wind_direction">
              <datalist id="wind_direction_entity_list">
                ${m(a.wind_direction_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Cloud coverage</label>
              <input id="cloud_coverage_entity" type="text" class="entity-select" list="cloud_coverage_entity_list" value="${a.cloud_coverage_entity||""}" placeholder="sensor.cloud_coverage">
              <datalist id="cloud_coverage_entity_list">
                ${m(a.cloud_coverage_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Precipitation</label>
              <input id="precipitation_entity" type="text" class="entity-select" list="precipitation_entity_list" value="${a.precipitation_entity||""}" placeholder="sensor.precipitation">
              <datalist id="precipitation_entity_list">
                ${m(a.precipitation_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Cloud speed multiplier</label>
              <input type="number" id="cloud_speed_multiplier" value="${a.cloud_speed_multiplier??1}" min="0.1" max="3" step="0.1" style="width:72px">
            </div>
            <div class="form-row">
              <label>Drizzle threshold (mm)</label>
              <input type="number" id="drizzle_precipitation_max" value="${a.drizzle_precipitation_max??2.5}" min="0" max="20" step="0.5" style="width:72px" title="Precipitation ≤ this = drizzle (light rain); above = normal rain">
            </div>
            <div class="form-row">
              <label>Wind sway factor</label>
              <input type="number" id="wind_sway_factor" value="${a.wind_sway_factor??.7}" min="0" max="2" step="0.1" style="width:72px" title="How strongly wind bends rain/snow (0 = off, 0.7 = default)">
            </div>
            <div class="form-row">
              <label>Rain max tilt (°)</label>
              <input type="number" id="rain_max_tilt_deg" value="${a.rain_max_tilt_deg??30}" min="0" max="60" step="5" style="width:72px" title="Max rain/snow tilt from wind (default 30)">
              <label>Rain wind min (km/h)</label>
              <input type="number" id="rain_wind_min_kmh" value="${a.rain_wind_min_kmh??3}" min="0" max="20" step="1" style="width:72px" title="Min wind speed to tilt rain (default 3)">
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:speedometer"></ha-icon> Effect speed factors (1 = default, 0.1–3)</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Effect speed factors (1 = default, 0.1–3)</div>
            <div class="form-row" style="flex-wrap:wrap;gap:8px 16px;">
              <label>Rain</label><input type="number" id="speed_factor_rain" value="${a.speed_factor_rain??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Snow</label><input type="number" id="speed_factor_snow" value="${a.speed_factor_snow??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Clouds</label><input type="number" id="speed_factor_clouds" value="${a.speed_factor_clouds??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Fog</label><input type="number" id="speed_factor_fog" value="${a.speed_factor_fog??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Smog</label><input type="number" id="speed_factor_smog" value="${a.speed_factor_smog??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Hail</label><input type="number" id="speed_factor_hail" value="${a.speed_factor_hail??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Lightning</label><input type="number" id="speed_factor_lightning" value="${a.speed_factor_lightning??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Stars</label><input type="number" id="speed_factor_stars" value="${a.speed_factor_stars??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Matrix</label><input type="number" id="speed_factor_matrix" value="${a.speed_factor_matrix??1}" min="0.1" max="3" step="0.1" style="width:52px">
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:tune"></ha-icon> Effects enabled</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Toggle individual effects (disable heavy ones if needed)</div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_rain" ${a.enable_rain!==!1?"checked":""}> Rain (rainy / pouring / lightning-rainy)</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_snow" ${a.enable_snow!==!1?"checked":""}> Snow (snowy / snowy2 / snowy-rainy)</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_clouds" ${a.enable_clouds!==!1?"checked":""}> Clouds</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_fog" ${a.enable_fog!==!1?"checked":""}> Fog</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_smog_effect" ${a.enable_smog_effect!==!1?"checked":""}> Smog alert fog</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_sun_glow" ${a.enable_sun_glow!==!1?"checked":""}> Sun glow / beams</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_moon_glow" ${a.enable_moon_glow!==!1?"checked":""}> Moon glow</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_stars" ${a.enable_stars!==!1?"checked":""}> Stars</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="stars_require_moon" ${a.stars_require_moon?"checked":""}> Stars require moon glow</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_hail" ${a.enable_hail!==!1?"checked":""}> Hail (meteors)</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_lightning_effect" ${a.enable_lightning_effect!==!1?"checked":""}> Lightning flashes</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_matrix" ${a.enable_matrix!==!1?"checked":""}> Matrix / gaming overlay</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_window_droplets" ${a.enable_window_droplets!==!1?"checked":""}> Window droplets (side rain on glass)</label>
            </div>
            <div class="section-title" style="margin-top:12px">Effect opacity (0–100, default 100)</div>
            <div class="form-row">
              <label>Moon</label><input type="number" id="opacity_moon" value="${a.opacity_moon??100}" min="0" max="100" style="width:52px">
              <label>Clouds</label><input type="number" id="opacity_clouds" value="${a.opacity_clouds??100}" min="0" max="100" style="width:52px">
              <label>Aurora</label><input type="number" id="opacity_aurora" value="${a.opacity_aurora??100}" min="0" max="100" style="width:52px">
              <label>Stars</label><input type="number" id="opacity_stars" value="${a.opacity_stars??100}" min="0" max="100" style="width:52px">
              <label>Droplets</label><input type="number" id="opacity_droplets" value="${a.opacity_droplets??100}" min="0" max="100" style="width:52px">
              <label>Sun</label><input type="number" id="opacity_sun" value="${a.opacity_sun??100}" min="0" max="100" style="width:52px">
              <label>Fog</label><input type="number" id="opacity_fog" value="${a.opacity_fog??100}" min="0" max="100" style="width:52px">
              <label>Smog</label><input type="number" id="opacity_smog" value="${a.opacity_smog??100}" min="0" max="100" style="width:52px">
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:target"></ha-icon> Spatial awareness</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Spatial awareness (where effects are drawn)</div>
            <div class="form-row">
              <label>Theme</label>
              <select id="theme_mode" title="Override light/dark for snow/effects; null = auto from HA theme">
                <option value="" ${a.theme_mode?"":"selected"}>Auto (from HA theme)</option>
                <option value="light" ${a.theme_mode==="light"?"selected":""}>Light</option>
                <option value="dark" ${a.theme_mode==="dark"?"selected":""}>Dark</option>
              </select>
            </div>
            <div class="form-row">
              <label>Mode</label>
              <select id="spatial_mode" class="entity-select">
                <option value="background" ${a.spatial_mode==="background"?"selected":""}>Background (behind all cards, z-index -1)</option>
                <option value="bubble" ${a.spatial_mode==="bubble"?"selected":""}>Bubble aware (under Bubble card backdrops, z-index 3)</option>
                <option value="gradient-mask" ${a.spatial_mode==="gradient-mask"?"selected":""}>Gradient mask (effects around card edges)</option>
                <option value="foreground" ${!a.spatial_mode||a.spatial_mode==="foreground"?"selected":""}>Foreground (current behavior, above cards)</option>
              </select>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:snowflake"></ha-icon> Snow variant</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Snow variant</div>
            <div class="form-row">
              <label>Preferred snow style</label>
              <select id="snowy_variant" class="entity-select">
                <option value="snowy" ${a.snowy_variant==="snowy"?"selected":""}>Classic snowy (particles)</option>
                <option value="snowy2" ${!a.snowy_variant||a.snowy_variant==="snowy2"?"selected":""}>Snowy2 (layered, lighter on mobile)</option>
              </select>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:northern-lights"></ha-icon> Aurora (Northern Lights)</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Aurora effect on clear nights – header bands when visibility score &gt; threshold</div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_aurora_effect" ${a.enable_aurora_effect!==!1?"checked":""}> Enable aurora effect</label>
            </div>
            <div class="form-row">
              <label>Style</label>
              <select id="aurora_variant" title="Bands: footer-style header; Northern Gradients: soft flowing curtains">
                <option value="bands" ${a.aurora_variant==="bands"||!a.aurora_variant?"selected":""}>Bands (header stripes)</option>
                <option value="northern-gradients" ${a.aurora_variant==="northern-gradients"?"selected":""}>Bubble Northern Gradients (soft curtains)</option>
              </select>
            </div>
            <div class="form-row">
              <label>Aurora chance entity (%)</label>
              <input id="aurora_chance_entity" type="text" class="entity-select" list="aurora_chance_entity_list" value="${a.aurora_chance_entity||""}" placeholder="sensor.aurora_60_1">
              <datalist id="aurora_chance_entity_list">
                ${m(a.aurora_chance_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
              <span class="help">NOAA Aurora Forecast 0–100</span>
            </div>
            <div class="form-row">
              <label>Aurora alert (binary)</label>
              <input id="aurora_visibility_alert_entity" type="text" class="entity-select" list="aurora_visibility_alert_entity_list" value="${a.aurora_visibility_alert_entity||""}" placeholder="binary_sensor.aurora_visibility_alert">
              <datalist id="aurora_visibility_alert_entity_list">
                ${n(d,["binary_sensor"],a.aurora_visibility_alert_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
              <span class="help">Optional shortcut when ON</span>
            </div>
            <div class="form-row">
              <label>K-index (optional)</label>
              <input id="k_index_entity" type="text" class="entity-select" list="k_index_entity_list" value="${a.k_index_entity||""}" placeholder="sensor.planetary_k_index">
              <datalist id="k_index_entity_list">
                ${m(a.k_index_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
              <span class="help">Planetary Kp from NOAA Space Weather</span>
            </div>
            <div class="form-row">
              <label>Min visibility score (0–1)</label>
              <input type="number" id="aurora_visibility_min" value="${a.aurora_visibility_min??.15}" min="0" max="1" step="0.05" style="width:72px" title="Minimum score to show effect (default 0.15)">
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:blur"></ha-icon> Smog (PM µg/m³ – fog above threshold)</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Smog (PM µg/m³ – fog when above threshold). Default thresholds: WHO / EPA / EU</div>
            <div class="form-row">
              <label>PM2.5</label>
              <input id="pm25_entity" type="text" class="entity-select" list="pm25_entity_list" value="${a.pm25_entity||""}" placeholder="sensor.pm25">
              <datalist id="pm25_entity_list">
                ${m(a.pm25_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
              <label>Alert threshold (µg/m³)</label>
              <input type="number" id="smog_threshold_pm25" value="${a.smog_threshold_pm25??35}" min="1" max="500" style="width:60px" title="Default 35 (EPA: unhealthy for sensitive groups)">
            </div>
            <div class="form-row">
              <label>PM4</label>
              <input id="pm4_entity" type="text" class="entity-select" list="pm4_entity_list" value="${a.pm4_entity||""}" placeholder="sensor.pm4">
              <datalist id="pm4_entity_list">
                ${m(a.pm4_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
              <label>Alert threshold (µg/m³)</label>
              <input type="number" id="smog_threshold_pm4" value="${a.smog_threshold_pm4??50}" min="1" max="500" style="width:60px">
            </div>
            <div class="form-row">
              <label>PM10</label>
              <input id="pm10_entity" type="text" class="entity-select" list="pm10_entity_list" value="${a.pm10_entity||""}" placeholder="sensor.pm10">
              <datalist id="pm10_entity_list">
                ${m(a.pm10_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
              <label>Alert threshold (µg/m³)</label>
              <input type="number" id="smog_threshold_pm10" value="${a.smog_threshold_pm10??50}" min="1" max="500" style="width:60px" title="Default 50 (EU 24h limit / WHO guideline)">
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:flash"></ha-icon> Gaming &amp; Lightning</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Gaming &amp; Lightning</div>
            <div class="form-row">
              <label>Gaming mode</label>
              <input id="gaming_mode_entity" type="text" class="entity-select" list="gaming_mode_entity_list" value="${a.gaming_mode_entity||""}" placeholder="input_boolean.gaming_mode">
              <datalist id="gaming_mode_entity_list">
                ${b.map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="gaming_matrix_only" ${a.gaming_matrix_only?"checked":""}> When Gaming ON: Matrix only (no weather background)</label>
            </div>
            <div class="form-row">
              <label>Lightning counter</label>
              <input id="lightning_counter_entity" type="text" class="entity-select" list="lightning_counter_entity_list" value="${a.lightning_counter_entity||""}" placeholder="sensor.lightning_counter">
              <datalist id="lightning_counter_entity_list">
                ${m(a.lightning_counter_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Lightning distance</label>
              <input id="lightning_distance_entity" type="text" class="entity-select" list="lightning_distance_entity_list" value="${a.lightning_distance_entity||""}" placeholder="sensor.lightning_distance">
              <datalist id="lightning_distance_entity_list">
                ${m(a.lightning_distance_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:cellphone"></ha-icon> Mobile</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Mobile</div>
            <div class="form-row">
              <label><input type="checkbox" id="mobile_limit_dpr" ${a.mobile_limit_dpr?"checked":""}> Limit canvas resolution on mobile (better performance)</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="mobile_reduce_particles" ${a.mobile_reduce_particles?"checked":""}> Fewer particles (rain/snow/fog) on mobile</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="mobile_snowy2_light" ${a.mobile_snowy2_light?"checked":""}> Lighter <code>snowy2</code> snow on mobile</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="mobile_smog_simple" ${a.mobile_smog_simple?"checked":""}> Simpler smog rendering on mobile</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="mobile_30fps" ${a.mobile_30fps?"checked":""}> Limit animation to ~30 FPS on mobile</label>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:test-tube"></ha-icon> Development mode</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Development mode</div>
            <div class="form-row">
              <label><input type="checkbox" id="development_mode" ${a.development_mode?"checked":""}> Override real weather for testing</label>
            </div>
            ${a.development_mode?`
            <div class="form-row">
              <label>Test effect</label>
              <div class="radio-group">
                ${c.map(h=>`
                  <label><input type="radio" name="test_effect" value="${e(h)}" ${a.test_effect===h?"checked":""}> ${e(h)}</label>
                `).join("")}
              </div>
            </div>
            <div class="form-row" style="margin-top:10px;"><strong>Debug overrides</strong></div>
            <div class="form-row">
              <label>Precipitation</label>
              <select id="debug_precipitation">
                <option value="">Use sensors</option>
                <option value="light" ${a.debug_precipitation==="light"?"selected":""}>Light (~1 mm/h)</option>
                <option value="medium" ${a.debug_precipitation==="medium"?"selected":""}>Medium (~3 mm/h)</option>
                <option value="heavy" ${a.debug_precipitation==="heavy"?"selected":""}>Heavy (~8 mm/h)</option>
              </select>
            </div>
            <div class="form-row">
              <label>Wind speed</label>
              <select id="debug_wind_speed">
                <option value="">Use sensors</option>
                <option value="none" ${a.debug_wind_speed==="none"?"selected":""}>None</option>
                <option value="light" ${a.debug_wind_speed==="light"?"selected":""}>Light (~10 km/h)</option>
                <option value="medium" ${a.debug_wind_speed==="medium"?"selected":""}>Medium (~25 km/h)</option>
                <option value="strong" ${a.debug_wind_speed==="strong"?"selected":""}>Strong (~45 km/h)</option>
              </select>
            </div>
            <div class="form-row">
              <label>Wind direction</label>
              <select id="debug_wind_direction">
                <option value="">Use sensors</option>
                <option value="N" ${a.debug_wind_direction==="N"?"selected":""}>N</option>
                <option value="NE" ${a.debug_wind_direction==="NE"?"selected":""}>NE</option>
                <option value="E" ${a.debug_wind_direction==="E"?"selected":""}>E</option>
                <option value="SE" ${a.debug_wind_direction==="SE"?"selected":""}>SE</option>
                <option value="S" ${a.debug_wind_direction==="S"?"selected":""}>S</option>
                <option value="SW" ${a.debug_wind_direction==="SW"?"selected":""}>SW</option>
                <option value="W" ${a.debug_wind_direction==="W"?"selected":""}>W</option>
                <option value="NW" ${a.debug_wind_direction==="NW"?"selected":""}>NW</option>
              </select>
            </div>
            <div class="form-row">
              <label>Lightning distance (km)</label>
              <input type="number" id="debug_lightning_distance" value="${a.debug_lightning_distance??""}" placeholder="override" min="0" max="500" step="0.5" style="width:80px">
              <label>Lightning counter</label>
              <input type="number" id="debug_lightning_counter" value="${a.debug_lightning_counter??""}" placeholder="override" min="0" style="width:60px">
            </div>
            <div class="form-row">
              <label>Cloud coverage (%)</label>
              <input type="number" id="debug_cloud_coverage" value="${a.debug_cloud_coverage??""}" placeholder="0-100" min="0" max="100" style="width:80px">
            </div>
            <div class="form-row">
              <label>Aurora visibility score (0–1)</label>
              <input type="number" id="debug_aurora_score" value="${a.debug_aurora_score??""}" placeholder="force aurora" min="0" max="1" step="0.1" style="width:80px" title="Force aurora effect in dev mode">
            </div>
            `:""}
          </div>
            </div>
          </ha-expansion-panel>
        </div>
      `,this._attachListeners(),this._hass&&this._populateEntitySelects()}_attachListeners(){const a=this.shadowRoot;if(!a)return;const d=this._config||l,c=()=>{const Z=Object.assign({},d,{enabled:a.getElementById("enabled").checked,weather_entity:a.getElementById("weather_entity").value||l.weather_entity,sun_entity:a.getElementById("sun_entity").value||l.sun_entity,moon_phase_entity:a.getElementById("moon_phase_entity").value||null,uv_index_entity:a.getElementById("uv_index_entity").value||null,moon_position_entity:a.getElementById("moon_position_entity").value||null,moon_azimuth_entity:a.getElementById("moon_azimuth_entity").value||null,moon_altitude_entity:a.getElementById("moon_altitude_entity").value||null,moon_distance_entity:a.getElementById("moon_distance_entity").value||null,gaming_mode_entity:a.getElementById("gaming_mode_entity").value||null,pm25_entity:a.getElementById("pm25_entity").value||null,pm4_entity:a.getElementById("pm4_entity").value||null,pm10_entity:a.getElementById("pm10_entity").value||null,smog_threshold_pm25:parseInt(a.getElementById("smog_threshold_pm25")?.value||"35",10)||35,smog_threshold_pm4:parseInt(a.getElementById("smog_threshold_pm4")?.value||"50",10)||50,smog_threshold_pm10:parseInt(a.getElementById("smog_threshold_pm10")?.value||"50",10)||50,cloud_coverage_entity:a.getElementById("cloud_coverage_entity")?.value||null,wind_speed_entity:a.getElementById("wind_speed_entity")?.value||null,wind_direction_entity:a.getElementById("wind_direction_entity")?.value||null,precipitation_entity:a.getElementById("precipitation_entity")?.value||null,lightning_counter_entity:a.getElementById("lightning_counter_entity")?.value||null,lightning_distance_entity:a.getElementById("lightning_distance_entity")?.value||null,debug_precipitation:a.getElementById("debug_precipitation")?.value||null,debug_wind_speed:a.getElementById("debug_wind_speed")?.value||null,debug_wind_direction:a.getElementById("debug_wind_direction")?.value||null,debug_lightning_distance:a.getElementById("debug_lightning_distance")?.value||null,debug_lightning_counter:a.getElementById("debug_lightning_counter")?.value||null,debug_cloud_coverage:a.getElementById("debug_cloud_coverage")?.value||null,debug_aurora_score:a.getElementById("debug_aurora_score")?.value||null,aurora_variant:a.getElementById("aurora_variant")?.value||"bands",aurora_chance_entity:a.getElementById("aurora_chance_entity")?.value||null,aurora_visibility_alert_entity:a.getElementById("aurora_visibility_alert_entity")?.value||null,aurora_visibility_min:parseFloat(a.getElementById("aurora_visibility_min")?.value||"0.15")||.15,k_index_entity:a.getElementById("k_index_entity")?.value||null,enable_aurora_effect:!!a.getElementById("enable_aurora_effect")?.checked,cloud_speed_multiplier:parseFloat(a.getElementById("cloud_speed_multiplier")?.value||"1")||1,drizzle_precipitation_max:parseFloat(a.getElementById("drizzle_precipitation_max")?.value||"2.5")||2.5,wind_sway_factor:parseFloat(a.getElementById("wind_sway_factor")?.value||"0.7")||.7,rain_max_tilt_deg:parseFloat(a.getElementById("rain_max_tilt_deg")?.value||"30")||30,rain_wind_min_kmh:parseFloat(a.getElementById("rain_wind_min_kmh")?.value||"3")||3,speed_factor_rain:parseFloat(a.getElementById("speed_factor_rain")?.value||"1")||1,speed_factor_snow:parseFloat(a.getElementById("speed_factor_snow")?.value||"1")||1,speed_factor_clouds:parseFloat(a.getElementById("speed_factor_clouds")?.value||"1")||1,speed_factor_fog:parseFloat(a.getElementById("speed_factor_fog")?.value||"1")||1,speed_factor_smog:parseFloat(a.getElementById("speed_factor_smog")?.value||"1")||1,speed_factor_hail:parseFloat(a.getElementById("speed_factor_hail")?.value||"1")||1,speed_factor_lightning:parseFloat(a.getElementById("speed_factor_lightning")?.value||"1")||1,speed_factor_stars:parseFloat(a.getElementById("speed_factor_stars")?.value||"1")||1,speed_factor_matrix:parseFloat(a.getElementById("speed_factor_matrix")?.value||"1")||1,enable_rain:!!a.getElementById("enable_rain")?.checked,enable_snow:!!a.getElementById("enable_snow")?.checked,enable_clouds:!!a.getElementById("enable_clouds")?.checked,enable_fog:!!a.getElementById("enable_fog")?.checked,enable_smog_effect:!!a.getElementById("enable_smog_effect")?.checked,enable_sun_glow:!!a.getElementById("enable_sun_glow")?.checked,enable_moon_glow:!!a.getElementById("enable_moon_glow")?.checked,enable_stars:!!a.getElementById("enable_stars")?.checked,enable_hail:!!a.getElementById("enable_hail")?.checked,enable_lightning_effect:!!a.getElementById("enable_lightning_effect")?.checked,enable_matrix:!!a.getElementById("enable_matrix")?.checked,enable_window_droplets:!!a.getElementById("enable_window_droplets")?.checked,stars_require_moon:!!a.getElementById("stars_require_moon")?.checked,opacity_moon:Math.max(0,Math.min(100,parseFloat(a.getElementById("opacity_moon")?.value||"100")||100)),opacity_clouds:Math.max(0,Math.min(100,parseFloat(a.getElementById("opacity_clouds")?.value||"100")||100)),opacity_aurora:Math.max(0,Math.min(100,parseFloat(a.getElementById("opacity_aurora")?.value||"100")||100)),opacity_stars:Math.max(0,Math.min(100,parseFloat(a.getElementById("opacity_stars")?.value||"100")||100)),opacity_droplets:Math.max(0,Math.min(100,parseFloat(a.getElementById("opacity_droplets")?.value||"100")||100)),opacity_sun:Math.max(0,Math.min(100,parseFloat(a.getElementById("opacity_sun")?.value||"100")||100)),opacity_fog:Math.max(0,Math.min(100,parseFloat(a.getElementById("opacity_fog")?.value||"100")||100)),opacity_smog:Math.max(0,Math.min(100,parseFloat(a.getElementById("opacity_smog")?.value||"100")||100)),mobile_limit_dpr:!!a.getElementById("mobile_limit_dpr")?.checked,mobile_reduce_particles:!!a.getElementById("mobile_reduce_particles")?.checked,mobile_snowy2_light:!!a.getElementById("mobile_snowy2_light")?.checked,mobile_smog_simple:!!a.getElementById("mobile_smog_simple")?.checked,mobile_30fps:!!a.getElementById("mobile_30fps")?.checked,gaming_matrix_only:!!a.getElementById("gaming_matrix_only")?.checked,snowy_variant:a.getElementById("snowy_variant")?.value||"snowy2",theme_mode:a.getElementById("theme_mode")?.value||null,spatial_mode:a.getElementById("spatial_mode")?.value||"foreground",development_mode:a.getElementById("development_mode").checked,test_effect:(a.querySelector('input[name="test_effect"]:checked')||{}).value||"Use Real Weather"});this._config=Z,window.ForkUWeatherAwareConfig=Z,this.dispatchEvent(new CustomEvent("config-changed",{detail:{config:Z}}))};["weather_entity","sun_entity","theme_mode","moon_phase_entity","uv_index_entity","moon_position_entity","moon_azimuth_entity","moon_altitude_entity","moon_distance_entity","gaming_mode_entity","pm25_entity","pm4_entity","pm10_entity","smog_threshold_pm25","smog_threshold_pm4","smog_threshold_pm10","cloud_coverage_entity","wind_speed_entity","wind_direction_entity","precipitation_entity","lightning_counter_entity","lightning_distance_entity","aurora_variant","aurora_chance_entity","aurora_visibility_alert_entity","aurora_visibility_min","k_index_entity","debug_precipitation","debug_wind_speed","debug_wind_direction","debug_lightning_distance","debug_lightning_counter","debug_cloud_coverage","debug_aurora_score","cloud_speed_multiplier","drizzle_precipitation_max","wind_sway_factor","rain_max_tilt_deg","rain_wind_min_kmh","speed_factor_rain","speed_factor_snow","speed_factor_clouds","speed_factor_fog","speed_factor_smog","speed_factor_hail","speed_factor_lightning","speed_factor_stars","speed_factor_matrix","snowy_variant","spatial_mode","opacity_moon","opacity_clouds","opacity_aurora","opacity_stars","opacity_droplets","opacity_sun","opacity_fog","opacity_smog"].forEach(Z=>{const m=a.getElementById(Z);m&&m.addEventListener("change",c)}),["enabled","development_mode","mobile_limit_dpr","mobile_reduce_particles","mobile_snowy2_light","mobile_smog_simple","mobile_30fps","gaming_matrix_only","enable_rain","enable_snow","enable_clouds","enable_fog","enable_smog_effect","enable_sun_glow","enable_moon_glow","enable_stars","enable_hail","enable_lightning_effect","enable_matrix","enable_window_droplets","stars_require_moon","enable_aurora_effect"].forEach(Z=>{const m=a.getElementById(Z);m&&m.addEventListener("change",c)}),a.querySelectorAll('input[name="test_effect"]').forEach(Z=>{Z.addEventListener("change",c)})}}customElements.get("fork-u-weather-aware-card")||customElements.define("fork-u-weather-aware-card",t),customElements.get("fork-u-weather-aware-editor")||customElements.define("fork-u-weather-aware-editor",i)}()})();
