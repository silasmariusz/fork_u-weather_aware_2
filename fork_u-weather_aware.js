(function(){"use strict";const cs={enabled:!0,weather_entity:"weather.openweathermap",development_mode:!1,test_effect:"Use Real Weather",sun_entity:"sun.sun",moon_phase_entity:null,uv_index_entity:null,moon_position_entity:null,moon_azimuth_entity:null,moon_altitude_entity:null,moon_distance_entity:null,gaming_mode_entity:null,pm25_entity:null,pm4_entity:null,pm10_entity:null,smog_threshold_pm25:35,smog_threshold_pm4:50,smog_threshold_pm10:50,cloud_coverage_entity:null,wind_speed_entity:null,wind_direction_entity:null,precipitation_entity:null,lightning_counter_entity:null,lightning_distance_entity:null,debug_precipitation:null,debug_wind_speed:null,debug_wind_direction:null,debug_lightning_distance:null,debug_lightning_counter:null,debug_cloud_coverage:null,cloud_speed_multiplier:1,rain_max_tilt_deg:30,rain_wind_min_kmh:3,theme_mode:null,drizzle_precipitation_max:2.5,speed_factor_rain:1,speed_factor_snow:1,speed_factor_clouds:1,speed_factor_fog:1,speed_factor_smog:1,speed_factor_hail:1,speed_factor_lightning:1,speed_factor_stars:1,speed_factor_matrix:1,wind_sway_factor:.7,spatial_mode:"foreground",enable_rain:!0,enable_snow:!0,enable_clouds:!0,enable_fog:!0,enable_smog_effect:!0,enable_sun_glow:!0,enable_moon_glow:!0,enable_stars:!0,enable_hail:!0,enable_lightning_effect:!0,enable_matrix:!0,enable_window_droplets:!0,stars_require_moon:!1,mobile_limit_dpr:!0,mobile_reduce_particles:!0,mobile_snowy2_light:!0,mobile_smog_simple:!1,mobile_30fps:!1,gaming_matrix_only:!1,snowy_variant:"snowy2",enable_aurora_effect:!0,aurora_variant:"bands",aurora_chance_entity:null,aurora_visibility_alert_entity:null,aurora_visibility_min:.15,k_index_entity:null,debug_aurora_score:null};window.ForkUWeatherAwareConfig=Object.assign({},cs,window.ForkUWeatherAwareConfig||{}),window.ForkUWeatherAwareDefaultConfig=cs;try{console.log("%cFork U – Weather Aware%c Three.js overlay · spatial, theme & mobile aware","background:#ffcc00;color:#000;font-weight:bold;padding:2px 6px;border-radius:3px 0 0 3px;","background:#1e1e1e;color:#fff;padding:2px 6px;border-radius:0 3px 3px 0;")}catch{}/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const xi="170",Rc=0,os=1,yc=2,ms=1,Cc=2,Oe=3,ml=0,ye=1,qe=2,Zl=0,Qe=1,fe=2,Zs=3,hs=4,Sc=5,Sl=100,Ic=101,xc=102,Yc=103,Nc=104,fc=200,Fc=201,Lc=202,Uc=203,Yi=204,Ni=205,Mc=206,Tc=207,vc=208,Jc=209,kc=210,wc=211,Hc=212,zc=213,Kc=214,fi=0,Fi=1,Li=2,Hl=3,Ui=4,Mi=5,Ti=6,vi=7,us=0,Bc=1,Ec=2,hl=0,Ac=1,Qc=2,Pc=3,jc=4,_c=5,Dc=6,Oc=7,bs=300,zl=301,Kl=302,Ji=303,ki=304,Jn=306,wi=1e3,Il=1001,Hi=1002,Je=1003,qc=1004,kn=1005,be=1006,zi=1007,xl=1008,Pe=1009,rs=1010,ps=1011,Gn=1012,Ki=1013,Yl=1014,$e=1015,Wn=1016,Bi=1017,Ei=1018,Bl=1020,Gs=35902,Ws=1021,Vs=1022,Fe=1023,Xs=1024,gs=1025,El=1026,Al=1027,Rs=1028,Ai=1029,ys=1030,Qi=1031,Pi=1033,wn=33776,Hn=33777,zn=33778,Kn=33779,ji=35840,_i=35841,Di=35842,Oi=35843,qi=36196,$i=37492,ta=37496,ea=37808,la=37809,na=37810,ia=37811,aa=37812,sa=37813,da=37814,ca=37815,oa=37816,ma=37817,Za=37818,ha=37819,ua=37820,ba=37821,Bn=36492,ra=36494,pa=36495,Cs=36283,Ga=36284,Wa=36285,Va=36286,$c=3200,to=3201,eo=0,lo=1,ul="",Le="srgb",Ql="srgb-linear",En="linear",Qt="srgb",Pl=7680,Ss=519,no=512,io=513,ao=514,Is=515,so=516,co=517,oo=518,mo=519,xs=35044,Ys="300 es",tl=2e3,An=2001;class jl{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const i=this._listeners[t];if(i!==void 0){const s=i.indexOf(e);s!==-1&&i.splice(s,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const n=this._listeners[t.type];if(n!==void 0){t.target=this;const i=n.slice(0);for(let s=0,a=i.length;s<a;s++)i[s].call(this,t);t.target=null}}}const re=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let Ns=1234567;const Vn=Math.PI/180,Xn=180/Math.PI;function _l(){const l=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(re[l&255]+re[l>>8&255]+re[l>>16&255]+re[l>>24&255]+"-"+re[t&255]+re[t>>8&255]+"-"+re[t>>16&15|64]+re[t>>24&255]+"-"+re[e&63|128]+re[e>>8&255]+"-"+re[e>>16&255]+re[e>>24&255]+re[n&255]+re[n>>8&255]+re[n>>16&255]+re[n>>24&255]).toLowerCase()}function Ve(l,t,e){return Math.max(t,Math.min(e,l))}function Xa(l,t){return(l%t+t)%t}function Zo(l,t,e,n,i){return n+(l-t)*(i-n)/(e-t)}function ho(l,t,e){return l!==t?(e-l)/(t-l):0}function gn(l,t,e){return(1-e)*l+e*t}function uo(l,t,e,n){return gn(l,t,1-Math.exp(-e*n))}function bo(l,t=1){return t-Math.abs(Xa(l,t*2)-t)}function ro(l,t,e){return l<=t?0:l>=e?1:(l=(l-t)/(e-t),l*l*(3-2*l))}function po(l,t,e){return l<=t?0:l>=e?1:(l=(l-t)/(e-t),l*l*l*(l*(l*6-15)+10))}function Go(l,t){return l+Math.floor(Math.random()*(t-l+1))}function Wo(l,t){return l+Math.random()*(t-l)}function Vo(l){return l*(.5-Math.random())}function Xo(l){l!==void 0&&(Ns=l);let t=Ns+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}function go(l){return l*Vn}function Ro(l){return l*Xn}function yo(l){return(l&l-1)===0&&l!==0}function Co(l){return Math.pow(2,Math.ceil(Math.log(l)/Math.LN2))}function So(l){return Math.pow(2,Math.floor(Math.log(l)/Math.LN2))}function Io(l,t,e,n,i){const s=Math.cos,a=Math.sin,d=s(e/2),c=a(e/2),o=s((t+n)/2),Z=a((t+n)/2),m=s((t-n)/2),b=a((t-n)/2),h=s((n-t)/2),p=a((n-t)/2);switch(i){case"XYX":l.set(d*Z,c*m,c*b,d*o);break;case"YZY":l.set(c*b,d*Z,c*m,d*o);break;case"ZXZ":l.set(c*m,c*b,d*Z,d*o);break;case"XZX":l.set(d*Z,c*p,c*h,d*o);break;case"YXY":l.set(c*h,d*Z,c*p,d*o);break;case"ZYZ":l.set(c*p,c*h,d*Z,d*o);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function Dl(l,t){switch(t.constructor){case Float32Array:return l;case Uint32Array:return l/4294967295;case Uint16Array:return l/65535;case Uint8Array:return l/255;case Int32Array:return Math.max(l/2147483647,-1);case Int16Array:return Math.max(l/32767,-1);case Int8Array:return Math.max(l/127,-1);default:throw new Error("Invalid component type.")}}function Xe(l,t){switch(t.constructor){case Float32Array:return l;case Uint32Array:return Math.round(l*4294967295);case Uint16Array:return Math.round(l*65535);case Uint8Array:return Math.round(l*255);case Int32Array:return Math.round(l*2147483647);case Int16Array:return Math.round(l*32767);case Int8Array:return Math.round(l*127);default:throw new Error("Invalid component type.")}}const jt={DEG2RAD:Vn,RAD2DEG:Xn,generateUUID:_l,clamp:Ve,euclideanModulo:Xa,mapLinear:Zo,inverseLerp:ho,lerp:gn,damp:uo,pingpong:bo,smoothstep:ro,smootherstep:po,randInt:Go,randFloat:Wo,randFloatSpread:Vo,seededRandom:Xo,degToRad:go,radToDeg:Ro,isPowerOfTwo:yo,ceilPowerOfTwo:Co,floorPowerOfTwo:So,setQuaternionFromProperEuler:Io,normalize:Xe,denormalize:Dl};class ft{constructor(t=0,e=0){ft.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Ve(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),s=this.x-t.x,a=this.y-t.y;return this.x=s*n-a*i+t.x,this.y=s*i+a*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class xt{constructor(t,e,n,i,s,a,d,c,o){xt.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],t!==void 0&&this.set(t,e,n,i,s,a,d,c,o)}set(t,e,n,i,s,a,d,c,o){const Z=this.elements;return Z[0]=t,Z[1]=i,Z[2]=d,Z[3]=e,Z[4]=s,Z[5]=c,Z[6]=n,Z[7]=a,Z[8]=o,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,s=this.elements,a=n[0],d=n[3],c=n[6],o=n[1],Z=n[4],m=n[7],b=n[2],h=n[5],p=n[8],V=i[0],r=i[3],u=i[6],C=i[1],R=i[4],G=i[7],N=i[2],I=i[5],x=i[8];return s[0]=a*V+d*C+c*N,s[3]=a*r+d*R+c*I,s[6]=a*u+d*G+c*x,s[1]=o*V+Z*C+m*N,s[4]=o*r+Z*R+m*I,s[7]=o*u+Z*G+m*x,s[2]=b*V+h*C+p*N,s[5]=b*r+h*R+p*I,s[8]=b*u+h*G+p*x,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],a=t[4],d=t[5],c=t[6],o=t[7],Z=t[8];return e*a*Z-e*d*o-n*s*Z+n*d*c+i*s*o-i*a*c}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],a=t[4],d=t[5],c=t[6],o=t[7],Z=t[8],m=Z*a-d*o,b=d*c-Z*s,h=o*s-a*c,p=e*m+n*b+i*h;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const V=1/p;return t[0]=m*V,t[1]=(i*o-Z*n)*V,t[2]=(d*n-i*a)*V,t[3]=b*V,t[4]=(Z*e-i*c)*V,t[5]=(i*s-d*e)*V,t[6]=h*V,t[7]=(n*c-o*e)*V,t[8]=(a*e-n*s)*V,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,s,a,d){const c=Math.cos(s),o=Math.sin(s);return this.set(n*c,n*o,-n*(c*a+o*d)+a+t,-i*o,i*c,-i*(-o*a+c*d)+d+e,0,0,1),this}scale(t,e){return this.premultiply(ga.makeScale(t,e)),this}rotate(t){return this.premultiply(ga.makeRotation(-t)),this}translate(t,e){return this.premultiply(ga.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,n,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<9;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}const ga=new xt;function fs(l){for(let t=l.length-1;t>=0;--t)if(l[t]>=65535)return!0;return!1}function Qn(l){return document.createElementNS("http://www.w3.org/1999/xhtml",l)}function xo(){const l=Qn("canvas");return l.style.display="block",l}const Fs={};function Rn(l){l in Fs||(Fs[l]=!0,console.warn(l))}function Yo(l,t,e){return new Promise(function(n,i){function s(){switch(l.clientWaitSync(t,l.SYNC_FLUSH_COMMANDS_BIT,0)){case l.WAIT_FAILED:i();break;case l.TIMEOUT_EXPIRED:setTimeout(s,e);break;default:n()}}setTimeout(s,e)})}function No(l){const t=l.elements;t[2]=.5*t[2]+.5*t[3],t[6]=.5*t[6]+.5*t[7],t[10]=.5*t[10]+.5*t[11],t[14]=.5*t[14]+.5*t[15]}function fo(l){const t=l.elements;t[11]===-1?(t[10]=-t[10]-1,t[14]=-t[14]):(t[10]=-t[10],t[14]=-t[14]+1)}const kt={enabled:!0,workingColorSpace:Ql,spaces:{},convert:function(l,t,e){return this.enabled===!1||t===e||!t||!e||(this.spaces[t].transfer===Qt&&(l.r=el(l.r),l.g=el(l.g),l.b=el(l.b)),this.spaces[t].primaries!==this.spaces[e].primaries&&(l.applyMatrix3(this.spaces[t].toXYZ),l.applyMatrix3(this.spaces[e].fromXYZ)),this.spaces[e].transfer===Qt&&(l.r=Ol(l.r),l.g=Ol(l.g),l.b=Ol(l.b))),l},fromWorkingColorSpace:function(l,t){return this.convert(l,this.workingColorSpace,t)},toWorkingColorSpace:function(l,t){return this.convert(l,t,this.workingColorSpace)},getPrimaries:function(l){return this.spaces[l].primaries},getTransfer:function(l){return l===ul?En:this.spaces[l].transfer},getLuminanceCoefficients:function(l,t=this.workingColorSpace){return l.fromArray(this.spaces[t].luminanceCoefficients)},define:function(l){Object.assign(this.spaces,l)},_getMatrix:function(l,t,e){return l.copy(this.spaces[t].toXYZ).multiply(this.spaces[e].fromXYZ)},_getDrawingBufferColorSpace:function(l){return this.spaces[l].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(l=this.workingColorSpace){return this.spaces[l].workingColorSpaceConfig.unpackColorSpace}};function el(l){return l<.04045?l*.0773993808:Math.pow(l*.9478672986+.0521327014,2.4)}function Ol(l){return l<.0031308?l*12.92:1.055*Math.pow(l,.41666)-.055}const Ls=[.64,.33,.3,.6,.15,.06],Us=[.2126,.7152,.0722],Ms=[.3127,.329],Ts=new xt().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),vs=new xt().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);kt.define({[Ql]:{primaries:Ls,whitePoint:Ms,transfer:En,toXYZ:Ts,fromXYZ:vs,luminanceCoefficients:Us,workingColorSpaceConfig:{unpackColorSpace:Le},outputColorSpaceConfig:{drawingBufferColorSpace:Le}},[Le]:{primaries:Ls,whitePoint:Ms,transfer:Qt,toXYZ:Ts,fromXYZ:vs,luminanceCoefficients:Us,outputColorSpaceConfig:{drawingBufferColorSpace:Le}}});let ql;class Fo{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{ql===void 0&&(ql=Qn("canvas")),ql.width=t.width,ql.height=t.height;const n=ql.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=ql}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=Qn("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");n.drawImage(t,0,0,t.width,t.height);const i=n.getImageData(0,0,t.width,t.height),s=i.data;for(let a=0;a<s.length;a++)s[a]=el(s[a]/255)*255;return n.putImageData(i,0,0),e}else if(t.data){const e=t.data.slice(0);for(let n=0;n<e.length;n++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[n]=Math.floor(el(e[n]/255)*255):e[n]=el(e[n]);return{data:e,width:t.width,height:t.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let Lo=0;class Js{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:Lo++}),this.uuid=_l(),this.data=t,this.dataReady=!0,this.version=0}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(i!==null){let s;if(Array.isArray(i)){s=[];for(let a=0,d=i.length;a<d;a++)i[a].isDataTexture?s.push(Ra(i[a].image)):s.push(Ra(i[a]))}else s=Ra(i);n.url=s}return e||(t.images[this.uuid]=n),n}}function Ra(l){return typeof HTMLImageElement<"u"&&l instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&l instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&l instanceof ImageBitmap?Fo.getDataURL(l):l.data?{data:Array.from(l.data),width:l.width,height:l.height,type:l.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Uo=0;class ge extends jl{constructor(t=ge.DEFAULT_IMAGE,e=ge.DEFAULT_MAPPING,n=Il,i=Il,s=be,a=xl,d=Fe,c=Pe,o=ge.DEFAULT_ANISOTROPY,Z=ul){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Uo++}),this.uuid=_l(),this.name="",this.source=new Js(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=n,this.wrapT=i,this.magFilter=s,this.minFilter=a,this.anisotropy=o,this.format=d,this.internalFormat=null,this.type=c,this.offset=new ft(0,0),this.repeat=new ft(1,1),this.center=new ft(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new xt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=Z,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==bs)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case wi:t.x=t.x-Math.floor(t.x);break;case Il:t.x=t.x<0?0:1;break;case Hi:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case wi:t.y=t.y-Math.floor(t.y);break;case Il:t.y=t.y<0?0:1;break;case Hi:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){t===!0&&this.pmremVersion++}}ge.DEFAULT_IMAGE=null,ge.DEFAULT_MAPPING=bs,ge.DEFAULT_ANISOTROPY=1;class ie{constructor(t=0,e=0,n=0,i=1){ie.prototype.isVector4=!0,this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,s=this.w,a=t.elements;return this.x=a[0]*e+a[4]*n+a[8]*i+a[12]*s,this.y=a[1]*e+a[5]*n+a[9]*i+a[13]*s,this.z=a[2]*e+a[6]*n+a[10]*i+a[14]*s,this.w=a[3]*e+a[7]*n+a[11]*i+a[15]*s,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,s;const c=t.elements,o=c[0],Z=c[4],m=c[8],b=c[1],h=c[5],p=c[9],V=c[2],r=c[6],u=c[10];if(Math.abs(Z-b)<.01&&Math.abs(m-V)<.01&&Math.abs(p-r)<.01){if(Math.abs(Z+b)<.1&&Math.abs(m+V)<.1&&Math.abs(p+r)<.1&&Math.abs(o+h+u-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const R=(o+1)/2,G=(h+1)/2,N=(u+1)/2,I=(Z+b)/4,x=(m+V)/4,M=(p+r)/4;return R>G&&R>N?R<.01?(n=0,i=.707106781,s=.707106781):(n=Math.sqrt(R),i=I/n,s=x/n):G>N?G<.01?(n=.707106781,i=0,s=.707106781):(i=Math.sqrt(G),n=I/i,s=M/i):N<.01?(n=.707106781,i=.707106781,s=0):(s=Math.sqrt(N),n=x/s,i=M/s),this.set(n,i,s,e),this}let C=Math.sqrt((r-p)*(r-p)+(m-V)*(m-V)+(b-Z)*(b-Z));return Math.abs(C)<.001&&(C=1),this.x=(r-p)/C,this.y=(m-V)/C,this.z=(b-Z)/C,this.w=Math.acos((o+h+u-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Mo extends jl{constructor(t=1,e=1,n={}){super(),this.isRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new ie(0,0,t,e),this.scissorTest=!1,this.viewport=new ie(0,0,t,e);const i={width:t,height:e,depth:1};n=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:be,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},n);const s=new ge(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace);s.flipY=!1,s.generateMipmaps=n.generateMipmaps,s.internalFormat=n.internalFormat,this.textures=[];const a=n.count;for(let d=0;d<a;d++)this.textures[d]=s.clone(),this.textures[d].isRenderTargetTexture=!0;this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,this.resolveDepthBuffer=n.resolveDepthBuffer,this.resolveStencilBuffer=n.resolveStencilBuffer,this.depthTexture=n.depthTexture,this.samples=n.samples}get texture(){return this.textures[0]}set texture(t){this.textures[0]=t}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let i=0,s=this.textures.length;i<s;i++)this.textures[i].image.width=t,this.textures[i].image.height=e,this.textures[i].image.depth=n;this.dispose()}this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.textures.length=0;for(let n=0,i=t.textures.length;n<i;n++)this.textures[n]=t.textures[n].clone(),this.textures[n].isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new Js(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.resolveDepthBuffer=t.resolveDepthBuffer,this.resolveStencilBuffer=t.resolveStencilBuffer,t.depthTexture!==null&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class bl extends Mo{constructor(t=1,e=1,n={}){super(t,e,n),this.isWebGLRenderTarget=!0}}class ks extends ge{constructor(t=null,e=1,n=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:n,depth:i},this.magFilter=Je,this.minFilter=Je,this.wrapR=Il,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class To extends ge{constructor(t=null,e=1,n=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:e,height:n,depth:i},this.magFilter=Je,this.minFilter=Je,this.wrapR=Il,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class yn{constructor(t=0,e=0,n=0,i=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=n,this._w=i}static slerpFlat(t,e,n,i,s,a,d){let c=n[i+0],o=n[i+1],Z=n[i+2],m=n[i+3];const b=s[a+0],h=s[a+1],p=s[a+2],V=s[a+3];if(d===0){t[e+0]=c,t[e+1]=o,t[e+2]=Z,t[e+3]=m;return}if(d===1){t[e+0]=b,t[e+1]=h,t[e+2]=p,t[e+3]=V;return}if(m!==V||c!==b||o!==h||Z!==p){let r=1-d;const u=c*b+o*h+Z*p+m*V,C=u>=0?1:-1,R=1-u*u;if(R>Number.EPSILON){const N=Math.sqrt(R),I=Math.atan2(N,u*C);r=Math.sin(r*I)/N,d=Math.sin(d*I)/N}const G=d*C;if(c=c*r+b*G,o=o*r+h*G,Z=Z*r+p*G,m=m*r+V*G,r===1-d){const N=1/Math.sqrt(c*c+o*o+Z*Z+m*m);c*=N,o*=N,Z*=N,m*=N}}t[e]=c,t[e+1]=o,t[e+2]=Z,t[e+3]=m}static multiplyQuaternionsFlat(t,e,n,i,s,a){const d=n[i],c=n[i+1],o=n[i+2],Z=n[i+3],m=s[a],b=s[a+1],h=s[a+2],p=s[a+3];return t[e]=d*p+Z*m+c*h-o*b,t[e+1]=c*p+Z*b+o*m-d*h,t[e+2]=o*p+Z*h+d*b-c*m,t[e+3]=Z*p-d*m-c*b-o*h,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const n=t._x,i=t._y,s=t._z,a=t._order,d=Math.cos,c=Math.sin,o=d(n/2),Z=d(i/2),m=d(s/2),b=c(n/2),h=c(i/2),p=c(s/2);switch(a){case"XYZ":this._x=b*Z*m+o*h*p,this._y=o*h*m-b*Z*p,this._z=o*Z*p+b*h*m,this._w=o*Z*m-b*h*p;break;case"YXZ":this._x=b*Z*m+o*h*p,this._y=o*h*m-b*Z*p,this._z=o*Z*p-b*h*m,this._w=o*Z*m+b*h*p;break;case"ZXY":this._x=b*Z*m-o*h*p,this._y=o*h*m+b*Z*p,this._z=o*Z*p+b*h*m,this._w=o*Z*m-b*h*p;break;case"ZYX":this._x=b*Z*m-o*h*p,this._y=o*h*m+b*Z*p,this._z=o*Z*p-b*h*m,this._w=o*Z*m+b*h*p;break;case"YZX":this._x=b*Z*m+o*h*p,this._y=o*h*m+b*Z*p,this._z=o*Z*p-b*h*m,this._w=o*Z*m-b*h*p;break;case"XZY":this._x=b*Z*m-o*h*p,this._y=o*h*m-b*Z*p,this._z=o*Z*p+b*h*m,this._w=o*Z*m+b*h*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return e===!0&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],s=e[8],a=e[1],d=e[5],c=e[9],o=e[2],Z=e[6],m=e[10],b=n+d+m;if(b>0){const h=.5/Math.sqrt(b+1);this._w=.25/h,this._x=(Z-c)*h,this._y=(s-o)*h,this._z=(a-i)*h}else if(n>d&&n>m){const h=2*Math.sqrt(1+n-d-m);this._w=(Z-c)/h,this._x=.25*h,this._y=(i+a)/h,this._z=(s+o)/h}else if(d>m){const h=2*Math.sqrt(1+d-n-m);this._w=(s-o)/h,this._x=(i+a)/h,this._y=.25*h,this._z=(c+Z)/h}else{const h=2*Math.sqrt(1+m-n-d);this._w=(a-i)/h,this._x=(s+o)/h,this._y=(c+Z)/h,this._z=.25*h}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Ve(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,s=t._z,a=t._w,d=e._x,c=e._y,o=e._z,Z=e._w;return this._x=n*Z+a*d+i*o-s*c,this._y=i*Z+a*c+s*d-n*o,this._z=s*Z+a*o+n*c-i*d,this._w=a*Z-n*d-i*c-s*o,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,i=this._y,s=this._z,a=this._w;let d=a*t._w+n*t._x+i*t._y+s*t._z;if(d<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,d=-d):this.copy(t),d>=1)return this._w=a,this._x=n,this._y=i,this._z=s,this;const c=1-d*d;if(c<=Number.EPSILON){const h=1-e;return this._w=h*a+e*this._w,this._x=h*n+e*this._x,this._y=h*i+e*this._y,this._z=h*s+e*this._z,this.normalize(),this}const o=Math.sqrt(c),Z=Math.atan2(o,d),m=Math.sin((1-e)*Z)/o,b=Math.sin(e*Z)/o;return this._w=a*m+this._w*b,this._x=n*m+this._x*b,this._y=i*m+this._y*b,this._z=s*m+this._z*b,this._onChangeCallback(),this}slerpQuaternions(t,e,n){return this.copy(t).slerp(e,n)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),n=Math.random(),i=Math.sqrt(1-n),s=Math.sqrt(n);return this.set(i*Math.sin(t),i*Math.cos(t),s*Math.sin(e),s*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class J{constructor(t=0,e=0,n=0){J.prototype.isVector3=!0,this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(ws.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(ws.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,s=t.elements;return this.x=s[0]*e+s[3]*n+s[6]*i,this.y=s[1]*e+s[4]*n+s[7]*i,this.z=s[2]*e+s[5]*n+s[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,s=t.elements,a=1/(s[3]*e+s[7]*n+s[11]*i+s[15]);return this.x=(s[0]*e+s[4]*n+s[8]*i+s[12])*a,this.y=(s[1]*e+s[5]*n+s[9]*i+s[13])*a,this.z=(s[2]*e+s[6]*n+s[10]*i+s[14])*a,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,s=t.x,a=t.y,d=t.z,c=t.w,o=2*(a*i-d*n),Z=2*(d*e-s*i),m=2*(s*n-a*e);return this.x=e+c*o+a*m-d*Z,this.y=n+c*Z+d*o-s*m,this.z=i+c*m+s*Z-a*o,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*i,this.y=s[1]*e+s[5]*n+s[9]*i,this.z=s[2]*e+s[6]*n+s[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,s=t.z,a=e.x,d=e.y,c=e.z;return this.x=i*c-s*d,this.y=s*a-n*c,this.z=n*d-i*a,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return ya.copy(this).projectOnVector(t),this.sub(ya)}reflect(t){return this.sub(ya.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Ve(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=Math.random()*2-1,n=Math.sqrt(1-e*e);return this.x=n*Math.cos(t),this.y=e,this.z=n*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const ya=new J,ws=new yn;class Cn{constructor(t=new J(1/0,1/0,1/0),e=new J(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e+=3)this.expandByPoint(ke.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,n=t.count;e<n;e++)this.expandByPoint(ke.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=ke.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const n=t.geometry;if(n!==void 0){const s=n.getAttribute("position");if(e===!0&&s!==void 0&&t.isInstancedMesh!==!0)for(let a=0,d=s.count;a<d;a++)t.isMesh===!0?t.getVertexPosition(a,ke):ke.fromBufferAttribute(s,a),ke.applyMatrix4(t.matrixWorld),this.expandByPoint(ke);else t.boundingBox!==void 0?(t.boundingBox===null&&t.computeBoundingBox(),Pn.copy(t.boundingBox)):(n.boundingBox===null&&n.computeBoundingBox(),Pn.copy(n.boundingBox)),Pn.applyMatrix4(t.matrixWorld),this.union(Pn)}const i=t.children;for(let s=0,a=i.length;s<a;s++)this.expandByObject(i[s],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,ke),ke.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Sn),jn.subVectors(this.max,Sn),$l.subVectors(t.a,Sn),tn.subVectors(t.b,Sn),en.subVectors(t.c,Sn),rl.subVectors(tn,$l),pl.subVectors(en,tn),Nl.subVectors($l,en);let e=[0,-rl.z,rl.y,0,-pl.z,pl.y,0,-Nl.z,Nl.y,rl.z,0,-rl.x,pl.z,0,-pl.x,Nl.z,0,-Nl.x,-rl.y,rl.x,0,-pl.y,pl.x,0,-Nl.y,Nl.x,0];return!Ca(e,$l,tn,en,jn)||(e=[1,0,0,0,1,0,0,0,1],!Ca(e,$l,tn,en,jn))?!1:(_n.crossVectors(rl,pl),e=[_n.x,_n.y,_n.z],Ca(e,$l,tn,en,jn))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,ke).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=this.getSize(ke).length()*.5),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(ll[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),ll[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),ll[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),ll[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),ll[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),ll[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),ll[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),ll[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(ll),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const ll=[new J,new J,new J,new J,new J,new J,new J,new J],ke=new J,Pn=new Cn,$l=new J,tn=new J,en=new J,rl=new J,pl=new J,Nl=new J,Sn=new J,jn=new J,_n=new J,fl=new J;function Ca(l,t,e,n,i){for(let s=0,a=l.length-3;s<=a;s+=3){fl.fromArray(l,s);const d=i.x*Math.abs(fl.x)+i.y*Math.abs(fl.y)+i.z*Math.abs(fl.z),c=t.dot(fl),o=e.dot(fl),Z=n.dot(fl);if(Math.max(-Math.max(c,o,Z),Math.min(c,o,Z))>d)return!1}return!0}const vo=new Cn,In=new J,Sa=new J;class Dn{constructor(t=new J,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):vo.setFromPoints(t).getCenter(n);let i=0;for(let s=0,a=t.length;s<a;s++)i=Math.max(i,n.distanceToSquared(t[s]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;In.subVectors(t,this.center);const e=In.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),i=(n-this.radius)*.5;this.center.addScaledVector(In,i/n),this.radius+=i}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)===!0?this.radius=Math.max(this.radius,t.radius):(Sa.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(In.copy(t.center).add(Sa)),this.expandByPoint(In.copy(t.center).sub(Sa))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const nl=new J,Ia=new J,On=new J,Gl=new J,xa=new J,qn=new J,Ya=new J;class Hs{constructor(t=new J,e=new J(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,nl)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=nl.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(nl.copy(this.origin).addScaledVector(this.direction,e),nl.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){Ia.copy(t).add(e).multiplyScalar(.5),On.copy(e).sub(t).normalize(),Gl.copy(this.origin).sub(Ia);const s=t.distanceTo(e)*.5,a=-this.direction.dot(On),d=Gl.dot(this.direction),c=-Gl.dot(On),o=Gl.lengthSq(),Z=Math.abs(1-a*a);let m,b,h,p;if(Z>0)if(m=a*c-d,b=a*d-c,p=s*Z,m>=0)if(b>=-p)if(b<=p){const V=1/Z;m*=V,b*=V,h=m*(m+a*b+2*d)+b*(a*m+b+2*c)+o}else b=s,m=Math.max(0,-(a*b+d)),h=-m*m+b*(b+2*c)+o;else b=-s,m=Math.max(0,-(a*b+d)),h=-m*m+b*(b+2*c)+o;else b<=-p?(m=Math.max(0,-(-a*s+d)),b=m>0?-s:Math.min(Math.max(-s,-c),s),h=-m*m+b*(b+2*c)+o):b<=p?(m=0,b=Math.min(Math.max(-s,-c),s),h=b*(b+2*c)+o):(m=Math.max(0,-(a*s+d)),b=m>0?s:Math.min(Math.max(-s,-c),s),h=-m*m+b*(b+2*c)+o);else b=a>0?-s:s,m=Math.max(0,-(a*b+d)),h=-m*m+b*(b+2*c)+o;return n&&n.copy(this.origin).addScaledVector(this.direction,m),i&&i.copy(Ia).addScaledVector(On,b),h}intersectSphere(t,e){nl.subVectors(t.center,this.origin);const n=nl.dot(this.direction),i=nl.dot(nl)-n*n,s=t.radius*t.radius;if(i>s)return null;const a=Math.sqrt(s-i),d=n-a,c=n+a;return c<0?null:d<0?this.at(c,e):this.at(d,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,s,a,d,c;const o=1/this.direction.x,Z=1/this.direction.y,m=1/this.direction.z,b=this.origin;return o>=0?(n=(t.min.x-b.x)*o,i=(t.max.x-b.x)*o):(n=(t.max.x-b.x)*o,i=(t.min.x-b.x)*o),Z>=0?(s=(t.min.y-b.y)*Z,a=(t.max.y-b.y)*Z):(s=(t.max.y-b.y)*Z,a=(t.min.y-b.y)*Z),n>a||s>i||((s>n||isNaN(n))&&(n=s),(a<i||isNaN(i))&&(i=a),m>=0?(d=(t.min.z-b.z)*m,c=(t.max.z-b.z)*m):(d=(t.max.z-b.z)*m,c=(t.min.z-b.z)*m),n>c||d>i)||((d>n||n!==n)&&(n=d),(c<i||i!==i)&&(i=c),i<0)?null:this.at(n>=0?n:i,e)}intersectsBox(t){return this.intersectBox(t,nl)!==null}intersectTriangle(t,e,n,i,s){xa.subVectors(e,t),qn.subVectors(n,t),Ya.crossVectors(xa,qn);let a=this.direction.dot(Ya),d;if(a>0){if(i)return null;d=1}else if(a<0)d=-1,a=-a;else return null;Gl.subVectors(this.origin,t);const c=d*this.direction.dot(qn.crossVectors(Gl,qn));if(c<0)return null;const o=d*this.direction.dot(xa.cross(Gl));if(o<0||c+o>a)return null;const Z=-d*Gl.dot(Ya);return Z<0?null:this.at(Z/a,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class ae{constructor(t,e,n,i,s,a,d,c,o,Z,m,b,h,p,V,r){ae.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,e,n,i,s,a,d,c,o,Z,m,b,h,p,V,r)}set(t,e,n,i,s,a,d,c,o,Z,m,b,h,p,V,r){const u=this.elements;return u[0]=t,u[4]=e,u[8]=n,u[12]=i,u[1]=s,u[5]=a,u[9]=d,u[13]=c,u[2]=o,u[6]=Z,u[10]=m,u[14]=b,u[3]=h,u[7]=p,u[11]=V,u[15]=r,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new ae().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/ln.setFromMatrixColumn(t,0).length(),s=1/ln.setFromMatrixColumn(t,1).length(),a=1/ln.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*s,e[5]=n[5]*s,e[6]=n[6]*s,e[7]=0,e[8]=n[8]*a,e[9]=n[9]*a,e[10]=n[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,n=t.x,i=t.y,s=t.z,a=Math.cos(n),d=Math.sin(n),c=Math.cos(i),o=Math.sin(i),Z=Math.cos(s),m=Math.sin(s);if(t.order==="XYZ"){const b=a*Z,h=a*m,p=d*Z,V=d*m;e[0]=c*Z,e[4]=-c*m,e[8]=o,e[1]=h+p*o,e[5]=b-V*o,e[9]=-d*c,e[2]=V-b*o,e[6]=p+h*o,e[10]=a*c}else if(t.order==="YXZ"){const b=c*Z,h=c*m,p=o*Z,V=o*m;e[0]=b+V*d,e[4]=p*d-h,e[8]=a*o,e[1]=a*m,e[5]=a*Z,e[9]=-d,e[2]=h*d-p,e[6]=V+b*d,e[10]=a*c}else if(t.order==="ZXY"){const b=c*Z,h=c*m,p=o*Z,V=o*m;e[0]=b-V*d,e[4]=-a*m,e[8]=p+h*d,e[1]=h+p*d,e[5]=a*Z,e[9]=V-b*d,e[2]=-a*o,e[6]=d,e[10]=a*c}else if(t.order==="ZYX"){const b=a*Z,h=a*m,p=d*Z,V=d*m;e[0]=c*Z,e[4]=p*o-h,e[8]=b*o+V,e[1]=c*m,e[5]=V*o+b,e[9]=h*o-p,e[2]=-o,e[6]=d*c,e[10]=a*c}else if(t.order==="YZX"){const b=a*c,h=a*o,p=d*c,V=d*o;e[0]=c*Z,e[4]=V-b*m,e[8]=p*m+h,e[1]=m,e[5]=a*Z,e[9]=-d*Z,e[2]=-o*Z,e[6]=h*m+p,e[10]=b-V*m}else if(t.order==="XZY"){const b=a*c,h=a*o,p=d*c,V=d*o;e[0]=c*Z,e[4]=-m,e[8]=o*Z,e[1]=b*m+V,e[5]=a*Z,e[9]=h*m-p,e[2]=p*m-h,e[6]=d*Z,e[10]=V*m+b}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Jo,t,ko)}lookAt(t,e,n){const i=this.elements;return xe.subVectors(t,e),xe.lengthSq()===0&&(xe.z=1),xe.normalize(),Wl.crossVectors(n,xe),Wl.lengthSq()===0&&(Math.abs(n.z)===1?xe.x+=1e-4:xe.z+=1e-4,xe.normalize(),Wl.crossVectors(n,xe)),Wl.normalize(),$n.crossVectors(xe,Wl),i[0]=Wl.x,i[4]=$n.x,i[8]=xe.x,i[1]=Wl.y,i[5]=$n.y,i[9]=xe.y,i[2]=Wl.z,i[6]=$n.z,i[10]=xe.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,s=this.elements,a=n[0],d=n[4],c=n[8],o=n[12],Z=n[1],m=n[5],b=n[9],h=n[13],p=n[2],V=n[6],r=n[10],u=n[14],C=n[3],R=n[7],G=n[11],N=n[15],I=i[0],x=i[4],M=i[8],y=i[12],g=i[1],Y=i[5],Q=i[9],w=i[13],E=i[2],D=i[6],K=i[10],$=i[14],z=i[3],nt=i[7],ot=i[11],Vt=i[15];return s[0]=a*I+d*g+c*E+o*z,s[4]=a*x+d*Y+c*D+o*nt,s[8]=a*M+d*Q+c*K+o*ot,s[12]=a*y+d*w+c*$+o*Vt,s[1]=Z*I+m*g+b*E+h*z,s[5]=Z*x+m*Y+b*D+h*nt,s[9]=Z*M+m*Q+b*K+h*ot,s[13]=Z*y+m*w+b*$+h*Vt,s[2]=p*I+V*g+r*E+u*z,s[6]=p*x+V*Y+r*D+u*nt,s[10]=p*M+V*Q+r*K+u*ot,s[14]=p*y+V*w+r*$+u*Vt,s[3]=C*I+R*g+G*E+N*z,s[7]=C*x+R*Y+G*D+N*nt,s[11]=C*M+R*Q+G*K+N*ot,s[15]=C*y+R*w+G*$+N*Vt,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],s=t[12],a=t[1],d=t[5],c=t[9],o=t[13],Z=t[2],m=t[6],b=t[10],h=t[14],p=t[3],V=t[7],r=t[11],u=t[15];return p*(+s*c*m-i*o*m-s*d*b+n*o*b+i*d*h-n*c*h)+V*(+e*c*h-e*o*b+s*a*b-i*a*h+i*o*Z-s*c*Z)+r*(+e*o*m-e*d*h-s*a*m+n*a*h+s*d*Z-n*o*Z)+u*(-i*d*Z-e*c*m+e*d*b+i*a*m-n*a*b+n*c*Z)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],a=t[4],d=t[5],c=t[6],o=t[7],Z=t[8],m=t[9],b=t[10],h=t[11],p=t[12],V=t[13],r=t[14],u=t[15],C=m*r*o-V*b*o+V*c*h-d*r*h-m*c*u+d*b*u,R=p*b*o-Z*r*o-p*c*h+a*r*h+Z*c*u-a*b*u,G=Z*V*o-p*m*o+p*d*h-a*V*h-Z*d*u+a*m*u,N=p*m*c-Z*V*c-p*d*b+a*V*b+Z*d*r-a*m*r,I=e*C+n*R+i*G+s*N;if(I===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const x=1/I;return t[0]=C*x,t[1]=(V*b*s-m*r*s-V*i*h+n*r*h+m*i*u-n*b*u)*x,t[2]=(d*r*s-V*c*s+V*i*o-n*r*o-d*i*u+n*c*u)*x,t[3]=(m*c*s-d*b*s-m*i*o+n*b*o+d*i*h-n*c*h)*x,t[4]=R*x,t[5]=(Z*r*s-p*b*s+p*i*h-e*r*h-Z*i*u+e*b*u)*x,t[6]=(p*c*s-a*r*s-p*i*o+e*r*o+a*i*u-e*c*u)*x,t[7]=(a*b*s-Z*c*s+Z*i*o-e*b*o-a*i*h+e*c*h)*x,t[8]=G*x,t[9]=(p*m*s-Z*V*s-p*n*h+e*V*h+Z*n*u-e*m*u)*x,t[10]=(a*V*s-p*d*s+p*n*o-e*V*o-a*n*u+e*d*u)*x,t[11]=(Z*d*s-a*m*s-Z*n*o+e*m*o+a*n*h-e*d*h)*x,t[12]=N*x,t[13]=(Z*V*i-p*m*i+p*n*b-e*V*b-Z*n*r+e*m*r)*x,t[14]=(p*d*i-a*V*i-p*n*c+e*V*c+a*n*r-e*d*r)*x,t[15]=(a*m*i-Z*d*i+Z*n*c-e*m*c-a*n*b+e*d*b)*x,this}scale(t){const e=this.elements,n=t.x,i=t.y,s=t.z;return e[0]*=n,e[4]*=i,e[8]*=s,e[1]*=n,e[5]*=i,e[9]*=s,e[2]*=n,e[6]*=i,e[10]*=s,e[3]*=n,e[7]*=i,e[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),s=1-n,a=t.x,d=t.y,c=t.z,o=s*a,Z=s*d;return this.set(o*a+n,o*d-i*c,o*c+i*d,0,o*d+i*c,Z*d+n,Z*c-i*a,0,o*c-i*d,Z*c+i*a,s*c*c+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,i,s,a){return this.set(1,n,s,0,t,1,a,0,e,i,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,s=e._x,a=e._y,d=e._z,c=e._w,o=s+s,Z=a+a,m=d+d,b=s*o,h=s*Z,p=s*m,V=a*Z,r=a*m,u=d*m,C=c*o,R=c*Z,G=c*m,N=n.x,I=n.y,x=n.z;return i[0]=(1-(V+u))*N,i[1]=(h+G)*N,i[2]=(p-R)*N,i[3]=0,i[4]=(h-G)*I,i[5]=(1-(b+u))*I,i[6]=(r+C)*I,i[7]=0,i[8]=(p+R)*x,i[9]=(r-C)*x,i[10]=(1-(b+V))*x,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let s=ln.set(i[0],i[1],i[2]).length();const a=ln.set(i[4],i[5],i[6]).length(),d=ln.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),t.x=i[12],t.y=i[13],t.z=i[14],we.copy(this);const o=1/s,Z=1/a,m=1/d;return we.elements[0]*=o,we.elements[1]*=o,we.elements[2]*=o,we.elements[4]*=Z,we.elements[5]*=Z,we.elements[6]*=Z,we.elements[8]*=m,we.elements[9]*=m,we.elements[10]*=m,e.setFromRotationMatrix(we),n.x=s,n.y=a,n.z=d,this}makePerspective(t,e,n,i,s,a,d=tl){const c=this.elements,o=2*s/(e-t),Z=2*s/(n-i),m=(e+t)/(e-t),b=(n+i)/(n-i);let h,p;if(d===tl)h=-(a+s)/(a-s),p=-2*a*s/(a-s);else if(d===An)h=-a/(a-s),p=-a*s/(a-s);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+d);return c[0]=o,c[4]=0,c[8]=m,c[12]=0,c[1]=0,c[5]=Z,c[9]=b,c[13]=0,c[2]=0,c[6]=0,c[10]=h,c[14]=p,c[3]=0,c[7]=0,c[11]=-1,c[15]=0,this}makeOrthographic(t,e,n,i,s,a,d=tl){const c=this.elements,o=1/(e-t),Z=1/(n-i),m=1/(a-s),b=(e+t)*o,h=(n+i)*Z;let p,V;if(d===tl)p=(a+s)*m,V=-2*m;else if(d===An)p=s*m,V=-1*m;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+d);return c[0]=2*o,c[4]=0,c[8]=0,c[12]=-b,c[1]=0,c[5]=2*Z,c[9]=0,c[13]=-h,c[2]=0,c[6]=0,c[10]=V,c[14]=-p,c[3]=0,c[7]=0,c[11]=0,c[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<16;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}const ln=new J,we=new ae,Jo=new J(0,0,0),ko=new J(1,1,1),Wl=new J,$n=new J,xe=new J,zs=new ae,Ks=new yn;class il{constructor(t=0,e=0,n=0,i=il.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i=this._order){return this._x=t,this._y=e,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const i=t.elements,s=i[0],a=i[4],d=i[8],c=i[1],o=i[5],Z=i[9],m=i[2],b=i[6],h=i[10];switch(e){case"XYZ":this._y=Math.asin(Ve(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(-Z,h),this._z=Math.atan2(-a,s)):(this._x=Math.atan2(b,o),this._z=0);break;case"YXZ":this._x=Math.asin(-Ve(Z,-1,1)),Math.abs(Z)<.9999999?(this._y=Math.atan2(d,h),this._z=Math.atan2(c,o)):(this._y=Math.atan2(-m,s),this._z=0);break;case"ZXY":this._x=Math.asin(Ve(b,-1,1)),Math.abs(b)<.9999999?(this._y=Math.atan2(-m,h),this._z=Math.atan2(-a,o)):(this._y=0,this._z=Math.atan2(c,s));break;case"ZYX":this._y=Math.asin(-Ve(m,-1,1)),Math.abs(m)<.9999999?(this._x=Math.atan2(b,h),this._z=Math.atan2(c,s)):(this._x=0,this._z=Math.atan2(-a,o));break;case"YZX":this._z=Math.asin(Ve(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-Z,o),this._y=Math.atan2(-m,s)):(this._x=0,this._y=Math.atan2(d,h));break;case"XZY":this._z=Math.asin(-Ve(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(b,o),this._y=Math.atan2(d,s)):(this._x=Math.atan2(-Z,h),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return zs.makeRotationFromQuaternion(t),this.setFromRotationMatrix(zs,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Ks.setFromEuler(this),this.setFromQuaternion(Ks,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}il.DEFAULT_ORDER="XYZ";class Bs{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let wo=0;const Es=new J,nn=new yn,al=new ae,ti=new J,xn=new J,Ho=new J,zo=new yn,As=new J(1,0,0),Qs=new J(0,1,0),Ps=new J(0,0,1),js={type:"added"},Ko={type:"removed"},an={type:"childadded",child:null},Na={type:"childremoved",child:null};class Ce extends jl{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:wo++}),this.uuid=_l(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Ce.DEFAULT_UP.clone();const t=new J,e=new il,n=new yn,i=new J(1,1,1);function s(){n.setFromEuler(e,!1)}function a(){e.setFromQuaternion(n,void 0,!1)}e._onChange(s),n._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new ae},normalMatrix:{value:new xt}}),this.matrix=new ae,this.matrixWorld=new ae,this.matrixAutoUpdate=Ce.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Ce.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Bs,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return nn.setFromAxisAngle(t,e),this.quaternion.multiply(nn),this}rotateOnWorldAxis(t,e){return nn.setFromAxisAngle(t,e),this.quaternion.premultiply(nn),this}rotateX(t){return this.rotateOnAxis(As,t)}rotateY(t){return this.rotateOnAxis(Qs,t)}rotateZ(t){return this.rotateOnAxis(Ps,t)}translateOnAxis(t,e){return Es.copy(t).applyQuaternion(this.quaternion),this.position.add(Es.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(As,t)}translateY(t){return this.translateOnAxis(Qs,t)}translateZ(t){return this.translateOnAxis(Ps,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(al.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?ti.copy(t):ti.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),xn.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?al.lookAt(xn,ti,this.up):al.lookAt(ti,xn,this.up),this.quaternion.setFromRotationMatrix(al),i&&(al.extractRotation(i.matrixWorld),nn.setFromRotationMatrix(al),this.quaternion.premultiply(nn.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(js),an.child=t,this.dispatchEvent(an),an.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Ko),Na.child=t,this.dispatchEvent(Na),Na.child=null),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),al.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),al.multiply(t.parent.matrixWorld)),t.applyMatrix4(al),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(js),an.child=t,this.dispatchEvent(an),an.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const a=this.children[n].getObjectByProperty(t,e);if(a!==void 0)return a}}getObjectsByProperty(t,e,n=[]){this[t]===e&&n.push(this);const i=this.children;for(let s=0,a=i.length;s<a;s++)i[s].getObjectsByProperty(t,e,n);return n}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(xn,t,Ho),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(xn,zo,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(t===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),e===!0){const i=this.children;for(let s=0,a=i.length;s<a;s++)i[s].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.visibility=this._visibility,i.active=this._active,i.bounds=this._bounds.map(d=>({boxInitialized:d.boxInitialized,boxMin:d.box.min.toArray(),boxMax:d.box.max.toArray(),sphereInitialized:d.sphereInitialized,sphereRadius:d.sphere.radius,sphereCenter:d.sphere.center.toArray()})),i.maxInstanceCount=this._maxInstanceCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.geometryCount=this._geometryCount,i.matricesTexture=this._matricesTexture.toJSON(t),this._colorsTexture!==null&&(i.colorsTexture=this._colorsTexture.toJSON(t)),this.boundingSphere!==null&&(i.boundingSphere={center:i.boundingSphere.center.toArray(),radius:i.boundingSphere.radius}),this.boundingBox!==null&&(i.boundingBox={min:i.boundingBox.min.toArray(),max:i.boundingBox.max.toArray()}));function s(d,c){return d[c.uuid]===void 0&&(d[c.uuid]=c.toJSON(t)),c.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=s(t.geometries,this.geometry);const d=this.geometry.parameters;if(d!==void 0&&d.shapes!==void 0){const c=d.shapes;if(Array.isArray(c))for(let o=0,Z=c.length;o<Z;o++){const m=c[o];s(t.shapes,m)}else s(t.shapes,c)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const d=[];for(let c=0,o=this.material.length;c<o;c++)d.push(s(t.materials,this.material[c]));i.material=d}else i.material=s(t.materials,this.material);if(this.children.length>0){i.children=[];for(let d=0;d<this.children.length;d++)i.children.push(this.children[d].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let d=0;d<this.animations.length;d++){const c=this.animations[d];i.animations.push(s(t.animations,c))}}if(e){const d=a(t.geometries),c=a(t.materials),o=a(t.textures),Z=a(t.images),m=a(t.shapes),b=a(t.skeletons),h=a(t.animations),p=a(t.nodes);d.length>0&&(n.geometries=d),c.length>0&&(n.materials=c),o.length>0&&(n.textures=o),Z.length>0&&(n.images=Z),m.length>0&&(n.shapes=m),b.length>0&&(n.skeletons=b),h.length>0&&(n.animations=h),p.length>0&&(n.nodes=p)}return n.object=i,n;function a(d){const c=[];for(const o in d){const Z=d[o];delete Z.metadata,c.push(Z)}return c}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let n=0;n<t.children.length;n++){const i=t.children[n];this.add(i.clone())}return this}}Ce.DEFAULT_UP=new J(0,1,0),Ce.DEFAULT_MATRIX_AUTO_UPDATE=!0,Ce.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const He=new J,sl=new J,fa=new J,dl=new J,sn=new J,dn=new J,_s=new J,Fa=new J,La=new J,Ua=new J,Ma=new ie,Ta=new ie,va=new ie;class ze{constructor(t=new J,e=new J,n=new J){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i.subVectors(n,e),He.subVectors(t,e),i.cross(He);const s=i.lengthSq();return s>0?i.multiplyScalar(1/Math.sqrt(s)):i.set(0,0,0)}static getBarycoord(t,e,n,i,s){He.subVectors(i,e),sl.subVectors(n,e),fa.subVectors(t,e);const a=He.dot(He),d=He.dot(sl),c=He.dot(fa),o=sl.dot(sl),Z=sl.dot(fa),m=a*o-d*d;if(m===0)return s.set(0,0,0),null;const b=1/m,h=(o*c-d*Z)*b,p=(a*Z-d*c)*b;return s.set(1-h-p,p,h)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,dl)===null?!1:dl.x>=0&&dl.y>=0&&dl.x+dl.y<=1}static getInterpolation(t,e,n,i,s,a,d,c){return this.getBarycoord(t,e,n,i,dl)===null?(c.x=0,c.y=0,"z"in c&&(c.z=0),"w"in c&&(c.w=0),null):(c.setScalar(0),c.addScaledVector(s,dl.x),c.addScaledVector(a,dl.y),c.addScaledVector(d,dl.z),c)}static getInterpolatedAttribute(t,e,n,i,s,a){return Ma.setScalar(0),Ta.setScalar(0),va.setScalar(0),Ma.fromBufferAttribute(t,e),Ta.fromBufferAttribute(t,n),va.fromBufferAttribute(t,i),a.setScalar(0),a.addScaledVector(Ma,s.x),a.addScaledVector(Ta,s.y),a.addScaledVector(va,s.z),a}static isFrontFacing(t,e,n,i){return He.subVectors(n,e),sl.subVectors(t,e),He.cross(sl).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}setFromAttributeAndIndices(t,e,n,i){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,i),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return He.subVectors(this.c,this.b),sl.subVectors(this.a,this.b),He.cross(sl).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return ze.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return ze.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,n,i,s){return ze.getInterpolation(t,this.a,this.b,this.c,e,n,i,s)}containsPoint(t){return ze.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return ze.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,i=this.b,s=this.c;let a,d;sn.subVectors(i,n),dn.subVectors(s,n),Fa.subVectors(t,n);const c=sn.dot(Fa),o=dn.dot(Fa);if(c<=0&&o<=0)return e.copy(n);La.subVectors(t,i);const Z=sn.dot(La),m=dn.dot(La);if(Z>=0&&m<=Z)return e.copy(i);const b=c*m-Z*o;if(b<=0&&c>=0&&Z<=0)return a=c/(c-Z),e.copy(n).addScaledVector(sn,a);Ua.subVectors(t,s);const h=sn.dot(Ua),p=dn.dot(Ua);if(p>=0&&h<=p)return e.copy(s);const V=h*o-c*p;if(V<=0&&o>=0&&p<=0)return d=o/(o-p),e.copy(n).addScaledVector(dn,d);const r=Z*p-h*m;if(r<=0&&m-Z>=0&&h-p>=0)return _s.subVectors(s,i),d=(m-Z)/(m-Z+(h-p)),e.copy(i).addScaledVector(_s,d);const u=1/(r+V+b);return a=V*u,d=b*u,e.copy(n).addScaledVector(sn,a).addScaledVector(dn,d)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const Ds={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Vl={h:0,s:0,l:0},ei={h:0,s:0,l:0};function Ja(l,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?l+(t-l)*6*e:e<1/2?t:e<2/3?l+(t-l)*6*(2/3-e):l}class Kt{constructor(t,e,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,n)}set(t,e,n){if(e===void 0&&n===void 0){const i=t;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(t,e,n);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=Le){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,kt.toWorkingColorSpace(this,e),this}setRGB(t,e,n,i=kt.workingColorSpace){return this.r=t,this.g=e,this.b=n,kt.toWorkingColorSpace(this,i),this}setHSL(t,e,n,i=kt.workingColorSpace){if(t=Xa(t,1),e=Ve(e,0,1),n=Ve(n,0,1),e===0)this.r=this.g=this.b=n;else{const s=n<=.5?n*(1+e):n+e-n*e,a=2*n-s;this.r=Ja(a,s,t+1/3),this.g=Ja(a,s,t),this.b=Ja(a,s,t-1/3)}return kt.toWorkingColorSpace(this,i),this}setStyle(t,e=Le){function n(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(t)){let s;const a=i[1],d=i[2];switch(a){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))return n(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,e);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))return n(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,e);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))return n(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(t)){const s=i[1],a=s.length;if(a===3)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,e);if(a===6)return this.setHex(parseInt(s,16),e);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=Le){const n=Ds[t.toLowerCase()];return n!==void 0?this.setHex(n,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=el(t.r),this.g=el(t.g),this.b=el(t.b),this}copyLinearToSRGB(t){return this.r=Ol(t.r),this.g=Ol(t.g),this.b=Ol(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=Le){return kt.fromWorkingColorSpace(pe.copy(this),t),Math.round(Ve(pe.r*255,0,255))*65536+Math.round(Ve(pe.g*255,0,255))*256+Math.round(Ve(pe.b*255,0,255))}getHexString(t=Le){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=kt.workingColorSpace){kt.fromWorkingColorSpace(pe.copy(this),e);const n=pe.r,i=pe.g,s=pe.b,a=Math.max(n,i,s),d=Math.min(n,i,s);let c,o;const Z=(d+a)/2;if(d===a)c=0,o=0;else{const m=a-d;switch(o=Z<=.5?m/(a+d):m/(2-a-d),a){case n:c=(i-s)/m+(i<s?6:0);break;case i:c=(s-n)/m+2;break;case s:c=(n-i)/m+4;break}c/=6}return t.h=c,t.s=o,t.l=Z,t}getRGB(t,e=kt.workingColorSpace){return kt.fromWorkingColorSpace(pe.copy(this),e),t.r=pe.r,t.g=pe.g,t.b=pe.b,t}getStyle(t=Le){kt.fromWorkingColorSpace(pe.copy(this),t);const e=pe.r,n=pe.g,i=pe.b;return t!==Le?`color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(e*255)},${Math.round(n*255)},${Math.round(i*255)})`}offsetHSL(t,e,n){return this.getHSL(Vl),this.setHSL(Vl.h+t,Vl.s+e,Vl.l+n)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Vl),t.getHSL(ei);const n=gn(Vl.h,ei.h,e),i=gn(Vl.s,ei.s,e),s=gn(Vl.l,ei.l,e);return this.setHSL(n,i,s),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,n=this.g,i=this.b,s=t.elements;return this.r=s[0]*e+s[3]*n+s[6]*i,this.g=s[1]*e+s[4]*n+s[7]*i,this.b=s[2]*e+s[5]*n+s[8]*i,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const pe=new Kt;Kt.NAMES=Ds;let Bo=0;class Yn extends jl{static get type(){return"Material"}get type(){return this.constructor.type}set type(t){}constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Bo++}),this.uuid=_l(),this.name="",this.blending=Qe,this.side=ml,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=Yi,this.blendDst=Ni,this.blendEquation=Sl,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Kt(0,0,0),this.blendAlpha=0,this.depthFunc=Hl,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Ss,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Pl,this.stencilZFail=Pl,this.stencilZPass=Pl,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const n=t[e];if(n===void 0){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const i=this[e];if(i===void 0){console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const n={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(n.dispersion=this.dispersion),this.iridescence!==void 0&&(n.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(n.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.anisotropy!==void 0&&(n.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(n.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(n.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapRotation!==void 0&&(n.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Qe&&(n.blending=this.blending),this.side!==ml&&(n.side=this.side),this.vertexColors===!0&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=!0),this.blendSrc!==Yi&&(n.blendSrc=this.blendSrc),this.blendDst!==Ni&&(n.blendDst=this.blendDst),this.blendEquation!==Sl&&(n.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(n.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(n.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(n.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(n.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(n.blendAlpha=this.blendAlpha),this.depthFunc!==Hl&&(n.depthFunc=this.depthFunc),this.depthTest===!1&&(n.depthTest=this.depthTest),this.depthWrite===!1&&(n.depthWrite=this.depthWrite),this.colorWrite===!1&&(n.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(n.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==Ss&&(n.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(n.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(n.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Pl&&(n.stencilFail=this.stencilFail),this.stencilZFail!==Pl&&(n.stencilZFail=this.stencilZFail),this.stencilZPass!==Pl&&(n.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(n.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaHash===!0&&(n.alphaHash=!0),this.alphaToCoverage===!0&&(n.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=!0),this.forceSinglePass===!0&&(n.forceSinglePass=!0),this.wireframe===!0&&(n.wireframe=!0),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=!0),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData);function i(s){const a=[];for(const d in s){const c=s[d];delete c.metadata,a.push(c)}return a}if(e){const s=i(t.textures),a=i(t.images);s.length>0&&(n.textures=s),a.length>0&&(n.images=a)}return n}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(e!==null){const i=e.length;n=new Array(i);for(let s=0;s!==i;++s)n[s]=e[s].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class Nn extends Yn{static get type(){return"MeshBasicMaterial"}constructor(t){super(),this.isMeshBasicMaterial=!0,this.color=new Kt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new il,this.combine=us,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const de=new J,li=new ft;class Se{constructor(t,e,n=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=n,this.usage=xs,this.updateRanges=[],this.gpuType=$e,this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,s=this.itemSize;i<s;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,n=this.count;e<n;e++)li.fromBufferAttribute(this,e),li.applyMatrix3(t),this.setXY(e,li.x,li.y);else if(this.itemSize===3)for(let e=0,n=this.count;e<n;e++)de.fromBufferAttribute(this,e),de.applyMatrix3(t),this.setXYZ(e,de.x,de.y,de.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)de.fromBufferAttribute(this,e),de.applyMatrix4(t),this.setXYZ(e,de.x,de.y,de.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)de.fromBufferAttribute(this,e),de.applyNormalMatrix(t),this.setXYZ(e,de.x,de.y,de.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)de.fromBufferAttribute(this,e),de.transformDirection(t),this.setXYZ(e,de.x,de.y,de.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let n=this.array[t*this.itemSize+e];return this.normalized&&(n=Dl(n,this.array)),n}setComponent(t,e,n){return this.normalized&&(n=Xe(n,this.array)),this.array[t*this.itemSize+e]=n,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=Dl(e,this.array)),e}setX(t,e){return this.normalized&&(e=Xe(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=Dl(e,this.array)),e}setY(t,e){return this.normalized&&(e=Xe(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=Dl(e,this.array)),e}setZ(t,e){return this.normalized&&(e=Xe(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=Dl(e,this.array)),e}setW(t,e){return this.normalized&&(e=Xe(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.normalized&&(e=Xe(e,this.array),n=Xe(n,this.array)),this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.normalized&&(e=Xe(e,this.array),n=Xe(n,this.array),i=Xe(i,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,s){return t*=this.itemSize,this.normalized&&(e=Xe(e,this.array),n=Xe(n,this.array),i=Xe(i,this.array),s=Xe(s,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=s,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==xs&&(t.usage=this.usage),t}}class Os extends Se{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class qs extends Se{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class Fl extends Se{constructor(t,e,n){super(new Float32Array(t),e,n)}}let Eo=0;const Ue=new ae,ka=new Ce,cn=new J,Ye=new Cn,fn=new Cn,Ze=new J;class Me extends jl{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Eo++}),this.uuid=_l(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(fs(t)?qs:Os)(t,1):this.index=t,this}setIndirect(t){return this.indirect=t,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const s=new xt().getNormalMatrix(t);n.applyNormalMatrix(s),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(t),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return Ue.makeRotationFromQuaternion(t),this.applyMatrix4(Ue),this}rotateX(t){return Ue.makeRotationX(t),this.applyMatrix4(Ue),this}rotateY(t){return Ue.makeRotationY(t),this.applyMatrix4(Ue),this}rotateZ(t){return Ue.makeRotationZ(t),this.applyMatrix4(Ue),this}translate(t,e,n){return Ue.makeTranslation(t,e,n),this.applyMatrix4(Ue),this}scale(t,e,n){return Ue.makeScale(t,e,n),this.applyMatrix4(Ue),this}lookAt(t){return ka.lookAt(t),ka.updateMatrix(),this.applyMatrix4(ka.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(cn).negate(),this.translate(cn.x,cn.y,cn.z),this}setFromPoints(t){const e=this.getAttribute("position");if(e===void 0){const n=[];for(let i=0,s=t.length;i<s;i++){const a=t[i];n.push(a.x,a.y,a.z||0)}this.setAttribute("position",new Fl(n,3))}else{for(let n=0,i=e.count;n<i;n++){const s=t[n];e.setXYZ(n,s.x,s.y,s.z||0)}t.length>e.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),e.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Cn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new J(-1/0,-1/0,-1/0),new J(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,i=e.length;n<i;n++){const s=e[n];Ye.setFromBufferAttribute(s),this.morphTargetsRelative?(Ze.addVectors(this.boundingBox.min,Ye.min),this.boundingBox.expandByPoint(Ze),Ze.addVectors(this.boundingBox.max,Ye.max),this.boundingBox.expandByPoint(Ze)):(this.boundingBox.expandByPoint(Ye.min),this.boundingBox.expandByPoint(Ye.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Dn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new J,1/0);return}if(t){const n=this.boundingSphere.center;if(Ye.setFromBufferAttribute(t),e)for(let s=0,a=e.length;s<a;s++){const d=e[s];fn.setFromBufferAttribute(d),this.morphTargetsRelative?(Ze.addVectors(Ye.min,fn.min),Ye.expandByPoint(Ze),Ze.addVectors(Ye.max,fn.max),Ye.expandByPoint(Ze)):(Ye.expandByPoint(fn.min),Ye.expandByPoint(fn.max))}Ye.getCenter(n);let i=0;for(let s=0,a=t.count;s<a;s++)Ze.fromBufferAttribute(t,s),i=Math.max(i,n.distanceToSquared(Ze));if(e)for(let s=0,a=e.length;s<a;s++){const d=e[s],c=this.morphTargetsRelative;for(let o=0,Z=d.count;o<Z;o++)Ze.fromBufferAttribute(d,o),c&&(cn.fromBufferAttribute(t,o),Ze.add(cn)),i=Math.max(i,n.distanceToSquared(Ze))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=e.position,i=e.normal,s=e.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Se(new Float32Array(4*n.count),4));const a=this.getAttribute("tangent"),d=[],c=[];for(let M=0;M<n.count;M++)d[M]=new J,c[M]=new J;const o=new J,Z=new J,m=new J,b=new ft,h=new ft,p=new ft,V=new J,r=new J;function u(M,y,g){o.fromBufferAttribute(n,M),Z.fromBufferAttribute(n,y),m.fromBufferAttribute(n,g),b.fromBufferAttribute(s,M),h.fromBufferAttribute(s,y),p.fromBufferAttribute(s,g),Z.sub(o),m.sub(o),h.sub(b),p.sub(b);const Y=1/(h.x*p.y-p.x*h.y);isFinite(Y)&&(V.copy(Z).multiplyScalar(p.y).addScaledVector(m,-h.y).multiplyScalar(Y),r.copy(m).multiplyScalar(h.x).addScaledVector(Z,-p.x).multiplyScalar(Y),d[M].add(V),d[y].add(V),d[g].add(V),c[M].add(r),c[y].add(r),c[g].add(r))}let C=this.groups;C.length===0&&(C=[{start:0,count:t.count}]);for(let M=0,y=C.length;M<y;++M){const g=C[M],Y=g.start,Q=g.count;for(let w=Y,E=Y+Q;w<E;w+=3)u(t.getX(w+0),t.getX(w+1),t.getX(w+2))}const R=new J,G=new J,N=new J,I=new J;function x(M){N.fromBufferAttribute(i,M),I.copy(N);const y=d[M];R.copy(y),R.sub(N.multiplyScalar(N.dot(y))).normalize(),G.crossVectors(I,y);const Y=G.dot(c[M])<0?-1:1;a.setXYZW(M,R.x,R.y,R.z,Y)}for(let M=0,y=C.length;M<y;++M){const g=C[M],Y=g.start,Q=g.count;for(let w=Y,E=Y+Q;w<E;w+=3)x(t.getX(w+0)),x(t.getX(w+1)),x(t.getX(w+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new Se(new Float32Array(e.count*3),3),this.setAttribute("normal",n);else for(let b=0,h=n.count;b<h;b++)n.setXYZ(b,0,0,0);const i=new J,s=new J,a=new J,d=new J,c=new J,o=new J,Z=new J,m=new J;if(t)for(let b=0,h=t.count;b<h;b+=3){const p=t.getX(b+0),V=t.getX(b+1),r=t.getX(b+2);i.fromBufferAttribute(e,p),s.fromBufferAttribute(e,V),a.fromBufferAttribute(e,r),Z.subVectors(a,s),m.subVectors(i,s),Z.cross(m),d.fromBufferAttribute(n,p),c.fromBufferAttribute(n,V),o.fromBufferAttribute(n,r),d.add(Z),c.add(Z),o.add(Z),n.setXYZ(p,d.x,d.y,d.z),n.setXYZ(V,c.x,c.y,c.z),n.setXYZ(r,o.x,o.y,o.z)}else for(let b=0,h=e.count;b<h;b+=3)i.fromBufferAttribute(e,b+0),s.fromBufferAttribute(e,b+1),a.fromBufferAttribute(e,b+2),Z.subVectors(a,s),m.subVectors(i,s),Z.cross(m),n.setXYZ(b+0,Z.x,Z.y,Z.z),n.setXYZ(b+1,Z.x,Z.y,Z.z),n.setXYZ(b+2,Z.x,Z.y,Z.z);this.normalizeNormals(),n.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)Ze.fromBufferAttribute(t,e),Ze.normalize(),t.setXYZ(e,Ze.x,Ze.y,Ze.z)}toNonIndexed(){function t(d,c){const o=d.array,Z=d.itemSize,m=d.normalized,b=new o.constructor(c.length*Z);let h=0,p=0;for(let V=0,r=c.length;V<r;V++){d.isInterleavedBufferAttribute?h=c[V]*d.data.stride+d.offset:h=c[V]*Z;for(let u=0;u<Z;u++)b[p++]=o[h++]}return new Se(b,Z,m)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Me,n=this.index.array,i=this.attributes;for(const d in i){const c=i[d],o=t(c,n);e.setAttribute(d,o)}const s=this.morphAttributes;for(const d in s){const c=[],o=s[d];for(let Z=0,m=o.length;Z<m;Z++){const b=o[Z],h=t(b,n);c.push(h)}e.morphAttributes[d]=c}e.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let d=0,c=a.length;d<c;d++){const o=a[d];e.addGroup(o.start,o.count,o.materialIndex)}return e}toJSON(){const t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const c=this.parameters;for(const o in c)c[o]!==void 0&&(t[o]=c[o]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const c in n){const o=n[c];t.data.attributes[c]=o.toJSON(t.data)}const i={};let s=!1;for(const c in this.morphAttributes){const o=this.morphAttributes[c],Z=[];for(let m=0,b=o.length;m<b;m++){const h=o[m];Z.push(h.toJSON(t.data))}Z.length>0&&(i[c]=Z,s=!0)}s&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(t.data.groups=JSON.parse(JSON.stringify(a)));const d=this.boundingSphere;return d!==null&&(t.data.boundingSphere={center:d.center.toArray(),radius:d.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;n!==null&&this.setIndex(n.clone(e));const i=t.attributes;for(const o in i){const Z=i[o];this.setAttribute(o,Z.clone(e))}const s=t.morphAttributes;for(const o in s){const Z=[],m=s[o];for(let b=0,h=m.length;b<h;b++)Z.push(m[b].clone(e));this.morphAttributes[o]=Z}this.morphTargetsRelative=t.morphTargetsRelative;const a=t.groups;for(let o=0,Z=a.length;o<Z;o++){const m=a[o];this.addGroup(m.start,m.count,m.materialIndex)}const d=t.boundingBox;d!==null&&(this.boundingBox=d.clone());const c=t.boundingSphere;return c!==null&&(this.boundingSphere=c.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const $s=new ae,Ll=new Hs,ni=new Dn,td=new J,ii=new J,ai=new J,si=new J,wa=new J,di=new J,ed=new J,ci=new J;class ee extends Ce{constructor(t=new Me,e=new Nn){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const d=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[d]=s}}}}getVertexPosition(t,e){const n=this.geometry,i=n.attributes.position,s=n.morphAttributes.position,a=n.morphTargetsRelative;e.fromBufferAttribute(i,t);const d=this.morphTargetInfluences;if(s&&d){di.set(0,0,0);for(let c=0,o=s.length;c<o;c++){const Z=d[c],m=s[c];Z!==0&&(wa.fromBufferAttribute(m,t),a?di.addScaledVector(wa,Z):di.addScaledVector(wa.sub(e),Z))}e.add(di)}return e}raycast(t,e){const n=this.geometry,i=this.material,s=this.matrixWorld;i!==void 0&&(n.boundingSphere===null&&n.computeBoundingSphere(),ni.copy(n.boundingSphere),ni.applyMatrix4(s),Ll.copy(t.ray).recast(t.near),!(ni.containsPoint(Ll.origin)===!1&&(Ll.intersectSphere(ni,td)===null||Ll.origin.distanceToSquared(td)>(t.far-t.near)**2))&&($s.copy(s).invert(),Ll.copy(t.ray).applyMatrix4($s),!(n.boundingBox!==null&&Ll.intersectsBox(n.boundingBox)===!1)&&this._computeIntersections(t,e,Ll)))}_computeIntersections(t,e,n){let i;const s=this.geometry,a=this.material,d=s.index,c=s.attributes.position,o=s.attributes.uv,Z=s.attributes.uv1,m=s.attributes.normal,b=s.groups,h=s.drawRange;if(d!==null)if(Array.isArray(a))for(let p=0,V=b.length;p<V;p++){const r=b[p],u=a[r.materialIndex],C=Math.max(r.start,h.start),R=Math.min(d.count,Math.min(r.start+r.count,h.start+h.count));for(let G=C,N=R;G<N;G+=3){const I=d.getX(G),x=d.getX(G+1),M=d.getX(G+2);i=oi(this,u,t,n,o,Z,m,I,x,M),i&&(i.faceIndex=Math.floor(G/3),i.face.materialIndex=r.materialIndex,e.push(i))}}else{const p=Math.max(0,h.start),V=Math.min(d.count,h.start+h.count);for(let r=p,u=V;r<u;r+=3){const C=d.getX(r),R=d.getX(r+1),G=d.getX(r+2);i=oi(this,a,t,n,o,Z,m,C,R,G),i&&(i.faceIndex=Math.floor(r/3),e.push(i))}}else if(c!==void 0)if(Array.isArray(a))for(let p=0,V=b.length;p<V;p++){const r=b[p],u=a[r.materialIndex],C=Math.max(r.start,h.start),R=Math.min(c.count,Math.min(r.start+r.count,h.start+h.count));for(let G=C,N=R;G<N;G+=3){const I=G,x=G+1,M=G+2;i=oi(this,u,t,n,o,Z,m,I,x,M),i&&(i.faceIndex=Math.floor(G/3),i.face.materialIndex=r.materialIndex,e.push(i))}}else{const p=Math.max(0,h.start),V=Math.min(c.count,h.start+h.count);for(let r=p,u=V;r<u;r+=3){const C=r,R=r+1,G=r+2;i=oi(this,a,t,n,o,Z,m,C,R,G),i&&(i.faceIndex=Math.floor(r/3),e.push(i))}}}}function Ao(l,t,e,n,i,s,a,d){let c;if(t.side===ye?c=n.intersectTriangle(a,s,i,!0,d):c=n.intersectTriangle(i,s,a,t.side===ml,d),c===null)return null;ci.copy(d),ci.applyMatrix4(l.matrixWorld);const o=e.ray.origin.distanceTo(ci);return o<e.near||o>e.far?null:{distance:o,point:ci.clone(),object:l}}function oi(l,t,e,n,i,s,a,d,c,o){l.getVertexPosition(d,ii),l.getVertexPosition(c,ai),l.getVertexPosition(o,si);const Z=Ao(l,t,e,n,ii,ai,si,ed);if(Z){const m=new J;ze.getBarycoord(ed,ii,ai,si,m),i&&(Z.uv=ze.getInterpolatedAttribute(i,d,c,o,m,new ft)),s&&(Z.uv1=ze.getInterpolatedAttribute(s,d,c,o,m,new ft)),a&&(Z.normal=ze.getInterpolatedAttribute(a,d,c,o,m,new J),Z.normal.dot(n.direction)>0&&Z.normal.multiplyScalar(-1));const b={a:d,b:c,c:o,normal:new J,materialIndex:0};ze.getNormal(ii,ai,si,b.normal),Z.face=b,Z.barycoord=m}return Z}class Fn extends Me{constructor(t=1,e=1,n=1,i=1,s=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:s,depthSegments:a};const d=this;i=Math.floor(i),s=Math.floor(s),a=Math.floor(a);const c=[],o=[],Z=[],m=[];let b=0,h=0;p("z","y","x",-1,-1,n,e,t,a,s,0),p("z","y","x",1,-1,n,e,-t,a,s,1),p("x","z","y",1,1,t,n,e,i,a,2),p("x","z","y",1,-1,t,n,-e,i,a,3),p("x","y","z",1,-1,t,e,n,i,s,4),p("x","y","z",-1,-1,t,e,-n,i,s,5),this.setIndex(c),this.setAttribute("position",new Fl(o,3)),this.setAttribute("normal",new Fl(Z,3)),this.setAttribute("uv",new Fl(m,2));function p(V,r,u,C,R,G,N,I,x,M,y){const g=G/x,Y=N/M,Q=G/2,w=N/2,E=I/2,D=x+1,K=M+1;let $=0,z=0;const nt=new J;for(let ot=0;ot<K;ot++){const Vt=ot*Y-w;for(let Ut=0;Ut<D;Ut++){const Pt=Ut*g-Q;nt[V]=Pt*C,nt[r]=Vt*R,nt[u]=E,o.push(nt.x,nt.y,nt.z),nt[V]=0,nt[r]=0,nt[u]=I>0?1:-1,Z.push(nt.x,nt.y,nt.z),m.push(Ut/x),m.push(1-ot/M),$+=1}}for(let ot=0;ot<M;ot++)for(let Vt=0;Vt<x;Vt++){const Ut=b+Vt+D*ot,Pt=b+Vt+D*(ot+1),A=b+(Vt+1)+D*(ot+1),tt=b+(Vt+1)+D*ot;c.push(Ut,Pt,tt),c.push(Pt,A,tt),z+=6}d.addGroup(h,z,y),h+=z,b+=$}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Fn(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function on(l){const t={};for(const e in l){t[e]={};for(const n in l[e]){const i=l[e][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),t[e][n]=null):t[e][n]=i.clone():Array.isArray(i)?t[e][n]=i.slice():t[e][n]=i}}return t}function Re(l){const t={};for(let e=0;e<l.length;e++){const n=on(l[e]);for(const i in n)t[i]=n[i]}return t}function Qo(l){const t=[];for(let e=0;e<l.length;e++)t.push(l[e].clone());return t}function ld(l){const t=l.getRenderTarget();return t===null?l.outputColorSpace:t.isXRRenderTarget===!0?t.texture.colorSpace:kt.workingColorSpace}const Po={clone:on,merge:Re};var jo=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,_o=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class ce extends Yn{static get type(){return"ShaderMaterial"}constructor(t){super(),this.isShaderMaterial=!0,this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=jo,this.fragmentShader=_o,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=on(t.uniforms),this.uniformsGroups=Qo(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const a=this.uniforms[i].value;a&&a.isTexture?e.uniforms[i]={type:"t",value:a.toJSON(t).uuid}:a&&a.isColor?e.uniforms[i]={type:"c",value:a.getHex()}:a&&a.isVector2?e.uniforms[i]={type:"v2",value:a.toArray()}:a&&a.isVector3?e.uniforms[i]={type:"v3",value:a.toArray()}:a&&a.isVector4?e.uniforms[i]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?e.uniforms[i]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?e.uniforms[i]={type:"m4",value:a.toArray()}:e.uniforms[i]={value:a}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}class nd extends Ce{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new ae,this.projectionMatrix=new ae,this.projectionMatrixInverse=new ae,this.coordinateSystem=tl}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const Xl=new J,id=new ft,ad=new ft;class Ke extends nd{constructor(t=50,e=1,n=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=Xn*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(Vn*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return Xn*2*Math.atan(Math.tan(Vn*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,e,n){Xl.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(Xl.x,Xl.y).multiplyScalar(-t/Xl.z),Xl.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),n.set(Xl.x,Xl.y).multiplyScalar(-t/Xl.z)}getViewSize(t,e){return this.getViewBounds(t,id,ad),e.subVectors(ad,id)}setViewOffset(t,e,n,i,s,a){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(Vn*.5*this.fov)/this.zoom,n=2*e,i=this.aspect*n,s=-.5*i;const a=this.view;if(this.view!==null&&this.view.enabled){const c=a.fullWidth,o=a.fullHeight;s+=a.offsetX*i/c,e-=a.offsetY*n/o,i*=a.width/c,n*=a.height/o}const d=this.filmOffset;d!==0&&(s+=t*d/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+i,e,e-n,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const mn=-90,Zn=1;class Do extends Ce{constructor(t,e,n){super(),this.type="CubeCamera",this.renderTarget=n,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new Ke(mn,Zn,t,e);i.layers=this.layers,this.add(i);const s=new Ke(mn,Zn,t,e);s.layers=this.layers,this.add(s);const a=new Ke(mn,Zn,t,e);a.layers=this.layers,this.add(a);const d=new Ke(mn,Zn,t,e);d.layers=this.layers,this.add(d);const c=new Ke(mn,Zn,t,e);c.layers=this.layers,this.add(c);const o=new Ke(mn,Zn,t,e);o.layers=this.layers,this.add(o)}updateCoordinateSystem(){const t=this.coordinateSystem,e=this.children.concat(),[n,i,s,a,d,c]=e;for(const o of e)this.remove(o);if(t===tl)n.up.set(0,1,0),n.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),a.up.set(0,0,1),a.lookAt(0,-1,0),d.up.set(0,1,0),d.lookAt(0,0,1),c.up.set(0,1,0),c.lookAt(0,0,-1);else if(t===An)n.up.set(0,-1,0),n.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),a.up.set(0,0,-1),a.lookAt(0,-1,0),d.up.set(0,-1,0),d.lookAt(0,0,1),c.up.set(0,-1,0),c.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+t);for(const o of e)this.add(o),o.updateMatrixWorld()}update(t,e){this.parent===null&&this.updateMatrixWorld();const{renderTarget:n,activeMipmapLevel:i}=this;this.coordinateSystem!==t.coordinateSystem&&(this.coordinateSystem=t.coordinateSystem,this.updateCoordinateSystem());const[s,a,d,c,o,Z]=this.children,m=t.getRenderTarget(),b=t.getActiveCubeFace(),h=t.getActiveMipmapLevel(),p=t.xr.enabled;t.xr.enabled=!1;const V=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0,i),t.render(e,s),t.setRenderTarget(n,1,i),t.render(e,a),t.setRenderTarget(n,2,i),t.render(e,d),t.setRenderTarget(n,3,i),t.render(e,c),t.setRenderTarget(n,4,i),t.render(e,o),n.texture.generateMipmaps=V,t.setRenderTarget(n,5,i),t.render(e,Z),t.setRenderTarget(m,b,h),t.xr.enabled=p,n.texture.needsPMREMUpdate=!0}}class sd extends ge{constructor(t,e,n,i,s,a,d,c,o,Z){t=t!==void 0?t:[],e=e!==void 0?e:zl,super(t,e,n,i,s,a,d,c,o,Z),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class Oo extends bl{constructor(t=1,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const n={width:t,height:t,depth:1},i=[n,n,n,n,n,n];this.texture=new sd(i,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:be}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new Fn(5,5,5),s=new ce({name:"CubemapFromEquirect",uniforms:on(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:ye,blending:Zl});s.uniforms.tEquirect.value=e;const a=new ee(i,s),d=e.minFilter;return e.minFilter===xl&&(e.minFilter=be),new Do(1,10,this).update(t,a),e.minFilter=d,a.geometry.dispose(),a.material.dispose(),this}clear(t,e,n,i){const s=t.getRenderTarget();for(let a=0;a<6;a++)t.setRenderTarget(this,a),t.clear(e,n,i);t.setRenderTarget(s)}}const Ha=new J,qo=new J,$o=new xt;class Ul{constructor(t=new J(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=Ha.subVectors(n,e).cross(qo.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const n=t.delta(Ha),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const s=-(t.start.dot(this.normal)+this.constant)/i;return s<0||s>1?null:e.copy(t.start).addScaledVector(n,s)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||$o.getNormalMatrix(t),i=this.coplanarPoint(Ha).applyMatrix4(t),s=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Ml=new Dn,mi=new J;class dd{constructor(t=new Ul,e=new Ul,n=new Ul,i=new Ul,s=new Ul,a=new Ul){this.planes=[t,e,n,i,s,a]}set(t,e,n,i,s,a){const d=this.planes;return d[0].copy(t),d[1].copy(e),d[2].copy(n),d[3].copy(i),d[4].copy(s),d[5].copy(a),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t,e=tl){const n=this.planes,i=t.elements,s=i[0],a=i[1],d=i[2],c=i[3],o=i[4],Z=i[5],m=i[6],b=i[7],h=i[8],p=i[9],V=i[10],r=i[11],u=i[12],C=i[13],R=i[14],G=i[15];if(n[0].setComponents(c-s,b-o,r-h,G-u).normalize(),n[1].setComponents(c+s,b+o,r+h,G+u).normalize(),n[2].setComponents(c+a,b+Z,r+p,G+C).normalize(),n[3].setComponents(c-a,b-Z,r-p,G-C).normalize(),n[4].setComponents(c-d,b-m,r-V,G-R).normalize(),e===tl)n[5].setComponents(c+d,b+m,r+V,G+R).normalize();else if(e===An)n[5].setComponents(d,m,V,R).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);return this}intersectsObject(t){if(t.boundingSphere!==void 0)t.boundingSphere===null&&t.computeBoundingSphere(),Ml.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;e.boundingSphere===null&&e.computeBoundingSphere(),Ml.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(Ml)}intersectsSprite(t){return Ml.center.set(0,0,0),Ml.radius=.7071067811865476,Ml.applyMatrix4(t.matrixWorld),this.intersectsSphere(Ml)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let s=0;s<6;s++)if(e[s].distanceToPoint(n)<i)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(mi.x=i.normal.x>0?t.max.x:t.min.x,mi.y=i.normal.y>0?t.max.y:t.min.y,mi.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(mi)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function cd(){let l=null,t=!1,e=null,n=null;function i(s,a){e(s,a),n=l.requestAnimationFrame(i)}return{start:function(){t!==!0&&e!==null&&(n=l.requestAnimationFrame(i),t=!0)},stop:function(){l.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(s){e=s},setContext:function(s){l=s}}}function tm(l){const t=new WeakMap;function e(d,c){const o=d.array,Z=d.usage,m=o.byteLength,b=l.createBuffer();l.bindBuffer(c,b),l.bufferData(c,o,Z),d.onUploadCallback();let h;if(o instanceof Float32Array)h=l.FLOAT;else if(o instanceof Uint16Array)d.isFloat16BufferAttribute?h=l.HALF_FLOAT:h=l.UNSIGNED_SHORT;else if(o instanceof Int16Array)h=l.SHORT;else if(o instanceof Uint32Array)h=l.UNSIGNED_INT;else if(o instanceof Int32Array)h=l.INT;else if(o instanceof Int8Array)h=l.BYTE;else if(o instanceof Uint8Array)h=l.UNSIGNED_BYTE;else if(o instanceof Uint8ClampedArray)h=l.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+o);return{buffer:b,type:h,bytesPerElement:o.BYTES_PER_ELEMENT,version:d.version,size:m}}function n(d,c,o){const Z=c.array,m=c.updateRanges;if(l.bindBuffer(o,d),m.length===0)l.bufferSubData(o,0,Z);else{m.sort((h,p)=>h.start-p.start);let b=0;for(let h=1;h<m.length;h++){const p=m[b],V=m[h];V.start<=p.start+p.count+1?p.count=Math.max(p.count,V.start+V.count-p.start):(++b,m[b]=V)}m.length=b+1;for(let h=0,p=m.length;h<p;h++){const V=m[h];l.bufferSubData(o,V.start*Z.BYTES_PER_ELEMENT,Z,V.start,V.count)}c.clearUpdateRanges()}c.onUploadCallback()}function i(d){return d.isInterleavedBufferAttribute&&(d=d.data),t.get(d)}function s(d){d.isInterleavedBufferAttribute&&(d=d.data);const c=t.get(d);c&&(l.deleteBuffer(c.buffer),t.delete(d))}function a(d,c){if(d.isInterleavedBufferAttribute&&(d=d.data),d.isGLBufferAttribute){const Z=t.get(d);(!Z||Z.version<d.version)&&t.set(d,{buffer:d.buffer,type:d.type,bytesPerElement:d.elementSize,version:d.version});return}const o=t.get(d);if(o===void 0)t.set(d,e(d,c));else if(o.version<d.version){if(o.size!==d.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");n(o.buffer,d,c),o.version=d.version}}return{get:i,remove:s,update:a}}class te extends Me{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const s=t/2,a=e/2,d=Math.floor(n),c=Math.floor(i),o=d+1,Z=c+1,m=t/d,b=e/c,h=[],p=[],V=[],r=[];for(let u=0;u<Z;u++){const C=u*b-a;for(let R=0;R<o;R++){const G=R*m-s;p.push(G,-C,0),V.push(0,0,1),r.push(R/d),r.push(1-u/c)}}for(let u=0;u<c;u++)for(let C=0;C<d;C++){const R=C+o*u,G=C+o*(u+1),N=C+1+o*(u+1),I=C+1+o*u;h.push(R,G,I),h.push(G,N,I)}this.setIndex(h),this.setAttribute("position",new Fl(p,3)),this.setAttribute("normal",new Fl(V,3)),this.setAttribute("uv",new Fl(r,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new te(t.width,t.height,t.widthSegments,t.heightSegments)}}var em=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,lm=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,nm=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,im=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,am=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,sm=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,dm=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,cm=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,om=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,mm=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,Zm=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,hm=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,um=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,bm=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,rm=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,pm=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,Gm=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,Wm=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,Vm=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,Xm=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,gm=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,Rm=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,ym=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,Cm=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,Sm=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,Im=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,xm=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Ym=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,Nm=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,fm=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Fm="gl_FragColor = linearToOutputTexel( gl_FragColor );",Lm=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,Um=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Mm=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Tm=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,vm=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,Jm=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,km=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,wm=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Hm=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,zm=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Km=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,Bm=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Em=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,Am=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,Qm=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,Pm=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,jm=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,_m=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,Dm=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,Om=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,qm=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,$m=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,tZ=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,eZ=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,lZ=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,nZ=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,iZ=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,aZ=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,sZ=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,dZ=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,cZ=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,oZ=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,mZ=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,ZZ=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,hZ=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,uZ=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,bZ=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,rZ=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,pZ=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,GZ=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,WZ=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,VZ=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,XZ=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,gZ=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,RZ=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,yZ=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,CZ=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,SZ=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,IZ=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,xZ=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,YZ=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,NZ=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,fZ=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,FZ=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,LZ=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,UZ=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,MZ=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,TZ=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,vZ=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,JZ=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,kZ=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,wZ=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,HZ=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,zZ=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,KZ=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,BZ=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,EZ=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,AZ=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,QZ=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,PZ=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,jZ=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,_Z=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,DZ=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,OZ=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,qZ=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,$Z=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const Ft={alphahash_fragment:em,alphahash_pars_fragment:lm,alphamap_fragment:nm,alphamap_pars_fragment:im,alphatest_fragment:am,alphatest_pars_fragment:sm,aomap_fragment:dm,aomap_pars_fragment:cm,batching_pars_vertex:om,batching_vertex:mm,begin_vertex:Zm,beginnormal_vertex:hm,bsdfs:um,iridescence_fragment:bm,bumpmap_pars_fragment:rm,clipping_planes_fragment:pm,clipping_planes_pars_fragment:Gm,clipping_planes_pars_vertex:Wm,clipping_planes_vertex:Vm,color_fragment:Xm,color_pars_fragment:gm,color_pars_vertex:Rm,color_vertex:ym,common:Cm,cube_uv_reflection_fragment:Sm,defaultnormal_vertex:Im,displacementmap_pars_vertex:xm,displacementmap_vertex:Ym,emissivemap_fragment:Nm,emissivemap_pars_fragment:fm,colorspace_fragment:Fm,colorspace_pars_fragment:Lm,envmap_fragment:Um,envmap_common_pars_fragment:Mm,envmap_pars_fragment:Tm,envmap_pars_vertex:vm,envmap_physical_pars_fragment:Pm,envmap_vertex:Jm,fog_vertex:km,fog_pars_vertex:wm,fog_fragment:Hm,fog_pars_fragment:zm,gradientmap_pars_fragment:Km,lightmap_pars_fragment:Bm,lights_lambert_fragment:Em,lights_lambert_pars_fragment:Am,lights_pars_begin:Qm,lights_toon_fragment:jm,lights_toon_pars_fragment:_m,lights_phong_fragment:Dm,lights_phong_pars_fragment:Om,lights_physical_fragment:qm,lights_physical_pars_fragment:$m,lights_fragment_begin:tZ,lights_fragment_maps:eZ,lights_fragment_end:lZ,logdepthbuf_fragment:nZ,logdepthbuf_pars_fragment:iZ,logdepthbuf_pars_vertex:aZ,logdepthbuf_vertex:sZ,map_fragment:dZ,map_pars_fragment:cZ,map_particle_fragment:oZ,map_particle_pars_fragment:mZ,metalnessmap_fragment:ZZ,metalnessmap_pars_fragment:hZ,morphinstance_vertex:uZ,morphcolor_vertex:bZ,morphnormal_vertex:rZ,morphtarget_pars_vertex:pZ,morphtarget_vertex:GZ,normal_fragment_begin:WZ,normal_fragment_maps:VZ,normal_pars_fragment:XZ,normal_pars_vertex:gZ,normal_vertex:RZ,normalmap_pars_fragment:yZ,clearcoat_normal_fragment_begin:CZ,clearcoat_normal_fragment_maps:SZ,clearcoat_pars_fragment:IZ,iridescence_pars_fragment:xZ,opaque_fragment:YZ,packing:NZ,premultiplied_alpha_fragment:fZ,project_vertex:FZ,dithering_fragment:LZ,dithering_pars_fragment:UZ,roughnessmap_fragment:MZ,roughnessmap_pars_fragment:TZ,shadowmap_pars_fragment:vZ,shadowmap_pars_vertex:JZ,shadowmap_vertex:kZ,shadowmask_pars_fragment:wZ,skinbase_vertex:HZ,skinning_pars_vertex:zZ,skinning_vertex:KZ,skinnormal_vertex:BZ,specularmap_fragment:EZ,specularmap_pars_fragment:AZ,tonemapping_fragment:QZ,tonemapping_pars_fragment:PZ,transmission_fragment:jZ,transmission_pars_fragment:_Z,uv_pars_fragment:DZ,uv_pars_vertex:OZ,uv_vertex:qZ,worldpos_vertex:$Z,background_vert:`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,background_frag:`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,backgroundCube_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,backgroundCube_frag:`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,cube_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,cube_frag:`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,depth_vert:`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,depth_frag:`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,distanceRGBA_vert:`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,distanceRGBA_frag:`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,equirect_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,equirect_frag:`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,linedashed_vert:`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,linedashed_frag:`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,meshbasic_vert:`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,meshbasic_frag:`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshlambert_vert:`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshlambert_frag:`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshmatcap_vert:`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,meshmatcap_frag:`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshnormal_vert:`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,meshnormal_frag:`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,meshphong_vert:`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshphong_frag:`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphysical_vert:`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,meshphysical_frag:`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshtoon_vert:`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshtoon_frag:`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,points_vert:`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,points_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,shadow_vert:`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,shadow_frag:`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,sprite_vert:`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,sprite_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`},et={common:{diffuse:{value:new Kt(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new xt},alphaMap:{value:null},alphaMapTransform:{value:new xt},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new xt}},envmap:{envMap:{value:null},envMapRotation:{value:new xt},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new xt}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new xt}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new xt},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new xt},normalScale:{value:new ft(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new xt},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new xt}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new xt}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new xt}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Kt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Kt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new xt},alphaTest:{value:0},uvTransform:{value:new xt}},sprite:{diffuse:{value:new Kt(16777215)},opacity:{value:1},center:{value:new ft(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new xt},alphaMap:{value:null},alphaMapTransform:{value:new xt},alphaTest:{value:0}}},je={basic:{uniforms:Re([et.common,et.specularmap,et.envmap,et.aomap,et.lightmap,et.fog]),vertexShader:Ft.meshbasic_vert,fragmentShader:Ft.meshbasic_frag},lambert:{uniforms:Re([et.common,et.specularmap,et.envmap,et.aomap,et.lightmap,et.emissivemap,et.bumpmap,et.normalmap,et.displacementmap,et.fog,et.lights,{emissive:{value:new Kt(0)}}]),vertexShader:Ft.meshlambert_vert,fragmentShader:Ft.meshlambert_frag},phong:{uniforms:Re([et.common,et.specularmap,et.envmap,et.aomap,et.lightmap,et.emissivemap,et.bumpmap,et.normalmap,et.displacementmap,et.fog,et.lights,{emissive:{value:new Kt(0)},specular:{value:new Kt(1118481)},shininess:{value:30}}]),vertexShader:Ft.meshphong_vert,fragmentShader:Ft.meshphong_frag},standard:{uniforms:Re([et.common,et.envmap,et.aomap,et.lightmap,et.emissivemap,et.bumpmap,et.normalmap,et.displacementmap,et.roughnessmap,et.metalnessmap,et.fog,et.lights,{emissive:{value:new Kt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Ft.meshphysical_vert,fragmentShader:Ft.meshphysical_frag},toon:{uniforms:Re([et.common,et.aomap,et.lightmap,et.emissivemap,et.bumpmap,et.normalmap,et.displacementmap,et.gradientmap,et.fog,et.lights,{emissive:{value:new Kt(0)}}]),vertexShader:Ft.meshtoon_vert,fragmentShader:Ft.meshtoon_frag},matcap:{uniforms:Re([et.common,et.bumpmap,et.normalmap,et.displacementmap,et.fog,{matcap:{value:null}}]),vertexShader:Ft.meshmatcap_vert,fragmentShader:Ft.meshmatcap_frag},points:{uniforms:Re([et.points,et.fog]),vertexShader:Ft.points_vert,fragmentShader:Ft.points_frag},dashed:{uniforms:Re([et.common,et.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Ft.linedashed_vert,fragmentShader:Ft.linedashed_frag},depth:{uniforms:Re([et.common,et.displacementmap]),vertexShader:Ft.depth_vert,fragmentShader:Ft.depth_frag},normal:{uniforms:Re([et.common,et.bumpmap,et.normalmap,et.displacementmap,{opacity:{value:1}}]),vertexShader:Ft.meshnormal_vert,fragmentShader:Ft.meshnormal_frag},sprite:{uniforms:Re([et.sprite,et.fog]),vertexShader:Ft.sprite_vert,fragmentShader:Ft.sprite_frag},background:{uniforms:{uvTransform:{value:new xt},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Ft.background_vert,fragmentShader:Ft.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new xt}},vertexShader:Ft.backgroundCube_vert,fragmentShader:Ft.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Ft.cube_vert,fragmentShader:Ft.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Ft.equirect_vert,fragmentShader:Ft.equirect_frag},distanceRGBA:{uniforms:Re([et.common,et.displacementmap,{referencePosition:{value:new J},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Ft.distanceRGBA_vert,fragmentShader:Ft.distanceRGBA_frag},shadow:{uniforms:Re([et.lights,et.fog,{color:{value:new Kt(0)},opacity:{value:1}}]),vertexShader:Ft.shadow_vert,fragmentShader:Ft.shadow_frag}};je.physical={uniforms:Re([je.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new xt},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new xt},clearcoatNormalScale:{value:new ft(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new xt},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new xt},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new xt},sheen:{value:0},sheenColor:{value:new Kt(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new xt},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new xt},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new xt},transmissionSamplerSize:{value:new ft},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new xt},attenuationDistance:{value:0},attenuationColor:{value:new Kt(0)},specularColor:{value:new Kt(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new xt},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new xt},anisotropyVector:{value:new ft},anisotropyMap:{value:null},anisotropyMapTransform:{value:new xt}}]),vertexShader:Ft.meshphysical_vert,fragmentShader:Ft.meshphysical_frag};const Zi={r:0,b:0,g:0},Tl=new il,th=new ae;function eh(l,t,e,n,i,s,a){const d=new Kt(0);let c=s===!0?0:1,o,Z,m=null,b=0,h=null;function p(C){let R=C.isScene===!0?C.background:null;return R&&R.isTexture&&(R=(C.backgroundBlurriness>0?e:t).get(R)),R}function V(C){let R=!1;const G=p(C);G===null?u(d,c):G&&G.isColor&&(u(G,1),R=!0);const N=l.xr.getEnvironmentBlendMode();N==="additive"?n.buffers.color.setClear(0,0,0,1,a):N==="alpha-blend"&&n.buffers.color.setClear(0,0,0,0,a),(l.autoClear||R)&&(n.buffers.depth.setTest(!0),n.buffers.depth.setMask(!0),n.buffers.color.setMask(!0),l.clear(l.autoClearColor,l.autoClearDepth,l.autoClearStencil))}function r(C,R){const G=p(R);G&&(G.isCubeTexture||G.mapping===Jn)?(Z===void 0&&(Z=new ee(new Fn(1,1,1),new ce({name:"BackgroundCubeMaterial",uniforms:on(je.backgroundCube.uniforms),vertexShader:je.backgroundCube.vertexShader,fragmentShader:je.backgroundCube.fragmentShader,side:ye,depthTest:!1,depthWrite:!1,fog:!1})),Z.geometry.deleteAttribute("normal"),Z.geometry.deleteAttribute("uv"),Z.onBeforeRender=function(N,I,x){this.matrixWorld.copyPosition(x.matrixWorld)},Object.defineProperty(Z.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(Z)),Tl.copy(R.backgroundRotation),Tl.x*=-1,Tl.y*=-1,Tl.z*=-1,G.isCubeTexture&&G.isRenderTargetTexture===!1&&(Tl.y*=-1,Tl.z*=-1),Z.material.uniforms.envMap.value=G,Z.material.uniforms.flipEnvMap.value=G.isCubeTexture&&G.isRenderTargetTexture===!1?-1:1,Z.material.uniforms.backgroundBlurriness.value=R.backgroundBlurriness,Z.material.uniforms.backgroundIntensity.value=R.backgroundIntensity,Z.material.uniforms.backgroundRotation.value.setFromMatrix4(th.makeRotationFromEuler(Tl)),Z.material.toneMapped=kt.getTransfer(G.colorSpace)!==Qt,(m!==G||b!==G.version||h!==l.toneMapping)&&(Z.material.needsUpdate=!0,m=G,b=G.version,h=l.toneMapping),Z.layers.enableAll(),C.unshift(Z,Z.geometry,Z.material,0,0,null)):G&&G.isTexture&&(o===void 0&&(o=new ee(new te(2,2),new ce({name:"BackgroundMaterial",uniforms:on(je.background.uniforms),vertexShader:je.background.vertexShader,fragmentShader:je.background.fragmentShader,side:ml,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(o)),o.material.uniforms.t2D.value=G,o.material.uniforms.backgroundIntensity.value=R.backgroundIntensity,o.material.toneMapped=kt.getTransfer(G.colorSpace)!==Qt,G.matrixAutoUpdate===!0&&G.updateMatrix(),o.material.uniforms.uvTransform.value.copy(G.matrix),(m!==G||b!==G.version||h!==l.toneMapping)&&(o.material.needsUpdate=!0,m=G,b=G.version,h=l.toneMapping),o.layers.enableAll(),C.unshift(o,o.geometry,o.material,0,0,null))}function u(C,R){C.getRGB(Zi,ld(l)),n.buffers.color.setClear(Zi.r,Zi.g,Zi.b,R,a)}return{getClearColor:function(){return d},setClearColor:function(C,R=1){d.set(C),c=R,u(d,c)},getClearAlpha:function(){return c},setClearAlpha:function(C){c=C,u(d,c)},render:V,addToRenderList:r}}function lh(l,t){const e=l.getParameter(l.MAX_VERTEX_ATTRIBS),n={},i=b(null);let s=i,a=!1;function d(g,Y,Q,w,E){let D=!1;const K=m(w,Q,Y);s!==K&&(s=K,o(s.object)),D=h(g,w,Q,E),D&&p(g,w,Q,E),E!==null&&t.update(E,l.ELEMENT_ARRAY_BUFFER),(D||a)&&(a=!1,G(g,Y,Q,w),E!==null&&l.bindBuffer(l.ELEMENT_ARRAY_BUFFER,t.get(E).buffer))}function c(){return l.createVertexArray()}function o(g){return l.bindVertexArray(g)}function Z(g){return l.deleteVertexArray(g)}function m(g,Y,Q){const w=Q.wireframe===!0;let E=n[g.id];E===void 0&&(E={},n[g.id]=E);let D=E[Y.id];D===void 0&&(D={},E[Y.id]=D);let K=D[w];return K===void 0&&(K=b(c()),D[w]=K),K}function b(g){const Y=[],Q=[],w=[];for(let E=0;E<e;E++)Y[E]=0,Q[E]=0,w[E]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:Y,enabledAttributes:Q,attributeDivisors:w,object:g,attributes:{},index:null}}function h(g,Y,Q,w){const E=s.attributes,D=Y.attributes;let K=0;const $=Q.getAttributes();for(const z in $)if($[z].location>=0){const ot=E[z];let Vt=D[z];if(Vt===void 0&&(z==="instanceMatrix"&&g.instanceMatrix&&(Vt=g.instanceMatrix),z==="instanceColor"&&g.instanceColor&&(Vt=g.instanceColor)),ot===void 0||ot.attribute!==Vt||Vt&&ot.data!==Vt.data)return!0;K++}return s.attributesNum!==K||s.index!==w}function p(g,Y,Q,w){const E={},D=Y.attributes;let K=0;const $=Q.getAttributes();for(const z in $)if($[z].location>=0){let ot=D[z];ot===void 0&&(z==="instanceMatrix"&&g.instanceMatrix&&(ot=g.instanceMatrix),z==="instanceColor"&&g.instanceColor&&(ot=g.instanceColor));const Vt={};Vt.attribute=ot,ot&&ot.data&&(Vt.data=ot.data),E[z]=Vt,K++}s.attributes=E,s.attributesNum=K,s.index=w}function V(){const g=s.newAttributes;for(let Y=0,Q=g.length;Y<Q;Y++)g[Y]=0}function r(g){u(g,0)}function u(g,Y){const Q=s.newAttributes,w=s.enabledAttributes,E=s.attributeDivisors;Q[g]=1,w[g]===0&&(l.enableVertexAttribArray(g),w[g]=1),E[g]!==Y&&(l.vertexAttribDivisor(g,Y),E[g]=Y)}function C(){const g=s.newAttributes,Y=s.enabledAttributes;for(let Q=0,w=Y.length;Q<w;Q++)Y[Q]!==g[Q]&&(l.disableVertexAttribArray(Q),Y[Q]=0)}function R(g,Y,Q,w,E,D,K){K===!0?l.vertexAttribIPointer(g,Y,Q,E,D):l.vertexAttribPointer(g,Y,Q,w,E,D)}function G(g,Y,Q,w){V();const E=w.attributes,D=Q.getAttributes(),K=Y.defaultAttributeValues;for(const $ in D){const z=D[$];if(z.location>=0){let nt=E[$];if(nt===void 0&&($==="instanceMatrix"&&g.instanceMatrix&&(nt=g.instanceMatrix),$==="instanceColor"&&g.instanceColor&&(nt=g.instanceColor)),nt!==void 0){const ot=nt.normalized,Vt=nt.itemSize,Ut=t.get(nt);if(Ut===void 0)continue;const Pt=Ut.buffer,A=Ut.type,tt=Ut.bytesPerElement,pt=A===l.INT||A===l.UNSIGNED_INT||nt.gpuType===Ki;if(nt.isInterleavedBufferAttribute){const it=nt.data,yt=it.stride,It=nt.offset;if(it.isInstancedInterleavedBuffer){for(let Mt=0;Mt<z.locationSize;Mt++)u(z.location+Mt,it.meshPerAttribute);g.isInstancedMesh!==!0&&w._maxInstanceCount===void 0&&(w._maxInstanceCount=it.meshPerAttribute*it.count)}else for(let Mt=0;Mt<z.locationSize;Mt++)r(z.location+Mt);l.bindBuffer(l.ARRAY_BUFFER,Pt);for(let Mt=0;Mt<z.locationSize;Mt++)R(z.location+Mt,Vt/z.locationSize,A,ot,yt*tt,(It+Vt/z.locationSize*Mt)*tt,pt)}else{if(nt.isInstancedBufferAttribute){for(let it=0;it<z.locationSize;it++)u(z.location+it,nt.meshPerAttribute);g.isInstancedMesh!==!0&&w._maxInstanceCount===void 0&&(w._maxInstanceCount=nt.meshPerAttribute*nt.count)}else for(let it=0;it<z.locationSize;it++)r(z.location+it);l.bindBuffer(l.ARRAY_BUFFER,Pt);for(let it=0;it<z.locationSize;it++)R(z.location+it,Vt/z.locationSize,A,ot,Vt*tt,Vt/z.locationSize*it*tt,pt)}}else if(K!==void 0){const ot=K[$];if(ot!==void 0)switch(ot.length){case 2:l.vertexAttrib2fv(z.location,ot);break;case 3:l.vertexAttrib3fv(z.location,ot);break;case 4:l.vertexAttrib4fv(z.location,ot);break;default:l.vertexAttrib1fv(z.location,ot)}}}}C()}function N(){M();for(const g in n){const Y=n[g];for(const Q in Y){const w=Y[Q];for(const E in w)Z(w[E].object),delete w[E];delete Y[Q]}delete n[g]}}function I(g){if(n[g.id]===void 0)return;const Y=n[g.id];for(const Q in Y){const w=Y[Q];for(const E in w)Z(w[E].object),delete w[E];delete Y[Q]}delete n[g.id]}function x(g){for(const Y in n){const Q=n[Y];if(Q[g.id]===void 0)continue;const w=Q[g.id];for(const E in w)Z(w[E].object),delete w[E];delete Q[g.id]}}function M(){y(),a=!0,s!==i&&(s=i,o(s.object))}function y(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:d,reset:M,resetDefaultState:y,dispose:N,releaseStatesOfGeometry:I,releaseStatesOfProgram:x,initAttributes:V,enableAttribute:r,disableUnusedAttributes:C}}function nh(l,t,e){let n;function i(o){n=o}function s(o,Z){l.drawArrays(n,o,Z),e.update(Z,n,1)}function a(o,Z,m){m!==0&&(l.drawArraysInstanced(n,o,Z,m),e.update(Z,n,m))}function d(o,Z,m){if(m===0)return;t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n,o,0,Z,0,m);let h=0;for(let p=0;p<m;p++)h+=Z[p];e.update(h,n,1)}function c(o,Z,m,b){if(m===0)return;const h=t.get("WEBGL_multi_draw");if(h===null)for(let p=0;p<o.length;p++)a(o[p],Z[p],b[p]);else{h.multiDrawArraysInstancedWEBGL(n,o,0,Z,0,b,0,m);let p=0;for(let V=0;V<m;V++)p+=Z[V]*b[V];e.update(p,n,1)}}this.setMode=i,this.render=s,this.renderInstances=a,this.renderMultiDraw=d,this.renderMultiDrawInstances=c}function ih(l,t,e,n){let i;function s(){if(i!==void 0)return i;if(t.has("EXT_texture_filter_anisotropic")===!0){const x=t.get("EXT_texture_filter_anisotropic");i=l.getParameter(x.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function a(x){return!(x!==Fe&&n.convert(x)!==l.getParameter(l.IMPLEMENTATION_COLOR_READ_FORMAT))}function d(x){const M=x===Wn&&(t.has("EXT_color_buffer_half_float")||t.has("EXT_color_buffer_float"));return!(x!==Pe&&n.convert(x)!==l.getParameter(l.IMPLEMENTATION_COLOR_READ_TYPE)&&x!==$e&&!M)}function c(x){if(x==="highp"){if(l.getShaderPrecisionFormat(l.VERTEX_SHADER,l.HIGH_FLOAT).precision>0&&l.getShaderPrecisionFormat(l.FRAGMENT_SHADER,l.HIGH_FLOAT).precision>0)return"highp";x="mediump"}return x==="mediump"&&l.getShaderPrecisionFormat(l.VERTEX_SHADER,l.MEDIUM_FLOAT).precision>0&&l.getShaderPrecisionFormat(l.FRAGMENT_SHADER,l.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let o=e.precision!==void 0?e.precision:"highp";const Z=c(o);Z!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",Z,"instead."),o=Z);const m=e.logarithmicDepthBuffer===!0,b=e.reverseDepthBuffer===!0&&t.has("EXT_clip_control"),h=l.getParameter(l.MAX_TEXTURE_IMAGE_UNITS),p=l.getParameter(l.MAX_VERTEX_TEXTURE_IMAGE_UNITS),V=l.getParameter(l.MAX_TEXTURE_SIZE),r=l.getParameter(l.MAX_CUBE_MAP_TEXTURE_SIZE),u=l.getParameter(l.MAX_VERTEX_ATTRIBS),C=l.getParameter(l.MAX_VERTEX_UNIFORM_VECTORS),R=l.getParameter(l.MAX_VARYING_VECTORS),G=l.getParameter(l.MAX_FRAGMENT_UNIFORM_VECTORS),N=p>0,I=l.getParameter(l.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:s,getMaxPrecision:c,textureFormatReadable:a,textureTypeReadable:d,precision:o,logarithmicDepthBuffer:m,reverseDepthBuffer:b,maxTextures:h,maxVertexTextures:p,maxTextureSize:V,maxCubemapSize:r,maxAttributes:u,maxVertexUniforms:C,maxVaryings:R,maxFragmentUniforms:G,vertexTextures:N,maxSamples:I}}function ah(l){const t=this;let e=null,n=0,i=!1,s=!1;const a=new Ul,d=new xt,c={value:null,needsUpdate:!1};this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(m,b){const h=m.length!==0||b||n!==0||i;return i=b,n=m.length,h},this.beginShadows=function(){s=!0,Z(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(m,b){e=Z(m,b,0)},this.setState=function(m,b,h){const p=m.clippingPlanes,V=m.clipIntersection,r=m.clipShadows,u=l.get(m);if(!i||p===null||p.length===0||s&&!r)s?Z(null):o();else{const C=s?0:n,R=C*4;let G=u.clippingState||null;c.value=G,G=Z(p,b,R,h);for(let N=0;N!==R;++N)G[N]=e[N];u.clippingState=G,this.numIntersection=V?this.numPlanes:0,this.numPlanes+=C}};function o(){c.value!==e&&(c.value=e,c.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function Z(m,b,h,p){const V=m!==null?m.length:0;let r=null;if(V!==0){if(r=c.value,p!==!0||r===null){const u=h+V*4,C=b.matrixWorldInverse;d.getNormalMatrix(C),(r===null||r.length<u)&&(r=new Float32Array(u));for(let R=0,G=h;R!==V;++R,G+=4)a.copy(m[R]).applyMatrix4(C,d),a.normal.toArray(r,G),r[G+3]=a.constant}c.value=r,c.needsUpdate=!0}return t.numPlanes=V,t.numIntersection=0,r}}function sh(l){let t=new WeakMap;function e(a,d){return d===Ji?a.mapping=zl:d===ki&&(a.mapping=Kl),a}function n(a){if(a&&a.isTexture){const d=a.mapping;if(d===Ji||d===ki)if(t.has(a)){const c=t.get(a).texture;return e(c,a.mapping)}else{const c=a.image;if(c&&c.height>0){const o=new Oo(c.height);return o.fromEquirectangularTexture(l,a),t.set(a,o),a.addEventListener("dispose",i),e(o.texture,a.mapping)}else return null}}return a}function i(a){const d=a.target;d.removeEventListener("dispose",i);const c=t.get(d);c!==void 0&&(t.delete(d),c.dispose())}function s(){t=new WeakMap}return{get:n,dispose:s}}class za extends nd{constructor(t=-1,e=1,n=1,i=-1,s=.1,a=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=s,this.far=a,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,s,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let s=n-t,a=n+t,d=i+e,c=i-e;if(this.view!==null&&this.view.enabled){const o=(this.right-this.left)/this.view.fullWidth/this.zoom,Z=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=o*this.view.offsetX,a=s+o*this.view.width,d-=Z*this.view.offsetY,c=d-Z*this.view.height}this.projectionMatrix.makeOrthographic(s,a,d,c,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}const hn=4,od=[.125,.215,.35,.446,.526,.582],vl=20,Ka=new za,md=new Kt;let Ba=null,Ea=0,Aa=0,Qa=!1;const Jl=(1+Math.sqrt(5))/2,un=1/Jl,Zd=[new J(-Jl,un,0),new J(Jl,un,0),new J(-un,0,Jl),new J(un,0,Jl),new J(0,Jl,-un),new J(0,Jl,un),new J(-1,1,-1),new J(1,1,-1),new J(-1,1,1),new J(1,1,1)];class hd{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,i=100){Ba=this._renderer.getRenderTarget(),Ea=this._renderer.getActiveCubeFace(),Aa=this._renderer.getActiveMipmapLevel(),Qa=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(t,n,i,s),e>0&&this._blur(s,0,0,e),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=rd(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=bd(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(Ba,Ea,Aa),this._renderer.xr.enabled=Qa,t.scissorTest=!1,hi(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===zl||t.mapping===Kl?this._setSize(t.image.length===0?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),Ba=this._renderer.getRenderTarget(),Ea=this._renderer.getActiveCubeFace(),Aa=this._renderer.getActiveMipmapLevel(),Qa=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const n=e||this._allocateTargets();return this._textureToCubeUV(t,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,n={magFilter:be,minFilter:be,generateMipmaps:!1,type:Wn,format:Fe,colorSpace:Ql,depthBuffer:!1},i=ud(t,e,n);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==t||this._pingPongRenderTarget.height!==e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=ud(t,e,n);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=dh(s)),this._blurMaterial=ch(s,t,e)}return i}_compileMaterial(t){const e=new ee(this._lodPlanes[0],t);this._renderer.compile(e,Ka)}_sceneToCubeUV(t,e,n,i){const d=new Ke(90,1,e,n),c=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],Z=this._renderer,m=Z.autoClear,b=Z.toneMapping;Z.getClearColor(md),Z.toneMapping=hl,Z.autoClear=!1;const h=new Nn({name:"PMREM.Background",side:ye,depthWrite:!1,depthTest:!1}),p=new ee(new Fn,h);let V=!1;const r=t.background;r?r.isColor&&(h.color.copy(r),t.background=null,V=!0):(h.color.copy(md),V=!0);for(let u=0;u<6;u++){const C=u%3;C===0?(d.up.set(0,c[u],0),d.lookAt(o[u],0,0)):C===1?(d.up.set(0,0,c[u]),d.lookAt(0,o[u],0)):(d.up.set(0,c[u],0),d.lookAt(0,0,o[u]));const R=this._cubeSize;hi(i,C*R,u>2?R:0,R,R),Z.setRenderTarget(i),V&&Z.render(p,d),Z.render(t,d)}p.geometry.dispose(),p.material.dispose(),Z.toneMapping=b,Z.autoClear=m,t.background=r}_textureToCubeUV(t,e){const n=this._renderer,i=t.mapping===zl||t.mapping===Kl;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=rd()),this._cubemapMaterial.uniforms.flipEnvMap.value=t.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=bd());const s=i?this._cubemapMaterial:this._equirectMaterial,a=new ee(this._lodPlanes[0],s),d=s.uniforms;d.envMap.value=t;const c=this._cubeSize;hi(e,0,0,3*c,2*c),n.setRenderTarget(e),n.render(a,Ka)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;const i=this._lodPlanes.length;for(let s=1;s<i;s++){const a=Math.sqrt(this._sigmas[s]*this._sigmas[s]-this._sigmas[s-1]*this._sigmas[s-1]),d=Zd[(i-s-1)%Zd.length];this._blur(t,s-1,s,a,d)}e.autoClear=n}_blur(t,e,n,i,s){const a=this._pingPongRenderTarget;this._halfBlur(t,a,e,n,i,"latitudinal",s),this._halfBlur(a,t,n,n,i,"longitudinal",s)}_halfBlur(t,e,n,i,s,a,d){const c=this._renderer,o=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const Z=3,m=new ee(this._lodPlanes[i],o),b=o.uniforms,h=this._sizeLods[n]-1,p=isFinite(s)?Math.PI/(2*h):2*Math.PI/(2*vl-1),V=s/p,r=isFinite(s)?1+Math.floor(Z*V):vl;r>vl&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${r} samples when the maximum is set to ${vl}`);const u=[];let C=0;for(let x=0;x<vl;++x){const M=x/V,y=Math.exp(-M*M/2);u.push(y),x===0?C+=y:x<r&&(C+=2*y)}for(let x=0;x<u.length;x++)u[x]=u[x]/C;b.envMap.value=t.texture,b.samples.value=r,b.weights.value=u,b.latitudinal.value=a==="latitudinal",d&&(b.poleAxis.value=d);const{_lodMax:R}=this;b.dTheta.value=p,b.mipInt.value=R-n;const G=this._sizeLods[i],N=3*G*(i>R-hn?i-R+hn:0),I=4*(this._cubeSize-G);hi(e,N,I,3*G,2*G),c.setRenderTarget(e),c.render(m,Ka)}}function dh(l){const t=[],e=[],n=[];let i=l;const s=l-hn+1+od.length;for(let a=0;a<s;a++){const d=Math.pow(2,i);e.push(d);let c=1/d;a>l-hn?c=od[a-l+hn-1]:a===0&&(c=0),n.push(c);const o=1/(d-2),Z=-o,m=1+o,b=[Z,Z,m,Z,m,m,Z,Z,m,m,Z,m],h=6,p=6,V=3,r=2,u=1,C=new Float32Array(V*p*h),R=new Float32Array(r*p*h),G=new Float32Array(u*p*h);for(let I=0;I<h;I++){const x=I%3*2/3-1,M=I>2?0:-1,y=[x,M,0,x+2/3,M,0,x+2/3,M+1,0,x,M,0,x+2/3,M+1,0,x,M+1,0];C.set(y,V*p*I),R.set(b,r*p*I);const g=[I,I,I,I,I,I];G.set(g,u*p*I)}const N=new Me;N.setAttribute("position",new Se(C,V)),N.setAttribute("uv",new Se(R,r)),N.setAttribute("faceIndex",new Se(G,u)),t.push(N),i>hn&&i--}return{lodPlanes:t,sizeLods:e,sigmas:n}}function ud(l,t,e){const n=new bl(l,t,e);return n.texture.mapping=Jn,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function hi(l,t,e,n,i){l.viewport.set(t,e,n,i),l.scissor.set(t,e,n,i)}function ch(l,t,e){const n=new Float32Array(vl),i=new J(0,1,0);return new ce({name:"SphericalGaussianBlur",defines:{n:vl,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/e,CUBEUV_MAX_MIP:`${l}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:Pa(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Zl,depthTest:!1,depthWrite:!1})}function bd(){return new ce({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:Pa(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Zl,depthTest:!1,depthWrite:!1})}function rd(){return new ce({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:Pa(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Zl,depthTest:!1,depthWrite:!1})}function Pa(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function oh(l){let t=new WeakMap,e=null;function n(d){if(d&&d.isTexture){const c=d.mapping,o=c===Ji||c===ki,Z=c===zl||c===Kl;if(o||Z){let m=t.get(d);const b=m!==void 0?m.texture.pmremVersion:0;if(d.isRenderTargetTexture&&d.pmremVersion!==b)return e===null&&(e=new hd(l)),m=o?e.fromEquirectangular(d,m):e.fromCubemap(d,m),m.texture.pmremVersion=d.pmremVersion,t.set(d,m),m.texture;if(m!==void 0)return m.texture;{const h=d.image;return o&&h&&h.height>0||Z&&h&&i(h)?(e===null&&(e=new hd(l)),m=o?e.fromEquirectangular(d):e.fromCubemap(d),m.texture.pmremVersion=d.pmremVersion,t.set(d,m),d.addEventListener("dispose",s),m.texture):null}}}return d}function i(d){let c=0;const o=6;for(let Z=0;Z<o;Z++)d[Z]!==void 0&&c++;return c===o}function s(d){const c=d.target;c.removeEventListener("dispose",s);const o=t.get(c);o!==void 0&&(t.delete(c),o.dispose())}function a(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:n,dispose:a}}function mh(l){const t={};function e(n){if(t[n]!==void 0)return t[n];let i;switch(n){case"WEBGL_depth_texture":i=l.getExtension("WEBGL_depth_texture")||l.getExtension("MOZ_WEBGL_depth_texture")||l.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=l.getExtension("EXT_texture_filter_anisotropic")||l.getExtension("MOZ_EXT_texture_filter_anisotropic")||l.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=l.getExtension("WEBGL_compressed_texture_s3tc")||l.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||l.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=l.getExtension("WEBGL_compressed_texture_pvrtc")||l.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=l.getExtension(n)}return t[n]=i,i}return{has:function(n){return e(n)!==null},init:function(){e("EXT_color_buffer_float"),e("WEBGL_clip_cull_distance"),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("WEBGL_multisampled_render_to_texture"),e("WEBGL_render_shared_exponent")},get:function(n){const i=e(n);return i===null&&Rn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function Zh(l,t,e,n){const i={},s=new WeakMap;function a(m){const b=m.target;b.index!==null&&t.remove(b.index);for(const p in b.attributes)t.remove(b.attributes[p]);for(const p in b.morphAttributes){const V=b.morphAttributes[p];for(let r=0,u=V.length;r<u;r++)t.remove(V[r])}b.removeEventListener("dispose",a),delete i[b.id];const h=s.get(b);h&&(t.remove(h),s.delete(b)),n.releaseStatesOfGeometry(b),b.isInstancedBufferGeometry===!0&&delete b._maxInstanceCount,e.memory.geometries--}function d(m,b){return i[b.id]===!0||(b.addEventListener("dispose",a),i[b.id]=!0,e.memory.geometries++),b}function c(m){const b=m.attributes;for(const p in b)t.update(b[p],l.ARRAY_BUFFER);const h=m.morphAttributes;for(const p in h){const V=h[p];for(let r=0,u=V.length;r<u;r++)t.update(V[r],l.ARRAY_BUFFER)}}function o(m){const b=[],h=m.index,p=m.attributes.position;let V=0;if(h!==null){const C=h.array;V=h.version;for(let R=0,G=C.length;R<G;R+=3){const N=C[R+0],I=C[R+1],x=C[R+2];b.push(N,I,I,x,x,N)}}else if(p!==void 0){const C=p.array;V=p.version;for(let R=0,G=C.length/3-1;R<G;R+=3){const N=R+0,I=R+1,x=R+2;b.push(N,I,I,x,x,N)}}else return;const r=new(fs(b)?qs:Os)(b,1);r.version=V;const u=s.get(m);u&&t.remove(u),s.set(m,r)}function Z(m){const b=s.get(m);if(b){const h=m.index;h!==null&&b.version<h.version&&o(m)}else o(m);return s.get(m)}return{get:d,update:c,getWireframeAttribute:Z}}function hh(l,t,e){let n;function i(b){n=b}let s,a;function d(b){s=b.type,a=b.bytesPerElement}function c(b,h){l.drawElements(n,h,s,b*a),e.update(h,n,1)}function o(b,h,p){p!==0&&(l.drawElementsInstanced(n,h,s,b*a,p),e.update(h,n,p))}function Z(b,h,p){if(p===0)return;t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n,h,0,s,b,0,p);let r=0;for(let u=0;u<p;u++)r+=h[u];e.update(r,n,1)}function m(b,h,p,V){if(p===0)return;const r=t.get("WEBGL_multi_draw");if(r===null)for(let u=0;u<b.length;u++)o(b[u]/a,h[u],V[u]);else{r.multiDrawElementsInstancedWEBGL(n,h,0,s,b,0,V,0,p);let u=0;for(let C=0;C<p;C++)u+=h[C]*V[C];e.update(u,n,1)}}this.setMode=i,this.setIndex=d,this.render=c,this.renderInstances=o,this.renderMultiDraw=Z,this.renderMultiDrawInstances=m}function uh(l){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,a,d){switch(e.calls++,a){case l.TRIANGLES:e.triangles+=d*(s/3);break;case l.LINES:e.lines+=d*(s/2);break;case l.LINE_STRIP:e.lines+=d*(s-1);break;case l.LINE_LOOP:e.lines+=d*s;break;case l.POINTS:e.points+=d*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function i(){e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:i,update:n}}function bh(l,t,e){const n=new WeakMap,i=new ie;function s(a,d,c){const o=a.morphTargetInfluences,Z=d.morphAttributes.position||d.morphAttributes.normal||d.morphAttributes.color,m=Z!==void 0?Z.length:0;let b=n.get(d);if(b===void 0||b.count!==m){let y=function(){x.dispose(),n.delete(d),d.removeEventListener("dispose",y)};b!==void 0&&b.texture.dispose();const h=d.morphAttributes.position!==void 0,p=d.morphAttributes.normal!==void 0,V=d.morphAttributes.color!==void 0,r=d.morphAttributes.position||[],u=d.morphAttributes.normal||[],C=d.morphAttributes.color||[];let R=0;h===!0&&(R=1),p===!0&&(R=2),V===!0&&(R=3);let G=d.attributes.position.count*R,N=1;G>t.maxTextureSize&&(N=Math.ceil(G/t.maxTextureSize),G=t.maxTextureSize);const I=new Float32Array(G*N*4*m),x=new ks(I,G,N,m);x.type=$e,x.needsUpdate=!0;const M=R*4;for(let g=0;g<m;g++){const Y=r[g],Q=u[g],w=C[g],E=G*N*4*g;for(let D=0;D<Y.count;D++){const K=D*M;h===!0&&(i.fromBufferAttribute(Y,D),I[E+K+0]=i.x,I[E+K+1]=i.y,I[E+K+2]=i.z,I[E+K+3]=0),p===!0&&(i.fromBufferAttribute(Q,D),I[E+K+4]=i.x,I[E+K+5]=i.y,I[E+K+6]=i.z,I[E+K+7]=0),V===!0&&(i.fromBufferAttribute(w,D),I[E+K+8]=i.x,I[E+K+9]=i.y,I[E+K+10]=i.z,I[E+K+11]=w.itemSize===4?i.w:1)}}b={count:m,texture:x,size:new ft(G,N)},n.set(d,b),d.addEventListener("dispose",y)}if(a.isInstancedMesh===!0&&a.morphTexture!==null)c.getUniforms().setValue(l,"morphTexture",a.morphTexture,e);else{let h=0;for(let V=0;V<o.length;V++)h+=o[V];const p=d.morphTargetsRelative?1:1-h;c.getUniforms().setValue(l,"morphTargetBaseInfluence",p),c.getUniforms().setValue(l,"morphTargetInfluences",o)}c.getUniforms().setValue(l,"morphTargetsTexture",b.texture,e),c.getUniforms().setValue(l,"morphTargetsTextureSize",b.size)}return{update:s}}function rh(l,t,e,n){let i=new WeakMap;function s(c){const o=n.render.frame,Z=c.geometry,m=t.get(c,Z);if(i.get(m)!==o&&(t.update(m),i.set(m,o)),c.isInstancedMesh&&(c.hasEventListener("dispose",d)===!1&&c.addEventListener("dispose",d),i.get(c)!==o&&(e.update(c.instanceMatrix,l.ARRAY_BUFFER),c.instanceColor!==null&&e.update(c.instanceColor,l.ARRAY_BUFFER),i.set(c,o))),c.isSkinnedMesh){const b=c.skeleton;i.get(b)!==o&&(b.update(),i.set(b,o))}return m}function a(){i=new WeakMap}function d(c){const o=c.target;o.removeEventListener("dispose",d),e.remove(o.instanceMatrix),o.instanceColor!==null&&e.remove(o.instanceColor)}return{update:s,dispose:a}}class pd extends ge{constructor(t,e,n,i,s,a,d,c,o,Z=El){if(Z!==El&&Z!==Al)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&Z===El&&(n=Yl),n===void 0&&Z===Al&&(n=Bl),super(null,i,s,a,d,c,Z,n,o),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=d!==void 0?d:Je,this.minFilter=c!==void 0?c:Je,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return this.compareFunction!==null&&(e.compareFunction=this.compareFunction),e}}const Gd=new ge,Wd=new pd(1,1),Vd=new ks,Xd=new To,gd=new sd,Rd=[],yd=[],Cd=new Float32Array(16),Sd=new Float32Array(9),Id=new Float32Array(4);function bn(l,t,e){const n=l[0];if(n<=0||n>0)return l;const i=t*e;let s=Rd[i];if(s===void 0&&(s=new Float32Array(i),Rd[i]=s),t!==0){n.toArray(s,0);for(let a=1,d=0;a!==t;++a)d+=e,l[a].toArray(s,d)}return s}function oe(l,t){if(l.length!==t.length)return!1;for(let e=0,n=l.length;e<n;e++)if(l[e]!==t[e])return!1;return!0}function me(l,t){for(let e=0,n=t.length;e<n;e++)l[e]=t[e]}function ui(l,t){let e=yd[t];e===void 0&&(e=new Int32Array(t),yd[t]=e);for(let n=0;n!==t;++n)e[n]=l.allocateTextureUnit();return e}function ph(l,t){const e=this.cache;e[0]!==t&&(l.uniform1f(this.addr,t),e[0]=t)}function Gh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(l.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(oe(e,t))return;l.uniform2fv(this.addr,t),me(e,t)}}function Wh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(l.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(l.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(oe(e,t))return;l.uniform3fv(this.addr,t),me(e,t)}}function Vh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(l.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(oe(e,t))return;l.uniform4fv(this.addr,t),me(e,t)}}function Xh(l,t){const e=this.cache,n=t.elements;if(n===void 0){if(oe(e,t))return;l.uniformMatrix2fv(this.addr,!1,t),me(e,t)}else{if(oe(e,n))return;Id.set(n),l.uniformMatrix2fv(this.addr,!1,Id),me(e,n)}}function gh(l,t){const e=this.cache,n=t.elements;if(n===void 0){if(oe(e,t))return;l.uniformMatrix3fv(this.addr,!1,t),me(e,t)}else{if(oe(e,n))return;Sd.set(n),l.uniformMatrix3fv(this.addr,!1,Sd),me(e,n)}}function Rh(l,t){const e=this.cache,n=t.elements;if(n===void 0){if(oe(e,t))return;l.uniformMatrix4fv(this.addr,!1,t),me(e,t)}else{if(oe(e,n))return;Cd.set(n),l.uniformMatrix4fv(this.addr,!1,Cd),me(e,n)}}function yh(l,t){const e=this.cache;e[0]!==t&&(l.uniform1i(this.addr,t),e[0]=t)}function Ch(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(l.uniform2i(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(oe(e,t))return;l.uniform2iv(this.addr,t),me(e,t)}}function Sh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(l.uniform3i(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else{if(oe(e,t))return;l.uniform3iv(this.addr,t),me(e,t)}}function Ih(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(l.uniform4i(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(oe(e,t))return;l.uniform4iv(this.addr,t),me(e,t)}}function xh(l,t){const e=this.cache;e[0]!==t&&(l.uniform1ui(this.addr,t),e[0]=t)}function Yh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(l.uniform2ui(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(oe(e,t))return;l.uniform2uiv(this.addr,t),me(e,t)}}function Nh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(l.uniform3ui(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else{if(oe(e,t))return;l.uniform3uiv(this.addr,t),me(e,t)}}function fh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(l.uniform4ui(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(oe(e,t))return;l.uniform4uiv(this.addr,t),me(e,t)}}function Fh(l,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(l.uniform1i(this.addr,i),n[0]=i);let s;this.type===l.SAMPLER_2D_SHADOW?(Wd.compareFunction=Is,s=Wd):s=Gd,e.setTexture2D(t||s,i)}function Lh(l,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(l.uniform1i(this.addr,i),n[0]=i),e.setTexture3D(t||Xd,i)}function Uh(l,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(l.uniform1i(this.addr,i),n[0]=i),e.setTextureCube(t||gd,i)}function Mh(l,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(l.uniform1i(this.addr,i),n[0]=i),e.setTexture2DArray(t||Vd,i)}function Th(l){switch(l){case 5126:return ph;case 35664:return Gh;case 35665:return Wh;case 35666:return Vh;case 35674:return Xh;case 35675:return gh;case 35676:return Rh;case 5124:case 35670:return yh;case 35667:case 35671:return Ch;case 35668:case 35672:return Sh;case 35669:case 35673:return Ih;case 5125:return xh;case 36294:return Yh;case 36295:return Nh;case 36296:return fh;case 35678:case 36198:case 36298:case 36306:case 35682:return Fh;case 35679:case 36299:case 36307:return Lh;case 35680:case 36300:case 36308:case 36293:return Uh;case 36289:case 36303:case 36311:case 36292:return Mh}}function vh(l,t){l.uniform1fv(this.addr,t)}function Jh(l,t){const e=bn(t,this.size,2);l.uniform2fv(this.addr,e)}function kh(l,t){const e=bn(t,this.size,3);l.uniform3fv(this.addr,e)}function wh(l,t){const e=bn(t,this.size,4);l.uniform4fv(this.addr,e)}function Hh(l,t){const e=bn(t,this.size,4);l.uniformMatrix2fv(this.addr,!1,e)}function zh(l,t){const e=bn(t,this.size,9);l.uniformMatrix3fv(this.addr,!1,e)}function Kh(l,t){const e=bn(t,this.size,16);l.uniformMatrix4fv(this.addr,!1,e)}function Bh(l,t){l.uniform1iv(this.addr,t)}function Eh(l,t){l.uniform2iv(this.addr,t)}function Ah(l,t){l.uniform3iv(this.addr,t)}function Qh(l,t){l.uniform4iv(this.addr,t)}function Ph(l,t){l.uniform1uiv(this.addr,t)}function jh(l,t){l.uniform2uiv(this.addr,t)}function _h(l,t){l.uniform3uiv(this.addr,t)}function Dh(l,t){l.uniform4uiv(this.addr,t)}function Oh(l,t,e){const n=this.cache,i=t.length,s=ui(e,i);oe(n,s)||(l.uniform1iv(this.addr,s),me(n,s));for(let a=0;a!==i;++a)e.setTexture2D(t[a]||Gd,s[a])}function qh(l,t,e){const n=this.cache,i=t.length,s=ui(e,i);oe(n,s)||(l.uniform1iv(this.addr,s),me(n,s));for(let a=0;a!==i;++a)e.setTexture3D(t[a]||Xd,s[a])}function $h(l,t,e){const n=this.cache,i=t.length,s=ui(e,i);oe(n,s)||(l.uniform1iv(this.addr,s),me(n,s));for(let a=0;a!==i;++a)e.setTextureCube(t[a]||gd,s[a])}function tu(l,t,e){const n=this.cache,i=t.length,s=ui(e,i);oe(n,s)||(l.uniform1iv(this.addr,s),me(n,s));for(let a=0;a!==i;++a)e.setTexture2DArray(t[a]||Vd,s[a])}function eu(l){switch(l){case 5126:return vh;case 35664:return Jh;case 35665:return kh;case 35666:return wh;case 35674:return Hh;case 35675:return zh;case 35676:return Kh;case 5124:case 35670:return Bh;case 35667:case 35671:return Eh;case 35668:case 35672:return Ah;case 35669:case 35673:return Qh;case 5125:return Ph;case 36294:return jh;case 36295:return _h;case 36296:return Dh;case 35678:case 36198:case 36298:case 36306:case 35682:return Oh;case 35679:case 36299:case 36307:return qh;case 35680:case 36300:case 36308:case 36293:return $h;case 36289:case 36303:case 36311:case 36292:return tu}}class lu{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.type=e.type,this.setValue=Th(e.type)}}class nu{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.type=e.type,this.size=e.size,this.setValue=eu(e.type)}}class iu{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,n){const i=this.seq;for(let s=0,a=i.length;s!==a;++s){const d=i[s];d.setValue(t,e[d.id],n)}}}const ja=/(\w+)(\])?(\[|\.)?/g;function xd(l,t){l.seq.push(t),l.map[t.id]=t}function au(l,t,e){const n=l.name,i=n.length;for(ja.lastIndex=0;;){const s=ja.exec(n),a=ja.lastIndex;let d=s[1];const c=s[2]==="]",o=s[3];if(c&&(d=d|0),o===void 0||o==="["&&a+2===i){xd(e,o===void 0?new lu(d,l,t):new nu(d,l,t));break}else{let m=e.map[d];m===void 0&&(m=new iu(d),xd(e,m)),e=m}}}class bi{constructor(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){const s=t.getActiveUniform(e,i),a=t.getUniformLocation(e,s.name);au(s,a,this)}}setValue(t,e,n,i){const s=this.map[e];s!==void 0&&s.setValue(t,n,i)}setOptional(t,e,n){const i=e[n];i!==void 0&&this.setValue(t,n,i)}static upload(t,e,n,i){for(let s=0,a=e.length;s!==a;++s){const d=e[s],c=n[d.id];c.needsUpdate!==!1&&d.setValue(t,c.value,i)}}static seqWithValue(t,e){const n=[];for(let i=0,s=t.length;i!==s;++i){const a=t[i];a.id in e&&n.push(a)}return n}}function Yd(l,t,e){const n=l.createShader(t);return l.shaderSource(n,e),l.compileShader(n),n}const su=37297;let du=0;function cu(l,t){const e=l.split(`
`),n=[],i=Math.max(t-6,0),s=Math.min(t+6,e.length);for(let a=i;a<s;a++){const d=a+1;n.push(`${d===t?">":" "} ${d}: ${e[a]}`)}return n.join(`
`)}const Nd=new xt;function ou(l){kt._getMatrix(Nd,kt.workingColorSpace,l);const t=`mat3( ${Nd.elements.map(e=>e.toFixed(4))} )`;switch(kt.getTransfer(l)){case En:return[t,"LinearTransferOETF"];case Qt:return[t,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",l),[t,"LinearTransferOETF"]}}function fd(l,t,e){const n=l.getShaderParameter(t,l.COMPILE_STATUS),i=l.getShaderInfoLog(t).trim();if(n&&i==="")return"";const s=/ERROR: 0:(\d+)/.exec(i);if(s){const a=parseInt(s[1]);return e.toUpperCase()+`

`+i+`

`+cu(l.getShaderSource(t),a)}else return i}function mu(l,t){const e=ou(t);return[`vec4 ${l}( vec4 value ) {`,`	return ${e[1]}( vec4( value.rgb * ${e[0]}, value.a ) );`,"}"].join(`
`)}function Zu(l,t){let e;switch(t){case Ac:e="Linear";break;case Qc:e="Reinhard";break;case Pc:e="Cineon";break;case jc:e="ACESFilmic";break;case Dc:e="AgX";break;case Oc:e="Neutral";break;case _c:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+l+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}const ri=new J;function hu(){kt.getLuminanceCoefficients(ri);const l=ri.x.toFixed(4),t=ri.y.toFixed(4),e=ri.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${l}, ${t}, ${e} );`,"	return dot( weights, rgb );","}"].join(`
`)}function uu(l){return[l.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",l.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(Ln).join(`
`)}function bu(l){const t=[];for(const e in l){const n=l[e];n!==!1&&t.push("#define "+e+" "+n)}return t.join(`
`)}function ru(l,t){const e={},n=l.getProgramParameter(t,l.ACTIVE_ATTRIBUTES);for(let i=0;i<n;i++){const s=l.getActiveAttrib(t,i),a=s.name;let d=1;s.type===l.FLOAT_MAT2&&(d=2),s.type===l.FLOAT_MAT3&&(d=3),s.type===l.FLOAT_MAT4&&(d=4),e[a]={type:s.type,location:l.getAttribLocation(t,a),locationSize:d}}return e}function Ln(l){return l!==""}function Fd(l,t){const e=t.numSpotLightShadows+t.numSpotLightMaps-t.numSpotLightShadowsWithMaps;return l.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,e).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function Ld(l,t){return l.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const pu=/^[ \t]*#include +<([\w\d./]+)>/gm;function _a(l){return l.replace(pu,Wu)}const Gu=new Map;function Wu(l,t){let e=Ft[t];if(e===void 0){const n=Gu.get(t);if(n!==void 0)e=Ft[n],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',t,n);else throw new Error("Can not resolve #include <"+t+">")}return _a(e)}const Vu=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Ud(l){return l.replace(Vu,Xu)}function Xu(l,t,e,n){let i="";for(let s=parseInt(t);s<parseInt(e);s++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function Md(l){let t=`precision ${l.precision} float;
	precision ${l.precision} int;
	precision ${l.precision} sampler2D;
	precision ${l.precision} samplerCube;
	precision ${l.precision} sampler3D;
	precision ${l.precision} sampler2DArray;
	precision ${l.precision} sampler2DShadow;
	precision ${l.precision} samplerCubeShadow;
	precision ${l.precision} sampler2DArrayShadow;
	precision ${l.precision} isampler2D;
	precision ${l.precision} isampler3D;
	precision ${l.precision} isamplerCube;
	precision ${l.precision} isampler2DArray;
	precision ${l.precision} usampler2D;
	precision ${l.precision} usampler3D;
	precision ${l.precision} usamplerCube;
	precision ${l.precision} usampler2DArray;
	`;return l.precision==="highp"?t+=`
#define HIGH_PRECISION`:l.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:l.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function gu(l){let t="SHADOWMAP_TYPE_BASIC";return l.shadowMapType===ms?t="SHADOWMAP_TYPE_PCF":l.shadowMapType===Cc?t="SHADOWMAP_TYPE_PCF_SOFT":l.shadowMapType===Oe&&(t="SHADOWMAP_TYPE_VSM"),t}function Ru(l){let t="ENVMAP_TYPE_CUBE";if(l.envMap)switch(l.envMapMode){case zl:case Kl:t="ENVMAP_TYPE_CUBE";break;case Jn:t="ENVMAP_TYPE_CUBE_UV";break}return t}function yu(l){let t="ENVMAP_MODE_REFLECTION";if(l.envMap)switch(l.envMapMode){case Kl:t="ENVMAP_MODE_REFRACTION";break}return t}function Cu(l){let t="ENVMAP_BLENDING_NONE";if(l.envMap)switch(l.combine){case us:t="ENVMAP_BLENDING_MULTIPLY";break;case Bc:t="ENVMAP_BLENDING_MIX";break;case Ec:t="ENVMAP_BLENDING_ADD";break}return t}function Su(l){const t=l.envMapCubeUVHeight;if(t===null)return null;const e=Math.log2(t)-2,n=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,e),7*16)),texelHeight:n,maxMip:e}}function Iu(l,t,e,n){const i=l.getContext(),s=e.defines;let a=e.vertexShader,d=e.fragmentShader;const c=gu(e),o=Ru(e),Z=yu(e),m=Cu(e),b=Su(e),h=uu(e),p=bu(s),V=i.createProgram();let r,u,C=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(r=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,p].filter(Ln).join(`
`),r.length>0&&(r+=`
`),u=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,p].filter(Ln).join(`
`),u.length>0&&(u+=`
`)):(r=[Md(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,p,e.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",e.batching?"#define USE_BATCHING":"",e.batchingColor?"#define USE_BATCHING_COLOR":"",e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.instancingMorph?"#define USE_INSTANCING_MORPH":"",e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+Z:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.displacementMap?"#define USE_DISPLACEMENTMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaHash?"#define USE_ALPHAHASH":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.mapUv?"#define MAP_UV "+e.mapUv:"",e.alphaMapUv?"#define ALPHAMAP_UV "+e.alphaMapUv:"",e.lightMapUv?"#define LIGHTMAP_UV "+e.lightMapUv:"",e.aoMapUv?"#define AOMAP_UV "+e.aoMapUv:"",e.emissiveMapUv?"#define EMISSIVEMAP_UV "+e.emissiveMapUv:"",e.bumpMapUv?"#define BUMPMAP_UV "+e.bumpMapUv:"",e.normalMapUv?"#define NORMALMAP_UV "+e.normalMapUv:"",e.displacementMapUv?"#define DISPLACEMENTMAP_UV "+e.displacementMapUv:"",e.metalnessMapUv?"#define METALNESSMAP_UV "+e.metalnessMapUv:"",e.roughnessMapUv?"#define ROUGHNESSMAP_UV "+e.roughnessMapUv:"",e.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+e.anisotropyMapUv:"",e.clearcoatMapUv?"#define CLEARCOATMAP_UV "+e.clearcoatMapUv:"",e.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+e.clearcoatNormalMapUv:"",e.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+e.clearcoatRoughnessMapUv:"",e.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+e.iridescenceMapUv:"",e.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+e.iridescenceThicknessMapUv:"",e.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+e.sheenColorMapUv:"",e.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+e.sheenRoughnessMapUv:"",e.specularMapUv?"#define SPECULARMAP_UV "+e.specularMapUv:"",e.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+e.specularColorMapUv:"",e.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+e.specularIntensityMapUv:"",e.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+e.transmissionMapUv:"",e.thicknessMapUv?"#define THICKNESSMAP_UV "+e.thicknessMapUv:"",e.vertexTangents&&e.flatShading===!1?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphColors?"#define USE_MORPHCOLORS":"",e.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+e.morphTextureStride:"",e.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+c:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Ln).join(`
`),u=[Md(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,p,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+o:"",e.envMap?"#define "+Z:"",e.envMap?"#define "+m:"",b?"#define CUBEUV_TEXEL_WIDTH "+b.texelWidth:"",b?"#define CUBEUV_TEXEL_HEIGHT "+b.texelHeight:"",b?"#define CUBEUV_MAX_MIP "+b.maxMip+".0":"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.dispersion?"#define USE_DISPERSION":"",e.iridescence?"#define USE_IRIDESCENCE":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.alphaHash?"#define USE_ALPHAHASH":"",e.sheen?"#define USE_SHEEN":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents&&e.flatShading===!1?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor||e.batchingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+c:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",e.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",e.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==hl?"#define TONE_MAPPING":"",e.toneMapping!==hl?Ft.tonemapping_pars_fragment:"",e.toneMapping!==hl?Zu("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.opaque?"#define OPAQUE":"",Ft.colorspace_pars_fragment,mu("linearToOutputTexel",e.outputColorSpace),hu(),e.useDepthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Ln).join(`
`)),a=_a(a),a=Fd(a,e),a=Ld(a,e),d=_a(d),d=Fd(d,e),d=Ld(d,e),a=Ud(a),d=Ud(d),e.isRawShaderMaterial!==!0&&(C=`#version 300 es
`,r=[h,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+r,u=["#define varying in",e.glslVersion===Ys?"":"layout(location = 0) out highp vec4 pc_fragColor;",e.glslVersion===Ys?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+u);const R=C+r+a,G=C+u+d,N=Yd(i,i.VERTEX_SHADER,R),I=Yd(i,i.FRAGMENT_SHADER,G);i.attachShader(V,N),i.attachShader(V,I),e.index0AttributeName!==void 0?i.bindAttribLocation(V,0,e.index0AttributeName):e.morphTargets===!0&&i.bindAttribLocation(V,0,"position"),i.linkProgram(V);function x(Y){if(l.debug.checkShaderErrors){const Q=i.getProgramInfoLog(V).trim(),w=i.getShaderInfoLog(N).trim(),E=i.getShaderInfoLog(I).trim();let D=!0,K=!0;if(i.getProgramParameter(V,i.LINK_STATUS)===!1)if(D=!1,typeof l.debug.onShaderError=="function")l.debug.onShaderError(i,V,N,I);else{const $=fd(i,N,"vertex"),z=fd(i,I,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(V,i.VALIDATE_STATUS)+`

Material Name: `+Y.name+`
Material Type: `+Y.type+`

Program Info Log: `+Q+`
`+$+`
`+z)}else Q!==""?console.warn("THREE.WebGLProgram: Program Info Log:",Q):(w===""||E==="")&&(K=!1);K&&(Y.diagnostics={runnable:D,programLog:Q,vertexShader:{log:w,prefix:r},fragmentShader:{log:E,prefix:u}})}i.deleteShader(N),i.deleteShader(I),M=new bi(i,V),y=ru(i,V)}let M;this.getUniforms=function(){return M===void 0&&x(this),M};let y;this.getAttributes=function(){return y===void 0&&x(this),y};let g=e.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return g===!1&&(g=i.getProgramParameter(V,su)),g},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(V),this.program=void 0},this.type=e.shaderType,this.name=e.shaderName,this.id=du++,this.cacheKey=t,this.usedTimes=1,this.program=V,this.vertexShader=N,this.fragmentShader=I,this}let xu=0;class Yu{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,n=t.fragmentShader,i=this._getShaderStage(e),s=this._getShaderStage(n),a=this._getShaderCacheForMaterial(t);return a.has(i)===!1&&(a.add(i),i.usedTimes++),a.has(s)===!1&&(a.add(s),s.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const n of e)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;let n=e.get(t);return n===void 0&&(n=new Set,e.set(t,n)),n}_getShaderStage(t){const e=this.shaderCache;let n=e.get(t);return n===void 0&&(n=new Nu(t),e.set(t,n)),n}}class Nu{constructor(t){this.id=xu++,this.code=t,this.usedTimes=0}}function fu(l,t,e,n,i,s,a){const d=new Bs,c=new Yu,o=new Set,Z=[],m=i.logarithmicDepthBuffer,b=i.vertexTextures;let h=i.precision;const p={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function V(y){return o.add(y),y===0?"uv":`uv${y}`}function r(y,g,Y,Q,w){const E=Q.fog,D=w.geometry,K=y.isMeshStandardMaterial?Q.environment:null,$=(y.isMeshStandardMaterial?e:t).get(y.envMap||K),z=$&&$.mapping===Jn?$.image.height:null,nt=p[y.type];y.precision!==null&&(h=i.getMaxPrecision(y.precision),h!==y.precision&&console.warn("THREE.WebGLProgram.getParameters:",y.precision,"not supported, using",h,"instead."));const ot=D.morphAttributes.position||D.morphAttributes.normal||D.morphAttributes.color,Vt=ot!==void 0?ot.length:0;let Ut=0;D.morphAttributes.position!==void 0&&(Ut=1),D.morphAttributes.normal!==void 0&&(Ut=2),D.morphAttributes.color!==void 0&&(Ut=3);let Pt,A,tt,pt;if(nt){const At=je[nt];Pt=At.vertexShader,A=At.fragmentShader}else Pt=y.vertexShader,A=y.fragmentShader,c.update(y),tt=c.getVertexShaderID(y),pt=c.getFragmentShaderID(y);const it=l.getRenderTarget(),yt=l.state.buffers.depth.getReversed(),It=w.isInstancedMesh===!0,Mt=w.isBatchedMesh===!0,le=!!y.map,wt=!!y.matcap,se=!!$,U=!!y.aoMap,Te=!!y.lightMap,Tt=!!y.bumpMap,vt=!!y.normalMap,gt=!!y.displacementMap,Ot=!!y.emissiveMap,Xt=!!y.metalnessMap,S=!!y.roughnessMap,W=y.anisotropy>0,T=y.clearcoat>0,P=y.dispersion>0,_=y.iridescence>0,B=y.sheen>0,Gt=y.transmission>0,at=W&&!!y.anisotropyMap,mt=T&&!!y.clearcoatMap,Ht=T&&!!y.clearcoatNormalMap,O=T&&!!y.clearcoatRoughnessMap,Zt=_&&!!y.iridescenceMap,Rt=_&&!!y.iridescenceThicknessMap,Ct=B&&!!y.sheenColorMap,ht=B&&!!y.sheenRoughnessMap,Jt=!!y.specularMap,Lt=!!y.specularColorMap,_t=!!y.specularIntensityMap,f=Gt&&!!y.transmissionMap,lt=Gt&&!!y.thicknessMap,H=!!y.gradientMap,j=!!y.alphaMap,ct=y.alphaTest>0,st=!!y.alphaHash,Yt=!!y.extensions;let ne=hl;y.toneMapped&&(it===null||it.isXRRenderTarget===!0)&&(ne=l.toneMapping);const We={shaderID:nt,shaderType:y.type,shaderName:y.name,vertexShader:Pt,fragmentShader:A,defines:y.defines,customVertexShaderID:tt,customFragmentShaderID:pt,isRawShaderMaterial:y.isRawShaderMaterial===!0,glslVersion:y.glslVersion,precision:h,batching:Mt,batchingColor:Mt&&w._colorsTexture!==null,instancing:It,instancingColor:It&&w.instanceColor!==null,instancingMorph:It&&w.morphTexture!==null,supportsVertexTextures:b,outputColorSpace:it===null?l.outputColorSpace:it.isXRRenderTarget===!0?it.texture.colorSpace:Ql,alphaToCoverage:!!y.alphaToCoverage,map:le,matcap:wt,envMap:se,envMapMode:se&&$.mapping,envMapCubeUVHeight:z,aoMap:U,lightMap:Te,bumpMap:Tt,normalMap:vt,displacementMap:b&&gt,emissiveMap:Ot,normalMapObjectSpace:vt&&y.normalMapType===lo,normalMapTangentSpace:vt&&y.normalMapType===eo,metalnessMap:Xt,roughnessMap:S,anisotropy:W,anisotropyMap:at,clearcoat:T,clearcoatMap:mt,clearcoatNormalMap:Ht,clearcoatRoughnessMap:O,dispersion:P,iridescence:_,iridescenceMap:Zt,iridescenceThicknessMap:Rt,sheen:B,sheenColorMap:Ct,sheenRoughnessMap:ht,specularMap:Jt,specularColorMap:Lt,specularIntensityMap:_t,transmission:Gt,transmissionMap:f,thicknessMap:lt,gradientMap:H,opaque:y.transparent===!1&&y.blending===Qe&&y.alphaToCoverage===!1,alphaMap:j,alphaTest:ct,alphaHash:st,combine:y.combine,mapUv:le&&V(y.map.channel),aoMapUv:U&&V(y.aoMap.channel),lightMapUv:Te&&V(y.lightMap.channel),bumpMapUv:Tt&&V(y.bumpMap.channel),normalMapUv:vt&&V(y.normalMap.channel),displacementMapUv:gt&&V(y.displacementMap.channel),emissiveMapUv:Ot&&V(y.emissiveMap.channel),metalnessMapUv:Xt&&V(y.metalnessMap.channel),roughnessMapUv:S&&V(y.roughnessMap.channel),anisotropyMapUv:at&&V(y.anisotropyMap.channel),clearcoatMapUv:mt&&V(y.clearcoatMap.channel),clearcoatNormalMapUv:Ht&&V(y.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:O&&V(y.clearcoatRoughnessMap.channel),iridescenceMapUv:Zt&&V(y.iridescenceMap.channel),iridescenceThicknessMapUv:Rt&&V(y.iridescenceThicknessMap.channel),sheenColorMapUv:Ct&&V(y.sheenColorMap.channel),sheenRoughnessMapUv:ht&&V(y.sheenRoughnessMap.channel),specularMapUv:Jt&&V(y.specularMap.channel),specularColorMapUv:Lt&&V(y.specularColorMap.channel),specularIntensityMapUv:_t&&V(y.specularIntensityMap.channel),transmissionMapUv:f&&V(y.transmissionMap.channel),thicknessMapUv:lt&&V(y.thicknessMap.channel),alphaMapUv:j&&V(y.alphaMap.channel),vertexTangents:!!D.attributes.tangent&&(vt||W),vertexColors:y.vertexColors,vertexAlphas:y.vertexColors===!0&&!!D.attributes.color&&D.attributes.color.itemSize===4,pointsUvs:w.isPoints===!0&&!!D.attributes.uv&&(le||j),fog:!!E,useFog:y.fog===!0,fogExp2:!!E&&E.isFogExp2,flatShading:y.flatShading===!0,sizeAttenuation:y.sizeAttenuation===!0,logarithmicDepthBuffer:m,reverseDepthBuffer:yt,skinning:w.isSkinnedMesh===!0,morphTargets:D.morphAttributes.position!==void 0,morphNormals:D.morphAttributes.normal!==void 0,morphColors:D.morphAttributes.color!==void 0,morphTargetsCount:Vt,morphTextureStride:Ut,numDirLights:g.directional.length,numPointLights:g.point.length,numSpotLights:g.spot.length,numSpotLightMaps:g.spotLightMap.length,numRectAreaLights:g.rectArea.length,numHemiLights:g.hemi.length,numDirLightShadows:g.directionalShadowMap.length,numPointLightShadows:g.pointShadowMap.length,numSpotLightShadows:g.spotShadowMap.length,numSpotLightShadowsWithMaps:g.numSpotLightShadowsWithMaps,numLightProbes:g.numLightProbes,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:y.dithering,shadowMapEnabled:l.shadowMap.enabled&&Y.length>0,shadowMapType:l.shadowMap.type,toneMapping:ne,decodeVideoTexture:le&&y.map.isVideoTexture===!0&&kt.getTransfer(y.map.colorSpace)===Qt,decodeVideoTextureEmissive:Ot&&y.emissiveMap.isVideoTexture===!0&&kt.getTransfer(y.emissiveMap.colorSpace)===Qt,premultipliedAlpha:y.premultipliedAlpha,doubleSided:y.side===qe,flipSided:y.side===ye,useDepthPacking:y.depthPacking>=0,depthPacking:y.depthPacking||0,index0AttributeName:y.index0AttributeName,extensionClipCullDistance:Yt&&y.extensions.clipCullDistance===!0&&n.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(Yt&&y.extensions.multiDraw===!0||Mt)&&n.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:n.has("KHR_parallel_shader_compile"),customProgramCacheKey:y.customProgramCacheKey()};return We.vertexUv1s=o.has(1),We.vertexUv2s=o.has(2),We.vertexUv3s=o.has(3),o.clear(),We}function u(y){const g=[];if(y.shaderID?g.push(y.shaderID):(g.push(y.customVertexShaderID),g.push(y.customFragmentShaderID)),y.defines!==void 0)for(const Y in y.defines)g.push(Y),g.push(y.defines[Y]);return y.isRawShaderMaterial===!1&&(C(g,y),R(g,y),g.push(l.outputColorSpace)),g.push(y.customProgramCacheKey),g.join()}function C(y,g){y.push(g.precision),y.push(g.outputColorSpace),y.push(g.envMapMode),y.push(g.envMapCubeUVHeight),y.push(g.mapUv),y.push(g.alphaMapUv),y.push(g.lightMapUv),y.push(g.aoMapUv),y.push(g.bumpMapUv),y.push(g.normalMapUv),y.push(g.displacementMapUv),y.push(g.emissiveMapUv),y.push(g.metalnessMapUv),y.push(g.roughnessMapUv),y.push(g.anisotropyMapUv),y.push(g.clearcoatMapUv),y.push(g.clearcoatNormalMapUv),y.push(g.clearcoatRoughnessMapUv),y.push(g.iridescenceMapUv),y.push(g.iridescenceThicknessMapUv),y.push(g.sheenColorMapUv),y.push(g.sheenRoughnessMapUv),y.push(g.specularMapUv),y.push(g.specularColorMapUv),y.push(g.specularIntensityMapUv),y.push(g.transmissionMapUv),y.push(g.thicknessMapUv),y.push(g.combine),y.push(g.fogExp2),y.push(g.sizeAttenuation),y.push(g.morphTargetsCount),y.push(g.morphAttributeCount),y.push(g.numDirLights),y.push(g.numPointLights),y.push(g.numSpotLights),y.push(g.numSpotLightMaps),y.push(g.numHemiLights),y.push(g.numRectAreaLights),y.push(g.numDirLightShadows),y.push(g.numPointLightShadows),y.push(g.numSpotLightShadows),y.push(g.numSpotLightShadowsWithMaps),y.push(g.numLightProbes),y.push(g.shadowMapType),y.push(g.toneMapping),y.push(g.numClippingPlanes),y.push(g.numClipIntersection),y.push(g.depthPacking)}function R(y,g){d.disableAll(),g.supportsVertexTextures&&d.enable(0),g.instancing&&d.enable(1),g.instancingColor&&d.enable(2),g.instancingMorph&&d.enable(3),g.matcap&&d.enable(4),g.envMap&&d.enable(5),g.normalMapObjectSpace&&d.enable(6),g.normalMapTangentSpace&&d.enable(7),g.clearcoat&&d.enable(8),g.iridescence&&d.enable(9),g.alphaTest&&d.enable(10),g.vertexColors&&d.enable(11),g.vertexAlphas&&d.enable(12),g.vertexUv1s&&d.enable(13),g.vertexUv2s&&d.enable(14),g.vertexUv3s&&d.enable(15),g.vertexTangents&&d.enable(16),g.anisotropy&&d.enable(17),g.alphaHash&&d.enable(18),g.batching&&d.enable(19),g.dispersion&&d.enable(20),g.batchingColor&&d.enable(21),y.push(d.mask),d.disableAll(),g.fog&&d.enable(0),g.useFog&&d.enable(1),g.flatShading&&d.enable(2),g.logarithmicDepthBuffer&&d.enable(3),g.reverseDepthBuffer&&d.enable(4),g.skinning&&d.enable(5),g.morphTargets&&d.enable(6),g.morphNormals&&d.enable(7),g.morphColors&&d.enable(8),g.premultipliedAlpha&&d.enable(9),g.shadowMapEnabled&&d.enable(10),g.doubleSided&&d.enable(11),g.flipSided&&d.enable(12),g.useDepthPacking&&d.enable(13),g.dithering&&d.enable(14),g.transmission&&d.enable(15),g.sheen&&d.enable(16),g.opaque&&d.enable(17),g.pointsUvs&&d.enable(18),g.decodeVideoTexture&&d.enable(19),g.decodeVideoTextureEmissive&&d.enable(20),g.alphaToCoverage&&d.enable(21),y.push(d.mask)}function G(y){const g=p[y.type];let Y;if(g){const Q=je[g];Y=Po.clone(Q.uniforms)}else Y=y.uniforms;return Y}function N(y,g){let Y;for(let Q=0,w=Z.length;Q<w;Q++){const E=Z[Q];if(E.cacheKey===g){Y=E,++Y.usedTimes;break}}return Y===void 0&&(Y=new Iu(l,g,y,s),Z.push(Y)),Y}function I(y){if(--y.usedTimes===0){const g=Z.indexOf(y);Z[g]=Z[Z.length-1],Z.pop(),y.destroy()}}function x(y){c.remove(y)}function M(){c.dispose()}return{getParameters:r,getProgramCacheKey:u,getUniforms:G,acquireProgram:N,releaseProgram:I,releaseShaderCache:x,programs:Z,dispose:M}}function Fu(){let l=new WeakMap;function t(a){return l.has(a)}function e(a){let d=l.get(a);return d===void 0&&(d={},l.set(a,d)),d}function n(a){l.delete(a)}function i(a,d,c){l.get(a)[d]=c}function s(){l=new WeakMap}return{has:t,get:e,remove:n,update:i,dispose:s}}function Lu(l,t){return l.groupOrder!==t.groupOrder?l.groupOrder-t.groupOrder:l.renderOrder!==t.renderOrder?l.renderOrder-t.renderOrder:l.material.id!==t.material.id?l.material.id-t.material.id:l.z!==t.z?l.z-t.z:l.id-t.id}function Td(l,t){return l.groupOrder!==t.groupOrder?l.groupOrder-t.groupOrder:l.renderOrder!==t.renderOrder?l.renderOrder-t.renderOrder:l.z!==t.z?t.z-l.z:l.id-t.id}function vd(){const l=[];let t=0;const e=[],n=[],i=[];function s(){t=0,e.length=0,n.length=0,i.length=0}function a(m,b,h,p,V,r){let u=l[t];return u===void 0?(u={id:m.id,object:m,geometry:b,material:h,groupOrder:p,renderOrder:m.renderOrder,z:V,group:r},l[t]=u):(u.id=m.id,u.object=m,u.geometry=b,u.material=h,u.groupOrder=p,u.renderOrder=m.renderOrder,u.z=V,u.group=r),t++,u}function d(m,b,h,p,V,r){const u=a(m,b,h,p,V,r);h.transmission>0?n.push(u):h.transparent===!0?i.push(u):e.push(u)}function c(m,b,h,p,V,r){const u=a(m,b,h,p,V,r);h.transmission>0?n.unshift(u):h.transparent===!0?i.unshift(u):e.unshift(u)}function o(m,b){e.length>1&&e.sort(m||Lu),n.length>1&&n.sort(b||Td),i.length>1&&i.sort(b||Td)}function Z(){for(let m=t,b=l.length;m<b;m++){const h=l[m];if(h.id===null)break;h.id=null,h.object=null,h.geometry=null,h.material=null,h.group=null}}return{opaque:e,transmissive:n,transparent:i,init:s,push:d,unshift:c,finish:Z,sort:o}}function Uu(){let l=new WeakMap;function t(n,i){const s=l.get(n);let a;return s===void 0?(a=new vd,l.set(n,[a])):i>=s.length?(a=new vd,s.push(a)):a=s[i],a}function e(){l=new WeakMap}return{get:t,dispose:e}}function Mu(){const l={};return{get:function(t){if(l[t.id]!==void 0)return l[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new J,color:new Kt};break;case"SpotLight":e={position:new J,direction:new J,color:new Kt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new J,color:new Kt,distance:0,decay:0};break;case"HemisphereLight":e={direction:new J,skyColor:new Kt,groundColor:new Kt};break;case"RectAreaLight":e={color:new Kt,position:new J,halfWidth:new J,halfHeight:new J};break}return l[t.id]=e,e}}}function Tu(){const l={};return{get:function(t){if(l[t.id]!==void 0)return l[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ft};break;case"SpotLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ft};break;case"PointLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ft,shadowCameraNear:1,shadowCameraFar:1e3};break}return l[t.id]=e,e}}}let vu=0;function Ju(l,t){return(t.castShadow?2:0)-(l.castShadow?2:0)+(t.map?1:0)-(l.map?1:0)}function ku(l){const t=new Mu,e=Tu(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let o=0;o<9;o++)n.probe.push(new J);const i=new J,s=new ae,a=new ae;function d(o){let Z=0,m=0,b=0;for(let y=0;y<9;y++)n.probe[y].set(0,0,0);let h=0,p=0,V=0,r=0,u=0,C=0,R=0,G=0,N=0,I=0,x=0;o.sort(Ju);for(let y=0,g=o.length;y<g;y++){const Y=o[y],Q=Y.color,w=Y.intensity,E=Y.distance,D=Y.shadow&&Y.shadow.map?Y.shadow.map.texture:null;if(Y.isAmbientLight)Z+=Q.r*w,m+=Q.g*w,b+=Q.b*w;else if(Y.isLightProbe){for(let K=0;K<9;K++)n.probe[K].addScaledVector(Y.sh.coefficients[K],w);x++}else if(Y.isDirectionalLight){const K=t.get(Y);if(K.color.copy(Y.color).multiplyScalar(Y.intensity),Y.castShadow){const $=Y.shadow,z=e.get(Y);z.shadowIntensity=$.intensity,z.shadowBias=$.bias,z.shadowNormalBias=$.normalBias,z.shadowRadius=$.radius,z.shadowMapSize=$.mapSize,n.directionalShadow[h]=z,n.directionalShadowMap[h]=D,n.directionalShadowMatrix[h]=Y.shadow.matrix,C++}n.directional[h]=K,h++}else if(Y.isSpotLight){const K=t.get(Y);K.position.setFromMatrixPosition(Y.matrixWorld),K.color.copy(Q).multiplyScalar(w),K.distance=E,K.coneCos=Math.cos(Y.angle),K.penumbraCos=Math.cos(Y.angle*(1-Y.penumbra)),K.decay=Y.decay,n.spot[V]=K;const $=Y.shadow;if(Y.map&&(n.spotLightMap[N]=Y.map,N++,$.updateMatrices(Y),Y.castShadow&&I++),n.spotLightMatrix[V]=$.matrix,Y.castShadow){const z=e.get(Y);z.shadowIntensity=$.intensity,z.shadowBias=$.bias,z.shadowNormalBias=$.normalBias,z.shadowRadius=$.radius,z.shadowMapSize=$.mapSize,n.spotShadow[V]=z,n.spotShadowMap[V]=D,G++}V++}else if(Y.isRectAreaLight){const K=t.get(Y);K.color.copy(Q).multiplyScalar(w),K.halfWidth.set(Y.width*.5,0,0),K.halfHeight.set(0,Y.height*.5,0),n.rectArea[r]=K,r++}else if(Y.isPointLight){const K=t.get(Y);if(K.color.copy(Y.color).multiplyScalar(Y.intensity),K.distance=Y.distance,K.decay=Y.decay,Y.castShadow){const $=Y.shadow,z=e.get(Y);z.shadowIntensity=$.intensity,z.shadowBias=$.bias,z.shadowNormalBias=$.normalBias,z.shadowRadius=$.radius,z.shadowMapSize=$.mapSize,z.shadowCameraNear=$.camera.near,z.shadowCameraFar=$.camera.far,n.pointShadow[p]=z,n.pointShadowMap[p]=D,n.pointShadowMatrix[p]=Y.shadow.matrix,R++}n.point[p]=K,p++}else if(Y.isHemisphereLight){const K=t.get(Y);K.skyColor.copy(Y.color).multiplyScalar(w),K.groundColor.copy(Y.groundColor).multiplyScalar(w),n.hemi[u]=K,u++}}r>0&&(l.has("OES_texture_float_linear")===!0?(n.rectAreaLTC1=et.LTC_FLOAT_1,n.rectAreaLTC2=et.LTC_FLOAT_2):(n.rectAreaLTC1=et.LTC_HALF_1,n.rectAreaLTC2=et.LTC_HALF_2)),n.ambient[0]=Z,n.ambient[1]=m,n.ambient[2]=b;const M=n.hash;(M.directionalLength!==h||M.pointLength!==p||M.spotLength!==V||M.rectAreaLength!==r||M.hemiLength!==u||M.numDirectionalShadows!==C||M.numPointShadows!==R||M.numSpotShadows!==G||M.numSpotMaps!==N||M.numLightProbes!==x)&&(n.directional.length=h,n.spot.length=V,n.rectArea.length=r,n.point.length=p,n.hemi.length=u,n.directionalShadow.length=C,n.directionalShadowMap.length=C,n.pointShadow.length=R,n.pointShadowMap.length=R,n.spotShadow.length=G,n.spotShadowMap.length=G,n.directionalShadowMatrix.length=C,n.pointShadowMatrix.length=R,n.spotLightMatrix.length=G+N-I,n.spotLightMap.length=N,n.numSpotLightShadowsWithMaps=I,n.numLightProbes=x,M.directionalLength=h,M.pointLength=p,M.spotLength=V,M.rectAreaLength=r,M.hemiLength=u,M.numDirectionalShadows=C,M.numPointShadows=R,M.numSpotShadows=G,M.numSpotMaps=N,M.numLightProbes=x,n.version=vu++)}function c(o,Z){let m=0,b=0,h=0,p=0,V=0;const r=Z.matrixWorldInverse;for(let u=0,C=o.length;u<C;u++){const R=o[u];if(R.isDirectionalLight){const G=n.directional[m];G.direction.setFromMatrixPosition(R.matrixWorld),i.setFromMatrixPosition(R.target.matrixWorld),G.direction.sub(i),G.direction.transformDirection(r),m++}else if(R.isSpotLight){const G=n.spot[h];G.position.setFromMatrixPosition(R.matrixWorld),G.position.applyMatrix4(r),G.direction.setFromMatrixPosition(R.matrixWorld),i.setFromMatrixPosition(R.target.matrixWorld),G.direction.sub(i),G.direction.transformDirection(r),h++}else if(R.isRectAreaLight){const G=n.rectArea[p];G.position.setFromMatrixPosition(R.matrixWorld),G.position.applyMatrix4(r),a.identity(),s.copy(R.matrixWorld),s.premultiply(r),a.extractRotation(s),G.halfWidth.set(R.width*.5,0,0),G.halfHeight.set(0,R.height*.5,0),G.halfWidth.applyMatrix4(a),G.halfHeight.applyMatrix4(a),p++}else if(R.isPointLight){const G=n.point[b];G.position.setFromMatrixPosition(R.matrixWorld),G.position.applyMatrix4(r),b++}else if(R.isHemisphereLight){const G=n.hemi[V];G.direction.setFromMatrixPosition(R.matrixWorld),G.direction.transformDirection(r),V++}}}return{setup:d,setupView:c,state:n}}function Jd(l){const t=new ku(l),e=[],n=[];function i(Z){o.camera=Z,e.length=0,n.length=0}function s(Z){e.push(Z)}function a(Z){n.push(Z)}function d(){t.setup(e)}function c(Z){t.setupView(e,Z)}const o={lightsArray:e,shadowsArray:n,camera:null,lights:t,transmissionRenderTarget:{}};return{init:i,state:o,setupLights:d,setupLightsView:c,pushLight:s,pushShadow:a}}function wu(l){let t=new WeakMap;function e(i,s=0){const a=t.get(i);let d;return a===void 0?(d=new Jd(l),t.set(i,[d])):s>=a.length?(d=new Jd(l),a.push(d)):d=a[s],d}function n(){t=new WeakMap}return{get:e,dispose:n}}class Hu extends Yn{static get type(){return"MeshDepthMaterial"}constructor(t){super(),this.isMeshDepthMaterial=!0,this.depthPacking=$c,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class zu extends Yn{static get type(){return"MeshDistanceMaterial"}constructor(t){super(),this.isMeshDistanceMaterial=!0,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}const Ku=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,Bu=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function Eu(l,t,e){let n=new dd;const i=new ft,s=new ft,a=new ie,d=new Hu({depthPacking:to}),c=new zu,o={},Z=e.maxTextureSize,m={[ml]:ye,[ye]:ml,[qe]:qe},b=new ce({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new ft},radius:{value:4}},vertexShader:Ku,fragmentShader:Bu}),h=b.clone();h.defines.HORIZONTAL_PASS=1;const p=new Me;p.setAttribute("position",new Se(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const V=new ee(p,b),r=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=ms;let u=this.type;this.render=function(I,x,M){if(r.enabled===!1||r.autoUpdate===!1&&r.needsUpdate===!1||I.length===0)return;const y=l.getRenderTarget(),g=l.getActiveCubeFace(),Y=l.getActiveMipmapLevel(),Q=l.state;Q.setBlending(Zl),Q.buffers.color.setClear(1,1,1,1),Q.buffers.depth.setTest(!0),Q.setScissorTest(!1);const w=u!==Oe&&this.type===Oe,E=u===Oe&&this.type!==Oe;for(let D=0,K=I.length;D<K;D++){const $=I[D],z=$.shadow;if(z===void 0){console.warn("THREE.WebGLShadowMap:",$,"has no shadow.");continue}if(z.autoUpdate===!1&&z.needsUpdate===!1)continue;i.copy(z.mapSize);const nt=z.getFrameExtents();if(i.multiply(nt),s.copy(z.mapSize),(i.x>Z||i.y>Z)&&(i.x>Z&&(s.x=Math.floor(Z/nt.x),i.x=s.x*nt.x,z.mapSize.x=s.x),i.y>Z&&(s.y=Math.floor(Z/nt.y),i.y=s.y*nt.y,z.mapSize.y=s.y)),z.map===null||w===!0||E===!0){const Vt=this.type!==Oe?{minFilter:Je,magFilter:Je}:{};z.map!==null&&z.map.dispose(),z.map=new bl(i.x,i.y,Vt),z.map.texture.name=$.name+".shadowMap",z.camera.updateProjectionMatrix()}l.setRenderTarget(z.map),l.clear();const ot=z.getViewportCount();for(let Vt=0;Vt<ot;Vt++){const Ut=z.getViewport(Vt);a.set(s.x*Ut.x,s.y*Ut.y,s.x*Ut.z,s.y*Ut.w),Q.viewport(a),z.updateMatrices($,Vt),n=z.getFrustum(),G(x,M,z.camera,$,this.type)}z.isPointLightShadow!==!0&&this.type===Oe&&C(z,M),z.needsUpdate=!1}u=this.type,r.needsUpdate=!1,l.setRenderTarget(y,g,Y)};function C(I,x){const M=t.update(V);b.defines.VSM_SAMPLES!==I.blurSamples&&(b.defines.VSM_SAMPLES=I.blurSamples,h.defines.VSM_SAMPLES=I.blurSamples,b.needsUpdate=!0,h.needsUpdate=!0),I.mapPass===null&&(I.mapPass=new bl(i.x,i.y)),b.uniforms.shadow_pass.value=I.map.texture,b.uniforms.resolution.value=I.mapSize,b.uniforms.radius.value=I.radius,l.setRenderTarget(I.mapPass),l.clear(),l.renderBufferDirect(x,null,M,b,V,null),h.uniforms.shadow_pass.value=I.mapPass.texture,h.uniforms.resolution.value=I.mapSize,h.uniforms.radius.value=I.radius,l.setRenderTarget(I.map),l.clear(),l.renderBufferDirect(x,null,M,h,V,null)}function R(I,x,M,y){let g=null;const Y=M.isPointLight===!0?I.customDistanceMaterial:I.customDepthMaterial;if(Y!==void 0)g=Y;else if(g=M.isPointLight===!0?c:d,l.localClippingEnabled&&x.clipShadows===!0&&Array.isArray(x.clippingPlanes)&&x.clippingPlanes.length!==0||x.displacementMap&&x.displacementScale!==0||x.alphaMap&&x.alphaTest>0||x.map&&x.alphaTest>0){const Q=g.uuid,w=x.uuid;let E=o[Q];E===void 0&&(E={},o[Q]=E);let D=E[w];D===void 0&&(D=g.clone(),E[w]=D,x.addEventListener("dispose",N)),g=D}if(g.visible=x.visible,g.wireframe=x.wireframe,y===Oe?g.side=x.shadowSide!==null?x.shadowSide:x.side:g.side=x.shadowSide!==null?x.shadowSide:m[x.side],g.alphaMap=x.alphaMap,g.alphaTest=x.alphaTest,g.map=x.map,g.clipShadows=x.clipShadows,g.clippingPlanes=x.clippingPlanes,g.clipIntersection=x.clipIntersection,g.displacementMap=x.displacementMap,g.displacementScale=x.displacementScale,g.displacementBias=x.displacementBias,g.wireframeLinewidth=x.wireframeLinewidth,g.linewidth=x.linewidth,M.isPointLight===!0&&g.isMeshDistanceMaterial===!0){const Q=l.properties.get(g);Q.light=M}return g}function G(I,x,M,y,g){if(I.visible===!1)return;if(I.layers.test(x.layers)&&(I.isMesh||I.isLine||I.isPoints)&&(I.castShadow||I.receiveShadow&&g===Oe)&&(!I.frustumCulled||n.intersectsObject(I))){I.modelViewMatrix.multiplyMatrices(M.matrixWorldInverse,I.matrixWorld);const w=t.update(I),E=I.material;if(Array.isArray(E)){const D=w.groups;for(let K=0,$=D.length;K<$;K++){const z=D[K],nt=E[z.materialIndex];if(nt&&nt.visible){const ot=R(I,nt,y,g);I.onBeforeShadow(l,I,x,M,w,ot,z),l.renderBufferDirect(M,null,w,ot,I,z),I.onAfterShadow(l,I,x,M,w,ot,z)}}}else if(E.visible){const D=R(I,E,y,g);I.onBeforeShadow(l,I,x,M,w,D,null),l.renderBufferDirect(M,null,w,D,I,null),I.onAfterShadow(l,I,x,M,w,D,null)}}const Q=I.children;for(let w=0,E=Q.length;w<E;w++)G(Q[w],x,M,y,g)}function N(I){I.target.removeEventListener("dispose",N);for(const M in o){const y=o[M],g=I.target.uuid;g in y&&(y[g].dispose(),delete y[g])}}}const Au={[fi]:Fi,[Li]:Ti,[Ui]:vi,[Hl]:Mi,[Fi]:fi,[Ti]:Li,[vi]:Ui,[Mi]:Hl};function Qu(l,t){function e(){let f=!1;const lt=new ie;let H=null;const j=new ie(0,0,0,0);return{setMask:function(ct){H!==ct&&!f&&(l.colorMask(ct,ct,ct,ct),H=ct)},setLocked:function(ct){f=ct},setClear:function(ct,st,Yt,ne,We){We===!0&&(ct*=ne,st*=ne,Yt*=ne),lt.set(ct,st,Yt,ne),j.equals(lt)===!1&&(l.clearColor(ct,st,Yt,ne),j.copy(lt))},reset:function(){f=!1,H=null,j.set(-1,0,0,0)}}}function n(){let f=!1,lt=!1,H=null,j=null,ct=null;return{setReversed:function(st){if(lt!==st){const Yt=t.get("EXT_clip_control");lt?Yt.clipControlEXT(Yt.LOWER_LEFT_EXT,Yt.ZERO_TO_ONE_EXT):Yt.clipControlEXT(Yt.LOWER_LEFT_EXT,Yt.NEGATIVE_ONE_TO_ONE_EXT);const ne=ct;ct=null,this.setClear(ne)}lt=st},getReversed:function(){return lt},setTest:function(st){st?it(l.DEPTH_TEST):yt(l.DEPTH_TEST)},setMask:function(st){H!==st&&!f&&(l.depthMask(st),H=st)},setFunc:function(st){if(lt&&(st=Au[st]),j!==st){switch(st){case fi:l.depthFunc(l.NEVER);break;case Fi:l.depthFunc(l.ALWAYS);break;case Li:l.depthFunc(l.LESS);break;case Hl:l.depthFunc(l.LEQUAL);break;case Ui:l.depthFunc(l.EQUAL);break;case Mi:l.depthFunc(l.GEQUAL);break;case Ti:l.depthFunc(l.GREATER);break;case vi:l.depthFunc(l.NOTEQUAL);break;default:l.depthFunc(l.LEQUAL)}j=st}},setLocked:function(st){f=st},setClear:function(st){ct!==st&&(lt&&(st=1-st),l.clearDepth(st),ct=st)},reset:function(){f=!1,H=null,j=null,ct=null,lt=!1}}}function i(){let f=!1,lt=null,H=null,j=null,ct=null,st=null,Yt=null,ne=null,We=null;return{setTest:function(At){f||(At?it(l.STENCIL_TEST):yt(l.STENCIL_TEST))},setMask:function(At){lt!==At&&!f&&(l.stencilMask(At),lt=At)},setFunc:function(At,Ee,cl){(H!==At||j!==Ee||ct!==cl)&&(l.stencilFunc(At,Ee,cl),H=At,j=Ee,ct=cl)},setOp:function(At,Ee,cl){(st!==At||Yt!==Ee||ne!==cl)&&(l.stencilOp(At,Ee,cl),st=At,Yt=Ee,ne=cl)},setLocked:function(At){f=At},setClear:function(At){We!==At&&(l.clearStencil(At),We=At)},reset:function(){f=!1,lt=null,H=null,j=null,ct=null,st=null,Yt=null,ne=null,We=null}}}const s=new e,a=new n,d=new i,c=new WeakMap,o=new WeakMap;let Z={},m={},b=new WeakMap,h=[],p=null,V=!1,r=null,u=null,C=null,R=null,G=null,N=null,I=null,x=new Kt(0,0,0),M=0,y=!1,g=null,Y=null,Q=null,w=null,E=null;const D=l.getParameter(l.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let K=!1,$=0;const z=l.getParameter(l.VERSION);z.indexOf("WebGL")!==-1?($=parseFloat(/^WebGL (\d)/.exec(z)[1]),K=$>=1):z.indexOf("OpenGL ES")!==-1&&($=parseFloat(/^OpenGL ES (\d)/.exec(z)[1]),K=$>=2);let nt=null,ot={};const Vt=l.getParameter(l.SCISSOR_BOX),Ut=l.getParameter(l.VIEWPORT),Pt=new ie().fromArray(Vt),A=new ie().fromArray(Ut);function tt(f,lt,H,j){const ct=new Uint8Array(4),st=l.createTexture();l.bindTexture(f,st),l.texParameteri(f,l.TEXTURE_MIN_FILTER,l.NEAREST),l.texParameteri(f,l.TEXTURE_MAG_FILTER,l.NEAREST);for(let Yt=0;Yt<H;Yt++)f===l.TEXTURE_3D||f===l.TEXTURE_2D_ARRAY?l.texImage3D(lt,0,l.RGBA,1,1,j,0,l.RGBA,l.UNSIGNED_BYTE,ct):l.texImage2D(lt+Yt,0,l.RGBA,1,1,0,l.RGBA,l.UNSIGNED_BYTE,ct);return st}const pt={};pt[l.TEXTURE_2D]=tt(l.TEXTURE_2D,l.TEXTURE_2D,1),pt[l.TEXTURE_CUBE_MAP]=tt(l.TEXTURE_CUBE_MAP,l.TEXTURE_CUBE_MAP_POSITIVE_X,6),pt[l.TEXTURE_2D_ARRAY]=tt(l.TEXTURE_2D_ARRAY,l.TEXTURE_2D_ARRAY,1,1),pt[l.TEXTURE_3D]=tt(l.TEXTURE_3D,l.TEXTURE_3D,1,1),s.setClear(0,0,0,1),a.setClear(1),d.setClear(0),it(l.DEPTH_TEST),a.setFunc(Hl),Tt(!1),vt(os),it(l.CULL_FACE),U(Zl);function it(f){Z[f]!==!0&&(l.enable(f),Z[f]=!0)}function yt(f){Z[f]!==!1&&(l.disable(f),Z[f]=!1)}function It(f,lt){return m[f]!==lt?(l.bindFramebuffer(f,lt),m[f]=lt,f===l.DRAW_FRAMEBUFFER&&(m[l.FRAMEBUFFER]=lt),f===l.FRAMEBUFFER&&(m[l.DRAW_FRAMEBUFFER]=lt),!0):!1}function Mt(f,lt){let H=h,j=!1;if(f){H=b.get(lt),H===void 0&&(H=[],b.set(lt,H));const ct=f.textures;if(H.length!==ct.length||H[0]!==l.COLOR_ATTACHMENT0){for(let st=0,Yt=ct.length;st<Yt;st++)H[st]=l.COLOR_ATTACHMENT0+st;H.length=ct.length,j=!0}}else H[0]!==l.BACK&&(H[0]=l.BACK,j=!0);j&&l.drawBuffers(H)}function le(f){return p!==f?(l.useProgram(f),p=f,!0):!1}const wt={[Sl]:l.FUNC_ADD,[Ic]:l.FUNC_SUBTRACT,[xc]:l.FUNC_REVERSE_SUBTRACT};wt[Yc]=l.MIN,wt[Nc]=l.MAX;const se={[fc]:l.ZERO,[Fc]:l.ONE,[Lc]:l.SRC_COLOR,[Yi]:l.SRC_ALPHA,[kc]:l.SRC_ALPHA_SATURATE,[vc]:l.DST_COLOR,[Mc]:l.DST_ALPHA,[Uc]:l.ONE_MINUS_SRC_COLOR,[Ni]:l.ONE_MINUS_SRC_ALPHA,[Jc]:l.ONE_MINUS_DST_COLOR,[Tc]:l.ONE_MINUS_DST_ALPHA,[wc]:l.CONSTANT_COLOR,[Hc]:l.ONE_MINUS_CONSTANT_COLOR,[zc]:l.CONSTANT_ALPHA,[Kc]:l.ONE_MINUS_CONSTANT_ALPHA};function U(f,lt,H,j,ct,st,Yt,ne,We,At){if(f===Zl){V===!0&&(yt(l.BLEND),V=!1);return}if(V===!1&&(it(l.BLEND),V=!0),f!==Sc){if(f!==r||At!==y){if((u!==Sl||G!==Sl)&&(l.blendEquation(l.FUNC_ADD),u=Sl,G=Sl),At)switch(f){case Qe:l.blendFuncSeparate(l.ONE,l.ONE_MINUS_SRC_ALPHA,l.ONE,l.ONE_MINUS_SRC_ALPHA);break;case fe:l.blendFunc(l.ONE,l.ONE);break;case Zs:l.blendFuncSeparate(l.ZERO,l.ONE_MINUS_SRC_COLOR,l.ZERO,l.ONE);break;case hs:l.blendFuncSeparate(l.ZERO,l.SRC_COLOR,l.ZERO,l.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",f);break}else switch(f){case Qe:l.blendFuncSeparate(l.SRC_ALPHA,l.ONE_MINUS_SRC_ALPHA,l.ONE,l.ONE_MINUS_SRC_ALPHA);break;case fe:l.blendFunc(l.SRC_ALPHA,l.ONE);break;case Zs:l.blendFuncSeparate(l.ZERO,l.ONE_MINUS_SRC_COLOR,l.ZERO,l.ONE);break;case hs:l.blendFunc(l.ZERO,l.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",f);break}C=null,R=null,N=null,I=null,x.set(0,0,0),M=0,r=f,y=At}return}ct=ct||lt,st=st||H,Yt=Yt||j,(lt!==u||ct!==G)&&(l.blendEquationSeparate(wt[lt],wt[ct]),u=lt,G=ct),(H!==C||j!==R||st!==N||Yt!==I)&&(l.blendFuncSeparate(se[H],se[j],se[st],se[Yt]),C=H,R=j,N=st,I=Yt),(ne.equals(x)===!1||We!==M)&&(l.blendColor(ne.r,ne.g,ne.b,We),x.copy(ne),M=We),r=f,y=!1}function Te(f,lt){f.side===qe?yt(l.CULL_FACE):it(l.CULL_FACE);let H=f.side===ye;lt&&(H=!H),Tt(H),f.blending===Qe&&f.transparent===!1?U(Zl):U(f.blending,f.blendEquation,f.blendSrc,f.blendDst,f.blendEquationAlpha,f.blendSrcAlpha,f.blendDstAlpha,f.blendColor,f.blendAlpha,f.premultipliedAlpha),a.setFunc(f.depthFunc),a.setTest(f.depthTest),a.setMask(f.depthWrite),s.setMask(f.colorWrite);const j=f.stencilWrite;d.setTest(j),j&&(d.setMask(f.stencilWriteMask),d.setFunc(f.stencilFunc,f.stencilRef,f.stencilFuncMask),d.setOp(f.stencilFail,f.stencilZFail,f.stencilZPass)),Ot(f.polygonOffset,f.polygonOffsetFactor,f.polygonOffsetUnits),f.alphaToCoverage===!0?it(l.SAMPLE_ALPHA_TO_COVERAGE):yt(l.SAMPLE_ALPHA_TO_COVERAGE)}function Tt(f){g!==f&&(f?l.frontFace(l.CW):l.frontFace(l.CCW),g=f)}function vt(f){f!==Rc?(it(l.CULL_FACE),f!==Y&&(f===os?l.cullFace(l.BACK):f===yc?l.cullFace(l.FRONT):l.cullFace(l.FRONT_AND_BACK))):yt(l.CULL_FACE),Y=f}function gt(f){f!==Q&&(K&&l.lineWidth(f),Q=f)}function Ot(f,lt,H){f?(it(l.POLYGON_OFFSET_FILL),(w!==lt||E!==H)&&(l.polygonOffset(lt,H),w=lt,E=H)):yt(l.POLYGON_OFFSET_FILL)}function Xt(f){f?it(l.SCISSOR_TEST):yt(l.SCISSOR_TEST)}function S(f){f===void 0&&(f=l.TEXTURE0+D-1),nt!==f&&(l.activeTexture(f),nt=f)}function W(f,lt,H){H===void 0&&(nt===null?H=l.TEXTURE0+D-1:H=nt);let j=ot[H];j===void 0&&(j={type:void 0,texture:void 0},ot[H]=j),(j.type!==f||j.texture!==lt)&&(nt!==H&&(l.activeTexture(H),nt=H),l.bindTexture(f,lt||pt[f]),j.type=f,j.texture=lt)}function T(){const f=ot[nt];f!==void 0&&f.type!==void 0&&(l.bindTexture(f.type,null),f.type=void 0,f.texture=void 0)}function P(){try{l.compressedTexImage2D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function _(){try{l.compressedTexImage3D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function B(){try{l.texSubImage2D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function Gt(){try{l.texSubImage3D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function at(){try{l.compressedTexSubImage2D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function mt(){try{l.compressedTexSubImage3D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function Ht(){try{l.texStorage2D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function O(){try{l.texStorage3D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function Zt(){try{l.texImage2D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function Rt(){try{l.texImage3D.apply(l,arguments)}catch(f){console.error("THREE.WebGLState:",f)}}function Ct(f){Pt.equals(f)===!1&&(l.scissor(f.x,f.y,f.z,f.w),Pt.copy(f))}function ht(f){A.equals(f)===!1&&(l.viewport(f.x,f.y,f.z,f.w),A.copy(f))}function Jt(f,lt){let H=o.get(lt);H===void 0&&(H=new WeakMap,o.set(lt,H));let j=H.get(f);j===void 0&&(j=l.getUniformBlockIndex(lt,f.name),H.set(f,j))}function Lt(f,lt){const j=o.get(lt).get(f);c.get(lt)!==j&&(l.uniformBlockBinding(lt,j,f.__bindingPointIndex),c.set(lt,j))}function _t(){l.disable(l.BLEND),l.disable(l.CULL_FACE),l.disable(l.DEPTH_TEST),l.disable(l.POLYGON_OFFSET_FILL),l.disable(l.SCISSOR_TEST),l.disable(l.STENCIL_TEST),l.disable(l.SAMPLE_ALPHA_TO_COVERAGE),l.blendEquation(l.FUNC_ADD),l.blendFunc(l.ONE,l.ZERO),l.blendFuncSeparate(l.ONE,l.ZERO,l.ONE,l.ZERO),l.blendColor(0,0,0,0),l.colorMask(!0,!0,!0,!0),l.clearColor(0,0,0,0),l.depthMask(!0),l.depthFunc(l.LESS),a.setReversed(!1),l.clearDepth(1),l.stencilMask(4294967295),l.stencilFunc(l.ALWAYS,0,4294967295),l.stencilOp(l.KEEP,l.KEEP,l.KEEP),l.clearStencil(0),l.cullFace(l.BACK),l.frontFace(l.CCW),l.polygonOffset(0,0),l.activeTexture(l.TEXTURE0),l.bindFramebuffer(l.FRAMEBUFFER,null),l.bindFramebuffer(l.DRAW_FRAMEBUFFER,null),l.bindFramebuffer(l.READ_FRAMEBUFFER,null),l.useProgram(null),l.lineWidth(1),l.scissor(0,0,l.canvas.width,l.canvas.height),l.viewport(0,0,l.canvas.width,l.canvas.height),Z={},nt=null,ot={},m={},b=new WeakMap,h=[],p=null,V=!1,r=null,u=null,C=null,R=null,G=null,N=null,I=null,x=new Kt(0,0,0),M=0,y=!1,g=null,Y=null,Q=null,w=null,E=null,Pt.set(0,0,l.canvas.width,l.canvas.height),A.set(0,0,l.canvas.width,l.canvas.height),s.reset(),a.reset(),d.reset()}return{buffers:{color:s,depth:a,stencil:d},enable:it,disable:yt,bindFramebuffer:It,drawBuffers:Mt,useProgram:le,setBlending:U,setMaterial:Te,setFlipSided:Tt,setCullFace:vt,setLineWidth:gt,setPolygonOffset:Ot,setScissorTest:Xt,activeTexture:S,bindTexture:W,unbindTexture:T,compressedTexImage2D:P,compressedTexImage3D:_,texImage2D:Zt,texImage3D:Rt,updateUBOMapping:Jt,uniformBlockBinding:Lt,texStorage2D:Ht,texStorage3D:O,texSubImage2D:B,texSubImage3D:Gt,compressedTexSubImage2D:at,compressedTexSubImage3D:mt,scissor:Ct,viewport:ht,reset:_t}}function kd(l,t,e,n){const i=Pu(n);switch(e){case Ws:return l*t;case Xs:return l*t;case gs:return l*t*2;case Rs:return l*t/i.components*i.byteLength;case Ai:return l*t/i.components*i.byteLength;case ys:return l*t*2/i.components*i.byteLength;case Qi:return l*t*2/i.components*i.byteLength;case Vs:return l*t*3/i.components*i.byteLength;case Fe:return l*t*4/i.components*i.byteLength;case Pi:return l*t*4/i.components*i.byteLength;case wn:case Hn:return Math.floor((l+3)/4)*Math.floor((t+3)/4)*8;case zn:case Kn:return Math.floor((l+3)/4)*Math.floor((t+3)/4)*16;case _i:case Oi:return Math.max(l,16)*Math.max(t,8)/4;case ji:case Di:return Math.max(l,8)*Math.max(t,8)/2;case qi:case $i:return Math.floor((l+3)/4)*Math.floor((t+3)/4)*8;case ta:return Math.floor((l+3)/4)*Math.floor((t+3)/4)*16;case ea:return Math.floor((l+3)/4)*Math.floor((t+3)/4)*16;case la:return Math.floor((l+4)/5)*Math.floor((t+3)/4)*16;case na:return Math.floor((l+4)/5)*Math.floor((t+4)/5)*16;case ia:return Math.floor((l+5)/6)*Math.floor((t+4)/5)*16;case aa:return Math.floor((l+5)/6)*Math.floor((t+5)/6)*16;case sa:return Math.floor((l+7)/8)*Math.floor((t+4)/5)*16;case da:return Math.floor((l+7)/8)*Math.floor((t+5)/6)*16;case ca:return Math.floor((l+7)/8)*Math.floor((t+7)/8)*16;case oa:return Math.floor((l+9)/10)*Math.floor((t+4)/5)*16;case ma:return Math.floor((l+9)/10)*Math.floor((t+5)/6)*16;case Za:return Math.floor((l+9)/10)*Math.floor((t+7)/8)*16;case ha:return Math.floor((l+9)/10)*Math.floor((t+9)/10)*16;case ua:return Math.floor((l+11)/12)*Math.floor((t+9)/10)*16;case ba:return Math.floor((l+11)/12)*Math.floor((t+11)/12)*16;case Bn:case ra:case pa:return Math.ceil(l/4)*Math.ceil(t/4)*16;case Cs:case Ga:return Math.ceil(l/4)*Math.ceil(t/4)*8;case Wa:case Va:return Math.ceil(l/4)*Math.ceil(t/4)*16}throw new Error(`Unable to determine texture byte length for ${e} format.`)}function Pu(l){switch(l){case Pe:case rs:return{byteLength:1,components:1};case Gn:case ps:case Wn:return{byteLength:2,components:1};case Bi:case Ei:return{byteLength:2,components:4};case Yl:case Ki:case $e:return{byteLength:4,components:1};case Gs:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${l}.`)}function ju(l,t,e,n,i,s,a){const d=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,c=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),o=new ft,Z=new WeakMap;let m;const b=new WeakMap;let h=!1;try{h=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function p(S,W){return h?new OffscreenCanvas(S,W):Qn("canvas")}function V(S,W,T){let P=1;const _=Xt(S);if((_.width>T||_.height>T)&&(P=T/Math.max(_.width,_.height)),P<1)if(typeof HTMLImageElement<"u"&&S instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&S instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&S instanceof ImageBitmap||typeof VideoFrame<"u"&&S instanceof VideoFrame){const B=Math.floor(P*_.width),Gt=Math.floor(P*_.height);m===void 0&&(m=p(B,Gt));const at=W?p(B,Gt):m;return at.width=B,at.height=Gt,at.getContext("2d").drawImage(S,0,0,B,Gt),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+_.width+"x"+_.height+") to ("+B+"x"+Gt+")."),at}else return"data"in S&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+_.width+"x"+_.height+")."),S;return S}function r(S){return S.generateMipmaps}function u(S){l.generateMipmap(S)}function C(S){return S.isWebGLCubeRenderTarget?l.TEXTURE_CUBE_MAP:S.isWebGL3DRenderTarget?l.TEXTURE_3D:S.isWebGLArrayRenderTarget||S.isCompressedArrayTexture?l.TEXTURE_2D_ARRAY:l.TEXTURE_2D}function R(S,W,T,P,_=!1){if(S!==null){if(l[S]!==void 0)return l[S];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+S+"'")}let B=W;if(W===l.RED&&(T===l.FLOAT&&(B=l.R32F),T===l.HALF_FLOAT&&(B=l.R16F),T===l.UNSIGNED_BYTE&&(B=l.R8)),W===l.RED_INTEGER&&(T===l.UNSIGNED_BYTE&&(B=l.R8UI),T===l.UNSIGNED_SHORT&&(B=l.R16UI),T===l.UNSIGNED_INT&&(B=l.R32UI),T===l.BYTE&&(B=l.R8I),T===l.SHORT&&(B=l.R16I),T===l.INT&&(B=l.R32I)),W===l.RG&&(T===l.FLOAT&&(B=l.RG32F),T===l.HALF_FLOAT&&(B=l.RG16F),T===l.UNSIGNED_BYTE&&(B=l.RG8)),W===l.RG_INTEGER&&(T===l.UNSIGNED_BYTE&&(B=l.RG8UI),T===l.UNSIGNED_SHORT&&(B=l.RG16UI),T===l.UNSIGNED_INT&&(B=l.RG32UI),T===l.BYTE&&(B=l.RG8I),T===l.SHORT&&(B=l.RG16I),T===l.INT&&(B=l.RG32I)),W===l.RGB_INTEGER&&(T===l.UNSIGNED_BYTE&&(B=l.RGB8UI),T===l.UNSIGNED_SHORT&&(B=l.RGB16UI),T===l.UNSIGNED_INT&&(B=l.RGB32UI),T===l.BYTE&&(B=l.RGB8I),T===l.SHORT&&(B=l.RGB16I),T===l.INT&&(B=l.RGB32I)),W===l.RGBA_INTEGER&&(T===l.UNSIGNED_BYTE&&(B=l.RGBA8UI),T===l.UNSIGNED_SHORT&&(B=l.RGBA16UI),T===l.UNSIGNED_INT&&(B=l.RGBA32UI),T===l.BYTE&&(B=l.RGBA8I),T===l.SHORT&&(B=l.RGBA16I),T===l.INT&&(B=l.RGBA32I)),W===l.RGB&&T===l.UNSIGNED_INT_5_9_9_9_REV&&(B=l.RGB9_E5),W===l.RGBA){const Gt=_?En:kt.getTransfer(P);T===l.FLOAT&&(B=l.RGBA32F),T===l.HALF_FLOAT&&(B=l.RGBA16F),T===l.UNSIGNED_BYTE&&(B=Gt===Qt?l.SRGB8_ALPHA8:l.RGBA8),T===l.UNSIGNED_SHORT_4_4_4_4&&(B=l.RGBA4),T===l.UNSIGNED_SHORT_5_5_5_1&&(B=l.RGB5_A1)}return(B===l.R16F||B===l.R32F||B===l.RG16F||B===l.RG32F||B===l.RGBA16F||B===l.RGBA32F)&&t.get("EXT_color_buffer_float"),B}function G(S,W){let T;return S?W===null||W===Yl||W===Bl?T=l.DEPTH24_STENCIL8:W===$e?T=l.DEPTH32F_STENCIL8:W===Gn&&(T=l.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):W===null||W===Yl||W===Bl?T=l.DEPTH_COMPONENT24:W===$e?T=l.DEPTH_COMPONENT32F:W===Gn&&(T=l.DEPTH_COMPONENT16),T}function N(S,W){return r(S)===!0||S.isFramebufferTexture&&S.minFilter!==Je&&S.minFilter!==be?Math.log2(Math.max(W.width,W.height))+1:S.mipmaps!==void 0&&S.mipmaps.length>0?S.mipmaps.length:S.isCompressedTexture&&Array.isArray(S.image)?W.mipmaps.length:1}function I(S){const W=S.target;W.removeEventListener("dispose",I),M(W),W.isVideoTexture&&Z.delete(W)}function x(S){const W=S.target;W.removeEventListener("dispose",x),g(W)}function M(S){const W=n.get(S);if(W.__webglInit===void 0)return;const T=S.source,P=b.get(T);if(P){const _=P[W.__cacheKey];_.usedTimes--,_.usedTimes===0&&y(S),Object.keys(P).length===0&&b.delete(T)}n.remove(S)}function y(S){const W=n.get(S);l.deleteTexture(W.__webglTexture);const T=S.source,P=b.get(T);delete P[W.__cacheKey],a.memory.textures--}function g(S){const W=n.get(S);if(S.depthTexture&&(S.depthTexture.dispose(),n.remove(S.depthTexture)),S.isWebGLCubeRenderTarget)for(let P=0;P<6;P++){if(Array.isArray(W.__webglFramebuffer[P]))for(let _=0;_<W.__webglFramebuffer[P].length;_++)l.deleteFramebuffer(W.__webglFramebuffer[P][_]);else l.deleteFramebuffer(W.__webglFramebuffer[P]);W.__webglDepthbuffer&&l.deleteRenderbuffer(W.__webglDepthbuffer[P])}else{if(Array.isArray(W.__webglFramebuffer))for(let P=0;P<W.__webglFramebuffer.length;P++)l.deleteFramebuffer(W.__webglFramebuffer[P]);else l.deleteFramebuffer(W.__webglFramebuffer);if(W.__webglDepthbuffer&&l.deleteRenderbuffer(W.__webglDepthbuffer),W.__webglMultisampledFramebuffer&&l.deleteFramebuffer(W.__webglMultisampledFramebuffer),W.__webglColorRenderbuffer)for(let P=0;P<W.__webglColorRenderbuffer.length;P++)W.__webglColorRenderbuffer[P]&&l.deleteRenderbuffer(W.__webglColorRenderbuffer[P]);W.__webglDepthRenderbuffer&&l.deleteRenderbuffer(W.__webglDepthRenderbuffer)}const T=S.textures;for(let P=0,_=T.length;P<_;P++){const B=n.get(T[P]);B.__webglTexture&&(l.deleteTexture(B.__webglTexture),a.memory.textures--),n.remove(T[P])}n.remove(S)}let Y=0;function Q(){Y=0}function w(){const S=Y;return S>=i.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+S+" texture units while this GPU supports only "+i.maxTextures),Y+=1,S}function E(S){const W=[];return W.push(S.wrapS),W.push(S.wrapT),W.push(S.wrapR||0),W.push(S.magFilter),W.push(S.minFilter),W.push(S.anisotropy),W.push(S.internalFormat),W.push(S.format),W.push(S.type),W.push(S.generateMipmaps),W.push(S.premultiplyAlpha),W.push(S.flipY),W.push(S.unpackAlignment),W.push(S.colorSpace),W.join()}function D(S,W){const T=n.get(S);if(S.isVideoTexture&&gt(S),S.isRenderTargetTexture===!1&&S.version>0&&T.__version!==S.version){const P=S.image;if(P===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(P.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{A(T,S,W);return}}e.bindTexture(l.TEXTURE_2D,T.__webglTexture,l.TEXTURE0+W)}function K(S,W){const T=n.get(S);if(S.version>0&&T.__version!==S.version){A(T,S,W);return}e.bindTexture(l.TEXTURE_2D_ARRAY,T.__webglTexture,l.TEXTURE0+W)}function $(S,W){const T=n.get(S);if(S.version>0&&T.__version!==S.version){A(T,S,W);return}e.bindTexture(l.TEXTURE_3D,T.__webglTexture,l.TEXTURE0+W)}function z(S,W){const T=n.get(S);if(S.version>0&&T.__version!==S.version){tt(T,S,W);return}e.bindTexture(l.TEXTURE_CUBE_MAP,T.__webglTexture,l.TEXTURE0+W)}const nt={[wi]:l.REPEAT,[Il]:l.CLAMP_TO_EDGE,[Hi]:l.MIRRORED_REPEAT},ot={[Je]:l.NEAREST,[qc]:l.NEAREST_MIPMAP_NEAREST,[kn]:l.NEAREST_MIPMAP_LINEAR,[be]:l.LINEAR,[zi]:l.LINEAR_MIPMAP_NEAREST,[xl]:l.LINEAR_MIPMAP_LINEAR},Vt={[no]:l.NEVER,[mo]:l.ALWAYS,[io]:l.LESS,[Is]:l.LEQUAL,[ao]:l.EQUAL,[oo]:l.GEQUAL,[so]:l.GREATER,[co]:l.NOTEQUAL};function Ut(S,W){if(W.type===$e&&t.has("OES_texture_float_linear")===!1&&(W.magFilter===be||W.magFilter===zi||W.magFilter===kn||W.magFilter===xl||W.minFilter===be||W.minFilter===zi||W.minFilter===kn||W.minFilter===xl)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),l.texParameteri(S,l.TEXTURE_WRAP_S,nt[W.wrapS]),l.texParameteri(S,l.TEXTURE_WRAP_T,nt[W.wrapT]),(S===l.TEXTURE_3D||S===l.TEXTURE_2D_ARRAY)&&l.texParameteri(S,l.TEXTURE_WRAP_R,nt[W.wrapR]),l.texParameteri(S,l.TEXTURE_MAG_FILTER,ot[W.magFilter]),l.texParameteri(S,l.TEXTURE_MIN_FILTER,ot[W.minFilter]),W.compareFunction&&(l.texParameteri(S,l.TEXTURE_COMPARE_MODE,l.COMPARE_REF_TO_TEXTURE),l.texParameteri(S,l.TEXTURE_COMPARE_FUNC,Vt[W.compareFunction])),t.has("EXT_texture_filter_anisotropic")===!0){if(W.magFilter===Je||W.minFilter!==kn&&W.minFilter!==xl||W.type===$e&&t.has("OES_texture_float_linear")===!1)return;if(W.anisotropy>1||n.get(W).__currentAnisotropy){const T=t.get("EXT_texture_filter_anisotropic");l.texParameterf(S,T.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(W.anisotropy,i.getMaxAnisotropy())),n.get(W).__currentAnisotropy=W.anisotropy}}}function Pt(S,W){let T=!1;S.__webglInit===void 0&&(S.__webglInit=!0,W.addEventListener("dispose",I));const P=W.source;let _=b.get(P);_===void 0&&(_={},b.set(P,_));const B=E(W);if(B!==S.__cacheKey){_[B]===void 0&&(_[B]={texture:l.createTexture(),usedTimes:0},a.memory.textures++,T=!0),_[B].usedTimes++;const Gt=_[S.__cacheKey];Gt!==void 0&&(_[S.__cacheKey].usedTimes--,Gt.usedTimes===0&&y(W)),S.__cacheKey=B,S.__webglTexture=_[B].texture}return T}function A(S,W,T){let P=l.TEXTURE_2D;(W.isDataArrayTexture||W.isCompressedArrayTexture)&&(P=l.TEXTURE_2D_ARRAY),W.isData3DTexture&&(P=l.TEXTURE_3D);const _=Pt(S,W),B=W.source;e.bindTexture(P,S.__webglTexture,l.TEXTURE0+T);const Gt=n.get(B);if(B.version!==Gt.__version||_===!0){e.activeTexture(l.TEXTURE0+T);const at=kt.getPrimaries(kt.workingColorSpace),mt=W.colorSpace===ul?null:kt.getPrimaries(W.colorSpace),Ht=W.colorSpace===ul||at===mt?l.NONE:l.BROWSER_DEFAULT_WEBGL;l.pixelStorei(l.UNPACK_FLIP_Y_WEBGL,W.flipY),l.pixelStorei(l.UNPACK_PREMULTIPLY_ALPHA_WEBGL,W.premultiplyAlpha),l.pixelStorei(l.UNPACK_ALIGNMENT,W.unpackAlignment),l.pixelStorei(l.UNPACK_COLORSPACE_CONVERSION_WEBGL,Ht);let O=V(W.image,!1,i.maxTextureSize);O=Ot(W,O);const Zt=s.convert(W.format,W.colorSpace),Rt=s.convert(W.type);let Ct=R(W.internalFormat,Zt,Rt,W.colorSpace,W.isVideoTexture);Ut(P,W);let ht;const Jt=W.mipmaps,Lt=W.isVideoTexture!==!0,_t=Gt.__version===void 0||_===!0,f=B.dataReady,lt=N(W,O);if(W.isDepthTexture)Ct=G(W.format===Al,W.type),_t&&(Lt?e.texStorage2D(l.TEXTURE_2D,1,Ct,O.width,O.height):e.texImage2D(l.TEXTURE_2D,0,Ct,O.width,O.height,0,Zt,Rt,null));else if(W.isDataTexture)if(Jt.length>0){Lt&&_t&&e.texStorage2D(l.TEXTURE_2D,lt,Ct,Jt[0].width,Jt[0].height);for(let H=0,j=Jt.length;H<j;H++)ht=Jt[H],Lt?f&&e.texSubImage2D(l.TEXTURE_2D,H,0,0,ht.width,ht.height,Zt,Rt,ht.data):e.texImage2D(l.TEXTURE_2D,H,Ct,ht.width,ht.height,0,Zt,Rt,ht.data);W.generateMipmaps=!1}else Lt?(_t&&e.texStorage2D(l.TEXTURE_2D,lt,Ct,O.width,O.height),f&&e.texSubImage2D(l.TEXTURE_2D,0,0,0,O.width,O.height,Zt,Rt,O.data)):e.texImage2D(l.TEXTURE_2D,0,Ct,O.width,O.height,0,Zt,Rt,O.data);else if(W.isCompressedTexture)if(W.isCompressedArrayTexture){Lt&&_t&&e.texStorage3D(l.TEXTURE_2D_ARRAY,lt,Ct,Jt[0].width,Jt[0].height,O.depth);for(let H=0,j=Jt.length;H<j;H++)if(ht=Jt[H],W.format!==Fe)if(Zt!==null)if(Lt){if(f)if(W.layerUpdates.size>0){const ct=kd(ht.width,ht.height,W.format,W.type);for(const st of W.layerUpdates){const Yt=ht.data.subarray(st*ct/ht.data.BYTES_PER_ELEMENT,(st+1)*ct/ht.data.BYTES_PER_ELEMENT);e.compressedTexSubImage3D(l.TEXTURE_2D_ARRAY,H,0,0,st,ht.width,ht.height,1,Zt,Yt)}W.clearLayerUpdates()}else e.compressedTexSubImage3D(l.TEXTURE_2D_ARRAY,H,0,0,0,ht.width,ht.height,O.depth,Zt,ht.data)}else e.compressedTexImage3D(l.TEXTURE_2D_ARRAY,H,Ct,ht.width,ht.height,O.depth,0,ht.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else Lt?f&&e.texSubImage3D(l.TEXTURE_2D_ARRAY,H,0,0,0,ht.width,ht.height,O.depth,Zt,Rt,ht.data):e.texImage3D(l.TEXTURE_2D_ARRAY,H,Ct,ht.width,ht.height,O.depth,0,Zt,Rt,ht.data)}else{Lt&&_t&&e.texStorage2D(l.TEXTURE_2D,lt,Ct,Jt[0].width,Jt[0].height);for(let H=0,j=Jt.length;H<j;H++)ht=Jt[H],W.format!==Fe?Zt!==null?Lt?f&&e.compressedTexSubImage2D(l.TEXTURE_2D,H,0,0,ht.width,ht.height,Zt,ht.data):e.compressedTexImage2D(l.TEXTURE_2D,H,Ct,ht.width,ht.height,0,ht.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Lt?f&&e.texSubImage2D(l.TEXTURE_2D,H,0,0,ht.width,ht.height,Zt,Rt,ht.data):e.texImage2D(l.TEXTURE_2D,H,Ct,ht.width,ht.height,0,Zt,Rt,ht.data)}else if(W.isDataArrayTexture)if(Lt){if(_t&&e.texStorage3D(l.TEXTURE_2D_ARRAY,lt,Ct,O.width,O.height,O.depth),f)if(W.layerUpdates.size>0){const H=kd(O.width,O.height,W.format,W.type);for(const j of W.layerUpdates){const ct=O.data.subarray(j*H/O.data.BYTES_PER_ELEMENT,(j+1)*H/O.data.BYTES_PER_ELEMENT);e.texSubImage3D(l.TEXTURE_2D_ARRAY,0,0,0,j,O.width,O.height,1,Zt,Rt,ct)}W.clearLayerUpdates()}else e.texSubImage3D(l.TEXTURE_2D_ARRAY,0,0,0,0,O.width,O.height,O.depth,Zt,Rt,O.data)}else e.texImage3D(l.TEXTURE_2D_ARRAY,0,Ct,O.width,O.height,O.depth,0,Zt,Rt,O.data);else if(W.isData3DTexture)Lt?(_t&&e.texStorage3D(l.TEXTURE_3D,lt,Ct,O.width,O.height,O.depth),f&&e.texSubImage3D(l.TEXTURE_3D,0,0,0,0,O.width,O.height,O.depth,Zt,Rt,O.data)):e.texImage3D(l.TEXTURE_3D,0,Ct,O.width,O.height,O.depth,0,Zt,Rt,O.data);else if(W.isFramebufferTexture){if(_t)if(Lt)e.texStorage2D(l.TEXTURE_2D,lt,Ct,O.width,O.height);else{let H=O.width,j=O.height;for(let ct=0;ct<lt;ct++)e.texImage2D(l.TEXTURE_2D,ct,Ct,H,j,0,Zt,Rt,null),H>>=1,j>>=1}}else if(Jt.length>0){if(Lt&&_t){const H=Xt(Jt[0]);e.texStorage2D(l.TEXTURE_2D,lt,Ct,H.width,H.height)}for(let H=0,j=Jt.length;H<j;H++)ht=Jt[H],Lt?f&&e.texSubImage2D(l.TEXTURE_2D,H,0,0,Zt,Rt,ht):e.texImage2D(l.TEXTURE_2D,H,Ct,Zt,Rt,ht);W.generateMipmaps=!1}else if(Lt){if(_t){const H=Xt(O);e.texStorage2D(l.TEXTURE_2D,lt,Ct,H.width,H.height)}f&&e.texSubImage2D(l.TEXTURE_2D,0,0,0,Zt,Rt,O)}else e.texImage2D(l.TEXTURE_2D,0,Ct,Zt,Rt,O);r(W)&&u(P),Gt.__version=B.version,W.onUpdate&&W.onUpdate(W)}S.__version=W.version}function tt(S,W,T){if(W.image.length!==6)return;const P=Pt(S,W),_=W.source;e.bindTexture(l.TEXTURE_CUBE_MAP,S.__webglTexture,l.TEXTURE0+T);const B=n.get(_);if(_.version!==B.__version||P===!0){e.activeTexture(l.TEXTURE0+T);const Gt=kt.getPrimaries(kt.workingColorSpace),at=W.colorSpace===ul?null:kt.getPrimaries(W.colorSpace),mt=W.colorSpace===ul||Gt===at?l.NONE:l.BROWSER_DEFAULT_WEBGL;l.pixelStorei(l.UNPACK_FLIP_Y_WEBGL,W.flipY),l.pixelStorei(l.UNPACK_PREMULTIPLY_ALPHA_WEBGL,W.premultiplyAlpha),l.pixelStorei(l.UNPACK_ALIGNMENT,W.unpackAlignment),l.pixelStorei(l.UNPACK_COLORSPACE_CONVERSION_WEBGL,mt);const Ht=W.isCompressedTexture||W.image[0].isCompressedTexture,O=W.image[0]&&W.image[0].isDataTexture,Zt=[];for(let j=0;j<6;j++)!Ht&&!O?Zt[j]=V(W.image[j],!0,i.maxCubemapSize):Zt[j]=O?W.image[j].image:W.image[j],Zt[j]=Ot(W,Zt[j]);const Rt=Zt[0],Ct=s.convert(W.format,W.colorSpace),ht=s.convert(W.type),Jt=R(W.internalFormat,Ct,ht,W.colorSpace),Lt=W.isVideoTexture!==!0,_t=B.__version===void 0||P===!0,f=_.dataReady;let lt=N(W,Rt);Ut(l.TEXTURE_CUBE_MAP,W);let H;if(Ht){Lt&&_t&&e.texStorage2D(l.TEXTURE_CUBE_MAP,lt,Jt,Rt.width,Rt.height);for(let j=0;j<6;j++){H=Zt[j].mipmaps;for(let ct=0;ct<H.length;ct++){const st=H[ct];W.format!==Fe?Ct!==null?Lt?f&&e.compressedTexSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct,0,0,st.width,st.height,Ct,st.data):e.compressedTexImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct,Jt,st.width,st.height,0,st.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Lt?f&&e.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct,0,0,st.width,st.height,Ct,ht,st.data):e.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct,Jt,st.width,st.height,0,Ct,ht,st.data)}}}else{if(H=W.mipmaps,Lt&&_t){H.length>0&&lt++;const j=Xt(Zt[0]);e.texStorage2D(l.TEXTURE_CUBE_MAP,lt,Jt,j.width,j.height)}for(let j=0;j<6;j++)if(O){Lt?f&&e.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,0,0,0,Zt[j].width,Zt[j].height,Ct,ht,Zt[j].data):e.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,0,Jt,Zt[j].width,Zt[j].height,0,Ct,ht,Zt[j].data);for(let ct=0;ct<H.length;ct++){const Yt=H[ct].image[j].image;Lt?f&&e.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct+1,0,0,Yt.width,Yt.height,Ct,ht,Yt.data):e.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct+1,Jt,Yt.width,Yt.height,0,Ct,ht,Yt.data)}}else{Lt?f&&e.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,0,0,0,Ct,ht,Zt[j]):e.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,0,Jt,Ct,ht,Zt[j]);for(let ct=0;ct<H.length;ct++){const st=H[ct];Lt?f&&e.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct+1,0,0,Ct,ht,st.image[j]):e.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct+1,Jt,Ct,ht,st.image[j])}}}r(W)&&u(l.TEXTURE_CUBE_MAP),B.__version=_.version,W.onUpdate&&W.onUpdate(W)}S.__version=W.version}function pt(S,W,T,P,_,B){const Gt=s.convert(T.format,T.colorSpace),at=s.convert(T.type),mt=R(T.internalFormat,Gt,at,T.colorSpace),Ht=n.get(W),O=n.get(T);if(O.__renderTarget=W,!Ht.__hasExternalTextures){const Zt=Math.max(1,W.width>>B),Rt=Math.max(1,W.height>>B);_===l.TEXTURE_3D||_===l.TEXTURE_2D_ARRAY?e.texImage3D(_,B,mt,Zt,Rt,W.depth,0,Gt,at,null):e.texImage2D(_,B,mt,Zt,Rt,0,Gt,at,null)}e.bindFramebuffer(l.FRAMEBUFFER,S),vt(W)?d.framebufferTexture2DMultisampleEXT(l.FRAMEBUFFER,P,_,O.__webglTexture,0,Tt(W)):(_===l.TEXTURE_2D||_>=l.TEXTURE_CUBE_MAP_POSITIVE_X&&_<=l.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&l.framebufferTexture2D(l.FRAMEBUFFER,P,_,O.__webglTexture,B),e.bindFramebuffer(l.FRAMEBUFFER,null)}function it(S,W,T){if(l.bindRenderbuffer(l.RENDERBUFFER,S),W.depthBuffer){const P=W.depthTexture,_=P&&P.isDepthTexture?P.type:null,B=G(W.stencilBuffer,_),Gt=W.stencilBuffer?l.DEPTH_STENCIL_ATTACHMENT:l.DEPTH_ATTACHMENT,at=Tt(W);vt(W)?d.renderbufferStorageMultisampleEXT(l.RENDERBUFFER,at,B,W.width,W.height):T?l.renderbufferStorageMultisample(l.RENDERBUFFER,at,B,W.width,W.height):l.renderbufferStorage(l.RENDERBUFFER,B,W.width,W.height),l.framebufferRenderbuffer(l.FRAMEBUFFER,Gt,l.RENDERBUFFER,S)}else{const P=W.textures;for(let _=0;_<P.length;_++){const B=P[_],Gt=s.convert(B.format,B.colorSpace),at=s.convert(B.type),mt=R(B.internalFormat,Gt,at,B.colorSpace),Ht=Tt(W);T&&vt(W)===!1?l.renderbufferStorageMultisample(l.RENDERBUFFER,Ht,mt,W.width,W.height):vt(W)?d.renderbufferStorageMultisampleEXT(l.RENDERBUFFER,Ht,mt,W.width,W.height):l.renderbufferStorage(l.RENDERBUFFER,mt,W.width,W.height)}}l.bindRenderbuffer(l.RENDERBUFFER,null)}function yt(S,W){if(W&&W.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(l.FRAMEBUFFER,S),!(W.depthTexture&&W.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const P=n.get(W.depthTexture);P.__renderTarget=W,(!P.__webglTexture||W.depthTexture.image.width!==W.width||W.depthTexture.image.height!==W.height)&&(W.depthTexture.image.width=W.width,W.depthTexture.image.height=W.height,W.depthTexture.needsUpdate=!0),D(W.depthTexture,0);const _=P.__webglTexture,B=Tt(W);if(W.depthTexture.format===El)vt(W)?d.framebufferTexture2DMultisampleEXT(l.FRAMEBUFFER,l.DEPTH_ATTACHMENT,l.TEXTURE_2D,_,0,B):l.framebufferTexture2D(l.FRAMEBUFFER,l.DEPTH_ATTACHMENT,l.TEXTURE_2D,_,0);else if(W.depthTexture.format===Al)vt(W)?d.framebufferTexture2DMultisampleEXT(l.FRAMEBUFFER,l.DEPTH_STENCIL_ATTACHMENT,l.TEXTURE_2D,_,0,B):l.framebufferTexture2D(l.FRAMEBUFFER,l.DEPTH_STENCIL_ATTACHMENT,l.TEXTURE_2D,_,0);else throw new Error("Unknown depthTexture format")}function It(S){const W=n.get(S),T=S.isWebGLCubeRenderTarget===!0;if(W.__boundDepthTexture!==S.depthTexture){const P=S.depthTexture;if(W.__depthDisposeCallback&&W.__depthDisposeCallback(),P){const _=()=>{delete W.__boundDepthTexture,delete W.__depthDisposeCallback,P.removeEventListener("dispose",_)};P.addEventListener("dispose",_),W.__depthDisposeCallback=_}W.__boundDepthTexture=P}if(S.depthTexture&&!W.__autoAllocateDepthBuffer){if(T)throw new Error("target.depthTexture not supported in Cube render targets");yt(W.__webglFramebuffer,S)}else if(T){W.__webglDepthbuffer=[];for(let P=0;P<6;P++)if(e.bindFramebuffer(l.FRAMEBUFFER,W.__webglFramebuffer[P]),W.__webglDepthbuffer[P]===void 0)W.__webglDepthbuffer[P]=l.createRenderbuffer(),it(W.__webglDepthbuffer[P],S,!1);else{const _=S.stencilBuffer?l.DEPTH_STENCIL_ATTACHMENT:l.DEPTH_ATTACHMENT,B=W.__webglDepthbuffer[P];l.bindRenderbuffer(l.RENDERBUFFER,B),l.framebufferRenderbuffer(l.FRAMEBUFFER,_,l.RENDERBUFFER,B)}}else if(e.bindFramebuffer(l.FRAMEBUFFER,W.__webglFramebuffer),W.__webglDepthbuffer===void 0)W.__webglDepthbuffer=l.createRenderbuffer(),it(W.__webglDepthbuffer,S,!1);else{const P=S.stencilBuffer?l.DEPTH_STENCIL_ATTACHMENT:l.DEPTH_ATTACHMENT,_=W.__webglDepthbuffer;l.bindRenderbuffer(l.RENDERBUFFER,_),l.framebufferRenderbuffer(l.FRAMEBUFFER,P,l.RENDERBUFFER,_)}e.bindFramebuffer(l.FRAMEBUFFER,null)}function Mt(S,W,T){const P=n.get(S);W!==void 0&&pt(P.__webglFramebuffer,S,S.texture,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,0),T!==void 0&&It(S)}function le(S){const W=S.texture,T=n.get(S),P=n.get(W);S.addEventListener("dispose",x);const _=S.textures,B=S.isWebGLCubeRenderTarget===!0,Gt=_.length>1;if(Gt||(P.__webglTexture===void 0&&(P.__webglTexture=l.createTexture()),P.__version=W.version,a.memory.textures++),B){T.__webglFramebuffer=[];for(let at=0;at<6;at++)if(W.mipmaps&&W.mipmaps.length>0){T.__webglFramebuffer[at]=[];for(let mt=0;mt<W.mipmaps.length;mt++)T.__webglFramebuffer[at][mt]=l.createFramebuffer()}else T.__webglFramebuffer[at]=l.createFramebuffer()}else{if(W.mipmaps&&W.mipmaps.length>0){T.__webglFramebuffer=[];for(let at=0;at<W.mipmaps.length;at++)T.__webglFramebuffer[at]=l.createFramebuffer()}else T.__webglFramebuffer=l.createFramebuffer();if(Gt)for(let at=0,mt=_.length;at<mt;at++){const Ht=n.get(_[at]);Ht.__webglTexture===void 0&&(Ht.__webglTexture=l.createTexture(),a.memory.textures++)}if(S.samples>0&&vt(S)===!1){T.__webglMultisampledFramebuffer=l.createFramebuffer(),T.__webglColorRenderbuffer=[],e.bindFramebuffer(l.FRAMEBUFFER,T.__webglMultisampledFramebuffer);for(let at=0;at<_.length;at++){const mt=_[at];T.__webglColorRenderbuffer[at]=l.createRenderbuffer(),l.bindRenderbuffer(l.RENDERBUFFER,T.__webglColorRenderbuffer[at]);const Ht=s.convert(mt.format,mt.colorSpace),O=s.convert(mt.type),Zt=R(mt.internalFormat,Ht,O,mt.colorSpace,S.isXRRenderTarget===!0),Rt=Tt(S);l.renderbufferStorageMultisample(l.RENDERBUFFER,Rt,Zt,S.width,S.height),l.framebufferRenderbuffer(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0+at,l.RENDERBUFFER,T.__webglColorRenderbuffer[at])}l.bindRenderbuffer(l.RENDERBUFFER,null),S.depthBuffer&&(T.__webglDepthRenderbuffer=l.createRenderbuffer(),it(T.__webglDepthRenderbuffer,S,!0)),e.bindFramebuffer(l.FRAMEBUFFER,null)}}if(B){e.bindTexture(l.TEXTURE_CUBE_MAP,P.__webglTexture),Ut(l.TEXTURE_CUBE_MAP,W);for(let at=0;at<6;at++)if(W.mipmaps&&W.mipmaps.length>0)for(let mt=0;mt<W.mipmaps.length;mt++)pt(T.__webglFramebuffer[at][mt],S,W,l.COLOR_ATTACHMENT0,l.TEXTURE_CUBE_MAP_POSITIVE_X+at,mt);else pt(T.__webglFramebuffer[at],S,W,l.COLOR_ATTACHMENT0,l.TEXTURE_CUBE_MAP_POSITIVE_X+at,0);r(W)&&u(l.TEXTURE_CUBE_MAP),e.unbindTexture()}else if(Gt){for(let at=0,mt=_.length;at<mt;at++){const Ht=_[at],O=n.get(Ht);e.bindTexture(l.TEXTURE_2D,O.__webglTexture),Ut(l.TEXTURE_2D,Ht),pt(T.__webglFramebuffer,S,Ht,l.COLOR_ATTACHMENT0+at,l.TEXTURE_2D,0),r(Ht)&&u(l.TEXTURE_2D)}e.unbindTexture()}else{let at=l.TEXTURE_2D;if((S.isWebGL3DRenderTarget||S.isWebGLArrayRenderTarget)&&(at=S.isWebGL3DRenderTarget?l.TEXTURE_3D:l.TEXTURE_2D_ARRAY),e.bindTexture(at,P.__webglTexture),Ut(at,W),W.mipmaps&&W.mipmaps.length>0)for(let mt=0;mt<W.mipmaps.length;mt++)pt(T.__webglFramebuffer[mt],S,W,l.COLOR_ATTACHMENT0,at,mt);else pt(T.__webglFramebuffer,S,W,l.COLOR_ATTACHMENT0,at,0);r(W)&&u(at),e.unbindTexture()}S.depthBuffer&&It(S)}function wt(S){const W=S.textures;for(let T=0,P=W.length;T<P;T++){const _=W[T];if(r(_)){const B=C(S),Gt=n.get(_).__webglTexture;e.bindTexture(B,Gt),u(B),e.unbindTexture()}}}const se=[],U=[];function Te(S){if(S.samples>0){if(vt(S)===!1){const W=S.textures,T=S.width,P=S.height;let _=l.COLOR_BUFFER_BIT;const B=S.stencilBuffer?l.DEPTH_STENCIL_ATTACHMENT:l.DEPTH_ATTACHMENT,Gt=n.get(S),at=W.length>1;if(at)for(let mt=0;mt<W.length;mt++)e.bindFramebuffer(l.FRAMEBUFFER,Gt.__webglMultisampledFramebuffer),l.framebufferRenderbuffer(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0+mt,l.RENDERBUFFER,null),e.bindFramebuffer(l.FRAMEBUFFER,Gt.__webglFramebuffer),l.framebufferTexture2D(l.DRAW_FRAMEBUFFER,l.COLOR_ATTACHMENT0+mt,l.TEXTURE_2D,null,0);e.bindFramebuffer(l.READ_FRAMEBUFFER,Gt.__webglMultisampledFramebuffer),e.bindFramebuffer(l.DRAW_FRAMEBUFFER,Gt.__webglFramebuffer);for(let mt=0;mt<W.length;mt++){if(S.resolveDepthBuffer&&(S.depthBuffer&&(_|=l.DEPTH_BUFFER_BIT),S.stencilBuffer&&S.resolveStencilBuffer&&(_|=l.STENCIL_BUFFER_BIT)),at){l.framebufferRenderbuffer(l.READ_FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.RENDERBUFFER,Gt.__webglColorRenderbuffer[mt]);const Ht=n.get(W[mt]).__webglTexture;l.framebufferTexture2D(l.DRAW_FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,Ht,0)}l.blitFramebuffer(0,0,T,P,0,0,T,P,_,l.NEAREST),c===!0&&(se.length=0,U.length=0,se.push(l.COLOR_ATTACHMENT0+mt),S.depthBuffer&&S.resolveDepthBuffer===!1&&(se.push(B),U.push(B),l.invalidateFramebuffer(l.DRAW_FRAMEBUFFER,U)),l.invalidateFramebuffer(l.READ_FRAMEBUFFER,se))}if(e.bindFramebuffer(l.READ_FRAMEBUFFER,null),e.bindFramebuffer(l.DRAW_FRAMEBUFFER,null),at)for(let mt=0;mt<W.length;mt++){e.bindFramebuffer(l.FRAMEBUFFER,Gt.__webglMultisampledFramebuffer),l.framebufferRenderbuffer(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0+mt,l.RENDERBUFFER,Gt.__webglColorRenderbuffer[mt]);const Ht=n.get(W[mt]).__webglTexture;e.bindFramebuffer(l.FRAMEBUFFER,Gt.__webglFramebuffer),l.framebufferTexture2D(l.DRAW_FRAMEBUFFER,l.COLOR_ATTACHMENT0+mt,l.TEXTURE_2D,Ht,0)}e.bindFramebuffer(l.DRAW_FRAMEBUFFER,Gt.__webglMultisampledFramebuffer)}else if(S.depthBuffer&&S.resolveDepthBuffer===!1&&c){const W=S.stencilBuffer?l.DEPTH_STENCIL_ATTACHMENT:l.DEPTH_ATTACHMENT;l.invalidateFramebuffer(l.DRAW_FRAMEBUFFER,[W])}}}function Tt(S){return Math.min(i.maxSamples,S.samples)}function vt(S){const W=n.get(S);return S.samples>0&&t.has("WEBGL_multisampled_render_to_texture")===!0&&W.__useRenderToTexture!==!1}function gt(S){const W=a.render.frame;Z.get(S)!==W&&(Z.set(S,W),S.update())}function Ot(S,W){const T=S.colorSpace,P=S.format,_=S.type;return S.isCompressedTexture===!0||S.isVideoTexture===!0||T!==Ql&&T!==ul&&(kt.getTransfer(T)===Qt?(P!==Fe||_!==Pe)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",T)),W}function Xt(S){return typeof HTMLImageElement<"u"&&S instanceof HTMLImageElement?(o.width=S.naturalWidth||S.width,o.height=S.naturalHeight||S.height):typeof VideoFrame<"u"&&S instanceof VideoFrame?(o.width=S.displayWidth,o.height=S.displayHeight):(o.width=S.width,o.height=S.height),o}this.allocateTextureUnit=w,this.resetTextureUnits=Q,this.setTexture2D=D,this.setTexture2DArray=K,this.setTexture3D=$,this.setTextureCube=z,this.rebindTextures=Mt,this.setupRenderTarget=le,this.updateRenderTargetMipmap=wt,this.updateMultisampleRenderTarget=Te,this.setupDepthRenderbuffer=It,this.setupFrameBufferTexture=pt,this.useMultisampledRTT=vt}function _u(l,t){function e(n,i=ul){let s;const a=kt.getTransfer(i);if(n===Pe)return l.UNSIGNED_BYTE;if(n===Bi)return l.UNSIGNED_SHORT_4_4_4_4;if(n===Ei)return l.UNSIGNED_SHORT_5_5_5_1;if(n===Gs)return l.UNSIGNED_INT_5_9_9_9_REV;if(n===rs)return l.BYTE;if(n===ps)return l.SHORT;if(n===Gn)return l.UNSIGNED_SHORT;if(n===Ki)return l.INT;if(n===Yl)return l.UNSIGNED_INT;if(n===$e)return l.FLOAT;if(n===Wn)return l.HALF_FLOAT;if(n===Ws)return l.ALPHA;if(n===Vs)return l.RGB;if(n===Fe)return l.RGBA;if(n===Xs)return l.LUMINANCE;if(n===gs)return l.LUMINANCE_ALPHA;if(n===El)return l.DEPTH_COMPONENT;if(n===Al)return l.DEPTH_STENCIL;if(n===Rs)return l.RED;if(n===Ai)return l.RED_INTEGER;if(n===ys)return l.RG;if(n===Qi)return l.RG_INTEGER;if(n===Pi)return l.RGBA_INTEGER;if(n===wn||n===Hn||n===zn||n===Kn)if(a===Qt)if(s=t.get("WEBGL_compressed_texture_s3tc_srgb"),s!==null){if(n===wn)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===Hn)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===zn)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===Kn)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(s=t.get("WEBGL_compressed_texture_s3tc"),s!==null){if(n===wn)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===Hn)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===zn)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===Kn)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(n===ji||n===_i||n===Di||n===Oi)if(s=t.get("WEBGL_compressed_texture_pvrtc"),s!==null){if(n===ji)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===_i)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===Di)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===Oi)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(n===qi||n===$i||n===ta)if(s=t.get("WEBGL_compressed_texture_etc"),s!==null){if(n===qi||n===$i)return a===Qt?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(n===ta)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(n===ea||n===la||n===na||n===ia||n===aa||n===sa||n===da||n===ca||n===oa||n===ma||n===Za||n===ha||n===ua||n===ba)if(s=t.get("WEBGL_compressed_texture_astc"),s!==null){if(n===ea)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===la)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===na)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===ia)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===aa)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===sa)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===da)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===ca)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===oa)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===ma)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===Za)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===ha)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===ua)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===ba)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(n===Bn||n===ra||n===pa)if(s=t.get("EXT_texture_compression_bptc"),s!==null){if(n===Bn)return a===Qt?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(n===ra)return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(n===pa)return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(n===Cs||n===Ga||n===Wa||n===Va)if(s=t.get("EXT_texture_compression_rgtc"),s!==null){if(n===Bn)return s.COMPRESSED_RED_RGTC1_EXT;if(n===Ga)return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(n===Wa)return s.COMPRESSED_RED_GREEN_RGTC2_EXT;if(n===Va)return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return n===Bl?l.UNSIGNED_INT_24_8:l[n]!==void 0?l[n]:null}return{convert:e}}class Du extends Ke{constructor(t=[]){super(),this.isArrayCamera=!0,this.cameras=t}}class he extends Ce{constructor(){super(),this.isGroup=!0,this.type="Group"}}const Ou={type:"move"};class Da{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new he,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new he,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new J,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new J),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new he,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new J,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new J),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}connect(t){if(t&&t.hand){const e=this._hand;if(e)for(const n of t.hand.values())this._getHandJoint(e,n)}return this.dispatchEvent({type:"connected",data:t}),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,n){let i=null,s=null,a=null;const d=this._targetRay,c=this._grip,o=this._hand;if(t&&e.session.visibilityState!=="visible-blurred"){if(o&&t.hand){a=!0;for(const V of t.hand.values()){const r=e.getJointPose(V,n),u=this._getHandJoint(o,V);r!==null&&(u.matrix.fromArray(r.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale),u.matrixWorldNeedsUpdate=!0,u.jointRadius=r.radius),u.visible=r!==null}const Z=o.joints["index-finger-tip"],m=o.joints["thumb-tip"],b=Z.position.distanceTo(m.position),h=.02,p=.005;o.inputState.pinching&&b>h+p?(o.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!o.inputState.pinching&&b<=h-p&&(o.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else c!==null&&t.gripSpace&&(s=e.getPose(t.gripSpace,n),s!==null&&(c.matrix.fromArray(s.transform.matrix),c.matrix.decompose(c.position,c.rotation,c.scale),c.matrixWorldNeedsUpdate=!0,s.linearVelocity?(c.hasLinearVelocity=!0,c.linearVelocity.copy(s.linearVelocity)):c.hasLinearVelocity=!1,s.angularVelocity?(c.hasAngularVelocity=!0,c.angularVelocity.copy(s.angularVelocity)):c.hasAngularVelocity=!1));d!==null&&(i=e.getPose(t.targetRaySpace,n),i===null&&s!==null&&(i=s),i!==null&&(d.matrix.fromArray(i.transform.matrix),d.matrix.decompose(d.position,d.rotation,d.scale),d.matrixWorldNeedsUpdate=!0,i.linearVelocity?(d.hasLinearVelocity=!0,d.linearVelocity.copy(i.linearVelocity)):d.hasLinearVelocity=!1,i.angularVelocity?(d.hasAngularVelocity=!0,d.angularVelocity.copy(i.angularVelocity)):d.hasAngularVelocity=!1,this.dispatchEvent(Ou)))}return d!==null&&(d.visible=i!==null),c!==null&&(c.visible=s!==null),o!==null&&(o.visible=a!==null),this}_getHandJoint(t,e){if(t.joints[e.jointName]===void 0){const n=new he;n.matrixAutoUpdate=!1,n.visible=!1,t.joints[e.jointName]=n,t.add(n)}return t.joints[e.jointName]}}const qu=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,$u=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class tb{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(t,e,n){if(this.texture===null){const i=new ge,s=t.properties.get(i);s.__webglTexture=e.texture,(e.depthNear!=n.depthNear||e.depthFar!=n.depthFar)&&(this.depthNear=e.depthNear,this.depthFar=e.depthFar),this.texture=i}}getMesh(t){if(this.texture!==null&&this.mesh===null){const e=t.cameras[0].viewport,n=new ce({vertexShader:qu,fragmentShader:$u,uniforms:{depthColor:{value:this.texture},depthWidth:{value:e.z},depthHeight:{value:e.w}}});this.mesh=new ee(new te(20,20),n)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class eb extends jl{constructor(t,e){super();const n=this;let i=null,s=1,a=null,d="local-floor",c=1,o=null,Z=null,m=null,b=null,h=null,p=null;const V=new tb,r=e.getContextAttributes();let u=null,C=null;const R=[],G=[],N=new ft;let I=null;const x=new Ke;x.viewport=new ie;const M=new Ke;M.viewport=new ie;const y=[x,M],g=new Du;let Y=null,Q=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(A){let tt=R[A];return tt===void 0&&(tt=new Da,R[A]=tt),tt.getTargetRaySpace()},this.getControllerGrip=function(A){let tt=R[A];return tt===void 0&&(tt=new Da,R[A]=tt),tt.getGripSpace()},this.getHand=function(A){let tt=R[A];return tt===void 0&&(tt=new Da,R[A]=tt),tt.getHandSpace()};function w(A){const tt=G.indexOf(A.inputSource);if(tt===-1)return;const pt=R[tt];pt!==void 0&&(pt.update(A.inputSource,A.frame,o||a),pt.dispatchEvent({type:A.type,data:A.inputSource}))}function E(){i.removeEventListener("select",w),i.removeEventListener("selectstart",w),i.removeEventListener("selectend",w),i.removeEventListener("squeeze",w),i.removeEventListener("squeezestart",w),i.removeEventListener("squeezeend",w),i.removeEventListener("end",E),i.removeEventListener("inputsourceschange",D);for(let A=0;A<R.length;A++){const tt=G[A];tt!==null&&(G[A]=null,R[A].disconnect(tt))}Y=null,Q=null,V.reset(),t.setRenderTarget(u),h=null,b=null,m=null,i=null,C=null,Pt.stop(),n.isPresenting=!1,t.setPixelRatio(I),t.setSize(N.width,N.height,!1),n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(A){s=A,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(A){d=A,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o||a},this.setReferenceSpace=function(A){o=A},this.getBaseLayer=function(){return b!==null?b:h},this.getBinding=function(){return m},this.getFrame=function(){return p},this.getSession=function(){return i},this.setSession=async function(A){if(i=A,i!==null){if(u=t.getRenderTarget(),i.addEventListener("select",w),i.addEventListener("selectstart",w),i.addEventListener("selectend",w),i.addEventListener("squeeze",w),i.addEventListener("squeezestart",w),i.addEventListener("squeezeend",w),i.addEventListener("end",E),i.addEventListener("inputsourceschange",D),r.xrCompatible!==!0&&await e.makeXRCompatible(),I=t.getPixelRatio(),t.getSize(N),i.renderState.layers===void 0){const tt={antialias:r.antialias,alpha:!0,depth:r.depth,stencil:r.stencil,framebufferScaleFactor:s};h=new XRWebGLLayer(i,e,tt),i.updateRenderState({baseLayer:h}),t.setPixelRatio(1),t.setSize(h.framebufferWidth,h.framebufferHeight,!1),C=new bl(h.framebufferWidth,h.framebufferHeight,{format:Fe,type:Pe,colorSpace:t.outputColorSpace,stencilBuffer:r.stencil})}else{let tt=null,pt=null,it=null;r.depth&&(it=r.stencil?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT24,tt=r.stencil?Al:El,pt=r.stencil?Bl:Yl);const yt={colorFormat:e.RGBA8,depthFormat:it,scaleFactor:s};m=new XRWebGLBinding(i,e),b=m.createProjectionLayer(yt),i.updateRenderState({layers:[b]}),t.setPixelRatio(1),t.setSize(b.textureWidth,b.textureHeight,!1),C=new bl(b.textureWidth,b.textureHeight,{format:Fe,type:Pe,depthTexture:new pd(b.textureWidth,b.textureHeight,pt,void 0,void 0,void 0,void 0,void 0,void 0,tt),stencilBuffer:r.stencil,colorSpace:t.outputColorSpace,samples:r.antialias?4:0,resolveDepthBuffer:b.ignoreDepthValues===!1})}C.isXRRenderTarget=!0,this.setFoveation(c),o=null,a=await i.requestReferenceSpace(d),Pt.setContext(i),Pt.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode},this.getDepthTexture=function(){return V.getDepthTexture()};function D(A){for(let tt=0;tt<A.removed.length;tt++){const pt=A.removed[tt],it=G.indexOf(pt);it>=0&&(G[it]=null,R[it].disconnect(pt))}for(let tt=0;tt<A.added.length;tt++){const pt=A.added[tt];let it=G.indexOf(pt);if(it===-1){for(let It=0;It<R.length;It++)if(It>=G.length){G.push(pt),it=It;break}else if(G[It]===null){G[It]=pt,it=It;break}if(it===-1)break}const yt=R[it];yt&&yt.connect(pt)}}const K=new J,$=new J;function z(A,tt,pt){K.setFromMatrixPosition(tt.matrixWorld),$.setFromMatrixPosition(pt.matrixWorld);const it=K.distanceTo($),yt=tt.projectionMatrix.elements,It=pt.projectionMatrix.elements,Mt=yt[14]/(yt[10]-1),le=yt[14]/(yt[10]+1),wt=(yt[9]+1)/yt[5],se=(yt[9]-1)/yt[5],U=(yt[8]-1)/yt[0],Te=(It[8]+1)/It[0],Tt=Mt*U,vt=Mt*Te,gt=it/(-U+Te),Ot=gt*-U;if(tt.matrixWorld.decompose(A.position,A.quaternion,A.scale),A.translateX(Ot),A.translateZ(gt),A.matrixWorld.compose(A.position,A.quaternion,A.scale),A.matrixWorldInverse.copy(A.matrixWorld).invert(),yt[10]===-1)A.projectionMatrix.copy(tt.projectionMatrix),A.projectionMatrixInverse.copy(tt.projectionMatrixInverse);else{const Xt=Mt+gt,S=le+gt,W=Tt-Ot,T=vt+(it-Ot),P=wt*le/S*Xt,_=se*le/S*Xt;A.projectionMatrix.makePerspective(W,T,P,_,Xt,S),A.projectionMatrixInverse.copy(A.projectionMatrix).invert()}}function nt(A,tt){tt===null?A.matrixWorld.copy(A.matrix):A.matrixWorld.multiplyMatrices(tt.matrixWorld,A.matrix),A.matrixWorldInverse.copy(A.matrixWorld).invert()}this.updateCamera=function(A){if(i===null)return;let tt=A.near,pt=A.far;V.texture!==null&&(V.depthNear>0&&(tt=V.depthNear),V.depthFar>0&&(pt=V.depthFar)),g.near=M.near=x.near=tt,g.far=M.far=x.far=pt,(Y!==g.near||Q!==g.far)&&(i.updateRenderState({depthNear:g.near,depthFar:g.far}),Y=g.near,Q=g.far),x.layers.mask=A.layers.mask|2,M.layers.mask=A.layers.mask|4,g.layers.mask=x.layers.mask|M.layers.mask;const it=A.parent,yt=g.cameras;nt(g,it);for(let It=0;It<yt.length;It++)nt(yt[It],it);yt.length===2?z(g,x,M):g.projectionMatrix.copy(x.projectionMatrix),ot(A,g,it)};function ot(A,tt,pt){pt===null?A.matrix.copy(tt.matrixWorld):(A.matrix.copy(pt.matrixWorld),A.matrix.invert(),A.matrix.multiply(tt.matrixWorld)),A.matrix.decompose(A.position,A.quaternion,A.scale),A.updateMatrixWorld(!0),A.projectionMatrix.copy(tt.projectionMatrix),A.projectionMatrixInverse.copy(tt.projectionMatrixInverse),A.isPerspectiveCamera&&(A.fov=Xn*2*Math.atan(1/A.projectionMatrix.elements[5]),A.zoom=1)}this.getCamera=function(){return g},this.getFoveation=function(){if(!(b===null&&h===null))return c},this.setFoveation=function(A){c=A,b!==null&&(b.fixedFoveation=A),h!==null&&h.fixedFoveation!==void 0&&(h.fixedFoveation=A)},this.hasDepthSensing=function(){return V.texture!==null},this.getDepthSensingMesh=function(){return V.getMesh(g)};let Vt=null;function Ut(A,tt){if(Z=tt.getViewerPose(o||a),p=tt,Z!==null){const pt=Z.views;h!==null&&(t.setRenderTargetFramebuffer(C,h.framebuffer),t.setRenderTarget(C));let it=!1;pt.length!==g.cameras.length&&(g.cameras.length=0,it=!0);for(let It=0;It<pt.length;It++){const Mt=pt[It];let le=null;if(h!==null)le=h.getViewport(Mt);else{const se=m.getViewSubImage(b,Mt);le=se.viewport,It===0&&(t.setRenderTargetTextures(C,se.colorTexture,b.ignoreDepthValues?void 0:se.depthStencilTexture),t.setRenderTarget(C))}let wt=y[It];wt===void 0&&(wt=new Ke,wt.layers.enable(It),wt.viewport=new ie,y[It]=wt),wt.matrix.fromArray(Mt.transform.matrix),wt.matrix.decompose(wt.position,wt.quaternion,wt.scale),wt.projectionMatrix.fromArray(Mt.projectionMatrix),wt.projectionMatrixInverse.copy(wt.projectionMatrix).invert(),wt.viewport.set(le.x,le.y,le.width,le.height),It===0&&(g.matrix.copy(wt.matrix),g.matrix.decompose(g.position,g.quaternion,g.scale)),it===!0&&g.cameras.push(wt)}const yt=i.enabledFeatures;if(yt&&yt.includes("depth-sensing")){const It=m.getDepthInformation(pt[0]);It&&It.isValid&&It.texture&&V.init(t,It,i.renderState)}}for(let pt=0;pt<R.length;pt++){const it=G[pt],yt=R[pt];it!==null&&yt!==void 0&&yt.update(it,tt,o||a)}Vt&&Vt(A,tt),tt.detectedPlanes&&n.dispatchEvent({type:"planesdetected",data:tt}),p=null}const Pt=new cd;Pt.setAnimationLoop(Ut),this.setAnimationLoop=function(A){Vt=A},this.dispose=function(){}}}const kl=new il,lb=new ae;function nb(l,t){function e(r,u){r.matrixAutoUpdate===!0&&r.updateMatrix(),u.value.copy(r.matrix)}function n(r,u){u.color.getRGB(r.fogColor.value,ld(l)),u.isFog?(r.fogNear.value=u.near,r.fogFar.value=u.far):u.isFogExp2&&(r.fogDensity.value=u.density)}function i(r,u,C,R,G){u.isMeshBasicMaterial||u.isMeshLambertMaterial?s(r,u):u.isMeshToonMaterial?(s(r,u),m(r,u)):u.isMeshPhongMaterial?(s(r,u),Z(r,u)):u.isMeshStandardMaterial?(s(r,u),b(r,u),u.isMeshPhysicalMaterial&&h(r,u,G)):u.isMeshMatcapMaterial?(s(r,u),p(r,u)):u.isMeshDepthMaterial?s(r,u):u.isMeshDistanceMaterial?(s(r,u),V(r,u)):u.isMeshNormalMaterial?s(r,u):u.isLineBasicMaterial?(a(r,u),u.isLineDashedMaterial&&d(r,u)):u.isPointsMaterial?c(r,u,C,R):u.isSpriteMaterial?o(r,u):u.isShadowMaterial?(r.color.value.copy(u.color),r.opacity.value=u.opacity):u.isShaderMaterial&&(u.uniformsNeedUpdate=!1)}function s(r,u){r.opacity.value=u.opacity,u.color&&r.diffuse.value.copy(u.color),u.emissive&&r.emissive.value.copy(u.emissive).multiplyScalar(u.emissiveIntensity),u.map&&(r.map.value=u.map,e(u.map,r.mapTransform)),u.alphaMap&&(r.alphaMap.value=u.alphaMap,e(u.alphaMap,r.alphaMapTransform)),u.bumpMap&&(r.bumpMap.value=u.bumpMap,e(u.bumpMap,r.bumpMapTransform),r.bumpScale.value=u.bumpScale,u.side===ye&&(r.bumpScale.value*=-1)),u.normalMap&&(r.normalMap.value=u.normalMap,e(u.normalMap,r.normalMapTransform),r.normalScale.value.copy(u.normalScale),u.side===ye&&r.normalScale.value.negate()),u.displacementMap&&(r.displacementMap.value=u.displacementMap,e(u.displacementMap,r.displacementMapTransform),r.displacementScale.value=u.displacementScale,r.displacementBias.value=u.displacementBias),u.emissiveMap&&(r.emissiveMap.value=u.emissiveMap,e(u.emissiveMap,r.emissiveMapTransform)),u.specularMap&&(r.specularMap.value=u.specularMap,e(u.specularMap,r.specularMapTransform)),u.alphaTest>0&&(r.alphaTest.value=u.alphaTest);const C=t.get(u),R=C.envMap,G=C.envMapRotation;R&&(r.envMap.value=R,kl.copy(G),kl.x*=-1,kl.y*=-1,kl.z*=-1,R.isCubeTexture&&R.isRenderTargetTexture===!1&&(kl.y*=-1,kl.z*=-1),r.envMapRotation.value.setFromMatrix4(lb.makeRotationFromEuler(kl)),r.flipEnvMap.value=R.isCubeTexture&&R.isRenderTargetTexture===!1?-1:1,r.reflectivity.value=u.reflectivity,r.ior.value=u.ior,r.refractionRatio.value=u.refractionRatio),u.lightMap&&(r.lightMap.value=u.lightMap,r.lightMapIntensity.value=u.lightMapIntensity,e(u.lightMap,r.lightMapTransform)),u.aoMap&&(r.aoMap.value=u.aoMap,r.aoMapIntensity.value=u.aoMapIntensity,e(u.aoMap,r.aoMapTransform))}function a(r,u){r.diffuse.value.copy(u.color),r.opacity.value=u.opacity,u.map&&(r.map.value=u.map,e(u.map,r.mapTransform))}function d(r,u){r.dashSize.value=u.dashSize,r.totalSize.value=u.dashSize+u.gapSize,r.scale.value=u.scale}function c(r,u,C,R){r.diffuse.value.copy(u.color),r.opacity.value=u.opacity,r.size.value=u.size*C,r.scale.value=R*.5,u.map&&(r.map.value=u.map,e(u.map,r.uvTransform)),u.alphaMap&&(r.alphaMap.value=u.alphaMap,e(u.alphaMap,r.alphaMapTransform)),u.alphaTest>0&&(r.alphaTest.value=u.alphaTest)}function o(r,u){r.diffuse.value.copy(u.color),r.opacity.value=u.opacity,r.rotation.value=u.rotation,u.map&&(r.map.value=u.map,e(u.map,r.mapTransform)),u.alphaMap&&(r.alphaMap.value=u.alphaMap,e(u.alphaMap,r.alphaMapTransform)),u.alphaTest>0&&(r.alphaTest.value=u.alphaTest)}function Z(r,u){r.specular.value.copy(u.specular),r.shininess.value=Math.max(u.shininess,1e-4)}function m(r,u){u.gradientMap&&(r.gradientMap.value=u.gradientMap)}function b(r,u){r.metalness.value=u.metalness,u.metalnessMap&&(r.metalnessMap.value=u.metalnessMap,e(u.metalnessMap,r.metalnessMapTransform)),r.roughness.value=u.roughness,u.roughnessMap&&(r.roughnessMap.value=u.roughnessMap,e(u.roughnessMap,r.roughnessMapTransform)),u.envMap&&(r.envMapIntensity.value=u.envMapIntensity)}function h(r,u,C){r.ior.value=u.ior,u.sheen>0&&(r.sheenColor.value.copy(u.sheenColor).multiplyScalar(u.sheen),r.sheenRoughness.value=u.sheenRoughness,u.sheenColorMap&&(r.sheenColorMap.value=u.sheenColorMap,e(u.sheenColorMap,r.sheenColorMapTransform)),u.sheenRoughnessMap&&(r.sheenRoughnessMap.value=u.sheenRoughnessMap,e(u.sheenRoughnessMap,r.sheenRoughnessMapTransform))),u.clearcoat>0&&(r.clearcoat.value=u.clearcoat,r.clearcoatRoughness.value=u.clearcoatRoughness,u.clearcoatMap&&(r.clearcoatMap.value=u.clearcoatMap,e(u.clearcoatMap,r.clearcoatMapTransform)),u.clearcoatRoughnessMap&&(r.clearcoatRoughnessMap.value=u.clearcoatRoughnessMap,e(u.clearcoatRoughnessMap,r.clearcoatRoughnessMapTransform)),u.clearcoatNormalMap&&(r.clearcoatNormalMap.value=u.clearcoatNormalMap,e(u.clearcoatNormalMap,r.clearcoatNormalMapTransform),r.clearcoatNormalScale.value.copy(u.clearcoatNormalScale),u.side===ye&&r.clearcoatNormalScale.value.negate())),u.dispersion>0&&(r.dispersion.value=u.dispersion),u.iridescence>0&&(r.iridescence.value=u.iridescence,r.iridescenceIOR.value=u.iridescenceIOR,r.iridescenceThicknessMinimum.value=u.iridescenceThicknessRange[0],r.iridescenceThicknessMaximum.value=u.iridescenceThicknessRange[1],u.iridescenceMap&&(r.iridescenceMap.value=u.iridescenceMap,e(u.iridescenceMap,r.iridescenceMapTransform)),u.iridescenceThicknessMap&&(r.iridescenceThicknessMap.value=u.iridescenceThicknessMap,e(u.iridescenceThicknessMap,r.iridescenceThicknessMapTransform))),u.transmission>0&&(r.transmission.value=u.transmission,r.transmissionSamplerMap.value=C.texture,r.transmissionSamplerSize.value.set(C.width,C.height),u.transmissionMap&&(r.transmissionMap.value=u.transmissionMap,e(u.transmissionMap,r.transmissionMapTransform)),r.thickness.value=u.thickness,u.thicknessMap&&(r.thicknessMap.value=u.thicknessMap,e(u.thicknessMap,r.thicknessMapTransform)),r.attenuationDistance.value=u.attenuationDistance,r.attenuationColor.value.copy(u.attenuationColor)),u.anisotropy>0&&(r.anisotropyVector.value.set(u.anisotropy*Math.cos(u.anisotropyRotation),u.anisotropy*Math.sin(u.anisotropyRotation)),u.anisotropyMap&&(r.anisotropyMap.value=u.anisotropyMap,e(u.anisotropyMap,r.anisotropyMapTransform))),r.specularIntensity.value=u.specularIntensity,r.specularColor.value.copy(u.specularColor),u.specularColorMap&&(r.specularColorMap.value=u.specularColorMap,e(u.specularColorMap,r.specularColorMapTransform)),u.specularIntensityMap&&(r.specularIntensityMap.value=u.specularIntensityMap,e(u.specularIntensityMap,r.specularIntensityMapTransform))}function p(r,u){u.matcap&&(r.matcap.value=u.matcap)}function V(r,u){const C=t.get(u).light;r.referencePosition.value.setFromMatrixPosition(C.matrixWorld),r.nearDistance.value=C.shadow.camera.near,r.farDistance.value=C.shadow.camera.far}return{refreshFogUniforms:n,refreshMaterialUniforms:i}}function ib(l,t,e,n){let i={},s={},a=[];const d=l.getParameter(l.MAX_UNIFORM_BUFFER_BINDINGS);function c(C,R){const G=R.program;n.uniformBlockBinding(C,G)}function o(C,R){let G=i[C.id];G===void 0&&(p(C),G=Z(C),i[C.id]=G,C.addEventListener("dispose",r));const N=R.program;n.updateUBOMapping(C,N);const I=t.render.frame;s[C.id]!==I&&(b(C),s[C.id]=I)}function Z(C){const R=m();C.__bindingPointIndex=R;const G=l.createBuffer(),N=C.__size,I=C.usage;return l.bindBuffer(l.UNIFORM_BUFFER,G),l.bufferData(l.UNIFORM_BUFFER,N,I),l.bindBuffer(l.UNIFORM_BUFFER,null),l.bindBufferBase(l.UNIFORM_BUFFER,R,G),G}function m(){for(let C=0;C<d;C++)if(a.indexOf(C)===-1)return a.push(C),C;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function b(C){const R=i[C.id],G=C.uniforms,N=C.__cache;l.bindBuffer(l.UNIFORM_BUFFER,R);for(let I=0,x=G.length;I<x;I++){const M=Array.isArray(G[I])?G[I]:[G[I]];for(let y=0,g=M.length;y<g;y++){const Y=M[y];if(h(Y,I,y,N)===!0){const Q=Y.__offset,w=Array.isArray(Y.value)?Y.value:[Y.value];let E=0;for(let D=0;D<w.length;D++){const K=w[D],$=V(K);typeof K=="number"||typeof K=="boolean"?(Y.__data[0]=K,l.bufferSubData(l.UNIFORM_BUFFER,Q+E,Y.__data)):K.isMatrix3?(Y.__data[0]=K.elements[0],Y.__data[1]=K.elements[1],Y.__data[2]=K.elements[2],Y.__data[3]=0,Y.__data[4]=K.elements[3],Y.__data[5]=K.elements[4],Y.__data[6]=K.elements[5],Y.__data[7]=0,Y.__data[8]=K.elements[6],Y.__data[9]=K.elements[7],Y.__data[10]=K.elements[8],Y.__data[11]=0):(K.toArray(Y.__data,E),E+=$.storage/Float32Array.BYTES_PER_ELEMENT)}l.bufferSubData(l.UNIFORM_BUFFER,Q,Y.__data)}}}l.bindBuffer(l.UNIFORM_BUFFER,null)}function h(C,R,G,N){const I=C.value,x=R+"_"+G;if(N[x]===void 0)return typeof I=="number"||typeof I=="boolean"?N[x]=I:N[x]=I.clone(),!0;{const M=N[x];if(typeof I=="number"||typeof I=="boolean"){if(M!==I)return N[x]=I,!0}else if(M.equals(I)===!1)return M.copy(I),!0}return!1}function p(C){const R=C.uniforms;let G=0;const N=16;for(let x=0,M=R.length;x<M;x++){const y=Array.isArray(R[x])?R[x]:[R[x]];for(let g=0,Y=y.length;g<Y;g++){const Q=y[g],w=Array.isArray(Q.value)?Q.value:[Q.value];for(let E=0,D=w.length;E<D;E++){const K=w[E],$=V(K),z=G%N,nt=z%$.boundary,ot=z+nt;G+=nt,ot!==0&&N-ot<$.storage&&(G+=N-ot),Q.__data=new Float32Array($.storage/Float32Array.BYTES_PER_ELEMENT),Q.__offset=G,G+=$.storage}}}const I=G%N;return I>0&&(G+=N-I),C.__size=G,C.__cache={},this}function V(C){const R={boundary:0,storage:0};return typeof C=="number"||typeof C=="boolean"?(R.boundary=4,R.storage=4):C.isVector2?(R.boundary=8,R.storage=8):C.isVector3||C.isColor?(R.boundary=16,R.storage=12):C.isVector4?(R.boundary=16,R.storage=16):C.isMatrix3?(R.boundary=48,R.storage=48):C.isMatrix4?(R.boundary=64,R.storage=64):C.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",C),R}function r(C){const R=C.target;R.removeEventListener("dispose",r);const G=a.indexOf(R.__bindingPointIndex);a.splice(G,1),l.deleteBuffer(i[R.id]),delete i[R.id],delete s[R.id]}function u(){for(const C in i)l.deleteBuffer(i[C]);a=[],i={},s={}}return{bind:c,update:o,dispose:u}}class ab{constructor(t={}){const{canvas:e=xo(),context:n=null,depth:i=!0,stencil:s=!1,alpha:a=!1,antialias:d=!1,premultipliedAlpha:c=!0,preserveDrawingBuffer:o=!1,powerPreference:Z="default",failIfMajorPerformanceCaveat:m=!1,reverseDepthBuffer:b=!1}=t;this.isWebGLRenderer=!0;let h;if(n!==null){if(typeof WebGLRenderingContext<"u"&&n instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");h=n.getContextAttributes().alpha}else h=a;const p=new Uint32Array(4),V=new Int32Array(4);let r=null,u=null;const C=[],R=[];this.domElement=e,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=Le,this.toneMapping=hl,this.toneMappingExposure=1;const G=this;let N=!1,I=0,x=0,M=null,y=-1,g=null;const Y=new ie,Q=new ie;let w=null;const E=new Kt(0);let D=0,K=e.width,$=e.height,z=1,nt=null,ot=null;const Vt=new ie(0,0,K,$),Ut=new ie(0,0,K,$);let Pt=!1;const A=new dd;let tt=!1,pt=!1;const it=new ae,yt=new ae,It=new J,Mt=new ie,le={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let wt=!1;function se(){return M===null?z:1}let U=n;function Te(X,F){return e.getContext(X,F)}try{const X={alpha:!0,depth:i,stencil:s,antialias:d,premultipliedAlpha:c,preserveDrawingBuffer:o,powerPreference:Z,failIfMajorPerformanceCaveat:m};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${xi}`),e.addEventListener("webglcontextlost",j,!1),e.addEventListener("webglcontextrestored",ct,!1),e.addEventListener("webglcontextcreationerror",st,!1),U===null){const F="webgl2";if(U=Te(F,X),U===null)throw Te(F)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(X){throw console.error("THREE.WebGLRenderer: "+X.message),X}let Tt,vt,gt,Ot,Xt,S,W,T,P,_,B,Gt,at,mt,Ht,O,Zt,Rt,Ct,ht,Jt,Lt,_t,f;function lt(){Tt=new mh(U),Tt.init(),Lt=new _u(U,Tt),vt=new ih(U,Tt,t,Lt),gt=new Qu(U,Tt),vt.reverseDepthBuffer&&b&&gt.buffers.depth.setReversed(!0),Ot=new uh(U),Xt=new Fu,S=new ju(U,Tt,gt,Xt,vt,Lt,Ot),W=new sh(G),T=new oh(G),P=new tm(U),_t=new lh(U,P),_=new Zh(U,P,Ot,_t),B=new rh(U,_,P,Ot),Ct=new bh(U,vt,S),O=new ah(Xt),Gt=new fu(G,W,T,Tt,vt,_t,O),at=new nb(G,Xt),mt=new Uu,Ht=new wu(Tt),Rt=new eh(G,W,T,gt,B,h,c),Zt=new Eu(G,B,vt),f=new ib(U,Ot,vt,gt),ht=new nh(U,Tt,Ot),Jt=new hh(U,Tt,Ot),Ot.programs=Gt.programs,G.capabilities=vt,G.extensions=Tt,G.properties=Xt,G.renderLists=mt,G.shadowMap=Zt,G.state=gt,G.info=Ot}lt();const H=new eb(G,U);this.xr=H,this.getContext=function(){return U},this.getContextAttributes=function(){return U.getContextAttributes()},this.forceContextLoss=function(){const X=Tt.get("WEBGL_lose_context");X&&X.loseContext()},this.forceContextRestore=function(){const X=Tt.get("WEBGL_lose_context");X&&X.restoreContext()},this.getPixelRatio=function(){return z},this.setPixelRatio=function(X){X!==void 0&&(z=X,this.setSize(K,$,!1))},this.getSize=function(X){return X.set(K,$)},this.setSize=function(X,F,v=!0){if(H.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}K=X,$=F,e.width=Math.floor(X*z),e.height=Math.floor(F*z),v===!0&&(e.style.width=X+"px",e.style.height=F+"px"),this.setViewport(0,0,X,F)},this.getDrawingBufferSize=function(X){return X.set(K*z,$*z).floor()},this.setDrawingBufferSize=function(X,F,v){K=X,$=F,z=v,e.width=Math.floor(X*v),e.height=Math.floor(F*v),this.setViewport(0,0,X,F)},this.getCurrentViewport=function(X){return X.copy(Y)},this.getViewport=function(X){return X.copy(Vt)},this.setViewport=function(X,F,v,k){X.isVector4?Vt.set(X.x,X.y,X.z,X.w):Vt.set(X,F,v,k),gt.viewport(Y.copy(Vt).multiplyScalar(z).round())},this.getScissor=function(X){return X.copy(Ut)},this.setScissor=function(X,F,v,k){X.isVector4?Ut.set(X.x,X.y,X.z,X.w):Ut.set(X,F,v,k),gt.scissor(Q.copy(Ut).multiplyScalar(z).round())},this.getScissorTest=function(){return Pt},this.setScissorTest=function(X){gt.setScissorTest(Pt=X)},this.setOpaqueSort=function(X){nt=X},this.setTransparentSort=function(X){ot=X},this.getClearColor=function(X){return X.copy(Rt.getClearColor())},this.setClearColor=function(){Rt.setClearColor.apply(Rt,arguments)},this.getClearAlpha=function(){return Rt.getClearAlpha()},this.setClearAlpha=function(){Rt.setClearAlpha.apply(Rt,arguments)},this.clear=function(X=!0,F=!0,v=!0){let k=0;if(X){let L=!1;if(M!==null){const q=M.texture.format;L=q===Pi||q===Qi||q===Ai}if(L){const q=M.texture.type,dt=q===Pe||q===Yl||q===Gn||q===Bl||q===Bi||q===Ei,ut=Rt.getClearColor(),bt=Rt.getClearAlpha(),St=ut.r,Nt=ut.g,rt=ut.b;dt?(p[0]=St,p[1]=Nt,p[2]=rt,p[3]=bt,U.clearBufferuiv(U.COLOR,0,p)):(V[0]=St,V[1]=Nt,V[2]=rt,V[3]=bt,U.clearBufferiv(U.COLOR,0,V))}else k|=U.COLOR_BUFFER_BIT}F&&(k|=U.DEPTH_BUFFER_BIT),v&&(k|=U.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),U.clear(k)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",j,!1),e.removeEventListener("webglcontextrestored",ct,!1),e.removeEventListener("webglcontextcreationerror",st,!1),mt.dispose(),Ht.dispose(),Xt.dispose(),W.dispose(),T.dispose(),B.dispose(),_t.dispose(),f.dispose(),Gt.dispose(),H.dispose(),H.removeEventListener("sessionstart",bc),H.removeEventListener("sessionend",rc),wl.stop()};function j(X){X.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),N=!0}function ct(){console.log("THREE.WebGLRenderer: Context Restored."),N=!1;const X=Ot.autoReset,F=Zt.enabled,v=Zt.autoUpdate,k=Zt.needsUpdate,L=Zt.type;lt(),Ot.autoReset=X,Zt.enabled=F,Zt.autoUpdate=v,Zt.needsUpdate=k,Zt.type=L}function st(X){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",X.statusMessage)}function Yt(X){const F=X.target;F.removeEventListener("dispose",Yt),ne(F)}function ne(X){We(X),Xt.remove(X)}function We(X){const F=Xt.get(X).programs;F!==void 0&&(F.forEach(function(v){Gt.releaseProgram(v)}),X.isShaderMaterial&&Gt.releaseShaderCache(X))}this.renderBufferDirect=function(X,F,v,k,L,q){F===null&&(F=le);const dt=L.isMesh&&L.matrixWorld.determinant()<0,ut=_b(X,F,v,k,L);gt.setMaterial(k,dt);let bt=v.index,St=1;if(k.wireframe===!0){if(bt=_.getWireframeAttribute(v),bt===void 0)return;St=2}const Nt=v.drawRange,rt=v.attributes.position;let zt=Nt.start*St,Dt=(Nt.start+Nt.count)*St;q!==null&&(zt=Math.max(zt,q.start*St),Dt=Math.min(Dt,(q.start+q.count)*St)),bt!==null?(zt=Math.max(zt,0),Dt=Math.min(Dt,bt.count)):rt!=null&&(zt=Math.max(zt,0),Dt=Math.min(Dt,rt.count));const qt=Dt-zt;if(qt<0||qt===1/0)return;_t.setup(L,k,ut,v,bt);let Ie,Bt=ht;if(bt!==null&&(Ie=P.get(bt),Bt=Jt,Bt.setIndex(Ie)),L.isMesh)k.wireframe===!0?(gt.setLineWidth(k.wireframeLinewidth*se()),Bt.setMode(U.LINES)):Bt.setMode(U.TRIANGLES);else if(L.isLine){let Wt=k.linewidth;Wt===void 0&&(Wt=1),gt.setLineWidth(Wt*se()),L.isLineSegments?Bt.setMode(U.LINES):L.isLineLoop?Bt.setMode(U.LINE_LOOP):Bt.setMode(U.LINE_STRIP)}else L.isPoints?Bt.setMode(U.POINTS):L.isSprite&&Bt.setMode(U.TRIANGLES);if(L.isBatchedMesh)if(L._multiDrawInstances!==null)Bt.renderMultiDrawInstances(L._multiDrawStarts,L._multiDrawCounts,L._multiDrawCount,L._multiDrawInstances);else if(Tt.get("WEBGL_multi_draw"))Bt.renderMultiDraw(L._multiDrawStarts,L._multiDrawCounts,L._multiDrawCount);else{const Wt=L._multiDrawStarts,ol=L._multiDrawCounts,Et=L._multiDrawCount,Ae=bt?P.get(bt).bytesPerElement:1,pn=Xt.get(k).currentProgram.getUniforms();for(let Ne=0;Ne<Et;Ne++)pn.setValue(U,"_gl_DrawID",Ne),Bt.render(Wt[Ne]/Ae,ol[Ne])}else if(L.isInstancedMesh)Bt.renderInstances(zt,qt,L.count);else if(v.isInstancedBufferGeometry){const Wt=v._maxInstanceCount!==void 0?v._maxInstanceCount:1/0,ol=Math.min(v.instanceCount,Wt);Bt.renderInstances(zt,qt,ol)}else Bt.render(zt,qt)};function At(X,F,v){X.transparent===!0&&X.side===qe&&X.forceSinglePass===!1?(X.side=ye,X.needsUpdate=!0,Ii(X,F,v),X.side=ml,X.needsUpdate=!0,Ii(X,F,v),X.side=qe):Ii(X,F,v)}this.compile=function(X,F,v=null){v===null&&(v=X),u=Ht.get(v),u.init(F),R.push(u),v.traverseVisible(function(L){L.isLight&&L.layers.test(F.layers)&&(u.pushLight(L),L.castShadow&&u.pushShadow(L))}),X!==v&&X.traverseVisible(function(L){L.isLight&&L.layers.test(F.layers)&&(u.pushLight(L),L.castShadow&&u.pushShadow(L))}),u.setupLights();const k=new Set;return X.traverse(function(L){if(!(L.isMesh||L.isPoints||L.isLine||L.isSprite))return;const q=L.material;if(q)if(Array.isArray(q))for(let dt=0;dt<q.length;dt++){const ut=q[dt];At(ut,v,L),k.add(ut)}else At(q,v,L),k.add(q)}),R.pop(),u=null,k},this.compileAsync=function(X,F,v=null){const k=this.compile(X,F,v);return new Promise(L=>{function q(){if(k.forEach(function(dt){Xt.get(dt).currentProgram.isReady()&&k.delete(dt)}),k.size===0){L(X);return}setTimeout(q,10)}Tt.get("KHR_parallel_shader_compile")!==null?q():setTimeout(q,10)})};let Ee=null;function cl(X){Ee&&Ee(X)}function bc(){wl.stop()}function rc(){wl.start()}const wl=new cd;wl.setAnimationLoop(cl),typeof self<"u"&&wl.setContext(self),this.setAnimationLoop=function(X){Ee=X,H.setAnimationLoop(X),X===null?wl.stop():wl.start()},H.addEventListener("sessionstart",bc),H.addEventListener("sessionend",rc),this.render=function(X,F){if(F!==void 0&&F.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(N===!0)return;if(X.matrixWorldAutoUpdate===!0&&X.updateMatrixWorld(),F.parent===null&&F.matrixWorldAutoUpdate===!0&&F.updateMatrixWorld(),H.enabled===!0&&H.isPresenting===!0&&(H.cameraAutoUpdate===!0&&H.updateCamera(F),F=H.getCamera()),X.isScene===!0&&X.onBeforeRender(G,X,F,M),u=Ht.get(X,R.length),u.init(F),R.push(u),yt.multiplyMatrices(F.projectionMatrix,F.matrixWorldInverse),A.setFromProjectionMatrix(yt),pt=this.localClippingEnabled,tt=O.init(this.clippingPlanes,pt),r=mt.get(X,C.length),r.init(),C.push(r),H.enabled===!0&&H.isPresenting===!0){const q=G.xr.getDepthSensingMesh();q!==null&&ds(q,F,-1/0,G.sortObjects)}ds(X,F,0,G.sortObjects),r.finish(),G.sortObjects===!0&&r.sort(nt,ot),wt=H.enabled===!1||H.isPresenting===!1||H.hasDepthSensing()===!1,wt&&Rt.addToRenderList(r,X),this.info.render.frame++,tt===!0&&O.beginShadows();const v=u.state.shadowsArray;Zt.render(v,X,F),tt===!0&&O.endShadows(),this.info.autoReset===!0&&this.info.reset();const k=r.opaque,L=r.transmissive;if(u.setupLights(),F.isArrayCamera){const q=F.cameras;if(L.length>0)for(let dt=0,ut=q.length;dt<ut;dt++){const bt=q[dt];Gc(k,L,X,bt)}wt&&Rt.render(X);for(let dt=0,ut=q.length;dt<ut;dt++){const bt=q[dt];pc(r,X,bt,bt.viewport)}}else L.length>0&&Gc(k,L,X,F),wt&&Rt.render(X),pc(r,X,F);M!==null&&(S.updateMultisampleRenderTarget(M),S.updateRenderTargetMipmap(M)),X.isScene===!0&&X.onAfterRender(G,X,F),_t.resetDefaultState(),y=-1,g=null,R.pop(),R.length>0?(u=R[R.length-1],tt===!0&&O.setGlobalState(G.clippingPlanes,u.state.camera)):u=null,C.pop(),C.length>0?r=C[C.length-1]:r=null};function ds(X,F,v,k){if(X.visible===!1)return;if(X.layers.test(F.layers)){if(X.isGroup)v=X.renderOrder;else if(X.isLOD)X.autoUpdate===!0&&X.update(F);else if(X.isLight)u.pushLight(X),X.castShadow&&u.pushShadow(X);else if(X.isSprite){if(!X.frustumCulled||A.intersectsSprite(X)){k&&Mt.setFromMatrixPosition(X.matrixWorld).applyMatrix4(yt);const dt=B.update(X),ut=X.material;ut.visible&&r.push(X,dt,ut,v,Mt.z,null)}}else if((X.isMesh||X.isLine||X.isPoints)&&(!X.frustumCulled||A.intersectsObject(X))){const dt=B.update(X),ut=X.material;if(k&&(X.boundingSphere!==void 0?(X.boundingSphere===null&&X.computeBoundingSphere(),Mt.copy(X.boundingSphere.center)):(dt.boundingSphere===null&&dt.computeBoundingSphere(),Mt.copy(dt.boundingSphere.center)),Mt.applyMatrix4(X.matrixWorld).applyMatrix4(yt)),Array.isArray(ut)){const bt=dt.groups;for(let St=0,Nt=bt.length;St<Nt;St++){const rt=bt[St],zt=ut[rt.materialIndex];zt&&zt.visible&&r.push(X,dt,zt,v,Mt.z,rt)}}else ut.visible&&r.push(X,dt,ut,v,Mt.z,null)}}const q=X.children;for(let dt=0,ut=q.length;dt<ut;dt++)ds(q[dt],F,v,k)}function pc(X,F,v,k){const L=X.opaque,q=X.transmissive,dt=X.transparent;u.setupLightsView(v),tt===!0&&O.setGlobalState(G.clippingPlanes,v),k&&gt.viewport(Y.copy(k)),L.length>0&&Si(L,F,v),q.length>0&&Si(q,F,v),dt.length>0&&Si(dt,F,v),gt.buffers.depth.setTest(!0),gt.buffers.depth.setMask(!0),gt.buffers.color.setMask(!0),gt.setPolygonOffset(!1)}function Gc(X,F,v,k){if((v.isScene===!0?v.overrideMaterial:null)!==null)return;u.state.transmissionRenderTarget[k.id]===void 0&&(u.state.transmissionRenderTarget[k.id]=new bl(1,1,{generateMipmaps:!0,type:Tt.has("EXT_color_buffer_half_float")||Tt.has("EXT_color_buffer_float")?Wn:Pe,minFilter:xl,samples:4,stencilBuffer:s,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:kt.workingColorSpace}));const q=u.state.transmissionRenderTarget[k.id],dt=k.viewport||Y;q.setSize(dt.z,dt.w);const ut=G.getRenderTarget();G.setRenderTarget(q),G.getClearColor(E),D=G.getClearAlpha(),D<1&&G.setClearColor(16777215,.5),G.clear(),wt&&Rt.render(v);const bt=G.toneMapping;G.toneMapping=hl;const St=k.viewport;if(k.viewport!==void 0&&(k.viewport=void 0),u.setupLightsView(k),tt===!0&&O.setGlobalState(G.clippingPlanes,k),Si(X,v,k),S.updateMultisampleRenderTarget(q),S.updateRenderTargetMipmap(q),Tt.has("WEBGL_multisampled_render_to_texture")===!1){let Nt=!1;for(let rt=0,zt=F.length;rt<zt;rt++){const Dt=F[rt],qt=Dt.object,Ie=Dt.geometry,Bt=Dt.material,Wt=Dt.group;if(Bt.side===qe&&qt.layers.test(k.layers)){const ol=Bt.side;Bt.side=ye,Bt.needsUpdate=!0,Wc(qt,v,k,Ie,Bt,Wt),Bt.side=ol,Bt.needsUpdate=!0,Nt=!0}}Nt===!0&&(S.updateMultisampleRenderTarget(q),S.updateRenderTargetMipmap(q))}G.setRenderTarget(ut),G.setClearColor(E,D),St!==void 0&&(k.viewport=St),G.toneMapping=bt}function Si(X,F,v){const k=F.isScene===!0?F.overrideMaterial:null;for(let L=0,q=X.length;L<q;L++){const dt=X[L],ut=dt.object,bt=dt.geometry,St=k===null?dt.material:k,Nt=dt.group;ut.layers.test(v.layers)&&Wc(ut,F,v,bt,St,Nt)}}function Wc(X,F,v,k,L,q){X.onBeforeRender(G,F,v,k,L,q),X.modelViewMatrix.multiplyMatrices(v.matrixWorldInverse,X.matrixWorld),X.normalMatrix.getNormalMatrix(X.modelViewMatrix),L.onBeforeRender(G,F,v,k,X,q),L.transparent===!0&&L.side===qe&&L.forceSinglePass===!1?(L.side=ye,L.needsUpdate=!0,G.renderBufferDirect(v,F,k,L,X,q),L.side=ml,L.needsUpdate=!0,G.renderBufferDirect(v,F,k,L,X,q),L.side=qe):G.renderBufferDirect(v,F,k,L,X,q),X.onAfterRender(G,F,v,k,L,q)}function Ii(X,F,v){F.isScene!==!0&&(F=le);const k=Xt.get(X),L=u.state.lights,q=u.state.shadowsArray,dt=L.state.version,ut=Gt.getParameters(X,L.state,q,F,v),bt=Gt.getProgramCacheKey(ut);let St=k.programs;k.environment=X.isMeshStandardMaterial?F.environment:null,k.fog=F.fog,k.envMap=(X.isMeshStandardMaterial?T:W).get(X.envMap||k.environment),k.envMapRotation=k.environment!==null&&X.envMap===null?F.environmentRotation:X.envMapRotation,St===void 0&&(X.addEventListener("dispose",Yt),St=new Map,k.programs=St);let Nt=St.get(bt);if(Nt!==void 0){if(k.currentProgram===Nt&&k.lightsStateVersion===dt)return Xc(X,ut),Nt}else ut.uniforms=Gt.getUniforms(X),X.onBeforeCompile(ut,G),Nt=Gt.acquireProgram(ut,bt),St.set(bt,Nt),k.uniforms=ut.uniforms;const rt=k.uniforms;return(!X.isShaderMaterial&&!X.isRawShaderMaterial||X.clipping===!0)&&(rt.clippingPlanes=O.uniform),Xc(X,ut),k.needsLights=Ob(X),k.lightsStateVersion=dt,k.needsLights&&(rt.ambientLightColor.value=L.state.ambient,rt.lightProbe.value=L.state.probe,rt.directionalLights.value=L.state.directional,rt.directionalLightShadows.value=L.state.directionalShadow,rt.spotLights.value=L.state.spot,rt.spotLightShadows.value=L.state.spotShadow,rt.rectAreaLights.value=L.state.rectArea,rt.ltc_1.value=L.state.rectAreaLTC1,rt.ltc_2.value=L.state.rectAreaLTC2,rt.pointLights.value=L.state.point,rt.pointLightShadows.value=L.state.pointShadow,rt.hemisphereLights.value=L.state.hemi,rt.directionalShadowMap.value=L.state.directionalShadowMap,rt.directionalShadowMatrix.value=L.state.directionalShadowMatrix,rt.spotShadowMap.value=L.state.spotShadowMap,rt.spotLightMatrix.value=L.state.spotLightMatrix,rt.spotLightMap.value=L.state.spotLightMap,rt.pointShadowMap.value=L.state.pointShadowMap,rt.pointShadowMatrix.value=L.state.pointShadowMatrix),k.currentProgram=Nt,k.uniformsList=null,Nt}function Vc(X){if(X.uniformsList===null){const F=X.currentProgram.getUniforms();X.uniformsList=bi.seqWithValue(F.seq,X.uniforms)}return X.uniformsList}function Xc(X,F){const v=Xt.get(X);v.outputColorSpace=F.outputColorSpace,v.batching=F.batching,v.batchingColor=F.batchingColor,v.instancing=F.instancing,v.instancingColor=F.instancingColor,v.instancingMorph=F.instancingMorph,v.skinning=F.skinning,v.morphTargets=F.morphTargets,v.morphNormals=F.morphNormals,v.morphColors=F.morphColors,v.morphTargetsCount=F.morphTargetsCount,v.numClippingPlanes=F.numClippingPlanes,v.numIntersection=F.numClipIntersection,v.vertexAlphas=F.vertexAlphas,v.vertexTangents=F.vertexTangents,v.toneMapping=F.toneMapping}function _b(X,F,v,k,L){F.isScene!==!0&&(F=le),S.resetTextureUnits();const q=F.fog,dt=k.isMeshStandardMaterial?F.environment:null,ut=M===null?G.outputColorSpace:M.isXRRenderTarget===!0?M.texture.colorSpace:Ql,bt=(k.isMeshStandardMaterial?T:W).get(k.envMap||dt),St=k.vertexColors===!0&&!!v.attributes.color&&v.attributes.color.itemSize===4,Nt=!!v.attributes.tangent&&(!!k.normalMap||k.anisotropy>0),rt=!!v.morphAttributes.position,zt=!!v.morphAttributes.normal,Dt=!!v.morphAttributes.color;let qt=hl;k.toneMapped&&(M===null||M.isXRRenderTarget===!0)&&(qt=G.toneMapping);const Ie=v.morphAttributes.position||v.morphAttributes.normal||v.morphAttributes.color,Bt=Ie!==void 0?Ie.length:0,Wt=Xt.get(k),ol=u.state.lights;if(tt===!0&&(pt===!0||X!==g)){const ve=X===g&&k.id===y;O.setState(k,X,ve)}let Et=!1;k.version===Wt.__version?(Wt.needsLights&&Wt.lightsStateVersion!==ol.state.version||Wt.outputColorSpace!==ut||L.isBatchedMesh&&Wt.batching===!1||!L.isBatchedMesh&&Wt.batching===!0||L.isBatchedMesh&&Wt.batchingColor===!0&&L.colorTexture===null||L.isBatchedMesh&&Wt.batchingColor===!1&&L.colorTexture!==null||L.isInstancedMesh&&Wt.instancing===!1||!L.isInstancedMesh&&Wt.instancing===!0||L.isSkinnedMesh&&Wt.skinning===!1||!L.isSkinnedMesh&&Wt.skinning===!0||L.isInstancedMesh&&Wt.instancingColor===!0&&L.instanceColor===null||L.isInstancedMesh&&Wt.instancingColor===!1&&L.instanceColor!==null||L.isInstancedMesh&&Wt.instancingMorph===!0&&L.morphTexture===null||L.isInstancedMesh&&Wt.instancingMorph===!1&&L.morphTexture!==null||Wt.envMap!==bt||k.fog===!0&&Wt.fog!==q||Wt.numClippingPlanes!==void 0&&(Wt.numClippingPlanes!==O.numPlanes||Wt.numIntersection!==O.numIntersection)||Wt.vertexAlphas!==St||Wt.vertexTangents!==Nt||Wt.morphTargets!==rt||Wt.morphNormals!==zt||Wt.morphColors!==Dt||Wt.toneMapping!==qt||Wt.morphTargetsCount!==Bt)&&(Et=!0):(Et=!0,Wt.__version=k.version);let Ae=Wt.currentProgram;Et===!0&&(Ae=Ii(k,F,L));let pn=!1,Ne=!1,Tn=!1;const $t=Ae.getUniforms(),De=Wt.uniforms;if(gt.useProgram(Ae.program)&&(pn=!0,Ne=!0,Tn=!0),k.id!==y&&(y=k.id,Ne=!0),pn||g!==X){gt.buffers.depth.getReversed()?(it.copy(X.projectionMatrix),No(it),fo(it),$t.setValue(U,"projectionMatrix",it)):$t.setValue(U,"projectionMatrix",X.projectionMatrix),$t.setValue(U,"viewMatrix",X.matrixWorldInverse);const yl=$t.map.cameraPosition;yl!==void 0&&yl.setValue(U,It.setFromMatrixPosition(X.matrixWorld)),vt.logarithmicDepthBuffer&&$t.setValue(U,"logDepthBufFC",2/(Math.log(X.far+1)/Math.LN2)),(k.isMeshPhongMaterial||k.isMeshToonMaterial||k.isMeshLambertMaterial||k.isMeshBasicMaterial||k.isMeshStandardMaterial||k.isShaderMaterial)&&$t.setValue(U,"isOrthographic",X.isOrthographicCamera===!0),g!==X&&(g=X,Ne=!0,Tn=!0)}if(L.isSkinnedMesh){$t.setOptional(U,L,"bindMatrix"),$t.setOptional(U,L,"bindMatrixInverse");const ve=L.skeleton;ve&&(ve.boneTexture===null&&ve.computeBoneTexture(),$t.setValue(U,"boneTexture",ve.boneTexture,S))}L.isBatchedMesh&&($t.setOptional(U,L,"batchingTexture"),$t.setValue(U,"batchingTexture",L._matricesTexture,S),$t.setOptional(U,L,"batchingIdTexture"),$t.setValue(U,"batchingIdTexture",L._indirectTexture,S),$t.setOptional(U,L,"batchingColorTexture"),L._colorsTexture!==null&&$t.setValue(U,"batchingColorTexture",L._colorsTexture,S));const vn=v.morphAttributes;if((vn.position!==void 0||vn.normal!==void 0||vn.color!==void 0)&&Ct.update(L,v,Ae),(Ne||Wt.receiveShadow!==L.receiveShadow)&&(Wt.receiveShadow=L.receiveShadow,$t.setValue(U,"receiveShadow",L.receiveShadow)),k.isMeshGouraudMaterial&&k.envMap!==null&&(De.envMap.value=bt,De.flipEnvMap.value=bt.isCubeTexture&&bt.isRenderTargetTexture===!1?-1:1),k.isMeshStandardMaterial&&k.envMap===null&&F.environment!==null&&(De.envMapIntensity.value=F.environmentIntensity),Ne&&($t.setValue(U,"toneMappingExposure",G.toneMappingExposure),Wt.needsLights&&Db(De,Tn),q&&k.fog===!0&&at.refreshFogUniforms(De,q),at.refreshMaterialUniforms(De,k,z,$,u.state.transmissionRenderTarget[X.id]),bi.upload(U,Vc(Wt),De,S)),k.isShaderMaterial&&k.uniformsNeedUpdate===!0&&(bi.upload(U,Vc(Wt),De,S),k.uniformsNeedUpdate=!1),k.isSpriteMaterial&&$t.setValue(U,"center",L.center),$t.setValue(U,"modelViewMatrix",L.modelViewMatrix),$t.setValue(U,"normalMatrix",L.normalMatrix),$t.setValue(U,"modelMatrix",L.matrixWorld),k.isShaderMaterial||k.isRawShaderMaterial){const ve=k.uniformsGroups;for(let yl=0,Cl=ve.length;yl<Cl;yl++){const gc=ve[yl];f.update(gc,Ae),f.bind(gc,Ae)}}return Ae}function Db(X,F){X.ambientLightColor.needsUpdate=F,X.lightProbe.needsUpdate=F,X.directionalLights.needsUpdate=F,X.directionalLightShadows.needsUpdate=F,X.pointLights.needsUpdate=F,X.pointLightShadows.needsUpdate=F,X.spotLights.needsUpdate=F,X.spotLightShadows.needsUpdate=F,X.rectAreaLights.needsUpdate=F,X.hemisphereLights.needsUpdate=F}function Ob(X){return X.isMeshLambertMaterial||X.isMeshToonMaterial||X.isMeshPhongMaterial||X.isMeshStandardMaterial||X.isShadowMaterial||X.isShaderMaterial&&X.lights===!0}this.getActiveCubeFace=function(){return I},this.getActiveMipmapLevel=function(){return x},this.getRenderTarget=function(){return M},this.setRenderTargetTextures=function(X,F,v){Xt.get(X.texture).__webglTexture=F,Xt.get(X.depthTexture).__webglTexture=v;const k=Xt.get(X);k.__hasExternalTextures=!0,k.__autoAllocateDepthBuffer=v===void 0,k.__autoAllocateDepthBuffer||Tt.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),k.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(X,F){const v=Xt.get(X);v.__webglFramebuffer=F,v.__useDefaultFramebuffer=F===void 0},this.setRenderTarget=function(X,F=0,v=0){M=X,I=F,x=v;let k=!0,L=null,q=!1,dt=!1;if(X){const bt=Xt.get(X);if(bt.__useDefaultFramebuffer!==void 0)gt.bindFramebuffer(U.FRAMEBUFFER,null),k=!1;else if(bt.__webglFramebuffer===void 0)S.setupRenderTarget(X);else if(bt.__hasExternalTextures)S.rebindTextures(X,Xt.get(X.texture).__webglTexture,Xt.get(X.depthTexture).__webglTexture);else if(X.depthBuffer){const rt=X.depthTexture;if(bt.__boundDepthTexture!==rt){if(rt!==null&&Xt.has(rt)&&(X.width!==rt.image.width||X.height!==rt.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");S.setupDepthRenderbuffer(X)}}const St=X.texture;(St.isData3DTexture||St.isDataArrayTexture||St.isCompressedArrayTexture)&&(dt=!0);const Nt=Xt.get(X).__webglFramebuffer;X.isWebGLCubeRenderTarget?(Array.isArray(Nt[F])?L=Nt[F][v]:L=Nt[F],q=!0):X.samples>0&&S.useMultisampledRTT(X)===!1?L=Xt.get(X).__webglMultisampledFramebuffer:Array.isArray(Nt)?L=Nt[v]:L=Nt,Y.copy(X.viewport),Q.copy(X.scissor),w=X.scissorTest}else Y.copy(Vt).multiplyScalar(z).floor(),Q.copy(Ut).multiplyScalar(z).floor(),w=Pt;if(gt.bindFramebuffer(U.FRAMEBUFFER,L)&&k&&gt.drawBuffers(X,L),gt.viewport(Y),gt.scissor(Q),gt.setScissorTest(w),q){const bt=Xt.get(X.texture);U.framebufferTexture2D(U.FRAMEBUFFER,U.COLOR_ATTACHMENT0,U.TEXTURE_CUBE_MAP_POSITIVE_X+F,bt.__webglTexture,v)}else if(dt){const bt=Xt.get(X.texture),St=F||0;U.framebufferTextureLayer(U.FRAMEBUFFER,U.COLOR_ATTACHMENT0,bt.__webglTexture,v||0,St)}y=-1},this.readRenderTargetPixels=function(X,F,v,k,L,q,dt){if(!(X&&X.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let ut=Xt.get(X).__webglFramebuffer;if(X.isWebGLCubeRenderTarget&&dt!==void 0&&(ut=ut[dt]),ut){gt.bindFramebuffer(U.FRAMEBUFFER,ut);try{const bt=X.texture,St=bt.format,Nt=bt.type;if(!vt.textureFormatReadable(St)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!vt.textureTypeReadable(Nt)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}F>=0&&F<=X.width-k&&v>=0&&v<=X.height-L&&U.readPixels(F,v,k,L,Lt.convert(St),Lt.convert(Nt),q)}finally{const bt=M!==null?Xt.get(M).__webglFramebuffer:null;gt.bindFramebuffer(U.FRAMEBUFFER,bt)}}},this.readRenderTargetPixelsAsync=async function(X,F,v,k,L,q,dt){if(!(X&&X.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let ut=Xt.get(X).__webglFramebuffer;if(X.isWebGLCubeRenderTarget&&dt!==void 0&&(ut=ut[dt]),ut){const bt=X.texture,St=bt.format,Nt=bt.type;if(!vt.textureFormatReadable(St))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!vt.textureTypeReadable(Nt))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");if(F>=0&&F<=X.width-k&&v>=0&&v<=X.height-L){gt.bindFramebuffer(U.FRAMEBUFFER,ut);const rt=U.createBuffer();U.bindBuffer(U.PIXEL_PACK_BUFFER,rt),U.bufferData(U.PIXEL_PACK_BUFFER,q.byteLength,U.STREAM_READ),U.readPixels(F,v,k,L,Lt.convert(St),Lt.convert(Nt),0);const zt=M!==null?Xt.get(M).__webglFramebuffer:null;gt.bindFramebuffer(U.FRAMEBUFFER,zt);const Dt=U.fenceSync(U.SYNC_GPU_COMMANDS_COMPLETE,0);return U.flush(),await Yo(U,Dt,4),U.bindBuffer(U.PIXEL_PACK_BUFFER,rt),U.getBufferSubData(U.PIXEL_PACK_BUFFER,0,q),U.deleteBuffer(rt),U.deleteSync(Dt),q}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")}},this.copyFramebufferToTexture=function(X,F=null,v=0){X.isTexture!==!0&&(Rn("WebGLRenderer: copyFramebufferToTexture function signature has changed."),F=arguments[0]||null,X=arguments[1]);const k=Math.pow(2,-v),L=Math.floor(X.image.width*k),q=Math.floor(X.image.height*k),dt=F!==null?F.x:0,ut=F!==null?F.y:0;S.setTexture2D(X,0),U.copyTexSubImage2D(U.TEXTURE_2D,v,0,0,dt,ut,L,q),gt.unbindTexture()},this.copyTextureToTexture=function(X,F,v=null,k=null,L=0){X.isTexture!==!0&&(Rn("WebGLRenderer: copyTextureToTexture function signature has changed."),k=arguments[0]||null,X=arguments[1],F=arguments[2],L=arguments[3]||0,v=null);let q,dt,ut,bt,St,Nt,rt,zt,Dt;const qt=X.isCompressedTexture?X.mipmaps[L]:X.image;v!==null?(q=v.max.x-v.min.x,dt=v.max.y-v.min.y,ut=v.isBox3?v.max.z-v.min.z:1,bt=v.min.x,St=v.min.y,Nt=v.isBox3?v.min.z:0):(q=qt.width,dt=qt.height,ut=qt.depth||1,bt=0,St=0,Nt=0),k!==null?(rt=k.x,zt=k.y,Dt=k.z):(rt=0,zt=0,Dt=0);const Ie=Lt.convert(F.format),Bt=Lt.convert(F.type);let Wt;F.isData3DTexture?(S.setTexture3D(F,0),Wt=U.TEXTURE_3D):F.isDataArrayTexture||F.isCompressedArrayTexture?(S.setTexture2DArray(F,0),Wt=U.TEXTURE_2D_ARRAY):(S.setTexture2D(F,0),Wt=U.TEXTURE_2D),U.pixelStorei(U.UNPACK_FLIP_Y_WEBGL,F.flipY),U.pixelStorei(U.UNPACK_PREMULTIPLY_ALPHA_WEBGL,F.premultiplyAlpha),U.pixelStorei(U.UNPACK_ALIGNMENT,F.unpackAlignment);const ol=U.getParameter(U.UNPACK_ROW_LENGTH),Et=U.getParameter(U.UNPACK_IMAGE_HEIGHT),Ae=U.getParameter(U.UNPACK_SKIP_PIXELS),pn=U.getParameter(U.UNPACK_SKIP_ROWS),Ne=U.getParameter(U.UNPACK_SKIP_IMAGES);U.pixelStorei(U.UNPACK_ROW_LENGTH,qt.width),U.pixelStorei(U.UNPACK_IMAGE_HEIGHT,qt.height),U.pixelStorei(U.UNPACK_SKIP_PIXELS,bt),U.pixelStorei(U.UNPACK_SKIP_ROWS,St),U.pixelStorei(U.UNPACK_SKIP_IMAGES,Nt);const Tn=X.isDataArrayTexture||X.isData3DTexture,$t=F.isDataArrayTexture||F.isData3DTexture;if(X.isRenderTargetTexture||X.isDepthTexture){const De=Xt.get(X),vn=Xt.get(F),ve=Xt.get(De.__renderTarget),yl=Xt.get(vn.__renderTarget);gt.bindFramebuffer(U.READ_FRAMEBUFFER,ve.__webglFramebuffer),gt.bindFramebuffer(U.DRAW_FRAMEBUFFER,yl.__webglFramebuffer);for(let Cl=0;Cl<ut;Cl++)Tn&&U.framebufferTextureLayer(U.READ_FRAMEBUFFER,U.COLOR_ATTACHMENT0,Xt.get(X).__webglTexture,L,Nt+Cl),X.isDepthTexture?($t&&U.framebufferTextureLayer(U.DRAW_FRAMEBUFFER,U.COLOR_ATTACHMENT0,Xt.get(F).__webglTexture,L,Dt+Cl),U.blitFramebuffer(bt,St,q,dt,rt,zt,q,dt,U.DEPTH_BUFFER_BIT,U.NEAREST)):$t?U.copyTexSubImage3D(Wt,L,rt,zt,Dt+Cl,bt,St,q,dt):U.copyTexSubImage2D(Wt,L,rt,zt,Dt+Cl,bt,St,q,dt);gt.bindFramebuffer(U.READ_FRAMEBUFFER,null),gt.bindFramebuffer(U.DRAW_FRAMEBUFFER,null)}else $t?X.isDataTexture||X.isData3DTexture?U.texSubImage3D(Wt,L,rt,zt,Dt,q,dt,ut,Ie,Bt,qt.data):F.isCompressedArrayTexture?U.compressedTexSubImage3D(Wt,L,rt,zt,Dt,q,dt,ut,Ie,qt.data):U.texSubImage3D(Wt,L,rt,zt,Dt,q,dt,ut,Ie,Bt,qt):X.isDataTexture?U.texSubImage2D(U.TEXTURE_2D,L,rt,zt,q,dt,Ie,Bt,qt.data):X.isCompressedTexture?U.compressedTexSubImage2D(U.TEXTURE_2D,L,rt,zt,qt.width,qt.height,Ie,qt.data):U.texSubImage2D(U.TEXTURE_2D,L,rt,zt,q,dt,Ie,Bt,qt);U.pixelStorei(U.UNPACK_ROW_LENGTH,ol),U.pixelStorei(U.UNPACK_IMAGE_HEIGHT,Et),U.pixelStorei(U.UNPACK_SKIP_PIXELS,Ae),U.pixelStorei(U.UNPACK_SKIP_ROWS,pn),U.pixelStorei(U.UNPACK_SKIP_IMAGES,Ne),L===0&&F.generateMipmaps&&U.generateMipmap(Wt),gt.unbindTexture()},this.copyTextureToTexture3D=function(X,F,v=null,k=null,L=0){return X.isTexture!==!0&&(Rn("WebGLRenderer: copyTextureToTexture3D function signature has changed."),v=arguments[0]||null,k=arguments[1]||null,X=arguments[2],F=arguments[3],L=arguments[4]||0),Rn('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),this.copyTextureToTexture(X,F,v,k,L)},this.initRenderTarget=function(X){Xt.get(X).__webglFramebuffer===void 0&&S.setupRenderTarget(X)},this.initTexture=function(X){X.isCubeTexture?S.setTextureCube(X,0):X.isData3DTexture?S.setTexture3D(X,0):X.isDataArrayTexture||X.isCompressedArrayTexture?S.setTexture2DArray(X,0):S.setTexture2D(X,0),gt.unbindTexture()},this.resetState=function(){I=0,x=0,M=null,gt.reset(),_t.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return tl}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(t){this._outputColorSpace=t;const e=this.getContext();e.drawingBufferColorspace=kt._getDrawingBufferColorSpace(t),e.unpackColorSpace=kt._getUnpackColorSpace()}}class wd extends Ce{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new il,this.environmentIntensity=1,this.environmentRotation=new il,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,this.backgroundRotation.copy(t.backgroundRotation),this.environmentIntensity=t.environmentIntensity,this.environmentRotation.copy(t.environmentRotation),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(e.object.backgroundIntensity=this.backgroundIntensity),e.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(e.object.environmentIntensity=this.environmentIntensity),e.object.environmentRotation=this.environmentRotation.toArray(),e}}class _e extends Se{constructor(t,e,n,i=1){super(t,e,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}class pi extends Yn{static get type(){return"PointsMaterial"}constructor(t){super(),this.isPointsMaterial=!0,this.color=new Kt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const Hd=new ae,Oa=new Hs,Gi=new Dn,Wi=new J;class qa extends Ce{constructor(t=new Me,e=new pi){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,s=t.params.Points.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Gi.copy(n.boundingSphere),Gi.applyMatrix4(i),Gi.radius+=s,t.ray.intersectsSphere(Gi)===!1)return;Hd.copy(i).invert(),Oa.copy(t.ray).applyMatrix4(Hd);const d=s/((this.scale.x+this.scale.y+this.scale.z)/3),c=d*d,o=n.index,m=n.attributes.position;if(o!==null){const b=Math.max(0,a.start),h=Math.min(o.count,a.start+a.count);for(let p=b,V=h;p<V;p++){const r=o.getX(p);Wi.fromBufferAttribute(m,r),zd(Wi,r,c,i,t,e,this)}}else{const b=Math.max(0,a.start),h=Math.min(m.count,a.start+a.count);for(let p=b,V=h;p<V;p++)Wi.fromBufferAttribute(m,p),zd(Wi,p,c,i,t,e,this)}}updateMorphTargets(){const e=this.geometry.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const d=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[d]=s}}}}}function zd(l,t,e,n,i,s,a){const d=Oa.distanceSqToPoint(l);if(d<e){const c=new J;Oa.closestPointToPoint(l,c),c.applyMatrix4(n);const o=i.ray.origin.distanceTo(c);if(o<i.near||o>i.far)return;s.push({distance:o,distanceToRay:Math.sqrt(d),point:c,index:t,face:null,faceIndex:null,barycoord:null,object:a})}}class sb extends ge{constructor(t,e,n,i,s,a,d,c,o){super(t,e,n,i,s,a,d,c,o),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Kd extends Me{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}toJSON(){const t=super.toJSON();return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:xi}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=xi);const $a=100,Vi=new Map;let db=0;const Bd=typeof globalThis.requestAnimationFrame=="function"?l=>globalThis.requestAnimationFrame(l):l=>{const t=++db,e=setTimeout(()=>{Vi.delete(t),l(performance.now())},16);return Vi.set(t,e),t},cb=typeof globalThis.cancelAnimationFrame=="function"?l=>globalThis.cancelAnimationFrame(l):l=>{const t=Vi.get(l);t&&(clearTimeout(t),Vi.delete(l))};function Xi(l,t=l){if(typeof document<"u"&&document.createElement){const e=document.createElement("canvas");e.width=l,e.height=t;const n=e.getContext("2d");if(!n)throw new Error("Unable to get 2D context");return{canvas:e,ctx:n}}if(typeof OffscreenCanvas<"u"){const e=new OffscreenCanvas(l,t),n=e.getContext("2d");if(!n)throw new Error("Unable to get 2D context");return{canvas:e,ctx:n}}throw new Error("Canvas not supported")}function gi(l){return new sb(l)}function Ed(){const{canvas:t,ctx:e}=Xi(32,32),n=e.createRadialGradient(32/2,32/2,0,32/2,32/2,32/2);n.addColorStop(0,"rgba(255, 255, 255, 1)"),n.addColorStop(.4,"rgba(255, 255, 255, 0.5)"),n.addColorStop(1,"rgba(255, 255, 255, 0)"),e.fillStyle=n,e.fillRect(0,0,32,32);const i=gi(t);return i.needsUpdate=!0,i}function ob(){const{canvas:t,ctx:e}=Xi(16,16),n=e.createRadialGradient(16/2,16/2,0,16/2,16/2,16/2);n.addColorStop(0,"rgba(255, 255, 255, 1)"),n.addColorStop(.3,"rgba(255, 255, 255, 0.6)"),n.addColorStop(1,"rgba(255, 255, 255, 0)"),e.fillStyle=n,e.fillRect(0,0,16,16);const i=gi(t);return i.needsUpdate=!0,i}const ts=`
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;class mb{constructor(t){this.canvas=t.canvas,this.viewportWidth=t.viewportWidth,this.viewportHeight=t.viewportHeight,this.devicePixelRatio=t.devicePixelRatio??1,this.isMobile=t.isMobile??!1,this.viewWidth=this.computeViewWidth($a),this.viewHeight=$a,this.camera=this.createCamera(),this.renderer=this.createRenderer(),this.scene=new wd,this.animationFrame=null,this.lastTimestamp=0,this.currentEffect="none",this.activeEffect=null,this.opacity=100,this.effectExtras={},this.lastAppliedExtras={},this.snowSurfaces=[],this.smogOverlay=null,this.windowDropletsOverlay=null,this.lightningOverlay=null,this.auroraOverlay=null,this.renderTarget=null,this.maskScene=null,this.maskCamera=null,this.maskQuad=null,this.renderLoop=e=>this.renderFrame(e)}computeViewWidth(t){return t*(this.viewportWidth/Math.max(1,this.viewportHeight))}createCamera(){const t=this.viewWidth/2,e=this.viewHeight/2,n=new za(-t,t,e,-e,-1e3,1e3);return n.position.z=10,n}createRenderer(){const t=new ab({canvas:this.canvas,alpha:!0,antialias:!this.isMobile,powerPreference:"high-performance",stencil:!1,depth:!1,preserveDrawingBuffer:!1});return t.setPixelRatio(Math.min(this.devicePixelRatio||1,this.isMobile?1:1.5)),t.setSize(this.viewportWidth,this.viewportHeight,!1),t}start(t,e,n={}){this.opacity=Math.max(0,Math.min(100,e)),this.effectExtras=n;const i=this.effectExtras.moonPosition,s=this.lastAppliedExtras.moonPosition,a=i?.x!==s?.x||i?.y!==s?.y,d=this.lastAppliedExtras.windBearing!==this.effectExtras.windBearing||this.lastAppliedExtras.windSpeedKmh!==this.effectExtras.windSpeedKmh,c=this.lastAppliedExtras.snowAccumulation!==this.effectExtras.snowAccumulation||this.lastAppliedExtras.matrixRainColor!==this.effectExtras.matrixRainColor||this.lastAppliedExtras.smogActive!==this.effectExtras.smogActive||this.lastAppliedExtras.windowDroplets!==this.effectExtras.windowDroplets||this.lastAppliedExtras.lightningOverlay!==this.effectExtras.lightningOverlay||this.lastAppliedExtras.cloudCoverage!==this.effectExtras.cloudCoverage||this.lastAppliedExtras.themeMode!==this.effectExtras.themeMode||this.lastAppliedExtras.cloudSpeedMultiplier!==this.effectExtras.cloudSpeedMultiplier||this.lastAppliedExtras.auroraOverlay!==this.effectExtras.auroraOverlay||this.lastAppliedExtras.auroraVisibilityScore!==this.effectExtras.auroraVisibilityScore||this.lastAppliedExtras.auroraVariant!==this.effectExtras.auroraVariant||a||d;if(this.currentEffect===t&&this.activeEffect&&!c){this.activeEffect.setOpacity(this.opacity),this.updateSmogOverlay(),this.updateWindowDropletsOverlay(),this.updateLightningOverlay(),this.updateAuroraOverlay(),this.startLoop();return}this.setEffect(t)}stop(){this.disposeSmogOverlay(),this.disposeWindowDropletsOverlay(),this.disposeLightningOverlay(),this.disposeAuroraOverlay(),this.disposeActiveEffect(),this.currentEffect="none",this.stopLoop(),this.lastAppliedExtras={}}updateSmogOverlay(){const t=!!this.effectExtras.smogActive;t&&!this.smogOverlay?(this.smogOverlay=Cb(this),this.scene.add(this.smogOverlay.group)):!t&&this.smogOverlay?this.disposeSmogOverlay():this.smogOverlay&&this.smogOverlay.setOpacity(this.opacity)}disposeSmogOverlay(){this.smogOverlay&&(this.scene.remove(this.smogOverlay.group),this.smogOverlay.dispose(),this.smogOverlay=null)}updateWindowDropletsOverlay(){const t=!!this.effectExtras.windowDroplets;t&&!this.windowDropletsOverlay?(this.windowDropletsOverlay=yb(this),this.scene.add(this.windowDropletsOverlay.group)):!t&&this.windowDropletsOverlay?this.disposeWindowDropletsOverlay():this.windowDropletsOverlay&&this.windowDropletsOverlay.setOpacity(this.opacity)}disposeWindowDropletsOverlay(){this.windowDropletsOverlay&&(this.scene.remove(this.windowDropletsOverlay.group),this.windowDropletsOverlay.dispose(),this.windowDropletsOverlay=null)}updateLightningOverlay(){const t=this.currentEffect==="rain_storm"&&!!this.effectExtras.lightningData;t&&!this.lightningOverlay?(this.lightningOverlay=jd({viewWidth:this.viewWidth,viewHeight:this.viewHeight,opacity:this.opacity,isMobile:this.isMobile}),this.scene.add(this.lightningOverlay.group)):!t&&this.lightningOverlay?this.disposeLightningOverlay():this.lightningOverlay&&this.lightningOverlay.setOpacity(this.opacity)}disposeLightningOverlay(){this.lightningOverlay&&(this.scene.remove(this.lightningOverlay.group),this.lightningOverlay.dispose(),this.lightningOverlay=null)}updateAuroraOverlay(){const t=this.currentEffect==="stars"&&!!this.effectExtras.auroraOverlay,e=Math.max(0,Math.min(1,this.effectExtras.auroraVisibilityScore??0)),n=this.effectExtras.auroraVariant||"bands",i=this.auroraOverlay&&this.lastAppliedExtras.auroraVariant!==n;t&&(!this.auroraOverlay||i)?(this.auroraOverlay&&this.disposeAuroraOverlay(),this.auroraOverlay=Ib(this,e,n),this.scene.add(this.auroraOverlay.group)):!t&&this.auroraOverlay?this.disposeAuroraOverlay():this.auroraOverlay&&(this.auroraOverlay.setOpacity(this.opacity),this.auroraOverlay.setVisibilityScore?.(e))}disposeAuroraOverlay(){this.auroraOverlay&&(this.scene.remove(this.auroraOverlay.group),this.auroraOverlay.dispose(),this.auroraOverlay=null)}setOpacity(t){this.opacity=Math.max(0,Math.min(100,t)),this.activeEffect?.setOpacity(this.opacity)}setSnowSurfaces(t){this.snowSurfaces=t||[],this.activeEffect?.setSnowSurfaces?.(this.snowSurfaces)}getLastAppliedExtras(){return{...this.lastAppliedExtras}}resize(t){if(this.viewportWidth=t.viewportWidth,this.viewportHeight=t.viewportHeight,this.renderTarget&&this.renderTarget.setSize(this.viewportWidth,this.viewportHeight),this.devicePixelRatio=t.devicePixelRatio??1,this.isMobile=t.isMobile??!1,this.viewWidth=this.computeViewWidth($a),this.camera=this.createCamera(),this.renderer.setPixelRatio(Math.min(this.devicePixelRatio||1,this.isMobile?1:1.5)),this.renderer.setSize(this.viewportWidth,this.viewportHeight,!1),this.activeEffect?.onResize)this.activeEffect.onResize(this.viewWidth,this.viewHeight,this.isMobile,this.viewportWidth,this.viewportHeight),this.activeEffect.setSnowSurfaces?.(this.snowSurfaces);else if(this.currentEffect!=="none"){const e=this.currentEffect;this.currentEffect="none",this.setEffect(e)}}destroy(){this.stop(),this.renderTarget&&(this.renderTarget.dispose(),this.renderTarget=null),this.maskQuad?.material&&this.maskQuad.material.dispose(),this.maskScene?.clear(),this.renderer.dispose(),this.scene.clear()}startLoop(){this.animationFrame==null&&(this.lastTimestamp=0,this.animationFrame=Bd(this.renderLoop))}stopLoop(){this.animationFrame!=null&&(cb(this.animationFrame),this.animationFrame=null)}renderFrame(t){this.lastTimestamp===0&&(this.lastTimestamp=t);const e=Math.min((t-this.lastTimestamp)/1e3,.05);this.lastTimestamp=t,this.activeEffect?.update(e,t/1e3,this.effectExtras),this.smogOverlay?.update(e),this.windowDropletsOverlay?.update(e),this.lightningOverlay?.update(e,t/1e3,this.effectExtras),this.auroraOverlay?.update(e);const n=this.effectExtras.spatialMode==="gradient-mask";n&&(this.ensureGradientMaskPass(),this.renderer.setRenderTarget(this.renderTarget)),this.renderer.render(this.scene,this.camera),n&&(this.renderer.setRenderTarget(null),this.maskQuad.material.uniforms.tDiffuse.value=this.renderTarget.texture,this.renderer.render(this.maskScene,this.maskCamera)),this.animationFrame=Bd(this.renderLoop)}ensureGradientMaskPass(){if(this.renderTarget)return;this.renderTarget=new bl(this.viewportWidth,this.viewportHeight,{minFilter:be,magFilter:be,format:Fe,type:Pe,stencilBuffer:!1}),this.maskCamera=new za(-1,1,1,-1,0,1),this.maskScene=new wd;const t=new te(2,2),e=new ce({uniforms:{tDiffuse:{value:null},uInner:{value:.32},uOuter:{value:.85}},vertexShader:"varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }",fragmentShader:`
        uniform sampler2D tDiffuse;
        uniform float uInner;
        uniform float uOuter;
        varying vec2 vUv;
        void main() {
          vec4 tex = texture2D(tDiffuse, vUv);
          vec2 c = vUv - 0.5;
          float d = length(c) * 2.0;
          float mask = smoothstep(uInner, uOuter, d);
          gl_FragColor = vec4(tex.rgb, tex.a * mask);
        }
      `,transparent:!0,depthWrite:!1});this.maskQuad=new ee(t,e),this.maskScene.add(this.maskQuad)}setEffect(t){if(this.disposeActiveEffect(),this.currentEffect=t,t==="none"){this.stopLoop();return}const e=this.createEffectInstance(t);if(!e){this.stopLoop(),this.currentEffect="none";return}this.activeEffect=e,this.activeEffect.setOpacity(this.opacity),this.snowSurfaces.length&&this.activeEffect.setSnowSurfaces&&this.activeEffect.setSnowSurfaces(this.snowSurfaces),this.scene.add(e.group),this.lastAppliedExtras={...this.effectExtras},this.updateSmogOverlay(),this.updateWindowDropletsOverlay(),this.updateLightningOverlay(),this.updateAuroraOverlay(),this.startLoop()}disposeActiveEffect(){this.activeEffect&&(this.scene.remove(this.activeEffect.group),this.activeEffect.dispose(),this.activeEffect=null)}createEffectInstance(t){const e={viewWidth:this.viewWidth,viewHeight:this.viewHeight,viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,isMobile:this.isMobile,effect:t,opacity:this.opacity,snowAccumulation:!!this.effectExtras.snowAccumulation,snowSurfaces:this.snowSurfaces,matrixRainColor:this.effectExtras.matrixRainColor,moonPosition:this.effectExtras.moonPosition,windBearing:this.effectExtras.windBearing,windSpeedKmh:this.effectExtras.windSpeedKmh,windSwayFactor:this.effectExtras.windSwayFactor,rainMaxTiltDeg:this.effectExtras.rainMaxTiltDeg,rainWindMinKmh:this.effectExtras.rainWindMinKmh,sunPosition:this.effectExtras.sunPosition,cloudCoverage:this.effectExtras.cloudCoverage,precipitationMultiplier:this.effectExtras.precipitationMultiplier??1,themeMode:this.effectExtras.themeMode??"dark",cloudSpeedMultiplier:this.effectExtras.cloudSpeedMultiplier??1};return t==="lightning"?jd(e):t==="sun_beams"?fb(e):t==="stars"?gb(e):t==="matrix"?Vb(e):t==="clouds"?Fb(e):t==="hail"?Lb(e):t.startsWith("rain")?hb(e):t==="snow_layered"?rb(e):t.startsWith("snow")?bb(e):t.startsWith("fog")?Nb(e):null}}function Zb(l,t){const e=t?.6:1;return l==="rain_storm"?{count:Math.floor(600*e),length:{min:1.1,max:1.5},speed:{min:1.4,max:1.9},timeScale:1.2,lightning:!0,lightningOnly:!1}:l==="rain_drizzle"?{count:Math.floor(250*e),length:{min:.6,max:.9},speed:{min:.3,max:.6},timeScale:.6,lightning:!1,lightningOnly:!1}:{count:Math.floor(480*e),length:{min:.9,max:1.2},speed:{min:1,max:1.3},timeScale:1,lightning:!1,lightningOnly:!1}}function hb(l){const t=new he,e=Zb(l.effect,l.isMobile),n=e.count,i=new te(.06,1),s=new Kd;s.index=i.index,s.attributes.position=i.attributes.position,s.attributes.uv=i.attributes.uv,s.instanceCount=n;const a=new Float32Array(n*3),d=new Float32Array(n),c=new Float32Array(n),o=new Float32Array(n),Z=new Float32Array(n);for(let G=0;G<n;G++){const N=G*3;a[N]=jt.randFloatSpread(l.viewWidth+10),a[N+1]=jt.randFloatSpread(l.viewHeight),a[N+2]=Math.random()*.5,d[G]=jt.randFloat(e.speed.min,e.speed.max),c[G]=jt.randFloat(e.length.min,e.length.max),o[G]=jt.randFloat(.5,1.5),Z[G]=Math.random()}s.setAttribute("instanceOffset",new _e(a,3)),s.setAttribute("instanceSpeed",new _e(d,1)),s.setAttribute("instanceLength",new _e(c,1)),s.setAttribute("instanceSway",new _e(o,1)),s.setAttribute("instancePhase",new _e(Z,1));const m=l.rainWindMinKmh??3,b=l.windSwayFactor??.7,h=l.windSpeedKmh??5,p=(l.windBearing??270)*Math.PI/180;let V=0;h>=m&&(V=-Math.sin(p)*h*.06*b);const r=V*.15,u={uTime:{value:0},uOpacity:{value:l.opacity/100},uViewSize:{value:new ft(l.viewWidth,l.viewHeight)},uWindSway:{value:r}},C=new ce({uniforms:u,vertexShader:`
      attribute vec3 instanceOffset;
      attribute float instanceSpeed;
      attribute float instanceLength;
      attribute float instanceSway;
      attribute float instancePhase;
      uniform float uTime;
      uniform vec2 uViewSize;
      uniform float uWindSway;
      varying float vAlpha;
      void main() {
        float progress = fract(uTime * instanceSpeed + instancePhase);
        float travel = (uViewSize.y * 0.5) - progress * (uViewSize.y + 20.0);
        vec3 transformed = position;
        transformed.y *= instanceLength;
        transformed.x += instanceOffset.x + sin(progress * 6.28318 + instancePhase) * instanceSway + uWindSway * progress * uViewSize.y;
        transformed.y += travel + instanceOffset.y;
        transformed.z += -5.0 + instanceOffset.z;
        vAlpha = 1.0 - progress;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
      }
    `,fragmentShader:`
      uniform float uOpacity;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(0.65, 0.75, 0.9, clamp(vAlpha * 0.85 * uOpacity, 0.0, 1.0));
      }
    `,transparent:!0,depthWrite:!1,blending:fe}),R=new ee(s,C);return R.frustumCulled=!1,t.add(R),{group:t,update(G,N,I){const x=I?.precipitationMultiplier??1;u.uTime.value+=G*e.timeScale*x,u.uViewSize.value.set(l.viewWidth,l.viewHeight)},setOpacity(G){u.uOpacity.value=Math.max(0,Math.min(1,G/100))},onResize(G,N){l.viewWidth=G,l.viewHeight=N,u.uViewSize.value.set(G,N)},dispose(){s.dispose(),C.dispose()}}}function ub(l,t){const e=t?.6:1;return Math.floor(l==="snow_storm"?1e3*e:600*e)}function bb(l){const t=new he,e=ub(l.effect,l.isMobile),n=new Float32Array(e*3),i=new Float32Array(e*3),s=l.rainWindMinKmh??3,a=l.windSwayFactor??.7,d=l.windSpeedKmh??5,c=(l.windBearing??270)*Math.PI/180,o=d>=s?-Math.sin(c)*d*.06*a*.8:0;for(let u=0;u<e;u++){const C=u*3;n[C]=jt.randFloatSpread(l.viewWidth+30),n[C+1]=jt.randFloatSpread(l.viewHeight+30),n[C+2]=Math.random()*4-2,i[C]=jt.randFloat(-.2,.2)+o,i[C+1]=l.effect==="snow_storm"?jt.randFloat(-1.4,-.9):jt.randFloat(-.8,-.4),i[C+2]=jt.randFloat(-.05,.05)}const Z=new Me;Z.setAttribute("position",new Se(n,3));const m=Ed(),b=l.effect==="snow_storm"?.9:.75,p=l.themeMode==="light"?16777215:15267071,V=new pi({map:m,transparent:!0,opacity:b*(l.opacity/100),sizeAttenuation:!1,size:l.effect==="snow_storm"?3.4:2.6,color:p,depthWrite:!1,depthTest:!1,blending:fe}),r=new qa(Z,V);return r.frustumCulled=!1,t.add(r),{group:t,update(u){const C=Z.attributes.position.array;for(let R=0;R<C.length;R+=3){C[R]+=i[R]*u*25,C[R+1]+=i[R+1]*u*25,C[R+2]+=i[R+2]*u*10;const G=l.viewWidth/2+15,N=l.viewHeight/2+15;C[R+1]<-N&&(C[R+1]=N,C[R]=jt.randFloatSpread(l.viewWidth+30)),C[R]<-G&&(C[R]=G),C[R]>G&&(C[R]=-G)}Z.attributes.position.needsUpdate=!0},setOpacity(u){V.opacity=b*Math.max(0,Math.min(1,u/100))},onResize(u,C){l.viewWidth=u,l.viewHeight=C},dispose(){Z.dispose(),V.dispose(),m.dispose()}}}const Ad=[{sizeMin:24,sizeMax:40,speedFactor:.12,swayAmpMin:10,swayAmpMax:30,opacity:1,colorMin:255,colorMax:255},{sizeMin:20,sizeMax:28,speedFactor:.09,swayAmpMin:10,swayAmpMax:25,opacity:.85,colorMin:255,colorMax:255},{sizeMin:16,sizeMax:24,speedFactor:.07,swayAmpMin:10,swayAmpMax:20,opacity:.75,colorMin:255,colorMax:255},{sizeMin:12,sizeMax:18,speedFactor:.05,swayAmpMin:10,swayAmpMax:20,opacity:.65,colorMin:220,colorMax:229},{sizeMin:10,sizeMax:14,speedFactor:.03,swayAmpMin:10,swayAmpMax:20,opacity:.55,colorMin:210,colorMax:219},{sizeMin:8,sizeMax:12,speedFactor:.01,swayAmpMin:10,swayAmpMax:20,opacity:.4,colorMin:200,colorMax:209}];function rb(l){const t=new he;let e=l.isMobile?180:300;const n=Math.floor(e/Ad.length),i=Ed(),s=l.rainWindMinKmh??3,a=l.windSwayFactor??.7,d=l.windSpeedKmh??5,c=(l.windBearing??270)*Math.PI/180,o=d>=s?-Math.sin(c)*d*.06*a*.12:0,Z=Ad.map(m=>{const b=new Float32Array(n*3),h=new Float32Array(n),p=new Float32Array(n),V=new Float32Array(n),r=new Float32Array(n);for(let N=0;N<n;N++){const I=N*3,x=m.sizeMin+Math.random()*(m.sizeMax-m.sizeMin);b[I]=jt.randFloatSpread(l.viewWidth+20),b[I+1]=jt.randFloatSpread(l.viewHeight+20),b[I+2]=Math.random()*2-1,h[N]=x*m.speedFactor*.15+Math.random()*.02,p[N]=m.swayAmpMin+Math.random()*(m.swayAmpMax-m.swayAmpMin),V[N]=Math.random()*Math.PI*2,r[N]=.01+Math.random()*.02}const u=new Me;u.setAttribute("position",new Se(b,3));const C=(m.sizeMin+m.sizeMax)/2,R=new pi({map:i,transparent:!0,opacity:m.opacity*(l.opacity/100),sizeAttenuation:!1,size:C*.15,color:16777215,depthWrite:!1,depthTest:!1,blending:fe}),G=new qa(u,R);return G.frustumCulled=!1,t.add(G),{geo:u,mat:R,fallSpeeds:h,swayAmps:p,swayOffsets:V,swaySpeeds:r,baseOpacity:m.opacity}});return{group:t,update(m){Z.forEach(b=>{const h=b.geo.attributes.position.array,p=m*60;for(let V=0;V<h.length/3;V++){const r=V*3;b.swayOffsets[V]+=b.swaySpeeds[V];const u=Math.sin(b.swayOffsets[V])*b.swayAmps[V]*.08;h[r]+=(u+o)*p,h[r+1]-=b.fallSpeeds[V]*p;const C=l.viewWidth/2+15,R=l.viewHeight/2+15;h[r+1]<-R&&(h[r+1]=R,h[r]=jt.randFloatSpread(l.viewWidth+20)),h[r]<-C&&(h[r]=C),h[r]>C&&(h[r]=-C)}b.geo.attributes.position.needsUpdate=!0})},setOpacity(m){const b=Math.max(0,Math.min(1,m/100));Z.forEach(h=>{h.mat.opacity=h.baseOpacity*b})},onResize(m,b){l.viewWidth=m,l.viewHeight=b},dispose(){Z.forEach(m=>{m.geo.dispose(),m.mat.dispose()}),i.dispose()}}}const Qd=["園","迎","簡","益","大","诶","比","西","迪","伊","弗","吉","尺","杰","开","艾","勒","马","娜"],pb="#00ff41",Gb="#00cc33",Wb=85;function Vb(l){const t=new he,e=Math.max(256,Math.floor(l.viewportWidth/2)),n=Math.max(256,Math.floor(l.viewportHeight/2)),{canvas:i,ctx:s}=Xi(e,n),a=gi(i);a.minFilter=be,a.magFilter=be;const d=new te(l.viewWidth,l.viewHeight),c=new Nn({map:a,transparent:!0,opacity:.9*(l.opacity/100),depthWrite:!1}),o=new ee(d,c);t.add(o);const Z=[];let m=0;return{group:t,update(b){const h=i.width,p=i.height,V=h/l.viewportWidth;m+=b*1e3;const r=p/3,u=Z.some(G=>G.y>r);if((Z.length===0||u)&&m>=.8&&Z.length<6){m=0;const G=h*.28,N=h*.72;let I=15,x;do{x=Math.random()<.5?30+Math.random()*(G-60):N+30+Math.random()*(h-N-60);const y=Wb*(h/l.viewportWidth);if(!Z.some(Y=>Math.abs(Y.x-x)<y))break}while(--I>0);if(I>0){const M=4+Math.floor(Math.random()*8);Z.push({x,y:-80,chars:Array.from({length:M},()=>Qd[Math.floor(Math.random()*Qd.length)]),speed:(.15+Math.random()*.12)*V})}}s.fillStyle="rgba(0,0,0,0.08)",s.fillRect(0,0,h,p),s.font=`${Math.max(12,16*V)}px monospace`,s.textAlign="center",s.textBaseline="top";const R=h/2;for(let G=Z.length-1;G>=0;G--){const N=Z[G];if(N.y+=N.speed,N.y>p+150){Z.splice(G,1);continue}const I=Math.abs(N.x-R),x=I<h*.2?.5+I/(h*.2)*.4:.9,M=16*V;for(let y=0;y<N.chars.length;y++){const g=1-y/N.chars.length*.5;s.globalAlpha=g*x,s.fillStyle=y===0?pb:Gb,s.fillText(N.chars[y],N.x,N.y+y*M)}s.globalAlpha=1}a.needsUpdate=!0},setOpacity(b){c.opacity=.9*Math.max(0,Math.min(1,b/100))},onResize(b,h){l.viewWidth=b,l.viewHeight=h,o.geometry.dispose(),o.geometry=new te(b,h)},dispose(){d.dispose(),c.dispose(),a.dispose()}}}function Xb(l){return Math.floor(l?400*.6:400)}function gb(l){const t=new he,e=Xb(l.isMobile),n=new Float32Array(e*3),i=l.moonPosition;for(let m=0;m<e;m++){const b=m*3;n[b]=jt.randFloatSpread(l.viewWidth+20),n[b+1]=jt.randFloatSpread(l.viewHeight+20),n[b+2]=Math.random()*2-1}const s=new Me;s.setAttribute("position",new Se(n,3));const a=ob(),d=new pi({map:a,transparent:!0,opacity:.85*(l.opacity/100),sizeAttenuation:!1,size:2,color:15267071,depthWrite:!1,depthTest:!1,blending:fe}),c=new qa(s,d);c.frustumCulled=!1,t.add(c);let o=null;if(i&&typeof i.x=="number"&&typeof i.y=="number"){const m=(i.x-.5)*l.viewWidth,b=(.5-i.y)*l.viewHeight,h=Math.max(l.viewWidth,l.viewHeight)*.35,p=new te(h,h),V=new ce({uniforms:{uOpacity:{value:.22*(l.opacity/100)}},vertexShader:"varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }",fragmentShader:`
        varying vec2 vUv;
        uniform float uOpacity;
        void main() {
          vec2 c = vUv - 0.5;
          float d = length(c) * 2.0;
          float alpha = exp(-d * d * 2.8) * uOpacity;
          gl_FragColor = vec4(0.96, 0.97, 1.0, alpha);
        }
      `,transparent:!0,depthWrite:!1,blending:fe});o=new ee(p,V),o.position.set(m,b,-1),o.renderOrder=1,t.add(o)}let Z=0;return{group:t,update(m){Z+=m*1.2,d.opacity=.85*(l.opacity/100)*(.8+.2*Math.sin(Z))},setOpacity(m){d.opacity=.85*Math.max(0,Math.min(1,m/100))},onResize(m,b){l.viewWidth=m,l.viewHeight=b},dispose(){s.dispose(),d.dispose(),a.dispose(),o&&(o.geometry.dispose(),o.material.dispose())}}}const Rb=55;function yb(l){const t=l.viewWidth,e=l.viewHeight,{canvas:n,ctx:i}=Xi(Math.max(256,Math.floor(l.viewportWidth/2)),Math.max(256,Math.floor(l.viewportHeight/2))),s=gi(n);s.minFilter=be,s.magFilter=be;const a=new te(t,e),d=new Nn({map:s,transparent:!0,opacity:.95*(l.opacity/100),depthWrite:!1}),c=new ee(a,d);c.renderOrder=5;const o=new he;o.add(c);const Z=[];let m=0,b=0;function h(V,r,u){for(const C of Z){const R=V-C.x,G=r-C.y,N=Rb+(u+C.size)*.5;if(R*R+G*G<N*N)return!0}return!1}function p(){return 2200+Math.random()*2800}return{group:o,update(V){const r=n.width,u=n.height,C=Math.min(V*1e3,50);if(m+=C,b<=0&&(b=p()),m>=b){m=0,b=p();const R=.18,G=r*R,N=r*(1-R),I=Math.random()<.5?"left":"right",x=4+Math.random()*6;let M,y,g=12;do M=I==="left"?Math.random()*G:N+Math.random()*(r-N),y=Math.random()*u*.55;while(--g>0&&h(M,y,x));g>0&&Z.push({x:M,y,size:x,phase:"appear",opacity:0,life:0,appearDur:300,restDur:2e3+Math.random()*2500,slideVel:8+Math.random()*6,slideAccel:.8+Math.random()*.6})}i.clearRect(0,0,r,u);for(let R=Z.length-1;R>=0;R--){const G=Z[R];if(G.life+=C,G.phase==="appear")G.opacity=Math.min(1,G.life/G.appearDur*1.8),G.life>=G.appearDur&&(G.phase="rest",G.life=0,G.opacity=1);else if(G.phase==="rest")G.life>=G.restDur&&(G.phase="slide",G.life=0);else{const N=C/1e3;G.slideVel=(G.slideVel||8)+G.slideAccel*N*60,G.y+=G.slideVel*N;const I=G.y/u;if(G.opacity=I<.85?1:Math.max(0,(1-I)/.15),G.y>u+G.size*2){Z.splice(R,1);continue}}if(G.y<=u+G.size*2){i.save(),i.globalAlpha=G.opacity;const N=i.createRadialGradient(G.x-G.size*.3,G.y-G.size*.3,0,G.x,G.y,G.size*1.5);N.addColorStop(0,"rgba(230, 240, 255, 0.75)"),N.addColorStop(.35,"rgba(200, 218, 242, 0.55)"),N.addColorStop(.7,"rgba(170, 190, 215, 0.25)"),N.addColorStop(1,"rgba(150, 170, 195, 0)"),i.fillStyle=N,i.beginPath(),i.ellipse(G.x,G.y,G.size*.5,G.size*1.1,0,0,Math.PI*2),i.fill();const I=i.createRadialGradient(G.x-G.size*.25,G.y-G.size*.4,0,G.x-G.size*.25,G.y-G.size*.4,G.size*.6);I.addColorStop(0,`rgba(255,255,255,${.6*G.opacity})`),I.addColorStop(.5,`rgba(255,255,255,${.2*G.opacity})`),I.addColorStop(1,"rgba(255,255,255,0)"),i.fillStyle=I,i.beginPath(),i.ellipse(G.x-G.size*.2,G.y-G.size*.35,G.size*.35,G.size*.4,0,0,Math.PI*2),i.fill(),i.restore()}}s.needsUpdate=!0},setOpacity(V){d.opacity=.95*Math.max(0,Math.min(1,V/100))},dispose(){a.dispose(),d.dispose(),s.dispose()}}}function Cb(l){const t=l.viewWidth,e=l.viewHeight,n=new te(t,e),i={uTime:{value:0},uOpacity:{value:.18*(l.opacity/100)},uScale:{value:1.4},uResolution:{value:new ft(t,e)}},s=new ce({uniforms:i,vertexShader:ts,fragmentShader:`
      varying vec2 vUv;
      uniform float uTime;
      uniform float uOpacity;
      uniform float uScale;
      uniform vec2 uResolution;
      float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
      float noise(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(mix(hash(i), hash(i + vec2(1,0)), u.x), mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), u.x), u.y);
      }
      float fbm(vec2 p) {
        float v = 0.0, amp = 0.5;
        for (int i = 0; i < 4; i++) {
          v += amp * noise(p);
          p *= 2.0;
          amp *= 0.5;
        }
        return v;
      }
      void main() {
        vec2 aspect = vec2(uResolution.x / max(uResolution.y, 0.0001), 1.0);
        vec2 uv = (vUv - 0.5) * aspect + 0.5;
        uv *= uScale;
        uv += vec2(0.015, 0.06) * uTime;
        float d = fbm(uv);
        d = smoothstep(0.2, 0.65, d);
        float vMask = smoothstep(0.85, 0.25, vUv.y);
        vec3 color = vec3(0.55, 0.52, 0.48);
        gl_FragColor = vec4(color, d * vMask * uOpacity);
      }
    `,transparent:!0,depthWrite:!1,blending:Qe}),a=new ee(n,s);a.renderOrder=10;const d=new he;return d.add(a),{group:d,update(c){i.uTime.value+=c*.15},setOpacity(c){i.uOpacity.value=.18*Math.max(0,Math.min(1,c/100))},dispose(){n.dispose(),s.dispose()}}}function Sb(l,t){const e=l.viewWidth,n=l.viewHeight,i=new te(e*1.2,n*1.2),s={uTime:{value:0},uOpacity:{value:.5*(t||.5)*(l.opacity/100)},uResolution:{value:new ft(e,n)}},a=new ce({uniforms:s,vertexShader:`
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,fragmentShader:`
      varying vec2 vUv;
      uniform float uTime;
      uniform float uOpacity;
      uniform vec2 uResolution;
      float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
      float noise(vec2 p) {
        vec2 i = floor(p); vec2 f = fract(p);
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(mix(hash(i), hash(i+vec2(1,0)), u.x), mix(hash(i+vec2(0,1)), hash(i+vec2(1,1)), u.x), u.y);
      }
      float fbm(vec2 p) {
        float v = 0.0, amp = 0.5;
        for (int i = 0; i < 4; i++) { v += amp * noise(p); p *= 2.0; amp *= 0.5; }
        return v;
      }
      void main() {
        vec2 uv = vUv;
        float t = uv.x * 0.6 + uv.y * 0.4 + uTime * 0.012;
        float n = fbm(uv * 3.0 + uTime * 0.03);
        t = fract(t + n * 0.15);
        vec3 col;
        if (t < 0.2) col = mix(vec3(0.38, 0.65, 0.98), vec3(0.91, 0.47, 0.98), t * 5.0);
        else if (t < 0.4) col = mix(vec3(0.91, 0.47, 0.98), vec3(0.38, 0.65, 0.98), (t - 0.2) * 5.0);
        else if (t < 0.6) col = mix(vec3(0.38, 0.65, 0.98), vec3(0.37, 0.92, 0.83), (t - 0.4) * 5.0);
        else if (t < 0.8) col = mix(vec3(0.37, 0.92, 0.83), vec3(0.38, 0.65, 0.98), (t - 0.6) * 5.0);
        else col = mix(vec3(0.38, 0.65, 0.98), vec3(0.91, 0.47, 0.98), (t - 0.8) * 5.0);
        vec2 fromTopRight = uv - vec2(1.0, 0.0);
        float dist = length(fromTopRight) * 1.4;
        float mask = 1.0 - smoothstep(0.3, 1.0, dist);
        float alpha = mask * uOpacity * (0.9 + 0.1 * n);
        gl_FragColor = vec4(col, alpha);
      }
    `,transparent:!0,depthWrite:!1,blending:fe}),d=new ee(i,a);d.position.set(0,0,-9),d.renderOrder=9;const c=new he;c.add(d);let o=t||.5;const Z=()=>{const m=.5*o*Math.max(0,Math.min(1,l.opacity/100));s.uOpacity.value=m};return{group:c,update(m){s.uTime.value+=m},setOpacity(){Z()},setVisibilityScore(m){o=m||.5,Z()},dispose(){i.dispose(),a.dispose()}}}const Pd=[{width:1,colorA:[71/255,60/255,120/255],colorB:[247/255,42/255,59/255],speed:1.26},{width:.9,colorA:[24/255,196/255,153/255],colorB:[216/255,240/255,94/255],speed:1.57},{width:.8,colorA:[255/255,221/255,0/255],colorB:[62/255,51/255,255/255],speed:2.09},{width:.7,colorA:[120/255,24/255,72/255],colorB:[242/255,187/255,233/255],speed:3.14},{width:.6,colorA:[66/255,242/255,161/255],colorB:[244/255,246/255,173/255],speed:6.28}];function Ib(l,t,e){if(e==="northern-gradients")return Sb(l,t);const n=l.viewWidth,s=l.viewHeight/2-2,a=5,d=new he,c=`
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,o=`
    varying vec2 vUv;
    uniform float uTime;
    uniform float uOpacity;
    uniform vec3 uColorA;
    uniform vec3 uColorB;
    uniform float uSpeed;
    void main() {
      float t = 0.5 + 0.5 * sin(uTime * uSpeed);
      vec3 col = mix(uColorA, uColorB, t);
      float dist = abs(vUv.y - 0.5) * 2.0;
      float alpha = (1.0 - smoothstep(0.3, 1.0, dist)) * uOpacity;
      gl_FragColor = vec4(col, alpha);
    }
  `;for(let h=0;h<Pd.length;h++){const p=Pd[h],V=n*p.width,r=new te(V,a),u={uTime:{value:0},uOpacity:{value:.4*(t||.5)*(l.opacity/100)},uColorA:{value:new J().fromArray(p.colorA)},uColorB:{value:new J().fromArray(p.colorB)},uSpeed:{value:p.speed}},C=new ce({uniforms:u,vertexShader:c,fragmentShader:o,transparent:!0,depthWrite:!1,blending:fe}),R=new ee(r,C);R.position.set(0,s-h*(a+1),-8),R.renderOrder=9,d.add(R)}let Z=t||.5;const m=d.children,b=()=>{const h=.4*Z*Math.max(0,Math.min(1,l.opacity/100));for(const p of m)p.material.uniforms.uOpacity.value=h};return{group:d,update(h){for(const p of m)p.material.uniforms.uTime.value+=h},setOpacity(){b()},setVisibilityScore(h){Z=h||.5,b()},dispose(){for(const h of m)h.geometry.dispose(),h.material.dispose()}}}function xb(l,t){const e=l==="fog_dense",n=e?.225:.11,i=t?.85:1,s=e?[{scale:1*i,speed:.28,intensity:1,flow:new ft(.08,.02),low:.25,high:.78,contrast:1.1,color:[.86,.89,.95]},{scale:1.6*i,speed:.36,intensity:.85,flow:new ft(-.05,.025),low:.2,high:.7,contrast:1.22,color:[.9,.92,.97]}]:[{scale:1.2*i,speed:.22,intensity:.75,flow:new ft(.05,.015),low:.3,high:.82,contrast:1.15,color:[.88,.91,.96]},{scale:1.9*i,speed:.3,intensity:.55,flow:new ft(-.03,.012),low:.25,high:.75,contrast:1.22,color:[.8,.84,.92]}];return{baseOpacity:n,layers:s}}const Yb=`
  varying vec2 vUv;
  uniform float uTime;
  uniform float uOpacity;
  uniform float uScale;
  uniform vec2 uFlow;
  uniform vec2 uResolution;
  uniform float uLow;
  uniform float uHigh;
  uniform float uContrast;
  uniform vec3 uColor;
  float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123); }
  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(
      mix(hash(i), hash(i + vec2(1,0)), u.x),
      mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), u.x), u.y);
  }
  float fbm(vec2 p) {
    float v = 0.0, amp = 0.5;
    for (int i = 0; i < 5; i++) {
      v += amp * noise(p);
      p *= 2.0;
      amp *= 0.5;
    }
    return v;
  }
  void main() {
    vec2 aspect = vec2(uResolution.x / max(uResolution.y, 0.0001), 1.0);
    vec2 uv = (vUv - 0.5) * aspect + 0.5;
    uv *= uScale;
    uv += uFlow * uTime;
    float primary = fbm(uv);
    float detail = fbm(uv * 1.8 - uFlow.yx * (uTime * 0.35));
    float density = mix(primary, detail, 0.35);
    density = smoothstep(uLow, uHigh, density);
    density = pow(density, uContrast);
    gl_FragColor = vec4(uColor, density * uOpacity);
  }
`;function Nb(l){const t=new he,e=xb(l.effect,l.isMobile),n=l.cloudCoverage,i=n!=null?.6+n/100*.5:1,s=e.layers.map(a=>{const d=new te(l.viewWidth,l.viewHeight),c={uTime:{value:0},uOpacity:{value:e.baseOpacity*a.intensity*(l.opacity/100)*i},uScale:{value:a.scale},uFlow:{value:a.flow.clone()},uResolution:{value:new ft(l.viewWidth,l.viewHeight)},uLow:{value:a.low},uHigh:{value:a.high},uContrast:{value:a.contrast},uColor:{value:new Kt(a.color[0],a.color[1],a.color[2])}},o=new ce({uniforms:c,vertexShader:ts,fragmentShader:Yb,transparent:!0,depthWrite:!1,blending:Qe}),Z=new ee(d,o);return Z.renderOrder=-3,t.add(Z),{mesh:Z,uniforms:c,config:a}});return{group:t,update(a){s.forEach(d=>{d.uniforms.uTime.value+=a*d.config.speed})},setOpacity(a){const d=Math.max(0,Math.min(1,a/100)),c=l.isMobile?.75:1;s.forEach(o=>{o.uniforms.uOpacity.value=e.baseOpacity*o.config.intensity*d*c})},onResize(a,d){l.viewWidth=a,l.viewHeight=d,s.forEach(c=>{c.uniforms.uResolution.value.set(a,d),c.mesh.geometry.dispose(),c.mesh.geometry=new te(a,d)})},dispose(){s.forEach(a=>{a.mesh.geometry.dispose(),a.mesh.material.dispose()})}}}function fb(l){const t=new he;let e=new te(l.viewWidth,l.viewHeight);const n=l.sunPosition||{azimuth:180,elevation:45,uvIndex:3},i=Math.max(0,Math.min(1,(n.azimuth-90)/180)),s=.08+.35*(1-Math.min(90,Math.max(0,n.elevation))/90),a={uTime:{value:0},uOpacity:{value:l.opacity/100},uViewSize:{value:new ft(l.viewWidth,l.viewHeight)},uOrigin:{value:new ft(i,s)},uUvIndex:{value:n.uvIndex}},d=new ce({uniforms:a,vertexShader:"varying vec3 vPosition; void main() { vPosition = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }",fragmentShader:`
      varying vec3 vPosition;
      uniform vec2 uViewSize;
      uniform vec2 uOrigin;
      uniform float uTime;
      uniform float uOpacity;
      uniform float uUvIndex;
      void main() {
        vec2 uv = vec2((vPosition.x / uViewSize.x) + 0.5, (vPosition.y / uViewSize.y) + 0.5);
        vec2 dir = uOrigin - uv;
        float dist = length(dir);
        float angle = atan(dir.y, dir.x);
        float beams = sin(angle * 18.0 + uTime * 0.8) * 0.5 + 0.5;
        float intensity = smoothstep(0.6, 0.0, dist) * beams;
        float alpha = intensity * 0.65 * uOpacity;
        vec3 color;
        if (uUvIndex >= 6.0) {
          color = mix(vec3(1.0, 0.5, 0.15), vec3(1.0, 0.35, 0.1), dist);
        } else if (uUvIndex >= 4.0) {
          color = mix(vec3(1.0, 0.75, 0.35), vec3(1.0, 0.55, 0.2), dist);
        } else {
          color = mix(vec3(1.0, 0.95, 0.8), vec3(1.0, 0.85, 0.4), dist);
        }
        gl_FragColor = vec4(color, alpha);
      }
    `,transparent:!0,depthWrite:!1,blending:fe}),c=new ee(e,d);return c.position.set(0,0,-2),t.add(c),{group:t,update(o,Z,m){if(a.uTime.value+=o,m?.sunPosition){const b=m.sunPosition;a.uOrigin.value.set(Math.max(0,Math.min(1,(b.azimuth-90)/180)),.08+.35*(1-Math.min(90,Math.max(0,b.elevation))/90)),a.uUvIndex.value=b.uvIndex??3}},setOpacity(o){a.uOpacity.value=Math.max(0,Math.min(1,o/100))},onResize(o,Z){l.viewWidth=o,l.viewHeight=Z,a.uViewSize.value.set(o,Z),e.dispose(),e=new te(o,Z),c.geometry=e},dispose(){e.dispose(),d.dispose()}}}function Fb(l){const t=new he,e=.6,n=l.cloudCoverage,i=n!=null?.5+n/100*.5:1,s=l.cloudSpeedMultiplier??1;let a=new te(l.viewWidth,l.viewHeight*e);const d={uTime:{value:0},uOpacity:{value:l.opacity/100*.24*i},uViewSize:{value:new ft(l.viewWidth,l.viewHeight)},uScale:{value:l.isMobile?1.5:1}},c=`
    varying vec2 vUv;
    uniform float uTime;
    uniform float uOpacity;
    uniform float uScale;
    float hash(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
    float noise(vec2 p) {
      vec2 i = floor(p);
      vec2 f = fract(p);
      vec2 u = f * f * (3.0 - 2.0 * f);
      return mix(mix(hash(i), hash(i+vec2(1,0)), u.x), mix(hash(i+vec2(0,1)), hash(i+vec2(1,1)), u.x), u.y);
    }
    float fbm(vec2 p) {
      float v = 0.0, amp = 0.5, freq = 1.0;
      for (int i = 0; i < 6; i++) {
        v += amp * noise(p * freq);
        amp *= 0.5;
        freq *= 2.0;
      }
      return v;
    }
    void main() {
      vec2 uv = vUv * uScale;
      float time = uTime * 0.05;
      vec2 q = vec2(fbm(uv + vec2(time * 0.5, time * 0.2)), fbm(uv + vec2(1.0)));
      vec2 r = vec2(fbm(uv + q + vec2(1.7, 9.2) + 0.15 * time), fbm(uv + q + vec2(8.3, 2.8) + 0.126 * time));
      float f = fbm(uv + r);
      float cloud = smoothstep(0.2, 0.7, f);
      cloud *= smoothstep(0.0, 0.3, vUv.y);
      cloud *= smoothstep(1.0, 0.8, vUv.y);
      float shadow = smoothstep(0.3, 0.6, fbm(uv * 2.0 + r + vec2(0.5)));
      vec3 color = mix(vec3(0.81, 0.82, 0.89), vec3(1.0), shadow * 0.8 + 0.2);
      gl_FragColor = vec4(color, cloud * uOpacity);
    }
  `,o=new ce({uniforms:d,vertexShader:"varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }",fragmentShader:c,transparent:!0,depthWrite:!1,blending:Qe}),Z=new ee(a,o);return Z.position.set(0,l.viewHeight*.25,-6),Z.renderOrder=-2,t.add(Z),{group:t,update(m){d.uTime.value+=m*s},setOpacity(m){d.uOpacity.value=Math.max(0,Math.min(1,m/100))},onResize(m,b,h){a.dispose(),a=new te(m,b*e),Z.geometry=a,d.uViewSize.value.set(m,b),d.uScale.value=h?1.5:1,Z.position.set(0,b*.25,-6)},dispose(){a.dispose(),o.dispose()}}}function jd(l){const t=new he,e=`
    varying vec2 vUv;
    uniform float uFlash;
    uniform vec2 uOrigin;
    uniform float uTime;
    float hash(float n) { return fract(sin(n) * 43758.5453); }
    float jaggedLine(vec2 uv, float anchor, float seed) {
      float segments = 8.0;
      float progress = clamp(1.0 - uv.y, 0.0, 0.999) * segments;
      float idx = floor(progress);
      float frac = fract(progress);
      float offsetA = hash(seed + idx) * 0.24 - 0.12;
      float offsetB = hash(seed + idx + 1.0) * 0.24 - 0.12;
      float offset = mix(offsetA, offsetB, smoothstep(0.0, 1.0, frac));
      float width = mix(0.006, 0.02, hash(seed + idx * 1.7));
      float target = anchor + offset;
      float dist = abs(uv.x - target);
      float intensity = smoothstep(width, 0.0, dist);
      float fade = smoothstep(0.0, 0.9, 1.0 - uv.y);
      return intensity * fade;
    }
    void main() {
      float seed = floor(uTime * 11.0);
      float core = jaggedLine(vUv, uOrigin.x, seed);
      float halo = jaggedLine(vUv, uOrigin.x + 0.008, seed + 2.0) * 0.4;
      float alpha = clamp((core + halo) * uFlash, 0.0, 1.0);
      gl_FragColor = vec4(1.0, 0.98, 0.9, alpha);
    }
  `,n={uFlash:{value:0},uOrigin:{value:new ft(.85,1.05)},uTime:{value:0}};let i=new te(l.viewWidth,l.viewHeight);const s=new ce({uniforms:n,vertexShader:ts,fragmentShader:e,transparent:!0,depthWrite:!1,depthTest:!1,blending:fe}),a=new ee(i,s);a.position.set(0,0,-6),a.renderOrder=25,t.add(a);let d=new te(l.viewWidth,l.viewHeight);const c=new Nn({color:16777215,transparent:!0,opacity:0,depthWrite:!1,depthTest:!1,blending:fe}),o=new ee(d,c);o.position.set(0,0,-8),o.renderOrder=30,t.add(o);const Z=20;let m=jt.randFloat(1,3),b=0,h=.25,p=0,V=-1;const r=Math.max(0,Math.min(1,l.opacity/100)),u=()=>{h=jt.randFloat(.18,.32),b=h,n.uFlash.value=1,n.uOrigin.value.set(jt.randFloat(.6,.95),jt.randFloat(.85,1.05)),c.opacity=Math.max(c.opacity,.55*r+.15)};return{group:t,update(C,R,G){const N=G?.lightningData,I=typeof G?.speed_factor_lightning=="number"?G.speed_factor_lightning:1;if(N&&(N.strikesToTrigger>0||N.distanceKm>0)){if(N.strikesToTrigger>0&&p<=0){const x=N.distanceKm*3;V=R+x,p=Z}V>0&&R>=V&&(V=-1,u()),p=Math.max(0,p-C*I)}else m-=C*I,m<=0&&(m=jt.randFloat(1.5,4),u());if(n.uTime.value+=C,b>0){b-=C;const x=Math.max(0,b/Math.max(h,.001));n.uFlash.value=Math.pow(x,1.4)*r}else n.uFlash.value>0&&(n.uFlash.value=Math.max(0,n.uFlash.value-C*8));c.opacity=Math.max(0,c.opacity-C*6)},setOpacity(C){const R=Math.max(0,Math.min(1,C/100));n.uFlash.value*=R/r},onResize(C,R){l.viewWidth=C,l.viewHeight=R,i.dispose(),i=new te(C,R),a.geometry=i,d.dispose(),d=new te(C,R),o.geometry=d},dispose(){i.dispose(),s.dispose(),d.dispose(),c.dispose()}}}function Lb(l){const t=new he,e=l.isMobile?10:15,n=new te(.25,.25),i=new Kd;i.index=n.index,i.attributes.position=n.attributes.position,i.attributes.uv=n.attributes.uv,i.instanceCount=e;const s=new Float32Array(e*3),a=new Float32Array(e),d=new Float32Array(e),c=new Float32Array(e),o=new Float32Array(e);for(let h=0;h<e;h++){const p=h*3;s[p]=jt.randFloatSpread(l.viewWidth+10),s[p+1]=jt.randFloatSpread(l.viewHeight),s[p+2]=Math.random()*2,a[h]=jt.randFloat(2.8,4),d[h]=jt.randFloat(1.8,2.8),c[h]=Math.random()*Math.PI*2,o[h]=Math.random()}i.setAttribute("instanceOffset",new _e(s,3)),i.setAttribute("instanceSpeed",new _e(a,1)),i.setAttribute("instanceSize",new _e(d,1)),i.setAttribute("instanceRotation",new _e(c,1)),i.setAttribute("instancePhase",new _e(o,1));const Z={uTime:{value:0},uOpacity:{value:l.opacity/100},uViewSize:{value:new ft(l.viewWidth,l.viewHeight)}},m=new ce({uniforms:Z,vertexShader:`
      attribute vec3 instanceOffset;
      attribute float instanceSpeed;
      attribute float instanceSize;
      attribute float instanceRotation;
      attribute float instancePhase;
      uniform float uTime;
      uniform vec2 uViewSize;
      varying float vAlpha;
      void main() {
        float progress = fract(uTime * instanceSpeed + instancePhase);
        float travel = (uViewSize.y * 0.5) - progress * (uViewSize.y + 20.0);
        float angle = instanceRotation + uTime * instanceSpeed * 3.0;
        vec2 rotated = vec2(position.x * cos(angle) - position.y * sin(angle), position.x * sin(angle) + position.y * cos(angle));
        vec3 transformed = vec3(rotated * instanceSize, position.z);
        transformed.x += instanceOffset.x;
        transformed.y += travel + instanceOffset.y;
        transformed.z += -5.0 + instanceOffset.z;
        vAlpha = 1.0;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
      }
    `,fragmentShader:`
      uniform float uOpacity;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(0.95, 0.98, 1.0, vAlpha * uOpacity);
      }
    `,transparent:!0,depthWrite:!1,blending:Qe}),b=new ee(i,m);return b.frustumCulled=!1,t.add(b),{group:t,update(h){Z.uTime.value+=h,Z.uViewSize.value.set(l.viewWidth,l.viewHeight)},setOpacity(h){Z.uOpacity.value=Math.max(0,Math.min(1,h/100))},onResize(h,p){l.viewWidth=h,l.viewHeight=p,Z.uViewSize.value.set(h,p)},dispose(){i.dispose(),m.dispose()}}}const _d="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiOy8qKgogKiBAbGljZW5zZQogKiBDb3B5cmlnaHQgMjAxMC0yMDI0IFRocmVlLmpzIEF1dGhvcnMKICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVAogKi9jb25zdCBOaT0iMTcwIixqdD0iIixidD0ic3JnYiIseG49InNyZ2ItbGluZWFyIixpaT0ibGluZWFyIixxZT0ic3JnYiIseHI9IjMwMCBlcyI7Y2xhc3MgTW57YWRkRXZlbnRMaXN0ZW5lcihlLHQpe3RoaXMuX2xpc3RlbmVycz09PXZvaWQgMCYmKHRoaXMuX2xpc3RlbmVycz17fSk7Y29uc3Qgbj10aGlzLl9saXN0ZW5lcnM7bltlXT09PXZvaWQgMCYmKG5bZV09W10pLG5bZV0uaW5kZXhPZih0KT09PS0xJiZuW2VdLnB1c2godCl9aGFzRXZlbnRMaXN0ZW5lcihlLHQpe2lmKHRoaXMuX2xpc3RlbmVycz09PXZvaWQgMClyZXR1cm4hMTtjb25zdCBuPXRoaXMuX2xpc3RlbmVycztyZXR1cm4gbltlXSE9PXZvaWQgMCYmbltlXS5pbmRleE9mKHQpIT09LTF9cmVtb3ZlRXZlbnRMaXN0ZW5lcihlLHQpe2lmKHRoaXMuX2xpc3RlbmVycz09PXZvaWQgMClyZXR1cm47Y29uc3Qgcj10aGlzLl9saXN0ZW5lcnNbZV07aWYociE9PXZvaWQgMCl7Y29uc3Qgcz1yLmluZGV4T2YodCk7cyE9PS0xJiZyLnNwbGljZShzLDEpfX1kaXNwYXRjaEV2ZW50KGUpe2lmKHRoaXMuX2xpc3RlbmVycz09PXZvaWQgMClyZXR1cm47Y29uc3Qgbj10aGlzLl9saXN0ZW5lcnNbZS50eXBlXTtpZihuIT09dm9pZCAwKXtlLnRhcmdldD10aGlzO2NvbnN0IHI9bi5zbGljZSgwKTtmb3IobGV0IHM9MCxhPXIubGVuZ3RoO3M8YTtzKyspcltzXS5jYWxsKHRoaXMsZSk7ZS50YXJnZXQ9bnVsbH19fWNvbnN0IGZ0PVsiMDAiLCIwMSIsIjAyIiwiMDMiLCIwNCIsIjA1IiwiMDYiLCIwNyIsIjA4IiwiMDkiLCIwYSIsIjBiIiwiMGMiLCIwZCIsIjBlIiwiMGYiLCIxMCIsIjExIiwiMTIiLCIxMyIsIjE0IiwiMTUiLCIxNiIsIjE3IiwiMTgiLCIxOSIsIjFhIiwiMWIiLCIxYyIsIjFkIiwiMWUiLCIxZiIsIjIwIiwiMjEiLCIyMiIsIjIzIiwiMjQiLCIyNSIsIjI2IiwiMjciLCIyOCIsIjI5IiwiMmEiLCIyYiIsIjJjIiwiMmQiLCIyZSIsIjJmIiwiMzAiLCIzMSIsIjMyIiwiMzMiLCIzNCIsIjM1IiwiMzYiLCIzNyIsIjM4IiwiMzkiLCIzYSIsIjNiIiwiM2MiLCIzZCIsIjNlIiwiM2YiLCI0MCIsIjQxIiwiNDIiLCI0MyIsIjQ0IiwiNDUiLCI0NiIsIjQ3IiwiNDgiLCI0OSIsIjRhIiwiNGIiLCI0YyIsIjRkIiwiNGUiLCI0ZiIsIjUwIiwiNTEiLCI1MiIsIjUzIiwiNTQiLCI1NSIsIjU2IiwiNTciLCI1OCIsIjU5IiwiNWEiLCI1YiIsIjVjIiwiNWQiLCI1ZSIsIjVmIiwiNjAiLCI2MSIsIjYyIiwiNjMiLCI2NCIsIjY1IiwiNjYiLCI2NyIsIjY4IiwiNjkiLCI2YSIsIjZiIiwiNmMiLCI2ZCIsIjZlIiwiNmYiLCI3MCIsIjcxIiwiNzIiLCI3MyIsIjc0IiwiNzUiLCI3NiIsIjc3IiwiNzgiLCI3OSIsIjdhIiwiN2IiLCI3YyIsIjdkIiwiN2UiLCI3ZiIsIjgwIiwiODEiLCI4MiIsIjgzIiwiODQiLCI4NSIsIjg2IiwiODciLCI4OCIsIjg5IiwiOGEiLCI4YiIsIjhjIiwiOGQiLCI4ZSIsIjhmIiwiOTAiLCI5MSIsIjkyIiwiOTMiLCI5NCIsIjk1IiwiOTYiLCI5NyIsIjk4IiwiOTkiLCI5YSIsIjliIiwiOWMiLCI5ZCIsIjllIiwiOWYiLCJhMCIsImExIiwiYTIiLCJhMyIsImE0IiwiYTUiLCJhNiIsImE3IiwiYTgiLCJhOSIsImFhIiwiYWIiLCJhYyIsImFkIiwiYWUiLCJhZiIsImIwIiwiYjEiLCJiMiIsImIzIiwiYjQiLCJiNSIsImI2IiwiYjciLCJiOCIsImI5IiwiYmEiLCJiYiIsImJjIiwiYmQiLCJiZSIsImJmIiwiYzAiLCJjMSIsImMyIiwiYzMiLCJjNCIsImM1IiwiYzYiLCJjNyIsImM4IiwiYzkiLCJjYSIsImNiIiwiY2MiLCJjZCIsImNlIiwiY2YiLCJkMCIsImQxIiwiZDIiLCJkMyIsImQ0IiwiZDUiLCJkNiIsImQ3IiwiZDgiLCJkOSIsImRhIiwiZGIiLCJkYyIsImRkIiwiZGUiLCJkZiIsImUwIiwiZTEiLCJlMiIsImUzIiwiZTQiLCJlNSIsImU2IiwiZTciLCJlOCIsImU5IiwiZWEiLCJlYiIsImVjIiwiZWQiLCJlZSIsImVmIiwiZjAiLCJmMSIsImYyIiwiZjMiLCJmNCIsImY1IiwiZjYiLCJmNyIsImY4IiwiZjkiLCJmYSIsImZiIiwiZmMiLCJmZCIsImZlIiwiZmYiXTtsZXQgTXI9MTIzNDU2Nztjb25zdCBIbj1NYXRoLlBJLzE4MCxWbj0xODAvTWF0aC5QSTtmdW5jdGlvbiBTbigpe2NvbnN0IGk9TWF0aC5yYW5kb20oKSo0Mjk0OTY3Mjk1fDAsZT1NYXRoLnJhbmRvbSgpKjQyOTQ5NjcyOTV8MCx0PU1hdGgucmFuZG9tKCkqNDI5NDk2NzI5NXwwLG49TWF0aC5yYW5kb20oKSo0Mjk0OTY3Mjk1fDA7cmV0dXJuKGZ0W2kmMjU1XStmdFtpPj44JjI1NV0rZnRbaT4+MTYmMjU1XStmdFtpPj4yNCYyNTVdKyItIitmdFtlJjI1NV0rZnRbZT4+OCYyNTVdKyItIitmdFtlPj4xNiYxNXw2NF0rZnRbZT4+MjQmMjU1XSsiLSIrZnRbdCY2M3wxMjhdK2Z0W3Q+PjgmMjU1XSsiLSIrZnRbdD4+MTYmMjU1XStmdFt0Pj4yNCYyNTVdK2Z0W24mMjU1XStmdFtuPj44JjI1NV0rZnRbbj4+MTYmMjU1XStmdFtuPj4yNCYyNTVdKS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIGd0KGksZSx0KXtyZXR1cm4gTWF0aC5tYXgoZSxNYXRoLm1pbih0LGkpKX1mdW5jdGlvbiBPaShpLGUpe3JldHVybihpJWUrZSklZX1mdW5jdGlvbiAkcyhpLGUsdCxuLHIpe3JldHVybiBuKyhpLWUpKihyLW4pLyh0LWUpfWZ1bmN0aW9uIEtzKGksZSx0KXtyZXR1cm4gaSE9PWU/KHQtaSkvKGUtaSk6MH1mdW5jdGlvbiBrbihpLGUsdCl7cmV0dXJuKDEtdCkqaSt0KmV9ZnVuY3Rpb24gWnMoaSxlLHQsbil7cmV0dXJuIGtuKGksZSwxLU1hdGguZXhwKC10Km4pKX1mdW5jdGlvbiBqcyhpLGU9MSl7cmV0dXJuIGUtTWF0aC5hYnMoT2koaSxlKjIpLWUpfWZ1bmN0aW9uIEpzKGksZSx0KXtyZXR1cm4gaTw9ZT8wOmk+PXQ/MTooaT0oaS1lKS8odC1lKSxpKmkqKDMtMippKSl9ZnVuY3Rpb24gUXMoaSxlLHQpe3JldHVybiBpPD1lPzA6aT49dD8xOihpPShpLWUpLyh0LWUpLGkqaSppKihpKihpKjYtMTUpKzEwKSl9ZnVuY3Rpb24gZWEoaSxlKXtyZXR1cm4gaStNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKGUtaSsxKSl9ZnVuY3Rpb24gdGEoaSxlKXtyZXR1cm4gaStNYXRoLnJhbmRvbSgpKihlLWkpfWZ1bmN0aW9uIG5hKGkpe3JldHVybiBpKiguNS1NYXRoLnJhbmRvbSgpKX1mdW5jdGlvbiBpYShpKXtpIT09dm9pZCAwJiYoTXI9aSk7bGV0IGU9TXIrPTE4MzE1NjU4MTM7cmV0dXJuIGU9TWF0aC5pbXVsKGVeZT4+PjE1LGV8MSksZV49ZStNYXRoLmltdWwoZV5lPj4+NyxlfDYxKSwoKGVeZT4+PjE0KT4+PjApLzQyOTQ5NjcyOTZ9ZnVuY3Rpb24gcmEoaSl7cmV0dXJuIGkqSG59ZnVuY3Rpb24gc2EoaSl7cmV0dXJuIGkqVm59ZnVuY3Rpb24gYWEoaSl7cmV0dXJuKGkmaS0xKT09PTAmJmkhPT0wfWZ1bmN0aW9uIG9hKGkpe3JldHVybiBNYXRoLnBvdygyLE1hdGguY2VpbChNYXRoLmxvZyhpKS9NYXRoLkxOMikpfWZ1bmN0aW9uIGxhKGkpe3JldHVybiBNYXRoLnBvdygyLE1hdGguZmxvb3IoTWF0aC5sb2coaSkvTWF0aC5MTjIpKX1mdW5jdGlvbiBjYShpLGUsdCxuLHIpe2NvbnN0IHM9TWF0aC5jb3MsYT1NYXRoLnNpbixvPXModC8yKSxsPWEodC8yKSxjPXMoKGUrbikvMiksaD1hKChlK24pLzIpLGQ9cygoZS1uKS8yKSxmPWEoKGUtbikvMikscD1zKChuLWUpLzIpLF89YSgobi1lKS8yKTtzd2l0Y2gocil7Y2FzZSJYWVgiOmkuc2V0KG8qaCxsKmQsbCpmLG8qYyk7YnJlYWs7Y2FzZSJZWlkiOmkuc2V0KGwqZixvKmgsbCpkLG8qYyk7YnJlYWs7Y2FzZSJaWFoiOmkuc2V0KGwqZCxsKmYsbypoLG8qYyk7YnJlYWs7Y2FzZSJYWlgiOmkuc2V0KG8qaCxsKl8sbCpwLG8qYyk7YnJlYWs7Y2FzZSJZWFkiOmkuc2V0KGwqcCxvKmgsbCpfLG8qYyk7YnJlYWs7Y2FzZSJaWVoiOmkuc2V0KGwqXyxsKnAsbypoLG8qYyk7YnJlYWs7ZGVmYXVsdDpjb25zb2xlLndhcm4oIlRIUkVFLk1hdGhVdGlsczogLnNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAiK3IpfX1mdW5jdGlvbiBFbihpLGUpe3N3aXRjaChlLmNvbnN0cnVjdG9yKXtjYXNlIEZsb2F0MzJBcnJheTpyZXR1cm4gaTtjYXNlIFVpbnQzMkFycmF5OnJldHVybiBpLzQyOTQ5NjcyOTU7Y2FzZSBVaW50MTZBcnJheTpyZXR1cm4gaS82NTUzNTtjYXNlIFVpbnQ4QXJyYXk6cmV0dXJuIGkvMjU1O2Nhc2UgSW50MzJBcnJheTpyZXR1cm4gTWF0aC5tYXgoaS8yMTQ3NDgzNjQ3LC0xKTtjYXNlIEludDE2QXJyYXk6cmV0dXJuIE1hdGgubWF4KGkvMzI3NjcsLTEpO2Nhc2UgSW50OEFycmF5OnJldHVybiBNYXRoLm1heChpLzEyNywtMSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgY29tcG9uZW50IHR5cGUuIil9fWZ1bmN0aW9uIF90KGksZSl7c3dpdGNoKGUuY29uc3RydWN0b3Ipe2Nhc2UgRmxvYXQzMkFycmF5OnJldHVybiBpO2Nhc2UgVWludDMyQXJyYXk6cmV0dXJuIE1hdGgucm91bmQoaSo0Mjk0OTY3Mjk1KTtjYXNlIFVpbnQxNkFycmF5OnJldHVybiBNYXRoLnJvdW5kKGkqNjU1MzUpO2Nhc2UgVWludDhBcnJheTpyZXR1cm4gTWF0aC5yb3VuZChpKjI1NSk7Y2FzZSBJbnQzMkFycmF5OnJldHVybiBNYXRoLnJvdW5kKGkqMjE0NzQ4MzY0Nyk7Y2FzZSBJbnQxNkFycmF5OnJldHVybiBNYXRoLnJvdW5kKGkqMzI3NjcpO2Nhc2UgSW50OEFycmF5OnJldHVybiBNYXRoLnJvdW5kKGkqMTI3KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiSW52YWxpZCBjb21wb25lbnQgdHlwZS4iKX19Y29uc3QgJGU9e0RFRzJSQUQ6SG4sUkFEMkRFRzpWbixnZW5lcmF0ZVVVSUQ6U24sY2xhbXA6Z3QsZXVjbGlkZWFuTW9kdWxvOk9pLG1hcExpbmVhcjokcyxpbnZlcnNlTGVycDpLcyxsZXJwOmtuLGRhbXA6WnMscGluZ3Bvbmc6anMsc21vb3Roc3RlcDpKcyxzbW9vdGhlcnN0ZXA6UXMscmFuZEludDplYSxyYW5kRmxvYXQ6dGEscmFuZEZsb2F0U3ByZWFkOm5hLHNlZWRlZFJhbmRvbTppYSxkZWdUb1JhZDpyYSxyYWRUb0RlZzpzYSxpc1Bvd2VyT2ZUd286YWEsY2VpbFBvd2VyT2ZUd286b2EsZmxvb3JQb3dlck9mVHdvOmxhLHNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXI6Y2Esbm9ybWFsaXplOl90LGRlbm9ybWFsaXplOkVufTtjbGFzcyBQZXtjb25zdHJ1Y3RvcihlPTAsdD0wKXtQZS5wcm90b3R5cGUuaXNWZWN0b3IyPSEwLHRoaXMueD1lLHRoaXMueT10fWdldCB3aWR0aCgpe3JldHVybiB0aGlzLnh9c2V0IHdpZHRoKGUpe3RoaXMueD1lfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy55fXNldCBoZWlnaHQoZSl7dGhpcy55PWV9c2V0KGUsdCl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXN9c2V0U2NhbGFyKGUpe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9ZSx0aGlzfXNldFgoZSl7cmV0dXJuIHRoaXMueD1lLHRoaXN9c2V0WShlKXtyZXR1cm4gdGhpcy55PWUsdGhpc31zZXRDb21wb25lbnQoZSx0KXtzd2l0Y2goZSl7Y2FzZSAwOnRoaXMueD10O2JyZWFrO2Nhc2UgMTp0aGlzLnk9dDticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAiK2UpfXJldHVybiB0aGlzfWdldENvbXBvbmVudChlKXtzd2l0Y2goZSl7Y2FzZSAwOnJldHVybiB0aGlzLng7Y2FzZSAxOnJldHVybiB0aGlzLnk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoImluZGV4IGlzIG91dCBvZiByYW5nZTogIitlKX19Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54LHRoaXMueSl9Y29weShlKXtyZXR1cm4gdGhpcy54PWUueCx0aGlzLnk9ZS55LHRoaXN9YWRkKGUpe3JldHVybiB0aGlzLngrPWUueCx0aGlzLnkrPWUueSx0aGlzfWFkZFNjYWxhcihlKXtyZXR1cm4gdGhpcy54Kz1lLHRoaXMueSs9ZSx0aGlzfWFkZFZlY3RvcnMoZSx0KXtyZXR1cm4gdGhpcy54PWUueCt0LngsdGhpcy55PWUueSt0LnksdGhpc31hZGRTY2FsZWRWZWN0b3IoZSx0KXtyZXR1cm4gdGhpcy54Kz1lLngqdCx0aGlzLnkrPWUueSp0LHRoaXN9c3ViKGUpe3JldHVybiB0aGlzLngtPWUueCx0aGlzLnktPWUueSx0aGlzfXN1YlNjYWxhcihlKXtyZXR1cm4gdGhpcy54LT1lLHRoaXMueS09ZSx0aGlzfXN1YlZlY3RvcnMoZSx0KXtyZXR1cm4gdGhpcy54PWUueC10LngsdGhpcy55PWUueS10LnksdGhpc31tdWx0aXBseShlKXtyZXR1cm4gdGhpcy54Kj1lLngsdGhpcy55Kj1lLnksdGhpc31tdWx0aXBseVNjYWxhcihlKXtyZXR1cm4gdGhpcy54Kj1lLHRoaXMueSo9ZSx0aGlzfWRpdmlkZShlKXtyZXR1cm4gdGhpcy54Lz1lLngsdGhpcy55Lz1lLnksdGhpc31kaXZpZGVTY2FsYXIoZSl7cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMS9lKX1hcHBseU1hdHJpeDMoZSl7Y29uc3QgdD10aGlzLngsbj10aGlzLnkscj1lLmVsZW1lbnRzO3JldHVybiB0aGlzLng9clswXSp0K3JbM10qbityWzZdLHRoaXMueT1yWzFdKnQrcls0XSpuK3JbN10sdGhpc31taW4oZSl7cmV0dXJuIHRoaXMueD1NYXRoLm1pbih0aGlzLngsZS54KSx0aGlzLnk9TWF0aC5taW4odGhpcy55LGUueSksdGhpc31tYXgoZSl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0aGlzLngsZS54KSx0aGlzLnk9TWF0aC5tYXgodGhpcy55LGUueSksdGhpc31jbGFtcChlLHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgoZS54LE1hdGgubWluKHQueCx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgoZS55LE1hdGgubWluKHQueSx0aGlzLnkpKSx0aGlzfWNsYW1wU2NhbGFyKGUsdCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heChlLE1hdGgubWluKHQsdGhpcy54KSksdGhpcy55PU1hdGgubWF4KGUsTWF0aC5taW4odCx0aGlzLnkpKSx0aGlzfWNsYW1wTGVuZ3RoKGUsdCl7Y29uc3Qgbj10aGlzLmxlbmd0aCgpO3JldHVybiB0aGlzLmRpdmlkZVNjYWxhcihufHwxKS5tdWx0aXBseVNjYWxhcihNYXRoLm1heChlLE1hdGgubWluKHQsbikpKX1mbG9vcigpe3JldHVybiB0aGlzLng9TWF0aC5mbG9vcih0aGlzLngpLHRoaXMueT1NYXRoLmZsb29yKHRoaXMueSksdGhpc31jZWlsKCl7cmV0dXJuIHRoaXMueD1NYXRoLmNlaWwodGhpcy54KSx0aGlzLnk9TWF0aC5jZWlsKHRoaXMueSksdGhpc31yb3VuZCgpe3JldHVybiB0aGlzLng9TWF0aC5yb3VuZCh0aGlzLngpLHRoaXMueT1NYXRoLnJvdW5kKHRoaXMueSksdGhpc31yb3VuZFRvWmVybygpe3JldHVybiB0aGlzLng9TWF0aC50cnVuYyh0aGlzLngpLHRoaXMueT1NYXRoLnRydW5jKHRoaXMueSksdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy54PS10aGlzLngsdGhpcy55PS10aGlzLnksdGhpc31kb3QoZSl7cmV0dXJuIHRoaXMueCplLngrdGhpcy55KmUueX1jcm9zcyhlKXtyZXR1cm4gdGhpcy54KmUueS10aGlzLnkqZS54fWxlbmd0aFNxKCl7cmV0dXJuIHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueX1sZW5ndGgoKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSl9bWFuaGF0dGFuTGVuZ3RoKCl7cmV0dXJuIE1hdGguYWJzKHRoaXMueCkrTWF0aC5hYnModGhpcy55KX1ub3JtYWxpemUoKXtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKXx8MSl9YW5nbGUoKXtyZXR1cm4gTWF0aC5hdGFuMigtdGhpcy55LC10aGlzLngpK01hdGguUEl9YW5nbGVUbyhlKXtjb25zdCB0PU1hdGguc3FydCh0aGlzLmxlbmd0aFNxKCkqZS5sZW5ndGhTcSgpKTtpZih0PT09MClyZXR1cm4gTWF0aC5QSS8yO2NvbnN0IG49dGhpcy5kb3QoZSkvdDtyZXR1cm4gTWF0aC5hY29zKGd0KG4sLTEsMSkpfWRpc3RhbmNlVG8oZSl7cmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKGUpKX1kaXN0YW5jZVRvU3F1YXJlZChlKXtjb25zdCB0PXRoaXMueC1lLngsbj10aGlzLnktZS55O3JldHVybiB0KnQrbipufW1hbmhhdHRhbkRpc3RhbmNlVG8oZSl7cmV0dXJuIE1hdGguYWJzKHRoaXMueC1lLngpK01hdGguYWJzKHRoaXMueS1lLnkpfXNldExlbmd0aChlKXtyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihlKX1sZXJwKGUsdCl7cmV0dXJuIHRoaXMueCs9KGUueC10aGlzLngpKnQsdGhpcy55Kz0oZS55LXRoaXMueSkqdCx0aGlzfWxlcnBWZWN0b3JzKGUsdCxuKXtyZXR1cm4gdGhpcy54PWUueCsodC54LWUueCkqbix0aGlzLnk9ZS55Kyh0LnktZS55KSpuLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLng9PT10aGlzLngmJmUueT09PXRoaXMueX1mcm9tQXJyYXkoZSx0PTApe3JldHVybiB0aGlzLng9ZVt0XSx0aGlzLnk9ZVt0KzFdLHRoaXN9dG9BcnJheShlPVtdLHQ9MCl7cmV0dXJuIGVbdF09dGhpcy54LGVbdCsxXT10aGlzLnksZX1mcm9tQnVmZmVyQXR0cmlidXRlKGUsdCl7cmV0dXJuIHRoaXMueD1lLmdldFgodCksdGhpcy55PWUuZ2V0WSh0KSx0aGlzfXJvdGF0ZUFyb3VuZChlLHQpe2NvbnN0IG49TWF0aC5jb3ModCkscj1NYXRoLnNpbih0KSxzPXRoaXMueC1lLngsYT10aGlzLnktZS55O3JldHVybiB0aGlzLng9cypuLWEqcitlLngsdGhpcy55PXMqcithKm4rZS55LHRoaXN9cmFuZG9tKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJhbmRvbSgpLHRoaXMueT1NYXRoLnJhbmRvbSgpLHRoaXN9KltTeW1ib2wuaXRlcmF0b3JdKCl7eWllbGQgdGhpcy54LHlpZWxkIHRoaXMueX19Y2xhc3MgYmV7Y29uc3RydWN0b3IoZSx0LG4scixzLGEsbyxsLGMpe2JlLnByb3RvdHlwZS5pc01hdHJpeDM9ITAsdGhpcy5lbGVtZW50cz1bMSwwLDAsMCwxLDAsMCwwLDFdLGUhPT12b2lkIDAmJnRoaXMuc2V0KGUsdCxuLHIscyxhLG8sbCxjKX1zZXQoZSx0LG4scixzLGEsbyxsLGMpe2NvbnN0IGg9dGhpcy5lbGVtZW50cztyZXR1cm4gaFswXT1lLGhbMV09cixoWzJdPW8saFszXT10LGhbNF09cyxoWzVdPWwsaFs2XT1uLGhbN109YSxoWzhdPWMsdGhpc31pZGVudGl0eSgpe3JldHVybiB0aGlzLnNldCgxLDAsMCwwLDEsMCwwLDAsMSksdGhpc31jb3B5KGUpe2NvbnN0IHQ9dGhpcy5lbGVtZW50cyxuPWUuZWxlbWVudHM7cmV0dXJuIHRbMF09blswXSx0WzFdPW5bMV0sdFsyXT1uWzJdLHRbM109blszXSx0WzRdPW5bNF0sdFs1XT1uWzVdLHRbNl09bls2XSx0WzddPW5bN10sdFs4XT1uWzhdLHRoaXN9ZXh0cmFjdEJhc2lzKGUsdCxuKXtyZXR1cm4gZS5zZXRGcm9tTWF0cml4M0NvbHVtbih0aGlzLDApLHQuc2V0RnJvbU1hdHJpeDNDb2x1bW4odGhpcywxKSxuLnNldEZyb21NYXRyaXgzQ29sdW1uKHRoaXMsMiksdGhpc31zZXRGcm9tTWF0cml4NChlKXtjb25zdCB0PWUuZWxlbWVudHM7cmV0dXJuIHRoaXMuc2V0KHRbMF0sdFs0XSx0WzhdLHRbMV0sdFs1XSx0WzldLHRbMl0sdFs2XSx0WzEwXSksdGhpc31tdWx0aXBseShlKXtyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHRoaXMsZSl9cHJlbXVsdGlwbHkoZSl7cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyhlLHRoaXMpfW11bHRpcGx5TWF0cmljZXMoZSx0KXtjb25zdCBuPWUuZWxlbWVudHMscj10LmVsZW1lbnRzLHM9dGhpcy5lbGVtZW50cyxhPW5bMF0sbz1uWzNdLGw9bls2XSxjPW5bMV0saD1uWzRdLGQ9bls3XSxmPW5bMl0scD1uWzVdLF89bls4XSx4PXJbMF0sbT1yWzNdLHU9cls2XSxUPXJbMV0seT1yWzRdLGc9cls3XSxQPXJbMl0sdz1yWzVdLGI9cls4XTtyZXR1cm4gc1swXT1hKngrbypUK2wqUCxzWzNdPWEqbStvKnkrbCp3LHNbNl09YSp1K28qZytsKmIsc1sxXT1jKngraCpUK2QqUCxzWzRdPWMqbStoKnkrZCp3LHNbN109Yyp1K2gqZytkKmIsc1syXT1mKngrcCpUK18qUCxzWzVdPWYqbStwKnkrXyp3LHNbOF09Zip1K3AqZytfKmIsdGhpc31tdWx0aXBseVNjYWxhcihlKXtjb25zdCB0PXRoaXMuZWxlbWVudHM7cmV0dXJuIHRbMF0qPWUsdFszXSo9ZSx0WzZdKj1lLHRbMV0qPWUsdFs0XSo9ZSx0WzddKj1lLHRbMl0qPWUsdFs1XSo9ZSx0WzhdKj1lLHRoaXN9ZGV0ZXJtaW5hbnQoKXtjb25zdCBlPXRoaXMuZWxlbWVudHMsdD1lWzBdLG49ZVsxXSxyPWVbMl0scz1lWzNdLGE9ZVs0XSxvPWVbNV0sbD1lWzZdLGM9ZVs3XSxoPWVbOF07cmV0dXJuIHQqYSpoLXQqbypjLW4qcypoK24qbypsK3IqcypjLXIqYSpsfWludmVydCgpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyx0PWVbMF0sbj1lWzFdLHI9ZVsyXSxzPWVbM10sYT1lWzRdLG89ZVs1XSxsPWVbNl0sYz1lWzddLGg9ZVs4XSxkPWgqYS1vKmMsZj1vKmwtaCpzLHA9YypzLWEqbCxfPXQqZCtuKmYrcipwO2lmKF89PT0wKXJldHVybiB0aGlzLnNldCgwLDAsMCwwLDAsMCwwLDAsMCk7Y29uc3QgeD0xL187cmV0dXJuIGVbMF09ZCp4LGVbMV09KHIqYy1oKm4pKngsZVsyXT0obypuLXIqYSkqeCxlWzNdPWYqeCxlWzRdPShoKnQtcipsKSp4LGVbNV09KHIqcy1vKnQpKngsZVs2XT1wKngsZVs3XT0obipsLWMqdCkqeCxlWzhdPShhKnQtbipzKSp4LHRoaXN9dHJhbnNwb3NlKCl7bGV0IGU7Y29uc3QgdD10aGlzLmVsZW1lbnRzO3JldHVybiBlPXRbMV0sdFsxXT10WzNdLHRbM109ZSxlPXRbMl0sdFsyXT10WzZdLHRbNl09ZSxlPXRbNV0sdFs1XT10WzddLHRbN109ZSx0aGlzfWdldE5vcm1hbE1hdHJpeChlKXtyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4NChlKS5pbnZlcnQoKS50cmFuc3Bvc2UoKX10cmFuc3Bvc2VJbnRvQXJyYXkoZSl7Y29uc3QgdD10aGlzLmVsZW1lbnRzO3JldHVybiBlWzBdPXRbMF0sZVsxXT10WzNdLGVbMl09dFs2XSxlWzNdPXRbMV0sZVs0XT10WzRdLGVbNV09dFs3XSxlWzZdPXRbMl0sZVs3XT10WzVdLGVbOF09dFs4XSx0aGlzfXNldFV2VHJhbnNmb3JtKGUsdCxuLHIscyxhLG8pe2NvbnN0IGw9TWF0aC5jb3MocyksYz1NYXRoLnNpbihzKTtyZXR1cm4gdGhpcy5zZXQobipsLG4qYywtbioobCphK2MqbykrYStlLC1yKmMscipsLC1yKigtYyphK2wqbykrbyt0LDAsMCwxKSx0aGlzfXNjYWxlKGUsdCl7cmV0dXJuIHRoaXMucHJlbXVsdGlwbHkoQmkubWFrZVNjYWxlKGUsdCkpLHRoaXN9cm90YXRlKGUpe3JldHVybiB0aGlzLnByZW11bHRpcGx5KEJpLm1ha2VSb3RhdGlvbigtZSkpLHRoaXN9dHJhbnNsYXRlKGUsdCl7cmV0dXJuIHRoaXMucHJlbXVsdGlwbHkoQmkubWFrZVRyYW5zbGF0aW9uKGUsdCkpLHRoaXN9bWFrZVRyYW5zbGF0aW9uKGUsdCl7cmV0dXJuIGUuaXNWZWN0b3IyP3RoaXMuc2V0KDEsMCxlLngsMCwxLGUueSwwLDAsMSk6dGhpcy5zZXQoMSwwLGUsMCwxLHQsMCwwLDEpLHRoaXN9bWFrZVJvdGF0aW9uKGUpe2NvbnN0IHQ9TWF0aC5jb3MoZSksbj1NYXRoLnNpbihlKTtyZXR1cm4gdGhpcy5zZXQodCwtbiwwLG4sdCwwLDAsMCwxKSx0aGlzfW1ha2VTY2FsZShlLHQpe3JldHVybiB0aGlzLnNldChlLDAsMCwwLHQsMCwwLDAsMSksdGhpc31lcXVhbHMoZSl7Y29uc3QgdD10aGlzLmVsZW1lbnRzLG49ZS5lbGVtZW50cztmb3IobGV0IHI9MDtyPDk7cisrKWlmKHRbcl0hPT1uW3JdKXJldHVybiExO3JldHVybiEwfWZyb21BcnJheShlLHQ9MCl7Zm9yKGxldCBuPTA7bjw5O24rKyl0aGlzLmVsZW1lbnRzW25dPWVbbit0XTtyZXR1cm4gdGhpc310b0FycmF5KGU9W10sdD0wKXtjb25zdCBuPXRoaXMuZWxlbWVudHM7cmV0dXJuIGVbdF09blswXSxlW3QrMV09blsxXSxlW3QrMl09blsyXSxlW3QrM109blszXSxlW3QrNF09bls0XSxlW3QrNV09bls1XSxlW3QrNl09bls2XSxlW3QrN109bls3XSxlW3QrOF09bls4XSxlfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KHRoaXMuZWxlbWVudHMpfX1jb25zdCBCaT1uZXcgYmU7ZnVuY3Rpb24gU3IoaSl7Zm9yKGxldCBlPWkubGVuZ3RoLTE7ZT49MDstLWUpaWYoaVtlXT49NjU1MzUpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gcmkoaSl7cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIsaSl9ZnVuY3Rpb24gdWEoKXtjb25zdCBpPXJpKCJjYW52YXMiKTtyZXR1cm4gaS5zdHlsZS5kaXNwbGF5PSJibG9jayIsaX1jb25zdCBFcj17fTtmdW5jdGlvbiBXbihpKXtpIGluIEVyfHwoRXJbaV09ITAsY29uc29sZS53YXJuKGkpKX1mdW5jdGlvbiBoYShpLGUsdCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4scil7ZnVuY3Rpb24gcygpe3N3aXRjaChpLmNsaWVudFdhaXRTeW5jKGUsaS5TWU5DX0ZMVVNIX0NPTU1BTkRTX0JJVCwwKSl7Y2FzZSBpLldBSVRfRkFJTEVEOnIoKTticmVhaztjYXNlIGkuVElNRU9VVF9FWFBJUkVEOnNldFRpbWVvdXQocyx0KTticmVhaztkZWZhdWx0Om4oKX19c2V0VGltZW91dChzLHQpfSl9ZnVuY3Rpb24gZGEoaSl7Y29uc3QgZT1pLmVsZW1lbnRzO2VbMl09LjUqZVsyXSsuNSplWzNdLGVbNl09LjUqZVs2XSsuNSplWzddLGVbMTBdPS41KmVbMTBdKy41KmVbMTFdLGVbMTRdPS41KmVbMTRdKy41KmVbMTVdfWZ1bmN0aW9uIGZhKGkpe2NvbnN0IGU9aS5lbGVtZW50cztlWzExXT09PS0xPyhlWzEwXT0tZVsxMF0tMSxlWzE0XT0tZVsxNF0pOihlWzEwXT0tZVsxMF0sZVsxNF09LWVbMTRdKzEpfWNvbnN0IEJlPXtlbmFibGVkOiEwLHdvcmtpbmdDb2xvclNwYWNlOnhuLHNwYWNlczp7fSxjb252ZXJ0OmZ1bmN0aW9uKGksZSx0KXtyZXR1cm4gdGhpcy5lbmFibGVkPT09ITF8fGU9PT10fHwhZXx8IXR8fCh0aGlzLnNwYWNlc1tlXS50cmFuc2Zlcj09PXFlJiYoaS5yPVZ0KGkuciksaS5nPVZ0KGkuZyksaS5iPVZ0KGkuYikpLHRoaXMuc3BhY2VzW2VdLnByaW1hcmllcyE9PXRoaXMuc3BhY2VzW3RdLnByaW1hcmllcyYmKGkuYXBwbHlNYXRyaXgzKHRoaXMuc3BhY2VzW2VdLnRvWFlaKSxpLmFwcGx5TWF0cml4Myh0aGlzLnNwYWNlc1t0XS5mcm9tWFlaKSksdGhpcy5zcGFjZXNbdF0udHJhbnNmZXI9PT1xZSYmKGkucj15bihpLnIpLGkuZz15bihpLmcpLGkuYj15bihpLmIpKSksaX0sZnJvbVdvcmtpbmdDb2xvclNwYWNlOmZ1bmN0aW9uKGksZSl7cmV0dXJuIHRoaXMuY29udmVydChpLHRoaXMud29ya2luZ0NvbG9yU3BhY2UsZSl9LHRvV29ya2luZ0NvbG9yU3BhY2U6ZnVuY3Rpb24oaSxlKXtyZXR1cm4gdGhpcy5jb252ZXJ0KGksZSx0aGlzLndvcmtpbmdDb2xvclNwYWNlKX0sZ2V0UHJpbWFyaWVzOmZ1bmN0aW9uKGkpe3JldHVybiB0aGlzLnNwYWNlc1tpXS5wcmltYXJpZXN9LGdldFRyYW5zZmVyOmZ1bmN0aW9uKGkpe3JldHVybiBpPT09anQ/aWk6dGhpcy5zcGFjZXNbaV0udHJhbnNmZXJ9LGdldEx1bWluYW5jZUNvZWZmaWNpZW50czpmdW5jdGlvbihpLGU9dGhpcy53b3JraW5nQ29sb3JTcGFjZSl7cmV0dXJuIGkuZnJvbUFycmF5KHRoaXMuc3BhY2VzW2VdLmx1bWluYW5jZUNvZWZmaWNpZW50cyl9LGRlZmluZTpmdW5jdGlvbihpKXtPYmplY3QuYXNzaWduKHRoaXMuc3BhY2VzLGkpfSxfZ2V0TWF0cml4OmZ1bmN0aW9uKGksZSx0KXtyZXR1cm4gaS5jb3B5KHRoaXMuc3BhY2VzW2VdLnRvWFlaKS5tdWx0aXBseSh0aGlzLnNwYWNlc1t0XS5mcm9tWFlaKX0sX2dldERyYXdpbmdCdWZmZXJDb2xvclNwYWNlOmZ1bmN0aW9uKGkpe3JldHVybiB0aGlzLnNwYWNlc1tpXS5vdXRwdXRDb2xvclNwYWNlQ29uZmlnLmRyYXdpbmdCdWZmZXJDb2xvclNwYWNlfSxfZ2V0VW5wYWNrQ29sb3JTcGFjZTpmdW5jdGlvbihpPXRoaXMud29ya2luZ0NvbG9yU3BhY2Upe3JldHVybiB0aGlzLnNwYWNlc1tpXS53b3JraW5nQ29sb3JTcGFjZUNvbmZpZy51bnBhY2tDb2xvclNwYWNlfX07ZnVuY3Rpb24gVnQoaSl7cmV0dXJuIGk8LjA0MDQ1P2kqLjA3NzM5OTM4MDg6TWF0aC5wb3coaSouOTQ3ODY3Mjk4NisuMDUyMTMyNzAxNCwyLjQpfWZ1bmN0aW9uIHluKGkpe3JldHVybiBpPC4wMDMxMzA4P2kqMTIuOTI6MS4wNTUqTWF0aC5wb3coaSwuNDE2NjYpLS4wNTV9Y29uc3QgeXI9Wy42NCwuMzMsLjMsLjYsLjE1LC4wNl0sVHI9Wy4yMTI2LC43MTUyLC4wNzIyXSxBcj1bLjMxMjcsLjMyOV0sd3I9bmV3IGJlKCkuc2V0KC40MTIzOTA4LC4zNTc1ODQzLC4xODA0ODA4LC4yMTI2MzksLjcxNTE2ODcsLjA3MjE5MjMsLjAxOTMzMDgsLjExOTE5NDgsLjk1MDUzMjIpLGJyPW5ldyBiZSgpLnNldCgzLjI0MDk2OTksLTEuNTM3MzgzMiwtLjQ5ODYxMDgsLS45NjkyNDM2LDEuODc1OTY3NSwuMDQxNTU1MSwuMDU1NjMwMSwtLjIwMzk3NywxLjA1Njk3MTUpO0JlLmRlZmluZSh7W3huXTp7cHJpbWFyaWVzOnlyLHdoaXRlUG9pbnQ6QXIsdHJhbnNmZXI6aWksdG9YWVo6d3IsZnJvbVhZWjpicixsdW1pbmFuY2VDb2VmZmljaWVudHM6VHIsd29ya2luZ0NvbG9yU3BhY2VDb25maWc6e3VucGFja0NvbG9yU3BhY2U6YnR9LG91dHB1dENvbG9yU3BhY2VDb25maWc6e2RyYXdpbmdCdWZmZXJDb2xvclNwYWNlOmJ0fX0sW2J0XTp7cHJpbWFyaWVzOnlyLHdoaXRlUG9pbnQ6QXIsdHJhbnNmZXI6cWUsdG9YWVo6d3IsZnJvbVhZWjpicixsdW1pbmFuY2VDb2VmZmljaWVudHM6VHIsb3V0cHV0Q29sb3JTcGFjZUNvbmZpZzp7ZHJhd2luZ0J1ZmZlckNvbG9yU3BhY2U6YnR9fX0pO2xldCBUbjtjbGFzcyBwYXtzdGF0aWMgZ2V0RGF0YVVSTChlKXtpZigvXmRhdGE6L2kudGVzdChlLnNyYyl8fHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudD4idSIpcmV0dXJuIGUuc3JjO2xldCB0O2lmKGUgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCl0PWU7ZWxzZXtUbj09PXZvaWQgMCYmKFRuPXJpKCJjYW52YXMiKSksVG4ud2lkdGg9ZS53aWR0aCxUbi5oZWlnaHQ9ZS5oZWlnaHQ7Y29uc3Qgbj1Ubi5nZXRDb250ZXh0KCIyZCIpO2UgaW5zdGFuY2VvZiBJbWFnZURhdGE/bi5wdXRJbWFnZURhdGEoZSwwLDApOm4uZHJhd0ltYWdlKGUsMCwwLGUud2lkdGgsZS5oZWlnaHQpLHQ9VG59cmV0dXJuIHQud2lkdGg+MjA0OHx8dC5oZWlnaHQ+MjA0OD8oY29uc29sZS53YXJuKCJUSFJFRS5JbWFnZVV0aWxzLmdldERhdGFVUkw6IEltYWdlIGNvbnZlcnRlZCB0byBqcGcgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMiLGUpLHQudG9EYXRhVVJMKCJpbWFnZS9qcGVnIiwuNikpOnQudG9EYXRhVVJMKCJpbWFnZS9wbmciKX1zdGF0aWMgc1JHQlRvTGluZWFyKGUpe2lmKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50PCJ1IiYmZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnR8fHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudDwidSImJmUgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudHx8dHlwZW9mIEltYWdlQml0bWFwPCJ1IiYmZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKXtjb25zdCB0PXJpKCJjYW52YXMiKTt0LndpZHRoPWUud2lkdGgsdC5oZWlnaHQ9ZS5oZWlnaHQ7Y29uc3Qgbj10LmdldENvbnRleHQoIjJkIik7bi5kcmF3SW1hZ2UoZSwwLDAsZS53aWR0aCxlLmhlaWdodCk7Y29uc3Qgcj1uLmdldEltYWdlRGF0YSgwLDAsZS53aWR0aCxlLmhlaWdodCkscz1yLmRhdGE7Zm9yKGxldCBhPTA7YTxzLmxlbmd0aDthKyspc1thXT1WdChzW2FdLzI1NSkqMjU1O3JldHVybiBuLnB1dEltYWdlRGF0YShyLDAsMCksdH1lbHNlIGlmKGUuZGF0YSl7Y29uc3QgdD1lLmRhdGEuc2xpY2UoMCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheT90W25dPU1hdGguZmxvb3IoVnQodFtuXS8yNTUpKjI1NSk6dFtuXT1WdCh0W25dKTtyZXR1cm57ZGF0YTp0LHdpZHRoOmUud2lkdGgsaGVpZ2h0OmUuaGVpZ2h0fX1lbHNlIHJldHVybiBjb25zb2xlLndhcm4oIlRIUkVFLkltYWdlVXRpbHMuc1JHQlRvTGluZWFyKCk6IFVuc3VwcG9ydGVkIGltYWdlIHR5cGUuIE5vIGNvbG9yIHNwYWNlIGNvbnZlcnNpb24gYXBwbGllZC4iKSxlfX1sZXQgbWE9MDtjbGFzcyBScntjb25zdHJ1Y3RvcihlPW51bGwpe3RoaXMuaXNTb3VyY2U9ITAsT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImlkIix7dmFsdWU6bWErK30pLHRoaXMudXVpZD1TbigpLHRoaXMuZGF0YT1lLHRoaXMuZGF0YVJlYWR5PSEwLHRoaXMudmVyc2lvbj0wfXNldCBuZWVkc1VwZGF0ZShlKXtlPT09ITAmJnRoaXMudmVyc2lvbisrfXRvSlNPTihlKXtjb25zdCB0PWU9PT12b2lkIDB8fHR5cGVvZiBlPT0ic3RyaW5nIjtpZighdCYmZS5pbWFnZXNbdGhpcy51dWlkXSE9PXZvaWQgMClyZXR1cm4gZS5pbWFnZXNbdGhpcy51dWlkXTtjb25zdCBuPXt1dWlkOnRoaXMudXVpZCx1cmw6IiJ9LHI9dGhpcy5kYXRhO2lmKHIhPT1udWxsKXtsZXQgcztpZihBcnJheS5pc0FycmF5KHIpKXtzPVtdO2ZvcihsZXQgYT0wLG89ci5sZW5ndGg7YTxvO2ErKylyW2FdLmlzRGF0YVRleHR1cmU/cy5wdXNoKHppKHJbYV0uaW1hZ2UpKTpzLnB1c2goemkoclthXSkpfWVsc2Ugcz16aShyKTtuLnVybD1zfXJldHVybiB0fHwoZS5pbWFnZXNbdGhpcy51dWlkXT1uKSxufX1mdW5jdGlvbiB6aShpKXtyZXR1cm4gdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQ8InUiJiZpIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudHx8dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50PCJ1IiYmaSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50fHx0eXBlb2YgSW1hZ2VCaXRtYXA8InUiJiZpIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXA/cGEuZ2V0RGF0YVVSTChpKTppLmRhdGE/e2RhdGE6QXJyYXkuZnJvbShpLmRhdGEpLHdpZHRoOmkud2lkdGgsaGVpZ2h0OmkuaGVpZ2h0LHR5cGU6aS5kYXRhLmNvbnN0cnVjdG9yLm5hbWV9Oihjb25zb2xlLndhcm4oIlRIUkVFLlRleHR1cmU6IFVuYWJsZSB0byBzZXJpYWxpemUgVGV4dHVyZS4iKSx7fSl9bGV0IGdhPTA7Y2xhc3MgdnQgZXh0ZW5kcyBNbntjb25zdHJ1Y3RvcihlPXZ0LkRFRkFVTFRfSU1BR0UsdD12dC5ERUZBVUxUX01BUFBJTkcsbj0xMDAxLHI9MTAwMSxzPTEwMDYsYT0xMDA4LG89MTAyMyxsPTEwMDksYz12dC5ERUZBVUxUX0FOSVNPVFJPUFksaD1qdCl7c3VwZXIoKSx0aGlzLmlzVGV4dHVyZT0hMCxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiaWQiLHt2YWx1ZTpnYSsrfSksdGhpcy51dWlkPVNuKCksdGhpcy5uYW1lPSIiLHRoaXMuc291cmNlPW5ldyBScihlKSx0aGlzLm1pcG1hcHM9W10sdGhpcy5tYXBwaW5nPXQsdGhpcy5jaGFubmVsPTAsdGhpcy53cmFwUz1uLHRoaXMud3JhcFQ9cix0aGlzLm1hZ0ZpbHRlcj1zLHRoaXMubWluRmlsdGVyPWEsdGhpcy5hbmlzb3Ryb3B5PWMsdGhpcy5mb3JtYXQ9byx0aGlzLmludGVybmFsRm9ybWF0PW51bGwsdGhpcy50eXBlPWwsdGhpcy5vZmZzZXQ9bmV3IFBlKDAsMCksdGhpcy5yZXBlYXQ9bmV3IFBlKDEsMSksdGhpcy5jZW50ZXI9bmV3IFBlKDAsMCksdGhpcy5yb3RhdGlvbj0wLHRoaXMubWF0cml4QXV0b1VwZGF0ZT0hMCx0aGlzLm1hdHJpeD1uZXcgYmUsdGhpcy5nZW5lcmF0ZU1pcG1hcHM9ITAsdGhpcy5wcmVtdWx0aXBseUFscGhhPSExLHRoaXMuZmxpcFk9ITAsdGhpcy51bnBhY2tBbGlnbm1lbnQ9NCx0aGlzLmNvbG9yU3BhY2U9aCx0aGlzLnVzZXJEYXRhPXt9LHRoaXMudmVyc2lvbj0wLHRoaXMub25VcGRhdGU9bnVsbCx0aGlzLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hMSx0aGlzLnBtcmVtVmVyc2lvbj0wfWdldCBpbWFnZSgpe3JldHVybiB0aGlzLnNvdXJjZS5kYXRhfXNldCBpbWFnZShlPW51bGwpe3RoaXMuc291cmNlLmRhdGE9ZX11cGRhdGVNYXRyaXgoKXt0aGlzLm1hdHJpeC5zZXRVdlRyYW5zZm9ybSh0aGlzLm9mZnNldC54LHRoaXMub2Zmc2V0LnksdGhpcy5yZXBlYXQueCx0aGlzLnJlcGVhdC55LHRoaXMucm90YXRpb24sdGhpcy5jZW50ZXIueCx0aGlzLmNlbnRlci55KX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9Y29weShlKXtyZXR1cm4gdGhpcy5uYW1lPWUubmFtZSx0aGlzLnNvdXJjZT1lLnNvdXJjZSx0aGlzLm1pcG1hcHM9ZS5taXBtYXBzLnNsaWNlKDApLHRoaXMubWFwcGluZz1lLm1hcHBpbmcsdGhpcy5jaGFubmVsPWUuY2hhbm5lbCx0aGlzLndyYXBTPWUud3JhcFMsdGhpcy53cmFwVD1lLndyYXBULHRoaXMubWFnRmlsdGVyPWUubWFnRmlsdGVyLHRoaXMubWluRmlsdGVyPWUubWluRmlsdGVyLHRoaXMuYW5pc290cm9weT1lLmFuaXNvdHJvcHksdGhpcy5mb3JtYXQ9ZS5mb3JtYXQsdGhpcy5pbnRlcm5hbEZvcm1hdD1lLmludGVybmFsRm9ybWF0LHRoaXMudHlwZT1lLnR5cGUsdGhpcy5vZmZzZXQuY29weShlLm9mZnNldCksdGhpcy5yZXBlYXQuY29weShlLnJlcGVhdCksdGhpcy5jZW50ZXIuY29weShlLmNlbnRlciksdGhpcy5yb3RhdGlvbj1lLnJvdGF0aW9uLHRoaXMubWF0cml4QXV0b1VwZGF0ZT1lLm1hdHJpeEF1dG9VcGRhdGUsdGhpcy5tYXRyaXguY29weShlLm1hdHJpeCksdGhpcy5nZW5lcmF0ZU1pcG1hcHM9ZS5nZW5lcmF0ZU1pcG1hcHMsdGhpcy5wcmVtdWx0aXBseUFscGhhPWUucHJlbXVsdGlwbHlBbHBoYSx0aGlzLmZsaXBZPWUuZmxpcFksdGhpcy51bnBhY2tBbGlnbm1lbnQ9ZS51bnBhY2tBbGlnbm1lbnQsdGhpcy5jb2xvclNwYWNlPWUuY29sb3JTcGFjZSx0aGlzLnVzZXJEYXRhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZS51c2VyRGF0YSkpLHRoaXMubmVlZHNVcGRhdGU9ITAsdGhpc310b0pTT04oZSl7Y29uc3QgdD1lPT09dm9pZCAwfHx0eXBlb2YgZT09InN0cmluZyI7aWYoIXQmJmUudGV4dHVyZXNbdGhpcy51dWlkXSE9PXZvaWQgMClyZXR1cm4gZS50ZXh0dXJlc1t0aGlzLnV1aWRdO2NvbnN0IG49e21ldGFkYXRhOnt2ZXJzaW9uOjQuNix0eXBlOiJUZXh0dXJlIixnZW5lcmF0b3I6IlRleHR1cmUudG9KU09OIn0sdXVpZDp0aGlzLnV1aWQsbmFtZTp0aGlzLm5hbWUsaW1hZ2U6dGhpcy5zb3VyY2UudG9KU09OKGUpLnV1aWQsbWFwcGluZzp0aGlzLm1hcHBpbmcsY2hhbm5lbDp0aGlzLmNoYW5uZWwscmVwZWF0Olt0aGlzLnJlcGVhdC54LHRoaXMucmVwZWF0LnldLG9mZnNldDpbdGhpcy5vZmZzZXQueCx0aGlzLm9mZnNldC55XSxjZW50ZXI6W3RoaXMuY2VudGVyLngsdGhpcy5jZW50ZXIueV0scm90YXRpb246dGhpcy5yb3RhdGlvbix3cmFwOlt0aGlzLndyYXBTLHRoaXMud3JhcFRdLGZvcm1hdDp0aGlzLmZvcm1hdCxpbnRlcm5hbEZvcm1hdDp0aGlzLmludGVybmFsRm9ybWF0LHR5cGU6dGhpcy50eXBlLGNvbG9yU3BhY2U6dGhpcy5jb2xvclNwYWNlLG1pbkZpbHRlcjp0aGlzLm1pbkZpbHRlcixtYWdGaWx0ZXI6dGhpcy5tYWdGaWx0ZXIsYW5pc290cm9weTp0aGlzLmFuaXNvdHJvcHksZmxpcFk6dGhpcy5mbGlwWSxnZW5lcmF0ZU1pcG1hcHM6dGhpcy5nZW5lcmF0ZU1pcG1hcHMscHJlbXVsdGlwbHlBbHBoYTp0aGlzLnByZW11bHRpcGx5QWxwaGEsdW5wYWNrQWxpZ25tZW50OnRoaXMudW5wYWNrQWxpZ25tZW50fTtyZXR1cm4gT2JqZWN0LmtleXModGhpcy51c2VyRGF0YSkubGVuZ3RoPjAmJihuLnVzZXJEYXRhPXRoaXMudXNlckRhdGEpLHR8fChlLnRleHR1cmVzW3RoaXMudXVpZF09biksbn1kaXNwb3NlKCl7dGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJkaXNwb3NlIn0pfXRyYW5zZm9ybVV2KGUpe2lmKHRoaXMubWFwcGluZyE9PTMwMClyZXR1cm4gZTtpZihlLmFwcGx5TWF0cml4Myh0aGlzLm1hdHJpeCksZS54PDB8fGUueD4xKXN3aXRjaCh0aGlzLndyYXBTKXtjYXNlIDFlMzplLng9ZS54LU1hdGguZmxvb3IoZS54KTticmVhaztjYXNlIDEwMDE6ZS54PWUueDwwPzA6MTticmVhaztjYXNlIDEwMDI6TWF0aC5hYnMoTWF0aC5mbG9vcihlLngpJTIpPT09MT9lLng9TWF0aC5jZWlsKGUueCktZS54OmUueD1lLngtTWF0aC5mbG9vcihlLngpO2JyZWFrfWlmKGUueTwwfHxlLnk+MSlzd2l0Y2godGhpcy53cmFwVCl7Y2FzZSAxZTM6ZS55PWUueS1NYXRoLmZsb29yKGUueSk7YnJlYWs7Y2FzZSAxMDAxOmUueT1lLnk8MD8wOjE7YnJlYWs7Y2FzZSAxMDAyOk1hdGguYWJzKE1hdGguZmxvb3IoZS55KSUyKT09PTE/ZS55PU1hdGguY2VpbChlLnkpLWUueTplLnk9ZS55LU1hdGguZmxvb3IoZS55KTticmVha31yZXR1cm4gdGhpcy5mbGlwWSYmKGUueT0xLWUueSksZX1zZXQgbmVlZHNVcGRhdGUoZSl7ZT09PSEwJiYodGhpcy52ZXJzaW9uKyssdGhpcy5zb3VyY2UubmVlZHNVcGRhdGU9ITApfXNldCBuZWVkc1BNUkVNVXBkYXRlKGUpe2U9PT0hMCYmdGhpcy5wbXJlbVZlcnNpb24rK319dnQuREVGQVVMVF9JTUFHRT1udWxsLHZ0LkRFRkFVTFRfTUFQUElORz0zMDAsdnQuREVGQVVMVF9BTklTT1RST1BZPTE7Y2xhc3MgcnR7Y29uc3RydWN0b3IoZT0wLHQ9MCxuPTAscj0xKXtydC5wcm90b3R5cGUuaXNWZWN0b3I0PSEwLHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1uLHRoaXMudz1yfWdldCB3aWR0aCgpe3JldHVybiB0aGlzLnp9c2V0IHdpZHRoKGUpe3RoaXMuej1lfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy53fXNldCBoZWlnaHQoZSl7dGhpcy53PWV9c2V0KGUsdCxuLHIpe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzLno9bix0aGlzLnc9cix0aGlzfXNldFNjYWxhcihlKXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PWUsdGhpcy56PWUsdGhpcy53PWUsdGhpc31zZXRYKGUpe3JldHVybiB0aGlzLng9ZSx0aGlzfXNldFkoZSl7cmV0dXJuIHRoaXMueT1lLHRoaXN9c2V0WihlKXtyZXR1cm4gdGhpcy56PWUsdGhpc31zZXRXKGUpe3JldHVybiB0aGlzLnc9ZSx0aGlzfXNldENvbXBvbmVudChlLHQpe3N3aXRjaChlKXtjYXNlIDA6dGhpcy54PXQ7YnJlYWs7Y2FzZSAxOnRoaXMueT10O2JyZWFrO2Nhc2UgMjp0aGlzLno9dDticmVhaztjYXNlIDM6dGhpcy53PXQ7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoImluZGV4IGlzIG91dCBvZiByYW5nZTogIitlKX1yZXR1cm4gdGhpc31nZXRDb21wb25lbnQoZSl7c3dpdGNoKGUpe2Nhc2UgMDpyZXR1cm4gdGhpcy54O2Nhc2UgMTpyZXR1cm4gdGhpcy55O2Nhc2UgMjpyZXR1cm4gdGhpcy56O2Nhc2UgMzpyZXR1cm4gdGhpcy53O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIrZSl9fWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCx0aGlzLnksdGhpcy56LHRoaXMudyl9Y29weShlKXtyZXR1cm4gdGhpcy54PWUueCx0aGlzLnk9ZS55LHRoaXMuej1lLnosdGhpcy53PWUudyE9PXZvaWQgMD9lLnc6MSx0aGlzfWFkZChlKXtyZXR1cm4gdGhpcy54Kz1lLngsdGhpcy55Kz1lLnksdGhpcy56Kz1lLnosdGhpcy53Kz1lLncsdGhpc31hZGRTY2FsYXIoZSl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPWUsdGhpcy56Kz1lLHRoaXMudys9ZSx0aGlzfWFkZFZlY3RvcnMoZSx0KXtyZXR1cm4gdGhpcy54PWUueCt0LngsdGhpcy55PWUueSt0LnksdGhpcy56PWUueit0LnosdGhpcy53PWUudyt0LncsdGhpc31hZGRTY2FsZWRWZWN0b3IoZSx0KXtyZXR1cm4gdGhpcy54Kz1lLngqdCx0aGlzLnkrPWUueSp0LHRoaXMueis9ZS56KnQsdGhpcy53Kz1lLncqdCx0aGlzfXN1YihlKXtyZXR1cm4gdGhpcy54LT1lLngsdGhpcy55LT1lLnksdGhpcy56LT1lLnosdGhpcy53LT1lLncsdGhpc31zdWJTY2FsYXIoZSl7cmV0dXJuIHRoaXMueC09ZSx0aGlzLnktPWUsdGhpcy56LT1lLHRoaXMudy09ZSx0aGlzfXN1YlZlY3RvcnMoZSx0KXtyZXR1cm4gdGhpcy54PWUueC10LngsdGhpcy55PWUueS10LnksdGhpcy56PWUuei10LnosdGhpcy53PWUudy10LncsdGhpc31tdWx0aXBseShlKXtyZXR1cm4gdGhpcy54Kj1lLngsdGhpcy55Kj1lLnksdGhpcy56Kj1lLnosdGhpcy53Kj1lLncsdGhpc31tdWx0aXBseVNjYWxhcihlKXtyZXR1cm4gdGhpcy54Kj1lLHRoaXMueSo9ZSx0aGlzLnoqPWUsdGhpcy53Kj1lLHRoaXN9YXBwbHlNYXRyaXg0KGUpe2NvbnN0IHQ9dGhpcy54LG49dGhpcy55LHI9dGhpcy56LHM9dGhpcy53LGE9ZS5lbGVtZW50cztyZXR1cm4gdGhpcy54PWFbMF0qdCthWzRdKm4rYVs4XSpyK2FbMTJdKnMsdGhpcy55PWFbMV0qdCthWzVdKm4rYVs5XSpyK2FbMTNdKnMsdGhpcy56PWFbMl0qdCthWzZdKm4rYVsxMF0qcithWzE0XSpzLHRoaXMudz1hWzNdKnQrYVs3XSpuK2FbMTFdKnIrYVsxNV0qcyx0aGlzfWRpdmlkZShlKXtyZXR1cm4gdGhpcy54Lz1lLngsdGhpcy55Lz1lLnksdGhpcy56Lz1lLnosdGhpcy53Lz1lLncsdGhpc31kaXZpZGVTY2FsYXIoZSl7cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMS9lKX1zZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbihlKXt0aGlzLnc9MipNYXRoLmFjb3MoZS53KTtjb25zdCB0PU1hdGguc3FydCgxLWUudyplLncpO3JldHVybiB0PDFlLTQ/KHRoaXMueD0xLHRoaXMueT0wLHRoaXMuej0wKToodGhpcy54PWUueC90LHRoaXMueT1lLnkvdCx0aGlzLno9ZS56L3QpLHRoaXN9c2V0QXhpc0FuZ2xlRnJvbVJvdGF0aW9uTWF0cml4KGUpe2xldCB0LG4scixzO2NvbnN0IGw9ZS5lbGVtZW50cyxjPWxbMF0saD1sWzRdLGQ9bFs4XSxmPWxbMV0scD1sWzVdLF89bFs5XSx4PWxbMl0sbT1sWzZdLHU9bFsxMF07aWYoTWF0aC5hYnMoaC1mKTwuMDEmJk1hdGguYWJzKGQteCk8LjAxJiZNYXRoLmFicyhfLW0pPC4wMSl7aWYoTWF0aC5hYnMoaCtmKTwuMSYmTWF0aC5hYnMoZCt4KTwuMSYmTWF0aC5hYnMoXyttKTwuMSYmTWF0aC5hYnMoYytwK3UtMyk8LjEpcmV0dXJuIHRoaXMuc2V0KDEsMCwwLDApLHRoaXM7dD1NYXRoLlBJO2NvbnN0IHk9KGMrMSkvMixnPShwKzEpLzIsUD0odSsxKS8yLHc9KGgrZikvNCxiPShkK3gpLzQsRj0oXyttKS80O3JldHVybiB5PmcmJnk+UD95PC4wMT8obj0wLHI9LjcwNzEwNjc4MSxzPS43MDcxMDY3ODEpOihuPU1hdGguc3FydCh5KSxyPXcvbixzPWIvbik6Zz5QP2c8LjAxPyhuPS43MDcxMDY3ODEscj0wLHM9LjcwNzEwNjc4MSk6KHI9TWF0aC5zcXJ0KGcpLG49dy9yLHM9Ri9yKTpQPC4wMT8obj0uNzA3MTA2NzgxLHI9LjcwNzEwNjc4MSxzPTApOihzPU1hdGguc3FydChQKSxuPWIvcyxyPUYvcyksdGhpcy5zZXQobixyLHMsdCksdGhpc31sZXQgVD1NYXRoLnNxcnQoKG0tXykqKG0tXykrKGQteCkqKGQteCkrKGYtaCkqKGYtaCkpO3JldHVybiBNYXRoLmFicyhUKTwuMDAxJiYoVD0xKSx0aGlzLng9KG0tXykvVCx0aGlzLnk9KGQteCkvVCx0aGlzLno9KGYtaCkvVCx0aGlzLnc9TWF0aC5hY29zKChjK3ArdS0xKS8yKSx0aGlzfXNldEZyb21NYXRyaXhQb3NpdGlvbihlKXtjb25zdCB0PWUuZWxlbWVudHM7cmV0dXJuIHRoaXMueD10WzEyXSx0aGlzLnk9dFsxM10sdGhpcy56PXRbMTRdLHRoaXMudz10WzE1XSx0aGlzfW1pbihlKXtyZXR1cm4gdGhpcy54PU1hdGgubWluKHRoaXMueCxlLngpLHRoaXMueT1NYXRoLm1pbih0aGlzLnksZS55KSx0aGlzLno9TWF0aC5taW4odGhpcy56LGUueiksdGhpcy53PU1hdGgubWluKHRoaXMudyxlLncpLHRoaXN9bWF4KGUpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodGhpcy54LGUueCksdGhpcy55PU1hdGgubWF4KHRoaXMueSxlLnkpLHRoaXMuej1NYXRoLm1heCh0aGlzLnosZS56KSx0aGlzLnc9TWF0aC5tYXgodGhpcy53LGUudyksdGhpc31jbGFtcChlLHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgoZS54LE1hdGgubWluKHQueCx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgoZS55LE1hdGgubWluKHQueSx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgoZS56LE1hdGgubWluKHQueix0aGlzLnopKSx0aGlzLnc9TWF0aC5tYXgoZS53LE1hdGgubWluKHQudyx0aGlzLncpKSx0aGlzfWNsYW1wU2NhbGFyKGUsdCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heChlLE1hdGgubWluKHQsdGhpcy54KSksdGhpcy55PU1hdGgubWF4KGUsTWF0aC5taW4odCx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgoZSxNYXRoLm1pbih0LHRoaXMueikpLHRoaXMudz1NYXRoLm1heChlLE1hdGgubWluKHQsdGhpcy53KSksdGhpc31jbGFtcExlbmd0aChlLHQpe2NvbnN0IG49dGhpcy5sZW5ndGgoKTtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIobnx8MSkubXVsdGlwbHlTY2FsYXIoTWF0aC5tYXgoZSxNYXRoLm1pbih0LG4pKSl9Zmxvb3IoKXtyZXR1cm4gdGhpcy54PU1hdGguZmxvb3IodGhpcy54KSx0aGlzLnk9TWF0aC5mbG9vcih0aGlzLnkpLHRoaXMuej1NYXRoLmZsb29yKHRoaXMueiksdGhpcy53PU1hdGguZmxvb3IodGhpcy53KSx0aGlzfWNlaWwoKXtyZXR1cm4gdGhpcy54PU1hdGguY2VpbCh0aGlzLngpLHRoaXMueT1NYXRoLmNlaWwodGhpcy55KSx0aGlzLno9TWF0aC5jZWlsKHRoaXMueiksdGhpcy53PU1hdGguY2VpbCh0aGlzLncpLHRoaXN9cm91bmQoKXtyZXR1cm4gdGhpcy54PU1hdGgucm91bmQodGhpcy54KSx0aGlzLnk9TWF0aC5yb3VuZCh0aGlzLnkpLHRoaXMuej1NYXRoLnJvdW5kKHRoaXMueiksdGhpcy53PU1hdGgucm91bmQodGhpcy53KSx0aGlzfXJvdW5kVG9aZXJvKCl7cmV0dXJuIHRoaXMueD1NYXRoLnRydW5jKHRoaXMueCksdGhpcy55PU1hdGgudHJ1bmModGhpcy55KSx0aGlzLno9TWF0aC50cnVuYyh0aGlzLnopLHRoaXMudz1NYXRoLnRydW5jKHRoaXMudyksdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy54PS10aGlzLngsdGhpcy55PS10aGlzLnksdGhpcy56PS10aGlzLnosdGhpcy53PS10aGlzLncsdGhpc31kb3QoZSl7cmV0dXJuIHRoaXMueCplLngrdGhpcy55KmUueSt0aGlzLnoqZS56K3RoaXMudyplLnd9bGVuZ3RoU3EoKXtyZXR1cm4gdGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMud31sZW5ndGgoKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56K3RoaXMudyp0aGlzLncpfW1hbmhhdHRhbkxlbmd0aCgpe3JldHVybiBNYXRoLmFicyh0aGlzLngpK01hdGguYWJzKHRoaXMueSkrTWF0aC5hYnModGhpcy56KStNYXRoLmFicyh0aGlzLncpfW5vcm1hbGl6ZSgpe3JldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpfHwxKX1zZXRMZW5ndGgoZSl7cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoZSl9bGVycChlLHQpe3JldHVybiB0aGlzLngrPShlLngtdGhpcy54KSp0LHRoaXMueSs9KGUueS10aGlzLnkpKnQsdGhpcy56Kz0oZS56LXRoaXMueikqdCx0aGlzLncrPShlLnctdGhpcy53KSp0LHRoaXN9bGVycFZlY3RvcnMoZSx0LG4pe3JldHVybiB0aGlzLng9ZS54Kyh0LngtZS54KSpuLHRoaXMueT1lLnkrKHQueS1lLnkpKm4sdGhpcy56PWUueisodC56LWUueikqbix0aGlzLnc9ZS53Kyh0LnctZS53KSpuLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLng9PT10aGlzLngmJmUueT09PXRoaXMueSYmZS56PT09dGhpcy56JiZlLnc9PT10aGlzLnd9ZnJvbUFycmF5KGUsdD0wKXtyZXR1cm4gdGhpcy54PWVbdF0sdGhpcy55PWVbdCsxXSx0aGlzLno9ZVt0KzJdLHRoaXMudz1lW3QrM10sdGhpc310b0FycmF5KGU9W10sdD0wKXtyZXR1cm4gZVt0XT10aGlzLngsZVt0KzFdPXRoaXMueSxlW3QrMl09dGhpcy56LGVbdCszXT10aGlzLncsZX1mcm9tQnVmZmVyQXR0cmlidXRlKGUsdCl7cmV0dXJuIHRoaXMueD1lLmdldFgodCksdGhpcy55PWUuZ2V0WSh0KSx0aGlzLno9ZS5nZXRaKHQpLHRoaXMudz1lLmdldFcodCksdGhpc31yYW5kb20oKXtyZXR1cm4gdGhpcy54PU1hdGgucmFuZG9tKCksdGhpcy55PU1hdGgucmFuZG9tKCksdGhpcy56PU1hdGgucmFuZG9tKCksdGhpcy53PU1hdGgucmFuZG9tKCksdGhpc30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLngseWllbGQgdGhpcy55LHlpZWxkIHRoaXMueix5aWVsZCB0aGlzLnd9fWNsYXNzIF9hIGV4dGVuZHMgTW57Y29uc3RydWN0b3IoZT0xLHQ9MSxuPXt9KXtzdXBlcigpLHRoaXMuaXNSZW5kZXJUYXJnZXQ9ITAsdGhpcy53aWR0aD1lLHRoaXMuaGVpZ2h0PXQsdGhpcy5kZXB0aD0xLHRoaXMuc2Npc3Nvcj1uZXcgcnQoMCwwLGUsdCksdGhpcy5zY2lzc29yVGVzdD0hMSx0aGlzLnZpZXdwb3J0PW5ldyBydCgwLDAsZSx0KTtjb25zdCByPXt3aWR0aDplLGhlaWdodDp0LGRlcHRoOjF9O249T2JqZWN0LmFzc2lnbih7Z2VuZXJhdGVNaXBtYXBzOiExLGludGVybmFsRm9ybWF0Om51bGwsbWluRmlsdGVyOjEwMDYsZGVwdGhCdWZmZXI6ITAsc3RlbmNpbEJ1ZmZlcjohMSxyZXNvbHZlRGVwdGhCdWZmZXI6ITAscmVzb2x2ZVN0ZW5jaWxCdWZmZXI6ITAsZGVwdGhUZXh0dXJlOm51bGwsc2FtcGxlczowLGNvdW50OjF9LG4pO2NvbnN0IHM9bmV3IHZ0KHIsbi5tYXBwaW5nLG4ud3JhcFMsbi53cmFwVCxuLm1hZ0ZpbHRlcixuLm1pbkZpbHRlcixuLmZvcm1hdCxuLnR5cGUsbi5hbmlzb3Ryb3B5LG4uY29sb3JTcGFjZSk7cy5mbGlwWT0hMSxzLmdlbmVyYXRlTWlwbWFwcz1uLmdlbmVyYXRlTWlwbWFwcyxzLmludGVybmFsRm9ybWF0PW4uaW50ZXJuYWxGb3JtYXQsdGhpcy50ZXh0dXJlcz1bXTtjb25zdCBhPW4uY291bnQ7Zm9yKGxldCBvPTA7bzxhO28rKyl0aGlzLnRleHR1cmVzW29dPXMuY2xvbmUoKSx0aGlzLnRleHR1cmVzW29dLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hMDt0aGlzLmRlcHRoQnVmZmVyPW4uZGVwdGhCdWZmZXIsdGhpcy5zdGVuY2lsQnVmZmVyPW4uc3RlbmNpbEJ1ZmZlcix0aGlzLnJlc29sdmVEZXB0aEJ1ZmZlcj1uLnJlc29sdmVEZXB0aEJ1ZmZlcix0aGlzLnJlc29sdmVTdGVuY2lsQnVmZmVyPW4ucmVzb2x2ZVN0ZW5jaWxCdWZmZXIsdGhpcy5kZXB0aFRleHR1cmU9bi5kZXB0aFRleHR1cmUsdGhpcy5zYW1wbGVzPW4uc2FtcGxlc31nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzLnRleHR1cmVzWzBdfXNldCB0ZXh0dXJlKGUpe3RoaXMudGV4dHVyZXNbMF09ZX1zZXRTaXplKGUsdCxuPTEpe2lmKHRoaXMud2lkdGghPT1lfHx0aGlzLmhlaWdodCE9PXR8fHRoaXMuZGVwdGghPT1uKXt0aGlzLndpZHRoPWUsdGhpcy5oZWlnaHQ9dCx0aGlzLmRlcHRoPW47Zm9yKGxldCByPTAscz10aGlzLnRleHR1cmVzLmxlbmd0aDtyPHM7cisrKXRoaXMudGV4dHVyZXNbcl0uaW1hZ2Uud2lkdGg9ZSx0aGlzLnRleHR1cmVzW3JdLmltYWdlLmhlaWdodD10LHRoaXMudGV4dHVyZXNbcl0uaW1hZ2UuZGVwdGg9bjt0aGlzLmRpc3Bvc2UoKX10aGlzLnZpZXdwb3J0LnNldCgwLDAsZSx0KSx0aGlzLnNjaXNzb3Iuc2V0KDAsMCxlLHQpfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX1jb3B5KGUpe3RoaXMud2lkdGg9ZS53aWR0aCx0aGlzLmhlaWdodD1lLmhlaWdodCx0aGlzLmRlcHRoPWUuZGVwdGgsdGhpcy5zY2lzc29yLmNvcHkoZS5zY2lzc29yKSx0aGlzLnNjaXNzb3JUZXN0PWUuc2Npc3NvclRlc3QsdGhpcy52aWV3cG9ydC5jb3B5KGUudmlld3BvcnQpLHRoaXMudGV4dHVyZXMubGVuZ3RoPTA7Zm9yKGxldCBuPTAscj1lLnRleHR1cmVzLmxlbmd0aDtuPHI7bisrKXRoaXMudGV4dHVyZXNbbl09ZS50ZXh0dXJlc1tuXS5jbG9uZSgpLHRoaXMudGV4dHVyZXNbbl0uaXNSZW5kZXJUYXJnZXRUZXh0dXJlPSEwO2NvbnN0IHQ9T2JqZWN0LmFzc2lnbih7fSxlLnRleHR1cmUuaW1hZ2UpO3JldHVybiB0aGlzLnRleHR1cmUuc291cmNlPW5ldyBScih0KSx0aGlzLmRlcHRoQnVmZmVyPWUuZGVwdGhCdWZmZXIsdGhpcy5zdGVuY2lsQnVmZmVyPWUuc3RlbmNpbEJ1ZmZlcix0aGlzLnJlc29sdmVEZXB0aEJ1ZmZlcj1lLnJlc29sdmVEZXB0aEJ1ZmZlcix0aGlzLnJlc29sdmVTdGVuY2lsQnVmZmVyPWUucmVzb2x2ZVN0ZW5jaWxCdWZmZXIsZS5kZXB0aFRleHR1cmUhPT1udWxsJiYodGhpcy5kZXB0aFRleHR1cmU9ZS5kZXB0aFRleHR1cmUuY2xvbmUoKSksdGhpcy5zYW1wbGVzPWUuc2FtcGxlcyx0aGlzfWRpc3Bvc2UoKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImRpc3Bvc2UifSl9fWNsYXNzIEp0IGV4dGVuZHMgX2F7Y29uc3RydWN0b3IoZT0xLHQ9MSxuPXt9KXtzdXBlcihlLHQsbiksdGhpcy5pc1dlYkdMUmVuZGVyVGFyZ2V0PSEwfX1jbGFzcyBDciBleHRlbmRzIHZ0e2NvbnN0cnVjdG9yKGU9bnVsbCx0PTEsbj0xLHI9MSl7c3VwZXIobnVsbCksdGhpcy5pc0RhdGFBcnJheVRleHR1cmU9ITAsdGhpcy5pbWFnZT17ZGF0YTplLHdpZHRoOnQsaGVpZ2h0Om4sZGVwdGg6cn0sdGhpcy5tYWdGaWx0ZXI9MTAwMyx0aGlzLm1pbkZpbHRlcj0xMDAzLHRoaXMud3JhcFI9MTAwMSx0aGlzLmdlbmVyYXRlTWlwbWFwcz0hMSx0aGlzLmZsaXBZPSExLHRoaXMudW5wYWNrQWxpZ25tZW50PTEsdGhpcy5sYXllclVwZGF0ZXM9bmV3IFNldH1hZGRMYXllclVwZGF0ZShlKXt0aGlzLmxheWVyVXBkYXRlcy5hZGQoZSl9Y2xlYXJMYXllclVwZGF0ZXMoKXt0aGlzLmxheWVyVXBkYXRlcy5jbGVhcigpfX1jbGFzcyB2YSBleHRlbmRzIHZ0e2NvbnN0cnVjdG9yKGU9bnVsbCx0PTEsbj0xLHI9MSl7c3VwZXIobnVsbCksdGhpcy5pc0RhdGEzRFRleHR1cmU9ITAsdGhpcy5pbWFnZT17ZGF0YTplLHdpZHRoOnQsaGVpZ2h0Om4sZGVwdGg6cn0sdGhpcy5tYWdGaWx0ZXI9MTAwMyx0aGlzLm1pbkZpbHRlcj0xMDAzLHRoaXMud3JhcFI9MTAwMSx0aGlzLmdlbmVyYXRlTWlwbWFwcz0hMSx0aGlzLmZsaXBZPSExLHRoaXMudW5wYWNrQWxpZ25tZW50PTF9fWNsYXNzIFhue2NvbnN0cnVjdG9yKGU9MCx0PTAsbj0wLHI9MSl7dGhpcy5pc1F1YXRlcm5pb249ITAsdGhpcy5feD1lLHRoaXMuX3k9dCx0aGlzLl96PW4sdGhpcy5fdz1yfXN0YXRpYyBzbGVycEZsYXQoZSx0LG4scixzLGEsbyl7bGV0IGw9bltyKzBdLGM9bltyKzFdLGg9bltyKzJdLGQ9bltyKzNdO2NvbnN0IGY9c1thKzBdLHA9c1thKzFdLF89c1thKzJdLHg9c1thKzNdO2lmKG89PT0wKXtlW3QrMF09bCxlW3QrMV09YyxlW3QrMl09aCxlW3QrM109ZDtyZXR1cm59aWYobz09PTEpe2VbdCswXT1mLGVbdCsxXT1wLGVbdCsyXT1fLGVbdCszXT14O3JldHVybn1pZihkIT09eHx8bCE9PWZ8fGMhPT1wfHxoIT09Xyl7bGV0IG09MS1vO2NvbnN0IHU9bCpmK2MqcCtoKl8rZCp4LFQ9dT49MD8xOi0xLHk9MS11KnU7aWYoeT5OdW1iZXIuRVBTSUxPTil7Y29uc3QgUD1NYXRoLnNxcnQoeSksdz1NYXRoLmF0YW4yKFAsdSpUKTttPU1hdGguc2luKG0qdykvUCxvPU1hdGguc2luKG8qdykvUH1jb25zdCBnPW8qVDtpZihsPWwqbStmKmcsYz1jKm0rcCpnLGg9aCptK18qZyxkPWQqbSt4KmcsbT09PTEtbyl7Y29uc3QgUD0xL01hdGguc3FydChsKmwrYypjK2gqaCtkKmQpO2wqPVAsYyo9UCxoKj1QLGQqPVB9fWVbdF09bCxlW3QrMV09YyxlW3QrMl09aCxlW3QrM109ZH1zdGF0aWMgbXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQoZSx0LG4scixzLGEpe2NvbnN0IG89bltyXSxsPW5bcisxXSxjPW5bcisyXSxoPW5bciszXSxkPXNbYV0sZj1zW2ErMV0scD1zW2ErMl0sXz1zW2ErM107cmV0dXJuIGVbdF09bypfK2gqZCtsKnAtYypmLGVbdCsxXT1sKl8raCpmK2MqZC1vKnAsZVt0KzJdPWMqXytoKnArbypmLWwqZCxlW3QrM109aCpfLW8qZC1sKmYtYypwLGV9Z2V0IHgoKXtyZXR1cm4gdGhpcy5feH1zZXQgeChlKXt0aGlzLl94PWUsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfWdldCB5KCl7cmV0dXJuIHRoaXMuX3l9c2V0IHkoZSl7dGhpcy5feT1lLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKX1nZXQgeigpe3JldHVybiB0aGlzLl96fXNldCB6KGUpe3RoaXMuX3o9ZSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9Z2V0IHcoKXtyZXR1cm4gdGhpcy5fd31zZXQgdyhlKXt0aGlzLl93PWUsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfXNldChlLHQsbixyKXtyZXR1cm4gdGhpcy5feD1lLHRoaXMuX3k9dCx0aGlzLl96PW4sdGhpcy5fdz1yLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuX3gsdGhpcy5feSx0aGlzLl96LHRoaXMuX3cpfWNvcHkoZSl7cmV0dXJuIHRoaXMuX3g9ZS54LHRoaXMuX3k9ZS55LHRoaXMuX3o9ZS56LHRoaXMuX3c9ZS53LHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfXNldEZyb21FdWxlcihlLHQ9ITApe2NvbnN0IG49ZS5feCxyPWUuX3kscz1lLl96LGE9ZS5fb3JkZXIsbz1NYXRoLmNvcyxsPU1hdGguc2luLGM9byhuLzIpLGg9byhyLzIpLGQ9byhzLzIpLGY9bChuLzIpLHA9bChyLzIpLF89bChzLzIpO3N3aXRjaChhKXtjYXNlIlhZWiI6dGhpcy5feD1mKmgqZCtjKnAqXyx0aGlzLl95PWMqcCpkLWYqaCpfLHRoaXMuX3o9YypoKl8rZipwKmQsdGhpcy5fdz1jKmgqZC1mKnAqXzticmVhaztjYXNlIllYWiI6dGhpcy5feD1mKmgqZCtjKnAqXyx0aGlzLl95PWMqcCpkLWYqaCpfLHRoaXMuX3o9YypoKl8tZipwKmQsdGhpcy5fdz1jKmgqZCtmKnAqXzticmVhaztjYXNlIlpYWSI6dGhpcy5feD1mKmgqZC1jKnAqXyx0aGlzLl95PWMqcCpkK2YqaCpfLHRoaXMuX3o9YypoKl8rZipwKmQsdGhpcy5fdz1jKmgqZC1mKnAqXzticmVhaztjYXNlIlpZWCI6dGhpcy5feD1mKmgqZC1jKnAqXyx0aGlzLl95PWMqcCpkK2YqaCpfLHRoaXMuX3o9YypoKl8tZipwKmQsdGhpcy5fdz1jKmgqZCtmKnAqXzticmVhaztjYXNlIllaWCI6dGhpcy5feD1mKmgqZCtjKnAqXyx0aGlzLl95PWMqcCpkK2YqaCpfLHRoaXMuX3o9YypoKl8tZipwKmQsdGhpcy5fdz1jKmgqZC1mKnAqXzticmVhaztjYXNlIlhaWSI6dGhpcy5feD1mKmgqZC1jKnAqXyx0aGlzLl95PWMqcCpkLWYqaCpfLHRoaXMuX3o9YypoKl8rZipwKmQsdGhpcy5fdz1jKmgqZCtmKnAqXzticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybigiVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICIrYSl9cmV0dXJuIHQ9PT0hMCYmdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbUF4aXNBbmdsZShlLHQpe2NvbnN0IG49dC8yLHI9TWF0aC5zaW4obik7cmV0dXJuIHRoaXMuX3g9ZS54KnIsdGhpcy5feT1lLnkqcix0aGlzLl96PWUueipyLHRoaXMuX3c9TWF0aC5jb3MobiksdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVJvdGF0aW9uTWF0cml4KGUpe2NvbnN0IHQ9ZS5lbGVtZW50cyxuPXRbMF0scj10WzRdLHM9dFs4XSxhPXRbMV0sbz10WzVdLGw9dFs5XSxjPXRbMl0saD10WzZdLGQ9dFsxMF0sZj1uK28rZDtpZihmPjApe2NvbnN0IHA9LjUvTWF0aC5zcXJ0KGYrMSk7dGhpcy5fdz0uMjUvcCx0aGlzLl94PShoLWwpKnAsdGhpcy5feT0ocy1jKSpwLHRoaXMuX3o9KGEtcikqcH1lbHNlIGlmKG4+byYmbj5kKXtjb25zdCBwPTIqTWF0aC5zcXJ0KDErbi1vLWQpO3RoaXMuX3c9KGgtbCkvcCx0aGlzLl94PS4yNSpwLHRoaXMuX3k9KHIrYSkvcCx0aGlzLl96PShzK2MpL3B9ZWxzZSBpZihvPmQpe2NvbnN0IHA9MipNYXRoLnNxcnQoMStvLW4tZCk7dGhpcy5fdz0ocy1jKS9wLHRoaXMuX3g9KHIrYSkvcCx0aGlzLl95PS4yNSpwLHRoaXMuX3o9KGwraCkvcH1lbHNle2NvbnN0IHA9MipNYXRoLnNxcnQoMStkLW4tbyk7dGhpcy5fdz0oYS1yKS9wLHRoaXMuX3g9KHMrYykvcCx0aGlzLl95PShsK2gpL3AsdGhpcy5fej0uMjUqcH1yZXR1cm4gdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVVuaXRWZWN0b3JzKGUsdCl7bGV0IG49ZS5kb3QodCkrMTtyZXR1cm4gbjxOdW1iZXIuRVBTSUxPTj8obj0wLE1hdGguYWJzKGUueCk+TWF0aC5hYnMoZS56KT8odGhpcy5feD0tZS55LHRoaXMuX3k9ZS54LHRoaXMuX3o9MCx0aGlzLl93PW4pOih0aGlzLl94PTAsdGhpcy5feT0tZS56LHRoaXMuX3o9ZS55LHRoaXMuX3c9bikpOih0aGlzLl94PWUueSp0LnotZS56KnQueSx0aGlzLl95PWUueip0LngtZS54KnQueix0aGlzLl96PWUueCp0LnktZS55KnQueCx0aGlzLl93PW4pLHRoaXMubm9ybWFsaXplKCl9YW5nbGVUbyhlKXtyZXR1cm4gMipNYXRoLmFjb3MoTWF0aC5hYnMoZ3QodGhpcy5kb3QoZSksLTEsMSkpKX1yb3RhdGVUb3dhcmRzKGUsdCl7Y29uc3Qgbj10aGlzLmFuZ2xlVG8oZSk7aWYobj09PTApcmV0dXJuIHRoaXM7Y29uc3Qgcj1NYXRoLm1pbigxLHQvbik7cmV0dXJuIHRoaXMuc2xlcnAoZSxyKSx0aGlzfWlkZW50aXR5KCl7cmV0dXJuIHRoaXMuc2V0KDAsMCwwLDEpfWludmVydCgpe3JldHVybiB0aGlzLmNvbmp1Z2F0ZSgpfWNvbmp1Z2F0ZSgpe3JldHVybiB0aGlzLl94Kj0tMSx0aGlzLl95Kj0tMSx0aGlzLl96Kj0tMSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31kb3QoZSl7cmV0dXJuIHRoaXMuX3gqZS5feCt0aGlzLl95KmUuX3krdGhpcy5feiplLl96K3RoaXMuX3cqZS5fd31sZW5ndGhTcSgpe3JldHVybiB0aGlzLl94KnRoaXMuX3grdGhpcy5feSp0aGlzLl95K3RoaXMuX3oqdGhpcy5feit0aGlzLl93KnRoaXMuX3d9bGVuZ3RoKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLl94KnRoaXMuX3grdGhpcy5feSp0aGlzLl95K3RoaXMuX3oqdGhpcy5feit0aGlzLl93KnRoaXMuX3cpfW5vcm1hbGl6ZSgpe2xldCBlPXRoaXMubGVuZ3RoKCk7cmV0dXJuIGU9PT0wPyh0aGlzLl94PTAsdGhpcy5feT0wLHRoaXMuX3o9MCx0aGlzLl93PTEpOihlPTEvZSx0aGlzLl94PXRoaXMuX3gqZSx0aGlzLl95PXRoaXMuX3kqZSx0aGlzLl96PXRoaXMuX3oqZSx0aGlzLl93PXRoaXMuX3cqZSksdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9bXVsdGlwbHkoZSl7cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyh0aGlzLGUpfXByZW11bHRpcGx5KGUpe3JldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoZSx0aGlzKX1tdWx0aXBseVF1YXRlcm5pb25zKGUsdCl7Y29uc3Qgbj1lLl94LHI9ZS5feSxzPWUuX3osYT1lLl93LG89dC5feCxsPXQuX3ksYz10Ll96LGg9dC5fdztyZXR1cm4gdGhpcy5feD1uKmgrYSpvK3IqYy1zKmwsdGhpcy5feT1yKmgrYSpsK3Mqby1uKmMsdGhpcy5fej1zKmgrYSpjK24qbC1yKm8sdGhpcy5fdz1hKmgtbipvLXIqbC1zKmMsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2xlcnAoZSx0KXtpZih0PT09MClyZXR1cm4gdGhpcztpZih0PT09MSlyZXR1cm4gdGhpcy5jb3B5KGUpO2NvbnN0IG49dGhpcy5feCxyPXRoaXMuX3kscz10aGlzLl96LGE9dGhpcy5fdztsZXQgbz1hKmUuX3crbiplLl94K3IqZS5feStzKmUuX3o7aWYobzwwPyh0aGlzLl93PS1lLl93LHRoaXMuX3g9LWUuX3gsdGhpcy5feT0tZS5feSx0aGlzLl96PS1lLl96LG89LW8pOnRoaXMuY29weShlKSxvPj0xKXJldHVybiB0aGlzLl93PWEsdGhpcy5feD1uLHRoaXMuX3k9cix0aGlzLl96PXMsdGhpcztjb25zdCBsPTEtbypvO2lmKGw8PU51bWJlci5FUFNJTE9OKXtjb25zdCBwPTEtdDtyZXR1cm4gdGhpcy5fdz1wKmErdCp0aGlzLl93LHRoaXMuX3g9cCpuK3QqdGhpcy5feCx0aGlzLl95PXAqcit0KnRoaXMuX3ksdGhpcy5fej1wKnMrdCp0aGlzLl96LHRoaXMubm9ybWFsaXplKCksdGhpc31jb25zdCBjPU1hdGguc3FydChsKSxoPU1hdGguYXRhbjIoYyxvKSxkPU1hdGguc2luKCgxLXQpKmgpL2MsZj1NYXRoLnNpbih0KmgpL2M7cmV0dXJuIHRoaXMuX3c9YSpkK3RoaXMuX3cqZix0aGlzLl94PW4qZCt0aGlzLl94KmYsdGhpcy5feT1yKmQrdGhpcy5feSpmLHRoaXMuX3o9cypkK3RoaXMuX3oqZix0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31zbGVycFF1YXRlcm5pb25zKGUsdCxuKXtyZXR1cm4gdGhpcy5jb3B5KGUpLnNsZXJwKHQsbil9cmFuZG9tKCl7Y29uc3QgZT0yKk1hdGguUEkqTWF0aC5yYW5kb20oKSx0PTIqTWF0aC5QSSpNYXRoLnJhbmRvbSgpLG49TWF0aC5yYW5kb20oKSxyPU1hdGguc3FydCgxLW4pLHM9TWF0aC5zcXJ0KG4pO3JldHVybiB0aGlzLnNldChyKk1hdGguc2luKGUpLHIqTWF0aC5jb3MoZSkscypNYXRoLnNpbih0KSxzKk1hdGguY29zKHQpKX1lcXVhbHMoZSl7cmV0dXJuIGUuX3g9PT10aGlzLl94JiZlLl95PT09dGhpcy5feSYmZS5fej09PXRoaXMuX3omJmUuX3c9PT10aGlzLl93fWZyb21BcnJheShlLHQ9MCl7cmV0dXJuIHRoaXMuX3g9ZVt0XSx0aGlzLl95PWVbdCsxXSx0aGlzLl96PWVbdCsyXSx0aGlzLl93PWVbdCszXSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc310b0FycmF5KGU9W10sdD0wKXtyZXR1cm4gZVt0XT10aGlzLl94LGVbdCsxXT10aGlzLl95LGVbdCsyXT10aGlzLl96LGVbdCszXT10aGlzLl93LGV9ZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHQpe3JldHVybiB0aGlzLl94PWUuZ2V0WCh0KSx0aGlzLl95PWUuZ2V0WSh0KSx0aGlzLl96PWUuZ2V0Wih0KSx0aGlzLl93PWUuZ2V0Vyh0KSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc310b0pTT04oKXtyZXR1cm4gdGhpcy50b0FycmF5KCl9X29uQ2hhbmdlKGUpe3JldHVybiB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrPWUsdGhpc31fb25DaGFuZ2VDYWxsYmFjaygpe30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLl94LHlpZWxkIHRoaXMuX3kseWllbGQgdGhpcy5feix5aWVsZCB0aGlzLl93fX1jbGFzcyBPe2NvbnN0cnVjdG9yKGU9MCx0PTAsbj0wKXtPLnByb3RvdHlwZS5pc1ZlY3RvcjM9ITAsdGhpcy54PWUsdGhpcy55PXQsdGhpcy56PW59c2V0KGUsdCxuKXtyZXR1cm4gbj09PXZvaWQgMCYmKG49dGhpcy56KSx0aGlzLng9ZSx0aGlzLnk9dCx0aGlzLno9bix0aGlzfXNldFNjYWxhcihlKXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PWUsdGhpcy56PWUsdGhpc31zZXRYKGUpe3JldHVybiB0aGlzLng9ZSx0aGlzfXNldFkoZSl7cmV0dXJuIHRoaXMueT1lLHRoaXN9c2V0WihlKXtyZXR1cm4gdGhpcy56PWUsdGhpc31zZXRDb21wb25lbnQoZSx0KXtzd2l0Y2goZSl7Y2FzZSAwOnRoaXMueD10O2JyZWFrO2Nhc2UgMTp0aGlzLnk9dDticmVhaztjYXNlIDI6dGhpcy56PXQ7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoImluZGV4IGlzIG91dCBvZiByYW5nZTogIitlKX1yZXR1cm4gdGhpc31nZXRDb21wb25lbnQoZSl7c3dpdGNoKGUpe2Nhc2UgMDpyZXR1cm4gdGhpcy54O2Nhc2UgMTpyZXR1cm4gdGhpcy55O2Nhc2UgMjpyZXR1cm4gdGhpcy56O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIrZSl9fWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCx0aGlzLnksdGhpcy56KX1jb3B5KGUpe3JldHVybiB0aGlzLng9ZS54LHRoaXMueT1lLnksdGhpcy56PWUueix0aGlzfWFkZChlKXtyZXR1cm4gdGhpcy54Kz1lLngsdGhpcy55Kz1lLnksdGhpcy56Kz1lLnosdGhpc31hZGRTY2FsYXIoZSl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPWUsdGhpcy56Kz1lLHRoaXN9YWRkVmVjdG9ycyhlLHQpe3JldHVybiB0aGlzLng9ZS54K3QueCx0aGlzLnk9ZS55K3QueSx0aGlzLno9ZS56K3Queix0aGlzfWFkZFNjYWxlZFZlY3RvcihlLHQpe3JldHVybiB0aGlzLngrPWUueCp0LHRoaXMueSs9ZS55KnQsdGhpcy56Kz1lLnoqdCx0aGlzfXN1YihlKXtyZXR1cm4gdGhpcy54LT1lLngsdGhpcy55LT1lLnksdGhpcy56LT1lLnosdGhpc31zdWJTY2FsYXIoZSl7cmV0dXJuIHRoaXMueC09ZSx0aGlzLnktPWUsdGhpcy56LT1lLHRoaXN9c3ViVmVjdG9ycyhlLHQpe3JldHVybiB0aGlzLng9ZS54LXQueCx0aGlzLnk9ZS55LXQueSx0aGlzLno9ZS56LXQueix0aGlzfW11bHRpcGx5KGUpe3JldHVybiB0aGlzLngqPWUueCx0aGlzLnkqPWUueSx0aGlzLnoqPWUueix0aGlzfW11bHRpcGx5U2NhbGFyKGUpe3JldHVybiB0aGlzLngqPWUsdGhpcy55Kj1lLHRoaXMueio9ZSx0aGlzfW11bHRpcGx5VmVjdG9ycyhlLHQpe3JldHVybiB0aGlzLng9ZS54KnQueCx0aGlzLnk9ZS55KnQueSx0aGlzLno9ZS56KnQueix0aGlzfWFwcGx5RXVsZXIoZSl7cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKFByLnNldEZyb21FdWxlcihlKSl9YXBwbHlBeGlzQW5nbGUoZSx0KXtyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oUHIuc2V0RnJvbUF4aXNBbmdsZShlLHQpKX1hcHBseU1hdHJpeDMoZSl7Y29uc3QgdD10aGlzLngsbj10aGlzLnkscj10aGlzLnoscz1lLmVsZW1lbnRzO3JldHVybiB0aGlzLng9c1swXSp0K3NbM10qbitzWzZdKnIsdGhpcy55PXNbMV0qdCtzWzRdKm4rc1s3XSpyLHRoaXMuej1zWzJdKnQrc1s1XSpuK3NbOF0qcix0aGlzfWFwcGx5Tm9ybWFsTWF0cml4KGUpe3JldHVybiB0aGlzLmFwcGx5TWF0cml4MyhlKS5ub3JtYWxpemUoKX1hcHBseU1hdHJpeDQoZSl7Y29uc3QgdD10aGlzLngsbj10aGlzLnkscj10aGlzLnoscz1lLmVsZW1lbnRzLGE9MS8oc1szXSp0K3NbN10qbitzWzExXSpyK3NbMTVdKTtyZXR1cm4gdGhpcy54PShzWzBdKnQrc1s0XSpuK3NbOF0qcitzWzEyXSkqYSx0aGlzLnk9KHNbMV0qdCtzWzVdKm4rc1s5XSpyK3NbMTNdKSphLHRoaXMuej0oc1syXSp0K3NbNl0qbitzWzEwXSpyK3NbMTRdKSphLHRoaXN9YXBwbHlRdWF0ZXJuaW9uKGUpe2NvbnN0IHQ9dGhpcy54LG49dGhpcy55LHI9dGhpcy56LHM9ZS54LGE9ZS55LG89ZS56LGw9ZS53LGM9MiooYSpyLW8qbiksaD0yKihvKnQtcypyKSxkPTIqKHMqbi1hKnQpO3JldHVybiB0aGlzLng9dCtsKmMrYSpkLW8qaCx0aGlzLnk9bitsKmgrbypjLXMqZCx0aGlzLno9citsKmQrcypoLWEqYyx0aGlzfXByb2plY3QoZSl7cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KGUubWF0cml4V29ybGRJbnZlcnNlKS5hcHBseU1hdHJpeDQoZS5wcm9qZWN0aW9uTWF0cml4KX11bnByb2plY3QoZSl7cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KGUucHJvamVjdGlvbk1hdHJpeEludmVyc2UpLmFwcGx5TWF0cml4NChlLm1hdHJpeFdvcmxkKX10cmFuc2Zvcm1EaXJlY3Rpb24oZSl7Y29uc3QgdD10aGlzLngsbj10aGlzLnkscj10aGlzLnoscz1lLmVsZW1lbnRzO3JldHVybiB0aGlzLng9c1swXSp0K3NbNF0qbitzWzhdKnIsdGhpcy55PXNbMV0qdCtzWzVdKm4rc1s5XSpyLHRoaXMuej1zWzJdKnQrc1s2XSpuK3NbMTBdKnIsdGhpcy5ub3JtYWxpemUoKX1kaXZpZGUoZSl7cmV0dXJuIHRoaXMueC89ZS54LHRoaXMueS89ZS55LHRoaXMuei89ZS56LHRoaXN9ZGl2aWRlU2NhbGFyKGUpe3JldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEvZSl9bWluKGUpe3JldHVybiB0aGlzLng9TWF0aC5taW4odGhpcy54LGUueCksdGhpcy55PU1hdGgubWluKHRoaXMueSxlLnkpLHRoaXMuej1NYXRoLm1pbih0aGlzLnosZS56KSx0aGlzfW1heChlKXtyZXR1cm4gdGhpcy54PU1hdGgubWF4KHRoaXMueCxlLngpLHRoaXMueT1NYXRoLm1heCh0aGlzLnksZS55KSx0aGlzLno9TWF0aC5tYXgodGhpcy56LGUueiksdGhpc31jbGFtcChlLHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgoZS54LE1hdGgubWluKHQueCx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgoZS55LE1hdGgubWluKHQueSx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgoZS56LE1hdGgubWluKHQueix0aGlzLnopKSx0aGlzfWNsYW1wU2NhbGFyKGUsdCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heChlLE1hdGgubWluKHQsdGhpcy54KSksdGhpcy55PU1hdGgubWF4KGUsTWF0aC5taW4odCx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgoZSxNYXRoLm1pbih0LHRoaXMueikpLHRoaXN9Y2xhbXBMZW5ndGgoZSx0KXtjb25zdCBuPXRoaXMubGVuZ3RoKCk7cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKG58fDEpLm11bHRpcGx5U2NhbGFyKE1hdGgubWF4KGUsTWF0aC5taW4odCxuKSkpfWZsb29yKCl7cmV0dXJuIHRoaXMueD1NYXRoLmZsb29yKHRoaXMueCksdGhpcy55PU1hdGguZmxvb3IodGhpcy55KSx0aGlzLno9TWF0aC5mbG9vcih0aGlzLnopLHRoaXN9Y2VpbCgpe3JldHVybiB0aGlzLng9TWF0aC5jZWlsKHRoaXMueCksdGhpcy55PU1hdGguY2VpbCh0aGlzLnkpLHRoaXMuej1NYXRoLmNlaWwodGhpcy56KSx0aGlzfXJvdW5kKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJvdW5kKHRoaXMueCksdGhpcy55PU1hdGgucm91bmQodGhpcy55KSx0aGlzLno9TWF0aC5yb3VuZCh0aGlzLnopLHRoaXN9cm91bmRUb1plcm8oKXtyZXR1cm4gdGhpcy54PU1hdGgudHJ1bmModGhpcy54KSx0aGlzLnk9TWF0aC50cnVuYyh0aGlzLnkpLHRoaXMuej1NYXRoLnRydW5jKHRoaXMueiksdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy54PS10aGlzLngsdGhpcy55PS10aGlzLnksdGhpcy56PS10aGlzLnosdGhpc31kb3QoZSl7cmV0dXJuIHRoaXMueCplLngrdGhpcy55KmUueSt0aGlzLnoqZS56fWxlbmd0aFNxKCl7cmV0dXJuIHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56fWxlbmd0aCgpe3JldHVybiBNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnopfW1hbmhhdHRhbkxlbmd0aCgpe3JldHVybiBNYXRoLmFicyh0aGlzLngpK01hdGguYWJzKHRoaXMueSkrTWF0aC5hYnModGhpcy56KX1ub3JtYWxpemUoKXtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKXx8MSl9c2V0TGVuZ3RoKGUpe3JldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGUpfWxlcnAoZSx0KXtyZXR1cm4gdGhpcy54Kz0oZS54LXRoaXMueCkqdCx0aGlzLnkrPShlLnktdGhpcy55KSp0LHRoaXMueis9KGUuei10aGlzLnopKnQsdGhpc31sZXJwVmVjdG9ycyhlLHQsbil7cmV0dXJuIHRoaXMueD1lLngrKHQueC1lLngpKm4sdGhpcy55PWUueSsodC55LWUueSkqbix0aGlzLno9ZS56Kyh0LnotZS56KSpuLHRoaXN9Y3Jvc3MoZSl7cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKHRoaXMsZSl9Y3Jvc3NWZWN0b3JzKGUsdCl7Y29uc3Qgbj1lLngscj1lLnkscz1lLnosYT10Lngsbz10LnksbD10Lno7cmV0dXJuIHRoaXMueD1yKmwtcypvLHRoaXMueT1zKmEtbipsLHRoaXMuej1uKm8tciphLHRoaXN9cHJvamVjdE9uVmVjdG9yKGUpe2NvbnN0IHQ9ZS5sZW5ndGhTcSgpO2lmKHQ9PT0wKXJldHVybiB0aGlzLnNldCgwLDAsMCk7Y29uc3Qgbj1lLmRvdCh0aGlzKS90O3JldHVybiB0aGlzLmNvcHkoZSkubXVsdGlwbHlTY2FsYXIobil9cHJvamVjdE9uUGxhbmUoZSl7cmV0dXJuIEdpLmNvcHkodGhpcykucHJvamVjdE9uVmVjdG9yKGUpLHRoaXMuc3ViKEdpKX1yZWZsZWN0KGUpe3JldHVybiB0aGlzLnN1YihHaS5jb3B5KGUpLm11bHRpcGx5U2NhbGFyKDIqdGhpcy5kb3QoZSkpKX1hbmdsZVRvKGUpe2NvbnN0IHQ9TWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3EoKSplLmxlbmd0aFNxKCkpO2lmKHQ9PT0wKXJldHVybiBNYXRoLlBJLzI7Y29uc3Qgbj10aGlzLmRvdChlKS90O3JldHVybiBNYXRoLmFjb3MoZ3QobiwtMSwxKSl9ZGlzdGFuY2VUbyhlKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoZSkpfWRpc3RhbmNlVG9TcXVhcmVkKGUpe2NvbnN0IHQ9dGhpcy54LWUueCxuPXRoaXMueS1lLnkscj10aGlzLnotZS56O3JldHVybiB0KnQrbipuK3Iqcn1tYW5oYXR0YW5EaXN0YW5jZVRvKGUpe3JldHVybiBNYXRoLmFicyh0aGlzLngtZS54KStNYXRoLmFicyh0aGlzLnktZS55KStNYXRoLmFicyh0aGlzLnotZS56KX1zZXRGcm9tU3BoZXJpY2FsKGUpe3JldHVybiB0aGlzLnNldEZyb21TcGhlcmljYWxDb29yZHMoZS5yYWRpdXMsZS5waGksZS50aGV0YSl9c2V0RnJvbVNwaGVyaWNhbENvb3JkcyhlLHQsbil7Y29uc3Qgcj1NYXRoLnNpbih0KSplO3JldHVybiB0aGlzLng9cipNYXRoLnNpbihuKSx0aGlzLnk9TWF0aC5jb3ModCkqZSx0aGlzLno9cipNYXRoLmNvcyhuKSx0aGlzfXNldEZyb21DeWxpbmRyaWNhbChlKXtyZXR1cm4gdGhpcy5zZXRGcm9tQ3lsaW5kcmljYWxDb29yZHMoZS5yYWRpdXMsZS50aGV0YSxlLnkpfXNldEZyb21DeWxpbmRyaWNhbENvb3JkcyhlLHQsbil7cmV0dXJuIHRoaXMueD1lKk1hdGguc2luKHQpLHRoaXMueT1uLHRoaXMuej1lKk1hdGguY29zKHQpLHRoaXN9c2V0RnJvbU1hdHJpeFBvc2l0aW9uKGUpe2NvbnN0IHQ9ZS5lbGVtZW50cztyZXR1cm4gdGhpcy54PXRbMTJdLHRoaXMueT10WzEzXSx0aGlzLno9dFsxNF0sdGhpc31zZXRGcm9tTWF0cml4U2NhbGUoZSl7Y29uc3QgdD10aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oZSwwKS5sZW5ndGgoKSxuPXRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbihlLDEpLmxlbmd0aCgpLHI9dGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKGUsMikubGVuZ3RoKCk7cmV0dXJuIHRoaXMueD10LHRoaXMueT1uLHRoaXMuej1yLHRoaXN9c2V0RnJvbU1hdHJpeENvbHVtbihlLHQpe3JldHVybiB0aGlzLmZyb21BcnJheShlLmVsZW1lbnRzLHQqNCl9c2V0RnJvbU1hdHJpeDNDb2x1bW4oZSx0KXtyZXR1cm4gdGhpcy5mcm9tQXJyYXkoZS5lbGVtZW50cyx0KjMpfXNldEZyb21FdWxlcihlKXtyZXR1cm4gdGhpcy54PWUuX3gsdGhpcy55PWUuX3ksdGhpcy56PWUuX3osdGhpc31zZXRGcm9tQ29sb3IoZSl7cmV0dXJuIHRoaXMueD1lLnIsdGhpcy55PWUuZyx0aGlzLno9ZS5iLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLng9PT10aGlzLngmJmUueT09PXRoaXMueSYmZS56PT09dGhpcy56fWZyb21BcnJheShlLHQ9MCl7cmV0dXJuIHRoaXMueD1lW3RdLHRoaXMueT1lW3QrMV0sdGhpcy56PWVbdCsyXSx0aGlzfXRvQXJyYXkoZT1bXSx0PTApe3JldHVybiBlW3RdPXRoaXMueCxlW3QrMV09dGhpcy55LGVbdCsyXT10aGlzLnosZX1mcm9tQnVmZmVyQXR0cmlidXRlKGUsdCl7cmV0dXJuIHRoaXMueD1lLmdldFgodCksdGhpcy55PWUuZ2V0WSh0KSx0aGlzLno9ZS5nZXRaKHQpLHRoaXN9cmFuZG9tKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJhbmRvbSgpLHRoaXMueT1NYXRoLnJhbmRvbSgpLHRoaXMuej1NYXRoLnJhbmRvbSgpLHRoaXN9cmFuZG9tRGlyZWN0aW9uKCl7Y29uc3QgZT1NYXRoLnJhbmRvbSgpKk1hdGguUEkqMix0PU1hdGgucmFuZG9tKCkqMi0xLG49TWF0aC5zcXJ0KDEtdCp0KTtyZXR1cm4gdGhpcy54PW4qTWF0aC5jb3MoZSksdGhpcy55PXQsdGhpcy56PW4qTWF0aC5zaW4oZSksdGhpc30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLngseWllbGQgdGhpcy55LHlpZWxkIHRoaXMuen19Y29uc3QgR2k9bmV3IE8sUHI9bmV3IFhuO2NsYXNzIHFue2NvbnN0cnVjdG9yKGU9bmV3IE8oMS8wLDEvMCwxLzApLHQ9bmV3IE8oLTEvMCwtMS8wLC0xLzApKXt0aGlzLmlzQm94Mz0hMCx0aGlzLm1pbj1lLHRoaXMubWF4PXR9c2V0KGUsdCl7cmV0dXJuIHRoaXMubWluLmNvcHkoZSksdGhpcy5tYXguY29weSh0KSx0aGlzfXNldEZyb21BcnJheShlKXt0aGlzLm1ha2VFbXB0eSgpO2ZvcihsZXQgdD0wLG49ZS5sZW5ndGg7dDxuO3QrPTMpdGhpcy5leHBhbmRCeVBvaW50KEx0LmZyb21BcnJheShlLHQpKTtyZXR1cm4gdGhpc31zZXRGcm9tQnVmZmVyQXR0cmlidXRlKGUpe3RoaXMubWFrZUVtcHR5KCk7Zm9yKGxldCB0PTAsbj1lLmNvdW50O3Q8bjt0KyspdGhpcy5leHBhbmRCeVBvaW50KEx0LmZyb21CdWZmZXJBdHRyaWJ1dGUoZSx0KSk7cmV0dXJuIHRoaXN9c2V0RnJvbVBvaW50cyhlKXt0aGlzLm1ha2VFbXB0eSgpO2ZvcihsZXQgdD0wLG49ZS5sZW5ndGg7dDxuO3QrKyl0aGlzLmV4cGFuZEJ5UG9pbnQoZVt0XSk7cmV0dXJuIHRoaXN9c2V0RnJvbUNlbnRlckFuZFNpemUoZSx0KXtjb25zdCBuPUx0LmNvcHkodCkubXVsdGlwbHlTY2FsYXIoLjUpO3JldHVybiB0aGlzLm1pbi5jb3B5KGUpLnN1YihuKSx0aGlzLm1heC5jb3B5KGUpLmFkZChuKSx0aGlzfXNldEZyb21PYmplY3QoZSx0PSExKXtyZXR1cm4gdGhpcy5tYWtlRW1wdHkoKSx0aGlzLmV4cGFuZEJ5T2JqZWN0KGUsdCl9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfWNvcHkoZSl7cmV0dXJuIHRoaXMubWluLmNvcHkoZS5taW4pLHRoaXMubWF4LmNvcHkoZS5tYXgpLHRoaXN9bWFrZUVtcHR5KCl7cmV0dXJuIHRoaXMubWluLng9dGhpcy5taW4ueT10aGlzLm1pbi56PTEvMCx0aGlzLm1heC54PXRoaXMubWF4Lnk9dGhpcy5tYXguej0tMS8wLHRoaXN9aXNFbXB0eSgpe3JldHVybiB0aGlzLm1heC54PHRoaXMubWluLnh8fHRoaXMubWF4Lnk8dGhpcy5taW4ueXx8dGhpcy5tYXguejx0aGlzLm1pbi56fWdldENlbnRlcihlKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/ZS5zZXQoMCwwLDApOmUuYWRkVmVjdG9ycyh0aGlzLm1pbix0aGlzLm1heCkubXVsdGlwbHlTY2FsYXIoLjUpfWdldFNpemUoZSl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP2Uuc2V0KDAsMCwwKTplLnN1YlZlY3RvcnModGhpcy5tYXgsdGhpcy5taW4pfWV4cGFuZEJ5UG9pbnQoZSl7cmV0dXJuIHRoaXMubWluLm1pbihlKSx0aGlzLm1heC5tYXgoZSksdGhpc31leHBhbmRCeVZlY3RvcihlKXtyZXR1cm4gdGhpcy5taW4uc3ViKGUpLHRoaXMubWF4LmFkZChlKSx0aGlzfWV4cGFuZEJ5U2NhbGFyKGUpe3JldHVybiB0aGlzLm1pbi5hZGRTY2FsYXIoLWUpLHRoaXMubWF4LmFkZFNjYWxhcihlKSx0aGlzfWV4cGFuZEJ5T2JqZWN0KGUsdD0hMSl7ZS51cGRhdGVXb3JsZE1hdHJpeCghMSwhMSk7Y29uc3Qgbj1lLmdlb21ldHJ5O2lmKG4hPT12b2lkIDApe2NvbnN0IHM9bi5nZXRBdHRyaWJ1dGUoInBvc2l0aW9uIik7aWYodD09PSEwJiZzIT09dm9pZCAwJiZlLmlzSW5zdGFuY2VkTWVzaCE9PSEwKWZvcihsZXQgYT0wLG89cy5jb3VudDthPG87YSsrKWUuaXNNZXNoPT09ITA/ZS5nZXRWZXJ0ZXhQb3NpdGlvbihhLEx0KTpMdC5mcm9tQnVmZmVyQXR0cmlidXRlKHMsYSksTHQuYXBwbHlNYXRyaXg0KGUubWF0cml4V29ybGQpLHRoaXMuZXhwYW5kQnlQb2ludChMdCk7ZWxzZSBlLmJvdW5kaW5nQm94IT09dm9pZCAwPyhlLmJvdW5kaW5nQm94PT09bnVsbCYmZS5jb21wdXRlQm91bmRpbmdCb3goKSxzaS5jb3B5KGUuYm91bmRpbmdCb3gpKToobi5ib3VuZGluZ0JveD09PW51bGwmJm4uY29tcHV0ZUJvdW5kaW5nQm94KCksc2kuY29weShuLmJvdW5kaW5nQm94KSksc2kuYXBwbHlNYXRyaXg0KGUubWF0cml4V29ybGQpLHRoaXMudW5pb24oc2kpfWNvbnN0IHI9ZS5jaGlsZHJlbjtmb3IobGV0IHM9MCxhPXIubGVuZ3RoO3M8YTtzKyspdGhpcy5leHBhbmRCeU9iamVjdChyW3NdLHQpO3JldHVybiB0aGlzfWNvbnRhaW5zUG9pbnQoZSl7cmV0dXJuIGUueD49dGhpcy5taW4ueCYmZS54PD10aGlzLm1heC54JiZlLnk+PXRoaXMubWluLnkmJmUueTw9dGhpcy5tYXgueSYmZS56Pj10aGlzLm1pbi56JiZlLno8PXRoaXMubWF4Lnp9Y29udGFpbnNCb3goZSl7cmV0dXJuIHRoaXMubWluLng8PWUubWluLngmJmUubWF4Lng8PXRoaXMubWF4LngmJnRoaXMubWluLnk8PWUubWluLnkmJmUubWF4Lnk8PXRoaXMubWF4LnkmJnRoaXMubWluLno8PWUubWluLnomJmUubWF4Lno8PXRoaXMubWF4Lnp9Z2V0UGFyYW1ldGVyKGUsdCl7cmV0dXJuIHQuc2V0KChlLngtdGhpcy5taW4ueCkvKHRoaXMubWF4LngtdGhpcy5taW4ueCksKGUueS10aGlzLm1pbi55KS8odGhpcy5tYXgueS10aGlzLm1pbi55KSwoZS56LXRoaXMubWluLnopLyh0aGlzLm1heC56LXRoaXMubWluLnopKX1pbnRlcnNlY3RzQm94KGUpe3JldHVybiBlLm1heC54Pj10aGlzLm1pbi54JiZlLm1pbi54PD10aGlzLm1heC54JiZlLm1heC55Pj10aGlzLm1pbi55JiZlLm1pbi55PD10aGlzLm1heC55JiZlLm1heC56Pj10aGlzLm1pbi56JiZlLm1pbi56PD10aGlzLm1heC56fWludGVyc2VjdHNTcGhlcmUoZSl7cmV0dXJuIHRoaXMuY2xhbXBQb2ludChlLmNlbnRlcixMdCksTHQuZGlzdGFuY2VUb1NxdWFyZWQoZS5jZW50ZXIpPD1lLnJhZGl1cyplLnJhZGl1c31pbnRlcnNlY3RzUGxhbmUoZSl7bGV0IHQsbjtyZXR1cm4gZS5ub3JtYWwueD4wPyh0PWUubm9ybWFsLngqdGhpcy5taW4ueCxuPWUubm9ybWFsLngqdGhpcy5tYXgueCk6KHQ9ZS5ub3JtYWwueCp0aGlzLm1heC54LG49ZS5ub3JtYWwueCp0aGlzLm1pbi54KSxlLm5vcm1hbC55PjA/KHQrPWUubm9ybWFsLnkqdGhpcy5taW4ueSxuKz1lLm5vcm1hbC55KnRoaXMubWF4LnkpOih0Kz1lLm5vcm1hbC55KnRoaXMubWF4Lnksbis9ZS5ub3JtYWwueSp0aGlzLm1pbi55KSxlLm5vcm1hbC56PjA/KHQrPWUubm9ybWFsLnoqdGhpcy5taW4ueixuKz1lLm5vcm1hbC56KnRoaXMubWF4LnopOih0Kz1lLm5vcm1hbC56KnRoaXMubWF4Lnosbis9ZS5ub3JtYWwueip0aGlzLm1pbi56KSx0PD0tZS5jb25zdGFudCYmbj49LWUuY29uc3RhbnR9aW50ZXJzZWN0c1RyaWFuZ2xlKGUpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiExO3RoaXMuZ2V0Q2VudGVyKFluKSxhaS5zdWJWZWN0b3JzKHRoaXMubWF4LFluKSxBbi5zdWJWZWN0b3JzKGUuYSxZbiksd24uc3ViVmVjdG9ycyhlLmIsWW4pLGJuLnN1YlZlY3RvcnMoZS5jLFluKSxRdC5zdWJWZWN0b3JzKHduLEFuKSxlbi5zdWJWZWN0b3JzKGJuLHduKSxsbi5zdWJWZWN0b3JzKEFuLGJuKTtsZXQgdD1bMCwtUXQueixRdC55LDAsLWVuLnosZW4ueSwwLC1sbi56LGxuLnksUXQueiwwLC1RdC54LGVuLnosMCwtZW4ueCxsbi56LDAsLWxuLngsLVF0LnksUXQueCwwLC1lbi55LGVuLngsMCwtbG4ueSxsbi54LDBdO3JldHVybiFIaSh0LEFuLHduLGJuLGFpKXx8KHQ9WzEsMCwwLDAsMSwwLDAsMCwxXSwhSGkodCxBbix3bixibixhaSkpPyExOihvaS5jcm9zc1ZlY3RvcnMoUXQsZW4pLHQ9W29pLngsb2kueSxvaS56XSxIaSh0LEFuLHduLGJuLGFpKSl9Y2xhbXBQb2ludChlLHQpe3JldHVybiB0LmNvcHkoZSkuY2xhbXAodGhpcy5taW4sdGhpcy5tYXgpfWRpc3RhbmNlVG9Qb2ludChlKXtyZXR1cm4gdGhpcy5jbGFtcFBvaW50KGUsTHQpLmRpc3RhbmNlVG8oZSl9Z2V0Qm91bmRpbmdTcGhlcmUoZSl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP2UubWFrZUVtcHR5KCk6KHRoaXMuZ2V0Q2VudGVyKGUuY2VudGVyKSxlLnJhZGl1cz10aGlzLmdldFNpemUoTHQpLmxlbmd0aCgpKi41KSxlfWludGVyc2VjdChlKXtyZXR1cm4gdGhpcy5taW4ubWF4KGUubWluKSx0aGlzLm1heC5taW4oZS5tYXgpLHRoaXMuaXNFbXB0eSgpJiZ0aGlzLm1ha2VFbXB0eSgpLHRoaXN9dW5pb24oZSl7cmV0dXJuIHRoaXMubWluLm1pbihlLm1pbiksdGhpcy5tYXgubWF4KGUubWF4KSx0aGlzfWFwcGx5TWF0cml4NChlKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/dGhpczooa3RbMF0uc2V0KHRoaXMubWluLngsdGhpcy5taW4ueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoZSksa3RbMV0uc2V0KHRoaXMubWluLngsdGhpcy5taW4ueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoZSksa3RbMl0uc2V0KHRoaXMubWluLngsdGhpcy5tYXgueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoZSksa3RbM10uc2V0KHRoaXMubWluLngsdGhpcy5tYXgueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoZSksa3RbNF0uc2V0KHRoaXMubWF4LngsdGhpcy5taW4ueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoZSksa3RbNV0uc2V0KHRoaXMubWF4LngsdGhpcy5taW4ueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoZSksa3RbNl0uc2V0KHRoaXMubWF4LngsdGhpcy5tYXgueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoZSksa3RbN10uc2V0KHRoaXMubWF4LngsdGhpcy5tYXgueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoZSksdGhpcy5zZXRGcm9tUG9pbnRzKGt0KSx0aGlzKX10cmFuc2xhdGUoZSl7cmV0dXJuIHRoaXMubWluLmFkZChlKSx0aGlzLm1heC5hZGQoZSksdGhpc31lcXVhbHMoZSl7cmV0dXJuIGUubWluLmVxdWFscyh0aGlzLm1pbikmJmUubWF4LmVxdWFscyh0aGlzLm1heCl9fWNvbnN0IGt0PVtuZXcgTyxuZXcgTyxuZXcgTyxuZXcgTyxuZXcgTyxuZXcgTyxuZXcgTyxuZXcgT10sTHQ9bmV3IE8sc2k9bmV3IHFuLEFuPW5ldyBPLHduPW5ldyBPLGJuPW5ldyBPLFF0PW5ldyBPLGVuPW5ldyBPLGxuPW5ldyBPLFluPW5ldyBPLGFpPW5ldyBPLG9pPW5ldyBPLGNuPW5ldyBPO2Z1bmN0aW9uIEhpKGksZSx0LG4scil7Zm9yKGxldCBzPTAsYT1pLmxlbmd0aC0zO3M8PWE7cys9Myl7Y24uZnJvbUFycmF5KGkscyk7Y29uc3Qgbz1yLngqTWF0aC5hYnMoY24ueCkrci55Kk1hdGguYWJzKGNuLnkpK3IueipNYXRoLmFicyhjbi56KSxsPWUuZG90KGNuKSxjPXQuZG90KGNuKSxoPW4uZG90KGNuKTtpZihNYXRoLm1heCgtTWF0aC5tYXgobCxjLGgpLE1hdGgubWluKGwsYyxoKSk+bylyZXR1cm4hMX1yZXR1cm4hMH1jb25zdCB4YT1uZXcgcW4sJG49bmV3IE8sVmk9bmV3IE87Y2xhc3MgbGl7Y29uc3RydWN0b3IoZT1uZXcgTyx0PS0xKXt0aGlzLmlzU3BoZXJlPSEwLHRoaXMuY2VudGVyPWUsdGhpcy5yYWRpdXM9dH1zZXQoZSx0KXtyZXR1cm4gdGhpcy5jZW50ZXIuY29weShlKSx0aGlzLnJhZGl1cz10LHRoaXN9c2V0RnJvbVBvaW50cyhlLHQpe2NvbnN0IG49dGhpcy5jZW50ZXI7dCE9PXZvaWQgMD9uLmNvcHkodCk6eGEuc2V0RnJvbVBvaW50cyhlKS5nZXRDZW50ZXIobik7bGV0IHI9MDtmb3IobGV0IHM9MCxhPWUubGVuZ3RoO3M8YTtzKyspcj1NYXRoLm1heChyLG4uZGlzdGFuY2VUb1NxdWFyZWQoZVtzXSkpO3JldHVybiB0aGlzLnJhZGl1cz1NYXRoLnNxcnQociksdGhpc31jb3B5KGUpe3JldHVybiB0aGlzLmNlbnRlci5jb3B5KGUuY2VudGVyKSx0aGlzLnJhZGl1cz1lLnJhZGl1cyx0aGlzfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5yYWRpdXM8MH1tYWtlRW1wdHkoKXtyZXR1cm4gdGhpcy5jZW50ZXIuc2V0KDAsMCwwKSx0aGlzLnJhZGl1cz0tMSx0aGlzfWNvbnRhaW5zUG9pbnQoZSl7cmV0dXJuIGUuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5jZW50ZXIpPD10aGlzLnJhZGl1cyp0aGlzLnJhZGl1c31kaXN0YW5jZVRvUG9pbnQoZSl7cmV0dXJuIGUuZGlzdGFuY2VUbyh0aGlzLmNlbnRlciktdGhpcy5yYWRpdXN9aW50ZXJzZWN0c1NwaGVyZShlKXtjb25zdCB0PXRoaXMucmFkaXVzK2UucmFkaXVzO3JldHVybiBlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCh0aGlzLmNlbnRlcik8PXQqdH1pbnRlcnNlY3RzQm94KGUpe3JldHVybiBlLmludGVyc2VjdHNTcGhlcmUodGhpcyl9aW50ZXJzZWN0c1BsYW5lKGUpe3JldHVybiBNYXRoLmFicyhlLmRpc3RhbmNlVG9Qb2ludCh0aGlzLmNlbnRlcikpPD10aGlzLnJhZGl1c31jbGFtcFBvaW50KGUsdCl7Y29uc3Qgbj10aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZChlKTtyZXR1cm4gdC5jb3B5KGUpLG4+dGhpcy5yYWRpdXMqdGhpcy5yYWRpdXMmJih0LnN1Yih0aGlzLmNlbnRlcikubm9ybWFsaXplKCksdC5tdWx0aXBseVNjYWxhcih0aGlzLnJhZGl1cykuYWRkKHRoaXMuY2VudGVyKSksdH1nZXRCb3VuZGluZ0JveChlKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/KGUubWFrZUVtcHR5KCksZSk6KGUuc2V0KHRoaXMuY2VudGVyLHRoaXMuY2VudGVyKSxlLmV4cGFuZEJ5U2NhbGFyKHRoaXMucmFkaXVzKSxlKX1hcHBseU1hdHJpeDQoZSl7cmV0dXJuIHRoaXMuY2VudGVyLmFwcGx5TWF0cml4NChlKSx0aGlzLnJhZGl1cz10aGlzLnJhZGl1cyplLmdldE1heFNjYWxlT25BeGlzKCksdGhpc310cmFuc2xhdGUoZSl7cmV0dXJuIHRoaXMuY2VudGVyLmFkZChlKSx0aGlzfWV4cGFuZEJ5UG9pbnQoZSl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuY2VudGVyLmNvcHkoZSksdGhpcy5yYWRpdXM9MCx0aGlzOyRuLnN1YlZlY3RvcnMoZSx0aGlzLmNlbnRlcik7Y29uc3QgdD0kbi5sZW5ndGhTcSgpO2lmKHQ+dGhpcy5yYWRpdXMqdGhpcy5yYWRpdXMpe2NvbnN0IG49TWF0aC5zcXJ0KHQpLHI9KG4tdGhpcy5yYWRpdXMpKi41O3RoaXMuY2VudGVyLmFkZFNjYWxlZFZlY3RvcigkbixyL24pLHRoaXMucmFkaXVzKz1yfXJldHVybiB0aGlzfXVuaW9uKGUpe3JldHVybiBlLmlzRW1wdHkoKT90aGlzOnRoaXMuaXNFbXB0eSgpPyh0aGlzLmNvcHkoZSksdGhpcyk6KHRoaXMuY2VudGVyLmVxdWFscyhlLmNlbnRlcik9PT0hMD90aGlzLnJhZGl1cz1NYXRoLm1heCh0aGlzLnJhZGl1cyxlLnJhZGl1cyk6KFZpLnN1YlZlY3RvcnMoZS5jZW50ZXIsdGhpcy5jZW50ZXIpLnNldExlbmd0aChlLnJhZGl1cyksdGhpcy5leHBhbmRCeVBvaW50KCRuLmNvcHkoZS5jZW50ZXIpLmFkZChWaSkpLHRoaXMuZXhwYW5kQnlQb2ludCgkbi5jb3B5KGUuY2VudGVyKS5zdWIoVmkpKSksdGhpcyl9ZXF1YWxzKGUpe3JldHVybiBlLmNlbnRlci5lcXVhbHModGhpcy5jZW50ZXIpJiZlLnJhZGl1cz09PXRoaXMucmFkaXVzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX19Y29uc3QgV3Q9bmV3IE8sa2k9bmV3IE8sY2k9bmV3IE8sdG49bmV3IE8sV2k9bmV3IE8sdWk9bmV3IE8sWGk9bmV3IE87Y2xhc3MgRHJ7Y29uc3RydWN0b3IoZT1uZXcgTyx0PW5ldyBPKDAsMCwtMSkpe3RoaXMub3JpZ2luPWUsdGhpcy5kaXJlY3Rpb249dH1zZXQoZSx0KXtyZXR1cm4gdGhpcy5vcmlnaW4uY29weShlKSx0aGlzLmRpcmVjdGlvbi5jb3B5KHQpLHRoaXN9Y29weShlKXtyZXR1cm4gdGhpcy5vcmlnaW4uY29weShlLm9yaWdpbiksdGhpcy5kaXJlY3Rpb24uY29weShlLmRpcmVjdGlvbiksdGhpc31hdChlLHQpe3JldHVybiB0LmNvcHkodGhpcy5vcmlnaW4pLmFkZFNjYWxlZFZlY3Rvcih0aGlzLmRpcmVjdGlvbixlKX1sb29rQXQoZSl7cmV0dXJuIHRoaXMuZGlyZWN0aW9uLmNvcHkoZSkuc3ViKHRoaXMub3JpZ2luKS5ub3JtYWxpemUoKSx0aGlzfXJlY2FzdChlKXtyZXR1cm4gdGhpcy5vcmlnaW4uY29weSh0aGlzLmF0KGUsV3QpKSx0aGlzfWNsb3Nlc3RQb2ludFRvUG9pbnQoZSx0KXt0LnN1YlZlY3RvcnMoZSx0aGlzLm9yaWdpbik7Y29uc3Qgbj10LmRvdCh0aGlzLmRpcmVjdGlvbik7cmV0dXJuIG48MD90LmNvcHkodGhpcy5vcmlnaW4pOnQuY29weSh0aGlzLm9yaWdpbikuYWRkU2NhbGVkVmVjdG9yKHRoaXMuZGlyZWN0aW9uLG4pfWRpc3RhbmNlVG9Qb2ludChlKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQoZSkpfWRpc3RhbmNlU3FUb1BvaW50KGUpe2NvbnN0IHQ9V3Quc3ViVmVjdG9ycyhlLHRoaXMub3JpZ2luKS5kb3QodGhpcy5kaXJlY3Rpb24pO3JldHVybiB0PDA/dGhpcy5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQoZSk6KFd0LmNvcHkodGhpcy5vcmlnaW4pLmFkZFNjYWxlZFZlY3Rvcih0aGlzLmRpcmVjdGlvbix0KSxXdC5kaXN0YW5jZVRvU3F1YXJlZChlKSl9ZGlzdGFuY2VTcVRvU2VnbWVudChlLHQsbixyKXtraS5jb3B5KGUpLmFkZCh0KS5tdWx0aXBseVNjYWxhciguNSksY2kuY29weSh0KS5zdWIoZSkubm9ybWFsaXplKCksdG4uY29weSh0aGlzLm9yaWdpbikuc3ViKGtpKTtjb25zdCBzPWUuZGlzdGFuY2VUbyh0KSouNSxhPS10aGlzLmRpcmVjdGlvbi5kb3QoY2kpLG89dG4uZG90KHRoaXMuZGlyZWN0aW9uKSxsPS10bi5kb3QoY2kpLGM9dG4ubGVuZ3RoU3EoKSxoPU1hdGguYWJzKDEtYSphKTtsZXQgZCxmLHAsXztpZihoPjApaWYoZD1hKmwtbyxmPWEqby1sLF89cypoLGQ+PTApaWYoZj49LV8paWYoZjw9Xyl7Y29uc3QgeD0xL2g7ZCo9eCxmKj14LHA9ZCooZCthKmYrMipvKStmKihhKmQrZisyKmwpK2N9ZWxzZSBmPXMsZD1NYXRoLm1heCgwLC0oYSpmK28pKSxwPS1kKmQrZiooZisyKmwpK2M7ZWxzZSBmPS1zLGQ9TWF0aC5tYXgoMCwtKGEqZitvKSkscD0tZCpkK2YqKGYrMipsKStjO2Vsc2UgZjw9LV8/KGQ9TWF0aC5tYXgoMCwtKC1hKnMrbykpLGY9ZD4wPy1zOk1hdGgubWluKE1hdGgubWF4KC1zLC1sKSxzKSxwPS1kKmQrZiooZisyKmwpK2MpOmY8PV8/KGQ9MCxmPU1hdGgubWluKE1hdGgubWF4KC1zLC1sKSxzKSxwPWYqKGYrMipsKStjKTooZD1NYXRoLm1heCgwLC0oYSpzK28pKSxmPWQ+MD9zOk1hdGgubWluKE1hdGgubWF4KC1zLC1sKSxzKSxwPS1kKmQrZiooZisyKmwpK2MpO2Vsc2UgZj1hPjA/LXM6cyxkPU1hdGgubWF4KDAsLShhKmYrbykpLHA9LWQqZCtmKihmKzIqbCkrYztyZXR1cm4gbiYmbi5jb3B5KHRoaXMub3JpZ2luKS5hZGRTY2FsZWRWZWN0b3IodGhpcy5kaXJlY3Rpb24sZCksciYmci5jb3B5KGtpKS5hZGRTY2FsZWRWZWN0b3IoY2ksZikscH1pbnRlcnNlY3RTcGhlcmUoZSx0KXtXdC5zdWJWZWN0b3JzKGUuY2VudGVyLHRoaXMub3JpZ2luKTtjb25zdCBuPVd0LmRvdCh0aGlzLmRpcmVjdGlvbikscj1XdC5kb3QoV3QpLW4qbixzPWUucmFkaXVzKmUucmFkaXVzO2lmKHI+cylyZXR1cm4gbnVsbDtjb25zdCBhPU1hdGguc3FydChzLXIpLG89bi1hLGw9bithO3JldHVybiBsPDA/bnVsbDpvPDA/dGhpcy5hdChsLHQpOnRoaXMuYXQobyx0KX1pbnRlcnNlY3RzU3BoZXJlKGUpe3JldHVybiB0aGlzLmRpc3RhbmNlU3FUb1BvaW50KGUuY2VudGVyKTw9ZS5yYWRpdXMqZS5yYWRpdXN9ZGlzdGFuY2VUb1BsYW5lKGUpe2NvbnN0IHQ9ZS5ub3JtYWwuZG90KHRoaXMuZGlyZWN0aW9uKTtpZih0PT09MClyZXR1cm4gZS5kaXN0YW5jZVRvUG9pbnQodGhpcy5vcmlnaW4pPT09MD8wOm51bGw7Y29uc3Qgbj0tKHRoaXMub3JpZ2luLmRvdChlLm5vcm1hbCkrZS5jb25zdGFudCkvdDtyZXR1cm4gbj49MD9uOm51bGx9aW50ZXJzZWN0UGxhbmUoZSx0KXtjb25zdCBuPXRoaXMuZGlzdGFuY2VUb1BsYW5lKGUpO3JldHVybiBuPT09bnVsbD9udWxsOnRoaXMuYXQobix0KX1pbnRlcnNlY3RzUGxhbmUoZSl7Y29uc3QgdD1lLmRpc3RhbmNlVG9Qb2ludCh0aGlzLm9yaWdpbik7cmV0dXJuIHQ9PT0wfHxlLm5vcm1hbC5kb3QodGhpcy5kaXJlY3Rpb24pKnQ8MH1pbnRlcnNlY3RCb3goZSx0KXtsZXQgbixyLHMsYSxvLGw7Y29uc3QgYz0xL3RoaXMuZGlyZWN0aW9uLngsaD0xL3RoaXMuZGlyZWN0aW9uLnksZD0xL3RoaXMuZGlyZWN0aW9uLnosZj10aGlzLm9yaWdpbjtyZXR1cm4gYz49MD8obj0oZS5taW4ueC1mLngpKmMscj0oZS5tYXgueC1mLngpKmMpOihuPShlLm1heC54LWYueCkqYyxyPShlLm1pbi54LWYueCkqYyksaD49MD8ocz0oZS5taW4ueS1mLnkpKmgsYT0oZS5tYXgueS1mLnkpKmgpOihzPShlLm1heC55LWYueSkqaCxhPShlLm1pbi55LWYueSkqaCksbj5hfHxzPnJ8fCgocz5ufHxpc05hTihuKSkmJihuPXMpLChhPHJ8fGlzTmFOKHIpKSYmKHI9YSksZD49MD8obz0oZS5taW4uei1mLnopKmQsbD0oZS5tYXguei1mLnopKmQpOihvPShlLm1heC56LWYueikqZCxsPShlLm1pbi56LWYueikqZCksbj5sfHxvPnIpfHwoKG8+bnx8biE9PW4pJiYobj1vKSwobDxyfHxyIT09cikmJihyPWwpLHI8MCk/bnVsbDp0aGlzLmF0KG4+PTA/bjpyLHQpfWludGVyc2VjdHNCb3goZSl7cmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KGUsV3QpIT09bnVsbH1pbnRlcnNlY3RUcmlhbmdsZShlLHQsbixyLHMpe1dpLnN1YlZlY3RvcnModCxlKSx1aS5zdWJWZWN0b3JzKG4sZSksWGkuY3Jvc3NWZWN0b3JzKFdpLHVpKTtsZXQgYT10aGlzLmRpcmVjdGlvbi5kb3QoWGkpLG87aWYoYT4wKXtpZihyKXJldHVybiBudWxsO289MX1lbHNlIGlmKGE8MClvPS0xLGE9LWE7ZWxzZSByZXR1cm4gbnVsbDt0bi5zdWJWZWN0b3JzKHRoaXMub3JpZ2luLGUpO2NvbnN0IGw9byp0aGlzLmRpcmVjdGlvbi5kb3QodWkuY3Jvc3NWZWN0b3JzKHRuLHVpKSk7aWYobDwwKXJldHVybiBudWxsO2NvbnN0IGM9byp0aGlzLmRpcmVjdGlvbi5kb3QoV2kuY3Jvc3ModG4pKTtpZihjPDB8fGwrYz5hKXJldHVybiBudWxsO2NvbnN0IGg9LW8qdG4uZG90KFhpKTtyZXR1cm4gaDwwP251bGw6dGhpcy5hdChoL2Escyl9YXBwbHlNYXRyaXg0KGUpe3JldHVybiB0aGlzLm9yaWdpbi5hcHBseU1hdHJpeDQoZSksdGhpcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKGUpLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLm9yaWdpbi5lcXVhbHModGhpcy5vcmlnaW4pJiZlLmRpcmVjdGlvbi5lcXVhbHModGhpcy5kaXJlY3Rpb24pfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX19Y2xhc3Mgc3R7Y29uc3RydWN0b3IoZSx0LG4scixzLGEsbyxsLGMsaCxkLGYscCxfLHgsbSl7c3QucHJvdG90eXBlLmlzTWF0cml4ND0hMCx0aGlzLmVsZW1lbnRzPVsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxXSxlIT09dm9pZCAwJiZ0aGlzLnNldChlLHQsbixyLHMsYSxvLGwsYyxoLGQsZixwLF8seCxtKX1zZXQoZSx0LG4scixzLGEsbyxsLGMsaCxkLGYscCxfLHgsbSl7Y29uc3QgdT10aGlzLmVsZW1lbnRzO3JldHVybiB1WzBdPWUsdVs0XT10LHVbOF09bix1WzEyXT1yLHVbMV09cyx1WzVdPWEsdVs5XT1vLHVbMTNdPWwsdVsyXT1jLHVbNl09aCx1WzEwXT1kLHVbMTRdPWYsdVszXT1wLHVbN109Xyx1WzExXT14LHVbMTVdPW0sdGhpc31pZGVudGl0eSgpe3JldHVybiB0aGlzLnNldCgxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyBzdCgpLmZyb21BcnJheSh0aGlzLmVsZW1lbnRzKX1jb3B5KGUpe2NvbnN0IHQ9dGhpcy5lbGVtZW50cyxuPWUuZWxlbWVudHM7cmV0dXJuIHRbMF09blswXSx0WzFdPW5bMV0sdFsyXT1uWzJdLHRbM109blszXSx0WzRdPW5bNF0sdFs1XT1uWzVdLHRbNl09bls2XSx0WzddPW5bN10sdFs4XT1uWzhdLHRbOV09bls5XSx0WzEwXT1uWzEwXSx0WzExXT1uWzExXSx0WzEyXT1uWzEyXSx0WzEzXT1uWzEzXSx0WzE0XT1uWzE0XSx0WzE1XT1uWzE1XSx0aGlzfWNvcHlQb3NpdGlvbihlKXtjb25zdCB0PXRoaXMuZWxlbWVudHMsbj1lLmVsZW1lbnRzO3JldHVybiB0WzEyXT1uWzEyXSx0WzEzXT1uWzEzXSx0WzE0XT1uWzE0XSx0aGlzfXNldEZyb21NYXRyaXgzKGUpe2NvbnN0IHQ9ZS5lbGVtZW50cztyZXR1cm4gdGhpcy5zZXQodFswXSx0WzNdLHRbNl0sMCx0WzFdLHRbNF0sdFs3XSwwLHRbMl0sdFs1XSx0WzhdLDAsMCwwLDAsMSksdGhpc31leHRyYWN0QmFzaXMoZSx0LG4pe3JldHVybiBlLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywwKSx0LnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywxKSxuLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywyKSx0aGlzfW1ha2VCYXNpcyhlLHQsbil7cmV0dXJuIHRoaXMuc2V0KGUueCx0Lngsbi54LDAsZS55LHQueSxuLnksMCxlLnosdC56LG4ueiwwLDAsMCwwLDEpLHRoaXN9ZXh0cmFjdFJvdGF0aW9uKGUpe2NvbnN0IHQ9dGhpcy5lbGVtZW50cyxuPWUuZWxlbWVudHMscj0xL1JuLnNldEZyb21NYXRyaXhDb2x1bW4oZSwwKS5sZW5ndGgoKSxzPTEvUm4uc2V0RnJvbU1hdHJpeENvbHVtbihlLDEpLmxlbmd0aCgpLGE9MS9Sbi5zZXRGcm9tTWF0cml4Q29sdW1uKGUsMikubGVuZ3RoKCk7cmV0dXJuIHRbMF09blswXSpyLHRbMV09blsxXSpyLHRbMl09blsyXSpyLHRbM109MCx0WzRdPW5bNF0qcyx0WzVdPW5bNV0qcyx0WzZdPW5bNl0qcyx0WzddPTAsdFs4XT1uWzhdKmEsdFs5XT1uWzldKmEsdFsxMF09blsxMF0qYSx0WzExXT0wLHRbMTJdPTAsdFsxM109MCx0WzE0XT0wLHRbMTVdPTEsdGhpc31tYWtlUm90YXRpb25Gcm9tRXVsZXIoZSl7Y29uc3QgdD10aGlzLmVsZW1lbnRzLG49ZS54LHI9ZS55LHM9ZS56LGE9TWF0aC5jb3Mobiksbz1NYXRoLnNpbihuKSxsPU1hdGguY29zKHIpLGM9TWF0aC5zaW4ociksaD1NYXRoLmNvcyhzKSxkPU1hdGguc2luKHMpO2lmKGUub3JkZXI9PT0iWFlaIil7Y29uc3QgZj1hKmgscD1hKmQsXz1vKmgseD1vKmQ7dFswXT1sKmgsdFs0XT0tbCpkLHRbOF09Yyx0WzFdPXArXypjLHRbNV09Zi14KmMsdFs5XT0tbypsLHRbMl09eC1mKmMsdFs2XT1fK3AqYyx0WzEwXT1hKmx9ZWxzZSBpZihlLm9yZGVyPT09IllYWiIpe2NvbnN0IGY9bCpoLHA9bCpkLF89YypoLHg9YypkO3RbMF09Zit4Km8sdFs0XT1fKm8tcCx0WzhdPWEqYyx0WzFdPWEqZCx0WzVdPWEqaCx0WzldPS1vLHRbMl09cCpvLV8sdFs2XT14K2Yqbyx0WzEwXT1hKmx9ZWxzZSBpZihlLm9yZGVyPT09IlpYWSIpe2NvbnN0IGY9bCpoLHA9bCpkLF89YypoLHg9YypkO3RbMF09Zi14Km8sdFs0XT0tYSpkLHRbOF09XytwKm8sdFsxXT1wK18qbyx0WzVdPWEqaCx0WzldPXgtZipvLHRbMl09LWEqYyx0WzZdPW8sdFsxMF09YSpsfWVsc2UgaWYoZS5vcmRlcj09PSJaWVgiKXtjb25zdCBmPWEqaCxwPWEqZCxfPW8qaCx4PW8qZDt0WzBdPWwqaCx0WzRdPV8qYy1wLHRbOF09ZipjK3gsdFsxXT1sKmQsdFs1XT14KmMrZix0WzldPXAqYy1fLHRbMl09LWMsdFs2XT1vKmwsdFsxMF09YSpsfWVsc2UgaWYoZS5vcmRlcj09PSJZWlgiKXtjb25zdCBmPWEqbCxwPWEqYyxfPW8qbCx4PW8qYzt0WzBdPWwqaCx0WzRdPXgtZipkLHRbOF09XypkK3AsdFsxXT1kLHRbNV09YSpoLHRbOV09LW8qaCx0WzJdPS1jKmgsdFs2XT1wKmQrXyx0WzEwXT1mLXgqZH1lbHNlIGlmKGUub3JkZXI9PT0iWFpZIil7Y29uc3QgZj1hKmwscD1hKmMsXz1vKmwseD1vKmM7dFswXT1sKmgsdFs0XT0tZCx0WzhdPWMqaCx0WzFdPWYqZCt4LHRbNV09YSpoLHRbOV09cCpkLV8sdFsyXT1fKmQtcCx0WzZdPW8qaCx0WzEwXT14KmQrZn1yZXR1cm4gdFszXT0wLHRbN109MCx0WzExXT0wLHRbMTJdPTAsdFsxM109MCx0WzE0XT0wLHRbMTVdPTEsdGhpc31tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihlKXtyZXR1cm4gdGhpcy5jb21wb3NlKE1hLGUsU2EpfWxvb2tBdChlLHQsbil7Y29uc3Qgcj10aGlzLmVsZW1lbnRzO3JldHVybiB5dC5zdWJWZWN0b3JzKGUsdCkseXQubGVuZ3RoU3EoKT09PTAmJih5dC56PTEpLHl0Lm5vcm1hbGl6ZSgpLG5uLmNyb3NzVmVjdG9ycyhuLHl0KSxubi5sZW5ndGhTcSgpPT09MCYmKE1hdGguYWJzKG4ueik9PT0xP3l0LngrPTFlLTQ6eXQueis9MWUtNCx5dC5ub3JtYWxpemUoKSxubi5jcm9zc1ZlY3RvcnMobix5dCkpLG5uLm5vcm1hbGl6ZSgpLGhpLmNyb3NzVmVjdG9ycyh5dCxubiksclswXT1ubi54LHJbNF09aGkueCxyWzhdPXl0LngsclsxXT1ubi55LHJbNV09aGkueSxyWzldPXl0LnksclsyXT1ubi56LHJbNl09aGkueixyWzEwXT15dC56LHRoaXN9bXVsdGlwbHkoZSl7cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyh0aGlzLGUpfXByZW11bHRpcGx5KGUpe3JldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoZSx0aGlzKX1tdWx0aXBseU1hdHJpY2VzKGUsdCl7Y29uc3Qgbj1lLmVsZW1lbnRzLHI9dC5lbGVtZW50cyxzPXRoaXMuZWxlbWVudHMsYT1uWzBdLG89bls0XSxsPW5bOF0sYz1uWzEyXSxoPW5bMV0sZD1uWzVdLGY9bls5XSxwPW5bMTNdLF89blsyXSx4PW5bNl0sbT1uWzEwXSx1PW5bMTRdLFQ9blszXSx5PW5bN10sZz1uWzExXSxQPW5bMTVdLHc9clswXSxiPXJbNF0sRj1yWzhdLEU9clsxMl0sUz1yWzFdLFI9cls1XSxxPXJbOV0sej1yWzEzXSxXPXJbMl0sWj1yWzZdLFY9clsxMF0sUT1yWzE0XSxIPXJbM10saWU9cls3XSxjZT1yWzExXSx4ZT1yWzE1XTtyZXR1cm4gc1swXT1hKncrbypTK2wqVytjKkgsc1s0XT1hKmIrbypSK2wqWitjKmllLHNbOF09YSpGK28qcStsKlYrYypjZSxzWzEyXT1hKkUrbyp6K2wqUStjKnhlLHNbMV09aCp3K2QqUytmKlcrcCpILHNbNV09aCpiK2QqUitmKlorcCppZSxzWzldPWgqRitkKnErZipWK3AqY2Usc1sxM109aCpFK2QqeitmKlErcCp4ZSxzWzJdPV8qdyt4KlMrbSpXK3UqSCxzWzZdPV8qYit4KlIrbSpaK3UqaWUsc1sxMF09XypGK3gqcSttKlYrdSpjZSxzWzE0XT1fKkUreCp6K20qUSt1KnhlLHNbM109VCp3K3kqUytnKlcrUCpILHNbN109VCpiK3kqUitnKlorUCppZSxzWzExXT1UKkYreSpxK2cqVitQKmNlLHNbMTVdPVQqRSt5KnorZypRK1AqeGUsdGhpc31tdWx0aXBseVNjYWxhcihlKXtjb25zdCB0PXRoaXMuZWxlbWVudHM7cmV0dXJuIHRbMF0qPWUsdFs0XSo9ZSx0WzhdKj1lLHRbMTJdKj1lLHRbMV0qPWUsdFs1XSo9ZSx0WzldKj1lLHRbMTNdKj1lLHRbMl0qPWUsdFs2XSo9ZSx0WzEwXSo9ZSx0WzE0XSo9ZSx0WzNdKj1lLHRbN10qPWUsdFsxMV0qPWUsdFsxNV0qPWUsdGhpc31kZXRlcm1pbmFudCgpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyx0PWVbMF0sbj1lWzRdLHI9ZVs4XSxzPWVbMTJdLGE9ZVsxXSxvPWVbNV0sbD1lWzldLGM9ZVsxM10saD1lWzJdLGQ9ZVs2XSxmPWVbMTBdLHA9ZVsxNF0sXz1lWzNdLHg9ZVs3XSxtPWVbMTFdLHU9ZVsxNV07cmV0dXJuIF8qKCtzKmwqZC1yKmMqZC1zKm8qZituKmMqZityKm8qcC1uKmwqcCkreCooK3QqbCpwLXQqYypmK3MqYSpmLXIqYSpwK3IqYypoLXMqbCpoKSttKigrdCpjKmQtdCpvKnAtcyphKmQrbiphKnArcypvKmgtbipjKmgpK3UqKC1yKm8qaC10KmwqZCt0Km8qZityKmEqZC1uKmEqZituKmwqaCl9dHJhbnNwb3NlKCl7Y29uc3QgZT10aGlzLmVsZW1lbnRzO2xldCB0O3JldHVybiB0PWVbMV0sZVsxXT1lWzRdLGVbNF09dCx0PWVbMl0sZVsyXT1lWzhdLGVbOF09dCx0PWVbNl0sZVs2XT1lWzldLGVbOV09dCx0PWVbM10sZVszXT1lWzEyXSxlWzEyXT10LHQ9ZVs3XSxlWzddPWVbMTNdLGVbMTNdPXQsdD1lWzExXSxlWzExXT1lWzE0XSxlWzE0XT10LHRoaXN9c2V0UG9zaXRpb24oZSx0LG4pe2NvbnN0IHI9dGhpcy5lbGVtZW50cztyZXR1cm4gZS5pc1ZlY3RvcjM/KHJbMTJdPWUueCxyWzEzXT1lLnksclsxNF09ZS56KTooclsxMl09ZSxyWzEzXT10LHJbMTRdPW4pLHRoaXN9aW52ZXJ0KCl7Y29uc3QgZT10aGlzLmVsZW1lbnRzLHQ9ZVswXSxuPWVbMV0scj1lWzJdLHM9ZVszXSxhPWVbNF0sbz1lWzVdLGw9ZVs2XSxjPWVbN10saD1lWzhdLGQ9ZVs5XSxmPWVbMTBdLHA9ZVsxMV0sXz1lWzEyXSx4PWVbMTNdLG09ZVsxNF0sdT1lWzE1XSxUPWQqbSpjLXgqZipjK3gqbCpwLW8qbSpwLWQqbCp1K28qZip1LHk9XypmKmMtaCptKmMtXypsKnArYSptKnAraCpsKnUtYSpmKnUsZz1oKngqYy1fKmQqYytfKm8qcC1hKngqcC1oKm8qdSthKmQqdSxQPV8qZCpsLWgqeCpsLV8qbypmK2EqeCpmK2gqbyptLWEqZCptLHc9dCpUK24qeStyKmcrcypQO2lmKHc9PT0wKXJldHVybiB0aGlzLnNldCgwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwKTtjb25zdCBiPTEvdztyZXR1cm4gZVswXT1UKmIsZVsxXT0oeCpmKnMtZCptKnMteCpyKnArbiptKnArZCpyKnUtbipmKnUpKmIsZVsyXT0obyptKnMteCpsKnMreCpyKmMtbiptKmMtbypyKnUrbipsKnUpKmIsZVszXT0oZCpsKnMtbypmKnMtZCpyKmMrbipmKmMrbypyKnAtbipsKnApKmIsZVs0XT15KmIsZVs1XT0oaCptKnMtXypmKnMrXypyKnAtdCptKnAtaCpyKnUrdCpmKnUpKmIsZVs2XT0oXypsKnMtYSptKnMtXypyKmMrdCptKmMrYSpyKnUtdCpsKnUpKmIsZVs3XT0oYSpmKnMtaCpsKnMraCpyKmMtdCpmKmMtYSpyKnArdCpsKnApKmIsZVs4XT1nKmIsZVs5XT0oXypkKnMtaCp4KnMtXypuKnArdCp4KnAraCpuKnUtdCpkKnUpKmIsZVsxMF09KGEqeCpzLV8qbypzK18qbipjLXQqeCpjLWEqbip1K3Qqbyp1KSpiLGVbMTFdPShoKm8qcy1hKmQqcy1oKm4qYyt0KmQqYythKm4qcC10Km8qcCkqYixlWzEyXT1QKmIsZVsxM109KGgqeCpyLV8qZCpyK18qbipmLXQqeCpmLWgqbiptK3QqZCptKSpiLGVbMTRdPShfKm8qci1hKngqci1fKm4qbCt0KngqbCthKm4qbS10Km8qbSkqYixlWzE1XT0oYSpkKnItaCpvKnIraCpuKmwtdCpkKmwtYSpuKmYrdCpvKmYpKmIsdGhpc31zY2FsZShlKXtjb25zdCB0PXRoaXMuZWxlbWVudHMsbj1lLngscj1lLnkscz1lLno7cmV0dXJuIHRbMF0qPW4sdFs0XSo9cix0WzhdKj1zLHRbMV0qPW4sdFs1XSo9cix0WzldKj1zLHRbMl0qPW4sdFs2XSo9cix0WzEwXSo9cyx0WzNdKj1uLHRbN10qPXIsdFsxMV0qPXMsdGhpc31nZXRNYXhTY2FsZU9uQXhpcygpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyx0PWVbMF0qZVswXStlWzFdKmVbMV0rZVsyXSplWzJdLG49ZVs0XSplWzRdK2VbNV0qZVs1XStlWzZdKmVbNl0scj1lWzhdKmVbOF0rZVs5XSplWzldK2VbMTBdKmVbMTBdO3JldHVybiBNYXRoLnNxcnQoTWF0aC5tYXgodCxuLHIpKX1tYWtlVHJhbnNsYXRpb24oZSx0LG4pe3JldHVybiBlLmlzVmVjdG9yMz90aGlzLnNldCgxLDAsMCxlLngsMCwxLDAsZS55LDAsMCwxLGUueiwwLDAsMCwxKTp0aGlzLnNldCgxLDAsMCxlLDAsMSwwLHQsMCwwLDEsbiwwLDAsMCwxKSx0aGlzfW1ha2VSb3RhdGlvblgoZSl7Y29uc3QgdD1NYXRoLmNvcyhlKSxuPU1hdGguc2luKGUpO3JldHVybiB0aGlzLnNldCgxLDAsMCwwLDAsdCwtbiwwLDAsbix0LDAsMCwwLDAsMSksdGhpc31tYWtlUm90YXRpb25ZKGUpe2NvbnN0IHQ9TWF0aC5jb3MoZSksbj1NYXRoLnNpbihlKTtyZXR1cm4gdGhpcy5zZXQodCwwLG4sMCwwLDEsMCwwLC1uLDAsdCwwLDAsMCwwLDEpLHRoaXN9bWFrZVJvdGF0aW9uWihlKXtjb25zdCB0PU1hdGguY29zKGUpLG49TWF0aC5zaW4oZSk7cmV0dXJuIHRoaXMuc2V0KHQsLW4sMCwwLG4sdCwwLDAsMCwwLDEsMCwwLDAsMCwxKSx0aGlzfW1ha2VSb3RhdGlvbkF4aXMoZSx0KXtjb25zdCBuPU1hdGguY29zKHQpLHI9TWF0aC5zaW4odCkscz0xLW4sYT1lLngsbz1lLnksbD1lLnosYz1zKmEsaD1zKm87cmV0dXJuIHRoaXMuc2V0KGMqYStuLGMqby1yKmwsYypsK3IqbywwLGMqbytyKmwsaCpvK24saCpsLXIqYSwwLGMqbC1yKm8saCpsK3IqYSxzKmwqbCtuLDAsMCwwLDAsMSksdGhpc31tYWtlU2NhbGUoZSx0LG4pe3JldHVybiB0aGlzLnNldChlLDAsMCwwLDAsdCwwLDAsMCwwLG4sMCwwLDAsMCwxKSx0aGlzfW1ha2VTaGVhcihlLHQsbixyLHMsYSl7cmV0dXJuIHRoaXMuc2V0KDEsbixzLDAsZSwxLGEsMCx0LHIsMSwwLDAsMCwwLDEpLHRoaXN9Y29tcG9zZShlLHQsbil7Y29uc3Qgcj10aGlzLmVsZW1lbnRzLHM9dC5feCxhPXQuX3ksbz10Ll96LGw9dC5fdyxjPXMrcyxoPWErYSxkPW8rbyxmPXMqYyxwPXMqaCxfPXMqZCx4PWEqaCxtPWEqZCx1PW8qZCxUPWwqYyx5PWwqaCxnPWwqZCxQPW4ueCx3PW4ueSxiPW4uejtyZXR1cm4gclswXT0oMS0oeCt1KSkqUCxyWzFdPShwK2cpKlAsclsyXT0oXy15KSpQLHJbM109MCxyWzRdPShwLWcpKncscls1XT0oMS0oZit1KSkqdyxyWzZdPShtK1QpKncscls3XT0wLHJbOF09KF8reSkqYixyWzldPShtLVQpKmIsclsxMF09KDEtKGYreCkpKmIsclsxMV09MCxyWzEyXT1lLngsclsxM109ZS55LHJbMTRdPWUueixyWzE1XT0xLHRoaXN9ZGVjb21wb3NlKGUsdCxuKXtjb25zdCByPXRoaXMuZWxlbWVudHM7bGV0IHM9Um4uc2V0KHJbMF0sclsxXSxyWzJdKS5sZW5ndGgoKTtjb25zdCBhPVJuLnNldChyWzRdLHJbNV0scls2XSkubGVuZ3RoKCksbz1Sbi5zZXQocls4XSxyWzldLHJbMTBdKS5sZW5ndGgoKTt0aGlzLmRldGVybWluYW50KCk8MCYmKHM9LXMpLGUueD1yWzEyXSxlLnk9clsxM10sZS56PXJbMTRdLFV0LmNvcHkodGhpcyk7Y29uc3QgYz0xL3MsaD0xL2EsZD0xL287cmV0dXJuIFV0LmVsZW1lbnRzWzBdKj1jLFV0LmVsZW1lbnRzWzFdKj1jLFV0LmVsZW1lbnRzWzJdKj1jLFV0LmVsZW1lbnRzWzRdKj1oLFV0LmVsZW1lbnRzWzVdKj1oLFV0LmVsZW1lbnRzWzZdKj1oLFV0LmVsZW1lbnRzWzhdKj1kLFV0LmVsZW1lbnRzWzldKj1kLFV0LmVsZW1lbnRzWzEwXSo9ZCx0LnNldEZyb21Sb3RhdGlvbk1hdHJpeChVdCksbi54PXMsbi55PWEsbi56PW8sdGhpc31tYWtlUGVyc3BlY3RpdmUoZSx0LG4scixzLGEsbz0yZTMpe2NvbnN0IGw9dGhpcy5lbGVtZW50cyxjPTIqcy8odC1lKSxoPTIqcy8obi1yKSxkPSh0K2UpLyh0LWUpLGY9KG4rcikvKG4tcik7bGV0IHAsXztpZihvPT09MmUzKXA9LShhK3MpLyhhLXMpLF89LTIqYSpzLyhhLXMpO2Vsc2UgaWYobz09PTIwMDEpcD0tYS8oYS1zKSxfPS1hKnMvKGEtcyk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLk1hdHJpeDQubWFrZVBlcnNwZWN0aXZlKCk6IEludmFsaWQgY29vcmRpbmF0ZSBzeXN0ZW06ICIrbyk7cmV0dXJuIGxbMF09YyxsWzRdPTAsbFs4XT1kLGxbMTJdPTAsbFsxXT0wLGxbNV09aCxsWzldPWYsbFsxM109MCxsWzJdPTAsbFs2XT0wLGxbMTBdPXAsbFsxNF09XyxsWzNdPTAsbFs3XT0wLGxbMTFdPS0xLGxbMTVdPTAsdGhpc31tYWtlT3J0aG9ncmFwaGljKGUsdCxuLHIscyxhLG89MmUzKXtjb25zdCBsPXRoaXMuZWxlbWVudHMsYz0xLyh0LWUpLGg9MS8obi1yKSxkPTEvKGEtcyksZj0odCtlKSpjLHA9KG4rcikqaDtsZXQgXyx4O2lmKG89PT0yZTMpXz0oYStzKSpkLHg9LTIqZDtlbHNlIGlmKG89PT0yMDAxKV89cypkLHg9LTEqZDtlbHNlIHRocm93IG5ldyBFcnJvcigiVEhSRUUuTWF0cml4NC5tYWtlT3J0aG9ncmFwaGljKCk6IEludmFsaWQgY29vcmRpbmF0ZSBzeXN0ZW06ICIrbyk7cmV0dXJuIGxbMF09MipjLGxbNF09MCxsWzhdPTAsbFsxMl09LWYsbFsxXT0wLGxbNV09MipoLGxbOV09MCxsWzEzXT0tcCxsWzJdPTAsbFs2XT0wLGxbMTBdPXgsbFsxNF09LV8sbFszXT0wLGxbN109MCxsWzExXT0wLGxbMTVdPTEsdGhpc31lcXVhbHMoZSl7Y29uc3QgdD10aGlzLmVsZW1lbnRzLG49ZS5lbGVtZW50cztmb3IobGV0IHI9MDtyPDE2O3IrKylpZih0W3JdIT09bltyXSlyZXR1cm4hMTtyZXR1cm4hMH1mcm9tQXJyYXkoZSx0PTApe2ZvcihsZXQgbj0wO248MTY7bisrKXRoaXMuZWxlbWVudHNbbl09ZVtuK3RdO3JldHVybiB0aGlzfXRvQXJyYXkoZT1bXSx0PTApe2NvbnN0IG49dGhpcy5lbGVtZW50cztyZXR1cm4gZVt0XT1uWzBdLGVbdCsxXT1uWzFdLGVbdCsyXT1uWzJdLGVbdCszXT1uWzNdLGVbdCs0XT1uWzRdLGVbdCs1XT1uWzVdLGVbdCs2XT1uWzZdLGVbdCs3XT1uWzddLGVbdCs4XT1uWzhdLGVbdCs5XT1uWzldLGVbdCsxMF09blsxMF0sZVt0KzExXT1uWzExXSxlW3QrMTJdPW5bMTJdLGVbdCsxM109blsxM10sZVt0KzE0XT1uWzE0XSxlW3QrMTVdPW5bMTVdLGV9fWNvbnN0IFJuPW5ldyBPLFV0PW5ldyBzdCxNYT1uZXcgTygwLDAsMCksU2E9bmV3IE8oMSwxLDEpLG5uPW5ldyBPLGhpPW5ldyBPLHl0PW5ldyBPLExyPW5ldyBzdCxVcj1uZXcgWG47Y2xhc3MgWHR7Y29uc3RydWN0b3IoZT0wLHQ9MCxuPTAscj1YdC5ERUZBVUxUX09SREVSKXt0aGlzLmlzRXVsZXI9ITAsdGhpcy5feD1lLHRoaXMuX3k9dCx0aGlzLl96PW4sdGhpcy5fb3JkZXI9cn1nZXQgeCgpe3JldHVybiB0aGlzLl94fXNldCB4KGUpe3RoaXMuX3g9ZSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9Z2V0IHkoKXtyZXR1cm4gdGhpcy5feX1zZXQgeShlKXt0aGlzLl95PWUsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfWdldCB6KCl7cmV0dXJuIHRoaXMuX3p9c2V0IHooZSl7dGhpcy5fej1lLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKX1nZXQgb3JkZXIoKXtyZXR1cm4gdGhpcy5fb3JkZXJ9c2V0IG9yZGVyKGUpe3RoaXMuX29yZGVyPWUsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfXNldChlLHQsbixyPXRoaXMuX29yZGVyKXtyZXR1cm4gdGhpcy5feD1lLHRoaXMuX3k9dCx0aGlzLl96PW4sdGhpcy5fb3JkZXI9cix0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLl94LHRoaXMuX3ksdGhpcy5feix0aGlzLl9vcmRlcil9Y29weShlKXtyZXR1cm4gdGhpcy5feD1lLl94LHRoaXMuX3k9ZS5feSx0aGlzLl96PWUuX3osdGhpcy5fb3JkZXI9ZS5fb3JkZXIsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVJvdGF0aW9uTWF0cml4KGUsdD10aGlzLl9vcmRlcixuPSEwKXtjb25zdCByPWUuZWxlbWVudHMscz1yWzBdLGE9cls0XSxvPXJbOF0sbD1yWzFdLGM9cls1XSxoPXJbOV0sZD1yWzJdLGY9cls2XSxwPXJbMTBdO3N3aXRjaCh0KXtjYXNlIlhZWiI6dGhpcy5feT1NYXRoLmFzaW4oZ3QobywtMSwxKSksTWF0aC5hYnMobyk8Ljk5OTk5OTk/KHRoaXMuX3g9TWF0aC5hdGFuMigtaCxwKSx0aGlzLl96PU1hdGguYXRhbjIoLWEscykpOih0aGlzLl94PU1hdGguYXRhbjIoZixjKSx0aGlzLl96PTApO2JyZWFrO2Nhc2UiWVhaIjp0aGlzLl94PU1hdGguYXNpbigtZ3QoaCwtMSwxKSksTWF0aC5hYnMoaCk8Ljk5OTk5OTk/KHRoaXMuX3k9TWF0aC5hdGFuMihvLHApLHRoaXMuX3o9TWF0aC5hdGFuMihsLGMpKToodGhpcy5feT1NYXRoLmF0YW4yKC1kLHMpLHRoaXMuX3o9MCk7YnJlYWs7Y2FzZSJaWFkiOnRoaXMuX3g9TWF0aC5hc2luKGd0KGYsLTEsMSkpLE1hdGguYWJzKGYpPC45OTk5OTk5Pyh0aGlzLl95PU1hdGguYXRhbjIoLWQscCksdGhpcy5fej1NYXRoLmF0YW4yKC1hLGMpKToodGhpcy5feT0wLHRoaXMuX3o9TWF0aC5hdGFuMihsLHMpKTticmVhaztjYXNlIlpZWCI6dGhpcy5feT1NYXRoLmFzaW4oLWd0KGQsLTEsMSkpLE1hdGguYWJzKGQpPC45OTk5OTk5Pyh0aGlzLl94PU1hdGguYXRhbjIoZixwKSx0aGlzLl96PU1hdGguYXRhbjIobCxzKSk6KHRoaXMuX3g9MCx0aGlzLl96PU1hdGguYXRhbjIoLWEsYykpO2JyZWFrO2Nhc2UiWVpYIjp0aGlzLl96PU1hdGguYXNpbihndChsLC0xLDEpKSxNYXRoLmFicyhsKTwuOTk5OTk5OT8odGhpcy5feD1NYXRoLmF0YW4yKC1oLGMpLHRoaXMuX3k9TWF0aC5hdGFuMigtZCxzKSk6KHRoaXMuX3g9MCx0aGlzLl95PU1hdGguYXRhbjIobyxwKSk7YnJlYWs7Y2FzZSJYWlkiOnRoaXMuX3o9TWF0aC5hc2luKC1ndChhLC0xLDEpKSxNYXRoLmFicyhhKTwuOTk5OTk5OT8odGhpcy5feD1NYXRoLmF0YW4yKGYsYyksdGhpcy5feT1NYXRoLmF0YW4yKG8scykpOih0aGlzLl94PU1hdGguYXRhbjIoLWgscCksdGhpcy5feT0wKTticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybigiVEhSRUUuRXVsZXI6IC5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAiK3QpfXJldHVybiB0aGlzLl9vcmRlcj10LG49PT0hMCYmdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVF1YXRlcm5pb24oZSx0LG4pe3JldHVybiBMci5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihlKSx0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeChMcix0LG4pfXNldEZyb21WZWN0b3IzKGUsdD10aGlzLl9vcmRlcil7cmV0dXJuIHRoaXMuc2V0KGUueCxlLnksZS56LHQpfXJlb3JkZXIoZSl7cmV0dXJuIFVyLnNldEZyb21FdWxlcih0aGlzKSx0aGlzLnNldEZyb21RdWF0ZXJuaW9uKFVyLGUpfWVxdWFscyhlKXtyZXR1cm4gZS5feD09PXRoaXMuX3gmJmUuX3k9PT10aGlzLl95JiZlLl96PT09dGhpcy5feiYmZS5fb3JkZXI9PT10aGlzLl9vcmRlcn1mcm9tQXJyYXkoZSl7cmV0dXJuIHRoaXMuX3g9ZVswXSx0aGlzLl95PWVbMV0sdGhpcy5fej1lWzJdLGVbM10hPT12b2lkIDAmJih0aGlzLl9vcmRlcj1lWzNdKSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc310b0FycmF5KGU9W10sdD0wKXtyZXR1cm4gZVt0XT10aGlzLl94LGVbdCsxXT10aGlzLl95LGVbdCsyXT10aGlzLl96LGVbdCszXT10aGlzLl9vcmRlcixlfV9vbkNoYW5nZShlKXtyZXR1cm4gdGhpcy5fb25DaGFuZ2VDYWxsYmFjaz1lLHRoaXN9X29uQ2hhbmdlQ2FsbGJhY2soKXt9KltTeW1ib2wuaXRlcmF0b3JdKCl7eWllbGQgdGhpcy5feCx5aWVsZCB0aGlzLl95LHlpZWxkIHRoaXMuX3oseWllbGQgdGhpcy5fb3JkZXJ9fVh0LkRFRkFVTFRfT1JERVI9IlhZWiI7Y2xhc3MgRnJ7Y29uc3RydWN0b3IoKXt0aGlzLm1hc2s9MX1zZXQoZSl7dGhpcy5tYXNrPSgxPDxlfDApPj4+MH1lbmFibGUoZSl7dGhpcy5tYXNrfD0xPDxlfDB9ZW5hYmxlQWxsKCl7dGhpcy5tYXNrPS0xfXRvZ2dsZShlKXt0aGlzLm1hc2tePTE8PGV8MH1kaXNhYmxlKGUpe3RoaXMubWFzayY9figxPDxlfDApfWRpc2FibGVBbGwoKXt0aGlzLm1hc2s9MH10ZXN0KGUpe3JldHVybih0aGlzLm1hc2smZS5tYXNrKSE9PTB9aXNFbmFibGVkKGUpe3JldHVybih0aGlzLm1hc2smKDE8PGV8MCkpIT09MH19bGV0IEVhPTA7Y29uc3QgSXI9bmV3IE8sQ249bmV3IFhuLHF0PW5ldyBzdCxkaT1uZXcgTyxLbj1uZXcgTyx5YT1uZXcgTyxUYT1uZXcgWG4sTnI9bmV3IE8oMSwwLDApLE9yPW5ldyBPKDAsMSwwKSxCcj1uZXcgTygwLDAsMSksenI9e3R5cGU6ImFkZGVkIn0sQWE9e3R5cGU6InJlbW92ZWQifSxQbj17dHlwZToiY2hpbGRhZGRlZCIsY2hpbGQ6bnVsbH0scWk9e3R5cGU6ImNoaWxkcmVtb3ZlZCIsY2hpbGQ6bnVsbH07Y2xhc3MgTXQgZXh0ZW5kcyBNbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5pc09iamVjdDNEPSEwLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJpZCIse3ZhbHVlOkVhKyt9KSx0aGlzLnV1aWQ9U24oKSx0aGlzLm5hbWU9IiIsdGhpcy50eXBlPSJPYmplY3QzRCIsdGhpcy5wYXJlbnQ9bnVsbCx0aGlzLmNoaWxkcmVuPVtdLHRoaXMudXA9TXQuREVGQVVMVF9VUC5jbG9uZSgpO2NvbnN0IGU9bmV3IE8sdD1uZXcgWHQsbj1uZXcgWG4scj1uZXcgTygxLDEsMSk7ZnVuY3Rpb24gcygpe24uc2V0RnJvbUV1bGVyKHQsITEpfWZ1bmN0aW9uIGEoKXt0LnNldEZyb21RdWF0ZXJuaW9uKG4sdm9pZCAwLCExKX10Ll9vbkNoYW5nZShzKSxuLl9vbkNoYW5nZShhKSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLHtwb3NpdGlvbjp7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6ZX0scm90YXRpb246e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOnR9LHF1YXRlcm5pb246e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOm59LHNjYWxlOntjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTpyfSxtb2RlbFZpZXdNYXRyaXg6e3ZhbHVlOm5ldyBzdH0sbm9ybWFsTWF0cml4Ont2YWx1ZTpuZXcgYmV9fSksdGhpcy5tYXRyaXg9bmV3IHN0LHRoaXMubWF0cml4V29ybGQ9bmV3IHN0LHRoaXMubWF0cml4QXV0b1VwZGF0ZT1NdC5ERUZBVUxUX01BVFJJWF9BVVRPX1VQREFURSx0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZT1NdC5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURSx0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITEsdGhpcy5sYXllcnM9bmV3IEZyLHRoaXMudmlzaWJsZT0hMCx0aGlzLmNhc3RTaGFkb3c9ITEsdGhpcy5yZWNlaXZlU2hhZG93PSExLHRoaXMuZnJ1c3R1bUN1bGxlZD0hMCx0aGlzLnJlbmRlck9yZGVyPTAsdGhpcy5hbmltYXRpb25zPVtdLHRoaXMudXNlckRhdGE9e319b25CZWZvcmVTaGFkb3coKXt9b25BZnRlclNoYWRvdygpe31vbkJlZm9yZVJlbmRlcigpe31vbkFmdGVyUmVuZGVyKCl7fWFwcGx5TWF0cml4NChlKXt0aGlzLm1hdHJpeEF1dG9VcGRhdGUmJnRoaXMudXBkYXRlTWF0cml4KCksdGhpcy5tYXRyaXgucHJlbXVsdGlwbHkoZSksdGhpcy5tYXRyaXguZGVjb21wb3NlKHRoaXMucG9zaXRpb24sdGhpcy5xdWF0ZXJuaW9uLHRoaXMuc2NhbGUpfWFwcGx5UXVhdGVybmlvbihlKXtyZXR1cm4gdGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KGUpLHRoaXN9c2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlKGUsdCl7dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoZSx0KX1zZXRSb3RhdGlvbkZyb21FdWxlcihlKXt0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKGUsITApfXNldFJvdGF0aW9uRnJvbU1hdHJpeChlKXt0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KGUpfXNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oZSl7dGhpcy5xdWF0ZXJuaW9uLmNvcHkoZSl9cm90YXRlT25BeGlzKGUsdCl7cmV0dXJuIENuLnNldEZyb21BeGlzQW5nbGUoZSx0KSx0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkoQ24pLHRoaXN9cm90YXRlT25Xb3JsZEF4aXMoZSx0KXtyZXR1cm4gQ24uc2V0RnJvbUF4aXNBbmdsZShlLHQpLHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseShDbiksdGhpc31yb3RhdGVYKGUpe3JldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhOcixlKX1yb3RhdGVZKGUpe3JldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhPcixlKX1yb3RhdGVaKGUpe3JldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhCcixlKX10cmFuc2xhdGVPbkF4aXMoZSx0KXtyZXR1cm4gSXIuY29weShlKS5hcHBseVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKSx0aGlzLnBvc2l0aW9uLmFkZChJci5tdWx0aXBseVNjYWxhcih0KSksdGhpc310cmFuc2xhdGVYKGUpe3JldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhOcixlKX10cmFuc2xhdGVZKGUpe3JldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhPcixlKX10cmFuc2xhdGVaKGUpe3JldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhCcixlKX1sb2NhbFRvV29ybGQoZSl7cmV0dXJuIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLGUuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpfXdvcmxkVG9Mb2NhbChlKXtyZXR1cm4gdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksZS5hcHBseU1hdHJpeDQocXQuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKSl9bG9va0F0KGUsdCxuKXtlLmlzVmVjdG9yMz9kaS5jb3B5KGUpOmRpLnNldChlLHQsbik7Y29uc3Qgcj10aGlzLnBhcmVudDt0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxLbi5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5tYXRyaXhXb3JsZCksdGhpcy5pc0NhbWVyYXx8dGhpcy5pc0xpZ2h0P3F0Lmxvb2tBdChLbixkaSx0aGlzLnVwKTpxdC5sb29rQXQoZGksS24sdGhpcy51cCksdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChxdCksciYmKHF0LmV4dHJhY3RSb3RhdGlvbihyLm1hdHJpeFdvcmxkKSxDbi5zZXRGcm9tUm90YXRpb25NYXRyaXgocXQpLHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseShDbi5pbnZlcnQoKSkpfWFkZChlKXtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2ZvcihsZXQgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspdGhpcy5hZGQoYXJndW1lbnRzW3RdKTtyZXR1cm4gdGhpc31yZXR1cm4gZT09PXRoaXM/KGNvbnNvbGUuZXJyb3IoIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhbid0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLiIsZSksdGhpcyk6KGUmJmUuaXNPYmplY3QzRD8oZS5yZW1vdmVGcm9tUGFyZW50KCksZS5wYXJlbnQ9dGhpcyx0aGlzLmNoaWxkcmVuLnB1c2goZSksZS5kaXNwYXRjaEV2ZW50KHpyKSxQbi5jaGlsZD1lLHRoaXMuZGlzcGF0Y2hFdmVudChQbiksUG4uY2hpbGQ9bnVsbCk6Y29uc29sZS5lcnJvcigiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3Qgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk9iamVjdDNELiIsZSksdGhpcyl9cmVtb3ZlKGUpe2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKGxldCBuPTA7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl0aGlzLnJlbW92ZShhcmd1bWVudHNbbl0pO3JldHVybiB0aGlzfWNvbnN0IHQ9dGhpcy5jaGlsZHJlbi5pbmRleE9mKGUpO3JldHVybiB0IT09LTEmJihlLnBhcmVudD1udWxsLHRoaXMuY2hpbGRyZW4uc3BsaWNlKHQsMSksZS5kaXNwYXRjaEV2ZW50KEFhKSxxaS5jaGlsZD1lLHRoaXMuZGlzcGF0Y2hFdmVudChxaSkscWkuY2hpbGQ9bnVsbCksdGhpc31yZW1vdmVGcm9tUGFyZW50KCl7Y29uc3QgZT10aGlzLnBhcmVudDtyZXR1cm4gZSE9PW51bGwmJmUucmVtb3ZlKHRoaXMpLHRoaXN9Y2xlYXIoKXtyZXR1cm4gdGhpcy5yZW1vdmUoLi4udGhpcy5jaGlsZHJlbil9YXR0YWNoKGUpe3JldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxxdC5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpLGUucGFyZW50IT09bnVsbCYmKGUucGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxxdC5tdWx0aXBseShlLnBhcmVudC5tYXRyaXhXb3JsZCkpLGUuYXBwbHlNYXRyaXg0KHF0KSxlLnJlbW92ZUZyb21QYXJlbnQoKSxlLnBhcmVudD10aGlzLHRoaXMuY2hpbGRyZW4ucHVzaChlKSxlLnVwZGF0ZVdvcmxkTWF0cml4KCExLCEwKSxlLmRpc3BhdGNoRXZlbnQoenIpLFBuLmNoaWxkPWUsdGhpcy5kaXNwYXRjaEV2ZW50KFBuKSxQbi5jaGlsZD1udWxsLHRoaXN9Z2V0T2JqZWN0QnlJZChlKXtyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCJpZCIsZSl9Z2V0T2JqZWN0QnlOYW1lKGUpe3JldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoIm5hbWUiLGUpfWdldE9iamVjdEJ5UHJvcGVydHkoZSx0KXtpZih0aGlzW2VdPT09dClyZXR1cm4gdGhpcztmb3IobGV0IG49MCxyPXRoaXMuY2hpbGRyZW4ubGVuZ3RoO248cjtuKyspe2NvbnN0IGE9dGhpcy5jaGlsZHJlbltuXS5nZXRPYmplY3RCeVByb3BlcnR5KGUsdCk7aWYoYSE9PXZvaWQgMClyZXR1cm4gYX19Z2V0T2JqZWN0c0J5UHJvcGVydHkoZSx0LG49W10pe3RoaXNbZV09PT10JiZuLnB1c2godGhpcyk7Y29uc3Qgcj10aGlzLmNoaWxkcmVuO2ZvcihsZXQgcz0wLGE9ci5sZW5ndGg7czxhO3MrKylyW3NdLmdldE9iamVjdHNCeVByb3BlcnR5KGUsdCxuKTtyZXR1cm4gbn1nZXRXb3JsZFBvc2l0aW9uKGUpe3JldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxlLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1hdHJpeFdvcmxkKX1nZXRXb3JsZFF1YXRlcm5pb24oZSl7cmV0dXJuIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKEtuLGUseWEpLGV9Z2V0V29ybGRTY2FsZShlKXtyZXR1cm4gdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoS24sVGEsZSksZX1nZXRXb3JsZERpcmVjdGlvbihlKXt0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKTtjb25zdCB0PXRoaXMubWF0cml4V29ybGQuZWxlbWVudHM7cmV0dXJuIGUuc2V0KHRbOF0sdFs5XSx0WzEwXSkubm9ybWFsaXplKCl9cmF5Y2FzdCgpe310cmF2ZXJzZShlKXtlKHRoaXMpO2NvbnN0IHQ9dGhpcy5jaGlsZHJlbjtmb3IobGV0IG49MCxyPXQubGVuZ3RoO248cjtuKyspdFtuXS50cmF2ZXJzZShlKX10cmF2ZXJzZVZpc2libGUoZSl7aWYodGhpcy52aXNpYmxlPT09ITEpcmV0dXJuO2UodGhpcyk7Y29uc3QgdD10aGlzLmNoaWxkcmVuO2ZvcihsZXQgbj0wLHI9dC5sZW5ndGg7bjxyO24rKyl0W25dLnRyYXZlcnNlVmlzaWJsZShlKX10cmF2ZXJzZUFuY2VzdG9ycyhlKXtjb25zdCB0PXRoaXMucGFyZW50O3QhPT1udWxsJiYoZSh0KSx0LnRyYXZlcnNlQW5jZXN0b3JzKGUpKX11cGRhdGVNYXRyaXgoKXt0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sdGhpcy5xdWF0ZXJuaW9uLHRoaXMuc2NhbGUpLHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMH11cGRhdGVNYXRyaXhXb3JsZChlKXt0aGlzLm1hdHJpeEF1dG9VcGRhdGUmJnRoaXMudXBkYXRlTWF0cml4KCksKHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZXx8ZSkmJih0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZT09PSEwJiYodGhpcy5wYXJlbnQ9PT1udWxsP3RoaXMubWF0cml4V29ybGQuY29weSh0aGlzLm1hdHJpeCk6dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLHRoaXMubWF0cml4KSksdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSExLGU9ITApO2NvbnN0IHQ9dGhpcy5jaGlsZHJlbjtmb3IobGV0IG49MCxyPXQubGVuZ3RoO248cjtuKyspdFtuXS51cGRhdGVNYXRyaXhXb3JsZChlKX11cGRhdGVXb3JsZE1hdHJpeChlLHQpe2NvbnN0IG49dGhpcy5wYXJlbnQ7aWYoZT09PSEwJiZuIT09bnVsbCYmbi51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksdGhpcy5tYXRyaXhBdXRvVXBkYXRlJiZ0aGlzLnVwZGF0ZU1hdHJpeCgpLHRoaXMubWF0cml4V29ybGRBdXRvVXBkYXRlPT09ITAmJih0aGlzLnBhcmVudD09PW51bGw/dGhpcy5tYXRyaXhXb3JsZC5jb3B5KHRoaXMubWF0cml4KTp0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXModGhpcy5wYXJlbnQubWF0cml4V29ybGQsdGhpcy5tYXRyaXgpKSx0PT09ITApe2NvbnN0IHI9dGhpcy5jaGlsZHJlbjtmb3IobGV0IHM9MCxhPXIubGVuZ3RoO3M8YTtzKyspcltzXS51cGRhdGVXb3JsZE1hdHJpeCghMSwhMCl9fXRvSlNPTihlKXtjb25zdCB0PWU9PT12b2lkIDB8fHR5cGVvZiBlPT0ic3RyaW5nIixuPXt9O3QmJihlPXtnZW9tZXRyaWVzOnt9LG1hdGVyaWFsczp7fSx0ZXh0dXJlczp7fSxpbWFnZXM6e30sc2hhcGVzOnt9LHNrZWxldG9uczp7fSxhbmltYXRpb25zOnt9LG5vZGVzOnt9fSxuLm1ldGFkYXRhPXt2ZXJzaW9uOjQuNix0eXBlOiJPYmplY3QiLGdlbmVyYXRvcjoiT2JqZWN0M0QudG9KU09OIn0pO2NvbnN0IHI9e307ci51dWlkPXRoaXMudXVpZCxyLnR5cGU9dGhpcy50eXBlLHRoaXMubmFtZSE9PSIiJiYoci5uYW1lPXRoaXMubmFtZSksdGhpcy5jYXN0U2hhZG93PT09ITAmJihyLmNhc3RTaGFkb3c9ITApLHRoaXMucmVjZWl2ZVNoYWRvdz09PSEwJiYoci5yZWNlaXZlU2hhZG93PSEwKSx0aGlzLnZpc2libGU9PT0hMSYmKHIudmlzaWJsZT0hMSksdGhpcy5mcnVzdHVtQ3VsbGVkPT09ITEmJihyLmZydXN0dW1DdWxsZWQ9ITEpLHRoaXMucmVuZGVyT3JkZXIhPT0wJiYoci5yZW5kZXJPcmRlcj10aGlzLnJlbmRlck9yZGVyKSxPYmplY3Qua2V5cyh0aGlzLnVzZXJEYXRhKS5sZW5ndGg+MCYmKHIudXNlckRhdGE9dGhpcy51c2VyRGF0YSksci5sYXllcnM9dGhpcy5sYXllcnMubWFzayxyLm1hdHJpeD10aGlzLm1hdHJpeC50b0FycmF5KCksci51cD10aGlzLnVwLnRvQXJyYXkoKSx0aGlzLm1hdHJpeEF1dG9VcGRhdGU9PT0hMSYmKHIubWF0cml4QXV0b1VwZGF0ZT0hMSksdGhpcy5pc0luc3RhbmNlZE1lc2gmJihyLnR5cGU9Ikluc3RhbmNlZE1lc2giLHIuY291bnQ9dGhpcy5jb3VudCxyLmluc3RhbmNlTWF0cml4PXRoaXMuaW5zdGFuY2VNYXRyaXgudG9KU09OKCksdGhpcy5pbnN0YW5jZUNvbG9yIT09bnVsbCYmKHIuaW5zdGFuY2VDb2xvcj10aGlzLmluc3RhbmNlQ29sb3IudG9KU09OKCkpKSx0aGlzLmlzQmF0Y2hlZE1lc2gmJihyLnR5cGU9IkJhdGNoZWRNZXNoIixyLnBlck9iamVjdEZydXN0dW1DdWxsZWQ9dGhpcy5wZXJPYmplY3RGcnVzdHVtQ3VsbGVkLHIuc29ydE9iamVjdHM9dGhpcy5zb3J0T2JqZWN0cyxyLmRyYXdSYW5nZXM9dGhpcy5fZHJhd1JhbmdlcyxyLnJlc2VydmVkUmFuZ2VzPXRoaXMuX3Jlc2VydmVkUmFuZ2VzLHIudmlzaWJpbGl0eT10aGlzLl92aXNpYmlsaXR5LHIuYWN0aXZlPXRoaXMuX2FjdGl2ZSxyLmJvdW5kcz10aGlzLl9ib3VuZHMubWFwKG89Pih7Ym94SW5pdGlhbGl6ZWQ6by5ib3hJbml0aWFsaXplZCxib3hNaW46by5ib3gubWluLnRvQXJyYXkoKSxib3hNYXg6by5ib3gubWF4LnRvQXJyYXkoKSxzcGhlcmVJbml0aWFsaXplZDpvLnNwaGVyZUluaXRpYWxpemVkLHNwaGVyZVJhZGl1czpvLnNwaGVyZS5yYWRpdXMsc3BoZXJlQ2VudGVyOm8uc3BoZXJlLmNlbnRlci50b0FycmF5KCl9KSksci5tYXhJbnN0YW5jZUNvdW50PXRoaXMuX21heEluc3RhbmNlQ291bnQsci5tYXhWZXJ0ZXhDb3VudD10aGlzLl9tYXhWZXJ0ZXhDb3VudCxyLm1heEluZGV4Q291bnQ9dGhpcy5fbWF4SW5kZXhDb3VudCxyLmdlb21ldHJ5SW5pdGlhbGl6ZWQ9dGhpcy5fZ2VvbWV0cnlJbml0aWFsaXplZCxyLmdlb21ldHJ5Q291bnQ9dGhpcy5fZ2VvbWV0cnlDb3VudCxyLm1hdHJpY2VzVGV4dHVyZT10aGlzLl9tYXRyaWNlc1RleHR1cmUudG9KU09OKGUpLHRoaXMuX2NvbG9yc1RleHR1cmUhPT1udWxsJiYoci5jb2xvcnNUZXh0dXJlPXRoaXMuX2NvbG9yc1RleHR1cmUudG9KU09OKGUpKSx0aGlzLmJvdW5kaW5nU3BoZXJlIT09bnVsbCYmKHIuYm91bmRpbmdTcGhlcmU9e2NlbnRlcjpyLmJvdW5kaW5nU3BoZXJlLmNlbnRlci50b0FycmF5KCkscmFkaXVzOnIuYm91bmRpbmdTcGhlcmUucmFkaXVzfSksdGhpcy5ib3VuZGluZ0JveCE9PW51bGwmJihyLmJvdW5kaW5nQm94PXttaW46ci5ib3VuZGluZ0JveC5taW4udG9BcnJheSgpLG1heDpyLmJvdW5kaW5nQm94Lm1heC50b0FycmF5KCl9KSk7ZnVuY3Rpb24gcyhvLGwpe3JldHVybiBvW2wudXVpZF09PT12b2lkIDAmJihvW2wudXVpZF09bC50b0pTT04oZSkpLGwudXVpZH1pZih0aGlzLmlzU2NlbmUpdGhpcy5iYWNrZ3JvdW5kJiYodGhpcy5iYWNrZ3JvdW5kLmlzQ29sb3I/ci5iYWNrZ3JvdW5kPXRoaXMuYmFja2dyb3VuZC50b0pTT04oKTp0aGlzLmJhY2tncm91bmQuaXNUZXh0dXJlJiYoci5iYWNrZ3JvdW5kPXRoaXMuYmFja2dyb3VuZC50b0pTT04oZSkudXVpZCkpLHRoaXMuZW52aXJvbm1lbnQmJnRoaXMuZW52aXJvbm1lbnQuaXNUZXh0dXJlJiZ0aGlzLmVudmlyb25tZW50LmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSE9PSEwJiYoci5lbnZpcm9ubWVudD10aGlzLmVudmlyb25tZW50LnRvSlNPTihlKS51dWlkKTtlbHNlIGlmKHRoaXMuaXNNZXNofHx0aGlzLmlzTGluZXx8dGhpcy5pc1BvaW50cyl7ci5nZW9tZXRyeT1zKGUuZ2VvbWV0cmllcyx0aGlzLmdlb21ldHJ5KTtjb25zdCBvPXRoaXMuZ2VvbWV0cnkucGFyYW1ldGVycztpZihvIT09dm9pZCAwJiZvLnNoYXBlcyE9PXZvaWQgMCl7Y29uc3QgbD1vLnNoYXBlcztpZihBcnJheS5pc0FycmF5KGwpKWZvcihsZXQgYz0wLGg9bC5sZW5ndGg7YzxoO2MrKyl7Y29uc3QgZD1sW2NdO3MoZS5zaGFwZXMsZCl9ZWxzZSBzKGUuc2hhcGVzLGwpfX1pZih0aGlzLmlzU2tpbm5lZE1lc2gmJihyLmJpbmRNb2RlPXRoaXMuYmluZE1vZGUsci5iaW5kTWF0cml4PXRoaXMuYmluZE1hdHJpeC50b0FycmF5KCksdGhpcy5za2VsZXRvbiE9PXZvaWQgMCYmKHMoZS5za2VsZXRvbnMsdGhpcy5za2VsZXRvbiksci5za2VsZXRvbj10aGlzLnNrZWxldG9uLnV1aWQpKSx0aGlzLm1hdGVyaWFsIT09dm9pZCAwKWlmKEFycmF5LmlzQXJyYXkodGhpcy5tYXRlcmlhbCkpe2NvbnN0IG89W107Zm9yKGxldCBsPTAsYz10aGlzLm1hdGVyaWFsLmxlbmd0aDtsPGM7bCsrKW8ucHVzaChzKGUubWF0ZXJpYWxzLHRoaXMubWF0ZXJpYWxbbF0pKTtyLm1hdGVyaWFsPW99ZWxzZSByLm1hdGVyaWFsPXMoZS5tYXRlcmlhbHMsdGhpcy5tYXRlcmlhbCk7aWYodGhpcy5jaGlsZHJlbi5sZW5ndGg+MCl7ci5jaGlsZHJlbj1bXTtmb3IobGV0IG89MDtvPHRoaXMuY2hpbGRyZW4ubGVuZ3RoO28rKylyLmNoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltvXS50b0pTT04oZSkub2JqZWN0KX1pZih0aGlzLmFuaW1hdGlvbnMubGVuZ3RoPjApe3IuYW5pbWF0aW9ucz1bXTtmb3IobGV0IG89MDtvPHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7bysrKXtjb25zdCBsPXRoaXMuYW5pbWF0aW9uc1tvXTtyLmFuaW1hdGlvbnMucHVzaChzKGUuYW5pbWF0aW9ucyxsKSl9fWlmKHQpe2NvbnN0IG89YShlLmdlb21ldHJpZXMpLGw9YShlLm1hdGVyaWFscyksYz1hKGUudGV4dHVyZXMpLGg9YShlLmltYWdlcyksZD1hKGUuc2hhcGVzKSxmPWEoZS5za2VsZXRvbnMpLHA9YShlLmFuaW1hdGlvbnMpLF89YShlLm5vZGVzKTtvLmxlbmd0aD4wJiYobi5nZW9tZXRyaWVzPW8pLGwubGVuZ3RoPjAmJihuLm1hdGVyaWFscz1sKSxjLmxlbmd0aD4wJiYobi50ZXh0dXJlcz1jKSxoLmxlbmd0aD4wJiYobi5pbWFnZXM9aCksZC5sZW5ndGg+MCYmKG4uc2hhcGVzPWQpLGYubGVuZ3RoPjAmJihuLnNrZWxldG9ucz1mKSxwLmxlbmd0aD4wJiYobi5hbmltYXRpb25zPXApLF8ubGVuZ3RoPjAmJihuLm5vZGVzPV8pfXJldHVybiBuLm9iamVjdD1yLG47ZnVuY3Rpb24gYShvKXtjb25zdCBsPVtdO2Zvcihjb25zdCBjIGluIG8pe2NvbnN0IGg9b1tjXTtkZWxldGUgaC5tZXRhZGF0YSxsLnB1c2goaCl9cmV0dXJuIGx9fWNsb25lKGUpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyxlKX1jb3B5KGUsdD0hMCl7aWYodGhpcy5uYW1lPWUubmFtZSx0aGlzLnVwLmNvcHkoZS51cCksdGhpcy5wb3NpdGlvbi5jb3B5KGUucG9zaXRpb24pLHRoaXMucm90YXRpb24ub3JkZXI9ZS5yb3RhdGlvbi5vcmRlcix0aGlzLnF1YXRlcm5pb24uY29weShlLnF1YXRlcm5pb24pLHRoaXMuc2NhbGUuY29weShlLnNjYWxlKSx0aGlzLm1hdHJpeC5jb3B5KGUubWF0cml4KSx0aGlzLm1hdHJpeFdvcmxkLmNvcHkoZS5tYXRyaXhXb3JsZCksdGhpcy5tYXRyaXhBdXRvVXBkYXRlPWUubWF0cml4QXV0b1VwZGF0ZSx0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZT1lLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSx0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlLHRoaXMubGF5ZXJzLm1hc2s9ZS5sYXllcnMubWFzayx0aGlzLnZpc2libGU9ZS52aXNpYmxlLHRoaXMuY2FzdFNoYWRvdz1lLmNhc3RTaGFkb3csdGhpcy5yZWNlaXZlU2hhZG93PWUucmVjZWl2ZVNoYWRvdyx0aGlzLmZydXN0dW1DdWxsZWQ9ZS5mcnVzdHVtQ3VsbGVkLHRoaXMucmVuZGVyT3JkZXI9ZS5yZW5kZXJPcmRlcix0aGlzLmFuaW1hdGlvbnM9ZS5hbmltYXRpb25zLnNsaWNlKCksdGhpcy51c2VyRGF0YT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGUudXNlckRhdGEpKSx0PT09ITApZm9yKGxldCBuPTA7bjxlLmNoaWxkcmVuLmxlbmd0aDtuKyspe2NvbnN0IHI9ZS5jaGlsZHJlbltuXTt0aGlzLmFkZChyLmNsb25lKCkpfXJldHVybiB0aGlzfX1NdC5ERUZBVUxUX1VQPW5ldyBPKDAsMSwwKSxNdC5ERUZBVUxUX01BVFJJWF9BVVRPX1VQREFURT0hMCxNdC5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURT0hMDtjb25zdCBGdD1uZXcgTyxZdD1uZXcgTyxZaT1uZXcgTywkdD1uZXcgTyxEbj1uZXcgTyxMbj1uZXcgTyxHcj1uZXcgTywkaT1uZXcgTyxLaT1uZXcgTyxaaT1uZXcgTyxqaT1uZXcgcnQsSmk9bmV3IHJ0LFFpPW5ldyBydDtjbGFzcyBJdHtjb25zdHJ1Y3RvcihlPW5ldyBPLHQ9bmV3IE8sbj1uZXcgTyl7dGhpcy5hPWUsdGhpcy5iPXQsdGhpcy5jPW59c3RhdGljIGdldE5vcm1hbChlLHQsbixyKXtyLnN1YlZlY3RvcnMobix0KSxGdC5zdWJWZWN0b3JzKGUsdCksci5jcm9zcyhGdCk7Y29uc3Qgcz1yLmxlbmd0aFNxKCk7cmV0dXJuIHM+MD9yLm11bHRpcGx5U2NhbGFyKDEvTWF0aC5zcXJ0KHMpKTpyLnNldCgwLDAsMCl9c3RhdGljIGdldEJhcnljb29yZChlLHQsbixyLHMpe0Z0LnN1YlZlY3RvcnMocix0KSxZdC5zdWJWZWN0b3JzKG4sdCksWWkuc3ViVmVjdG9ycyhlLHQpO2NvbnN0IGE9RnQuZG90KEZ0KSxvPUZ0LmRvdChZdCksbD1GdC5kb3QoWWkpLGM9WXQuZG90KFl0KSxoPVl0LmRvdChZaSksZD1hKmMtbypvO2lmKGQ9PT0wKXJldHVybiBzLnNldCgwLDAsMCksbnVsbDtjb25zdCBmPTEvZCxwPShjKmwtbypoKSpmLF89KGEqaC1vKmwpKmY7cmV0dXJuIHMuc2V0KDEtcC1fLF8scCl9c3RhdGljIGNvbnRhaW5zUG9pbnQoZSx0LG4scil7cmV0dXJuIHRoaXMuZ2V0QmFyeWNvb3JkKGUsdCxuLHIsJHQpPT09bnVsbD8hMTokdC54Pj0wJiYkdC55Pj0wJiYkdC54KyR0Lnk8PTF9c3RhdGljIGdldEludGVycG9sYXRpb24oZSx0LG4scixzLGEsbyxsKXtyZXR1cm4gdGhpcy5nZXRCYXJ5Y29vcmQoZSx0LG4sciwkdCk9PT1udWxsPyhsLng9MCxsLnk9MCwieiJpbiBsJiYobC56PTApLCJ3ImluIGwmJihsLnc9MCksbnVsbCk6KGwuc2V0U2NhbGFyKDApLGwuYWRkU2NhbGVkVmVjdG9yKHMsJHQueCksbC5hZGRTY2FsZWRWZWN0b3IoYSwkdC55KSxsLmFkZFNjYWxlZFZlY3RvcihvLCR0LnopLGwpfXN0YXRpYyBnZXRJbnRlcnBvbGF0ZWRBdHRyaWJ1dGUoZSx0LG4scixzLGEpe3JldHVybiBqaS5zZXRTY2FsYXIoMCksSmkuc2V0U2NhbGFyKDApLFFpLnNldFNjYWxhcigwKSxqaS5mcm9tQnVmZmVyQXR0cmlidXRlKGUsdCksSmkuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLG4pLFFpLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSxyKSxhLnNldFNjYWxhcigwKSxhLmFkZFNjYWxlZFZlY3RvcihqaSxzLngpLGEuYWRkU2NhbGVkVmVjdG9yKEppLHMueSksYS5hZGRTY2FsZWRWZWN0b3IoUWkscy56KSxhfXN0YXRpYyBpc0Zyb250RmFjaW5nKGUsdCxuLHIpe3JldHVybiBGdC5zdWJWZWN0b3JzKG4sdCksWXQuc3ViVmVjdG9ycyhlLHQpLEZ0LmNyb3NzKFl0KS5kb3Qocik8MH1zZXQoZSx0LG4pe3JldHVybiB0aGlzLmEuY29weShlKSx0aGlzLmIuY29weSh0KSx0aGlzLmMuY29weShuKSx0aGlzfXNldEZyb21Qb2ludHNBbmRJbmRpY2VzKGUsdCxuLHIpe3JldHVybiB0aGlzLmEuY29weShlW3RdKSx0aGlzLmIuY29weShlW25dKSx0aGlzLmMuY29weShlW3JdKSx0aGlzfXNldEZyb21BdHRyaWJ1dGVBbmRJbmRpY2VzKGUsdCxuLHIpe3JldHVybiB0aGlzLmEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHQpLHRoaXMuYi5mcm9tQnVmZmVyQXR0cmlidXRlKGUsbiksdGhpcy5jLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSxyKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX1jb3B5KGUpe3JldHVybiB0aGlzLmEuY29weShlLmEpLHRoaXMuYi5jb3B5KGUuYiksdGhpcy5jLmNvcHkoZS5jKSx0aGlzfWdldEFyZWEoKXtyZXR1cm4gRnQuc3ViVmVjdG9ycyh0aGlzLmMsdGhpcy5iKSxZdC5zdWJWZWN0b3JzKHRoaXMuYSx0aGlzLmIpLEZ0LmNyb3NzKFl0KS5sZW5ndGgoKSouNX1nZXRNaWRwb2ludChlKXtyZXR1cm4gZS5hZGRWZWN0b3JzKHRoaXMuYSx0aGlzLmIpLmFkZCh0aGlzLmMpLm11bHRpcGx5U2NhbGFyKDEvMyl9Z2V0Tm9ybWFsKGUpe3JldHVybiBJdC5nZXROb3JtYWwodGhpcy5hLHRoaXMuYix0aGlzLmMsZSl9Z2V0UGxhbmUoZSl7cmV0dXJuIGUuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKHRoaXMuYSx0aGlzLmIsdGhpcy5jKX1nZXRCYXJ5Y29vcmQoZSx0KXtyZXR1cm4gSXQuZ2V0QmFyeWNvb3JkKGUsdGhpcy5hLHRoaXMuYix0aGlzLmMsdCl9Z2V0SW50ZXJwb2xhdGlvbihlLHQsbixyLHMpe3JldHVybiBJdC5nZXRJbnRlcnBvbGF0aW9uKGUsdGhpcy5hLHRoaXMuYix0aGlzLmMsdCxuLHIscyl9Y29udGFpbnNQb2ludChlKXtyZXR1cm4gSXQuY29udGFpbnNQb2ludChlLHRoaXMuYSx0aGlzLmIsdGhpcy5jKX1pc0Zyb250RmFjaW5nKGUpe3JldHVybiBJdC5pc0Zyb250RmFjaW5nKHRoaXMuYSx0aGlzLmIsdGhpcy5jLGUpfWludGVyc2VjdHNCb3goZSl7cmV0dXJuIGUuaW50ZXJzZWN0c1RyaWFuZ2xlKHRoaXMpfWNsb3Nlc3RQb2ludFRvUG9pbnQoZSx0KXtjb25zdCBuPXRoaXMuYSxyPXRoaXMuYixzPXRoaXMuYztsZXQgYSxvO0RuLnN1YlZlY3RvcnMocixuKSxMbi5zdWJWZWN0b3JzKHMsbiksJGkuc3ViVmVjdG9ycyhlLG4pO2NvbnN0IGw9RG4uZG90KCRpKSxjPUxuLmRvdCgkaSk7aWYobDw9MCYmYzw9MClyZXR1cm4gdC5jb3B5KG4pO0tpLnN1YlZlY3RvcnMoZSxyKTtjb25zdCBoPURuLmRvdChLaSksZD1Mbi5kb3QoS2kpO2lmKGg+PTAmJmQ8PWgpcmV0dXJuIHQuY29weShyKTtjb25zdCBmPWwqZC1oKmM7aWYoZjw9MCYmbD49MCYmaDw9MClyZXR1cm4gYT1sLyhsLWgpLHQuY29weShuKS5hZGRTY2FsZWRWZWN0b3IoRG4sYSk7Wmkuc3ViVmVjdG9ycyhlLHMpO2NvbnN0IHA9RG4uZG90KFppKSxfPUxuLmRvdChaaSk7aWYoXz49MCYmcDw9XylyZXR1cm4gdC5jb3B5KHMpO2NvbnN0IHg9cCpjLWwqXztpZih4PD0wJiZjPj0wJiZfPD0wKXJldHVybiBvPWMvKGMtXyksdC5jb3B5KG4pLmFkZFNjYWxlZFZlY3RvcihMbixvKTtjb25zdCBtPWgqXy1wKmQ7aWYobTw9MCYmZC1oPj0wJiZwLV8+PTApcmV0dXJuIEdyLnN1YlZlY3RvcnMocyxyKSxvPShkLWgpLyhkLWgrKHAtXykpLHQuY29weShyKS5hZGRTY2FsZWRWZWN0b3IoR3Isbyk7Y29uc3QgdT0xLyhtK3grZik7cmV0dXJuIGE9eCp1LG89Zip1LHQuY29weShuKS5hZGRTY2FsZWRWZWN0b3IoRG4sYSkuYWRkU2NhbGVkVmVjdG9yKExuLG8pfWVxdWFscyhlKXtyZXR1cm4gZS5hLmVxdWFscyh0aGlzLmEpJiZlLmIuZXF1YWxzKHRoaXMuYikmJmUuYy5lcXVhbHModGhpcy5jKX19Y29uc3QgSHI9e2FsaWNlYmx1ZToxNTc5MjM4MyxhbnRpcXVld2hpdGU6MTY0NDQzNzUsYXF1YTo2NTUzNSxhcXVhbWFyaW5lOjgzODg1NjQsYXp1cmU6MTU3OTQxNzUsYmVpZ2U6MTYxMTkyNjAsYmlzcXVlOjE2NzcwMjQ0LGJsYWNrOjAsYmxhbmNoZWRhbG1vbmQ6MTY3NzIwNDUsYmx1ZToyNTUsYmx1ZXZpb2xldDo5MDU1MjAyLGJyb3duOjEwODI0MjM0LGJ1cmx5d29vZDoxNDU5NjIzMSxjYWRldGJsdWU6NjI2NjUyOCxjaGFydHJldXNlOjgzODgzNTIsY2hvY29sYXRlOjEzNzg5NDcwLGNvcmFsOjE2NzQ0MjcyLGNvcm5mbG93ZXJibHVlOjY1OTE5ODEsY29ybnNpbGs6MTY3NzUzODgsY3JpbXNvbjoxNDQyMzEwMCxjeWFuOjY1NTM1LGRhcmtibHVlOjEzOSxkYXJrY3lhbjozNTcyMyxkYXJrZ29sZGVucm9kOjEyMDkyOTM5LGRhcmtncmF5OjExMTE5MDE3LGRhcmtncmVlbjoyNTYwMCxkYXJrZ3JleToxMTExOTAxNyxkYXJra2hha2k6MTI0MzMyNTksZGFya21hZ2VudGE6OTEwOTY0MyxkYXJrb2xpdmVncmVlbjo1NTk3OTk5LGRhcmtvcmFuZ2U6MTY3NDc1MjAsZGFya29yY2hpZDoxMDA0MDAxMixkYXJrcmVkOjkxMDk1MDQsZGFya3NhbG1vbjoxNTMwODQxMCxkYXJrc2VhZ3JlZW46OTQxOTkxOSxkYXJrc2xhdGVibHVlOjQ3MzQzNDcsZGFya3NsYXRlZ3JheTozMTAwNDk1LGRhcmtzbGF0ZWdyZXk6MzEwMDQ5NSxkYXJrdHVycXVvaXNlOjUyOTQ1LGRhcmt2aW9sZXQ6OTY5OTUzOSxkZWVwcGluazoxNjcxNjk0NyxkZWVwc2t5Ymx1ZTo0OTE1MSxkaW1ncmF5OjY5MDgyNjUsZGltZ3JleTo2OTA4MjY1LGRvZGdlcmJsdWU6MjAwMzE5OSxmaXJlYnJpY2s6MTE2NzQxNDYsZmxvcmFsd2hpdGU6MTY3NzU5MjAsZm9yZXN0Z3JlZW46MjI2Mzg0MixmdWNoc2lhOjE2NzExOTM1LGdhaW5zYm9ybzoxNDQ3NDQ2MCxnaG9zdHdoaXRlOjE2MzE2NjcxLGdvbGQ6MTY3NjY3MjAsZ29sZGVucm9kOjE0MzI5MTIwLGdyYXk6ODQyMTUwNCxncmVlbjozMjc2OCxncmVlbnllbGxvdzoxMTQwMzA1NSxncmV5Ojg0MjE1MDQsaG9uZXlkZXc6MTU3OTQxNjAsaG90cGluazoxNjczODc0MCxpbmRpYW5yZWQ6MTM0NTg1MjQsaW5kaWdvOjQ5MTUzMzAsaXZvcnk6MTY3NzcyMDAsa2hha2k6MTU3ODc2NjAsbGF2ZW5kZXI6MTUxMzI0MTAsbGF2ZW5kZXJibHVzaDoxNjc3MzM2NSxsYXduZ3JlZW46ODE5MDk3NixsZW1vbmNoaWZmb246MTY3NzU4ODUsbGlnaHRibHVlOjExMzkzMjU0LGxpZ2h0Y29yYWw6MTU3NjE1MzYsbGlnaHRjeWFuOjE0NzQ1NTk5LGxpZ2h0Z29sZGVucm9keWVsbG93OjE2NDQ4MjEwLGxpZ2h0Z3JheToxMzg4MjMyMyxsaWdodGdyZWVuOjk0OTgyNTYsbGlnaHRncmV5OjEzODgyMzIzLGxpZ2h0cGluazoxNjc1ODQ2NSxsaWdodHNhbG1vbjoxNjc1Mjc2MixsaWdodHNlYWdyZWVuOjIxNDI4OTAsbGlnaHRza3libHVlOjg5MDAzNDYsbGlnaHRzbGF0ZWdyYXk6NzgzMzc1MyxsaWdodHNsYXRlZ3JleTo3ODMzNzUzLGxpZ2h0c3RlZWxibHVlOjExNTg0NzM0LGxpZ2h0eWVsbG93OjE2Nzc3MTg0LGxpbWU6NjUyODAsbGltZWdyZWVuOjMzMjkzMzAsbGluZW46MTY0NDU2NzAsbWFnZW50YToxNjcxMTkzNSxtYXJvb246ODM4ODYwOCxtZWRpdW1hcXVhbWFyaW5lOjY3MzczMjIsbWVkaXVtYmx1ZToyMDUsbWVkaXVtb3JjaGlkOjEyMjExNjY3LG1lZGl1bXB1cnBsZTo5NjYyNjgzLG1lZGl1bXNlYWdyZWVuOjM5NzgwOTcsbWVkaXVtc2xhdGVibHVlOjgwODc3OTAsbWVkaXVtc3ByaW5nZ3JlZW46NjQxNTQsbWVkaXVtdHVycXVvaXNlOjQ3NzIzMDAsbWVkaXVtdmlvbGV0cmVkOjEzMDQ3MTczLG1pZG5pZ2h0Ymx1ZToxNjQ0OTEyLG1pbnRjcmVhbToxNjEyMTg1MCxtaXN0eXJvc2U6MTY3NzAyNzMsbW9jY2FzaW46MTY3NzAyMjksbmF2YWpvd2hpdGU6MTY3Njg2ODUsbmF2eToxMjgsb2xkbGFjZToxNjY0MzU1OCxvbGl2ZTo4NDIxMzc2LG9saXZlZHJhYjo3MDQ4NzM5LG9yYW5nZToxNjc1MzkyMCxvcmFuZ2VyZWQ6MTY3MjkzNDQsb3JjaGlkOjE0MzE1NzM0LHBhbGVnb2xkZW5yb2Q6MTU2NTcxMzAscGFsZWdyZWVuOjEwMDI1ODgwLHBhbGV0dXJxdW9pc2U6MTE1Mjk5NjYscGFsZXZpb2xldHJlZDoxNDM4MTIwMyxwYXBheWF3aGlwOjE2NzczMDc3LHBlYWNocHVmZjoxNjc2NzY3MyxwZXJ1OjEzNDY4OTkxLHBpbms6MTY3NjEwMzUscGx1bToxNDUyNDYzNyxwb3dkZXJibHVlOjExNTkxOTEwLHB1cnBsZTo4Mzg4NzM2LHJlYmVjY2FwdXJwbGU6NjY5Nzg4MSxyZWQ6MTY3MTE2ODAscm9zeWJyb3duOjEyMzU3NTE5LHJveWFsYmx1ZTo0Mjg2OTQ1LHNhZGRsZWJyb3duOjkxMjcxODcsc2FsbW9uOjE2NDE2ODgyLHNhbmR5YnJvd246MTYwMzI4NjQsc2VhZ3JlZW46MzA1MDMyNyxzZWFzaGVsbDoxNjc3NDYzOCxzaWVubmE6MTA1MDY3OTcsc2lsdmVyOjEyNjMyMjU2LHNreWJsdWU6ODkwMDMzMSxzbGF0ZWJsdWU6Njk3MDA2MSxzbGF0ZWdyYXk6NzM3Mjk0NCxzbGF0ZWdyZXk6NzM3Mjk0NCxzbm93OjE2Nzc1OTMwLHNwcmluZ2dyZWVuOjY1NDA3LHN0ZWVsYmx1ZTo0NjIwOTgwLHRhbjoxMzgwODc4MCx0ZWFsOjMyODk2LHRoaXN0bGU6MTQyMDQ4ODgsdG9tYXRvOjE2NzM3MDk1LHR1cnF1b2lzZTo0MjUxODU2LHZpb2xldDoxNTYzMTA4Nix3aGVhdDoxNjExMzMzMSx3aGl0ZToxNjc3NzIxNSx3aGl0ZXNtb2tlOjE2MTE5Mjg1LHllbGxvdzoxNjc3Njk2MCx5ZWxsb3dncmVlbjoxMDE0NTA3NH0scm49e2g6MCxzOjAsbDowfSxmaT17aDowLHM6MCxsOjB9O2Z1bmN0aW9uIGVyKGksZSx0KXtyZXR1cm4gdDwwJiYodCs9MSksdD4xJiYodC09MSksdDwxLzY/aSsoZS1pKSo2KnQ6dDwxLzI/ZTp0PDIvMz9pKyhlLWkpKjYqKDIvMy10KTppfWNsYXNzIFZle2NvbnN0cnVjdG9yKGUsdCxuKXtyZXR1cm4gdGhpcy5pc0NvbG9yPSEwLHRoaXMucj0xLHRoaXMuZz0xLHRoaXMuYj0xLHRoaXMuc2V0KGUsdCxuKX1zZXQoZSx0LG4pe2lmKHQ9PT12b2lkIDAmJm49PT12b2lkIDApe2NvbnN0IHI9ZTtyJiZyLmlzQ29sb3I/dGhpcy5jb3B5KHIpOnR5cGVvZiByPT0ibnVtYmVyIj90aGlzLnNldEhleChyKTp0eXBlb2Ygcj09InN0cmluZyImJnRoaXMuc2V0U3R5bGUocil9ZWxzZSB0aGlzLnNldFJHQihlLHQsbik7cmV0dXJuIHRoaXN9c2V0U2NhbGFyKGUpe3JldHVybiB0aGlzLnI9ZSx0aGlzLmc9ZSx0aGlzLmI9ZSx0aGlzfXNldEhleChlLHQ9YnQpe3JldHVybiBlPU1hdGguZmxvb3IoZSksdGhpcy5yPShlPj4xNiYyNTUpLzI1NSx0aGlzLmc9KGU+PjgmMjU1KS8yNTUsdGhpcy5iPShlJjI1NSkvMjU1LEJlLnRvV29ya2luZ0NvbG9yU3BhY2UodGhpcyx0KSx0aGlzfXNldFJHQihlLHQsbixyPUJlLndvcmtpbmdDb2xvclNwYWNlKXtyZXR1cm4gdGhpcy5yPWUsdGhpcy5nPXQsdGhpcy5iPW4sQmUudG9Xb3JraW5nQ29sb3JTcGFjZSh0aGlzLHIpLHRoaXN9c2V0SFNMKGUsdCxuLHI9QmUud29ya2luZ0NvbG9yU3BhY2Upe2lmKGU9T2koZSwxKSx0PWd0KHQsMCwxKSxuPWd0KG4sMCwxKSx0PT09MCl0aGlzLnI9dGhpcy5nPXRoaXMuYj1uO2Vsc2V7Y29uc3Qgcz1uPD0uNT9uKigxK3QpOm4rdC1uKnQsYT0yKm4tczt0aGlzLnI9ZXIoYSxzLGUrMS8zKSx0aGlzLmc9ZXIoYSxzLGUpLHRoaXMuYj1lcihhLHMsZS0xLzMpfXJldHVybiBCZS50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsciksdGhpc31zZXRTdHlsZShlLHQ9YnQpe2Z1bmN0aW9uIG4ocyl7cyE9PXZvaWQgMCYmcGFyc2VGbG9hdChzKTwxJiZjb25zb2xlLndhcm4oIlRIUkVFLkNvbG9yOiBBbHBoYSBjb21wb25lbnQgb2YgIitlKyIgd2lsbCBiZSBpZ25vcmVkLiIpfWxldCByO2lmKHI9L14oXHcrKVwoKFteXCldKilcKS8uZXhlYyhlKSl7bGV0IHM7Y29uc3QgYT1yWzFdLG89clsyXTtzd2l0Y2goYSl7Y2FzZSJyZ2IiOmNhc2UicmdiYSI6aWYocz0vXlxzKihcZCspXHMqLFxzKihcZCspXHMqLFxzKihcZCspXHMqKD86LFxzKihcZCpcLj9cZCspXHMqKT8kLy5leGVjKG8pKXJldHVybiBuKHNbNF0pLHRoaXMuc2V0UkdCKE1hdGgubWluKDI1NSxwYXJzZUludChzWzFdLDEwKSkvMjU1LE1hdGgubWluKDI1NSxwYXJzZUludChzWzJdLDEwKSkvMjU1LE1hdGgubWluKDI1NSxwYXJzZUludChzWzNdLDEwKSkvMjU1LHQpO2lmKHM9L15ccyooXGQrKVwlXHMqLFxzKihcZCspXCVccyosXHMqKFxkKylcJVxzKig/OixccyooXGQqXC4/XGQrKVxzKik/JC8uZXhlYyhvKSlyZXR1cm4gbihzWzRdKSx0aGlzLnNldFJHQihNYXRoLm1pbigxMDAscGFyc2VJbnQoc1sxXSwxMCkpLzEwMCxNYXRoLm1pbigxMDAscGFyc2VJbnQoc1syXSwxMCkpLzEwMCxNYXRoLm1pbigxMDAscGFyc2VJbnQoc1szXSwxMCkpLzEwMCx0KTticmVhaztjYXNlImhzbCI6Y2FzZSJoc2xhIjppZihzPS9eXHMqKFxkKlwuP1xkKylccyosXHMqKFxkKlwuP1xkKylcJVxzKixccyooXGQqXC4/XGQrKVwlXHMqKD86LFxzKihcZCpcLj9cZCspXHMqKT8kLy5leGVjKG8pKXJldHVybiBuKHNbNF0pLHRoaXMuc2V0SFNMKHBhcnNlRmxvYXQoc1sxXSkvMzYwLHBhcnNlRmxvYXQoc1syXSkvMTAwLHBhcnNlRmxvYXQoc1szXSkvMTAwLHQpO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS53YXJuKCJUSFJFRS5Db2xvcjogVW5rbm93biBjb2xvciBtb2RlbCAiK2UpfX1lbHNlIGlmKHI9L15cIyhbQS1GYS1mXGRdKykkLy5leGVjKGUpKXtjb25zdCBzPXJbMV0sYT1zLmxlbmd0aDtpZihhPT09MylyZXR1cm4gdGhpcy5zZXRSR0IocGFyc2VJbnQocy5jaGFyQXQoMCksMTYpLzE1LHBhcnNlSW50KHMuY2hhckF0KDEpLDE2KS8xNSxwYXJzZUludChzLmNoYXJBdCgyKSwxNikvMTUsdCk7aWYoYT09PTYpcmV0dXJuIHRoaXMuc2V0SGV4KHBhcnNlSW50KHMsMTYpLHQpO2NvbnNvbGUud2FybigiVEhSRUUuQ29sb3I6IEludmFsaWQgaGV4IGNvbG9yICIrZSl9ZWxzZSBpZihlJiZlLmxlbmd0aD4wKXJldHVybiB0aGlzLnNldENvbG9yTmFtZShlLHQpO3JldHVybiB0aGlzfXNldENvbG9yTmFtZShlLHQ9YnQpe2NvbnN0IG49SHJbZS50b0xvd2VyQ2FzZSgpXTtyZXR1cm4gbiE9PXZvaWQgMD90aGlzLnNldEhleChuLHQpOmNvbnNvbGUud2FybigiVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgIitlKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucix0aGlzLmcsdGhpcy5iKX1jb3B5KGUpe3JldHVybiB0aGlzLnI9ZS5yLHRoaXMuZz1lLmcsdGhpcy5iPWUuYix0aGlzfWNvcHlTUkdCVG9MaW5lYXIoZSl7cmV0dXJuIHRoaXMucj1WdChlLnIpLHRoaXMuZz1WdChlLmcpLHRoaXMuYj1WdChlLmIpLHRoaXN9Y29weUxpbmVhclRvU1JHQihlKXtyZXR1cm4gdGhpcy5yPXluKGUuciksdGhpcy5nPXluKGUuZyksdGhpcy5iPXluKGUuYiksdGhpc31jb252ZXJ0U1JHQlRvTGluZWFyKCl7cmV0dXJuIHRoaXMuY29weVNSR0JUb0xpbmVhcih0aGlzKSx0aGlzfWNvbnZlcnRMaW5lYXJUb1NSR0IoKXtyZXR1cm4gdGhpcy5jb3B5TGluZWFyVG9TUkdCKHRoaXMpLHRoaXN9Z2V0SGV4KGU9YnQpe3JldHVybiBCZS5mcm9tV29ya2luZ0NvbG9yU3BhY2UocHQuY29weSh0aGlzKSxlKSxNYXRoLnJvdW5kKGd0KHB0LnIqMjU1LDAsMjU1KSkqNjU1MzYrTWF0aC5yb3VuZChndChwdC5nKjI1NSwwLDI1NSkpKjI1NitNYXRoLnJvdW5kKGd0KHB0LmIqMjU1LDAsMjU1KSl9Z2V0SGV4U3RyaW5nKGU9YnQpe3JldHVybigiMDAwMDAwIit0aGlzLmdldEhleChlKS50b1N0cmluZygxNikpLnNsaWNlKC02KX1nZXRIU0woZSx0PUJlLndvcmtpbmdDb2xvclNwYWNlKXtCZS5mcm9tV29ya2luZ0NvbG9yU3BhY2UocHQuY29weSh0aGlzKSx0KTtjb25zdCBuPXB0LnIscj1wdC5nLHM9cHQuYixhPU1hdGgubWF4KG4scixzKSxvPU1hdGgubWluKG4scixzKTtsZXQgbCxjO2NvbnN0IGg9KG8rYSkvMjtpZihvPT09YSlsPTAsYz0wO2Vsc2V7Y29uc3QgZD1hLW87c3dpdGNoKGM9aDw9LjU/ZC8oYStvKTpkLygyLWEtbyksYSl7Y2FzZSBuOmw9KHItcykvZCsocjxzPzY6MCk7YnJlYWs7Y2FzZSByOmw9KHMtbikvZCsyO2JyZWFrO2Nhc2UgczpsPShuLXIpL2QrNDticmVha31sLz02fXJldHVybiBlLmg9bCxlLnM9YyxlLmw9aCxlfWdldFJHQihlLHQ9QmUud29ya2luZ0NvbG9yU3BhY2Upe3JldHVybiBCZS5mcm9tV29ya2luZ0NvbG9yU3BhY2UocHQuY29weSh0aGlzKSx0KSxlLnI9cHQucixlLmc9cHQuZyxlLmI9cHQuYixlfWdldFN0eWxlKGU9YnQpe0JlLmZyb21Xb3JraW5nQ29sb3JTcGFjZShwdC5jb3B5KHRoaXMpLGUpO2NvbnN0IHQ9cHQucixuPXB0Lmcscj1wdC5iO3JldHVybiBlIT09YnQ/YGNvbG9yKCR7ZX0gJHt0LnRvRml4ZWQoMyl9ICR7bi50b0ZpeGVkKDMpfSAke3IudG9GaXhlZCgzKX0pYDpgcmdiKCR7TWF0aC5yb3VuZCh0KjI1NSl9LCR7TWF0aC5yb3VuZChuKjI1NSl9LCR7TWF0aC5yb3VuZChyKjI1NSl9KWB9b2Zmc2V0SFNMKGUsdCxuKXtyZXR1cm4gdGhpcy5nZXRIU0wocm4pLHRoaXMuc2V0SFNMKHJuLmgrZSxybi5zK3Qscm4ubCtuKX1hZGQoZSl7cmV0dXJuIHRoaXMucis9ZS5yLHRoaXMuZys9ZS5nLHRoaXMuYis9ZS5iLHRoaXN9YWRkQ29sb3JzKGUsdCl7cmV0dXJuIHRoaXMucj1lLnIrdC5yLHRoaXMuZz1lLmcrdC5nLHRoaXMuYj1lLmIrdC5iLHRoaXN9YWRkU2NhbGFyKGUpe3JldHVybiB0aGlzLnIrPWUsdGhpcy5nKz1lLHRoaXMuYis9ZSx0aGlzfXN1YihlKXtyZXR1cm4gdGhpcy5yPU1hdGgubWF4KDAsdGhpcy5yLWUuciksdGhpcy5nPU1hdGgubWF4KDAsdGhpcy5nLWUuZyksdGhpcy5iPU1hdGgubWF4KDAsdGhpcy5iLWUuYiksdGhpc31tdWx0aXBseShlKXtyZXR1cm4gdGhpcy5yKj1lLnIsdGhpcy5nKj1lLmcsdGhpcy5iKj1lLmIsdGhpc31tdWx0aXBseVNjYWxhcihlKXtyZXR1cm4gdGhpcy5yKj1lLHRoaXMuZyo9ZSx0aGlzLmIqPWUsdGhpc31sZXJwKGUsdCl7cmV0dXJuIHRoaXMucis9KGUuci10aGlzLnIpKnQsdGhpcy5nKz0oZS5nLXRoaXMuZykqdCx0aGlzLmIrPShlLmItdGhpcy5iKSp0LHRoaXN9bGVycENvbG9ycyhlLHQsbil7cmV0dXJuIHRoaXMucj1lLnIrKHQuci1lLnIpKm4sdGhpcy5nPWUuZysodC5nLWUuZykqbix0aGlzLmI9ZS5iKyh0LmItZS5iKSpuLHRoaXN9bGVycEhTTChlLHQpe3RoaXMuZ2V0SFNMKHJuKSxlLmdldEhTTChmaSk7Y29uc3Qgbj1rbihybi5oLGZpLmgsdCkscj1rbihybi5zLGZpLnMsdCkscz1rbihybi5sLGZpLmwsdCk7cmV0dXJuIHRoaXMuc2V0SFNMKG4scixzKSx0aGlzfXNldEZyb21WZWN0b3IzKGUpe3JldHVybiB0aGlzLnI9ZS54LHRoaXMuZz1lLnksdGhpcy5iPWUueix0aGlzfWFwcGx5TWF0cml4MyhlKXtjb25zdCB0PXRoaXMucixuPXRoaXMuZyxyPXRoaXMuYixzPWUuZWxlbWVudHM7cmV0dXJuIHRoaXMucj1zWzBdKnQrc1szXSpuK3NbNl0qcix0aGlzLmc9c1sxXSp0K3NbNF0qbitzWzddKnIsdGhpcy5iPXNbMl0qdCtzWzVdKm4rc1s4XSpyLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLnI9PT10aGlzLnImJmUuZz09PXRoaXMuZyYmZS5iPT09dGhpcy5ifWZyb21BcnJheShlLHQ9MCl7cmV0dXJuIHRoaXMucj1lW3RdLHRoaXMuZz1lW3QrMV0sdGhpcy5iPWVbdCsyXSx0aGlzfXRvQXJyYXkoZT1bXSx0PTApe3JldHVybiBlW3RdPXRoaXMucixlW3QrMV09dGhpcy5nLGVbdCsyXT10aGlzLmIsZX1mcm9tQnVmZmVyQXR0cmlidXRlKGUsdCl7cmV0dXJuIHRoaXMucj1lLmdldFgodCksdGhpcy5nPWUuZ2V0WSh0KSx0aGlzLmI9ZS5nZXRaKHQpLHRoaXN9dG9KU09OKCl7cmV0dXJuIHRoaXMuZ2V0SGV4KCl9KltTeW1ib2wuaXRlcmF0b3JdKCl7eWllbGQgdGhpcy5yLHlpZWxkIHRoaXMuZyx5aWVsZCB0aGlzLmJ9fWNvbnN0IHB0PW5ldyBWZTtWZS5OQU1FUz1IcjtsZXQgd2E9MDtjbGFzcyBabiBleHRlbmRzIE1ue3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJNYXRlcmlhbCJ9Z2V0IHR5cGUoKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50eXBlfXNldCB0eXBlKGUpe31jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5pc01hdGVyaWFsPSEwLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJpZCIse3ZhbHVlOndhKyt9KSx0aGlzLnV1aWQ9U24oKSx0aGlzLm5hbWU9IiIsdGhpcy5ibGVuZGluZz0xLHRoaXMuc2lkZT0wLHRoaXMudmVydGV4Q29sb3JzPSExLHRoaXMub3BhY2l0eT0xLHRoaXMudHJhbnNwYXJlbnQ9ITEsdGhpcy5hbHBoYUhhc2g9ITEsdGhpcy5ibGVuZFNyYz0yMDQsdGhpcy5ibGVuZERzdD0yMDUsdGhpcy5ibGVuZEVxdWF0aW9uPTEwMCx0aGlzLmJsZW5kU3JjQWxwaGE9bnVsbCx0aGlzLmJsZW5kRHN0QWxwaGE9bnVsbCx0aGlzLmJsZW5kRXF1YXRpb25BbHBoYT1udWxsLHRoaXMuYmxlbmRDb2xvcj1uZXcgVmUoMCwwLDApLHRoaXMuYmxlbmRBbHBoYT0wLHRoaXMuZGVwdGhGdW5jPTMsdGhpcy5kZXB0aFRlc3Q9ITAsdGhpcy5kZXB0aFdyaXRlPSEwLHRoaXMuc3RlbmNpbFdyaXRlTWFzaz0yNTUsdGhpcy5zdGVuY2lsRnVuYz01MTksdGhpcy5zdGVuY2lsUmVmPTAsdGhpcy5zdGVuY2lsRnVuY01hc2s9MjU1LHRoaXMuc3RlbmNpbEZhaWw9NzY4MCx0aGlzLnN0ZW5jaWxaRmFpbD03NjgwLHRoaXMuc3RlbmNpbFpQYXNzPTc2ODAsdGhpcy5zdGVuY2lsV3JpdGU9ITEsdGhpcy5jbGlwcGluZ1BsYW5lcz1udWxsLHRoaXMuY2xpcEludGVyc2VjdGlvbj0hMSx0aGlzLmNsaXBTaGFkb3dzPSExLHRoaXMuc2hhZG93U2lkZT1udWxsLHRoaXMuY29sb3JXcml0ZT0hMCx0aGlzLnByZWNpc2lvbj1udWxsLHRoaXMucG9seWdvbk9mZnNldD0hMSx0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3I9MCx0aGlzLnBvbHlnb25PZmZzZXRVbml0cz0wLHRoaXMuZGl0aGVyaW5nPSExLHRoaXMuYWxwaGFUb0NvdmVyYWdlPSExLHRoaXMucHJlbXVsdGlwbGllZEFscGhhPSExLHRoaXMuZm9yY2VTaW5nbGVQYXNzPSExLHRoaXMudmlzaWJsZT0hMCx0aGlzLnRvbmVNYXBwZWQ9ITAsdGhpcy51c2VyRGF0YT17fSx0aGlzLnZlcnNpb249MCx0aGlzLl9hbHBoYVRlc3Q9MH1nZXQgYWxwaGFUZXN0KCl7cmV0dXJuIHRoaXMuX2FscGhhVGVzdH1zZXQgYWxwaGFUZXN0KGUpe3RoaXMuX2FscGhhVGVzdD4wIT1lPjAmJnRoaXMudmVyc2lvbisrLHRoaXMuX2FscGhhVGVzdD1lfW9uQmVmb3JlUmVuZGVyKCl7fW9uQmVmb3JlQ29tcGlsZSgpe31jdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKXtyZXR1cm4gdGhpcy5vbkJlZm9yZUNvbXBpbGUudG9TdHJpbmcoKX1zZXRWYWx1ZXMoZSl7aWYoZSE9PXZvaWQgMClmb3IoY29uc3QgdCBpbiBlKXtjb25zdCBuPWVbdF07aWYobj09PXZvaWQgMCl7Y29uc29sZS53YXJuKGBUSFJFRS5NYXRlcmlhbDogcGFyYW1ldGVyICcke3R9JyBoYXMgdmFsdWUgb2YgdW5kZWZpbmVkLmApO2NvbnRpbnVlfWNvbnN0IHI9dGhpc1t0XTtpZihyPT09dm9pZCAwKXtjb25zb2xlLndhcm4oYFRIUkVFLk1hdGVyaWFsOiAnJHt0fScgaXMgbm90IGEgcHJvcGVydHkgb2YgVEhSRUUuJHt0aGlzLnR5cGV9LmApO2NvbnRpbnVlfXImJnIuaXNDb2xvcj9yLnNldChuKTpyJiZyLmlzVmVjdG9yMyYmbiYmbi5pc1ZlY3RvcjM/ci5jb3B5KG4pOnRoaXNbdF09bn19dG9KU09OKGUpe2NvbnN0IHQ9ZT09PXZvaWQgMHx8dHlwZW9mIGU9PSJzdHJpbmciO3QmJihlPXt0ZXh0dXJlczp7fSxpbWFnZXM6e319KTtjb25zdCBuPXttZXRhZGF0YTp7dmVyc2lvbjo0LjYsdHlwZToiTWF0ZXJpYWwiLGdlbmVyYXRvcjoiTWF0ZXJpYWwudG9KU09OIn19O24udXVpZD10aGlzLnV1aWQsbi50eXBlPXRoaXMudHlwZSx0aGlzLm5hbWUhPT0iIiYmKG4ubmFtZT10aGlzLm5hbWUpLHRoaXMuY29sb3ImJnRoaXMuY29sb3IuaXNDb2xvciYmKG4uY29sb3I9dGhpcy5jb2xvci5nZXRIZXgoKSksdGhpcy5yb3VnaG5lc3MhPT12b2lkIDAmJihuLnJvdWdobmVzcz10aGlzLnJvdWdobmVzcyksdGhpcy5tZXRhbG5lc3MhPT12b2lkIDAmJihuLm1ldGFsbmVzcz10aGlzLm1ldGFsbmVzcyksdGhpcy5zaGVlbiE9PXZvaWQgMCYmKG4uc2hlZW49dGhpcy5zaGVlbiksdGhpcy5zaGVlbkNvbG9yJiZ0aGlzLnNoZWVuQ29sb3IuaXNDb2xvciYmKG4uc2hlZW5Db2xvcj10aGlzLnNoZWVuQ29sb3IuZ2V0SGV4KCkpLHRoaXMuc2hlZW5Sb3VnaG5lc3MhPT12b2lkIDAmJihuLnNoZWVuUm91Z2huZXNzPXRoaXMuc2hlZW5Sb3VnaG5lc3MpLHRoaXMuZW1pc3NpdmUmJnRoaXMuZW1pc3NpdmUuaXNDb2xvciYmKG4uZW1pc3NpdmU9dGhpcy5lbWlzc2l2ZS5nZXRIZXgoKSksdGhpcy5lbWlzc2l2ZUludGVuc2l0eSE9PXZvaWQgMCYmdGhpcy5lbWlzc2l2ZUludGVuc2l0eSE9PTEmJihuLmVtaXNzaXZlSW50ZW5zaXR5PXRoaXMuZW1pc3NpdmVJbnRlbnNpdHkpLHRoaXMuc3BlY3VsYXImJnRoaXMuc3BlY3VsYXIuaXNDb2xvciYmKG4uc3BlY3VsYXI9dGhpcy5zcGVjdWxhci5nZXRIZXgoKSksdGhpcy5zcGVjdWxhckludGVuc2l0eSE9PXZvaWQgMCYmKG4uc3BlY3VsYXJJbnRlbnNpdHk9dGhpcy5zcGVjdWxhckludGVuc2l0eSksdGhpcy5zcGVjdWxhckNvbG9yJiZ0aGlzLnNwZWN1bGFyQ29sb3IuaXNDb2xvciYmKG4uc3BlY3VsYXJDb2xvcj10aGlzLnNwZWN1bGFyQ29sb3IuZ2V0SGV4KCkpLHRoaXMuc2hpbmluZXNzIT09dm9pZCAwJiYobi5zaGluaW5lc3M9dGhpcy5zaGluaW5lc3MpLHRoaXMuY2xlYXJjb2F0IT09dm9pZCAwJiYobi5jbGVhcmNvYXQ9dGhpcy5jbGVhcmNvYXQpLHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzIT09dm9pZCAwJiYobi5jbGVhcmNvYXRSb3VnaG5lc3M9dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MpLHRoaXMuY2xlYXJjb2F0TWFwJiZ0aGlzLmNsZWFyY29hdE1hcC5pc1RleHR1cmUmJihuLmNsZWFyY29hdE1hcD10aGlzLmNsZWFyY29hdE1hcC50b0pTT04oZSkudXVpZCksdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAmJnRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwLmlzVGV4dHVyZSYmKG4uY2xlYXJjb2F0Um91Z2huZXNzTWFwPXRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLmNsZWFyY29hdE5vcm1hbE1hcCYmdGhpcy5jbGVhcmNvYXROb3JtYWxNYXAuaXNUZXh0dXJlJiYobi5jbGVhcmNvYXROb3JtYWxNYXA9dGhpcy5jbGVhcmNvYXROb3JtYWxNYXAudG9KU09OKGUpLnV1aWQsbi5jbGVhcmNvYXROb3JtYWxTY2FsZT10aGlzLmNsZWFyY29hdE5vcm1hbFNjYWxlLnRvQXJyYXkoKSksdGhpcy5kaXNwZXJzaW9uIT09dm9pZCAwJiYobi5kaXNwZXJzaW9uPXRoaXMuZGlzcGVyc2lvbiksdGhpcy5pcmlkZXNjZW5jZSE9PXZvaWQgMCYmKG4uaXJpZGVzY2VuY2U9dGhpcy5pcmlkZXNjZW5jZSksdGhpcy5pcmlkZXNjZW5jZUlPUiE9PXZvaWQgMCYmKG4uaXJpZGVzY2VuY2VJT1I9dGhpcy5pcmlkZXNjZW5jZUlPUiksdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlIT09dm9pZCAwJiYobi5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlPXRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSksdGhpcy5pcmlkZXNjZW5jZU1hcCYmdGhpcy5pcmlkZXNjZW5jZU1hcC5pc1RleHR1cmUmJihuLmlyaWRlc2NlbmNlTWFwPXRoaXMuaXJpZGVzY2VuY2VNYXAudG9KU09OKGUpLnV1aWQpLHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAmJnRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAuaXNUZXh0dXJlJiYobi5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcD10aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLmFuaXNvdHJvcHkhPT12b2lkIDAmJihuLmFuaXNvdHJvcHk9dGhpcy5hbmlzb3Ryb3B5KSx0aGlzLmFuaXNvdHJvcHlSb3RhdGlvbiE9PXZvaWQgMCYmKG4uYW5pc290cm9weVJvdGF0aW9uPXRoaXMuYW5pc290cm9weVJvdGF0aW9uKSx0aGlzLmFuaXNvdHJvcHlNYXAmJnRoaXMuYW5pc290cm9weU1hcC5pc1RleHR1cmUmJihuLmFuaXNvdHJvcHlNYXA9dGhpcy5hbmlzb3Ryb3B5TWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLm1hcCYmdGhpcy5tYXAuaXNUZXh0dXJlJiYobi5tYXA9dGhpcy5tYXAudG9KU09OKGUpLnV1aWQpLHRoaXMubWF0Y2FwJiZ0aGlzLm1hdGNhcC5pc1RleHR1cmUmJihuLm1hdGNhcD10aGlzLm1hdGNhcC50b0pTT04oZSkudXVpZCksdGhpcy5hbHBoYU1hcCYmdGhpcy5hbHBoYU1hcC5pc1RleHR1cmUmJihuLmFscGhhTWFwPXRoaXMuYWxwaGFNYXAudG9KU09OKGUpLnV1aWQpLHRoaXMubGlnaHRNYXAmJnRoaXMubGlnaHRNYXAuaXNUZXh0dXJlJiYobi5saWdodE1hcD10aGlzLmxpZ2h0TWFwLnRvSlNPTihlKS51dWlkLG4ubGlnaHRNYXBJbnRlbnNpdHk9dGhpcy5saWdodE1hcEludGVuc2l0eSksdGhpcy5hb01hcCYmdGhpcy5hb01hcC5pc1RleHR1cmUmJihuLmFvTWFwPXRoaXMuYW9NYXAudG9KU09OKGUpLnV1aWQsbi5hb01hcEludGVuc2l0eT10aGlzLmFvTWFwSW50ZW5zaXR5KSx0aGlzLmJ1bXBNYXAmJnRoaXMuYnVtcE1hcC5pc1RleHR1cmUmJihuLmJ1bXBNYXA9dGhpcy5idW1wTWFwLnRvSlNPTihlKS51dWlkLG4uYnVtcFNjYWxlPXRoaXMuYnVtcFNjYWxlKSx0aGlzLm5vcm1hbE1hcCYmdGhpcy5ub3JtYWxNYXAuaXNUZXh0dXJlJiYobi5ub3JtYWxNYXA9dGhpcy5ub3JtYWxNYXAudG9KU09OKGUpLnV1aWQsbi5ub3JtYWxNYXBUeXBlPXRoaXMubm9ybWFsTWFwVHlwZSxuLm5vcm1hbFNjYWxlPXRoaXMubm9ybWFsU2NhbGUudG9BcnJheSgpKSx0aGlzLmRpc3BsYWNlbWVudE1hcCYmdGhpcy5kaXNwbGFjZW1lbnRNYXAuaXNUZXh0dXJlJiYobi5kaXNwbGFjZW1lbnRNYXA9dGhpcy5kaXNwbGFjZW1lbnRNYXAudG9KU09OKGUpLnV1aWQsbi5kaXNwbGFjZW1lbnRTY2FsZT10aGlzLmRpc3BsYWNlbWVudFNjYWxlLG4uZGlzcGxhY2VtZW50Qmlhcz10aGlzLmRpc3BsYWNlbWVudEJpYXMpLHRoaXMucm91Z2huZXNzTWFwJiZ0aGlzLnJvdWdobmVzc01hcC5pc1RleHR1cmUmJihuLnJvdWdobmVzc01hcD10aGlzLnJvdWdobmVzc01hcC50b0pTT04oZSkudXVpZCksdGhpcy5tZXRhbG5lc3NNYXAmJnRoaXMubWV0YWxuZXNzTWFwLmlzVGV4dHVyZSYmKG4ubWV0YWxuZXNzTWFwPXRoaXMubWV0YWxuZXNzTWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLmVtaXNzaXZlTWFwJiZ0aGlzLmVtaXNzaXZlTWFwLmlzVGV4dHVyZSYmKG4uZW1pc3NpdmVNYXA9dGhpcy5lbWlzc2l2ZU1hcC50b0pTT04oZSkudXVpZCksdGhpcy5zcGVjdWxhck1hcCYmdGhpcy5zcGVjdWxhck1hcC5pc1RleHR1cmUmJihuLnNwZWN1bGFyTWFwPXRoaXMuc3BlY3VsYXJNYXAudG9KU09OKGUpLnV1aWQpLHRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAmJnRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAuaXNUZXh0dXJlJiYobi5zcGVjdWxhckludGVuc2l0eU1hcD10aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLnNwZWN1bGFyQ29sb3JNYXAmJnRoaXMuc3BlY3VsYXJDb2xvck1hcC5pc1RleHR1cmUmJihuLnNwZWN1bGFyQ29sb3JNYXA9dGhpcy5zcGVjdWxhckNvbG9yTWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLmVudk1hcCYmdGhpcy5lbnZNYXAuaXNUZXh0dXJlJiYobi5lbnZNYXA9dGhpcy5lbnZNYXAudG9KU09OKGUpLnV1aWQsdGhpcy5jb21iaW5lIT09dm9pZCAwJiYobi5jb21iaW5lPXRoaXMuY29tYmluZSkpLHRoaXMuZW52TWFwUm90YXRpb24hPT12b2lkIDAmJihuLmVudk1hcFJvdGF0aW9uPXRoaXMuZW52TWFwUm90YXRpb24udG9BcnJheSgpKSx0aGlzLmVudk1hcEludGVuc2l0eSE9PXZvaWQgMCYmKG4uZW52TWFwSW50ZW5zaXR5PXRoaXMuZW52TWFwSW50ZW5zaXR5KSx0aGlzLnJlZmxlY3Rpdml0eSE9PXZvaWQgMCYmKG4ucmVmbGVjdGl2aXR5PXRoaXMucmVmbGVjdGl2aXR5KSx0aGlzLnJlZnJhY3Rpb25SYXRpbyE9PXZvaWQgMCYmKG4ucmVmcmFjdGlvblJhdGlvPXRoaXMucmVmcmFjdGlvblJhdGlvKSx0aGlzLmdyYWRpZW50TWFwJiZ0aGlzLmdyYWRpZW50TWFwLmlzVGV4dHVyZSYmKG4uZ3JhZGllbnRNYXA9dGhpcy5ncmFkaWVudE1hcC50b0pTT04oZSkudXVpZCksdGhpcy50cmFuc21pc3Npb24hPT12b2lkIDAmJihuLnRyYW5zbWlzc2lvbj10aGlzLnRyYW5zbWlzc2lvbiksdGhpcy50cmFuc21pc3Npb25NYXAmJnRoaXMudHJhbnNtaXNzaW9uTWFwLmlzVGV4dHVyZSYmKG4udHJhbnNtaXNzaW9uTWFwPXRoaXMudHJhbnNtaXNzaW9uTWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLnRoaWNrbmVzcyE9PXZvaWQgMCYmKG4udGhpY2tuZXNzPXRoaXMudGhpY2tuZXNzKSx0aGlzLnRoaWNrbmVzc01hcCYmdGhpcy50aGlja25lc3NNYXAuaXNUZXh0dXJlJiYobi50aGlja25lc3NNYXA9dGhpcy50aGlja25lc3NNYXAudG9KU09OKGUpLnV1aWQpLHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZSE9PXZvaWQgMCYmdGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlIT09MS8wJiYobi5hdHRlbnVhdGlvbkRpc3RhbmNlPXRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZSksdGhpcy5hdHRlbnVhdGlvbkNvbG9yIT09dm9pZCAwJiYobi5hdHRlbnVhdGlvbkNvbG9yPXRoaXMuYXR0ZW51YXRpb25Db2xvci5nZXRIZXgoKSksdGhpcy5zaXplIT09dm9pZCAwJiYobi5zaXplPXRoaXMuc2l6ZSksdGhpcy5zaGFkb3dTaWRlIT09bnVsbCYmKG4uc2hhZG93U2lkZT10aGlzLnNoYWRvd1NpZGUpLHRoaXMuc2l6ZUF0dGVudWF0aW9uIT09dm9pZCAwJiYobi5zaXplQXR0ZW51YXRpb249dGhpcy5zaXplQXR0ZW51YXRpb24pLHRoaXMuYmxlbmRpbmchPT0xJiYobi5ibGVuZGluZz10aGlzLmJsZW5kaW5nKSx0aGlzLnNpZGUhPT0wJiYobi5zaWRlPXRoaXMuc2lkZSksdGhpcy52ZXJ0ZXhDb2xvcnM9PT0hMCYmKG4udmVydGV4Q29sb3JzPSEwKSx0aGlzLm9wYWNpdHk8MSYmKG4ub3BhY2l0eT10aGlzLm9wYWNpdHkpLHRoaXMudHJhbnNwYXJlbnQ9PT0hMCYmKG4udHJhbnNwYXJlbnQ9ITApLHRoaXMuYmxlbmRTcmMhPT0yMDQmJihuLmJsZW5kU3JjPXRoaXMuYmxlbmRTcmMpLHRoaXMuYmxlbmREc3QhPT0yMDUmJihuLmJsZW5kRHN0PXRoaXMuYmxlbmREc3QpLHRoaXMuYmxlbmRFcXVhdGlvbiE9PTEwMCYmKG4uYmxlbmRFcXVhdGlvbj10aGlzLmJsZW5kRXF1YXRpb24pLHRoaXMuYmxlbmRTcmNBbHBoYSE9PW51bGwmJihuLmJsZW5kU3JjQWxwaGE9dGhpcy5ibGVuZFNyY0FscGhhKSx0aGlzLmJsZW5kRHN0QWxwaGEhPT1udWxsJiYobi5ibGVuZERzdEFscGhhPXRoaXMuYmxlbmREc3RBbHBoYSksdGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEhPT1udWxsJiYobi5ibGVuZEVxdWF0aW9uQWxwaGE9dGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEpLHRoaXMuYmxlbmRDb2xvciYmdGhpcy5ibGVuZENvbG9yLmlzQ29sb3ImJihuLmJsZW5kQ29sb3I9dGhpcy5ibGVuZENvbG9yLmdldEhleCgpKSx0aGlzLmJsZW5kQWxwaGEhPT0wJiYobi5ibGVuZEFscGhhPXRoaXMuYmxlbmRBbHBoYSksdGhpcy5kZXB0aEZ1bmMhPT0zJiYobi5kZXB0aEZ1bmM9dGhpcy5kZXB0aEZ1bmMpLHRoaXMuZGVwdGhUZXN0PT09ITEmJihuLmRlcHRoVGVzdD10aGlzLmRlcHRoVGVzdCksdGhpcy5kZXB0aFdyaXRlPT09ITEmJihuLmRlcHRoV3JpdGU9dGhpcy5kZXB0aFdyaXRlKSx0aGlzLmNvbG9yV3JpdGU9PT0hMSYmKG4uY29sb3JXcml0ZT10aGlzLmNvbG9yV3JpdGUpLHRoaXMuc3RlbmNpbFdyaXRlTWFzayE9PTI1NSYmKG4uc3RlbmNpbFdyaXRlTWFzaz10aGlzLnN0ZW5jaWxXcml0ZU1hc2spLHRoaXMuc3RlbmNpbEZ1bmMhPT01MTkmJihuLnN0ZW5jaWxGdW5jPXRoaXMuc3RlbmNpbEZ1bmMpLHRoaXMuc3RlbmNpbFJlZiE9PTAmJihuLnN0ZW5jaWxSZWY9dGhpcy5zdGVuY2lsUmVmKSx0aGlzLnN0ZW5jaWxGdW5jTWFzayE9PTI1NSYmKG4uc3RlbmNpbEZ1bmNNYXNrPXRoaXMuc3RlbmNpbEZ1bmNNYXNrKSx0aGlzLnN0ZW5jaWxGYWlsIT09NzY4MCYmKG4uc3RlbmNpbEZhaWw9dGhpcy5zdGVuY2lsRmFpbCksdGhpcy5zdGVuY2lsWkZhaWwhPT03NjgwJiYobi5zdGVuY2lsWkZhaWw9dGhpcy5zdGVuY2lsWkZhaWwpLHRoaXMuc3RlbmNpbFpQYXNzIT09NzY4MCYmKG4uc3RlbmNpbFpQYXNzPXRoaXMuc3RlbmNpbFpQYXNzKSx0aGlzLnN0ZW5jaWxXcml0ZT09PSEwJiYobi5zdGVuY2lsV3JpdGU9dGhpcy5zdGVuY2lsV3JpdGUpLHRoaXMucm90YXRpb24hPT12b2lkIDAmJnRoaXMucm90YXRpb24hPT0wJiYobi5yb3RhdGlvbj10aGlzLnJvdGF0aW9uKSx0aGlzLnBvbHlnb25PZmZzZXQ9PT0hMCYmKG4ucG9seWdvbk9mZnNldD0hMCksdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yIT09MCYmKG4ucG9seWdvbk9mZnNldEZhY3Rvcj10aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IpLHRoaXMucG9seWdvbk9mZnNldFVuaXRzIT09MCYmKG4ucG9seWdvbk9mZnNldFVuaXRzPXRoaXMucG9seWdvbk9mZnNldFVuaXRzKSx0aGlzLmxpbmV3aWR0aCE9PXZvaWQgMCYmdGhpcy5saW5ld2lkdGghPT0xJiYobi5saW5ld2lkdGg9dGhpcy5saW5ld2lkdGgpLHRoaXMuZGFzaFNpemUhPT12b2lkIDAmJihuLmRhc2hTaXplPXRoaXMuZGFzaFNpemUpLHRoaXMuZ2FwU2l6ZSE9PXZvaWQgMCYmKG4uZ2FwU2l6ZT10aGlzLmdhcFNpemUpLHRoaXMuc2NhbGUhPT12b2lkIDAmJihuLnNjYWxlPXRoaXMuc2NhbGUpLHRoaXMuZGl0aGVyaW5nPT09ITAmJihuLmRpdGhlcmluZz0hMCksdGhpcy5hbHBoYVRlc3Q+MCYmKG4uYWxwaGFUZXN0PXRoaXMuYWxwaGFUZXN0KSx0aGlzLmFscGhhSGFzaD09PSEwJiYobi5hbHBoYUhhc2g9ITApLHRoaXMuYWxwaGFUb0NvdmVyYWdlPT09ITAmJihuLmFscGhhVG9Db3ZlcmFnZT0hMCksdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGE9PT0hMCYmKG4ucHJlbXVsdGlwbGllZEFscGhhPSEwKSx0aGlzLmZvcmNlU2luZ2xlUGFzcz09PSEwJiYobi5mb3JjZVNpbmdsZVBhc3M9ITApLHRoaXMud2lyZWZyYW1lPT09ITAmJihuLndpcmVmcmFtZT0hMCksdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg+MSYmKG4ud2lyZWZyYW1lTGluZXdpZHRoPXRoaXMud2lyZWZyYW1lTGluZXdpZHRoKSx0aGlzLndpcmVmcmFtZUxpbmVjYXAhPT0icm91bmQiJiYobi53aXJlZnJhbWVMaW5lY2FwPXRoaXMud2lyZWZyYW1lTGluZWNhcCksdGhpcy53aXJlZnJhbWVMaW5lam9pbiE9PSJyb3VuZCImJihuLndpcmVmcmFtZUxpbmVqb2luPXRoaXMud2lyZWZyYW1lTGluZWpvaW4pLHRoaXMuZmxhdFNoYWRpbmc9PT0hMCYmKG4uZmxhdFNoYWRpbmc9ITApLHRoaXMudmlzaWJsZT09PSExJiYobi52aXNpYmxlPSExKSx0aGlzLnRvbmVNYXBwZWQ9PT0hMSYmKG4udG9uZU1hcHBlZD0hMSksdGhpcy5mb2c9PT0hMSYmKG4uZm9nPSExKSxPYmplY3Qua2V5cyh0aGlzLnVzZXJEYXRhKS5sZW5ndGg+MCYmKG4udXNlckRhdGE9dGhpcy51c2VyRGF0YSk7ZnVuY3Rpb24gcihzKXtjb25zdCBhPVtdO2Zvcihjb25zdCBvIGluIHMpe2NvbnN0IGw9c1tvXTtkZWxldGUgbC5tZXRhZGF0YSxhLnB1c2gobCl9cmV0dXJuIGF9aWYodCl7Y29uc3Qgcz1yKGUudGV4dHVyZXMpLGE9cihlLmltYWdlcyk7cy5sZW5ndGg+MCYmKG4udGV4dHVyZXM9cyksYS5sZW5ndGg+MCYmKG4uaW1hZ2VzPWEpfXJldHVybiBufWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX1jb3B5KGUpe3RoaXMubmFtZT1lLm5hbWUsdGhpcy5ibGVuZGluZz1lLmJsZW5kaW5nLHRoaXMuc2lkZT1lLnNpZGUsdGhpcy52ZXJ0ZXhDb2xvcnM9ZS52ZXJ0ZXhDb2xvcnMsdGhpcy5vcGFjaXR5PWUub3BhY2l0eSx0aGlzLnRyYW5zcGFyZW50PWUudHJhbnNwYXJlbnQsdGhpcy5ibGVuZFNyYz1lLmJsZW5kU3JjLHRoaXMuYmxlbmREc3Q9ZS5ibGVuZERzdCx0aGlzLmJsZW5kRXF1YXRpb249ZS5ibGVuZEVxdWF0aW9uLHRoaXMuYmxlbmRTcmNBbHBoYT1lLmJsZW5kU3JjQWxwaGEsdGhpcy5ibGVuZERzdEFscGhhPWUuYmxlbmREc3RBbHBoYSx0aGlzLmJsZW5kRXF1YXRpb25BbHBoYT1lLmJsZW5kRXF1YXRpb25BbHBoYSx0aGlzLmJsZW5kQ29sb3IuY29weShlLmJsZW5kQ29sb3IpLHRoaXMuYmxlbmRBbHBoYT1lLmJsZW5kQWxwaGEsdGhpcy5kZXB0aEZ1bmM9ZS5kZXB0aEZ1bmMsdGhpcy5kZXB0aFRlc3Q9ZS5kZXB0aFRlc3QsdGhpcy5kZXB0aFdyaXRlPWUuZGVwdGhXcml0ZSx0aGlzLnN0ZW5jaWxXcml0ZU1hc2s9ZS5zdGVuY2lsV3JpdGVNYXNrLHRoaXMuc3RlbmNpbEZ1bmM9ZS5zdGVuY2lsRnVuYyx0aGlzLnN0ZW5jaWxSZWY9ZS5zdGVuY2lsUmVmLHRoaXMuc3RlbmNpbEZ1bmNNYXNrPWUuc3RlbmNpbEZ1bmNNYXNrLHRoaXMuc3RlbmNpbEZhaWw9ZS5zdGVuY2lsRmFpbCx0aGlzLnN0ZW5jaWxaRmFpbD1lLnN0ZW5jaWxaRmFpbCx0aGlzLnN0ZW5jaWxaUGFzcz1lLnN0ZW5jaWxaUGFzcyx0aGlzLnN0ZW5jaWxXcml0ZT1lLnN0ZW5jaWxXcml0ZTtjb25zdCB0PWUuY2xpcHBpbmdQbGFuZXM7bGV0IG49bnVsbDtpZih0IT09bnVsbCl7Y29uc3Qgcj10Lmxlbmd0aDtuPW5ldyBBcnJheShyKTtmb3IobGV0IHM9MDtzIT09cjsrK3MpbltzXT10W3NdLmNsb25lKCl9cmV0dXJuIHRoaXMuY2xpcHBpbmdQbGFuZXM9bix0aGlzLmNsaXBJbnRlcnNlY3Rpb249ZS5jbGlwSW50ZXJzZWN0aW9uLHRoaXMuY2xpcFNoYWRvd3M9ZS5jbGlwU2hhZG93cyx0aGlzLnNoYWRvd1NpZGU9ZS5zaGFkb3dTaWRlLHRoaXMuY29sb3JXcml0ZT1lLmNvbG9yV3JpdGUsdGhpcy5wcmVjaXNpb249ZS5wcmVjaXNpb24sdGhpcy5wb2x5Z29uT2Zmc2V0PWUucG9seWdvbk9mZnNldCx0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3I9ZS5wb2x5Z29uT2Zmc2V0RmFjdG9yLHRoaXMucG9seWdvbk9mZnNldFVuaXRzPWUucG9seWdvbk9mZnNldFVuaXRzLHRoaXMuZGl0aGVyaW5nPWUuZGl0aGVyaW5nLHRoaXMuYWxwaGFUZXN0PWUuYWxwaGFUZXN0LHRoaXMuYWxwaGFIYXNoPWUuYWxwaGFIYXNoLHRoaXMuYWxwaGFUb0NvdmVyYWdlPWUuYWxwaGFUb0NvdmVyYWdlLHRoaXMucHJlbXVsdGlwbGllZEFscGhhPWUucHJlbXVsdGlwbGllZEFscGhhLHRoaXMuZm9yY2VTaW5nbGVQYXNzPWUuZm9yY2VTaW5nbGVQYXNzLHRoaXMudmlzaWJsZT1lLnZpc2libGUsdGhpcy50b25lTWFwcGVkPWUudG9uZU1hcHBlZCx0aGlzLnVzZXJEYXRhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZS51c2VyRGF0YSkpLHRoaXN9ZGlzcG9zZSgpe3RoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToiZGlzcG9zZSJ9KX1zZXQgbmVlZHNVcGRhdGUoZSl7ZT09PSEwJiZ0aGlzLnZlcnNpb24rK31vbkJ1aWxkKCl7Y29uc29sZS53YXJuKCJNYXRlcmlhbDogb25CdWlsZCgpIGhhcyBiZWVuIHJlbW92ZWQuIil9fWNsYXNzIGpuIGV4dGVuZHMgWm57c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIk1lc2hCYXNpY01hdGVyaWFsIn1jb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuaXNNZXNoQmFzaWNNYXRlcmlhbD0hMCx0aGlzLmNvbG9yPW5ldyBWZSgxNjc3NzIxNSksdGhpcy5tYXA9bnVsbCx0aGlzLmxpZ2h0TWFwPW51bGwsdGhpcy5saWdodE1hcEludGVuc2l0eT0xLHRoaXMuYW9NYXA9bnVsbCx0aGlzLmFvTWFwSW50ZW5zaXR5PTEsdGhpcy5zcGVjdWxhck1hcD1udWxsLHRoaXMuYWxwaGFNYXA9bnVsbCx0aGlzLmVudk1hcD1udWxsLHRoaXMuZW52TWFwUm90YXRpb249bmV3IFh0LHRoaXMuY29tYmluZT0wLHRoaXMucmVmbGVjdGl2aXR5PTEsdGhpcy5yZWZyYWN0aW9uUmF0aW89Ljk4LHRoaXMud2lyZWZyYW1lPSExLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPTEsdGhpcy53aXJlZnJhbWVMaW5lY2FwPSJyb3VuZCIsdGhpcy53aXJlZnJhbWVMaW5lam9pbj0icm91bmQiLHRoaXMuZm9nPSEwLHRoaXMuc2V0VmFsdWVzKGUpfWNvcHkoZSl7cmV0dXJuIHN1cGVyLmNvcHkoZSksdGhpcy5jb2xvci5jb3B5KGUuY29sb3IpLHRoaXMubWFwPWUubWFwLHRoaXMubGlnaHRNYXA9ZS5saWdodE1hcCx0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5PWUubGlnaHRNYXBJbnRlbnNpdHksdGhpcy5hb01hcD1lLmFvTWFwLHRoaXMuYW9NYXBJbnRlbnNpdHk9ZS5hb01hcEludGVuc2l0eSx0aGlzLnNwZWN1bGFyTWFwPWUuc3BlY3VsYXJNYXAsdGhpcy5hbHBoYU1hcD1lLmFscGhhTWFwLHRoaXMuZW52TWFwPWUuZW52TWFwLHRoaXMuZW52TWFwUm90YXRpb24uY29weShlLmVudk1hcFJvdGF0aW9uKSx0aGlzLmNvbWJpbmU9ZS5jb21iaW5lLHRoaXMucmVmbGVjdGl2aXR5PWUucmVmbGVjdGl2aXR5LHRoaXMucmVmcmFjdGlvblJhdGlvPWUucmVmcmFjdGlvblJhdGlvLHRoaXMud2lyZWZyYW1lPWUud2lyZWZyYW1lLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPWUud2lyZWZyYW1lTGluZXdpZHRoLHRoaXMud2lyZWZyYW1lTGluZWNhcD1lLndpcmVmcmFtZUxpbmVjYXAsdGhpcy53aXJlZnJhbWVMaW5lam9pbj1lLndpcmVmcmFtZUxpbmVqb2luLHRoaXMuZm9nPWUuZm9nLHRoaXN9fWNvbnN0IG90PW5ldyBPLHBpPW5ldyBQZTtjbGFzcyBTdHtjb25zdHJ1Y3RvcihlLHQsbj0hMSl7aWYoQXJyYXkuaXNBcnJheShlKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LiIpO3RoaXMuaXNCdWZmZXJBdHRyaWJ1dGU9ITAsdGhpcy5uYW1lPSIiLHRoaXMuYXJyYXk9ZSx0aGlzLml0ZW1TaXplPXQsdGhpcy5jb3VudD1lIT09dm9pZCAwP2UubGVuZ3RoL3Q6MCx0aGlzLm5vcm1hbGl6ZWQ9bix0aGlzLnVzYWdlPTM1MDQ0LHRoaXMudXBkYXRlUmFuZ2VzPVtdLHRoaXMuZ3B1VHlwZT0xMDE1LHRoaXMudmVyc2lvbj0wfW9uVXBsb2FkQ2FsbGJhY2soKXt9c2V0IG5lZWRzVXBkYXRlKGUpe2U9PT0hMCYmdGhpcy52ZXJzaW9uKyt9c2V0VXNhZ2UoZSl7cmV0dXJuIHRoaXMudXNhZ2U9ZSx0aGlzfWFkZFVwZGF0ZVJhbmdlKGUsdCl7dGhpcy51cGRhdGVSYW5nZXMucHVzaCh7c3RhcnQ6ZSxjb3VudDp0fSl9Y2xlYXJVcGRhdGVSYW5nZXMoKXt0aGlzLnVwZGF0ZVJhbmdlcy5sZW5ndGg9MH1jb3B5KGUpe3JldHVybiB0aGlzLm5hbWU9ZS5uYW1lLHRoaXMuYXJyYXk9bmV3IGUuYXJyYXkuY29uc3RydWN0b3IoZS5hcnJheSksdGhpcy5pdGVtU2l6ZT1lLml0ZW1TaXplLHRoaXMuY291bnQ9ZS5jb3VudCx0aGlzLm5vcm1hbGl6ZWQ9ZS5ub3JtYWxpemVkLHRoaXMudXNhZ2U9ZS51c2FnZSx0aGlzLmdwdVR5cGU9ZS5ncHVUeXBlLHRoaXN9Y29weUF0KGUsdCxuKXtlKj10aGlzLml0ZW1TaXplLG4qPXQuaXRlbVNpemU7Zm9yKGxldCByPTAscz10aGlzLml0ZW1TaXplO3I8cztyKyspdGhpcy5hcnJheVtlK3JdPXQuYXJyYXlbbityXTtyZXR1cm4gdGhpc31jb3B5QXJyYXkoZSl7cmV0dXJuIHRoaXMuYXJyYXkuc2V0KGUpLHRoaXN9YXBwbHlNYXRyaXgzKGUpe2lmKHRoaXMuaXRlbVNpemU9PT0yKWZvcihsZXQgdD0wLG49dGhpcy5jb3VudDt0PG47dCsrKXBpLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcyx0KSxwaS5hcHBseU1hdHJpeDMoZSksdGhpcy5zZXRYWSh0LHBpLngscGkueSk7ZWxzZSBpZih0aGlzLml0ZW1TaXplPT09Mylmb3IobGV0IHQ9MCxuPXRoaXMuY291bnQ7dDxuO3QrKylvdC5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsdCksb3QuYXBwbHlNYXRyaXgzKGUpLHRoaXMuc2V0WFlaKHQsb3QueCxvdC55LG90LnopO3JldHVybiB0aGlzfWFwcGx5TWF0cml4NChlKXtmb3IobGV0IHQ9MCxuPXRoaXMuY291bnQ7dDxuO3QrKylvdC5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsdCksb3QuYXBwbHlNYXRyaXg0KGUpLHRoaXMuc2V0WFlaKHQsb3QueCxvdC55LG90LnopO3JldHVybiB0aGlzfWFwcGx5Tm9ybWFsTWF0cml4KGUpe2ZvcihsZXQgdD0wLG49dGhpcy5jb3VudDt0PG47dCsrKW90LmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcyx0KSxvdC5hcHBseU5vcm1hbE1hdHJpeChlKSx0aGlzLnNldFhZWih0LG90Lngsb3QueSxvdC56KTtyZXR1cm4gdGhpc310cmFuc2Zvcm1EaXJlY3Rpb24oZSl7Zm9yKGxldCB0PTAsbj10aGlzLmNvdW50O3Q8bjt0Kyspb3QuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLHQpLG90LnRyYW5zZm9ybURpcmVjdGlvbihlKSx0aGlzLnNldFhZWih0LG90Lngsb3QueSxvdC56KTtyZXR1cm4gdGhpc31zZXQoZSx0PTApe3JldHVybiB0aGlzLmFycmF5LnNldChlLHQpLHRoaXN9Z2V0Q29tcG9uZW50KGUsdCl7bGV0IG49dGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrdF07cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKG49RW4obix0aGlzLmFycmF5KSksbn1zZXRDb21wb25lbnQoZSx0LG4pe3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihuPV90KG4sdGhpcy5hcnJheSkpLHRoaXMuYXJyYXlbZSp0aGlzLml0ZW1TaXplK3RdPW4sdGhpc31nZXRYKGUpe2xldCB0PXRoaXMuYXJyYXlbZSp0aGlzLml0ZW1TaXplXTtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYodD1Fbih0LHRoaXMuYXJyYXkpKSx0fXNldFgoZSx0KXtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYodD1fdCh0LHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W2UqdGhpcy5pdGVtU2l6ZV09dCx0aGlzfWdldFkoZSl7bGV0IHQ9dGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrMV07cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9RW4odCx0aGlzLmFycmF5KSksdH1zZXRZKGUsdCl7cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9X3QodCx0aGlzLmFycmF5KSksdGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrMV09dCx0aGlzfWdldFooZSl7bGV0IHQ9dGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrMl07cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9RW4odCx0aGlzLmFycmF5KSksdH1zZXRaKGUsdCl7cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9X3QodCx0aGlzLmFycmF5KSksdGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrMl09dCx0aGlzfWdldFcoZSl7bGV0IHQ9dGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrM107cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9RW4odCx0aGlzLmFycmF5KSksdH1zZXRXKGUsdCl7cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9X3QodCx0aGlzLmFycmF5KSksdGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrM109dCx0aGlzfXNldFhZKGUsdCxuKXtyZXR1cm4gZSo9dGhpcy5pdGVtU2l6ZSx0aGlzLm5vcm1hbGl6ZWQmJih0PV90KHQsdGhpcy5hcnJheSksbj1fdChuLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W2UrMF09dCx0aGlzLmFycmF5W2UrMV09bix0aGlzfXNldFhZWihlLHQsbixyKXtyZXR1cm4gZSo9dGhpcy5pdGVtU2l6ZSx0aGlzLm5vcm1hbGl6ZWQmJih0PV90KHQsdGhpcy5hcnJheSksbj1fdChuLHRoaXMuYXJyYXkpLHI9X3Qocix0aGlzLmFycmF5KSksdGhpcy5hcnJheVtlKzBdPXQsdGhpcy5hcnJheVtlKzFdPW4sdGhpcy5hcnJheVtlKzJdPXIsdGhpc31zZXRYWVpXKGUsdCxuLHIscyl7cmV0dXJuIGUqPXRoaXMuaXRlbVNpemUsdGhpcy5ub3JtYWxpemVkJiYodD1fdCh0LHRoaXMuYXJyYXkpLG49X3Qobix0aGlzLmFycmF5KSxyPV90KHIsdGhpcy5hcnJheSkscz1fdChzLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W2UrMF09dCx0aGlzLmFycmF5W2UrMV09bix0aGlzLmFycmF5W2UrMl09cix0aGlzLmFycmF5W2UrM109cyx0aGlzfW9uVXBsb2FkKGUpe3JldHVybiB0aGlzLm9uVXBsb2FkQ2FsbGJhY2s9ZSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYXJyYXksdGhpcy5pdGVtU2l6ZSkuY29weSh0aGlzKX10b0pTT04oKXtjb25zdCBlPXtpdGVtU2l6ZTp0aGlzLml0ZW1TaXplLHR5cGU6dGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLGFycmF5OkFycmF5LmZyb20odGhpcy5hcnJheSksbm9ybWFsaXplZDp0aGlzLm5vcm1hbGl6ZWR9O3JldHVybiB0aGlzLm5hbWUhPT0iIiYmKGUubmFtZT10aGlzLm5hbWUpLHRoaXMudXNhZ2UhPT0zNTA0NCYmKGUudXNhZ2U9dGhpcy51c2FnZSksZX19Y2xhc3MgVnIgZXh0ZW5kcyBTdHtjb25zdHJ1Y3RvcihlLHQsbil7c3VwZXIobmV3IFVpbnQxNkFycmF5KGUpLHQsbil9fWNsYXNzIGtyIGV4dGVuZHMgU3R7Y29uc3RydWN0b3IoZSx0LG4pe3N1cGVyKG5ldyBVaW50MzJBcnJheShlKSx0LG4pfX1jbGFzcyB1biBleHRlbmRzIFN0e2NvbnN0cnVjdG9yKGUsdCxuKXtzdXBlcihuZXcgRmxvYXQzMkFycmF5KGUpLHQsbil9fWxldCBiYT0wO2NvbnN0IFJ0PW5ldyBzdCx0cj1uZXcgTXQsVW49bmV3IE8sVHQ9bmV3IHFuLEpuPW5ldyBxbixodD1uZXcgTztjbGFzcyBDdCBleHRlbmRzIE1ue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmlzQnVmZmVyR2VvbWV0cnk9ITAsT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImlkIix7dmFsdWU6YmErK30pLHRoaXMudXVpZD1TbigpLHRoaXMubmFtZT0iIix0aGlzLnR5cGU9IkJ1ZmZlckdlb21ldHJ5Iix0aGlzLmluZGV4PW51bGwsdGhpcy5pbmRpcmVjdD1udWxsLHRoaXMuYXR0cmlidXRlcz17fSx0aGlzLm1vcnBoQXR0cmlidXRlcz17fSx0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPSExLHRoaXMuZ3JvdXBzPVtdLHRoaXMuYm91bmRpbmdCb3g9bnVsbCx0aGlzLmJvdW5kaW5nU3BoZXJlPW51bGwsdGhpcy5kcmF3UmFuZ2U9e3N0YXJ0OjAsY291bnQ6MS8wfSx0aGlzLnVzZXJEYXRhPXt9fWdldEluZGV4KCl7cmV0dXJuIHRoaXMuaW5kZXh9c2V0SW5kZXgoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/dGhpcy5pbmRleD1uZXcoU3IoZSk/a3I6VnIpKGUsMSk6dGhpcy5pbmRleD1lLHRoaXN9c2V0SW5kaXJlY3QoZSl7cmV0dXJuIHRoaXMuaW5kaXJlY3Q9ZSx0aGlzfWdldEluZGlyZWN0KCl7cmV0dXJuIHRoaXMuaW5kaXJlY3R9Z2V0QXR0cmlidXRlKGUpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbZV19c2V0QXR0cmlidXRlKGUsdCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlc1tlXT10LHRoaXN9ZGVsZXRlQXR0cmlidXRlKGUpe3JldHVybiBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW2VdLHRoaXN9aGFzQXR0cmlidXRlKGUpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbZV0hPT12b2lkIDB9YWRkR3JvdXAoZSx0LG49MCl7dGhpcy5ncm91cHMucHVzaCh7c3RhcnQ6ZSxjb3VudDp0LG1hdGVyaWFsSW5kZXg6bn0pfWNsZWFyR3JvdXBzKCl7dGhpcy5ncm91cHM9W119c2V0RHJhd1JhbmdlKGUsdCl7dGhpcy5kcmF3UmFuZ2Uuc3RhcnQ9ZSx0aGlzLmRyYXdSYW5nZS5jb3VudD10fWFwcGx5TWF0cml4NChlKXtjb25zdCB0PXRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjt0IT09dm9pZCAwJiYodC5hcHBseU1hdHJpeDQoZSksdC5uZWVkc1VwZGF0ZT0hMCk7Y29uc3Qgbj10aGlzLmF0dHJpYnV0ZXMubm9ybWFsO2lmKG4hPT12b2lkIDApe2NvbnN0IHM9bmV3IGJlKCkuZ2V0Tm9ybWFsTWF0cml4KGUpO24uYXBwbHlOb3JtYWxNYXRyaXgocyksbi5uZWVkc1VwZGF0ZT0hMH1jb25zdCByPXRoaXMuYXR0cmlidXRlcy50YW5nZW50O3JldHVybiByIT09dm9pZCAwJiYoci50cmFuc2Zvcm1EaXJlY3Rpb24oZSksci5uZWVkc1VwZGF0ZT0hMCksdGhpcy5ib3VuZGluZ0JveCE9PW51bGwmJnRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCksdGhpcy5ib3VuZGluZ1NwaGVyZSE9PW51bGwmJnRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksdGhpc31hcHBseVF1YXRlcm5pb24oZSl7cmV0dXJuIFJ0Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKGUpLHRoaXMuYXBwbHlNYXRyaXg0KFJ0KSx0aGlzfXJvdGF0ZVgoZSl7cmV0dXJuIFJ0Lm1ha2VSb3RhdGlvblgoZSksdGhpcy5hcHBseU1hdHJpeDQoUnQpLHRoaXN9cm90YXRlWShlKXtyZXR1cm4gUnQubWFrZVJvdGF0aW9uWShlKSx0aGlzLmFwcGx5TWF0cml4NChSdCksdGhpc31yb3RhdGVaKGUpe3JldHVybiBSdC5tYWtlUm90YXRpb25aKGUpLHRoaXMuYXBwbHlNYXRyaXg0KFJ0KSx0aGlzfXRyYW5zbGF0ZShlLHQsbil7cmV0dXJuIFJ0Lm1ha2VUcmFuc2xhdGlvbihlLHQsbiksdGhpcy5hcHBseU1hdHJpeDQoUnQpLHRoaXN9c2NhbGUoZSx0LG4pe3JldHVybiBSdC5tYWtlU2NhbGUoZSx0LG4pLHRoaXMuYXBwbHlNYXRyaXg0KFJ0KSx0aGlzfWxvb2tBdChlKXtyZXR1cm4gdHIubG9va0F0KGUpLHRyLnVwZGF0ZU1hdHJpeCgpLHRoaXMuYXBwbHlNYXRyaXg0KHRyLm1hdHJpeCksdGhpc31jZW50ZXIoKXtyZXR1cm4gdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKSx0aGlzLmJvdW5kaW5nQm94LmdldENlbnRlcihVbikubmVnYXRlKCksdGhpcy50cmFuc2xhdGUoVW4ueCxVbi55LFVuLnopLHRoaXN9c2V0RnJvbVBvaW50cyhlKXtjb25zdCB0PXRoaXMuZ2V0QXR0cmlidXRlKCJwb3NpdGlvbiIpO2lmKHQ9PT12b2lkIDApe2NvbnN0IG49W107Zm9yKGxldCByPTAscz1lLmxlbmd0aDtyPHM7cisrKXtjb25zdCBhPWVbcl07bi5wdXNoKGEueCxhLnksYS56fHwwKX10aGlzLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyB1bihuLDMpKX1lbHNle2ZvcihsZXQgbj0wLHI9dC5jb3VudDtuPHI7bisrKXtjb25zdCBzPWVbbl07dC5zZXRYWVoobixzLngscy55LHMuenx8MCl9ZS5sZW5ndGg+dC5jb3VudCYmY29uc29sZS53YXJuKCJUSFJFRS5CdWZmZXJHZW9tZXRyeTogQnVmZmVyIHNpemUgdG9vIHNtYWxsIGZvciBwb2ludHMgZGF0YS4gVXNlIC5kaXNwb3NlKCkgYW5kIGNyZWF0ZSBhIG5ldyBnZW9tZXRyeS4iKSx0Lm5lZWRzVXBkYXRlPSEwfXJldHVybiB0aGlzfWNvbXB1dGVCb3VuZGluZ0JveCgpe3RoaXMuYm91bmRpbmdCb3g9PT1udWxsJiYodGhpcy5ib3VuZGluZ0JveD1uZXcgcW4pO2NvbnN0IGU9dGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLHQ9dGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247aWYoZSYmZS5pc0dMQnVmZmVyQXR0cmlidXRlKXtjb25zb2xlLmVycm9yKCJUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTogR0xCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgYSBtYW51YWwgYm91bmRpbmcgYm94LiIsdGhpcyksdGhpcy5ib3VuZGluZ0JveC5zZXQobmV3IE8oLTEvMCwtMS8wLC0xLzApLG5ldyBPKDEvMCwxLzAsMS8wKSk7cmV0dXJufWlmKGUhPT12b2lkIDApe2lmKHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShlKSx0KWZvcihsZXQgbj0wLHI9dC5sZW5ndGg7bjxyO24rKyl7Y29uc3Qgcz10W25dO1R0LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUocyksdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZT8oaHQuYWRkVmVjdG9ycyh0aGlzLmJvdW5kaW5nQm94Lm1pbixUdC5taW4pLHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChodCksaHQuYWRkVmVjdG9ycyh0aGlzLmJvdW5kaW5nQm94Lm1heCxUdC5tYXgpLHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChodCkpOih0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoVHQubWluKSx0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoVHQubWF4KSl9fWVsc2UgdGhpcy5ib3VuZGluZ0JveC5tYWtlRW1wdHkoKTsoaXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueCl8fGlzTmFOKHRoaXMuYm91bmRpbmdCb3gubWluLnkpfHxpc05hTih0aGlzLmJvdW5kaW5nQm94Lm1pbi56KSkmJmNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpOiBDb21wdXRlZCBtaW4vbWF4IGhhdmUgTmFOIHZhbHVlcy4gVGhlICJwb3NpdGlvbiIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJyx0aGlzKX1jb21wdXRlQm91bmRpbmdTcGhlcmUoKXt0aGlzLmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmKHRoaXMuYm91bmRpbmdTcGhlcmU9bmV3IGxpKTtjb25zdCBlPXRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbix0PXRoaXMubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO2lmKGUmJmUuaXNHTEJ1ZmZlckF0dHJpYnV0ZSl7Y29uc29sZS5lcnJvcigiVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IEdMQnVmZmVyQXR0cmlidXRlIHJlcXVpcmVzIGEgbWFudWFsIGJvdW5kaW5nIHNwaGVyZS4iLHRoaXMpLHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0KG5ldyBPLDEvMCk7cmV0dXJufWlmKGUpe2NvbnN0IG49dGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7aWYoVHQuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShlKSx0KWZvcihsZXQgcz0wLGE9dC5sZW5ndGg7czxhO3MrKyl7Y29uc3Qgbz10W3NdO0puLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUobyksdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZT8oaHQuYWRkVmVjdG9ycyhUdC5taW4sSm4ubWluKSxUdC5leHBhbmRCeVBvaW50KGh0KSxodC5hZGRWZWN0b3JzKFR0Lm1heCxKbi5tYXgpLFR0LmV4cGFuZEJ5UG9pbnQoaHQpKTooVHQuZXhwYW5kQnlQb2ludChKbi5taW4pLFR0LmV4cGFuZEJ5UG9pbnQoSm4ubWF4KSl9VHQuZ2V0Q2VudGVyKG4pO2xldCByPTA7Zm9yKGxldCBzPTAsYT1lLmNvdW50O3M8YTtzKyspaHQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHMpLHI9TWF0aC5tYXgocixuLmRpc3RhbmNlVG9TcXVhcmVkKGh0KSk7aWYodClmb3IobGV0IHM9MCxhPXQubGVuZ3RoO3M8YTtzKyspe2NvbnN0IG89dFtzXSxsPXRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7Zm9yKGxldCBjPTAsaD1vLmNvdW50O2M8aDtjKyspaHQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShvLGMpLGwmJihVbi5mcm9tQnVmZmVyQXR0cmlidXRlKGUsYyksaHQuYWRkKFVuKSkscj1NYXRoLm1heChyLG4uZGlzdGFuY2VUb1NxdWFyZWQoaHQpKX10aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cz1NYXRoLnNxcnQociksaXNOYU4odGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMpJiZjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogQ29tcHV0ZWQgcmFkaXVzIGlzIE5hTi4gVGhlICJwb3NpdGlvbiIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJyx0aGlzKX19Y29tcHV0ZVRhbmdlbnRzKCl7Y29uc3QgZT10aGlzLmluZGV4LHQ9dGhpcy5hdHRyaWJ1dGVzO2lmKGU9PT1udWxsfHx0LnBvc2l0aW9uPT09dm9pZCAwfHx0Lm5vcm1hbD09PXZvaWQgMHx8dC51dj09PXZvaWQgMCl7Y29uc29sZS5lcnJvcigiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBmYWlsZWQuIE1pc3NpbmcgcmVxdWlyZWQgYXR0cmlidXRlcyAoaW5kZXgsIHBvc2l0aW9uLCBub3JtYWwgb3IgdXYpIik7cmV0dXJufWNvbnN0IG49dC5wb3NpdGlvbixyPXQubm9ybWFsLHM9dC51djt0aGlzLmhhc0F0dHJpYnV0ZSgidGFuZ2VudCIpPT09ITEmJnRoaXMuc2V0QXR0cmlidXRlKCJ0YW5nZW50IixuZXcgU3QobmV3IEZsb2F0MzJBcnJheSg0Km4uY291bnQpLDQpKTtjb25zdCBhPXRoaXMuZ2V0QXR0cmlidXRlKCJ0YW5nZW50Iiksbz1bXSxsPVtdO2ZvcihsZXQgRj0wO0Y8bi5jb3VudDtGKyspb1tGXT1uZXcgTyxsW0ZdPW5ldyBPO2NvbnN0IGM9bmV3IE8saD1uZXcgTyxkPW5ldyBPLGY9bmV3IFBlLHA9bmV3IFBlLF89bmV3IFBlLHg9bmV3IE8sbT1uZXcgTztmdW5jdGlvbiB1KEYsRSxTKXtjLmZyb21CdWZmZXJBdHRyaWJ1dGUobixGKSxoLmZyb21CdWZmZXJBdHRyaWJ1dGUobixFKSxkLmZyb21CdWZmZXJBdHRyaWJ1dGUobixTKSxmLmZyb21CdWZmZXJBdHRyaWJ1dGUocyxGKSxwLmZyb21CdWZmZXJBdHRyaWJ1dGUocyxFKSxfLmZyb21CdWZmZXJBdHRyaWJ1dGUocyxTKSxoLnN1YihjKSxkLnN1YihjKSxwLnN1YihmKSxfLnN1YihmKTtjb25zdCBSPTEvKHAueCpfLnktXy54KnAueSk7aXNGaW5pdGUoUikmJih4LmNvcHkoaCkubXVsdGlwbHlTY2FsYXIoXy55KS5hZGRTY2FsZWRWZWN0b3IoZCwtcC55KS5tdWx0aXBseVNjYWxhcihSKSxtLmNvcHkoZCkubXVsdGlwbHlTY2FsYXIocC54KS5hZGRTY2FsZWRWZWN0b3IoaCwtXy54KS5tdWx0aXBseVNjYWxhcihSKSxvW0ZdLmFkZCh4KSxvW0VdLmFkZCh4KSxvW1NdLmFkZCh4KSxsW0ZdLmFkZChtKSxsW0VdLmFkZChtKSxsW1NdLmFkZChtKSl9bGV0IFQ9dGhpcy5ncm91cHM7VC5sZW5ndGg9PT0wJiYoVD1be3N0YXJ0OjAsY291bnQ6ZS5jb3VudH1dKTtmb3IobGV0IEY9MCxFPVQubGVuZ3RoO0Y8RTsrK0Ype2NvbnN0IFM9VFtGXSxSPVMuc3RhcnQscT1TLmNvdW50O2ZvcihsZXQgej1SLFc9UitxO3o8Vzt6Kz0zKXUoZS5nZXRYKHorMCksZS5nZXRYKHorMSksZS5nZXRYKHorMikpfWNvbnN0IHk9bmV3IE8sZz1uZXcgTyxQPW5ldyBPLHc9bmV3IE87ZnVuY3Rpb24gYihGKXtQLmZyb21CdWZmZXJBdHRyaWJ1dGUocixGKSx3LmNvcHkoUCk7Y29uc3QgRT1vW0ZdO3kuY29weShFKSx5LnN1YihQLm11bHRpcGx5U2NhbGFyKFAuZG90KEUpKSkubm9ybWFsaXplKCksZy5jcm9zc1ZlY3RvcnModyxFKTtjb25zdCBSPWcuZG90KGxbRl0pPDA/LTE6MTthLnNldFhZWlcoRix5LngseS55LHkueixSKX1mb3IobGV0IEY9MCxFPVQubGVuZ3RoO0Y8RTsrK0Ype2NvbnN0IFM9VFtGXSxSPVMuc3RhcnQscT1TLmNvdW50O2ZvcihsZXQgej1SLFc9UitxO3o8Vzt6Kz0zKWIoZS5nZXRYKHorMCkpLGIoZS5nZXRYKHorMSkpLGIoZS5nZXRYKHorMikpfX1jb21wdXRlVmVydGV4Tm9ybWFscygpe2NvbnN0IGU9dGhpcy5pbmRleCx0PXRoaXMuZ2V0QXR0cmlidXRlKCJwb3NpdGlvbiIpO2lmKHQhPT12b2lkIDApe2xldCBuPXRoaXMuZ2V0QXR0cmlidXRlKCJub3JtYWwiKTtpZihuPT09dm9pZCAwKW49bmV3IFN0KG5ldyBGbG9hdDMyQXJyYXkodC5jb3VudCozKSwzKSx0aGlzLnNldEF0dHJpYnV0ZSgibm9ybWFsIixuKTtlbHNlIGZvcihsZXQgZj0wLHA9bi5jb3VudDtmPHA7ZisrKW4uc2V0WFlaKGYsMCwwLDApO2NvbnN0IHI9bmV3IE8scz1uZXcgTyxhPW5ldyBPLG89bmV3IE8sbD1uZXcgTyxjPW5ldyBPLGg9bmV3IE8sZD1uZXcgTztpZihlKWZvcihsZXQgZj0wLHA9ZS5jb3VudDtmPHA7Zis9Myl7Y29uc3QgXz1lLmdldFgoZiswKSx4PWUuZ2V0WChmKzEpLG09ZS5nZXRYKGYrMik7ci5mcm9tQnVmZmVyQXR0cmlidXRlKHQsXykscy5mcm9tQnVmZmVyQXR0cmlidXRlKHQseCksYS5mcm9tQnVmZmVyQXR0cmlidXRlKHQsbSksaC5zdWJWZWN0b3JzKGEscyksZC5zdWJWZWN0b3JzKHIscyksaC5jcm9zcyhkKSxvLmZyb21CdWZmZXJBdHRyaWJ1dGUobixfKSxsLmZyb21CdWZmZXJBdHRyaWJ1dGUobix4KSxjLmZyb21CdWZmZXJBdHRyaWJ1dGUobixtKSxvLmFkZChoKSxsLmFkZChoKSxjLmFkZChoKSxuLnNldFhZWihfLG8ueCxvLnksby56KSxuLnNldFhZWih4LGwueCxsLnksbC56KSxuLnNldFhZWihtLGMueCxjLnksYy56KX1lbHNlIGZvcihsZXQgZj0wLHA9dC5jb3VudDtmPHA7Zis9MylyLmZyb21CdWZmZXJBdHRyaWJ1dGUodCxmKzApLHMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LGYrMSksYS5mcm9tQnVmZmVyQXR0cmlidXRlKHQsZisyKSxoLnN1YlZlY3RvcnMoYSxzKSxkLnN1YlZlY3RvcnMocixzKSxoLmNyb3NzKGQpLG4uc2V0WFlaKGYrMCxoLngsaC55LGgueiksbi5zZXRYWVooZisxLGgueCxoLnksaC56KSxuLnNldFhZWihmKzIsaC54LGgueSxoLnopO3RoaXMubm9ybWFsaXplTm9ybWFscygpLG4ubmVlZHNVcGRhdGU9ITB9fW5vcm1hbGl6ZU5vcm1hbHMoKXtjb25zdCBlPXRoaXMuYXR0cmlidXRlcy5ub3JtYWw7Zm9yKGxldCB0PTAsbj1lLmNvdW50O3Q8bjt0KyspaHQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHQpLGh0Lm5vcm1hbGl6ZSgpLGUuc2V0WFlaKHQsaHQueCxodC55LGh0LnopfXRvTm9uSW5kZXhlZCgpe2Z1bmN0aW9uIGUobyxsKXtjb25zdCBjPW8uYXJyYXksaD1vLml0ZW1TaXplLGQ9by5ub3JtYWxpemVkLGY9bmV3IGMuY29uc3RydWN0b3IobC5sZW5ndGgqaCk7bGV0IHA9MCxfPTA7Zm9yKGxldCB4PTAsbT1sLmxlbmd0aDt4PG07eCsrKXtvLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU/cD1sW3hdKm8uZGF0YS5zdHJpZGUrby5vZmZzZXQ6cD1sW3hdKmg7Zm9yKGxldCB1PTA7dTxoO3UrKylmW18rK109Y1twKytdfXJldHVybiBuZXcgU3QoZixoLGQpfWlmKHRoaXMuaW5kZXg9PT1udWxsKXJldHVybiBjb25zb2xlLndhcm4oIlRIUkVFLkJ1ZmZlckdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpOiBCdWZmZXJHZW9tZXRyeSBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLiIpLHRoaXM7Y29uc3QgdD1uZXcgQ3Qsbj10aGlzLmluZGV4LmFycmF5LHI9dGhpcy5hdHRyaWJ1dGVzO2Zvcihjb25zdCBvIGluIHIpe2NvbnN0IGw9cltvXSxjPWUobCxuKTt0LnNldEF0dHJpYnV0ZShvLGMpfWNvbnN0IHM9dGhpcy5tb3JwaEF0dHJpYnV0ZXM7Zm9yKGNvbnN0IG8gaW4gcyl7Y29uc3QgbD1bXSxjPXNbb107Zm9yKGxldCBoPTAsZD1jLmxlbmd0aDtoPGQ7aCsrKXtjb25zdCBmPWNbaF0scD1lKGYsbik7bC5wdXNoKHApfXQubW9ycGhBdHRyaWJ1dGVzW29dPWx9dC5tb3JwaFRhcmdldHNSZWxhdGl2ZT10aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO2NvbnN0IGE9dGhpcy5ncm91cHM7Zm9yKGxldCBvPTAsbD1hLmxlbmd0aDtvPGw7bysrKXtjb25zdCBjPWFbb107dC5hZGRHcm91cChjLnN0YXJ0LGMuY291bnQsYy5tYXRlcmlhbEluZGV4KX1yZXR1cm4gdH10b0pTT04oKXtjb25zdCBlPXttZXRhZGF0YTp7dmVyc2lvbjo0LjYsdHlwZToiQnVmZmVyR2VvbWV0cnkiLGdlbmVyYXRvcjoiQnVmZmVyR2VvbWV0cnkudG9KU09OIn19O2lmKGUudXVpZD10aGlzLnV1aWQsZS50eXBlPXRoaXMudHlwZSx0aGlzLm5hbWUhPT0iIiYmKGUubmFtZT10aGlzLm5hbWUpLE9iamVjdC5rZXlzKHRoaXMudXNlckRhdGEpLmxlbmd0aD4wJiYoZS51c2VyRGF0YT10aGlzLnVzZXJEYXRhKSx0aGlzLnBhcmFtZXRlcnMhPT12b2lkIDApe2NvbnN0IGw9dGhpcy5wYXJhbWV0ZXJzO2Zvcihjb25zdCBjIGluIGwpbFtjXSE9PXZvaWQgMCYmKGVbY109bFtjXSk7cmV0dXJuIGV9ZS5kYXRhPXthdHRyaWJ1dGVzOnt9fTtjb25zdCB0PXRoaXMuaW5kZXg7dCE9PW51bGwmJihlLmRhdGEuaW5kZXg9e3R5cGU6dC5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLGFycmF5OkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQuYXJyYXkpfSk7Y29uc3Qgbj10aGlzLmF0dHJpYnV0ZXM7Zm9yKGNvbnN0IGwgaW4gbil7Y29uc3QgYz1uW2xdO2UuZGF0YS5hdHRyaWJ1dGVzW2xdPWMudG9KU09OKGUuZGF0YSl9Y29uc3Qgcj17fTtsZXQgcz0hMTtmb3IoY29uc3QgbCBpbiB0aGlzLm1vcnBoQXR0cmlidXRlcyl7Y29uc3QgYz10aGlzLm1vcnBoQXR0cmlidXRlc1tsXSxoPVtdO2ZvcihsZXQgZD0wLGY9Yy5sZW5ndGg7ZDxmO2QrKyl7Y29uc3QgcD1jW2RdO2gucHVzaChwLnRvSlNPTihlLmRhdGEpKX1oLmxlbmd0aD4wJiYocltsXT1oLHM9ITApfXMmJihlLmRhdGEubW9ycGhBdHRyaWJ1dGVzPXIsZS5kYXRhLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPXRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUpO2NvbnN0IGE9dGhpcy5ncm91cHM7YS5sZW5ndGg+MCYmKGUuZGF0YS5ncm91cHM9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhKSkpO2NvbnN0IG89dGhpcy5ib3VuZGluZ1NwaGVyZTtyZXR1cm4gbyE9PW51bGwmJihlLmRhdGEuYm91bmRpbmdTcGhlcmU9e2NlbnRlcjpvLmNlbnRlci50b0FycmF5KCkscmFkaXVzOm8ucmFkaXVzfSksZX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9Y29weShlKXt0aGlzLmluZGV4PW51bGwsdGhpcy5hdHRyaWJ1dGVzPXt9LHRoaXMubW9ycGhBdHRyaWJ1dGVzPXt9LHRoaXMuZ3JvdXBzPVtdLHRoaXMuYm91bmRpbmdCb3g9bnVsbCx0aGlzLmJvdW5kaW5nU3BoZXJlPW51bGw7Y29uc3QgdD17fTt0aGlzLm5hbWU9ZS5uYW1lO2NvbnN0IG49ZS5pbmRleDtuIT09bnVsbCYmdGhpcy5zZXRJbmRleChuLmNsb25lKHQpKTtjb25zdCByPWUuYXR0cmlidXRlcztmb3IoY29uc3QgYyBpbiByKXtjb25zdCBoPXJbY107dGhpcy5zZXRBdHRyaWJ1dGUoYyxoLmNsb25lKHQpKX1jb25zdCBzPWUubW9ycGhBdHRyaWJ1dGVzO2Zvcihjb25zdCBjIGluIHMpe2NvbnN0IGg9W10sZD1zW2NdO2ZvcihsZXQgZj0wLHA9ZC5sZW5ndGg7ZjxwO2YrKyloLnB1c2goZFtmXS5jbG9uZSh0KSk7dGhpcy5tb3JwaEF0dHJpYnV0ZXNbY109aH10aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPWUubW9ycGhUYXJnZXRzUmVsYXRpdmU7Y29uc3QgYT1lLmdyb3Vwcztmb3IobGV0IGM9MCxoPWEubGVuZ3RoO2M8aDtjKyspe2NvbnN0IGQ9YVtjXTt0aGlzLmFkZEdyb3VwKGQuc3RhcnQsZC5jb3VudCxkLm1hdGVyaWFsSW5kZXgpfWNvbnN0IG89ZS5ib3VuZGluZ0JveDtvIT09bnVsbCYmKHRoaXMuYm91bmRpbmdCb3g9by5jbG9uZSgpKTtjb25zdCBsPWUuYm91bmRpbmdTcGhlcmU7cmV0dXJuIGwhPT1udWxsJiYodGhpcy5ib3VuZGluZ1NwaGVyZT1sLmNsb25lKCkpLHRoaXMuZHJhd1JhbmdlLnN0YXJ0PWUuZHJhd1JhbmdlLnN0YXJ0LHRoaXMuZHJhd1JhbmdlLmNvdW50PWUuZHJhd1JhbmdlLmNvdW50LHRoaXMudXNlckRhdGE9ZS51c2VyRGF0YSx0aGlzfWRpc3Bvc2UoKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImRpc3Bvc2UifSl9fWNvbnN0IFdyPW5ldyBzdCxobj1uZXcgRHIsbWk9bmV3IGxpLFhyPW5ldyBPLGdpPW5ldyBPLF9pPW5ldyBPLHZpPW5ldyBPLG5yPW5ldyBPLHhpPW5ldyBPLHFyPW5ldyBPLE1pPW5ldyBPO2NsYXNzIHR0IGV4dGVuZHMgTXR7Y29uc3RydWN0b3IoZT1uZXcgQ3QsdD1uZXcgam4pe3N1cGVyKCksdGhpcy5pc01lc2g9ITAsdGhpcy50eXBlPSJNZXNoIix0aGlzLmdlb21ldHJ5PWUsdGhpcy5tYXRlcmlhbD10LHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCl9Y29weShlLHQpe3JldHVybiBzdXBlci5jb3B5KGUsdCksZS5tb3JwaFRhcmdldEluZmx1ZW5jZXMhPT12b2lkIDAmJih0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcz1lLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5zbGljZSgpKSxlLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSE9PXZvaWQgMCYmKHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5PU9iamVjdC5hc3NpZ24oe30sZS5tb3JwaFRhcmdldERpY3Rpb25hcnkpKSx0aGlzLm1hdGVyaWFsPUFycmF5LmlzQXJyYXkoZS5tYXRlcmlhbCk/ZS5tYXRlcmlhbC5zbGljZSgpOmUubWF0ZXJpYWwsdGhpcy5nZW9tZXRyeT1lLmdlb21ldHJ5LHRoaXN9dXBkYXRlTW9ycGhUYXJnZXRzKCl7Y29uc3QgdD10aGlzLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyxuPU9iamVjdC5rZXlzKHQpO2lmKG4ubGVuZ3RoPjApe2NvbnN0IHI9dFtuWzBdXTtpZihyIT09dm9pZCAwKXt0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcz1bXSx0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeT17fTtmb3IobGV0IHM9MCxhPXIubGVuZ3RoO3M8YTtzKyspe2NvbnN0IG89cltzXS5uYW1lfHxTdHJpbmcocyk7dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCgwKSx0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVtvXT1zfX19fWdldFZlcnRleFBvc2l0aW9uKGUsdCl7Y29uc3Qgbj10aGlzLmdlb21ldHJ5LHI9bi5hdHRyaWJ1dGVzLnBvc2l0aW9uLHM9bi5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24sYT1uLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO3QuZnJvbUJ1ZmZlckF0dHJpYnV0ZShyLGUpO2NvbnN0IG89dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7aWYocyYmbyl7eGkuc2V0KDAsMCwwKTtmb3IobGV0IGw9MCxjPXMubGVuZ3RoO2w8YztsKyspe2NvbnN0IGg9b1tsXSxkPXNbbF07aCE9PTAmJihuci5mcm9tQnVmZmVyQXR0cmlidXRlKGQsZSksYT94aS5hZGRTY2FsZWRWZWN0b3IobnIsaCk6eGkuYWRkU2NhbGVkVmVjdG9yKG5yLnN1Yih0KSxoKSl9dC5hZGQoeGkpfXJldHVybiB0fXJheWNhc3QoZSx0KXtjb25zdCBuPXRoaXMuZ2VvbWV0cnkscj10aGlzLm1hdGVyaWFsLHM9dGhpcy5tYXRyaXhXb3JsZDtyIT09dm9pZCAwJiYobi5ib3VuZGluZ1NwaGVyZT09PW51bGwmJm4uY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksbWkuY29weShuLmJvdW5kaW5nU3BoZXJlKSxtaS5hcHBseU1hdHJpeDQocyksaG4uY29weShlLnJheSkucmVjYXN0KGUubmVhciksIShtaS5jb250YWluc1BvaW50KGhuLm9yaWdpbik9PT0hMSYmKGhuLmludGVyc2VjdFNwaGVyZShtaSxYcik9PT1udWxsfHxobi5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQoWHIpPihlLmZhci1lLm5lYXIpKioyKSkmJihXci5jb3B5KHMpLmludmVydCgpLGhuLmNvcHkoZS5yYXkpLmFwcGx5TWF0cml4NChXciksIShuLmJvdW5kaW5nQm94IT09bnVsbCYmaG4uaW50ZXJzZWN0c0JveChuLmJvdW5kaW5nQm94KT09PSExKSYmdGhpcy5fY29tcHV0ZUludGVyc2VjdGlvbnMoZSx0LGhuKSkpfV9jb21wdXRlSW50ZXJzZWN0aW9ucyhlLHQsbil7bGV0IHI7Y29uc3Qgcz10aGlzLmdlb21ldHJ5LGE9dGhpcy5tYXRlcmlhbCxvPXMuaW5kZXgsbD1zLmF0dHJpYnV0ZXMucG9zaXRpb24sYz1zLmF0dHJpYnV0ZXMudXYsaD1zLmF0dHJpYnV0ZXMudXYxLGQ9cy5hdHRyaWJ1dGVzLm5vcm1hbCxmPXMuZ3JvdXBzLHA9cy5kcmF3UmFuZ2U7aWYobyE9PW51bGwpaWYoQXJyYXkuaXNBcnJheShhKSlmb3IobGV0IF89MCx4PWYubGVuZ3RoO188eDtfKyspe2NvbnN0IG09ZltfXSx1PWFbbS5tYXRlcmlhbEluZGV4XSxUPU1hdGgubWF4KG0uc3RhcnQscC5zdGFydCkseT1NYXRoLm1pbihvLmNvdW50LE1hdGgubWluKG0uc3RhcnQrbS5jb3VudCxwLnN0YXJ0K3AuY291bnQpKTtmb3IobGV0IGc9VCxQPXk7ZzxQO2crPTMpe2NvbnN0IHc9by5nZXRYKGcpLGI9by5nZXRYKGcrMSksRj1vLmdldFgoZysyKTtyPVNpKHRoaXMsdSxlLG4sYyxoLGQsdyxiLEYpLHImJihyLmZhY2VJbmRleD1NYXRoLmZsb29yKGcvMyksci5mYWNlLm1hdGVyaWFsSW5kZXg9bS5tYXRlcmlhbEluZGV4LHQucHVzaChyKSl9fWVsc2V7Y29uc3QgXz1NYXRoLm1heCgwLHAuc3RhcnQpLHg9TWF0aC5taW4oby5jb3VudCxwLnN0YXJ0K3AuY291bnQpO2ZvcihsZXQgbT1fLHU9eDttPHU7bSs9Myl7Y29uc3QgVD1vLmdldFgobSkseT1vLmdldFgobSsxKSxnPW8uZ2V0WChtKzIpO3I9U2kodGhpcyxhLGUsbixjLGgsZCxULHksZyksciYmKHIuZmFjZUluZGV4PU1hdGguZmxvb3IobS8zKSx0LnB1c2gocikpfX1lbHNlIGlmKGwhPT12b2lkIDApaWYoQXJyYXkuaXNBcnJheShhKSlmb3IobGV0IF89MCx4PWYubGVuZ3RoO188eDtfKyspe2NvbnN0IG09ZltfXSx1PWFbbS5tYXRlcmlhbEluZGV4XSxUPU1hdGgubWF4KG0uc3RhcnQscC5zdGFydCkseT1NYXRoLm1pbihsLmNvdW50LE1hdGgubWluKG0uc3RhcnQrbS5jb3VudCxwLnN0YXJ0K3AuY291bnQpKTtmb3IobGV0IGc9VCxQPXk7ZzxQO2crPTMpe2NvbnN0IHc9ZyxiPWcrMSxGPWcrMjtyPVNpKHRoaXMsdSxlLG4sYyxoLGQsdyxiLEYpLHImJihyLmZhY2VJbmRleD1NYXRoLmZsb29yKGcvMyksci5mYWNlLm1hdGVyaWFsSW5kZXg9bS5tYXRlcmlhbEluZGV4LHQucHVzaChyKSl9fWVsc2V7Y29uc3QgXz1NYXRoLm1heCgwLHAuc3RhcnQpLHg9TWF0aC5taW4obC5jb3VudCxwLnN0YXJ0K3AuY291bnQpO2ZvcihsZXQgbT1fLHU9eDttPHU7bSs9Myl7Y29uc3QgVD1tLHk9bSsxLGc9bSsyO3I9U2kodGhpcyxhLGUsbixjLGgsZCxULHksZyksciYmKHIuZmFjZUluZGV4PU1hdGguZmxvb3IobS8zKSx0LnB1c2gocikpfX19fWZ1bmN0aW9uIFJhKGksZSx0LG4scixzLGEsbyl7bGV0IGw7aWYoZS5zaWRlPT09MT9sPW4uaW50ZXJzZWN0VHJpYW5nbGUoYSxzLHIsITAsbyk6bD1uLmludGVyc2VjdFRyaWFuZ2xlKHIscyxhLGUuc2lkZT09PTAsbyksbD09PW51bGwpcmV0dXJuIG51bGw7TWkuY29weShvKSxNaS5hcHBseU1hdHJpeDQoaS5tYXRyaXhXb3JsZCk7Y29uc3QgYz10LnJheS5vcmlnaW4uZGlzdGFuY2VUbyhNaSk7cmV0dXJuIGM8dC5uZWFyfHxjPnQuZmFyP251bGw6e2Rpc3RhbmNlOmMscG9pbnQ6TWkuY2xvbmUoKSxvYmplY3Q6aX19ZnVuY3Rpb24gU2koaSxlLHQsbixyLHMsYSxvLGwsYyl7aS5nZXRWZXJ0ZXhQb3NpdGlvbihvLGdpKSxpLmdldFZlcnRleFBvc2l0aW9uKGwsX2kpLGkuZ2V0VmVydGV4UG9zaXRpb24oYyx2aSk7Y29uc3QgaD1SYShpLGUsdCxuLGdpLF9pLHZpLHFyKTtpZihoKXtjb25zdCBkPW5ldyBPO0l0LmdldEJhcnljb29yZChxcixnaSxfaSx2aSxkKSxyJiYoaC51dj1JdC5nZXRJbnRlcnBvbGF0ZWRBdHRyaWJ1dGUocixvLGwsYyxkLG5ldyBQZSkpLHMmJihoLnV2MT1JdC5nZXRJbnRlcnBvbGF0ZWRBdHRyaWJ1dGUocyxvLGwsYyxkLG5ldyBQZSkpLGEmJihoLm5vcm1hbD1JdC5nZXRJbnRlcnBvbGF0ZWRBdHRyaWJ1dGUoYSxvLGwsYyxkLG5ldyBPKSxoLm5vcm1hbC5kb3Qobi5kaXJlY3Rpb24pPjAmJmgubm9ybWFsLm11bHRpcGx5U2NhbGFyKC0xKSk7Y29uc3QgZj17YTpvLGI6bCxjLG5vcm1hbDpuZXcgTyxtYXRlcmlhbEluZGV4OjB9O0l0LmdldE5vcm1hbChnaSxfaSx2aSxmLm5vcm1hbCksaC5mYWNlPWYsaC5iYXJ5Y29vcmQ9ZH1yZXR1cm4gaH1jbGFzcyBRbiBleHRlbmRzIEN0e2NvbnN0cnVjdG9yKGU9MSx0PTEsbj0xLHI9MSxzPTEsYT0xKXtzdXBlcigpLHRoaXMudHlwZT0iQm94R2VvbWV0cnkiLHRoaXMucGFyYW1ldGVycz17d2lkdGg6ZSxoZWlnaHQ6dCxkZXB0aDpuLHdpZHRoU2VnbWVudHM6cixoZWlnaHRTZWdtZW50czpzLGRlcHRoU2VnbWVudHM6YX07Y29uc3Qgbz10aGlzO3I9TWF0aC5mbG9vcihyKSxzPU1hdGguZmxvb3IocyksYT1NYXRoLmZsb29yKGEpO2NvbnN0IGw9W10sYz1bXSxoPVtdLGQ9W107bGV0IGY9MCxwPTA7XygieiIsInkiLCJ4IiwtMSwtMSxuLHQsZSxhLHMsMCksXygieiIsInkiLCJ4IiwxLC0xLG4sdCwtZSxhLHMsMSksXygieCIsInoiLCJ5IiwxLDEsZSxuLHQscixhLDIpLF8oIngiLCJ6IiwieSIsMSwtMSxlLG4sLXQscixhLDMpLF8oIngiLCJ5IiwieiIsMSwtMSxlLHQsbixyLHMsNCksXygieCIsInkiLCJ6IiwtMSwtMSxlLHQsLW4scixzLDUpLHRoaXMuc2V0SW5kZXgobCksdGhpcy5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgdW4oYywzKSksdGhpcy5zZXRBdHRyaWJ1dGUoIm5vcm1hbCIsbmV3IHVuKGgsMykpLHRoaXMuc2V0QXR0cmlidXRlKCJ1diIsbmV3IHVuKGQsMikpO2Z1bmN0aW9uIF8oeCxtLHUsVCx5LGcsUCx3LGIsRixFKXtjb25zdCBTPWcvYixSPVAvRixxPWcvMix6PVAvMixXPXcvMixaPWIrMSxWPUYrMTtsZXQgUT0wLEg9MDtjb25zdCBpZT1uZXcgTztmb3IobGV0IGNlPTA7Y2U8VjtjZSsrKXtjb25zdCB4ZT1jZSpSLXo7Zm9yKGxldCBVZT0wO1VlPFo7VWUrKyl7Y29uc3QgWWU9VWUqUy1xO2llW3hdPVllKlQsaWVbbV09eGUqeSxpZVt1XT1XLGMucHVzaChpZS54LGllLnksaWUueiksaWVbeF09MCxpZVttXT0wLGllW3VdPXc+MD8xOi0xLGgucHVzaChpZS54LGllLnksaWUueiksZC5wdXNoKFVlL2IpLGQucHVzaCgxLWNlL0YpLFErPTF9fWZvcihsZXQgY2U9MDtjZTxGO2NlKyspZm9yKGxldCB4ZT0wO3hlPGI7eGUrKyl7Y29uc3QgVWU9Zit4ZStaKmNlLFllPWYreGUrWiooY2UrMSksWD1mKyh4ZSsxKStaKihjZSsxKSxlZT1mKyh4ZSsxKStaKmNlO2wucHVzaChVZSxZZSxlZSksbC5wdXNoKFllLFgsZWUpLEgrPTZ9by5hZGRHcm91cChwLEgsRSkscCs9SCxmKz1RfX1jb3B5KGUpe3JldHVybiBzdXBlci5jb3B5KGUpLHRoaXMucGFyYW1ldGVycz1PYmplY3QuYXNzaWduKHt9LGUucGFyYW1ldGVycyksdGhpc31zdGF0aWMgZnJvbUpTT04oZSl7cmV0dXJuIG5ldyBRbihlLndpZHRoLGUuaGVpZ2h0LGUuZGVwdGgsZS53aWR0aFNlZ21lbnRzLGUuaGVpZ2h0U2VnbWVudHMsZS5kZXB0aFNlZ21lbnRzKX19ZnVuY3Rpb24gRm4oaSl7Y29uc3QgZT17fTtmb3IoY29uc3QgdCBpbiBpKXtlW3RdPXt9O2Zvcihjb25zdCBuIGluIGlbdF0pe2NvbnN0IHI9aVt0XVtuXTtyJiYoci5pc0NvbG9yfHxyLmlzTWF0cml4M3x8ci5pc01hdHJpeDR8fHIuaXNWZWN0b3IyfHxyLmlzVmVjdG9yM3x8ci5pc1ZlY3RvcjR8fHIuaXNUZXh0dXJlfHxyLmlzUXVhdGVybmlvbik/ci5pc1JlbmRlclRhcmdldFRleHR1cmU/KGNvbnNvbGUud2FybigiVW5pZm9ybXNVdGlsczogVGV4dHVyZXMgb2YgcmVuZGVyIHRhcmdldHMgY2Fubm90IGJlIGNsb25lZCB2aWEgY2xvbmVVbmlmb3JtcygpIG9yIG1lcmdlVW5pZm9ybXMoKS4iKSxlW3RdW25dPW51bGwpOmVbdF1bbl09ci5jbG9uZSgpOkFycmF5LmlzQXJyYXkocik/ZVt0XVtuXT1yLnNsaWNlKCk6ZVt0XVtuXT1yfX1yZXR1cm4gZX1mdW5jdGlvbiB4dChpKXtjb25zdCBlPXt9O2ZvcihsZXQgdD0wO3Q8aS5sZW5ndGg7dCsrKXtjb25zdCBuPUZuKGlbdF0pO2Zvcihjb25zdCByIGluIG4pZVtyXT1uW3JdfXJldHVybiBlfWZ1bmN0aW9uIENhKGkpe2NvbnN0IGU9W107Zm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0KyspZS5wdXNoKGlbdF0uY2xvbmUoKSk7cmV0dXJuIGV9ZnVuY3Rpb24gWXIoaSl7Y29uc3QgZT1pLmdldFJlbmRlclRhcmdldCgpO3JldHVybiBlPT09bnVsbD9pLm91dHB1dENvbG9yU3BhY2U6ZS5pc1hSUmVuZGVyVGFyZ2V0PT09ITA/ZS50ZXh0dXJlLmNvbG9yU3BhY2U6QmUud29ya2luZ0NvbG9yU3BhY2V9Y29uc3QgUGE9e2Nsb25lOkZuLG1lcmdlOnh0fTt2YXIgRGE9YHZvaWQgbWFpbigpIHsKCWdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTsKfWAsTGE9YHZvaWQgbWFpbigpIHsKCWdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApOwp9YDtjbGFzcyBsdCBleHRlbmRzIFpue3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJTaGFkZXJNYXRlcmlhbCJ9Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLmlzU2hhZGVyTWF0ZXJpYWw9ITAsdGhpcy5kZWZpbmVzPXt9LHRoaXMudW5pZm9ybXM9e30sdGhpcy51bmlmb3Jtc0dyb3Vwcz1bXSx0aGlzLnZlcnRleFNoYWRlcj1EYSx0aGlzLmZyYWdtZW50U2hhZGVyPUxhLHRoaXMubGluZXdpZHRoPTEsdGhpcy53aXJlZnJhbWU9ITEsdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9MSx0aGlzLmZvZz0hMSx0aGlzLmxpZ2h0cz0hMSx0aGlzLmNsaXBwaW5nPSExLHRoaXMuZm9yY2VTaW5nbGVQYXNzPSEwLHRoaXMuZXh0ZW5zaW9ucz17Y2xpcEN1bGxEaXN0YW5jZTohMSxtdWx0aURyYXc6ITF9LHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcz17Y29sb3I6WzEsMSwxXSx1djpbMCwwXSx1djE6WzAsMF19LHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZT12b2lkIDAsdGhpcy51bmlmb3Jtc05lZWRVcGRhdGU9ITEsdGhpcy5nbHNsVmVyc2lvbj1udWxsLGUhPT12b2lkIDAmJnRoaXMuc2V0VmFsdWVzKGUpfWNvcHkoZSl7cmV0dXJuIHN1cGVyLmNvcHkoZSksdGhpcy5mcmFnbWVudFNoYWRlcj1lLmZyYWdtZW50U2hhZGVyLHRoaXMudmVydGV4U2hhZGVyPWUudmVydGV4U2hhZGVyLHRoaXMudW5pZm9ybXM9Rm4oZS51bmlmb3JtcyksdGhpcy51bmlmb3Jtc0dyb3Vwcz1DYShlLnVuaWZvcm1zR3JvdXBzKSx0aGlzLmRlZmluZXM9T2JqZWN0LmFzc2lnbih7fSxlLmRlZmluZXMpLHRoaXMud2lyZWZyYW1lPWUud2lyZWZyYW1lLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPWUud2lyZWZyYW1lTGluZXdpZHRoLHRoaXMuZm9nPWUuZm9nLHRoaXMubGlnaHRzPWUubGlnaHRzLHRoaXMuY2xpcHBpbmc9ZS5jbGlwcGluZyx0aGlzLmV4dGVuc2lvbnM9T2JqZWN0LmFzc2lnbih7fSxlLmV4dGVuc2lvbnMpLHRoaXMuZ2xzbFZlcnNpb249ZS5nbHNsVmVyc2lvbix0aGlzfXRvSlNPTihlKXtjb25zdCB0PXN1cGVyLnRvSlNPTihlKTt0Lmdsc2xWZXJzaW9uPXRoaXMuZ2xzbFZlcnNpb24sdC51bmlmb3Jtcz17fTtmb3IoY29uc3QgciBpbiB0aGlzLnVuaWZvcm1zKXtjb25zdCBhPXRoaXMudW5pZm9ybXNbcl0udmFsdWU7YSYmYS5pc1RleHR1cmU/dC51bmlmb3Jtc1tyXT17dHlwZToidCIsdmFsdWU6YS50b0pTT04oZSkudXVpZH06YSYmYS5pc0NvbG9yP3QudW5pZm9ybXNbcl09e3R5cGU6ImMiLHZhbHVlOmEuZ2V0SGV4KCl9OmEmJmEuaXNWZWN0b3IyP3QudW5pZm9ybXNbcl09e3R5cGU6InYyIix2YWx1ZTphLnRvQXJyYXkoKX06YSYmYS5pc1ZlY3RvcjM/dC51bmlmb3Jtc1tyXT17dHlwZToidjMiLHZhbHVlOmEudG9BcnJheSgpfTphJiZhLmlzVmVjdG9yND90LnVuaWZvcm1zW3JdPXt0eXBlOiJ2NCIsdmFsdWU6YS50b0FycmF5KCl9OmEmJmEuaXNNYXRyaXgzP3QudW5pZm9ybXNbcl09e3R5cGU6Im0zIix2YWx1ZTphLnRvQXJyYXkoKX06YSYmYS5pc01hdHJpeDQ/dC51bmlmb3Jtc1tyXT17dHlwZToibTQiLHZhbHVlOmEudG9BcnJheSgpfTp0LnVuaWZvcm1zW3JdPXt2YWx1ZTphfX1PYmplY3Qua2V5cyh0aGlzLmRlZmluZXMpLmxlbmd0aD4wJiYodC5kZWZpbmVzPXRoaXMuZGVmaW5lcyksdC52ZXJ0ZXhTaGFkZXI9dGhpcy52ZXJ0ZXhTaGFkZXIsdC5mcmFnbWVudFNoYWRlcj10aGlzLmZyYWdtZW50U2hhZGVyLHQubGlnaHRzPXRoaXMubGlnaHRzLHQuY2xpcHBpbmc9dGhpcy5jbGlwcGluZztjb25zdCBuPXt9O2Zvcihjb25zdCByIGluIHRoaXMuZXh0ZW5zaW9ucyl0aGlzLmV4dGVuc2lvbnNbcl09PT0hMCYmKG5bcl09ITApO3JldHVybiBPYmplY3Qua2V5cyhuKS5sZW5ndGg+MCYmKHQuZXh0ZW5zaW9ucz1uKSx0fX1jbGFzcyAkciBleHRlbmRzIE10e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmlzQ2FtZXJhPSEwLHRoaXMudHlwZT0iQ2FtZXJhIix0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZT1uZXcgc3QsdGhpcy5wcm9qZWN0aW9uTWF0cml4PW5ldyBzdCx0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlPW5ldyBzdCx0aGlzLmNvb3JkaW5hdGVTeXN0ZW09MmUzfWNvcHkoZSx0KXtyZXR1cm4gc3VwZXIuY29weShlLHQpLHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoZS5tYXRyaXhXb3JsZEludmVyc2UpLHRoaXMucHJvamVjdGlvbk1hdHJpeC5jb3B5KGUucHJvamVjdGlvbk1hdHJpeCksdGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KGUucHJvamVjdGlvbk1hdHJpeEludmVyc2UpLHRoaXMuY29vcmRpbmF0ZVN5c3RlbT1lLmNvb3JkaW5hdGVTeXN0ZW0sdGhpc31nZXRXb3JsZERpcmVjdGlvbihlKXtyZXR1cm4gc3VwZXIuZ2V0V29ybGREaXJlY3Rpb24oZSkubmVnYXRlKCl9dXBkYXRlTWF0cml4V29ybGQoZSl7c3VwZXIudXBkYXRlTWF0cml4V29ybGQoZSksdGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKX11cGRhdGVXb3JsZE1hdHJpeChlLHQpe3N1cGVyLnVwZGF0ZVdvcmxkTWF0cml4KGUsdCksdGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9fWNvbnN0IHNuPW5ldyBPLEtyPW5ldyBQZSxacj1uZXcgUGU7Y2xhc3MgTnQgZXh0ZW5kcyAkcntjb25zdHJ1Y3RvcihlPTUwLHQ9MSxuPS4xLHI9MmUzKXtzdXBlcigpLHRoaXMuaXNQZXJzcGVjdGl2ZUNhbWVyYT0hMCx0aGlzLnR5cGU9IlBlcnNwZWN0aXZlQ2FtZXJhIix0aGlzLmZvdj1lLHRoaXMuem9vbT0xLHRoaXMubmVhcj1uLHRoaXMuZmFyPXIsdGhpcy5mb2N1cz0xMCx0aGlzLmFzcGVjdD10LHRoaXMudmlldz1udWxsLHRoaXMuZmlsbUdhdWdlPTM1LHRoaXMuZmlsbU9mZnNldD0wLHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfWNvcHkoZSx0KXtyZXR1cm4gc3VwZXIuY29weShlLHQpLHRoaXMuZm92PWUuZm92LHRoaXMuem9vbT1lLnpvb20sdGhpcy5uZWFyPWUubmVhcix0aGlzLmZhcj1lLmZhcix0aGlzLmZvY3VzPWUuZm9jdXMsdGhpcy5hc3BlY3Q9ZS5hc3BlY3QsdGhpcy52aWV3PWUudmlldz09PW51bGw/bnVsbDpPYmplY3QuYXNzaWduKHt9LGUudmlldyksdGhpcy5maWxtR2F1Z2U9ZS5maWxtR2F1Z2UsdGhpcy5maWxtT2Zmc2V0PWUuZmlsbU9mZnNldCx0aGlzfXNldEZvY2FsTGVuZ3RoKGUpe2NvbnN0IHQ9LjUqdGhpcy5nZXRGaWxtSGVpZ2h0KCkvZTt0aGlzLmZvdj1WbioyKk1hdGguYXRhbih0KSx0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX1nZXRGb2NhbExlbmd0aCgpe2NvbnN0IGU9TWF0aC50YW4oSG4qLjUqdGhpcy5mb3YpO3JldHVybiAuNSp0aGlzLmdldEZpbG1IZWlnaHQoKS9lfWdldEVmZmVjdGl2ZUZPVigpe3JldHVybiBWbioyKk1hdGguYXRhbihNYXRoLnRhbihIbiouNSp0aGlzLmZvdikvdGhpcy56b29tKX1nZXRGaWxtV2lkdGgoKXtyZXR1cm4gdGhpcy5maWxtR2F1Z2UqTWF0aC5taW4odGhpcy5hc3BlY3QsMSl9Z2V0RmlsbUhlaWdodCgpe3JldHVybiB0aGlzLmZpbG1HYXVnZS9NYXRoLm1heCh0aGlzLmFzcGVjdCwxKX1nZXRWaWV3Qm91bmRzKGUsdCxuKXtzbi5zZXQoLTEsLTEsLjUpLmFwcGx5TWF0cml4NCh0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKSx0LnNldChzbi54LHNuLnkpLm11bHRpcGx5U2NhbGFyKC1lL3NuLnopLHNuLnNldCgxLDEsLjUpLmFwcGx5TWF0cml4NCh0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKSxuLnNldChzbi54LHNuLnkpLm11bHRpcGx5U2NhbGFyKC1lL3NuLnopfWdldFZpZXdTaXplKGUsdCl7cmV0dXJuIHRoaXMuZ2V0Vmlld0JvdW5kcyhlLEtyLFpyKSx0LnN1YlZlY3RvcnMoWnIsS3IpfXNldFZpZXdPZmZzZXQoZSx0LG4scixzLGEpe3RoaXMuYXNwZWN0PWUvdCx0aGlzLnZpZXc9PT1udWxsJiYodGhpcy52aWV3PXtlbmFibGVkOiEwLGZ1bGxXaWR0aDoxLGZ1bGxIZWlnaHQ6MSxvZmZzZXRYOjAsb2Zmc2V0WTowLHdpZHRoOjEsaGVpZ2h0OjF9KSx0aGlzLnZpZXcuZW5hYmxlZD0hMCx0aGlzLnZpZXcuZnVsbFdpZHRoPWUsdGhpcy52aWV3LmZ1bGxIZWlnaHQ9dCx0aGlzLnZpZXcub2Zmc2V0WD1uLHRoaXMudmlldy5vZmZzZXRZPXIsdGhpcy52aWV3LndpZHRoPXMsdGhpcy52aWV3LmhlaWdodD1hLHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfWNsZWFyVmlld09mZnNldCgpe3RoaXMudmlldyE9PW51bGwmJih0aGlzLnZpZXcuZW5hYmxlZD0hMSksdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9dXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpe2NvbnN0IGU9dGhpcy5uZWFyO2xldCB0PWUqTWF0aC50YW4oSG4qLjUqdGhpcy5mb3YpL3RoaXMuem9vbSxuPTIqdCxyPXRoaXMuYXNwZWN0Km4scz0tLjUqcjtjb25zdCBhPXRoaXMudmlldztpZih0aGlzLnZpZXchPT1udWxsJiZ0aGlzLnZpZXcuZW5hYmxlZCl7Y29uc3QgbD1hLmZ1bGxXaWR0aCxjPWEuZnVsbEhlaWdodDtzKz1hLm9mZnNldFgqci9sLHQtPWEub2Zmc2V0WSpuL2Mscio9YS53aWR0aC9sLG4qPWEuaGVpZ2h0L2N9Y29uc3Qgbz10aGlzLmZpbG1PZmZzZXQ7byE9PTAmJihzKz1lKm8vdGhpcy5nZXRGaWxtV2lkdGgoKSksdGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VQZXJzcGVjdGl2ZShzLHMrcix0LHQtbixlLHRoaXMuZmFyLHRoaXMuY29vcmRpbmF0ZVN5c3RlbSksdGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KHRoaXMucHJvamVjdGlvbk1hdHJpeCkuaW52ZXJ0KCl9dG9KU09OKGUpe2NvbnN0IHQ9c3VwZXIudG9KU09OKGUpO3JldHVybiB0Lm9iamVjdC5mb3Y9dGhpcy5mb3YsdC5vYmplY3Quem9vbT10aGlzLnpvb20sdC5vYmplY3QubmVhcj10aGlzLm5lYXIsdC5vYmplY3QuZmFyPXRoaXMuZmFyLHQub2JqZWN0LmZvY3VzPXRoaXMuZm9jdXMsdC5vYmplY3QuYXNwZWN0PXRoaXMuYXNwZWN0LHRoaXMudmlldyE9PW51bGwmJih0Lm9iamVjdC52aWV3PU9iamVjdC5hc3NpZ24oe30sdGhpcy52aWV3KSksdC5vYmplY3QuZmlsbUdhdWdlPXRoaXMuZmlsbUdhdWdlLHQub2JqZWN0LmZpbG1PZmZzZXQ9dGhpcy5maWxtT2Zmc2V0LHR9fWNvbnN0IEluPS05MCxObj0xO2NsYXNzIFVhIGV4dGVuZHMgTXR7Y29uc3RydWN0b3IoZSx0LG4pe3N1cGVyKCksdGhpcy50eXBlPSJDdWJlQ2FtZXJhIix0aGlzLnJlbmRlclRhcmdldD1uLHRoaXMuY29vcmRpbmF0ZVN5c3RlbT1udWxsLHRoaXMuYWN0aXZlTWlwbWFwTGV2ZWw9MDtjb25zdCByPW5ldyBOdChJbixObixlLHQpO3IubGF5ZXJzPXRoaXMubGF5ZXJzLHRoaXMuYWRkKHIpO2NvbnN0IHM9bmV3IE50KEluLE5uLGUsdCk7cy5sYXllcnM9dGhpcy5sYXllcnMsdGhpcy5hZGQocyk7Y29uc3QgYT1uZXcgTnQoSW4sTm4sZSx0KTthLmxheWVycz10aGlzLmxheWVycyx0aGlzLmFkZChhKTtjb25zdCBvPW5ldyBOdChJbixObixlLHQpO28ubGF5ZXJzPXRoaXMubGF5ZXJzLHRoaXMuYWRkKG8pO2NvbnN0IGw9bmV3IE50KEluLE5uLGUsdCk7bC5sYXllcnM9dGhpcy5sYXllcnMsdGhpcy5hZGQobCk7Y29uc3QgYz1uZXcgTnQoSW4sTm4sZSx0KTtjLmxheWVycz10aGlzLmxheWVycyx0aGlzLmFkZChjKX11cGRhdGVDb29yZGluYXRlU3lzdGVtKCl7Y29uc3QgZT10aGlzLmNvb3JkaW5hdGVTeXN0ZW0sdD10aGlzLmNoaWxkcmVuLmNvbmNhdCgpLFtuLHIscyxhLG8sbF09dDtmb3IoY29uc3QgYyBvZiB0KXRoaXMucmVtb3ZlKGMpO2lmKGU9PT0yZTMpbi51cC5zZXQoMCwxLDApLG4ubG9va0F0KDEsMCwwKSxyLnVwLnNldCgwLDEsMCksci5sb29rQXQoLTEsMCwwKSxzLnVwLnNldCgwLDAsLTEpLHMubG9va0F0KDAsMSwwKSxhLnVwLnNldCgwLDAsMSksYS5sb29rQXQoMCwtMSwwKSxvLnVwLnNldCgwLDEsMCksby5sb29rQXQoMCwwLDEpLGwudXAuc2V0KDAsMSwwKSxsLmxvb2tBdCgwLDAsLTEpO2Vsc2UgaWYoZT09PTIwMDEpbi51cC5zZXQoMCwtMSwwKSxuLmxvb2tBdCgtMSwwLDApLHIudXAuc2V0KDAsLTEsMCksci5sb29rQXQoMSwwLDApLHMudXAuc2V0KDAsMCwxKSxzLmxvb2tBdCgwLDEsMCksYS51cC5zZXQoMCwwLC0xKSxhLmxvb2tBdCgwLC0xLDApLG8udXAuc2V0KDAsLTEsMCksby5sb29rQXQoMCwwLDEpLGwudXAuc2V0KDAsLTEsMCksbC5sb29rQXQoMCwwLC0xKTtlbHNlIHRocm93IG5ldyBFcnJvcigiVEhSRUUuQ3ViZUNhbWVyYS51cGRhdGVDb29yZGluYXRlU3lzdGVtKCk6IEludmFsaWQgY29vcmRpbmF0ZSBzeXN0ZW06ICIrZSk7Zm9yKGNvbnN0IGMgb2YgdCl0aGlzLmFkZChjKSxjLnVwZGF0ZU1hdHJpeFdvcmxkKCl9dXBkYXRlKGUsdCl7dGhpcy5wYXJlbnQ9PT1udWxsJiZ0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7Y29uc3R7cmVuZGVyVGFyZ2V0Om4sYWN0aXZlTWlwbWFwTGV2ZWw6cn09dGhpczt0aGlzLmNvb3JkaW5hdGVTeXN0ZW0hPT1lLmNvb3JkaW5hdGVTeXN0ZW0mJih0aGlzLmNvb3JkaW5hdGVTeXN0ZW09ZS5jb29yZGluYXRlU3lzdGVtLHRoaXMudXBkYXRlQ29vcmRpbmF0ZVN5c3RlbSgpKTtjb25zdFtzLGEsbyxsLGMsaF09dGhpcy5jaGlsZHJlbixkPWUuZ2V0UmVuZGVyVGFyZ2V0KCksZj1lLmdldEFjdGl2ZUN1YmVGYWNlKCkscD1lLmdldEFjdGl2ZU1pcG1hcExldmVsKCksXz1lLnhyLmVuYWJsZWQ7ZS54ci5lbmFibGVkPSExO2NvbnN0IHg9bi50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztuLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzPSExLGUuc2V0UmVuZGVyVGFyZ2V0KG4sMCxyKSxlLnJlbmRlcih0LHMpLGUuc2V0UmVuZGVyVGFyZ2V0KG4sMSxyKSxlLnJlbmRlcih0LGEpLGUuc2V0UmVuZGVyVGFyZ2V0KG4sMixyKSxlLnJlbmRlcih0LG8pLGUuc2V0UmVuZGVyVGFyZ2V0KG4sMyxyKSxlLnJlbmRlcih0LGwpLGUuc2V0UmVuZGVyVGFyZ2V0KG4sNCxyKSxlLnJlbmRlcih0LGMpLG4udGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM9eCxlLnNldFJlbmRlclRhcmdldChuLDUsciksZS5yZW5kZXIodCxoKSxlLnNldFJlbmRlclRhcmdldChkLGYscCksZS54ci5lbmFibGVkPV8sbi50ZXh0dXJlLm5lZWRzUE1SRU1VcGRhdGU9ITB9fWNsYXNzIGpyIGV4dGVuZHMgdnR7Y29uc3RydWN0b3IoZSx0LG4scixzLGEsbyxsLGMsaCl7ZT1lIT09dm9pZCAwP2U6W10sdD10IT09dm9pZCAwP3Q6MzAxLHN1cGVyKGUsdCxuLHIscyxhLG8sbCxjLGgpLHRoaXMuaXNDdWJlVGV4dHVyZT0hMCx0aGlzLmZsaXBZPSExfWdldCBpbWFnZXMoKXtyZXR1cm4gdGhpcy5pbWFnZX1zZXQgaW1hZ2VzKGUpe3RoaXMuaW1hZ2U9ZX19Y2xhc3MgRmEgZXh0ZW5kcyBKdHtjb25zdHJ1Y3RvcihlPTEsdD17fSl7c3VwZXIoZSxlLHQpLHRoaXMuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQ9ITA7Y29uc3Qgbj17d2lkdGg6ZSxoZWlnaHQ6ZSxkZXB0aDoxfSxyPVtuLG4sbixuLG4sbl07dGhpcy50ZXh0dXJlPW5ldyBqcihyLHQubWFwcGluZyx0LndyYXBTLHQud3JhcFQsdC5tYWdGaWx0ZXIsdC5taW5GaWx0ZXIsdC5mb3JtYXQsdC50eXBlLHQuYW5pc290cm9weSx0LmNvbG9yU3BhY2UpLHRoaXMudGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmU9ITAsdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcz10LmdlbmVyYXRlTWlwbWFwcyE9PXZvaWQgMD90LmdlbmVyYXRlTWlwbWFwczohMSx0aGlzLnRleHR1cmUubWluRmlsdGVyPXQubWluRmlsdGVyIT09dm9pZCAwP3QubWluRmlsdGVyOjEwMDZ9ZnJvbUVxdWlyZWN0YW5ndWxhclRleHR1cmUoZSx0KXt0aGlzLnRleHR1cmUudHlwZT10LnR5cGUsdGhpcy50ZXh0dXJlLmNvbG9yU3BhY2U9dC5jb2xvclNwYWNlLHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM9dC5nZW5lcmF0ZU1pcG1hcHMsdGhpcy50ZXh0dXJlLm1pbkZpbHRlcj10Lm1pbkZpbHRlcix0aGlzLnRleHR1cmUubWFnRmlsdGVyPXQubWFnRmlsdGVyO2NvbnN0IG49e3VuaWZvcm1zOnt0RXF1aXJlY3Q6e3ZhbHVlOm51bGx9fSx2ZXJ0ZXhTaGFkZXI6YAoKCQkJCXZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247CgoJCQkJdmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHsKCgkJCQkJcmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7CgoJCQkJfQoKCQkJCXZvaWQgbWFpbigpIHsKCgkJCQkJdldvcmxkRGlyZWN0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTsKCgkJCQkJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCQkJCQkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CgoJCQkJfQoJCQlgLGZyYWdtZW50U2hhZGVyOmAKCgkJCQl1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7CgoJCQkJdmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjsKCgkJCQkjaW5jbHVkZSA8Y29tbW9uPgoKCQkJCXZvaWQgbWFpbigpIHsKCgkJCQkJdmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHZXb3JsZERpcmVjdGlvbiApOwoKCQkJCQl2ZWMyIHNhbXBsZVVWID0gZXF1aXJlY3RVdiggZGlyZWN0aW9uICk7CgoJCQkJCWdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdEVxdWlyZWN0LCBzYW1wbGVVViApOwoKCQkJCX0KCQkJYH0scj1uZXcgUW4oNSw1LDUpLHM9bmV3IGx0KHtuYW1lOiJDdWJlbWFwRnJvbUVxdWlyZWN0Iix1bmlmb3JtczpGbihuLnVuaWZvcm1zKSx2ZXJ0ZXhTaGFkZXI6bi52ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXI6bi5mcmFnbWVudFNoYWRlcixzaWRlOjEsYmxlbmRpbmc6MH0pO3MudW5pZm9ybXMudEVxdWlyZWN0LnZhbHVlPXQ7Y29uc3QgYT1uZXcgdHQocixzKSxvPXQubWluRmlsdGVyO3JldHVybiB0Lm1pbkZpbHRlcj09PTEwMDgmJih0Lm1pbkZpbHRlcj0xMDA2KSxuZXcgVWEoMSwxMCx0aGlzKS51cGRhdGUoZSxhKSx0Lm1pbkZpbHRlcj1vLGEuZ2VvbWV0cnkuZGlzcG9zZSgpLGEubWF0ZXJpYWwuZGlzcG9zZSgpLHRoaXN9Y2xlYXIoZSx0LG4scil7Y29uc3Qgcz1lLmdldFJlbmRlclRhcmdldCgpO2ZvcihsZXQgYT0wO2E8NjthKyspZS5zZXRSZW5kZXJUYXJnZXQodGhpcyxhKSxlLmNsZWFyKHQsbixyKTtlLnNldFJlbmRlclRhcmdldChzKX19Y29uc3QgaXI9bmV3IE8sSWE9bmV3IE8sTmE9bmV3IGJlO2NsYXNzIGRue2NvbnN0cnVjdG9yKGU9bmV3IE8oMSwwLDApLHQ9MCl7dGhpcy5pc1BsYW5lPSEwLHRoaXMubm9ybWFsPWUsdGhpcy5jb25zdGFudD10fXNldChlLHQpe3JldHVybiB0aGlzLm5vcm1hbC5jb3B5KGUpLHRoaXMuY29uc3RhbnQ9dCx0aGlzfXNldENvbXBvbmVudHMoZSx0LG4scil7cmV0dXJuIHRoaXMubm9ybWFsLnNldChlLHQsbiksdGhpcy5jb25zdGFudD1yLHRoaXN9c2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoZSx0KXtyZXR1cm4gdGhpcy5ub3JtYWwuY29weShlKSx0aGlzLmNvbnN0YW50PS10LmRvdCh0aGlzLm5vcm1hbCksdGhpc31zZXRGcm9tQ29wbGFuYXJQb2ludHMoZSx0LG4pe2NvbnN0IHI9aXIuc3ViVmVjdG9ycyhuLHQpLmNyb3NzKElhLnN1YlZlY3RvcnMoZSx0KSkubm9ybWFsaXplKCk7cmV0dXJuIHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQocixlKSx0aGlzfWNvcHkoZSl7cmV0dXJuIHRoaXMubm9ybWFsLmNvcHkoZS5ub3JtYWwpLHRoaXMuY29uc3RhbnQ9ZS5jb25zdGFudCx0aGlzfW5vcm1hbGl6ZSgpe2NvbnN0IGU9MS90aGlzLm5vcm1hbC5sZW5ndGgoKTtyZXR1cm4gdGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoZSksdGhpcy5jb25zdGFudCo9ZSx0aGlzfW5lZ2F0ZSgpe3JldHVybiB0aGlzLmNvbnN0YW50Kj0tMSx0aGlzLm5vcm1hbC5uZWdhdGUoKSx0aGlzfWRpc3RhbmNlVG9Qb2ludChlKXtyZXR1cm4gdGhpcy5ub3JtYWwuZG90KGUpK3RoaXMuY29uc3RhbnR9ZGlzdGFuY2VUb1NwaGVyZShlKXtyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoZS5jZW50ZXIpLWUucmFkaXVzfXByb2plY3RQb2ludChlLHQpe3JldHVybiB0LmNvcHkoZSkuYWRkU2NhbGVkVmVjdG9yKHRoaXMubm9ybWFsLC10aGlzLmRpc3RhbmNlVG9Qb2ludChlKSl9aW50ZXJzZWN0TGluZShlLHQpe2NvbnN0IG49ZS5kZWx0YShpcikscj10aGlzLm5vcm1hbC5kb3Qobik7aWYocj09PTApcmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KGUuc3RhcnQpPT09MD90LmNvcHkoZS5zdGFydCk6bnVsbDtjb25zdCBzPS0oZS5zdGFydC5kb3QodGhpcy5ub3JtYWwpK3RoaXMuY29uc3RhbnQpL3I7cmV0dXJuIHM8MHx8cz4xP251bGw6dC5jb3B5KGUuc3RhcnQpLmFkZFNjYWxlZFZlY3RvcihuLHMpfWludGVyc2VjdHNMaW5lKGUpe2NvbnN0IHQ9dGhpcy5kaXN0YW5jZVRvUG9pbnQoZS5zdGFydCksbj10aGlzLmRpc3RhbmNlVG9Qb2ludChlLmVuZCk7cmV0dXJuIHQ8MCYmbj4wfHxuPDAmJnQ+MH1pbnRlcnNlY3RzQm94KGUpe3JldHVybiBlLmludGVyc2VjdHNQbGFuZSh0aGlzKX1pbnRlcnNlY3RzU3BoZXJlKGUpe3JldHVybiBlLmludGVyc2VjdHNQbGFuZSh0aGlzKX1jb3BsYW5hclBvaW50KGUpe3JldHVybiBlLmNvcHkodGhpcy5ub3JtYWwpLm11bHRpcGx5U2NhbGFyKC10aGlzLmNvbnN0YW50KX1hcHBseU1hdHJpeDQoZSx0KXtjb25zdCBuPXR8fE5hLmdldE5vcm1hbE1hdHJpeChlKSxyPXRoaXMuY29wbGFuYXJQb2ludChpcikuYXBwbHlNYXRyaXg0KGUpLHM9dGhpcy5ub3JtYWwuYXBwbHlNYXRyaXgzKG4pLm5vcm1hbGl6ZSgpO3JldHVybiB0aGlzLmNvbnN0YW50PS1yLmRvdChzKSx0aGlzfXRyYW5zbGF0ZShlKXtyZXR1cm4gdGhpcy5jb25zdGFudC09ZS5kb3QodGhpcy5ub3JtYWwpLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLm5vcm1hbC5lcXVhbHModGhpcy5ub3JtYWwpJiZlLmNvbnN0YW50PT09dGhpcy5jb25zdGFudH1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9fWNvbnN0IGZuPW5ldyBsaSxFaT1uZXcgTztjbGFzcyBKcntjb25zdHJ1Y3RvcihlPW5ldyBkbix0PW5ldyBkbixuPW5ldyBkbixyPW5ldyBkbixzPW5ldyBkbixhPW5ldyBkbil7dGhpcy5wbGFuZXM9W2UsdCxuLHIscyxhXX1zZXQoZSx0LG4scixzLGEpe2NvbnN0IG89dGhpcy5wbGFuZXM7cmV0dXJuIG9bMF0uY29weShlKSxvWzFdLmNvcHkodCksb1syXS5jb3B5KG4pLG9bM10uY29weShyKSxvWzRdLmNvcHkocyksb1s1XS5jb3B5KGEpLHRoaXN9Y29weShlKXtjb25zdCB0PXRoaXMucGxhbmVzO2ZvcihsZXQgbj0wO248NjtuKyspdFtuXS5jb3B5KGUucGxhbmVzW25dKTtyZXR1cm4gdGhpc31zZXRGcm9tUHJvamVjdGlvbk1hdHJpeChlLHQ9MmUzKXtjb25zdCBuPXRoaXMucGxhbmVzLHI9ZS5lbGVtZW50cyxzPXJbMF0sYT1yWzFdLG89clsyXSxsPXJbM10sYz1yWzRdLGg9cls1XSxkPXJbNl0sZj1yWzddLHA9cls4XSxfPXJbOV0seD1yWzEwXSxtPXJbMTFdLHU9clsxMl0sVD1yWzEzXSx5PXJbMTRdLGc9clsxNV07aWYoblswXS5zZXRDb21wb25lbnRzKGwtcyxmLWMsbS1wLGctdSkubm9ybWFsaXplKCksblsxXS5zZXRDb21wb25lbnRzKGwrcyxmK2MsbStwLGcrdSkubm9ybWFsaXplKCksblsyXS5zZXRDb21wb25lbnRzKGwrYSxmK2gsbStfLGcrVCkubm9ybWFsaXplKCksblszXS5zZXRDb21wb25lbnRzKGwtYSxmLWgsbS1fLGctVCkubm9ybWFsaXplKCksbls0XS5zZXRDb21wb25lbnRzKGwtbyxmLWQsbS14LGcteSkubm9ybWFsaXplKCksdD09PTJlMyluWzVdLnNldENvbXBvbmVudHMobCtvLGYrZCxtK3gsZyt5KS5ub3JtYWxpemUoKTtlbHNlIGlmKHQ9PT0yMDAxKW5bNV0uc2V0Q29tcG9uZW50cyhvLGQseCx5KS5ub3JtYWxpemUoKTtlbHNlIHRocm93IG5ldyBFcnJvcigiVEhSRUUuRnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeCgpOiBJbnZhbGlkIGNvb3JkaW5hdGUgc3lzdGVtOiAiK3QpO3JldHVybiB0aGlzfWludGVyc2VjdHNPYmplY3QoZSl7aWYoZS5ib3VuZGluZ1NwaGVyZSE9PXZvaWQgMCllLmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmZS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKSxmbi5jb3B5KGUuYm91bmRpbmdTcGhlcmUpLmFwcGx5TWF0cml4NChlLm1hdHJpeFdvcmxkKTtlbHNle2NvbnN0IHQ9ZS5nZW9tZXRyeTt0LmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmdC5jb21wdXRlQm91bmRpbmdTcGhlcmUoKSxmbi5jb3B5KHQuYm91bmRpbmdTcGhlcmUpLmFwcGx5TWF0cml4NChlLm1hdHJpeFdvcmxkKX1yZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKGZuKX1pbnRlcnNlY3RzU3ByaXRlKGUpe3JldHVybiBmbi5jZW50ZXIuc2V0KDAsMCwwKSxmbi5yYWRpdXM9LjcwNzEwNjc4MTE4NjU0NzYsZm4uYXBwbHlNYXRyaXg0KGUubWF0cml4V29ybGQpLHRoaXMuaW50ZXJzZWN0c1NwaGVyZShmbil9aW50ZXJzZWN0c1NwaGVyZShlKXtjb25zdCB0PXRoaXMucGxhbmVzLG49ZS5jZW50ZXIscj0tZS5yYWRpdXM7Zm9yKGxldCBzPTA7czw2O3MrKylpZih0W3NdLmRpc3RhbmNlVG9Qb2ludChuKTxyKXJldHVybiExO3JldHVybiEwfWludGVyc2VjdHNCb3goZSl7Y29uc3QgdD10aGlzLnBsYW5lcztmb3IobGV0IG49MDtuPDY7bisrKXtjb25zdCByPXRbbl07aWYoRWkueD1yLm5vcm1hbC54PjA/ZS5tYXgueDplLm1pbi54LEVpLnk9ci5ub3JtYWwueT4wP2UubWF4Lnk6ZS5taW4ueSxFaS56PXIubm9ybWFsLno+MD9lLm1heC56OmUubWluLnosci5kaXN0YW5jZVRvUG9pbnQoRWkpPDApcmV0dXJuITF9cmV0dXJuITB9Y29udGFpbnNQb2ludChlKXtjb25zdCB0PXRoaXMucGxhbmVzO2ZvcihsZXQgbj0wO248NjtuKyspaWYodFtuXS5kaXN0YW5jZVRvUG9pbnQoZSk8MClyZXR1cm4hMTtyZXR1cm4hMH1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9fWZ1bmN0aW9uIFFyKCl7bGV0IGk9bnVsbCxlPSExLHQ9bnVsbCxuPW51bGw7ZnVuY3Rpb24gcihzLGEpe3QocyxhKSxuPWkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHIpfXJldHVybntzdGFydDpmdW5jdGlvbigpe2UhPT0hMCYmdCE9PW51bGwmJihuPWkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHIpLGU9ITApfSxzdG9wOmZ1bmN0aW9uKCl7aS5jYW5jZWxBbmltYXRpb25GcmFtZShuKSxlPSExfSxzZXRBbmltYXRpb25Mb29wOmZ1bmN0aW9uKHMpe3Q9c30sc2V0Q29udGV4dDpmdW5jdGlvbihzKXtpPXN9fX1mdW5jdGlvbiBPYShpKXtjb25zdCBlPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIHQobyxsKXtjb25zdCBjPW8uYXJyYXksaD1vLnVzYWdlLGQ9Yy5ieXRlTGVuZ3RoLGY9aS5jcmVhdGVCdWZmZXIoKTtpLmJpbmRCdWZmZXIobCxmKSxpLmJ1ZmZlckRhdGEobCxjLGgpLG8ub25VcGxvYWRDYWxsYmFjaygpO2xldCBwO2lmKGMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpcD1pLkZMT0FUO2Vsc2UgaWYoYyBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KW8uaXNGbG9hdDE2QnVmZmVyQXR0cmlidXRlP3A9aS5IQUxGX0ZMT0FUOnA9aS5VTlNJR05FRF9TSE9SVDtlbHNlIGlmKGMgaW5zdGFuY2VvZiBJbnQxNkFycmF5KXA9aS5TSE9SVDtlbHNlIGlmKGMgaW5zdGFuY2VvZiBVaW50MzJBcnJheSlwPWkuVU5TSUdORURfSU5UO2Vsc2UgaWYoYyBpbnN0YW5jZW9mIEludDMyQXJyYXkpcD1pLklOVDtlbHNlIGlmKGMgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpcD1pLkJZVEU7ZWxzZSBpZihjIGluc3RhbmNlb2YgVWludDhBcnJheSlwPWkuVU5TSUdORURfQllURTtlbHNlIGlmKGMgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSlwPWkuVU5TSUdORURfQllURTtlbHNlIHRocm93IG5ldyBFcnJvcigiVEhSRUUuV2ViR0xBdHRyaWJ1dGVzOiBVbnN1cHBvcnRlZCBidWZmZXIgZGF0YSBmb3JtYXQ6ICIrYyk7cmV0dXJue2J1ZmZlcjpmLHR5cGU6cCxieXRlc1BlckVsZW1lbnQ6Yy5CWVRFU19QRVJfRUxFTUVOVCx2ZXJzaW9uOm8udmVyc2lvbixzaXplOmR9fWZ1bmN0aW9uIG4obyxsLGMpe2NvbnN0IGg9bC5hcnJheSxkPWwudXBkYXRlUmFuZ2VzO2lmKGkuYmluZEJ1ZmZlcihjLG8pLGQubGVuZ3RoPT09MClpLmJ1ZmZlclN1YkRhdGEoYywwLGgpO2Vsc2V7ZC5zb3J0KChwLF8pPT5wLnN0YXJ0LV8uc3RhcnQpO2xldCBmPTA7Zm9yKGxldCBwPTE7cDxkLmxlbmd0aDtwKyspe2NvbnN0IF89ZFtmXSx4PWRbcF07eC5zdGFydDw9Xy5zdGFydCtfLmNvdW50KzE/Xy5jb3VudD1NYXRoLm1heChfLmNvdW50LHguc3RhcnQreC5jb3VudC1fLnN0YXJ0KTooKytmLGRbZl09eCl9ZC5sZW5ndGg9ZisxO2ZvcihsZXQgcD0wLF89ZC5sZW5ndGg7cDxfO3ArKyl7Y29uc3QgeD1kW3BdO2kuYnVmZmVyU3ViRGF0YShjLHguc3RhcnQqaC5CWVRFU19QRVJfRUxFTUVOVCxoLHguc3RhcnQseC5jb3VudCl9bC5jbGVhclVwZGF0ZVJhbmdlcygpfWwub25VcGxvYWRDYWxsYmFjaygpfWZ1bmN0aW9uIHIobyl7cmV0dXJuIG8uaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSYmKG89by5kYXRhKSxlLmdldChvKX1mdW5jdGlvbiBzKG8pe28uaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSYmKG89by5kYXRhKTtjb25zdCBsPWUuZ2V0KG8pO2wmJihpLmRlbGV0ZUJ1ZmZlcihsLmJ1ZmZlciksZS5kZWxldGUobykpfWZ1bmN0aW9uIGEobyxsKXtpZihvLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUmJihvPW8uZGF0YSksby5pc0dMQnVmZmVyQXR0cmlidXRlKXtjb25zdCBoPWUuZ2V0KG8pOyghaHx8aC52ZXJzaW9uPG8udmVyc2lvbikmJmUuc2V0KG8se2J1ZmZlcjpvLmJ1ZmZlcix0eXBlOm8udHlwZSxieXRlc1BlckVsZW1lbnQ6by5lbGVtZW50U2l6ZSx2ZXJzaW9uOm8udmVyc2lvbn0pO3JldHVybn1jb25zdCBjPWUuZ2V0KG8pO2lmKGM9PT12b2lkIDApZS5zZXQobyx0KG8sbCkpO2Vsc2UgaWYoYy52ZXJzaW9uPG8udmVyc2lvbil7aWYoYy5zaXplIT09by5hcnJheS5ieXRlTGVuZ3RoKXRocm93IG5ldyBFcnJvcigiVEhSRUUuV2ViR0xBdHRyaWJ1dGVzOiBUaGUgc2l6ZSBvZiB0aGUgYnVmZmVyIGF0dHJpYnV0ZSdzIGFycmF5IGJ1ZmZlciBkb2VzIG5vdCBtYXRjaCB0aGUgb3JpZ2luYWwgc2l6ZS4gUmVzaXppbmcgYnVmZmVyIGF0dHJpYnV0ZXMgaXMgbm90IHN1cHBvcnRlZC4iKTtuKGMuYnVmZmVyLG8sbCksYy52ZXJzaW9uPW8udmVyc2lvbn19cmV0dXJue2dldDpyLHJlbW92ZTpzLHVwZGF0ZTphfX1jbGFzcyBldCBleHRlbmRzIEN0e2NvbnN0cnVjdG9yKGU9MSx0PTEsbj0xLHI9MSl7c3VwZXIoKSx0aGlzLnR5cGU9IlBsYW5lR2VvbWV0cnkiLHRoaXMucGFyYW1ldGVycz17d2lkdGg6ZSxoZWlnaHQ6dCx3aWR0aFNlZ21lbnRzOm4saGVpZ2h0U2VnbWVudHM6cn07Y29uc3Qgcz1lLzIsYT10LzIsbz1NYXRoLmZsb29yKG4pLGw9TWF0aC5mbG9vcihyKSxjPW8rMSxoPWwrMSxkPWUvbyxmPXQvbCxwPVtdLF89W10seD1bXSxtPVtdO2ZvcihsZXQgdT0wO3U8aDt1Kyspe2NvbnN0IFQ9dSpmLWE7Zm9yKGxldCB5PTA7eTxjO3krKyl7Y29uc3QgZz15KmQtcztfLnB1c2goZywtVCwwKSx4LnB1c2goMCwwLDEpLG0ucHVzaCh5L28pLG0ucHVzaCgxLXUvbCl9fWZvcihsZXQgdT0wO3U8bDt1KyspZm9yKGxldCBUPTA7VDxvO1QrKyl7Y29uc3QgeT1UK2MqdSxnPVQrYyoodSsxKSxQPVQrMStjKih1KzEpLHc9VCsxK2MqdTtwLnB1c2goeSxnLHcpLHAucHVzaChnLFAsdyl9dGhpcy5zZXRJbmRleChwKSx0aGlzLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyB1bihfLDMpKSx0aGlzLnNldEF0dHJpYnV0ZSgibm9ybWFsIixuZXcgdW4oeCwzKSksdGhpcy5zZXRBdHRyaWJ1dGUoInV2IixuZXcgdW4obSwyKSl9Y29weShlKXtyZXR1cm4gc3VwZXIuY29weShlKSx0aGlzLnBhcmFtZXRlcnM9T2JqZWN0LmFzc2lnbih7fSxlLnBhcmFtZXRlcnMpLHRoaXN9c3RhdGljIGZyb21KU09OKGUpe3JldHVybiBuZXcgZXQoZS53aWR0aCxlLmhlaWdodCxlLndpZHRoU2VnbWVudHMsZS5oZWlnaHRTZWdtZW50cyl9fXZhciBCYT1gI2lmZGVmIFVTRV9BTFBIQUhBU0gKCWlmICggZGlmZnVzZUNvbG9yLmEgPCBnZXRBbHBoYUhhc2hUaHJlc2hvbGQoIHZQb3NpdGlvbiApICkgZGlzY2FyZDsKI2VuZGlmYCx6YT1gI2lmZGVmIFVTRV9BTFBIQUhBU0gKCWNvbnN0IGZsb2F0IEFMUEhBX0hBU0hfU0NBTEUgPSAwLjA1OwoJZmxvYXQgaGFzaDJEKCB2ZWMyIHZhbHVlICkgewoJCXJldHVybiBmcmFjdCggMS4wZTQgKiBzaW4oIDE3LjAgKiB2YWx1ZS54ICsgMC4xICogdmFsdWUueSApICogKCAwLjEgKyBhYnMoIHNpbiggMTMuMCAqIHZhbHVlLnkgKyB2YWx1ZS54ICkgKSApICk7Cgl9CglmbG9hdCBoYXNoM0QoIHZlYzMgdmFsdWUgKSB7CgkJcmV0dXJuIGhhc2gyRCggdmVjMiggaGFzaDJEKCB2YWx1ZS54eSApLCB2YWx1ZS56ICkgKTsKCX0KCWZsb2F0IGdldEFscGhhSGFzaFRocmVzaG9sZCggdmVjMyBwb3NpdGlvbiApIHsKCQlmbG9hdCBtYXhEZXJpdiA9IG1heCgKCQkJbGVuZ3RoKCBkRmR4KCBwb3NpdGlvbi54eXogKSApLAoJCQlsZW5ndGgoIGRGZHkoIHBvc2l0aW9uLnh5eiApICkKCQkpOwoJCWZsb2F0IHBpeFNjYWxlID0gMS4wIC8gKCBBTFBIQV9IQVNIX1NDQUxFICogbWF4RGVyaXYgKTsKCQl2ZWMyIHBpeFNjYWxlcyA9IHZlYzIoCgkJCWV4cDIoIGZsb29yKCBsb2cyKCBwaXhTY2FsZSApICkgKSwKCQkJZXhwMiggY2VpbCggbG9nMiggcGl4U2NhbGUgKSApICkKCQkpOwoJCXZlYzIgYWxwaGEgPSB2ZWMyKAoJCQloYXNoM0QoIGZsb29yKCBwaXhTY2FsZXMueCAqIHBvc2l0aW9uLnh5eiApICksCgkJCWhhc2gzRCggZmxvb3IoIHBpeFNjYWxlcy55ICogcG9zaXRpb24ueHl6ICkgKQoJCSk7CgkJZmxvYXQgbGVycEZhY3RvciA9IGZyYWN0KCBsb2cyKCBwaXhTY2FsZSApICk7CgkJZmxvYXQgeCA9ICggMS4wIC0gbGVycEZhY3RvciApICogYWxwaGEueCArIGxlcnBGYWN0b3IgKiBhbHBoYS55OwoJCWZsb2F0IGEgPSBtaW4oIGxlcnBGYWN0b3IsIDEuMCAtIGxlcnBGYWN0b3IgKTsKCQl2ZWMzIGNhc2VzID0gdmVjMygKCQkJeCAqIHggLyAoIDIuMCAqIGEgKiAoIDEuMCAtIGEgKSApLAoJCQkoIHggLSAwLjUgKiBhICkgLyAoIDEuMCAtIGEgKSwKCQkJMS4wIC0gKCAoIDEuMCAtIHggKSAqICggMS4wIC0geCApIC8gKCAyLjAgKiBhICogKCAxLjAgLSBhICkgKSApCgkJKTsKCQlmbG9hdCB0aHJlc2hvbGQgPSAoIHggPCAoIDEuMCAtIGEgKSApCgkJCT8gKCAoIHggPCBhICkgPyBjYXNlcy54IDogY2FzZXMueSApCgkJCTogY2FzZXMuejsKCQlyZXR1cm4gY2xhbXAoIHRocmVzaG9sZCAsIDEuMGUtNiwgMS4wICk7Cgl9CiNlbmRpZmAsR2E9YCNpZmRlZiBVU0VfQUxQSEFNQVAKCWRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHZBbHBoYU1hcFV2ICkuZzsKI2VuZGlmYCxIYT1gI2lmZGVmIFVTRV9BTFBIQU1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7CiNlbmRpZmAsVmE9YCNpZmRlZiBVU0VfQUxQSEFURVNUCgkjaWZkZWYgQUxQSEFfVE9fQ09WRVJBR0UKCWRpZmZ1c2VDb2xvci5hID0gc21vb3Roc3RlcCggYWxwaGFUZXN0LCBhbHBoYVRlc3QgKyBmd2lkdGgoIGRpZmZ1c2VDb2xvci5hICksIGRpZmZ1c2VDb2xvci5hICk7CglpZiAoIGRpZmZ1c2VDb2xvci5hID09IDAuMCApIGRpc2NhcmQ7CgkjZWxzZQoJaWYgKCBkaWZmdXNlQ29sb3IuYSA8IGFscGhhVGVzdCApIGRpc2NhcmQ7CgkjZW5kaWYKI2VuZGlmYCxrYT1gI2lmZGVmIFVTRV9BTFBIQVRFU1QKCXVuaWZvcm0gZmxvYXQgYWxwaGFUZXN0OwojZW5kaWZgLFdhPWAjaWZkZWYgVVNFX0FPTUFQCglmbG9hdCBhbWJpZW50T2NjbHVzaW9uID0gKCB0ZXh0dXJlMkQoIGFvTWFwLCB2QW9NYXBVdiApLnIgLSAxLjAgKSAqIGFvTWFwSW50ZW5zaXR5ICsgMS4wOwoJcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IGFtYmllbnRPY2NsdXNpb247CgkjaWYgZGVmaW5lZCggVVNFX0NMRUFSQ09BVCApIAoJCWNsZWFyY29hdFNwZWN1bGFySW5kaXJlY3QgKj0gYW1iaWVudE9jY2x1c2lvbjsKCSNlbmRpZgoJI2lmIGRlZmluZWQoIFVTRV9TSEVFTiApIAoJCXNoZWVuU3BlY3VsYXJJbmRpcmVjdCAqPSBhbWJpZW50T2NjbHVzaW9uOwoJI2VuZGlmCgkjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFNUQU5EQVJEICkKCQlmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIgKSApOwoJCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKj0gY29tcHV0ZVNwZWN1bGFyT2NjbHVzaW9uKCBkb3ROViwgYW1iaWVudE9jY2x1c2lvbiwgbWF0ZXJpYWwucm91Z2huZXNzICk7CgkjZW5kaWYKI2VuZGlmYCxYYT1gI2lmZGVmIFVTRV9BT01BUAoJdW5pZm9ybSBzYW1wbGVyMkQgYW9NYXA7Cgl1bmlmb3JtIGZsb2F0IGFvTWFwSW50ZW5zaXR5OwojZW5kaWZgLHFhPWAjaWZkZWYgVVNFX0JBVENISU5HCgkjaWYgISBkZWZpbmVkKCBHTF9BTkdMRV9tdWx0aV9kcmF3ICkKCSNkZWZpbmUgZ2xfRHJhd0lEIF9nbF9EcmF3SUQKCXVuaWZvcm0gaW50IF9nbF9EcmF3SUQ7CgkjZW5kaWYKCXVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGJhdGNoaW5nVGV4dHVyZTsKCXVuaWZvcm0gaGlnaHAgdXNhbXBsZXIyRCBiYXRjaGluZ0lkVGV4dHVyZTsKCW1hdDQgZ2V0QmF0Y2hpbmdNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7CgkJaW50IHNpemUgPSB0ZXh0dXJlU2l6ZSggYmF0Y2hpbmdUZXh0dXJlLCAwICkueDsKCQlpbnQgaiA9IGludCggaSApICogNDsKCQlpbnQgeCA9IGogJSBzaXplOwoJCWludCB5ID0gaiAvIHNpemU7CgkJdmVjNCB2MSA9IHRleGVsRmV0Y2goIGJhdGNoaW5nVGV4dHVyZSwgaXZlYzIoIHgsIHkgKSwgMCApOwoJCXZlYzQgdjIgPSB0ZXhlbEZldGNoKCBiYXRjaGluZ1RleHR1cmUsIGl2ZWMyKCB4ICsgMSwgeSApLCAwICk7CgkJdmVjNCB2MyA9IHRleGVsRmV0Y2goIGJhdGNoaW5nVGV4dHVyZSwgaXZlYzIoIHggKyAyLCB5ICksIDAgKTsKCQl2ZWM0IHY0ID0gdGV4ZWxGZXRjaCggYmF0Y2hpbmdUZXh0dXJlLCBpdmVjMiggeCArIDMsIHkgKSwgMCApOwoJCXJldHVybiBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApOwoJfQoJZmxvYXQgZ2V0SW5kaXJlY3RJbmRleCggY29uc3QgaW4gaW50IGkgKSB7CgkJaW50IHNpemUgPSB0ZXh0dXJlU2l6ZSggYmF0Y2hpbmdJZFRleHR1cmUsIDAgKS54OwoJCWludCB4ID0gaSAlIHNpemU7CgkJaW50IHkgPSBpIC8gc2l6ZTsKCQlyZXR1cm4gZmxvYXQoIHRleGVsRmV0Y2goIGJhdGNoaW5nSWRUZXh0dXJlLCBpdmVjMiggeCwgeSApLCAwICkuciApOwoJfQojZW5kaWYKI2lmZGVmIFVTRV9CQVRDSElOR19DT0xPUgoJdW5pZm9ybSBzYW1wbGVyMkQgYmF0Y2hpbmdDb2xvclRleHR1cmU7Cgl2ZWMzIGdldEJhdGNoaW5nQ29sb3IoIGNvbnN0IGluIGZsb2F0IGkgKSB7CgkJaW50IHNpemUgPSB0ZXh0dXJlU2l6ZSggYmF0Y2hpbmdDb2xvclRleHR1cmUsIDAgKS54OwoJCWludCBqID0gaW50KCBpICk7CgkJaW50IHggPSBqICUgc2l6ZTsKCQlpbnQgeSA9IGogLyBzaXplOwoJCXJldHVybiB0ZXhlbEZldGNoKCBiYXRjaGluZ0NvbG9yVGV4dHVyZSwgaXZlYzIoIHgsIHkgKSwgMCApLnJnYjsKCX0KI2VuZGlmYCxZYT1gI2lmZGVmIFVTRV9CQVRDSElORwoJbWF0NCBiYXRjaGluZ01hdHJpeCA9IGdldEJhdGNoaW5nTWF0cml4KCBnZXRJbmRpcmVjdEluZGV4KCBnbF9EcmF3SUQgKSApOwojZW5kaWZgLCRhPWB2ZWMzIHRyYW5zZm9ybWVkID0gdmVjMyggcG9zaXRpb24gKTsKI2lmZGVmIFVTRV9BTFBIQUhBU0gKCXZQb3NpdGlvbiA9IHZlYzMoIHBvc2l0aW9uICk7CiNlbmRpZmAsS2E9YHZlYzMgb2JqZWN0Tm9ybWFsID0gdmVjMyggbm9ybWFsICk7CiNpZmRlZiBVU0VfVEFOR0VOVAoJdmVjMyBvYmplY3RUYW5nZW50ID0gdmVjMyggdGFuZ2VudC54eXogKTsKI2VuZGlmYCxaYT1gZmxvYXQgR19CbGlublBob25nX0ltcGxpY2l0KCApIHsKCXJldHVybiAwLjI1Owp9CmZsb2F0IERfQmxpbm5QaG9uZyggY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHsKCXJldHVybiBSRUNJUFJPQ0FMX1BJICogKCBzaGluaW5lc3MgKiAwLjUgKyAxLjAgKSAqIHBvdyggZG90TkgsIHNoaW5pbmVzcyApOwp9CnZlYzMgQlJERl9CbGlublBob25nKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcyApIHsKCXZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7CglmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7CglmbG9hdCBkb3RWSCA9IHNhdHVyYXRlKCBkb3QoIHZpZXdEaXIsIGhhbGZEaXIgKSApOwoJdmVjMyBGID0gRl9TY2hsaWNrKCBzcGVjdWxhckNvbG9yLCAxLjAsIGRvdFZIICk7CglmbG9hdCBHID0gR19CbGlublBob25nX0ltcGxpY2l0KCApOwoJZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApOwoJcmV0dXJuIEYgKiAoIEcgKiBEICk7Cn0gLy8gdmFsaWRhdGVkYCxqYT1gI2lmZGVmIFVTRV9JUklERVNDRU5DRQoJY29uc3QgbWF0MyBYWVpfVE9fUkVDNzA5ID0gbWF0MygKCQkgMy4yNDA0NTQyLCAtMC45NjkyNjYwLCAgMC4wNTU2NDM0LAoJCS0xLjUzNzEzODUsICAxLjg3NjAxMDgsIC0wLjIwNDAyNTksCgkJLTAuNDk4NTMxNCwgIDAuMDQxNTU2MCwgIDEuMDU3MjI1MgoJKTsKCXZlYzMgRnJlc25lbDBUb0lvciggdmVjMyBmcmVzbmVsMCApIHsKCQl2ZWMzIHNxcnRGMCA9IHNxcnQoIGZyZXNuZWwwICk7CgkJcmV0dXJuICggdmVjMyggMS4wICkgKyBzcXJ0RjAgKSAvICggdmVjMyggMS4wICkgLSBzcXJ0RjAgKTsKCX0KCXZlYzMgSW9yVG9GcmVzbmVsMCggdmVjMyB0cmFuc21pdHRlZElvciwgZmxvYXQgaW5jaWRlbnRJb3IgKSB7CgkJcmV0dXJuIHBvdzIoICggdHJhbnNtaXR0ZWRJb3IgLSB2ZWMzKCBpbmNpZGVudElvciApICkgLyAoIHRyYW5zbWl0dGVkSW9yICsgdmVjMyggaW5jaWRlbnRJb3IgKSApICk7Cgl9CglmbG9hdCBJb3JUb0ZyZXNuZWwwKCBmbG9hdCB0cmFuc21pdHRlZElvciwgZmxvYXQgaW5jaWRlbnRJb3IgKSB7CgkJcmV0dXJuIHBvdzIoICggdHJhbnNtaXR0ZWRJb3IgLSBpbmNpZGVudElvciApIC8gKCB0cmFuc21pdHRlZElvciArIGluY2lkZW50SW9yICkpOwoJfQoJdmVjMyBldmFsU2Vuc2l0aXZpdHkoIGZsb2F0IE9QRCwgdmVjMyBzaGlmdCApIHsKCQlmbG9hdCBwaGFzZSA9IDIuMCAqIFBJICogT1BEICogMS4wZS05OwoJCXZlYzMgdmFsID0gdmVjMyggNS40ODU2ZS0xMywgNC40MjAxZS0xMywgNS4yNDgxZS0xMyApOwoJCXZlYzMgcG9zID0gdmVjMyggMS42ODEwZSswNiwgMS43OTUzZSswNiwgMi4yMDg0ZSswNiApOwoJCXZlYzMgdmFyID0gdmVjMyggNC4zMjc4ZSswOSwgOS4zMDQ2ZSswOSwgNi42MTIxZSswOSApOwoJCXZlYzMgeHl6ID0gdmFsICogc3FydCggMi4wICogUEkgKiB2YXIgKSAqIGNvcyggcG9zICogcGhhc2UgKyBzaGlmdCApICogZXhwKCAtIHBvdzIoIHBoYXNlICkgKiB2YXIgKTsKCQl4eXoueCArPSA5Ljc0NzBlLTE0ICogc3FydCggMi4wICogUEkgKiA0LjUyODJlKzA5ICkgKiBjb3MoIDIuMjM5OWUrMDYgKiBwaGFzZSArIHNoaWZ0WyAwIF0gKSAqIGV4cCggLSA0LjUyODJlKzA5ICogcG93MiggcGhhc2UgKSApOwoJCXh5eiAvPSAxLjA2ODVlLTc7CgkJdmVjMyByZ2IgPSBYWVpfVE9fUkVDNzA5ICogeHl6OwoJCXJldHVybiByZ2I7Cgl9Cgl2ZWMzIGV2YWxJcmlkZXNjZW5jZSggZmxvYXQgb3V0c2lkZUlPUiwgZmxvYXQgZXRhMiwgZmxvYXQgY29zVGhldGExLCBmbG9hdCB0aGluRmlsbVRoaWNrbmVzcywgdmVjMyBiYXNlRjAgKSB7CgkJdmVjMyBJOwoJCWZsb2F0IGlyaWRlc2NlbmNlSU9SID0gbWl4KCBvdXRzaWRlSU9SLCBldGEyLCBzbW9vdGhzdGVwKCAwLjAsIDAuMDMsIHRoaW5GaWxtVGhpY2tuZXNzICkgKTsKCQlmbG9hdCBzaW5UaGV0YTJTcSA9IHBvdzIoIG91dHNpZGVJT1IgLyBpcmlkZXNjZW5jZUlPUiApICogKCAxLjAgLSBwb3cyKCBjb3NUaGV0YTEgKSApOwoJCWZsb2F0IGNvc1RoZXRhMlNxID0gMS4wIC0gc2luVGhldGEyU3E7CgkJaWYgKCBjb3NUaGV0YTJTcSA8IDAuMCApIHsKCQkJcmV0dXJuIHZlYzMoIDEuMCApOwoJCX0KCQlmbG9hdCBjb3NUaGV0YTIgPSBzcXJ0KCBjb3NUaGV0YTJTcSApOwoJCWZsb2F0IFIwID0gSW9yVG9GcmVzbmVsMCggaXJpZGVzY2VuY2VJT1IsIG91dHNpZGVJT1IgKTsKCQlmbG9hdCBSMTIgPSBGX1NjaGxpY2soIFIwLCAxLjAsIGNvc1RoZXRhMSApOwoJCWZsb2F0IFQxMjEgPSAxLjAgLSBSMTI7CgkJZmxvYXQgcGhpMTIgPSAwLjA7CgkJaWYgKCBpcmlkZXNjZW5jZUlPUiA8IG91dHNpZGVJT1IgKSBwaGkxMiA9IFBJOwoJCWZsb2F0IHBoaTIxID0gUEkgLSBwaGkxMjsKCQl2ZWMzIGJhc2VJT1IgPSBGcmVzbmVsMFRvSW9yKCBjbGFtcCggYmFzZUYwLCAwLjAsIDAuOTk5OSApICk7CQl2ZWMzIFIxID0gSW9yVG9GcmVzbmVsMCggYmFzZUlPUiwgaXJpZGVzY2VuY2VJT1IgKTsKCQl2ZWMzIFIyMyA9IEZfU2NobGljayggUjEsIDEuMCwgY29zVGhldGEyICk7CgkJdmVjMyBwaGkyMyA9IHZlYzMoIDAuMCApOwoJCWlmICggYmFzZUlPUlsgMCBdIDwgaXJpZGVzY2VuY2VJT1IgKSBwaGkyM1sgMCBdID0gUEk7CgkJaWYgKCBiYXNlSU9SWyAxIF0gPCBpcmlkZXNjZW5jZUlPUiApIHBoaTIzWyAxIF0gPSBQSTsKCQlpZiAoIGJhc2VJT1JbIDIgXSA8IGlyaWRlc2NlbmNlSU9SICkgcGhpMjNbIDIgXSA9IFBJOwoJCWZsb2F0IE9QRCA9IDIuMCAqIGlyaWRlc2NlbmNlSU9SICogdGhpbkZpbG1UaGlja25lc3MgKiBjb3NUaGV0YTI7CgkJdmVjMyBwaGkgPSB2ZWMzKCBwaGkyMSApICsgcGhpMjM7CgkJdmVjMyBSMTIzID0gY2xhbXAoIFIxMiAqIFIyMywgMWUtNSwgMC45OTk5ICk7CgkJdmVjMyByMTIzID0gc3FydCggUjEyMyApOwoJCXZlYzMgUnMgPSBwb3cyKCBUMTIxICkgKiBSMjMgLyAoIHZlYzMoIDEuMCApIC0gUjEyMyApOwoJCXZlYzMgQzAgPSBSMTIgKyBSczsKCQlJID0gQzA7CgkJdmVjMyBDbSA9IFJzIC0gVDEyMTsKCQlmb3IgKCBpbnQgbSA9IDE7IG0gPD0gMjsgKysgbSApIHsKCQkJQ20gKj0gcjEyMzsKCQkJdmVjMyBTbSA9IDIuMCAqIGV2YWxTZW5zaXRpdml0eSggZmxvYXQoIG0gKSAqIE9QRCwgZmxvYXQoIG0gKSAqIHBoaSApOwoJCQlJICs9IENtICogU207CgkJfQoJCXJldHVybiBtYXgoIEksIHZlYzMoIDAuMCApICk7Cgl9CiNlbmRpZmAsSmE9YCNpZmRlZiBVU0VfQlVNUE1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgYnVtcE1hcDsKCXVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlOwoJdmVjMiBkSGR4eV9md2QoKSB7CgkJdmVjMiBkU1RkeCA9IGRGZHgoIHZCdW1wTWFwVXYgKTsKCQl2ZWMyIGRTVGR5ID0gZEZkeSggdkJ1bXBNYXBVdiApOwoJCWZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdkJ1bXBNYXBVdiApLng7CgkJZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2QnVtcE1hcFV2ICsgZFNUZHggKS54IC0gSGxsOwoJCWZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdkJ1bXBNYXBVdiArIGRTVGR5ICkueCAtIEhsbDsKCQlyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTsKCX0KCXZlYzMgcGVydHVyYk5vcm1hbEFyYiggdmVjMyBzdXJmX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgZEhkeHksIGZsb2F0IGZhY2VEaXJlY3Rpb24gKSB7CgkJdmVjMyB2U2lnbWFYID0gbm9ybWFsaXplKCBkRmR4KCBzdXJmX3Bvcy54eXogKSApOwoJCXZlYzMgdlNpZ21hWSA9IG5vcm1hbGl6ZSggZEZkeSggc3VyZl9wb3MueHl6ICkgKTsKCQl2ZWMzIHZOID0gc3VyZl9ub3JtOwoJCXZlYzMgUjEgPSBjcm9zcyggdlNpZ21hWSwgdk4gKTsKCQl2ZWMzIFIyID0gY3Jvc3MoIHZOLCB2U2lnbWFYICk7CgkJZmxvYXQgZkRldCA9IGRvdCggdlNpZ21hWCwgUjEgKSAqIGZhY2VEaXJlY3Rpb247CgkJdmVjMyB2R3JhZCA9IHNpZ24oIGZEZXQgKSAqICggZEhkeHkueCAqIFIxICsgZEhkeHkueSAqIFIyICk7CgkJcmV0dXJuIG5vcm1hbGl6ZSggYWJzKCBmRGV0ICkgKiBzdXJmX25vcm0gLSB2R3JhZCApOwoJfQojZW5kaWZgLFFhPWAjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDAKCXZlYzQgcGxhbmU7CgkjaWZkZWYgQUxQSEFfVE9fQ09WRVJBR0UKCQlmbG9hdCBkaXN0YW5jZVRvUGxhbmUsIGRpc3RhbmNlR3JhZGllbnQ7CgkJZmxvYXQgY2xpcE9wYWNpdHkgPSAxLjA7CgkJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJCWZvciAoIGludCBpID0gMDsgaSA8IFVOSU9OX0NMSVBQSU5HX1BMQU5FUzsgaSArKyApIHsKCQkJcGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdOwoJCQlkaXN0YW5jZVRvUGxhbmUgPSAtIGRvdCggdkNsaXBQb3NpdGlvbiwgcGxhbmUueHl6ICkgKyBwbGFuZS53OwoJCQlkaXN0YW5jZUdyYWRpZW50ID0gZndpZHRoKCBkaXN0YW5jZVRvUGxhbmUgKSAvIDIuMDsKCQkJY2xpcE9wYWNpdHkgKj0gc21vb3Roc3RlcCggLSBkaXN0YW5jZUdyYWRpZW50LCBkaXN0YW5jZUdyYWRpZW50LCBkaXN0YW5jZVRvUGxhbmUgKTsKCQkJaWYgKCBjbGlwT3BhY2l0eSA9PSAwLjAgKSBkaXNjYXJkOwoJCX0KCQkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJCSNpZiBVTklPTl9DTElQUElOR19QTEFORVMgPCBOVU1fQ0xJUFBJTkdfUExBTkVTCgkJCWZsb2F0IHVuaW9uQ2xpcE9wYWNpdHkgPSAxLjA7CgkJCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCQkJZm9yICggaW50IGkgPSBVTklPTl9DTElQUElOR19QTEFORVM7IGkgPCBOVU1fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkgewoJCQkJcGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdOwoJCQkJZGlzdGFuY2VUb1BsYW5lID0gLSBkb3QoIHZDbGlwUG9zaXRpb24sIHBsYW5lLnh5eiApICsgcGxhbmUudzsKCQkJCWRpc3RhbmNlR3JhZGllbnQgPSBmd2lkdGgoIGRpc3RhbmNlVG9QbGFuZSApIC8gMi4wOwoJCQkJdW5pb25DbGlwT3BhY2l0eSAqPSAxLjAgLSBzbW9vdGhzdGVwKCAtIGRpc3RhbmNlR3JhZGllbnQsIGRpc3RhbmNlR3JhZGllbnQsIGRpc3RhbmNlVG9QbGFuZSApOwoJCQl9CgkJCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCgkJCWNsaXBPcGFjaXR5ICo9IDEuMCAtIHVuaW9uQ2xpcE9wYWNpdHk7CgkJI2VuZGlmCgkJZGlmZnVzZUNvbG9yLmEgKj0gY2xpcE9wYWNpdHk7CgkJaWYgKCBkaWZmdXNlQ29sb3IuYSA9PSAwLjAgKSBkaXNjYXJkOwoJI2Vsc2UKCQkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0CgkJZm9yICggaW50IGkgPSAwOyBpIDwgVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkgewoJCQlwbGFuZSA9IGNsaXBwaW5nUGxhbmVzWyBpIF07CgkJCWlmICggZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSBkaXNjYXJkOwoJCX0KCQkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJCSNpZiBVTklPTl9DTElQUElOR19QTEFORVMgPCBOVU1fQ0xJUFBJTkdfUExBTkVTCgkJCWJvb2wgY2xpcHBlZCA9IHRydWU7CgkJCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCQkJZm9yICggaW50IGkgPSBVTklPTl9DTElQUElOR19QTEFORVM7IGkgPCBOVU1fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkgewoJCQkJcGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdOwoJCQkJY2xpcHBlZCA9ICggZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSAmJiBjbGlwcGVkOwoJCQl9CgkJCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCgkJCWlmICggY2xpcHBlZCApIGRpc2NhcmQ7CgkJI2VuZGlmCgkjZW5kaWYKI2VuZGlmYCxlbz1gI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwCgl2YXJ5aW5nIHZlYzMgdkNsaXBQb3NpdGlvbjsKCXVuaWZvcm0gdmVjNCBjbGlwcGluZ1BsYW5lc1sgTlVNX0NMSVBQSU5HX1BMQU5FUyBdOwojZW5kaWZgLHRvPWAjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDAKCXZhcnlpbmcgdmVjMyB2Q2xpcFBvc2l0aW9uOwojZW5kaWZgLG5vPWAjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDAKCXZDbGlwUG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6OwojZW5kaWZgLGlvPWAjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBICkKCWRpZmZ1c2VDb2xvciAqPSB2Q29sb3I7CiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApCglkaWZmdXNlQ29sb3IucmdiICo9IHZDb2xvcjsKI2VuZGlmYCxybz1gI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApCgl2YXJ5aW5nIHZlYzQgdkNvbG9yOwojZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKQoJdmFyeWluZyB2ZWMzIHZDb2xvcjsKI2VuZGlmYCxzbz1gI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApCgl2YXJ5aW5nIHZlYzQgdkNvbG9yOwojZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfSU5TVEFOQ0lOR19DT0xPUiApIHx8IGRlZmluZWQoIFVTRV9CQVRDSElOR19DT0xPUiApCgl2YXJ5aW5nIHZlYzMgdkNvbG9yOwojZW5kaWZgLGFvPWAjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBICkKCXZDb2xvciA9IHZlYzQoIDEuMCApOwojZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfSU5TVEFOQ0lOR19DT0xPUiApIHx8IGRlZmluZWQoIFVTRV9CQVRDSElOR19DT0xPUiApCgl2Q29sb3IgPSB2ZWMzKCAxLjAgKTsKI2VuZGlmCiNpZmRlZiBVU0VfQ09MT1IKCXZDb2xvciAqPSBjb2xvcjsKI2VuZGlmCiNpZmRlZiBVU0VfSU5TVEFOQ0lOR19DT0xPUgoJdkNvbG9yLnh5eiAqPSBpbnN0YW5jZUNvbG9yLnh5ejsKI2VuZGlmCiNpZmRlZiBVU0VfQkFUQ0hJTkdfQ09MT1IKCXZlYzMgYmF0Y2hpbmdDb2xvciA9IGdldEJhdGNoaW5nQ29sb3IoIGdldEluZGlyZWN0SW5kZXgoIGdsX0RyYXdJRCApICk7Cgl2Q29sb3IueHl6ICo9IGJhdGNoaW5nQ29sb3IueHl6OwojZW5kaWZgLG9vPWAjZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTg5NzkzCiNkZWZpbmUgUEkyIDYuMjgzMTg1MzA3MTc5NTg2CiNkZWZpbmUgUElfSEFMRiAxLjU3MDc5NjMyNjc5NDg5NjYKI2RlZmluZSBSRUNJUFJPQ0FMX1BJIDAuMzE4MzA5ODg2MTgzNzkwNwojZGVmaW5lIFJFQ0lQUk9DQUxfUEkyIDAuMTU5MTU0OTQzMDkxODk1MzUKI2RlZmluZSBFUFNJTE9OIDFlLTYKI2lmbmRlZiBzYXR1cmF0ZQojZGVmaW5lIHNhdHVyYXRlKCBhICkgY2xhbXAoIGEsIDAuMCwgMS4wICkKI2VuZGlmCiNkZWZpbmUgd2hpdGVDb21wbGVtZW50KCBhICkgKCAxLjAgLSBzYXR1cmF0ZSggYSApICkKZmxvYXQgcG93MiggY29uc3QgaW4gZmxvYXQgeCApIHsgcmV0dXJuIHgqeDsgfQp2ZWMzIHBvdzIoIGNvbnN0IGluIHZlYzMgeCApIHsgcmV0dXJuIHgqeDsgfQpmbG9hdCBwb3czKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4Kng7IH0KZmxvYXQgcG93NCggY29uc3QgaW4gZmxvYXQgeCApIHsgZmxvYXQgeDIgPSB4Kng7IHJldHVybiB4Mip4MjsgfQpmbG9hdCBtYXgzKCBjb25zdCBpbiB2ZWMzIHYgKSB7IHJldHVybiBtYXgoIG1heCggdi54LCB2LnkgKSwgdi56ICk7IH0KZmxvYXQgYXZlcmFnZSggY29uc3QgaW4gdmVjMyB2ICkgeyByZXR1cm4gZG90KCB2LCB2ZWMzKCAwLjMzMzMzMzMgKSApOyB9CmhpZ2hwIGZsb2F0IHJhbmQoIGNvbnN0IGluIHZlYzIgdXYgKSB7Cgljb25zdCBoaWdocCBmbG9hdCBhID0gMTIuOTg5OCwgYiA9IDc4LjIzMywgYyA9IDQzNzU4LjU0NTM7CgloaWdocCBmbG9hdCBkdCA9IGRvdCggdXYueHksIHZlYzIoIGEsYiApICksIHNuID0gbW9kKCBkdCwgUEkgKTsKCXJldHVybiBmcmFjdCggc2luKCBzbiApICogYyApOwp9CiNpZmRlZiBISUdIX1BSRUNJU0lPTgoJZmxvYXQgcHJlY2lzaW9uU2FmZUxlbmd0aCggdmVjMyB2ICkgeyByZXR1cm4gbGVuZ3RoKCB2ICk7IH0KI2Vsc2UKCWZsb2F0IHByZWNpc2lvblNhZmVMZW5ndGgoIHZlYzMgdiApIHsKCQlmbG9hdCBtYXhDb21wb25lbnQgPSBtYXgzKCBhYnMoIHYgKSApOwoJCXJldHVybiBsZW5ndGgoIHYgLyBtYXhDb21wb25lbnQgKSAqIG1heENvbXBvbmVudDsKCX0KI2VuZGlmCnN0cnVjdCBJbmNpZGVudExpZ2h0IHsKCXZlYzMgY29sb3I7Cgl2ZWMzIGRpcmVjdGlvbjsKCWJvb2wgdmlzaWJsZTsKfTsKc3RydWN0IFJlZmxlY3RlZExpZ2h0IHsKCXZlYzMgZGlyZWN0RGlmZnVzZTsKCXZlYzMgZGlyZWN0U3BlY3VsYXI7Cgl2ZWMzIGluZGlyZWN0RGlmZnVzZTsKCXZlYzMgaW5kaXJlY3RTcGVjdWxhcjsKfTsKI2lmZGVmIFVTRV9BTFBIQUhBU0gKCXZhcnlpbmcgdmVjMyB2UG9zaXRpb247CiNlbmRpZgp2ZWMzIHRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkgewoJcmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7Cn0KdmVjMyBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7CglyZXR1cm4gbm9ybWFsaXplKCAoIHZlYzQoIGRpciwgMC4wICkgKiBtYXRyaXggKS54eXogKTsKfQptYXQzIHRyYW5zcG9zZU1hdDMoIGNvbnN0IGluIG1hdDMgbSApIHsKCW1hdDMgdG1wOwoJdG1wWyAwIF0gPSB2ZWMzKCBtWyAwIF0ueCwgbVsgMSBdLngsIG1bIDIgXS54ICk7Cgl0bXBbIDEgXSA9IHZlYzMoIG1bIDAgXS55LCBtWyAxIF0ueSwgbVsgMiBdLnkgKTsKCXRtcFsgMiBdID0gdmVjMyggbVsgMCBdLnosIG1bIDEgXS56LCBtWyAyIF0ueiApOwoJcmV0dXJuIHRtcDsKfQpib29sIGlzUGVyc3BlY3RpdmVNYXRyaXgoIG1hdDQgbSApIHsKCXJldHVybiBtWyAyIF1bIDMgXSA9PSAtIDEuMDsKfQp2ZWMyIGVxdWlyZWN0VXYoIGluIHZlYzMgZGlyICkgewoJZmxvYXQgdSA9IGF0YW4oIGRpci56LCBkaXIueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7CglmbG9hdCB2ID0gYXNpbiggY2xhbXAoIGRpci55LCAtIDEuMCwgMS4wICkgKSAqIFJFQ0lQUk9DQUxfUEkgKyAwLjU7CglyZXR1cm4gdmVjMiggdSwgdiApOwp9CnZlYzMgQlJERl9MYW1iZXJ0KCBjb25zdCBpbiB2ZWMzIGRpZmZ1c2VDb2xvciApIHsKCXJldHVybiBSRUNJUFJPQ0FMX1BJICogZGlmZnVzZUNvbG9yOwp9CnZlYzMgRl9TY2hsaWNrKCBjb25zdCBpbiB2ZWMzIGYwLCBjb25zdCBpbiBmbG9hdCBmOTAsIGNvbnN0IGluIGZsb2F0IGRvdFZIICkgewoJZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLSA1LjU1NDczICogZG90VkggLSA2Ljk4MzE2ICkgKiBkb3RWSCApOwoJcmV0dXJuIGYwICogKCAxLjAgLSBmcmVzbmVsICkgKyAoIGY5MCAqIGZyZXNuZWwgKTsKfQpmbG9hdCBGX1NjaGxpY2soIGNvbnN0IGluIGZsb2F0IGYwLCBjb25zdCBpbiBmbG9hdCBmOTAsIGNvbnN0IGluIGZsb2F0IGRvdFZIICkgewoJZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLSA1LjU1NDczICogZG90VkggLSA2Ljk4MzE2ICkgKiBkb3RWSCApOwoJcmV0dXJuIGYwICogKCAxLjAgLSBmcmVzbmVsICkgKyAoIGY5MCAqIGZyZXNuZWwgKTsKfSAvLyB2YWxpZGF0ZWRgLGxvPWAjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRV9VVgoJI2RlZmluZSBjdWJlVVZfbWluTWlwTGV2ZWwgNC4wCgkjZGVmaW5lIGN1YmVVVl9taW5UaWxlU2l6ZSAxNi4wCglmbG9hdCBnZXRGYWNlKCB2ZWMzIGRpcmVjdGlvbiApIHsKCQl2ZWMzIGFic0RpcmVjdGlvbiA9IGFicyggZGlyZWN0aW9uICk7CgkJZmxvYXQgZmFjZSA9IC0gMS4wOwoJCWlmICggYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueiApIHsKCQkJaWYgKCBhYnNEaXJlY3Rpb24ueCA+IGFic0RpcmVjdGlvbi55ICkKCQkJCWZhY2UgPSBkaXJlY3Rpb24ueCA+IDAuMCA/IDAuMCA6IDMuMDsKCQkJZWxzZQoJCQkJZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMS4wIDogNC4wOwoJCX0gZWxzZSB7CgkJCWlmICggYWJzRGlyZWN0aW9uLnogPiBhYnNEaXJlY3Rpb24ueSApCgkJCQlmYWNlID0gZGlyZWN0aW9uLnogPiAwLjAgPyAyLjAgOiA1LjA7CgkJCWVsc2UKCQkJCWZhY2UgPSBkaXJlY3Rpb24ueSA+IDAuMCA/IDEuMCA6IDQuMDsKCQl9CgkJcmV0dXJuIGZhY2U7Cgl9Cgl2ZWMyIGdldFVWKCB2ZWMzIGRpcmVjdGlvbiwgZmxvYXQgZmFjZSApIHsKCQl2ZWMyIHV2OwoJCWlmICggZmFjZSA9PSAwLjAgKSB7CgkJCXV2ID0gdmVjMiggZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi54ICk7CgkJfSBlbHNlIGlmICggZmFjZSA9PSAxLjAgKSB7CgkJCXV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueCwgLSBkaXJlY3Rpb24ueiApIC8gYWJzKCBkaXJlY3Rpb24ueSApOwoJCX0gZWxzZSBpZiAoIGZhY2UgPT0gMi4wICkgewoJCQl1diA9IHZlYzIoIC0gZGlyZWN0aW9uLngsIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi56ICk7CgkJfSBlbHNlIGlmICggZmFjZSA9PSAzLjAgKSB7CgkJCXV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnggKTsKCQl9IGVsc2UgaWYgKCBmYWNlID09IDQuMCApIHsKCQkJdXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueiApIC8gYWJzKCBkaXJlY3Rpb24ueSApOwoJCX0gZWxzZSB7CgkJCXV2ID0gdmVjMiggZGlyZWN0aW9uLngsIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi56ICk7CgkJfQoJCXJldHVybiAwLjUgKiAoIHV2ICsgMS4wICk7Cgl9Cgl2ZWMzIGJpbGluZWFyQ3ViZVVWKCBzYW1wbGVyMkQgZW52TWFwLCB2ZWMzIGRpcmVjdGlvbiwgZmxvYXQgbWlwSW50ICkgewoJCWZsb2F0IGZhY2UgPSBnZXRGYWNlKCBkaXJlY3Rpb24gKTsKCQlmbG9hdCBmaWx0ZXJJbnQgPSBtYXgoIGN1YmVVVl9taW5NaXBMZXZlbCAtIG1pcEludCwgMC4wICk7CgkJbWlwSW50ID0gbWF4KCBtaXBJbnQsIGN1YmVVVl9taW5NaXBMZXZlbCApOwoJCWZsb2F0IGZhY2VTaXplID0gZXhwMiggbWlwSW50ICk7CgkJaGlnaHAgdmVjMiB1diA9IGdldFVWKCBkaXJlY3Rpb24sIGZhY2UgKSAqICggZmFjZVNpemUgLSAyLjAgKSArIDEuMDsKCQlpZiAoIGZhY2UgPiAyLjAgKSB7CgkJCXV2LnkgKz0gZmFjZVNpemU7CgkJCWZhY2UgLT0gMy4wOwoJCX0KCQl1di54ICs9IGZhY2UgKiBmYWNlU2l6ZTsKCQl1di54ICs9IGZpbHRlckludCAqIDMuMCAqIGN1YmVVVl9taW5UaWxlU2l6ZTsKCQl1di55ICs9IDQuMCAqICggZXhwMiggQ1VCRVVWX01BWF9NSVAgKSAtIGZhY2VTaXplICk7CgkJdXYueCAqPSBDVUJFVVZfVEVYRUxfV0lEVEg7CgkJdXYueSAqPSBDVUJFVVZfVEVYRUxfSEVJR0hUOwoJCSNpZmRlZiB0ZXh0dXJlMkRHcmFkRVhUCgkJCXJldHVybiB0ZXh0dXJlMkRHcmFkRVhUKCBlbnZNYXAsIHV2LCB2ZWMyKCAwLjAgKSwgdmVjMiggMC4wICkgKS5yZ2I7CgkJI2Vsc2UKCQkJcmV0dXJuIHRleHR1cmUyRCggZW52TWFwLCB1diApLnJnYjsKCQkjZW5kaWYKCX0KCSNkZWZpbmUgY3ViZVVWX3IwIDEuMAoJI2RlZmluZSBjdWJlVVZfbTAgLSAyLjAKCSNkZWZpbmUgY3ViZVVWX3IxIDAuOAoJI2RlZmluZSBjdWJlVVZfbTEgLSAxLjAKCSNkZWZpbmUgY3ViZVVWX3I0IDAuNAoJI2RlZmluZSBjdWJlVVZfbTQgMi4wCgkjZGVmaW5lIGN1YmVVVl9yNSAwLjMwNQoJI2RlZmluZSBjdWJlVVZfbTUgMy4wCgkjZGVmaW5lIGN1YmVVVl9yNiAwLjIxCgkjZGVmaW5lIGN1YmVVVl9tNiA0LjAKCWZsb2F0IHJvdWdobmVzc1RvTWlwKCBmbG9hdCByb3VnaG5lc3MgKSB7CgkJZmxvYXQgbWlwID0gMC4wOwoJCWlmICggcm91Z2huZXNzID49IGN1YmVVVl9yMSApIHsKCQkJbWlwID0gKCBjdWJlVVZfcjAgLSByb3VnaG5lc3MgKSAqICggY3ViZVVWX20xIC0gY3ViZVVWX20wICkgLyAoIGN1YmVVVl9yMCAtIGN1YmVVVl9yMSApICsgY3ViZVVWX20wOwoJCX0gZWxzZSBpZiAoIHJvdWdobmVzcyA+PSBjdWJlVVZfcjQgKSB7CgkJCW1pcCA9ICggY3ViZVVWX3IxIC0gcm91Z2huZXNzICkgKiAoIGN1YmVVVl9tNCAtIGN1YmVVVl9tMSApIC8gKCBjdWJlVVZfcjEgLSBjdWJlVVZfcjQgKSArIGN1YmVVVl9tMTsKCQl9IGVsc2UgaWYgKCByb3VnaG5lc3MgPj0gY3ViZVVWX3I1ICkgewoJCQltaXAgPSAoIGN1YmVVVl9yNCAtIHJvdWdobmVzcyApICogKCBjdWJlVVZfbTUgLSBjdWJlVVZfbTQgKSAvICggY3ViZVVWX3I0IC0gY3ViZVVWX3I1ICkgKyBjdWJlVVZfbTQ7CgkJfSBlbHNlIGlmICggcm91Z2huZXNzID49IGN1YmVVVl9yNiApIHsKCQkJbWlwID0gKCBjdWJlVVZfcjUgLSByb3VnaG5lc3MgKSAqICggY3ViZVVWX202IC0gY3ViZVVWX201ICkgLyAoIGN1YmVVVl9yNSAtIGN1YmVVVl9yNiApICsgY3ViZVVWX201OwoJCX0gZWxzZSB7CgkJCW1pcCA9IC0gMi4wICogbG9nMiggMS4xNiAqIHJvdWdobmVzcyApOwkJfQoJCXJldHVybiBtaXA7Cgl9Cgl2ZWM0IHRleHR1cmVDdWJlVVYoIHNhbXBsZXIyRCBlbnZNYXAsIHZlYzMgc2FtcGxlRGlyLCBmbG9hdCByb3VnaG5lc3MgKSB7CgkJZmxvYXQgbWlwID0gY2xhbXAoIHJvdWdobmVzc1RvTWlwKCByb3VnaG5lc3MgKSwgY3ViZVVWX20wLCBDVUJFVVZfTUFYX01JUCApOwoJCWZsb2F0IG1pcEYgPSBmcmFjdCggbWlwICk7CgkJZmxvYXQgbWlwSW50ID0gZmxvb3IoIG1pcCApOwoJCXZlYzMgY29sb3IwID0gYmlsaW5lYXJDdWJlVVYoIGVudk1hcCwgc2FtcGxlRGlyLCBtaXBJbnQgKTsKCQlpZiAoIG1pcEYgPT0gMC4wICkgewoJCQlyZXR1cm4gdmVjNCggY29sb3IwLCAxLjAgKTsKCQl9IGVsc2UgewoJCQl2ZWMzIGNvbG9yMSA9IGJpbGluZWFyQ3ViZVVWKCBlbnZNYXAsIHNhbXBsZURpciwgbWlwSW50ICsgMS4wICk7CgkJCXJldHVybiB2ZWM0KCBtaXgoIGNvbG9yMCwgY29sb3IxLCBtaXBGICksIDEuMCApOwoJCX0KCX0KI2VuZGlmYCxjbz1gdmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG9iamVjdE5vcm1hbDsKI2lmZGVmIFVTRV9UQU5HRU5UCgl2ZWMzIHRyYW5zZm9ybWVkVGFuZ2VudCA9IG9iamVjdFRhbmdlbnQ7CiNlbmRpZgojaWZkZWYgVVNFX0JBVENISU5HCgltYXQzIGJtID0gbWF0MyggYmF0Y2hpbmdNYXRyaXggKTsKCXRyYW5zZm9ybWVkTm9ybWFsIC89IHZlYzMoIGRvdCggYm1bIDAgXSwgYm1bIDAgXSApLCBkb3QoIGJtWyAxIF0sIGJtWyAxIF0gKSwgZG90KCBibVsgMiBdLCBibVsgMiBdICkgKTsKCXRyYW5zZm9ybWVkTm9ybWFsID0gYm0gKiB0cmFuc2Zvcm1lZE5vcm1hbDsKCSNpZmRlZiBVU0VfVEFOR0VOVAoJCXRyYW5zZm9ybWVkVGFuZ2VudCA9IGJtICogdHJhbnNmb3JtZWRUYW5nZW50OwoJI2VuZGlmCiNlbmRpZgojaWZkZWYgVVNFX0lOU1RBTkNJTkcKCW1hdDMgaW0gPSBtYXQzKCBpbnN0YW5jZU1hdHJpeCApOwoJdHJhbnNmb3JtZWROb3JtYWwgLz0gdmVjMyggZG90KCBpbVsgMCBdLCBpbVsgMCBdICksIGRvdCggaW1bIDEgXSwgaW1bIDEgXSApLCBkb3QoIGltWyAyIF0sIGltWyAyIF0gKSApOwoJdHJhbnNmb3JtZWROb3JtYWwgPSBpbSAqIHRyYW5zZm9ybWVkTm9ybWFsOwoJI2lmZGVmIFVTRV9UQU5HRU5UCgkJdHJhbnNmb3JtZWRUYW5nZW50ID0gaW0gKiB0cmFuc2Zvcm1lZFRhbmdlbnQ7CgkjZW5kaWYKI2VuZGlmCnRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogdHJhbnNmb3JtZWROb3JtYWw7CiNpZmRlZiBGTElQX1NJREVECgl0cmFuc2Zvcm1lZE5vcm1hbCA9IC0gdHJhbnNmb3JtZWROb3JtYWw7CiNlbmRpZgojaWZkZWYgVVNFX1RBTkdFTlQKCXRyYW5zZm9ybWVkVGFuZ2VudCA9ICggbW9kZWxWaWV3TWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWRUYW5nZW50LCAwLjAgKSApLnh5ejsKCSNpZmRlZiBGTElQX1NJREVECgkJdHJhbnNmb3JtZWRUYW5nZW50ID0gLSB0cmFuc2Zvcm1lZFRhbmdlbnQ7CgkjZW5kaWYKI2VuZGlmYCx1bz1gI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIGRpc3BsYWNlbWVudE1hcDsKCXVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50U2NhbGU7Cgl1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudEJpYXM7CiNlbmRpZmAsaG89YCNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQCgl0cmFuc2Zvcm1lZCArPSBub3JtYWxpemUoIG9iamVjdE5vcm1hbCApICogKCB0ZXh0dXJlMkQoIGRpc3BsYWNlbWVudE1hcCwgdkRpc3BsYWNlbWVudE1hcFV2ICkueCAqIGRpc3BsYWNlbWVudFNjYWxlICsgZGlzcGxhY2VtZW50QmlhcyApOwojZW5kaWZgLGZvPWAjaWZkZWYgVVNFX0VNSVNTSVZFTUFQCgl2ZWM0IGVtaXNzaXZlQ29sb3IgPSB0ZXh0dXJlMkQoIGVtaXNzaXZlTWFwLCB2RW1pc3NpdmVNYXBVdiApOwoJI2lmZGVmIERFQ09ERV9WSURFT19URVhUVVJFX0VNSVNTSVZFCgkJZW1pc3NpdmVDb2xvciA9IHNSR0JUcmFuc2ZlckVPVEYoIGVtaXNzaXZlQ29sb3IgKTsKCSNlbmRpZgoJdG90YWxFbWlzc2l2ZVJhZGlhbmNlICo9IGVtaXNzaXZlQ29sb3IucmdiOwojZW5kaWZgLHBvPWAjaWZkZWYgVVNFX0VNSVNTSVZFTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2l2ZU1hcDsKI2VuZGlmYCxtbz0iZ2xfRnJhZ0NvbG9yID0gbGluZWFyVG9PdXRwdXRUZXhlbCggZ2xfRnJhZ0NvbG9yICk7Iixnbz1gdmVjNCBMaW5lYXJUcmFuc2Zlck9FVEYoIGluIHZlYzQgdmFsdWUgKSB7CglyZXR1cm4gdmFsdWU7Cn0KdmVjNCBzUkdCVHJhbnNmZXJFT1RGKCBpbiB2ZWM0IHZhbHVlICkgewoJcmV0dXJuIHZlYzQoIG1peCggcG93KCB2YWx1ZS5yZ2IgKiAwLjk0Nzg2NzI5ODYgKyB2ZWMzKCAwLjA1MjEzMjcwMTQgKSwgdmVjMyggMi40ICkgKSwgdmFsdWUucmdiICogMC4wNzczOTkzODA4LCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDQwNDUgKSApICkgKSwgdmFsdWUuYSApOwp9CnZlYzQgc1JHQlRyYW5zZmVyT0VURiggaW4gdmVjNCB2YWx1ZSApIHsKCXJldHVybiB2ZWM0KCBtaXgoIHBvdyggdmFsdWUucmdiLCB2ZWMzKCAwLjQxNjY2ICkgKSAqIDEuMDU1IC0gdmVjMyggMC4wNTUgKSwgdmFsdWUucmdiICogMTIuOTIsIHZlYzMoIGxlc3NUaGFuRXF1YWwoIHZhbHVlLnJnYiwgdmVjMyggMC4wMDMxMzA4ICkgKSApICksIHZhbHVlLmEgKTsKfWAsX289YCNpZmRlZiBVU0VfRU5WTUFQCgkjaWZkZWYgRU5WX1dPUkxEUE9TCgkJdmVjMyBjYW1lcmFUb0ZyYWc7CgkJaWYgKCBpc09ydGhvZ3JhcGhpYyApIHsKCQkJY2FtZXJhVG9GcmFnID0gbm9ybWFsaXplKCB2ZWMzKCAtIHZpZXdNYXRyaXhbIDAgXVsgMiBdLCAtIHZpZXdNYXRyaXhbIDEgXVsgMiBdLCAtIHZpZXdNYXRyaXhbIDIgXVsgMiBdICkgKTsKCQl9IGVsc2UgewoJCQljYW1lcmFUb0ZyYWcgPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTsKCQl9CgkJdmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApOwoJCSNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OCgkJCXZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIGNhbWVyYVRvRnJhZywgd29ybGROb3JtYWwgKTsKCQkjZWxzZQoJCQl2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCBjYW1lcmFUb0ZyYWcsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTsKCQkjZW5kaWYKCSNlbHNlCgkJdmVjMyByZWZsZWN0VmVjID0gdlJlZmxlY3Q7CgkjZW5kaWYKCSNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFCgkJdmVjNCBlbnZDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIGVudk1hcFJvdGF0aW9uICogdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7CgkjZWxzZQoJCXZlYzQgZW52Q29sb3IgPSB2ZWM0KCAwLjAgKTsKCSNlbmRpZgoJI2lmZGVmIEVOVk1BUF9CTEVORElOR19NVUxUSVBMWQoJCW91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIG91dGdvaW5nTGlnaHQgKiBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTsKCSNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19NSVggKQoJCW91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApOwoJI2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX0FERCApCgkJb3V0Z29pbmdMaWdodCArPSBlbnZDb2xvci54eXogKiBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5OwoJI2VuZGlmCiNlbmRpZmAsdm89YCNpZmRlZiBVU0VfRU5WTUFQCgl1bmlmb3JtIGZsb2F0IGVudk1hcEludGVuc2l0eTsKCXVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDsKCXVuaWZvcm0gbWF0MyBlbnZNYXBSb3RhdGlvbjsKCSNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFCgkJdW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7CgkjZWxzZQoJCXVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDsKCSNlbmRpZgoJCiNlbmRpZmAseG89YCNpZmRlZiBVU0VfRU5WTUFQCgl1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTsKCSNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIExBTUJFUlQgKQoJCSNkZWZpbmUgRU5WX1dPUkxEUE9TCgkjZW5kaWYKCSNpZmRlZiBFTlZfV09STERQT1MKCQl2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247CgkJdW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87CgkjZWxzZQoJCXZhcnlpbmcgdmVjMyB2UmVmbGVjdDsKCSNlbmRpZgojZW5kaWZgLE1vPWAjaWZkZWYgVVNFX0VOVk1BUAoJI2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggTEFNQkVSVCApCgkJI2RlZmluZSBFTlZfV09STERQT1MKCSNlbmRpZgoJI2lmZGVmIEVOVl9XT1JMRFBPUwoJCQoJCXZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjsKCSNlbHNlCgkJdmFyeWluZyB2ZWMzIHZSZWZsZWN0OwoJCXVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvOwoJI2VuZGlmCiNlbmRpZmAsU289YCNpZmRlZiBVU0VfRU5WTUFQCgkjaWZkZWYgRU5WX1dPUkxEUE9TCgkJdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejsKCSNlbHNlCgkJdmVjMyBjYW1lcmFUb1ZlcnRleDsKCQlpZiAoIGlzT3J0aG9ncmFwaGljICkgewoJCQljYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggdmVjMyggLSB2aWV3TWF0cml4WyAwIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAxIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAyIF1bIDIgXSApICk7CgkJfSBlbHNlIHsKCQkJY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHdvcmxkUG9zaXRpb24ueHl6IC0gY2FtZXJhUG9zaXRpb24gKTsKCQl9CgkJdmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHRyYW5zZm9ybWVkTm9ybWFsLCB2aWV3TWF0cml4ICk7CgkJI2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT04KCQkJdlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTsKCQkjZWxzZQoJCQl2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7CgkJI2VuZGlmCgkjZW5kaWYKI2VuZGlmYCxFbz1gI2lmZGVmIFVTRV9GT0cKCXZGb2dEZXB0aCA9IC0gbXZQb3NpdGlvbi56OwojZW5kaWZgLHlvPWAjaWZkZWYgVVNFX0ZPRwoJdmFyeWluZyBmbG9hdCB2Rm9nRGVwdGg7CiNlbmRpZmAsVG89YCNpZmRlZiBVU0VfRk9HCgkjaWZkZWYgRk9HX0VYUDIKCQlmbG9hdCBmb2dGYWN0b3IgPSAxLjAgLSBleHAoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiB2Rm9nRGVwdGggKiB2Rm9nRGVwdGggKTsKCSNlbHNlCgkJZmxvYXQgZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCB2Rm9nRGVwdGggKTsKCSNlbmRpZgoJZ2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggZ2xfRnJhZ0NvbG9yLnJnYiwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApOwojZW5kaWZgLEFvPWAjaWZkZWYgVVNFX0ZPRwoJdW5pZm9ybSB2ZWMzIGZvZ0NvbG9yOwoJdmFyeWluZyBmbG9hdCB2Rm9nRGVwdGg7CgkjaWZkZWYgRk9HX0VYUDIKCQl1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7CgkjZWxzZQoJCXVuaWZvcm0gZmxvYXQgZm9nTmVhcjsKCQl1bmlmb3JtIGZsb2F0IGZvZ0ZhcjsKCSNlbmRpZgojZW5kaWZgLHdvPWAjaWZkZWYgVVNFX0dSQURJRU5UTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBncmFkaWVudE1hcDsKI2VuZGlmCnZlYzMgZ2V0R3JhZGllbnRJcnJhZGlhbmNlKCB2ZWMzIG5vcm1hbCwgdmVjMyBsaWdodERpcmVjdGlvbiApIHsKCWZsb2F0IGRvdE5MID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyZWN0aW9uICk7Cgl2ZWMyIGNvb3JkID0gdmVjMiggZG90TkwgKiAwLjUgKyAwLjUsIDAuMCApOwoJI2lmZGVmIFVTRV9HUkFESUVOVE1BUAoJCXJldHVybiB2ZWMzKCB0ZXh0dXJlMkQoIGdyYWRpZW50TWFwLCBjb29yZCApLnIgKTsKCSNlbHNlCgkJdmVjMiBmdyA9IGZ3aWR0aCggY29vcmQgKSAqIDAuNTsKCQlyZXR1cm4gbWl4KCB2ZWMzKCAwLjcgKSwgdmVjMyggMS4wICksIHNtb290aHN0ZXAoIDAuNyAtIGZ3LngsIDAuNyArIGZ3LngsIGNvb3JkLnggKSApOwoJI2VuZGlmCn1gLGJvPWAjaWZkZWYgVVNFX0xJR0hUTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBsaWdodE1hcDsKCXVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7CiNlbmRpZmAsUm89YExhbWJlcnRNYXRlcmlhbCBtYXRlcmlhbDsKbWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjsKbWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aCA9IHNwZWN1bGFyU3RyZW5ndGg7YCxDbz1gdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CnN0cnVjdCBMYW1iZXJ0TWF0ZXJpYWwgewoJdmVjMyBkaWZmdXNlQ29sb3I7CglmbG9hdCBzcGVjdWxhclN0cmVuZ3RoOwp9Owp2b2lkIFJFX0RpcmVjdF9MYW1iZXJ0KCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBMYW1iZXJ0TWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkgewoJZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeU5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTsKCXZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7CglyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApOwp9CnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX0xhbWJlcnQoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gTGFtYmVydE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHsKCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTsKfQojZGVmaW5lIFJFX0RpcmVjdAkJCQlSRV9EaXJlY3RfTGFtYmVydAojZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZQkJUkVfSW5kaXJlY3REaWZmdXNlX0xhbWJlcnRgLFBvPWB1bmlmb3JtIGJvb2wgcmVjZWl2ZVNoYWRvdzsKdW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yOwojaWYgZGVmaW5lZCggVVNFX0xJR0hUX1BST0JFUyApCgl1bmlmb3JtIHZlYzMgbGlnaHRQcm9iZVsgOSBdOwojZW5kaWYKdmVjMyBzaEdldElycmFkaWFuY2VBdCggaW4gdmVjMyBub3JtYWwsIGluIHZlYzMgc2hDb2VmZmljaWVudHNbIDkgXSApIHsKCWZsb2F0IHggPSBub3JtYWwueCwgeSA9IG5vcm1hbC55LCB6ID0gbm9ybWFsLno7Cgl2ZWMzIHJlc3VsdCA9IHNoQ29lZmZpY2llbnRzWyAwIF0gKiAwLjg4NjIyNzsKCXJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgMSBdICogMi4wICogMC41MTE2NjQgKiB5OwoJcmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAyIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHo7CglyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDMgXSAqIDIuMCAqIDAuNTExNjY0ICogeDsKCXJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNCBdICogMi4wICogMC40MjkwNDMgKiB4ICogeTsKCXJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNSBdICogMi4wICogMC40MjkwNDMgKiB5ICogejsKCXJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNiBdICogKCAwLjc0MzEyNSAqIHogKiB6IC0gMC4yNDc3MDggKTsKCXJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNyBdICogMi4wICogMC40MjkwNDMgKiB4ICogejsKCXJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgOCBdICogMC40MjkwNDMgKiAoIHggKiB4IC0geSAqIHkgKTsKCXJldHVybiByZXN1bHQ7Cn0KdmVjMyBnZXRMaWdodFByb2JlSXJyYWRpYW5jZSggY29uc3QgaW4gdmVjMyBsaWdodFByb2JlWyA5IF0sIGNvbnN0IGluIHZlYzMgbm9ybWFsICkgewoJdmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApOwoJdmVjMyBpcnJhZGlhbmNlID0gc2hHZXRJcnJhZGlhbmNlQXQoIHdvcmxkTm9ybWFsLCBsaWdodFByb2JlICk7CglyZXR1cm4gaXJyYWRpYW5jZTsKfQp2ZWMzIGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgYW1iaWVudExpZ2h0Q29sb3IgKSB7Cgl2ZWMzIGlycmFkaWFuY2UgPSBhbWJpZW50TGlnaHRDb2xvcjsKCXJldHVybiBpcnJhZGlhbmNlOwp9CmZsb2F0IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIGNvbnN0IGluIGZsb2F0IGxpZ2h0RGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGN1dG9mZkRpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBkZWNheUV4cG9uZW50ICkgewoJZmxvYXQgZGlzdGFuY2VGYWxsb2ZmID0gMS4wIC8gbWF4KCBwb3coIGxpZ2h0RGlzdGFuY2UsIGRlY2F5RXhwb25lbnQgKSwgMC4wMSApOwoJaWYgKCBjdXRvZmZEaXN0YW5jZSA+IDAuMCApIHsKCQlkaXN0YW5jZUZhbGxvZmYgKj0gcG93Miggc2F0dXJhdGUoIDEuMCAtIHBvdzQoIGxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSApICkgKTsKCX0KCXJldHVybiBkaXN0YW5jZUZhbGxvZmY7Cn0KZmxvYXQgZ2V0U3BvdEF0dGVudWF0aW9uKCBjb25zdCBpbiBmbG9hdCBjb25lQ29zaW5lLCBjb25zdCBpbiBmbG9hdCBwZW51bWJyYUNvc2luZSwgY29uc3QgaW4gZmxvYXQgYW5nbGVDb3NpbmUgKSB7CglyZXR1cm4gc21vb3Roc3RlcCggY29uZUNvc2luZSwgcGVudW1icmFDb3NpbmUsIGFuZ2xlQ29zaW5lICk7Cn0KI2lmIE5VTV9ESVJfTElHSFRTID4gMAoJc3RydWN0IERpcmVjdGlvbmFsTGlnaHQgewoJCXZlYzMgZGlyZWN0aW9uOwoJCXZlYzMgY29sb3I7Cgl9OwoJdW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHRzWyBOVU1fRElSX0xJR0hUUyBdOwoJdm9pZCBnZXREaXJlY3Rpb25hbExpZ2h0SW5mbyggY29uc3QgaW4gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0LCBvdXQgSW5jaWRlbnRMaWdodCBsaWdodCApIHsKCQlsaWdodC5jb2xvciA9IGRpcmVjdGlvbmFsTGlnaHQuY29sb3I7CgkJbGlnaHQuZGlyZWN0aW9uID0gZGlyZWN0aW9uYWxMaWdodC5kaXJlY3Rpb247CgkJbGlnaHQudmlzaWJsZSA9IHRydWU7Cgl9CiNlbmRpZgojaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDAKCXN0cnVjdCBQb2ludExpZ2h0IHsKCQl2ZWMzIHBvc2l0aW9uOwoJCXZlYzMgY29sb3I7CgkJZmxvYXQgZGlzdGFuY2U7CgkJZmxvYXQgZGVjYXk7Cgl9OwoJdW5pZm9ybSBQb2ludExpZ2h0IHBvaW50TGlnaHRzWyBOVU1fUE9JTlRfTElHSFRTIF07Cgl2b2lkIGdldFBvaW50TGlnaHRJbmZvKCBjb25zdCBpbiBQb2ludExpZ2h0IHBvaW50TGlnaHQsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgb3V0IEluY2lkZW50TGlnaHQgbGlnaHQgKSB7CgkJdmVjMyBsVmVjdG9yID0gcG9pbnRMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5UG9zaXRpb247CgkJbGlnaHQuZGlyZWN0aW9uID0gbm9ybWFsaXplKCBsVmVjdG9yICk7CgkJZmxvYXQgbGlnaHREaXN0YW5jZSA9IGxlbmd0aCggbFZlY3RvciApOwoJCWxpZ2h0LmNvbG9yID0gcG9pbnRMaWdodC5jb2xvcjsKCQlsaWdodC5jb2xvciAqPSBnZXREaXN0YW5jZUF0dGVudWF0aW9uKCBsaWdodERpc3RhbmNlLCBwb2ludExpZ2h0LmRpc3RhbmNlLCBwb2ludExpZ2h0LmRlY2F5ICk7CgkJbGlnaHQudmlzaWJsZSA9ICggbGlnaHQuY29sb3IgIT0gdmVjMyggMC4wICkgKTsKCX0KI2VuZGlmCiNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwCglzdHJ1Y3QgU3BvdExpZ2h0IHsKCQl2ZWMzIHBvc2l0aW9uOwoJCXZlYzMgZGlyZWN0aW9uOwoJCXZlYzMgY29sb3I7CgkJZmxvYXQgZGlzdGFuY2U7CgkJZmxvYXQgZGVjYXk7CgkJZmxvYXQgY29uZUNvczsKCQlmbG9hdCBwZW51bWJyYUNvczsKCX07Cgl1bmlmb3JtIFNwb3RMaWdodCBzcG90TGlnaHRzWyBOVU1fU1BPVF9MSUdIVFMgXTsKCXZvaWQgZ2V0U3BvdExpZ2h0SW5mbyggY29uc3QgaW4gU3BvdExpZ2h0IHNwb3RMaWdodCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBvdXQgSW5jaWRlbnRMaWdodCBsaWdodCApIHsKCQl2ZWMzIGxWZWN0b3IgPSBzcG90TGlnaHQucG9zaXRpb24gLSBnZW9tZXRyeVBvc2l0aW9uOwoJCWxpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApOwoJCWZsb2F0IGFuZ2xlQ29zID0gZG90KCBsaWdodC5kaXJlY3Rpb24sIHNwb3RMaWdodC5kaXJlY3Rpb24gKTsKCQlmbG9hdCBzcG90QXR0ZW51YXRpb24gPSBnZXRTcG90QXR0ZW51YXRpb24oIHNwb3RMaWdodC5jb25lQ29zLCBzcG90TGlnaHQucGVudW1icmFDb3MsIGFuZ2xlQ29zICk7CgkJaWYgKCBzcG90QXR0ZW51YXRpb24gPiAwLjAgKSB7CgkJCWZsb2F0IGxpZ2h0RGlzdGFuY2UgPSBsZW5ndGgoIGxWZWN0b3IgKTsKCQkJbGlnaHQuY29sb3IgPSBzcG90TGlnaHQuY29sb3IgKiBzcG90QXR0ZW51YXRpb247CgkJCWxpZ2h0LmNvbG9yICo9IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIGxpZ2h0RGlzdGFuY2UsIHNwb3RMaWdodC5kaXN0YW5jZSwgc3BvdExpZ2h0LmRlY2F5ICk7CgkJCWxpZ2h0LnZpc2libGUgPSAoIGxpZ2h0LmNvbG9yICE9IHZlYzMoIDAuMCApICk7CgkJfSBlbHNlIHsKCQkJbGlnaHQuY29sb3IgPSB2ZWMzKCAwLjAgKTsKCQkJbGlnaHQudmlzaWJsZSA9IGZhbHNlOwoJCX0KCX0KI2VuZGlmCiNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDAKCXN0cnVjdCBSZWN0QXJlYUxpZ2h0IHsKCQl2ZWMzIGNvbG9yOwoJCXZlYzMgcG9zaXRpb247CgkJdmVjMyBoYWxmV2lkdGg7CgkJdmVjMyBoYWxmSGVpZ2h0OwoJfTsKCXVuaWZvcm0gc2FtcGxlcjJEIGx0Y18xOwl1bmlmb3JtIHNhbXBsZXIyRCBsdGNfMjsKCXVuaWZvcm0gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0c1sgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgXTsKI2VuZGlmCiNpZiBOVU1fSEVNSV9MSUdIVFMgPiAwCglzdHJ1Y3QgSGVtaXNwaGVyZUxpZ2h0IHsKCQl2ZWMzIGRpcmVjdGlvbjsKCQl2ZWMzIHNreUNvbG9yOwoJCXZlYzMgZ3JvdW5kQ29sb3I7Cgl9OwoJdW5pZm9ybSBIZW1pc3BoZXJlTGlnaHQgaGVtaXNwaGVyZUxpZ2h0c1sgTlVNX0hFTUlfTElHSFRTIF07Cgl2ZWMzIGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIEhlbWlzcGhlcmVMaWdodCBoZW1pTGlnaHQsIGNvbnN0IGluIHZlYzMgbm9ybWFsICkgewoJCWZsb2F0IGRvdE5MID0gZG90KCBub3JtYWwsIGhlbWlMaWdodC5kaXJlY3Rpb24gKTsKCQlmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdE5MICsgMC41OwoJCXZlYzMgaXJyYWRpYW5jZSA9IG1peCggaGVtaUxpZ2h0Lmdyb3VuZENvbG9yLCBoZW1pTGlnaHQuc2t5Q29sb3IsIGhlbWlEaWZmdXNlV2VpZ2h0ICk7CgkJcmV0dXJuIGlycmFkaWFuY2U7Cgl9CiNlbmRpZmAsRG89YCNpZmRlZiBVU0VfRU5WTUFQCgl2ZWMzIGdldElCTElycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkgewoJCSNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWCgkJCXZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTsKCQkJdmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgZW52TWFwUm90YXRpb24gKiB3b3JsZE5vcm1hbCwgMS4wICk7CgkJCXJldHVybiBQSSAqIGVudk1hcENvbG9yLnJnYiAqIGVudk1hcEludGVuc2l0eTsKCQkjZWxzZQoJCQlyZXR1cm4gdmVjMyggMC4wICk7CgkJI2VuZGlmCgl9Cgl2ZWMzIGdldElCTFJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7CgkJI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVfVVYKCQkJdmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggLSB2aWV3RGlyLCBub3JtYWwgKTsKCQkJcmVmbGVjdFZlYyA9IG5vcm1hbGl6ZSggbWl4KCByZWZsZWN0VmVjLCBub3JtYWwsIHJvdWdobmVzcyAqIHJvdWdobmVzcykgKTsKCQkJcmVmbGVjdFZlYyA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHJlZmxlY3RWZWMsIHZpZXdNYXRyaXggKTsKCQkJdmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgZW52TWFwUm90YXRpb24gKiByZWZsZWN0VmVjLCByb3VnaG5lc3MgKTsKCQkJcmV0dXJuIGVudk1hcENvbG9yLnJnYiAqIGVudk1hcEludGVuc2l0eTsKCQkjZWxzZQoJCQlyZXR1cm4gdmVjMyggMC4wICk7CgkJI2VuZGlmCgl9CgkjaWZkZWYgVVNFX0FOSVNPVFJPUFkKCQl2ZWMzIGdldElCTEFuaXNvdHJvcHlSYWRpYW5jZSggY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBjb25zdCBpbiB2ZWMzIGJpdGFuZ2VudCwgY29uc3QgaW4gZmxvYXQgYW5pc290cm9weSApIHsKCQkJI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVfVVYKCQkJCXZlYzMgYmVudE5vcm1hbCA9IGNyb3NzKCBiaXRhbmdlbnQsIHZpZXdEaXIgKTsKCQkJCWJlbnROb3JtYWwgPSBub3JtYWxpemUoIGNyb3NzKCBiZW50Tm9ybWFsLCBiaXRhbmdlbnQgKSApOwoJCQkJYmVudE5vcm1hbCA9IG5vcm1hbGl6ZSggbWl4KCBiZW50Tm9ybWFsLCBub3JtYWwsIHBvdzIoIHBvdzIoIDEuMCAtIGFuaXNvdHJvcHkgKiAoIDEuMCAtIHJvdWdobmVzcyApICkgKSApICk7CgkJCQlyZXR1cm4gZ2V0SUJMUmFkaWFuY2UoIHZpZXdEaXIsIGJlbnROb3JtYWwsIHJvdWdobmVzcyApOwoJCQkjZWxzZQoJCQkJcmV0dXJuIHZlYzMoIDAuMCApOwoJCQkjZW5kaWYKCQl9CgkjZW5kaWYKI2VuZGlmYCxMbz1gVG9vbk1hdGVyaWFsIG1hdGVyaWFsOwptYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiO2AsVW89YHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uOwpzdHJ1Y3QgVG9vbk1hdGVyaWFsIHsKCXZlYzMgZGlmZnVzZUNvbG9yOwp9Owp2b2lkIFJFX0RpcmVjdF9Ub29uKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBUb29uTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkgewoJdmVjMyBpcnJhZGlhbmNlID0gZ2V0R3JhZGllbnRJcnJhZGlhbmNlKCBnZW9tZXRyeU5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKiBkaXJlY3RMaWdodC5jb2xvcjsKCXJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7Cn0Kdm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfVG9vbiggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBUb29uTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkgewoJcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApOwp9CiNkZWZpbmUgUkVfRGlyZWN0CQkJCVJFX0RpcmVjdF9Ub29uCiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlCQlSRV9JbmRpcmVjdERpZmZ1c2VfVG9vbmAsRm89YEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbDsKbWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjsKbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IHNwZWN1bGFyOwptYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyA9IHNoaW5pbmVzczsKbWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aCA9IHNwZWN1bGFyU3RyZW5ndGg7YCxJbz1gdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CnN0cnVjdCBCbGlublBob25nTWF0ZXJpYWwgewoJdmVjMyBkaWZmdXNlQ29sb3I7Cgl2ZWMzIHNwZWN1bGFyQ29sb3I7CglmbG9hdCBzcGVjdWxhclNoaW5pbmVzczsKCWZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7Cn07CnZvaWQgUkVfRGlyZWN0X0JsaW5uUGhvbmcoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7CglmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Tm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApOwoJdmVjMyBpcnJhZGlhbmNlID0gZG90TkwgKiBkaXJlY3RMaWdodC5jb2xvcjsKCXJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7CglyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9CbGlublBob25nKCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlOb3JtYWwsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyU2hpbmluZXNzICkgKiBtYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoOwp9CnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmcoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHsKCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTsKfQojZGVmaW5lIFJFX0RpcmVjdAkJCQlSRV9EaXJlY3RfQmxpbm5QaG9uZwojZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZQkJUkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmdgLE5vPWBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsOwptYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiICogKCAxLjAgLSBtZXRhbG5lc3NGYWN0b3IgKTsKdmVjMyBkeHkgPSBtYXgoIGFicyggZEZkeCggbm9uUGVydHVyYmVkTm9ybWFsICkgKSwgYWJzKCBkRmR5KCBub25QZXJ0dXJiZWROb3JtYWwgKSApICk7CmZsb2F0IGdlb21ldHJ5Um91Z2huZXNzID0gbWF4KCBtYXgoIGR4eS54LCBkeHkueSApLCBkeHkueiApOwptYXRlcmlhbC5yb3VnaG5lc3MgPSBtYXgoIHJvdWdobmVzc0ZhY3RvciwgMC4wNTI1ICk7bWF0ZXJpYWwucm91Z2huZXNzICs9IGdlb21ldHJ5Um91Z2huZXNzOwptYXRlcmlhbC5yb3VnaG5lc3MgPSBtaW4oIG1hdGVyaWFsLnJvdWdobmVzcywgMS4wICk7CiNpZmRlZiBJT1IKCW1hdGVyaWFsLmlvciA9IGlvcjsKCSNpZmRlZiBVU0VfU1BFQ1VMQVIKCQlmbG9hdCBzcGVjdWxhckludGVuc2l0eUZhY3RvciA9IHNwZWN1bGFySW50ZW5zaXR5OwoJCXZlYzMgc3BlY3VsYXJDb2xvckZhY3RvciA9IHNwZWN1bGFyQ29sb3I7CgkJI2lmZGVmIFVTRV9TUEVDVUxBUl9DT0xPUk1BUAoJCQlzcGVjdWxhckNvbG9yRmFjdG9yICo9IHRleHR1cmUyRCggc3BlY3VsYXJDb2xvck1hcCwgdlNwZWN1bGFyQ29sb3JNYXBVdiApLnJnYjsKCQkjZW5kaWYKCQkjaWZkZWYgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUAoJCQlzcGVjdWxhckludGVuc2l0eUZhY3RvciAqPSB0ZXh0dXJlMkQoIHNwZWN1bGFySW50ZW5zaXR5TWFwLCB2U3BlY3VsYXJJbnRlbnNpdHlNYXBVdiApLmE7CgkJI2VuZGlmCgkJbWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSBtaXgoIHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yLCAxLjAsIG1ldGFsbmVzc0ZhY3RvciApOwoJI2Vsc2UKCQlmbG9hdCBzcGVjdWxhckludGVuc2l0eUZhY3RvciA9IDEuMDsKCQl2ZWMzIHNwZWN1bGFyQ29sb3JGYWN0b3IgPSB2ZWMzKCAxLjAgKTsKCQltYXRlcmlhbC5zcGVjdWxhckY5MCA9IDEuMDsKCSNlbmRpZgoJbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggbWluKCBwb3cyKCAoIG1hdGVyaWFsLmlvciAtIDEuMCApIC8gKCBtYXRlcmlhbC5pb3IgKyAxLjAgKSApICogc3BlY3VsYXJDb2xvckZhY3RvciwgdmVjMyggMS4wICkgKSAqIHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTsKI2Vsc2UKCW1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBtaXgoIHZlYzMoIDAuMDQgKSwgZGlmZnVzZUNvbG9yLnJnYiwgbWV0YWxuZXNzRmFjdG9yICk7CgltYXRlcmlhbC5zcGVjdWxhckY5MCA9IDEuMDsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUCgltYXRlcmlhbC5jbGVhcmNvYXQgPSBjbGVhcmNvYXQ7CgltYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgPSBjbGVhcmNvYXRSb3VnaG5lc3M7CgltYXRlcmlhbC5jbGVhcmNvYXRGMCA9IHZlYzMoIDAuMDQgKTsKCW1hdGVyaWFsLmNsZWFyY29hdEY5MCA9IDEuMDsKCSNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQCgkJbWF0ZXJpYWwuY2xlYXJjb2F0ICo9IHRleHR1cmUyRCggY2xlYXJjb2F0TWFwLCB2Q2xlYXJjb2F0TWFwVXYgKS54OwoJI2VuZGlmCgkjaWZkZWYgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAKCQltYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKj0gdGV4dHVyZTJEKCBjbGVhcmNvYXRSb3VnaG5lc3NNYXAsIHZDbGVhcmNvYXRSb3VnaG5lc3NNYXBVdiApLnk7CgkjZW5kaWYKCW1hdGVyaWFsLmNsZWFyY29hdCA9IHNhdHVyYXRlKCBtYXRlcmlhbC5jbGVhcmNvYXQgKTsJbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gbWF4KCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MsIDAuMDUyNSApOwoJbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICs9IGdlb21ldHJ5Um91Z2huZXNzOwoJbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gbWluKCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MsIDEuMCApOwojZW5kaWYKI2lmZGVmIFVTRV9ESVNQRVJTSU9OCgltYXRlcmlhbC5kaXNwZXJzaW9uID0gZGlzcGVyc2lvbjsKI2VuZGlmCiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0UKCW1hdGVyaWFsLmlyaWRlc2NlbmNlID0gaXJpZGVzY2VuY2U7CgltYXRlcmlhbC5pcmlkZXNjZW5jZUlPUiA9IGlyaWRlc2NlbmNlSU9SOwoJI2lmZGVmIFVTRV9JUklERVNDRU5DRU1BUAoJCW1hdGVyaWFsLmlyaWRlc2NlbmNlICo9IHRleHR1cmUyRCggaXJpZGVzY2VuY2VNYXAsIHZJcmlkZXNjZW5jZU1hcFV2ICkucjsKCSNlbmRpZgoJI2lmZGVmIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVAKCQltYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzcyA9IChpcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0gLSBpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0pICogdGV4dHVyZTJEKCBpcmlkZXNjZW5jZVRoaWNrbmVzc01hcCwgdklyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXYgKS5nICsgaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtOwoJI2Vsc2UKCQltYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzcyA9IGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTsKCSNlbmRpZgojZW5kaWYKI2lmZGVmIFVTRV9TSEVFTgoJbWF0ZXJpYWwuc2hlZW5Db2xvciA9IHNoZWVuQ29sb3I7CgkjaWZkZWYgVVNFX1NIRUVOX0NPTE9STUFQCgkJbWF0ZXJpYWwuc2hlZW5Db2xvciAqPSB0ZXh0dXJlMkQoIHNoZWVuQ29sb3JNYXAsIHZTaGVlbkNvbG9yTWFwVXYgKS5yZ2I7CgkjZW5kaWYKCW1hdGVyaWFsLnNoZWVuUm91Z2huZXNzID0gY2xhbXAoIHNoZWVuUm91Z2huZXNzLCAwLjA3LCAxLjAgKTsKCSNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQCgkJbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgKj0gdGV4dHVyZTJEKCBzaGVlblJvdWdobmVzc01hcCwgdlNoZWVuUm91Z2huZXNzTWFwVXYgKS5hOwoJI2VuZGlmCiNlbmRpZgojaWZkZWYgVVNFX0FOSVNPVFJPUFkKCSNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUAoJCW1hdDIgYW5pc290cm9weU1hdCA9IG1hdDIoIGFuaXNvdHJvcHlWZWN0b3IueCwgYW5pc290cm9weVZlY3Rvci55LCAtIGFuaXNvdHJvcHlWZWN0b3IueSwgYW5pc290cm9weVZlY3Rvci54ICk7CgkJdmVjMyBhbmlzb3Ryb3B5UG9sYXIgPSB0ZXh0dXJlMkQoIGFuaXNvdHJvcHlNYXAsIHZBbmlzb3Ryb3B5TWFwVXYgKS5yZ2I7CgkJdmVjMiBhbmlzb3Ryb3B5ViA9IGFuaXNvdHJvcHlNYXQgKiBub3JtYWxpemUoIDIuMCAqIGFuaXNvdHJvcHlQb2xhci5yZyAtIHZlYzIoIDEuMCApICkgKiBhbmlzb3Ryb3B5UG9sYXIuYjsKCSNlbHNlCgkJdmVjMiBhbmlzb3Ryb3B5ViA9IGFuaXNvdHJvcHlWZWN0b3I7CgkjZW5kaWYKCW1hdGVyaWFsLmFuaXNvdHJvcHkgPSBsZW5ndGgoIGFuaXNvdHJvcHlWICk7CglpZiggbWF0ZXJpYWwuYW5pc290cm9weSA9PSAwLjAgKSB7CgkJYW5pc290cm9weVYgPSB2ZWMyKCAxLjAsIDAuMCApOwoJfSBlbHNlIHsKCQlhbmlzb3Ryb3B5ViAvPSBtYXRlcmlhbC5hbmlzb3Ryb3B5OwoJCW1hdGVyaWFsLmFuaXNvdHJvcHkgPSBzYXR1cmF0ZSggbWF0ZXJpYWwuYW5pc290cm9weSApOwoJfQoJbWF0ZXJpYWwuYWxwaGFUID0gbWl4KCBwb3cyKCBtYXRlcmlhbC5yb3VnaG5lc3MgKSwgMS4wLCBwb3cyKCBtYXRlcmlhbC5hbmlzb3Ryb3B5ICkgKTsKCW1hdGVyaWFsLmFuaXNvdHJvcHlUID0gdGJuWyAwIF0gKiBhbmlzb3Ryb3B5Vi54ICsgdGJuWyAxIF0gKiBhbmlzb3Ryb3B5Vi55OwoJbWF0ZXJpYWwuYW5pc290cm9weUIgPSB0Ym5bIDEgXSAqIGFuaXNvdHJvcHlWLnggLSB0Ym5bIDAgXSAqIGFuaXNvdHJvcHlWLnk7CiNlbmRpZmAsT289YHN0cnVjdCBQaHlzaWNhbE1hdGVyaWFsIHsKCXZlYzMgZGlmZnVzZUNvbG9yOwoJZmxvYXQgcm91Z2huZXNzOwoJdmVjMyBzcGVjdWxhckNvbG9yOwoJZmxvYXQgc3BlY3VsYXJGOTA7CglmbG9hdCBkaXNwZXJzaW9uOwoJI2lmZGVmIFVTRV9DTEVBUkNPQVQKCQlmbG9hdCBjbGVhcmNvYXQ7CgkJZmxvYXQgY2xlYXJjb2F0Um91Z2huZXNzOwoJCXZlYzMgY2xlYXJjb2F0RjA7CgkJZmxvYXQgY2xlYXJjb2F0RjkwOwoJI2VuZGlmCgkjaWZkZWYgVVNFX0lSSURFU0NFTkNFCgkJZmxvYXQgaXJpZGVzY2VuY2U7CgkJZmxvYXQgaXJpZGVzY2VuY2VJT1I7CgkJZmxvYXQgaXJpZGVzY2VuY2VUaGlja25lc3M7CgkJdmVjMyBpcmlkZXNjZW5jZUZyZXNuZWw7CgkJdmVjMyBpcmlkZXNjZW5jZUYwOwoJI2VuZGlmCgkjaWZkZWYgVVNFX1NIRUVOCgkJdmVjMyBzaGVlbkNvbG9yOwoJCWZsb2F0IHNoZWVuUm91Z2huZXNzOwoJI2VuZGlmCgkjaWZkZWYgSU9SCgkJZmxvYXQgaW9yOwoJI2VuZGlmCgkjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTgoJCWZsb2F0IHRyYW5zbWlzc2lvbjsKCQlmbG9hdCB0cmFuc21pc3Npb25BbHBoYTsKCQlmbG9hdCB0aGlja25lc3M7CgkJZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZTsKCQl2ZWMzIGF0dGVudWF0aW9uQ29sb3I7CgkjZW5kaWYKCSNpZmRlZiBVU0VfQU5JU09UUk9QWQoJCWZsb2F0IGFuaXNvdHJvcHk7CgkJZmxvYXQgYWxwaGFUOwoJCXZlYzMgYW5pc290cm9weVQ7CgkJdmVjMyBhbmlzb3Ryb3B5QjsKCSNlbmRpZgp9Owp2ZWMzIGNsZWFyY29hdFNwZWN1bGFyRGlyZWN0ID0gdmVjMyggMC4wICk7CnZlYzMgY2xlYXJjb2F0U3BlY3VsYXJJbmRpcmVjdCA9IHZlYzMoIDAuMCApOwp2ZWMzIHNoZWVuU3BlY3VsYXJEaXJlY3QgPSB2ZWMzKCAwLjAgKTsKdmVjMyBzaGVlblNwZWN1bGFySW5kaXJlY3QgPSB2ZWMzKDAuMCApOwp2ZWMzIFNjaGxpY2tfdG9fRjAoIGNvbnN0IGluIHZlYzMgZiwgY29uc3QgaW4gZmxvYXQgZjkwLCBjb25zdCBpbiBmbG9hdCBkb3RWSCApIHsKICAgIGZsb2F0IHggPSBjbGFtcCggMS4wIC0gZG90VkgsIDAuMCwgMS4wICk7CiAgICBmbG9hdCB4MiA9IHggKiB4OwogICAgZmxvYXQgeDUgPSBjbGFtcCggeCAqIHgyICogeDIsIDAuMCwgMC45OTk5ICk7CiAgICByZXR1cm4gKCBmIC0gdmVjMyggZjkwICkgKiB4NSApIC8gKCAxLjAgLSB4NSApOwp9CmZsb2F0IFZfR0dYX1NtaXRoQ29ycmVsYXRlZCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5MLCBjb25zdCBpbiBmbG9hdCBkb3ROViApIHsKCWZsb2F0IGEyID0gcG93MiggYWxwaGEgKTsKCWZsb2F0IGd2ID0gZG90TkwgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5WICkgKTsKCWZsb2F0IGdsID0gZG90TlYgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5MICkgKTsKCXJldHVybiAwLjUgLyBtYXgoIGd2ICsgZ2wsIEVQU0lMT04gKTsKfQpmbG9hdCBEX0dHWCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5IICkgewoJZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApOwoJZmxvYXQgZGVub20gPSBwb3cyKCBkb3ROSCApICogKCBhMiAtIDEuMCApICsgMS4wOwoJcmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBhMiAvIHBvdzIoIGRlbm9tICk7Cn0KI2lmZGVmIFVTRV9BTklTT1RST1BZCglmbG9hdCBWX0dHWF9TbWl0aENvcnJlbGF0ZWRfQW5pc290cm9waWMoIGNvbnN0IGluIGZsb2F0IGFscGhhVCwgY29uc3QgaW4gZmxvYXQgYWxwaGFCLCBjb25zdCBpbiBmbG9hdCBkb3RUViwgY29uc3QgaW4gZmxvYXQgZG90QlYsIGNvbnN0IGluIGZsb2F0IGRvdFRMLCBjb25zdCBpbiBmbG9hdCBkb3RCTCwgY29uc3QgaW4gZmxvYXQgZG90TlYsIGNvbnN0IGluIGZsb2F0IGRvdE5MICkgewoJCWZsb2F0IGd2ID0gZG90TkwgKiBsZW5ndGgoIHZlYzMoIGFscGhhVCAqIGRvdFRWLCBhbHBoYUIgKiBkb3RCViwgZG90TlYgKSApOwoJCWZsb2F0IGdsID0gZG90TlYgKiBsZW5ndGgoIHZlYzMoIGFscGhhVCAqIGRvdFRMLCBhbHBoYUIgKiBkb3RCTCwgZG90TkwgKSApOwoJCWZsb2F0IHYgPSAwLjUgLyAoIGd2ICsgZ2wgKTsKCQlyZXR1cm4gc2F0dXJhdGUodik7Cgl9CglmbG9hdCBEX0dHWF9Bbmlzb3Ryb3BpYyggY29uc3QgaW4gZmxvYXQgYWxwaGFULCBjb25zdCBpbiBmbG9hdCBhbHBoYUIsIGNvbnN0IGluIGZsb2F0IGRvdE5ILCBjb25zdCBpbiBmbG9hdCBkb3RUSCwgY29uc3QgaW4gZmxvYXQgZG90QkggKSB7CgkJZmxvYXQgYTIgPSBhbHBoYVQgKiBhbHBoYUI7CgkJaGlnaHAgdmVjMyB2ID0gdmVjMyggYWxwaGFCICogZG90VEgsIGFscGhhVCAqIGRvdEJILCBhMiAqIGRvdE5IICk7CgkJaGlnaHAgZmxvYXQgdjIgPSBkb3QoIHYsIHYgKTsKCQlmbG9hdCB3MiA9IGEyIC8gdjI7CgkJcmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBhMiAqIHBvdzIgKCB3MiApOwoJfQojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVQKCXZlYzMgQlJERl9HR1hfQ2xlYXJjb2F0KCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsKSB7CgkJdmVjMyBmMCA9IG1hdGVyaWFsLmNsZWFyY29hdEYwOwoJCWZsb2F0IGY5MCA9IG1hdGVyaWFsLmNsZWFyY29hdEY5MDsKCQlmbG9hdCByb3VnaG5lc3MgPSBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3M7CgkJZmxvYXQgYWxwaGEgPSBwb3cyKCByb3VnaG5lc3MgKTsKCQl2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApOwoJCWZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7CgkJZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApOwoJCWZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTsKCQlmbG9hdCBkb3RWSCA9IHNhdHVyYXRlKCBkb3QoIHZpZXdEaXIsIGhhbGZEaXIgKSApOwoJCXZlYzMgRiA9IEZfU2NobGljayggZjAsIGY5MCwgZG90VkggKTsKCQlmbG9hdCBWID0gVl9HR1hfU21pdGhDb3JyZWxhdGVkKCBhbHBoYSwgZG90TkwsIGRvdE5WICk7CgkJZmxvYXQgRCA9IERfR0dYKCBhbHBoYSwgZG90TkggKTsKCQlyZXR1cm4gRiAqICggViAqIEQgKTsKCX0KI2VuZGlmCnZlYzMgQlJERl9HR1goIGNvbnN0IGluIHZlYzMgbGlnaHREaXIsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwgKSB7Cgl2ZWMzIGYwID0gbWF0ZXJpYWwuc3BlY3VsYXJDb2xvcjsKCWZsb2F0IGY5MCA9IG1hdGVyaWFsLnNwZWN1bGFyRjkwOwoJZmxvYXQgcm91Z2huZXNzID0gbWF0ZXJpYWwucm91Z2huZXNzOwoJZmxvYXQgYWxwaGEgPSBwb3cyKCByb3VnaG5lc3MgKTsKCXZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7CglmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApOwoJZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApOwoJZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApOwoJZmxvYXQgZG90VkggPSBzYXR1cmF0ZSggZG90KCB2aWV3RGlyLCBoYWxmRGlyICkgKTsKCXZlYzMgRiA9IEZfU2NobGljayggZjAsIGY5MCwgZG90VkggKTsKCSNpZmRlZiBVU0VfSVJJREVTQ0VOQ0UKCQlGID0gbWl4KCBGLCBtYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwsIG1hdGVyaWFsLmlyaWRlc2NlbmNlICk7CgkjZW5kaWYKCSNpZmRlZiBVU0VfQU5JU09UUk9QWQoJCWZsb2F0IGRvdFRMID0gZG90KCBtYXRlcmlhbC5hbmlzb3Ryb3B5VCwgbGlnaHREaXIgKTsKCQlmbG9hdCBkb3RUViA9IGRvdCggbWF0ZXJpYWwuYW5pc290cm9weVQsIHZpZXdEaXIgKTsKCQlmbG9hdCBkb3RUSCA9IGRvdCggbWF0ZXJpYWwuYW5pc290cm9weVQsIGhhbGZEaXIgKTsKCQlmbG9hdCBkb3RCTCA9IGRvdCggbWF0ZXJpYWwuYW5pc290cm9weUIsIGxpZ2h0RGlyICk7CgkJZmxvYXQgZG90QlYgPSBkb3QoIG1hdGVyaWFsLmFuaXNvdHJvcHlCLCB2aWV3RGlyICk7CgkJZmxvYXQgZG90QkggPSBkb3QoIG1hdGVyaWFsLmFuaXNvdHJvcHlCLCBoYWxmRGlyICk7CgkJZmxvYXQgViA9IFZfR0dYX1NtaXRoQ29ycmVsYXRlZF9Bbmlzb3Ryb3BpYyggbWF0ZXJpYWwuYWxwaGFULCBhbHBoYSwgZG90VFYsIGRvdEJWLCBkb3RUTCwgZG90QkwsIGRvdE5WLCBkb3ROTCApOwoJCWZsb2F0IEQgPSBEX0dHWF9Bbmlzb3Ryb3BpYyggbWF0ZXJpYWwuYWxwaGFULCBhbHBoYSwgZG90TkgsIGRvdFRILCBkb3RCSCApOwoJI2Vsc2UKCQlmbG9hdCBWID0gVl9HR1hfU21pdGhDb3JyZWxhdGVkKCBhbHBoYSwgZG90TkwsIGRvdE5WICk7CgkJZmxvYXQgRCA9IERfR0dYKCBhbHBoYSwgZG90TkggKTsKCSNlbmRpZgoJcmV0dXJuIEYgKiAoIFYgKiBEICk7Cn0KdmVjMiBMVENfVXYoIGNvbnN0IGluIHZlYzMgTiwgY29uc3QgaW4gdmVjMyBWLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7Cgljb25zdCBmbG9hdCBMVVRfU0laRSA9IDY0LjA7Cgljb25zdCBmbG9hdCBMVVRfU0NBTEUgPSAoIExVVF9TSVpFIC0gMS4wICkgLyBMVVRfU0laRTsKCWNvbnN0IGZsb2F0IExVVF9CSUFTID0gMC41IC8gTFVUX1NJWkU7CglmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIE4sIFYgKSApOwoJdmVjMiB1diA9IHZlYzIoIHJvdWdobmVzcywgc3FydCggMS4wIC0gZG90TlYgKSApOwoJdXYgPSB1diAqIExVVF9TQ0FMRSArIExVVF9CSUFTOwoJcmV0dXJuIHV2Owp9CmZsb2F0IExUQ19DbGlwcGVkU3BoZXJlRm9ybUZhY3RvciggY29uc3QgaW4gdmVjMyBmICkgewoJZmxvYXQgbCA9IGxlbmd0aCggZiApOwoJcmV0dXJuIG1heCggKCBsICogbCArIGYueiApIC8gKCBsICsgMS4wICksIDAuMCApOwp9CnZlYzMgTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb25zdCBpbiB2ZWMzIHYxLCBjb25zdCBpbiB2ZWMzIHYyICkgewoJZmxvYXQgeCA9IGRvdCggdjEsIHYyICk7CglmbG9hdCB5ID0gYWJzKCB4ICk7CglmbG9hdCBhID0gMC44NTQzOTg1ICsgKCAwLjQ5NjUxNTUgKyAwLjAxNDUyMDYgKiB5ICkgKiB5OwoJZmxvYXQgYiA9IDMuNDE3NTk0MCArICggNC4xNjE2NzI0ICsgeSApICogeTsKCWZsb2F0IHYgPSBhIC8gYjsKCWZsb2F0IHRoZXRhX3NpbnRoZXRhID0gKCB4ID4gMC4wICkgPyB2IDogMC41ICogaW52ZXJzZXNxcnQoIG1heCggMS4wIC0geCAqIHgsIDFlLTcgKSApIC0gdjsKCXJldHVybiBjcm9zcyggdjEsIHYyICkgKiB0aGV0YV9zaW50aGV0YTsKfQp2ZWMzIExUQ19FdmFsdWF0ZSggY29uc3QgaW4gdmVjMyBOLCBjb25zdCBpbiB2ZWMzIFYsIGNvbnN0IGluIHZlYzMgUCwgY29uc3QgaW4gbWF0MyBtSW52LCBjb25zdCBpbiB2ZWMzIHJlY3RDb29yZHNbIDQgXSApIHsKCXZlYzMgdjEgPSByZWN0Q29vcmRzWyAxIF0gLSByZWN0Q29vcmRzWyAwIF07Cgl2ZWMzIHYyID0gcmVjdENvb3Jkc1sgMyBdIC0gcmVjdENvb3Jkc1sgMCBdOwoJdmVjMyBsaWdodE5vcm1hbCA9IGNyb3NzKCB2MSwgdjIgKTsKCWlmKCBkb3QoIGxpZ2h0Tm9ybWFsLCBQIC0gcmVjdENvb3Jkc1sgMCBdICkgPCAwLjAgKSByZXR1cm4gdmVjMyggMC4wICk7Cgl2ZWMzIFQxLCBUMjsKCVQxID0gbm9ybWFsaXplKCBWIC0gTiAqIGRvdCggViwgTiApICk7CglUMiA9IC0gY3Jvc3MoIE4sIFQxICk7CgltYXQzIG1hdCA9IG1JbnYgKiB0cmFuc3Bvc2VNYXQzKCBtYXQzKCBUMSwgVDIsIE4gKSApOwoJdmVjMyBjb29yZHNbIDQgXTsKCWNvb3Jkc1sgMCBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAwIF0gLSBQICk7Cgljb29yZHNbIDEgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMSBdIC0gUCApOwoJY29vcmRzWyAyIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDIgXSAtIFAgKTsKCWNvb3Jkc1sgMyBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAzIF0gLSBQICk7Cgljb29yZHNbIDAgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAwIF0gKTsKCWNvb3Jkc1sgMSBdID0gbm9ybWFsaXplKCBjb29yZHNbIDEgXSApOwoJY29vcmRzWyAyIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMiBdICk7Cgljb29yZHNbIDMgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAzIF0gKTsKCXZlYzMgdmVjdG9yRm9ybUZhY3RvciA9IHZlYzMoIDAuMCApOwoJdmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMCBdLCBjb29yZHNbIDEgXSApOwoJdmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMSBdLCBjb29yZHNbIDIgXSApOwoJdmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMiBdLCBjb29yZHNbIDMgXSApOwoJdmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMyBdLCBjb29yZHNbIDAgXSApOwoJZmxvYXQgcmVzdWx0ID0gTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCB2ZWN0b3JGb3JtRmFjdG9yICk7CglyZXR1cm4gdmVjMyggcmVzdWx0ICk7Cn0KI2lmIGRlZmluZWQoIFVTRV9TSEVFTiApCmZsb2F0IERfQ2hhcmxpZSggZmxvYXQgcm91Z2huZXNzLCBmbG9hdCBkb3ROSCApIHsKCWZsb2F0IGFscGhhID0gcG93Miggcm91Z2huZXNzICk7CglmbG9hdCBpbnZBbHBoYSA9IDEuMCAvIGFscGhhOwoJZmxvYXQgY29zMmggPSBkb3ROSCAqIGRvdE5IOwoJZmxvYXQgc2luMmggPSBtYXgoIDEuMCAtIGNvczJoLCAwLjAwNzgxMjUgKTsKCXJldHVybiAoIDIuMCArIGludkFscGhhICkgKiBwb3coIHNpbjJoLCBpbnZBbHBoYSAqIDAuNSApIC8gKCAyLjAgKiBQSSApOwp9CmZsb2F0IFZfTmV1YmVsdCggZmxvYXQgZG90TlYsIGZsb2F0IGRvdE5MICkgewoJcmV0dXJuIHNhdHVyYXRlKCAxLjAgLyAoIDQuMCAqICggZG90TkwgKyBkb3ROViAtIGRvdE5MICogZG90TlYgKSApICk7Cn0KdmVjMyBCUkRGX1NoZWVuKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCB2ZWMzIHNoZWVuQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoZWVuUm91Z2huZXNzICkgewoJdmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBsaWdodERpciArIHZpZXdEaXIgKTsKCWZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7CglmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7CglmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7CglmbG9hdCBEID0gRF9DaGFybGllKCBzaGVlblJvdWdobmVzcywgZG90TkggKTsKCWZsb2F0IFYgPSBWX05ldWJlbHQoIGRvdE5WLCBkb3ROTCApOwoJcmV0dXJuIHNoZWVuQ29sb3IgKiAoIEQgKiBWICk7Cn0KI2VuZGlmCmZsb2F0IElCTFNoZWVuQlJERiggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkgewoJZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApOwoJZmxvYXQgcjIgPSByb3VnaG5lc3MgKiByb3VnaG5lc3M7CglmbG9hdCBhID0gcm91Z2huZXNzIDwgMC4yNSA/IC0zMzkuMiAqIHIyICsgMTYxLjQgKiByb3VnaG5lc3MgLSAyNS45IDogLTguNDggKiByMiArIDE0LjMgKiByb3VnaG5lc3MgLSA5Ljk1OwoJZmxvYXQgYiA9IHJvdWdobmVzcyA8IDAuMjUgPyA0NC4wICogcjIgLSAyMy43ICogcm91Z2huZXNzICsgMy4yNiA6IDEuOTcgKiByMiAtIDMuMjcgKiByb3VnaG5lc3MgKyAwLjcyOwoJZmxvYXQgREcgPSBleHAoIGEgKiBkb3ROViArIGIgKSArICggcm91Z2huZXNzIDwgMC4yNSA/IDAuMCA6IDAuMSAqICggcm91Z2huZXNzIC0gMC4yNSApICk7CglyZXR1cm4gc2F0dXJhdGUoIERHICogUkVDSVBST0NBTF9QSSApOwp9CnZlYzIgREZHQXBwcm94KCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7CglmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7Cgljb25zdCB2ZWM0IGMwID0gdmVjNCggLSAxLCAtIDAuMDI3NSwgLSAwLjU3MiwgMC4wMjIgKTsKCWNvbnN0IHZlYzQgYzEgPSB2ZWM0KCAxLCAwLjA0MjUsIDEuMDQsIC0gMC4wNCApOwoJdmVjNCByID0gcm91Z2huZXNzICogYzAgKyBjMTsKCWZsb2F0IGEwMDQgPSBtaW4oIHIueCAqIHIueCwgZXhwMiggLSA5LjI4ICogZG90TlYgKSApICogci54ICsgci55OwoJdmVjMiBmYWIgPSB2ZWMyKCAtIDEuMDQsIDEuMDQgKSAqIGEwMDQgKyByLnp3OwoJcmV0dXJuIGZhYjsKfQp2ZWMzIEVudmlyb25tZW50QlJERiggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkgewoJdmVjMiBmYWIgPSBERkdBcHByb3goIG5vcm1hbCwgdmlld0Rpciwgcm91Z2huZXNzICk7CglyZXR1cm4gc3BlY3VsYXJDb2xvciAqIGZhYi54ICsgc3BlY3VsYXJGOTAgKiBmYWIueTsKfQojaWZkZWYgVVNFX0lSSURFU0NFTkNFCnZvaWQgY29tcHV0ZU11bHRpc2NhdHRlcmluZ0lyaWRlc2NlbmNlKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNwZWN1bGFyRjkwLCBjb25zdCBpbiBmbG9hdCBpcmlkZXNjZW5jZSwgY29uc3QgaW4gdmVjMyBpcmlkZXNjZW5jZUYwLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGlub3V0IHZlYzMgc2luZ2xlU2NhdHRlciwgaW5vdXQgdmVjMyBtdWx0aVNjYXR0ZXIgKSB7CiNlbHNlCnZvaWQgY29tcHV0ZU11bHRpc2NhdHRlcmluZyggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBpbm91dCB2ZWMzIHNpbmdsZVNjYXR0ZXIsIGlub3V0IHZlYzMgbXVsdGlTY2F0dGVyICkgewojZW5kaWYKCXZlYzIgZmFiID0gREZHQXBwcm94KCBub3JtYWwsIHZpZXdEaXIsIHJvdWdobmVzcyApOwoJI2lmZGVmIFVTRV9JUklERVNDRU5DRQoJCXZlYzMgRnIgPSBtaXgoIHNwZWN1bGFyQ29sb3IsIGlyaWRlc2NlbmNlRjAsIGlyaWRlc2NlbmNlICk7CgkjZWxzZQoJCXZlYzMgRnIgPSBzcGVjdWxhckNvbG9yOwoJI2VuZGlmCgl2ZWMzIEZzc0VzcyA9IEZyICogZmFiLnggKyBzcGVjdWxhckY5MCAqIGZhYi55OwoJZmxvYXQgRXNzID0gZmFiLnggKyBmYWIueTsKCWZsb2F0IEVtcyA9IDEuMCAtIEVzczsKCXZlYzMgRmF2ZyA9IEZyICsgKCAxLjAgLSBGciApICogMC4wNDc2MTk7CXZlYzMgRm1zID0gRnNzRXNzICogRmF2ZyAvICggMS4wIC0gRW1zICogRmF2ZyApOwoJc2luZ2xlU2NhdHRlciArPSBGc3NFc3M7CgltdWx0aVNjYXR0ZXIgKz0gRm1zICogRW1zOwp9CiNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDAKCXZvaWQgUkVfRGlyZWN0X1JlY3RBcmVhX1BoeXNpY2FsKCBjb25zdCBpbiBSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHQsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkgewoJCXZlYzMgbm9ybWFsID0gZ2VvbWV0cnlOb3JtYWw7CgkJdmVjMyB2aWV3RGlyID0gZ2VvbWV0cnlWaWV3RGlyOwoJCXZlYzMgcG9zaXRpb24gPSBnZW9tZXRyeVBvc2l0aW9uOwoJCXZlYzMgbGlnaHRQb3MgPSByZWN0QXJlYUxpZ2h0LnBvc2l0aW9uOwoJCXZlYzMgaGFsZldpZHRoID0gcmVjdEFyZWFMaWdodC5oYWxmV2lkdGg7CgkJdmVjMyBoYWxmSGVpZ2h0ID0gcmVjdEFyZWFMaWdodC5oYWxmSGVpZ2h0OwoJCXZlYzMgbGlnaHRDb2xvciA9IHJlY3RBcmVhTGlnaHQuY29sb3I7CgkJZmxvYXQgcm91Z2huZXNzID0gbWF0ZXJpYWwucm91Z2huZXNzOwoJCXZlYzMgcmVjdENvb3Jkc1sgNCBdOwoJCXJlY3RDb29yZHNbIDAgXSA9IGxpZ2h0UG9zICsgaGFsZldpZHRoIC0gaGFsZkhlaWdodDsJCXJlY3RDb29yZHNbIDEgXSA9IGxpZ2h0UG9zIC0gaGFsZldpZHRoIC0gaGFsZkhlaWdodDsKCQlyZWN0Q29vcmRzWyAyIF0gPSBsaWdodFBvcyAtIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7CgkJcmVjdENvb3Jkc1sgMyBdID0gbGlnaHRQb3MgKyBoYWxmV2lkdGggKyBoYWxmSGVpZ2h0OwoJCXZlYzIgdXYgPSBMVENfVXYoIG5vcm1hbCwgdmlld0Rpciwgcm91Z2huZXNzICk7CgkJdmVjNCB0MSA9IHRleHR1cmUyRCggbHRjXzEsIHV2ICk7CgkJdmVjNCB0MiA9IHRleHR1cmUyRCggbHRjXzIsIHV2ICk7CgkJbWF0MyBtSW52ID0gbWF0MygKCQkJdmVjMyggdDEueCwgMCwgdDEueSApLAoJCQl2ZWMzKCAgICAwLCAxLCAgICAwICksCgkJCXZlYzMoIHQxLnosIDAsIHQxLncgKQoJCSk7CgkJdmVjMyBmcmVzbmVsID0gKCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICogdDIueCArICggdmVjMyggMS4wICkgLSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICkgKiB0Mi55ICk7CgkJcmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gbGlnaHRDb2xvciAqIGZyZXNuZWwgKiBMVENfRXZhbHVhdGUoIG5vcm1hbCwgdmlld0RpciwgcG9zaXRpb24sIG1JbnYsIHJlY3RDb29yZHMgKTsKCQlyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGxpZ2h0Q29sb3IgKiBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKiBMVENfRXZhbHVhdGUoIG5vcm1hbCwgdmlld0RpciwgcG9zaXRpb24sIG1hdDMoIDEuMCApLCByZWN0Q29vcmRzICk7Cgl9CiNlbmRpZgp2b2lkIFJFX0RpcmVjdF9QaHlzaWNhbCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7CglmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Tm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApOwoJdmVjMyBpcnJhZGlhbmNlID0gZG90TkwgKiBkaXJlY3RMaWdodC5jb2xvcjsKCSNpZmRlZiBVU0VfQ0xFQVJDT0FUCgkJZmxvYXQgZG90TkxjYyA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApOwoJCXZlYzMgY2NJcnJhZGlhbmNlID0gZG90TkxjYyAqIGRpcmVjdExpZ2h0LmNvbG9yOwoJCWNsZWFyY29hdFNwZWN1bGFyRGlyZWN0ICs9IGNjSXJyYWRpYW5jZSAqIEJSREZfR0dYX0NsZWFyY29hdCggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbCApOwoJI2VuZGlmCgkjaWZkZWYgVVNFX1NIRUVOCgkJc2hlZW5TcGVjdWxhckRpcmVjdCArPSBpcnJhZGlhbmNlICogQlJERl9TaGVlbiggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Tm9ybWFsLCBtYXRlcmlhbC5zaGVlbkNvbG9yLCBtYXRlcmlhbC5zaGVlblJvdWdobmVzcyApOwoJI2VuZGlmCglyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9HR1goIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeU5vcm1hbCwgbWF0ZXJpYWwgKTsKCXJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7Cn0Kdm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7CglyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7Cn0Kdm9pZCBSRV9JbmRpcmVjdFNwZWN1bGFyX1BoeXNpY2FsKCBjb25zdCBpbiB2ZWMzIHJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgY2xlYXJjb2F0UmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0KSB7CgkjaWZkZWYgVVNFX0NMRUFSQ09BVAoJCWNsZWFyY29hdFNwZWN1bGFySW5kaXJlY3QgKz0gY2xlYXJjb2F0UmFkaWFuY2UgKiBFbnZpcm9ubWVudEJSREYoIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIsIG1hdGVyaWFsLmNsZWFyY29hdEYwLCBtYXRlcmlhbC5jbGVhcmNvYXRGOTAsIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyApOwoJI2VuZGlmCgkjaWZkZWYgVVNFX1NIRUVOCgkJc2hlZW5TcGVjdWxhckluZGlyZWN0ICs9IGlycmFkaWFuY2UgKiBtYXRlcmlhbC5zaGVlbkNvbG9yICogSUJMU2hlZW5CUkRGKCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBtYXRlcmlhbC5zaGVlblJvdWdobmVzcyApOwoJI2VuZGlmCgl2ZWMzIHNpbmdsZVNjYXR0ZXJpbmcgPSB2ZWMzKCAwLjAgKTsKCXZlYzMgbXVsdGlTY2F0dGVyaW5nID0gdmVjMyggMC4wICk7Cgl2ZWMzIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZSA9IGlycmFkaWFuY2UgKiBSRUNJUFJPQ0FMX1BJOwoJI2lmZGVmIFVTRV9JUklERVNDRU5DRQoJCWNvbXB1dGVNdWx0aXNjYXR0ZXJpbmdJcmlkZXNjZW5jZSggZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsIG1hdGVyaWFsLmlyaWRlc2NlbmNlLCBtYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwsIG1hdGVyaWFsLnJvdWdobmVzcywgc2luZ2xlU2NhdHRlcmluZywgbXVsdGlTY2F0dGVyaW5nICk7CgkjZWxzZQoJCWNvbXB1dGVNdWx0aXNjYXR0ZXJpbmcoIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyRjkwLCBtYXRlcmlhbC5yb3VnaG5lc3MsIHNpbmdsZVNjYXR0ZXJpbmcsIG11bHRpU2NhdHRlcmluZyApOwoJI2VuZGlmCgl2ZWMzIHRvdGFsU2NhdHRlcmluZyA9IHNpbmdsZVNjYXR0ZXJpbmcgKyBtdWx0aVNjYXR0ZXJpbmc7Cgl2ZWMzIGRpZmZ1c2UgPSBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKiAoIDEuMCAtIG1heCggbWF4KCB0b3RhbFNjYXR0ZXJpbmcuciwgdG90YWxTY2F0dGVyaW5nLmcgKSwgdG90YWxTY2F0dGVyaW5nLmIgKSApOwoJcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArPSByYWRpYW5jZSAqIHNpbmdsZVNjYXR0ZXJpbmc7CglyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICs9IG11bHRpU2NhdHRlcmluZyAqIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZTsKCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBkaWZmdXNlICogY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlOwp9CiNkZWZpbmUgUkVfRGlyZWN0CQkJCVJFX0RpcmVjdF9QaHlzaWNhbAojZGVmaW5lIFJFX0RpcmVjdF9SZWN0QXJlYQkJUkVfRGlyZWN0X1JlY3RBcmVhX1BoeXNpY2FsCiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlCQlSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWwKI2RlZmluZSBSRV9JbmRpcmVjdFNwZWN1bGFyCQlSRV9JbmRpcmVjdFNwZWN1bGFyX1BoeXNpY2FsCmZsb2F0IGNvbXB1dGVTcGVjdWxhck9jY2x1c2lvbiggY29uc3QgaW4gZmxvYXQgZG90TlYsIGNvbnN0IGluIGZsb2F0IGFtYmllbnRPY2NsdXNpb24sIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHsKCXJldHVybiBzYXR1cmF0ZSggcG93KCBkb3ROViArIGFtYmllbnRPY2NsdXNpb24sIGV4cDIoIC0gMTYuMCAqIHJvdWdobmVzcyAtIDEuMCApICkgLSAxLjAgKyBhbWJpZW50T2NjbHVzaW9uICk7Cn1gLEJvPWAKdmVjMyBnZW9tZXRyeVBvc2l0aW9uID0gLSB2Vmlld1Bvc2l0aW9uOwp2ZWMzIGdlb21ldHJ5Tm9ybWFsID0gbm9ybWFsOwp2ZWMzIGdlb21ldHJ5Vmlld0RpciA9ICggaXNPcnRob2dyYXBoaWMgKSA/IHZlYzMoIDAsIDAsIDEgKSA6IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApOwp2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsID0gdmVjMyggMC4wICk7CiNpZmRlZiBVU0VfQ0xFQVJDT0FUCglnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCA9IGNsZWFyY29hdE5vcm1hbDsKI2VuZGlmCiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0UKCWZsb2F0IGRvdE5WaSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyICkgKTsKCWlmICggbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3MgPT0gMC4wICkgewoJCW1hdGVyaWFsLmlyaWRlc2NlbmNlID0gMC4wOwoJfSBlbHNlIHsKCQltYXRlcmlhbC5pcmlkZXNjZW5jZSA9IHNhdHVyYXRlKCBtYXRlcmlhbC5pcmlkZXNjZW5jZSApOwoJfQoJaWYgKCBtYXRlcmlhbC5pcmlkZXNjZW5jZSA+IDAuMCApIHsKCQltYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwgPSBldmFsSXJpZGVzY2VuY2UoIDEuMCwgbWF0ZXJpYWwuaXJpZGVzY2VuY2VJT1IsIGRvdE5WaSwgbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3MsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKTsKCQltYXRlcmlhbC5pcmlkZXNjZW5jZUYwID0gU2NobGlja190b19GMCggbWF0ZXJpYWwuaXJpZGVzY2VuY2VGcmVzbmVsLCAxLjAsIGRvdE5WaSApOwoJfQojZW5kaWYKSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodDsKI2lmICggTlVNX1BPSU5UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKQoJUG9pbnRMaWdodCBwb2ludExpZ2h0OwoJI2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDAKCVBvaW50TGlnaHRTaGFkb3cgcG9pbnRMaWdodFNoYWRvdzsKCSNlbmRpZgoJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJZm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHsKCQlwb2ludExpZ2h0ID0gcG9pbnRMaWdodHNbIGkgXTsKCQlnZXRQb2ludExpZ2h0SW5mbyggcG9pbnRMaWdodCwgZ2VvbWV0cnlQb3NpdGlvbiwgZGlyZWN0TGlnaHQgKTsKCQkjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmICggVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTICkKCQlwb2ludExpZ2h0U2hhZG93ID0gcG9pbnRMaWdodFNoYWRvd3NbIGkgXTsKCQlkaXJlY3RMaWdodC5jb2xvciAqPSAoIGRpcmVjdExpZ2h0LnZpc2libGUgJiYgcmVjZWl2ZVNoYWRvdyApID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dJbnRlbnNpdHksIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93QmlhcywgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0sIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93Q2FtZXJhTmVhciwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dDYW1lcmFGYXIgKSA6IDEuMDsKCQkjZW5kaWYKCQlSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeVBvc2l0aW9uLCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7Cgl9CgkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAojZW5kaWYKI2lmICggTlVNX1NQT1RfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApCglTcG90TGlnaHQgc3BvdExpZ2h0OwoJdmVjNCBzcG90Q29sb3I7Cgl2ZWMzIHNwb3RMaWdodENvb3JkOwoJYm9vbCBpblNwb3RMaWdodE1hcDsKCSNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDAKCVNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHRTaGFkb3c7CgkjZW5kaWYKCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCWZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHsKCQlzcG90TGlnaHQgPSBzcG90TGlnaHRzWyBpIF07CgkJZ2V0U3BvdExpZ2h0SW5mbyggc3BvdExpZ2h0LCBnZW9tZXRyeVBvc2l0aW9uLCBkaXJlY3RMaWdodCApOwoJCSNpZiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTX1dJVEhfTUFQUyApCgkJI2RlZmluZSBTUE9UX0xJR0hUX01BUF9JTkRFWCBVTlJPTExFRF9MT09QX0lOREVYCgkJI2VsaWYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyApCgkJI2RlZmluZSBTUE9UX0xJR0hUX01BUF9JTkRFWCBOVU1fU1BPVF9MSUdIVF9NQVBTCgkJI2Vsc2UKCQkjZGVmaW5lIFNQT1RfTElHSFRfTUFQX0lOREVYICggVU5ST0xMRURfTE9PUF9JTkRFWCAtIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgKyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTX1dJVEhfTUFQUyApCgkJI2VuZGlmCgkJI2lmICggU1BPVF9MSUdIVF9NQVBfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9NQVBTICkKCQkJc3BvdExpZ2h0Q29vcmQgPSB2U3BvdExpZ2h0Q29vcmRbIGkgXS54eXogLyB2U3BvdExpZ2h0Q29vcmRbIGkgXS53OwoJCQlpblNwb3RMaWdodE1hcCA9IGFsbCggbGVzc1RoYW4oIGFicyggc3BvdExpZ2h0Q29vcmQgKiAyLiAtIDEuICksIHZlYzMoIDEuMCApICkgKTsKCQkJc3BvdENvbG9yID0gdGV4dHVyZTJEKCBzcG90TGlnaHRNYXBbIFNQT1RfTElHSFRfTUFQX0lOREVYIF0sIHNwb3RMaWdodENvb3JkLnh5ICk7CgkJCWRpcmVjdExpZ2h0LmNvbG9yID0gaW5TcG90TGlnaHRNYXAgPyBkaXJlY3RMaWdodC5jb2xvciAqIHNwb3RDb2xvci5yZ2IgOiBkaXJlY3RMaWdodC5jb2xvcjsKCQkjZW5kaWYKCQkjdW5kZWYgU1BPVF9MSUdIVF9NQVBfSU5ERVgKCQkjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmICggVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgKQoJCXNwb3RMaWdodFNoYWRvdyA9IHNwb3RMaWdodFNoYWRvd3NbIGkgXTsKCQlkaXJlY3RMaWdodC5jb2xvciAqPSAoIGRpcmVjdExpZ2h0LnZpc2libGUgJiYgcmVjZWl2ZVNoYWRvdyApID8gZ2V0U2hhZG93KCBzcG90U2hhZG93TWFwWyBpIF0sIHNwb3RMaWdodFNoYWRvdy5zaGFkb3dNYXBTaXplLCBzcG90TGlnaHRTaGFkb3cuc2hhZG93SW50ZW5zaXR5LCBzcG90TGlnaHRTaGFkb3cuc2hhZG93Qmlhcywgc3BvdExpZ2h0U2hhZG93LnNoYWRvd1JhZGl1cywgdlNwb3RMaWdodENvb3JkWyBpIF0gKSA6IDEuMDsKCQkjZW5kaWYKCQlSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeVBvc2l0aW9uLCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7Cgl9CgkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAojZW5kaWYKI2lmICggTlVNX0RJUl9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0ICkKCURpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodDsKCSNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMAoJRGlyZWN0aW9uYWxMaWdodFNoYWRvdyBkaXJlY3Rpb25hbExpZ2h0U2hhZG93OwoJI2VuZGlmCgkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHsKCQlkaXJlY3Rpb25hbExpZ2h0ID0gZGlyZWN0aW9uYWxMaWdodHNbIGkgXTsKCQlnZXREaXJlY3Rpb25hbExpZ2h0SW5mbyggZGlyZWN0aW9uYWxMaWdodCwgZGlyZWN0TGlnaHQgKTsKCQkjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmICggVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9ESVJfTElHSFRfU0hBRE9XUyApCgkJZGlyZWN0aW9uYWxMaWdodFNoYWRvdyA9IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBpIF07CgkJZGlyZWN0TGlnaHQuY29sb3IgKj0gKCBkaXJlY3RMaWdodC52aXNpYmxlICYmIHJlY2VpdmVTaGFkb3cgKSA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodFNoYWRvdy5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93LnNoYWRvd0ludGVuc2l0eSwgZGlyZWN0aW9uYWxMaWdodFNoYWRvdy5zaGFkb3dCaWFzLCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93LnNoYWRvd1JhZGl1cywgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSApIDogMS4wOwoJCSNlbmRpZgoJCVJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5UG9zaXRpb24sIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTsKCX0KCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCiNlbmRpZgojaWYgKCBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3RfUmVjdEFyZWEgKQoJUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0OwoJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJZm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1JFQ1RfQVJFQV9MSUdIVFM7IGkgKysgKSB7CgkJcmVjdEFyZWFMaWdodCA9IHJlY3RBcmVhTGlnaHRzWyBpIF07CgkJUkVfRGlyZWN0X1JlY3RBcmVhKCByZWN0QXJlYUxpZ2h0LCBnZW9tZXRyeVBvc2l0aW9uLCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7Cgl9CgkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAojZW5kaWYKI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApCgl2ZWMzIGlibElycmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTsKCXZlYzMgaXJyYWRpYW5jZSA9IGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGFtYmllbnRMaWdodENvbG9yICk7CgkjaWYgZGVmaW5lZCggVVNFX0xJR0hUX1BST0JFUyApCgkJaXJyYWRpYW5jZSArPSBnZXRMaWdodFByb2JlSXJyYWRpYW5jZSggbGlnaHRQcm9iZSwgZ2VvbWV0cnlOb3JtYWwgKTsKCSNlbmRpZgoJI2lmICggTlVNX0hFTUlfTElHSFRTID4gMCApCgkJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJCWZvciAoIGludCBpID0gMDsgaSA8IE5VTV9IRU1JX0xJR0hUUzsgaSArKyApIHsKCQkJaXJyYWRpYW5jZSArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGdlb21ldHJ5Tm9ybWFsICk7CgkJfQoJCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCgkjZW5kaWYKI2VuZGlmCiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdFNwZWN1bGFyICkKCXZlYzMgcmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTsKCXZlYzMgY2xlYXJjb2F0UmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTsKI2VuZGlmYCx6bz1gI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApCgkjaWZkZWYgVVNFX0xJR0hUTUFQCgkJdmVjNCBsaWdodE1hcFRleGVsID0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdkxpZ2h0TWFwVXYgKTsKCQl2ZWMzIGxpZ2h0TWFwSXJyYWRpYW5jZSA9IGxpZ2h0TWFwVGV4ZWwucmdiICogbGlnaHRNYXBJbnRlbnNpdHk7CgkJaXJyYWRpYW5jZSArPSBsaWdodE1hcElycmFkaWFuY2U7CgkjZW5kaWYKCSNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggU1RBTkRBUkQgKSAmJiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWICkKCQlpYmxJcnJhZGlhbmNlICs9IGdldElCTElycmFkaWFuY2UoIGdlb21ldHJ5Tm9ybWFsICk7CgkjZW5kaWYKI2VuZGlmCiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApCgkjaWZkZWYgVVNFX0FOSVNPVFJPUFkKCQlyYWRpYW5jZSArPSBnZXRJQkxBbmlzb3Ryb3B5UmFkaWFuY2UoIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlOb3JtYWwsIG1hdGVyaWFsLnJvdWdobmVzcywgbWF0ZXJpYWwuYW5pc290cm9weUIsIG1hdGVyaWFsLmFuaXNvdHJvcHkgKTsKCSNlbHNlCgkJcmFkaWFuY2UgKz0gZ2V0SUJMUmFkaWFuY2UoIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlOb3JtYWwsIG1hdGVyaWFsLnJvdWdobmVzcyApOwoJI2VuZGlmCgkjaWZkZWYgVVNFX0NMRUFSQ09BVAoJCWNsZWFyY29hdFJhZGlhbmNlICs9IGdldElCTFJhZGlhbmNlKCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKTsKCSNlbmRpZgojZW5kaWZgLEdvPWAjaWYgZGVmaW5lZCggUkVfSW5kaXJlY3REaWZmdXNlICkKCVJFX0luZGlyZWN0RGlmZnVzZSggaXJyYWRpYW5jZSwgZ2VvbWV0cnlQb3NpdGlvbiwgZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApOwojZW5kaWYKI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKQoJUkVfSW5kaXJlY3RTcGVjdWxhciggcmFkaWFuY2UsIGlibElycmFkaWFuY2UsIGNsZWFyY29hdFJhZGlhbmNlLCBnZW9tZXRyeVBvc2l0aW9uLCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7CiNlbmRpZmAsSG89YCNpZiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUYgKQoJZ2xfRnJhZ0RlcHRoID0gdklzUGVyc3BlY3RpdmUgPT0gMC4wID8gZ2xfRnJhZ0Nvb3JkLnogOiBsb2cyKCB2RnJhZ0RlcHRoICkgKiBsb2dEZXB0aEJ1ZkZDICogMC41OwojZW5kaWZgLFZvPWAjaWYgZGVmaW5lZCggVVNFX0xPR0RFUFRIQlVGICkKCXVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQzsKCXZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDsKCXZhcnlpbmcgZmxvYXQgdklzUGVyc3BlY3RpdmU7CiNlbmRpZmAsa289YCNpZmRlZiBVU0VfTE9HREVQVEhCVUYKCXZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDsKCXZhcnlpbmcgZmxvYXQgdklzUGVyc3BlY3RpdmU7CiNlbmRpZmAsV289YCNpZmRlZiBVU0VfTE9HREVQVEhCVUYKCXZGcmFnRGVwdGggPSAxLjAgKyBnbF9Qb3NpdGlvbi53OwoJdklzUGVyc3BlY3RpdmUgPSBmbG9hdCggaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApICk7CiNlbmRpZmAsWG89YCNpZmRlZiBVU0VfTUFQCgl2ZWM0IHNhbXBsZWREaWZmdXNlQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdk1hcFV2ICk7CgkjaWZkZWYgREVDT0RFX1ZJREVPX1RFWFRVUkUKCQlzYW1wbGVkRGlmZnVzZUNvbG9yID0gc1JHQlRyYW5zZmVyRU9URiggc2FtcGxlZERpZmZ1c2VDb2xvciApOwoJI2VuZGlmCglkaWZmdXNlQ29sb3IgKj0gc2FtcGxlZERpZmZ1c2VDb2xvcjsKI2VuZGlmYCxxbz1gI2lmZGVmIFVTRV9NQVAKCXVuaWZvcm0gc2FtcGxlcjJEIG1hcDsKI2VuZGlmYCxZbz1gI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKQoJI2lmIGRlZmluZWQoIFVTRV9QT0lOVFNfVVYgKQoJCXZlYzIgdXYgPSB2VXY7CgkjZWxzZQoJCXZlYzIgdXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnksIDEgKSApLnh5OwoJI2VuZGlmCiNlbmRpZgojaWZkZWYgVVNFX01BUAoJZGlmZnVzZUNvbG9yICo9IHRleHR1cmUyRCggbWFwLCB1diApOwojZW5kaWYKI2lmZGVmIFVTRV9BTFBIQU1BUAoJZGlmZnVzZUNvbG9yLmEgKj0gdGV4dHVyZTJEKCBhbHBoYU1hcCwgdXYgKS5nOwojZW5kaWZgLCRvPWAjaWYgZGVmaW5lZCggVVNFX1BPSU5UU19VViApCgl2YXJ5aW5nIHZlYzIgdlV2OwojZWxzZQoJI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKQoJCXVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTsKCSNlbmRpZgojZW5kaWYKI2lmZGVmIFVTRV9NQVAKCXVuaWZvcm0gc2FtcGxlcjJEIG1hcDsKI2VuZGlmCiNpZmRlZiBVU0VfQUxQSEFNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwOwojZW5kaWZgLEtvPWBmbG9hdCBtZXRhbG5lc3NGYWN0b3IgPSBtZXRhbG5lc3M7CiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQCgl2ZWM0IHRleGVsTWV0YWxuZXNzID0gdGV4dHVyZTJEKCBtZXRhbG5lc3NNYXAsIHZNZXRhbG5lc3NNYXBVdiApOwoJbWV0YWxuZXNzRmFjdG9yICo9IHRleGVsTWV0YWxuZXNzLmI7CiNlbmRpZmAsWm89YCNpZmRlZiBVU0VfTUVUQUxORVNTTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBtZXRhbG5lc3NNYXA7CiNlbmRpZmAsam89YCNpZmRlZiBVU0VfSU5TVEFOQ0lOR19NT1JQSAoJZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBNT1JQSFRBUkdFVFNfQ09VTlQgXTsKCWZsb2F0IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZSA9IHRleGVsRmV0Y2goIG1vcnBoVGV4dHVyZSwgaXZlYzIoIDAsIGdsX0luc3RhbmNlSUQgKSwgMCApLnI7Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7CgkJbW9ycGhUYXJnZXRJbmZsdWVuY2VzW2ldID0gIHRleGVsRmV0Y2goIG1vcnBoVGV4dHVyZSwgaXZlYzIoIGkgKyAxLCBnbF9JbnN0YW5jZUlEICksIDAgKS5yOwoJfQojZW5kaWZgLEpvPWAjaWYgZGVmaW5lZCggVVNFX01PUlBIQ09MT1JTICkKCXZDb2xvciAqPSBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2U7Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7CgkJI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApCgkJCWlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gIT0gMC4wICkgdkNvbG9yICs9IGdldE1vcnBoKCBnbF9WZXJ0ZXhJRCwgaSwgMiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07CgkJI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SICkKCQkJaWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPSAwLjAgKSB2Q29sb3IgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAyICkucmdiICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07CgkJI2VuZGlmCgl9CiNlbmRpZmAsUW89YCNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTCglvYmplY3ROb3JtYWwgKj0gbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlOwoJZm9yICggaW50IGkgPSAwOyBpIDwgTU9SUEhUQVJHRVRTX0NPVU5UOyBpICsrICkgewoJCWlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gIT0gMC4wICkgb2JqZWN0Tm9ybWFsICs9IGdldE1vcnBoKCBnbF9WZXJ0ZXhJRCwgaSwgMSApLnh5eiAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdOwoJfQojZW5kaWZgLGVsPWAjaWZkZWYgVVNFX01PUlBIVEFSR0VUUwoJI2lmbmRlZiBVU0VfSU5TVEFOQ0lOR19NT1JQSAoJCXVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlOwoJCXVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBNT1JQSFRBUkdFVFNfQ09VTlQgXTsKCSNlbmRpZgoJdW5pZm9ybSBzYW1wbGVyMkRBcnJheSBtb3JwaFRhcmdldHNUZXh0dXJlOwoJdW5pZm9ybSBpdmVjMiBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZTsKCXZlYzQgZ2V0TW9ycGgoIGNvbnN0IGluIGludCB2ZXJ0ZXhJbmRleCwgY29uc3QgaW4gaW50IG1vcnBoVGFyZ2V0SW5kZXgsIGNvbnN0IGluIGludCBvZmZzZXQgKSB7CgkJaW50IHRleGVsSW5kZXggPSB2ZXJ0ZXhJbmRleCAqIE1PUlBIVEFSR0VUU19URVhUVVJFX1NUUklERSArIG9mZnNldDsKCQlpbnQgeSA9IHRleGVsSW5kZXggLyBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZS54OwoJCWludCB4ID0gdGV4ZWxJbmRleCAtIHkgKiBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZS54OwoJCWl2ZWMzIG1vcnBoVVYgPSBpdmVjMyggeCwgeSwgbW9ycGhUYXJnZXRJbmRleCApOwoJCXJldHVybiB0ZXhlbEZldGNoKCBtb3JwaFRhcmdldHNUZXh0dXJlLCBtb3JwaFVWLCAwICk7Cgl9CiNlbmRpZmAsdGw9YCNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTCgl0cmFuc2Zvcm1lZCAqPSBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2U7Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7CgkJaWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPSAwLjAgKSB0cmFuc2Zvcm1lZCArPSBnZXRNb3JwaCggZ2xfVmVydGV4SUQsIGksIDAgKS54eXogKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTsKCX0KI2VuZGlmYCxubD1gZmxvYXQgZmFjZURpcmVjdGlvbiA9IGdsX0Zyb250RmFjaW5nID8gMS4wIDogLSAxLjA7CiNpZmRlZiBGTEFUX1NIQURFRAoJdmVjMyBmZHggPSBkRmR4KCB2Vmlld1Bvc2l0aW9uICk7Cgl2ZWMzIGZkeSA9IGRGZHkoIHZWaWV3UG9zaXRpb24gKTsKCXZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggZmR4LCBmZHkgKSApOwojZWxzZQoJdmVjMyBub3JtYWwgPSBub3JtYWxpemUoIHZOb3JtYWwgKTsKCSNpZmRlZiBET1VCTEVfU0lERUQKCQlub3JtYWwgKj0gZmFjZURpcmVjdGlvbjsKCSNlbmRpZgojZW5kaWYKI2lmIGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFICkgfHwgZGVmaW5lZCggVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU5JU09UUk9QWSApCgkjaWZkZWYgVVNFX1RBTkdFTlQKCQltYXQzIHRibiA9IG1hdDMoIG5vcm1hbGl6ZSggdlRhbmdlbnQgKSwgbm9ybWFsaXplKCB2Qml0YW5nZW50ICksIG5vcm1hbCApOwoJI2Vsc2UKCQltYXQzIHRibiA9IGdldFRhbmdlbnRGcmFtZSggLSB2Vmlld1Bvc2l0aW9uLCBub3JtYWwsCgkJI2lmIGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKQoJCQl2Tm9ybWFsTWFwVXYKCQkjZWxpZiBkZWZpbmVkKCBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUCApCgkJCXZDbGVhcmNvYXROb3JtYWxNYXBVdgoJCSNlbHNlCgkJCXZVdgoJCSNlbmRpZgoJCSk7CgkjZW5kaWYKCSNpZiBkZWZpbmVkKCBET1VCTEVfU0lERUQgKSAmJiAhIGRlZmluZWQoIEZMQVRfU0hBREVEICkKCQl0Ym5bMF0gKj0gZmFjZURpcmVjdGlvbjsKCQl0Ym5bMV0gKj0gZmFjZURpcmVjdGlvbjsKCSNlbmRpZgojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQCgkjaWZkZWYgVVNFX1RBTkdFTlQKCQltYXQzIHRibjIgPSBtYXQzKCBub3JtYWxpemUoIHZUYW5nZW50ICksIG5vcm1hbGl6ZSggdkJpdGFuZ2VudCApLCBub3JtYWwgKTsKCSNlbHNlCgkJbWF0MyB0Ym4yID0gZ2V0VGFuZ2VudEZyYW1lKCAtIHZWaWV3UG9zaXRpb24sIG5vcm1hbCwgdkNsZWFyY29hdE5vcm1hbE1hcFV2ICk7CgkjZW5kaWYKCSNpZiBkZWZpbmVkKCBET1VCTEVfU0lERUQgKSAmJiAhIGRlZmluZWQoIEZMQVRfU0hBREVEICkKCQl0Ym4yWzBdICo9IGZhY2VEaXJlY3Rpb247CgkJdGJuMlsxXSAqPSBmYWNlRGlyZWN0aW9uOwoJI2VuZGlmCiNlbmRpZgp2ZWMzIG5vblBlcnR1cmJlZE5vcm1hbCA9IG5vcm1hbDtgLGlsPWAjaWZkZWYgVVNFX05PUk1BTE1BUF9PQkpFQ1RTUEFDRQoJbm9ybWFsID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZOb3JtYWxNYXBVdiApLnh5eiAqIDIuMCAtIDEuMDsKCSNpZmRlZiBGTElQX1NJREVECgkJbm9ybWFsID0gLSBub3JtYWw7CgkjZW5kaWYKCSNpZmRlZiBET1VCTEVfU0lERUQKCQlub3JtYWwgPSBub3JtYWwgKiBmYWNlRGlyZWN0aW9uOwoJI2VuZGlmCglub3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApOwojZWxpZiBkZWZpbmVkKCBVU0VfTk9STUFMTUFQX1RBTkdFTlRTUEFDRSApCgl2ZWMzIG1hcE4gPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdk5vcm1hbE1hcFV2ICkueHl6ICogMi4wIC0gMS4wOwoJbWFwTi54eSAqPSBub3JtYWxTY2FsZTsKCW5vcm1hbCA9IG5vcm1hbGl6ZSggdGJuICogbWFwTiApOwojZWxpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApCglub3JtYWwgPSBwZXJ0dXJiTm9ybWFsQXJiKCAtIHZWaWV3UG9zaXRpb24sIG5vcm1hbCwgZEhkeHlfZndkKCksIGZhY2VEaXJlY3Rpb24gKTsKI2VuZGlmYCxybD1gI2lmbmRlZiBGTEFUX1NIQURFRAoJdmFyeWluZyB2ZWMzIHZOb3JtYWw7CgkjaWZkZWYgVVNFX1RBTkdFTlQKCQl2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7CgkJdmFyeWluZyB2ZWMzIHZCaXRhbmdlbnQ7CgkjZW5kaWYKI2VuZGlmYCxzbD1gI2lmbmRlZiBGTEFUX1NIQURFRAoJdmFyeWluZyB2ZWMzIHZOb3JtYWw7CgkjaWZkZWYgVVNFX1RBTkdFTlQKCQl2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7CgkJdmFyeWluZyB2ZWMzIHZCaXRhbmdlbnQ7CgkjZW5kaWYKI2VuZGlmYCxhbD1gI2lmbmRlZiBGTEFUX1NIQURFRAoJdk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTsKCSNpZmRlZiBVU0VfVEFOR0VOVAoJCXZUYW5nZW50ID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZFRhbmdlbnQgKTsKCQl2Qml0YW5nZW50ID0gbm9ybWFsaXplKCBjcm9zcyggdk5vcm1hbCwgdlRhbmdlbnQgKSAqIHRhbmdlbnQudyApOwoJI2VuZGlmCiNlbmRpZmAsb2w9YCNpZmRlZiBVU0VfTk9STUFMTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7Cgl1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7CiNlbmRpZgojaWZkZWYgVVNFX05PUk1BTE1BUF9PQkpFQ1RTUEFDRQoJdW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDsKI2VuZGlmCiNpZiAhIGRlZmluZWQgKCBVU0VfVEFOR0VOVCApICYmICggZGVmaW5lZCAoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFICkgfHwgZGVmaW5lZCAoIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX0FOSVNPVFJPUFkgKSApCgltYXQzIGdldFRhbmdlbnRGcmFtZSggdmVjMyBleWVfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMiB1diApIHsKCQl2ZWMzIHEwID0gZEZkeCggZXllX3Bvcy54eXogKTsKCQl2ZWMzIHExID0gZEZkeSggZXllX3Bvcy54eXogKTsKCQl2ZWMyIHN0MCA9IGRGZHgoIHV2LnN0ICk7CgkJdmVjMiBzdDEgPSBkRmR5KCB1di5zdCApOwoJCXZlYzMgTiA9IHN1cmZfbm9ybTsKCQl2ZWMzIHExcGVycCA9IGNyb3NzKCBxMSwgTiApOwoJCXZlYzMgcTBwZXJwID0gY3Jvc3MoIE4sIHEwICk7CgkJdmVjMyBUID0gcTFwZXJwICogc3QwLnggKyBxMHBlcnAgKiBzdDEueDsKCQl2ZWMzIEIgPSBxMXBlcnAgKiBzdDAueSArIHEwcGVycCAqIHN0MS55OwoJCWZsb2F0IGRldCA9IG1heCggZG90KCBULCBUICksIGRvdCggQiwgQiApICk7CgkJZmxvYXQgc2NhbGUgPSAoIGRldCA9PSAwLjAgKSA/IDAuMCA6IGludmVyc2VzcXJ0KCBkZXQgKTsKCQlyZXR1cm4gbWF0MyggVCAqIHNjYWxlLCBCICogc2NhbGUsIE4gKTsKCX0KI2VuZGlmYCxsbD1gI2lmZGVmIFVTRV9DTEVBUkNPQVQKCXZlYzMgY2xlYXJjb2F0Tm9ybWFsID0gbm9uUGVydHVyYmVkTm9ybWFsOwojZW5kaWZgLGNsPWAjaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAKCXZlYzMgY2xlYXJjb2F0TWFwTiA9IHRleHR1cmUyRCggY2xlYXJjb2F0Tm9ybWFsTWFwLCB2Q2xlYXJjb2F0Tm9ybWFsTWFwVXYgKS54eXogKiAyLjAgLSAxLjA7CgljbGVhcmNvYXRNYXBOLnh5ICo9IGNsZWFyY29hdE5vcm1hbFNjYWxlOwoJY2xlYXJjb2F0Tm9ybWFsID0gbm9ybWFsaXplKCB0Ym4yICogY2xlYXJjb2F0TWFwTiApOwojZW5kaWZgLHVsPWAjaWZkZWYgVVNFX0NMRUFSQ09BVE1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgY2xlYXJjb2F0TWFwOwojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBjbGVhcmNvYXROb3JtYWxNYXA7Cgl1bmlmb3JtIHZlYzIgY2xlYXJjb2F0Tm9ybWFsU2NhbGU7CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyY29hdFJvdWdobmVzc01hcDsKI2VuZGlmYCxobD1gI2lmZGVmIFVTRV9JUklERVNDRU5DRU1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgaXJpZGVzY2VuY2VNYXA7CiNlbmRpZgojaWZkZWYgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUAoJdW5pZm9ybSBzYW1wbGVyMkQgaXJpZGVzY2VuY2VUaGlja25lc3NNYXA7CiNlbmRpZmAsZGw9YCNpZmRlZiBPUEFRVUUKZGlmZnVzZUNvbG9yLmEgPSAxLjA7CiNlbmRpZgojaWZkZWYgVVNFX1RSQU5TTUlTU0lPTgpkaWZmdXNlQ29sb3IuYSAqPSBtYXRlcmlhbC50cmFuc21pc3Npb25BbHBoYTsKI2VuZGlmCmdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7YCxmbD1gdmVjMyBwYWNrTm9ybWFsVG9SR0IoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkgewoJcmV0dXJuIG5vcm1hbGl6ZSggbm9ybWFsICkgKiAwLjUgKyAwLjU7Cn0KdmVjMyB1bnBhY2tSR0JUb05vcm1hbCggY29uc3QgaW4gdmVjMyByZ2IgKSB7CglyZXR1cm4gMi4wICogcmdiLnh5eiAtIDEuMDsKfQpjb25zdCBmbG9hdCBQYWNrVXBzY2FsZSA9IDI1Ni4gLyAyNTUuO2NvbnN0IGZsb2F0IFVucGFja0Rvd25zY2FsZSA9IDI1NS4gLyAyNTYuO2NvbnN0IGZsb2F0IFNoaWZ0UmlnaHQ4ID0gMS4gLyAyNTYuOwpjb25zdCBmbG9hdCBJbnYyNTUgPSAxLiAvIDI1NS47CmNvbnN0IHZlYzQgUGFja0ZhY3RvcnMgPSB2ZWM0KCAxLjAsIDI1Ni4wLCAyNTYuMCAqIDI1Ni4wLCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKTsKY29uc3QgdmVjMiBVbnBhY2tGYWN0b3JzMiA9IHZlYzIoIFVucGFja0Rvd25zY2FsZSwgMS4wIC8gUGFja0ZhY3RvcnMuZyApOwpjb25zdCB2ZWMzIFVucGFja0ZhY3RvcnMzID0gdmVjMyggVW5wYWNrRG93bnNjYWxlIC8gUGFja0ZhY3RvcnMucmcsIDEuMCAvIFBhY2tGYWN0b3JzLmIgKTsKY29uc3QgdmVjNCBVbnBhY2tGYWN0b3JzNCA9IHZlYzQoIFVucGFja0Rvd25zY2FsZSAvIFBhY2tGYWN0b3JzLnJnYiwgMS4wIC8gUGFja0ZhY3RvcnMuYSApOwp2ZWM0IHBhY2tEZXB0aFRvUkdCQSggY29uc3QgaW4gZmxvYXQgdiApIHsKCWlmKCB2IDw9IDAuMCApCgkJcmV0dXJuIHZlYzQoIDAuLCAwLiwgMC4sIDAuICk7CglpZiggdiA+PSAxLjAgKQoJCXJldHVybiB2ZWM0KCAxLiwgMS4sIDEuLCAxLiApOwoJZmxvYXQgdnVmOwoJZmxvYXQgYWYgPSBtb2RmKCB2ICogUGFja0ZhY3RvcnMuYSwgdnVmICk7CglmbG9hdCBiZiA9IG1vZGYoIHZ1ZiAqIFNoaWZ0UmlnaHQ4LCB2dWYgKTsKCWZsb2F0IGdmID0gbW9kZiggdnVmICogU2hpZnRSaWdodDgsIHZ1ZiApOwoJcmV0dXJuIHZlYzQoIHZ1ZiAqIEludjI1NSwgZ2YgKiBQYWNrVXBzY2FsZSwgYmYgKiBQYWNrVXBzY2FsZSwgYWYgKTsKfQp2ZWMzIHBhY2tEZXB0aFRvUkdCKCBjb25zdCBpbiBmbG9hdCB2ICkgewoJaWYoIHYgPD0gMC4wICkKCQlyZXR1cm4gdmVjMyggMC4sIDAuLCAwLiApOwoJaWYoIHYgPj0gMS4wICkKCQlyZXR1cm4gdmVjMyggMS4sIDEuLCAxLiApOwoJZmxvYXQgdnVmOwoJZmxvYXQgYmYgPSBtb2RmKCB2ICogUGFja0ZhY3RvcnMuYiwgdnVmICk7CglmbG9hdCBnZiA9IG1vZGYoIHZ1ZiAqIFNoaWZ0UmlnaHQ4LCB2dWYgKTsKCXJldHVybiB2ZWMzKCB2dWYgKiBJbnYyNTUsIGdmICogUGFja1Vwc2NhbGUsIGJmICk7Cn0KdmVjMiBwYWNrRGVwdGhUb1JHKCBjb25zdCBpbiBmbG9hdCB2ICkgewoJaWYoIHYgPD0gMC4wICkKCQlyZXR1cm4gdmVjMiggMC4sIDAuICk7CglpZiggdiA+PSAxLjAgKQoJCXJldHVybiB2ZWMyKCAxLiwgMS4gKTsKCWZsb2F0IHZ1ZjsKCWZsb2F0IGdmID0gbW9kZiggdiAqIDI1Ni4sIHZ1ZiApOwoJcmV0dXJuIHZlYzIoIHZ1ZiAqIEludjI1NSwgZ2YgKTsKfQpmbG9hdCB1bnBhY2tSR0JBVG9EZXB0aCggY29uc3QgaW4gdmVjNCB2ICkgewoJcmV0dXJuIGRvdCggdiwgVW5wYWNrRmFjdG9yczQgKTsKfQpmbG9hdCB1bnBhY2tSR0JUb0RlcHRoKCBjb25zdCBpbiB2ZWMzIHYgKSB7CglyZXR1cm4gZG90KCB2LCBVbnBhY2tGYWN0b3JzMyApOwp9CmZsb2F0IHVucGFja1JHVG9EZXB0aCggY29uc3QgaW4gdmVjMiB2ICkgewoJcmV0dXJuIHYuciAqIFVucGFja0ZhY3RvcnMyLnIgKyB2LmcgKiBVbnBhY2tGYWN0b3JzMi5nOwp9CnZlYzQgcGFjazJIYWxmVG9SR0JBKCBjb25zdCBpbiB2ZWMyIHYgKSB7Cgl2ZWM0IHIgPSB2ZWM0KCB2LngsIGZyYWN0KCB2LnggKiAyNTUuMCApLCB2LnksIGZyYWN0KCB2LnkgKiAyNTUuMCApICk7CglyZXR1cm4gdmVjNCggci54IC0gci55IC8gMjU1LjAsIHIueSwgci56IC0gci53IC8gMjU1LjAsIHIudyApOwp9CnZlYzIgdW5wYWNrUkdCQVRvMkhhbGYoIGNvbnN0IGluIHZlYzQgdiApIHsKCXJldHVybiB2ZWMyKCB2LnggKyAoIHYueSAvIDI1NS4wICksIHYueiArICggdi53IC8gMjU1LjAgKSApOwp9CmZsb2F0IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCggY29uc3QgaW4gZmxvYXQgdmlld1osIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHsKCXJldHVybiAoIHZpZXdaICsgbmVhciApIC8gKCBuZWFyIC0gZmFyICk7Cn0KZmxvYXQgb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKCBjb25zdCBpbiBmbG9hdCBkZXB0aCwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkgewoJcmV0dXJuIGRlcHRoICogKCBuZWFyIC0gZmFyICkgLSBuZWFyOwp9CmZsb2F0IHZpZXdaVG9QZXJzcGVjdGl2ZURlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkgewoJcmV0dXJuICggKCBuZWFyICsgdmlld1ogKSAqIGZhciApIC8gKCAoIGZhciAtIG5lYXIgKSAqIHZpZXdaICk7Cn0KZmxvYXQgcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooIGNvbnN0IGluIGZsb2F0IGRlcHRoLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7CglyZXR1cm4gKCBuZWFyICogZmFyICkgLyAoICggZmFyIC0gbmVhciApICogZGVwdGggLSBmYXIgKTsKfWAscGw9YCNpZmRlZiBQUkVNVUxUSVBMSUVEX0FMUEhBCglnbF9GcmFnQ29sb3IucmdiICo9IGdsX0ZyYWdDb2xvci5hOwojZW5kaWZgLG1sPWB2ZWM0IG12UG9zaXRpb24gPSB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7CiNpZmRlZiBVU0VfQkFUQ0hJTkcKCW12UG9zaXRpb24gPSBiYXRjaGluZ01hdHJpeCAqIG12UG9zaXRpb247CiNlbmRpZgojaWZkZWYgVVNFX0lOU1RBTkNJTkcKCW12UG9zaXRpb24gPSBpbnN0YW5jZU1hdHJpeCAqIG12UG9zaXRpb247CiNlbmRpZgptdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogbXZQb3NpdGlvbjsKZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtgLGdsPWAjaWZkZWYgRElUSEVSSU5HCglnbF9GcmFnQ29sb3IucmdiID0gZGl0aGVyaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7CiNlbmRpZmAsX2w9YCNpZmRlZiBESVRIRVJJTkcKCXZlYzMgZGl0aGVyaW5nKCB2ZWMzIGNvbG9yICkgewoJCWZsb2F0IGdyaWRfcG9zaXRpb24gPSByYW5kKCBnbF9GcmFnQ29vcmQueHkgKTsKCQl2ZWMzIGRpdGhlcl9zaGlmdF9SR0IgPSB2ZWMzKCAwLjI1IC8gMjU1LjAsIC0wLjI1IC8gMjU1LjAsIDAuMjUgLyAyNTUuMCApOwoJCWRpdGhlcl9zaGlmdF9SR0IgPSBtaXgoIDIuMCAqIGRpdGhlcl9zaGlmdF9SR0IsIC0yLjAgKiBkaXRoZXJfc2hpZnRfUkdCLCBncmlkX3Bvc2l0aW9uICk7CgkJcmV0dXJuIGNvbG9yICsgZGl0aGVyX3NoaWZ0X1JHQjsKCX0KI2VuZGlmYCx2bD1gZmxvYXQgcm91Z2huZXNzRmFjdG9yID0gcm91Z2huZXNzOwojaWZkZWYgVVNFX1JPVUdITkVTU01BUAoJdmVjNCB0ZXhlbFJvdWdobmVzcyA9IHRleHR1cmUyRCggcm91Z2huZXNzTWFwLCB2Um91Z2huZXNzTWFwVXYgKTsKCXJvdWdobmVzc0ZhY3RvciAqPSB0ZXhlbFJvdWdobmVzcy5nOwojZW5kaWZgLHhsPWAjaWZkZWYgVVNFX1JPVUdITkVTU01BUAoJdW5pZm9ybSBzYW1wbGVyMkQgcm91Z2huZXNzTWFwOwojZW5kaWZgLE1sPWAjaWYgTlVNX1NQT1RfTElHSFRfQ09PUkRTID4gMAoJdmFyeWluZyB2ZWM0IHZTcG90TGlnaHRDb29yZFsgTlVNX1NQT1RfTElHSFRfQ09PUkRTIF07CiNlbmRpZgojaWYgTlVNX1NQT1RfTElHSFRfTUFQUyA+IDAKCXVuaWZvcm0gc2FtcGxlcjJEIHNwb3RMaWdodE1hcFsgTlVNX1NQT1RfTElHSFRfTUFQUyBdOwojZW5kaWYKI2lmZGVmIFVTRV9TSEFET1dNQVAKCSNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwCgkJdW5pZm9ybSBzYW1wbGVyMkQgZGlyZWN0aW9uYWxTaGFkb3dNYXBbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdOwoJCXZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07CgkJc3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgewoJCQlmbG9hdCBzaGFkb3dJbnRlbnNpdHk7CgkJCWZsb2F0IHNoYWRvd0JpYXM7CgkJCWZsb2F0IHNoYWRvd05vcm1hbEJpYXM7CgkJCWZsb2F0IHNoYWRvd1JhZGl1czsKCQkJdmVjMiBzaGFkb3dNYXBTaXplOwoJCX07CgkJdW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTsKCSNlbmRpZgoJI2lmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwCgkJdW5pZm9ybSBzYW1wbGVyMkQgc3BvdFNoYWRvd01hcFsgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdOwoJCXN0cnVjdCBTcG90TGlnaHRTaGFkb3cgewoJCQlmbG9hdCBzaGFkb3dJbnRlbnNpdHk7CgkJCWZsb2F0IHNoYWRvd0JpYXM7CgkJCWZsb2F0IHNoYWRvd05vcm1hbEJpYXM7CgkJCWZsb2F0IHNoYWRvd1JhZGl1czsKCQkJdmVjMiBzaGFkb3dNYXBTaXplOwoJCX07CgkJdW5pZm9ybSBTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0U2hhZG93c1sgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdOwoJI2VuZGlmCgkjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwCgkJdW5pZm9ybSBzYW1wbGVyMkQgcG9pbnRTaGFkb3dNYXBbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07CgkJdmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdOwoJCXN0cnVjdCBQb2ludExpZ2h0U2hhZG93IHsKCQkJZmxvYXQgc2hhZG93SW50ZW5zaXR5OwoJCQlmbG9hdCBzaGFkb3dCaWFzOwoJCQlmbG9hdCBzaGFkb3dOb3JtYWxCaWFzOwoJCQlmbG9hdCBzaGFkb3dSYWRpdXM7CgkJCXZlYzIgc2hhZG93TWFwU2l6ZTsKCQkJZmxvYXQgc2hhZG93Q2FtZXJhTmVhcjsKCQkJZmxvYXQgc2hhZG93Q2FtZXJhRmFyOwoJCX07CgkJdW5pZm9ybSBQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3dzWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdOwoJI2VuZGlmCglmbG9hdCB0ZXh0dXJlMkRDb21wYXJlKCBzYW1wbGVyMkQgZGVwdGhzLCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICkgewoJCXJldHVybiBzdGVwKCBjb21wYXJlLCB1bnBhY2tSR0JBVG9EZXB0aCggdGV4dHVyZTJEKCBkZXB0aHMsIHV2ICkgKSApOwoJfQoJdmVjMiB0ZXh0dXJlMkREaXN0cmlidXRpb24oIHNhbXBsZXIyRCBzaGFkb3csIHZlYzIgdXYgKSB7CgkJcmV0dXJuIHVucGFja1JHQkFUbzJIYWxmKCB0ZXh0dXJlMkQoIHNoYWRvdywgdXYgKSApOwoJfQoJZmxvYXQgVlNNU2hhZG93IChzYW1wbGVyMkQgc2hhZG93LCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICl7CgkJZmxvYXQgb2NjbHVzaW9uID0gMS4wOwoJCXZlYzIgZGlzdHJpYnV0aW9uID0gdGV4dHVyZTJERGlzdHJpYnV0aW9uKCBzaGFkb3csIHV2ICk7CgkJZmxvYXQgaGFyZF9zaGFkb3cgPSBzdGVwKCBjb21wYXJlICwgZGlzdHJpYnV0aW9uLnggKTsKCQlpZiAoaGFyZF9zaGFkb3cgIT0gMS4wICkgewoJCQlmbG9hdCBkaXN0YW5jZSA9IGNvbXBhcmUgLSBkaXN0cmlidXRpb24ueCA7CgkJCWZsb2F0IHZhcmlhbmNlID0gbWF4KCAwLjAwMDAwLCBkaXN0cmlidXRpb24ueSAqIGRpc3RyaWJ1dGlvbi55ICk7CgkJCWZsb2F0IHNvZnRuZXNzX3Byb2JhYmlsaXR5ID0gdmFyaWFuY2UgLyAodmFyaWFuY2UgKyBkaXN0YW5jZSAqIGRpc3RhbmNlICk7CQkJc29mdG5lc3NfcHJvYmFiaWxpdHkgPSBjbGFtcCggKCBzb2Z0bmVzc19wcm9iYWJpbGl0eSAtIDAuMyApIC8gKCAwLjk1IC0gMC4zICksIDAuMCwgMS4wICk7CQkJb2NjbHVzaW9uID0gY2xhbXAoIG1heCggaGFyZF9zaGFkb3csIHNvZnRuZXNzX3Byb2JhYmlsaXR5ICksIDAuMCwgMS4wICk7CgkJfQoJCXJldHVybiBvY2NsdXNpb247Cgl9CglmbG9hdCBnZXRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93SW50ZW5zaXR5LCBmbG9hdCBzaGFkb3dCaWFzLCBmbG9hdCBzaGFkb3dSYWRpdXMsIHZlYzQgc2hhZG93Q29vcmQgKSB7CgkJZmxvYXQgc2hhZG93ID0gMS4wOwoJCXNoYWRvd0Nvb3JkLnh5eiAvPSBzaGFkb3dDb29yZC53OwoJCXNoYWRvd0Nvb3JkLnogKz0gc2hhZG93QmlhczsKCQlib29sIGluRnJ1c3R1bSA9IHNoYWRvd0Nvb3JkLnggPj0gMC4wICYmIHNoYWRvd0Nvb3JkLnggPD0gMS4wICYmIHNoYWRvd0Nvb3JkLnkgPj0gMC4wICYmIHNoYWRvd0Nvb3JkLnkgPD0gMS4wOwoJCWJvb2wgZnJ1c3R1bVRlc3QgPSBpbkZydXN0dW0gJiYgc2hhZG93Q29vcmQueiA8PSAxLjA7CgkJaWYgKCBmcnVzdHVtVGVzdCApIHsKCQkjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGICkKCQkJdmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7CgkJCWZsb2F0IGR4MCA9IC0gdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7CgkJCWZsb2F0IGR5MCA9IC0gdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7CgkJCWZsb2F0IGR4MSA9ICsgdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7CgkJCWZsb2F0IGR5MSA9ICsgdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7CgkJCWZsb2F0IGR4MiA9IGR4MCAvIDIuMDsKCQkJZmxvYXQgZHkyID0gZHkwIC8gMi4wOwoJCQlmbG9hdCBkeDMgPSBkeDEgLyAyLjA7CgkJCWZsb2F0IGR5MyA9IGR5MSAvIDIuMDsKCQkJc2hhZG93ID0gKAoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MiwgZHkyICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTIgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDMsIGR5MiApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgyLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgzLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MiwgZHkzICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTMgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDMsIGR5MyApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApLCBzaGFkb3dDb29yZC56ICkKCQkJKSAqICggMS4wIC8gMTcuMCApOwoJCSNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUICkKCQkJdmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7CgkJCWZsb2F0IGR4ID0gdGV4ZWxTaXplLng7CgkJCWZsb2F0IGR5ID0gdGV4ZWxTaXplLnk7CgkJCXZlYzIgdXYgPSBzaGFkb3dDb29yZC54eTsKCQkJdmVjMiBmID0gZnJhY3QoIHV2ICogc2hhZG93TWFwU2l6ZSArIDAuNSApOwoJCQl1diAtPSBmICogdGV4ZWxTaXplOwoJCQlzaGFkb3cgPSAoCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2LCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAwLjAsIGR5ICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdGV4ZWxTaXplLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJbWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApLAoJCQkJCSB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIDAuMCApLCBzaGFkb3dDb29yZC56ICksCgkJCQkJIGYueCApICsKCQkJCW1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIC1keCwgZHkgKSwgc2hhZG93Q29vcmQueiApLAoJCQkJCSB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIGR5ICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkgZi54ICkgKwoJCQkJbWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCAtZHkgKSwgc2hhZG93Q29vcmQueiApLAoJCQkJCSB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksCgkJCQkJIGYueSApICsKCQkJCW1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAtZHkgKSwgc2hhZG93Q29vcmQueiApLAoJCQkJCSB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggZHgsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkgZi55ICkgKwoJCQkJbWl4KCBtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIC1keSApLCBzaGFkb3dDb29yZC56ICksCgkJCQkJCSAgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCAtZHkgKSwgc2hhZG93Q29vcmQueiApLAoJCQkJCQkgIGYueCApLAoJCQkJCSBtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkJICB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkJICBmLnggKSwKCQkJCQkgZi55ICkKCQkJKSAqICggMS4wIC8gOS4wICk7CgkJI2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfVlNNICkKCQkJc2hhZG93ID0gVlNNU2hhZG93KCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICk7CgkJI2Vsc2UKCQkJc2hhZG93ID0gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApOwoJCSNlbmRpZgoJCX0KCQlyZXR1cm4gbWl4KCAxLjAsIHNoYWRvdywgc2hhZG93SW50ZW5zaXR5ICk7Cgl9Cgl2ZWMyIGN1YmVUb1VWKCB2ZWMzIHYsIGZsb2F0IHRleGVsU2l6ZVkgKSB7CgkJdmVjMyBhYnNWID0gYWJzKCB2ICk7CgkJZmxvYXQgc2NhbGVUb0N1YmUgPSAxLjAgLyBtYXgoIGFic1YueCwgbWF4KCBhYnNWLnksIGFic1YueiApICk7CgkJYWJzViAqPSBzY2FsZVRvQ3ViZTsKCQl2ICo9IHNjYWxlVG9DdWJlICogKCAxLjAgLSAyLjAgKiB0ZXhlbFNpemVZICk7CgkJdmVjMiBwbGFuYXIgPSB2Lnh5OwoJCWZsb2F0IGFsbW9zdEFUZXhlbCA9IDEuNSAqIHRleGVsU2l6ZVk7CgkJZmxvYXQgYWxtb3N0T25lID0gMS4wIC0gYWxtb3N0QVRleGVsOwoJCWlmICggYWJzVi56ID49IGFsbW9zdE9uZSApIHsKCQkJaWYgKCB2LnogPiAwLjAgKQoJCQkJcGxhbmFyLnggPSA0LjAgLSB2Lng7CgkJfSBlbHNlIGlmICggYWJzVi54ID49IGFsbW9zdE9uZSApIHsKCQkJZmxvYXQgc2lnblggPSBzaWduKCB2LnggKTsKCQkJcGxhbmFyLnggPSB2LnogKiBzaWduWCArIDIuMCAqIHNpZ25YOwoJCX0gZWxzZSBpZiAoIGFic1YueSA+PSBhbG1vc3RPbmUgKSB7CgkJCWZsb2F0IHNpZ25ZID0gc2lnbiggdi55ICk7CgkJCXBsYW5hci54ID0gdi54ICsgMi4wICogc2lnblkgKyAyLjA7CgkJCXBsYW5hci55ID0gdi56ICogc2lnblkgLSAyLjA7CgkJfQoJCXJldHVybiB2ZWMyKCAwLjEyNSwgMC4yNSApICogcGxhbmFyICsgdmVjMiggMC4zNzUsIDAuNzUgKTsKCX0KCWZsb2F0IGdldFBvaW50U2hhZG93KCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFNpemUsIGZsb2F0IHNoYWRvd0ludGVuc2l0eSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkLCBmbG9hdCBzaGFkb3dDYW1lcmFOZWFyLCBmbG9hdCBzaGFkb3dDYW1lcmFGYXIgKSB7CgkJZmxvYXQgc2hhZG93ID0gMS4wOwoJCXZlYzMgbGlnaHRUb1Bvc2l0aW9uID0gc2hhZG93Q29vcmQueHl6OwoJCQoJCWZsb2F0IGxpZ2h0VG9Qb3NpdGlvbkxlbmd0aCA9IGxlbmd0aCggbGlnaHRUb1Bvc2l0aW9uICk7CgkJaWYgKCBsaWdodFRvUG9zaXRpb25MZW5ndGggLSBzaGFkb3dDYW1lcmFGYXIgPD0gMC4wICYmIGxpZ2h0VG9Qb3NpdGlvbkxlbmd0aCAtIHNoYWRvd0NhbWVyYU5lYXIgPj0gMC4wICkgewoJCQlmbG9hdCBkcCA9ICggbGlnaHRUb1Bvc2l0aW9uTGVuZ3RoIC0gc2hhZG93Q2FtZXJhTmVhciApIC8gKCBzaGFkb3dDYW1lcmFGYXIgLSBzaGFkb3dDYW1lcmFOZWFyICk7CQkJZHAgKz0gc2hhZG93QmlhczsKCQkJdmVjMyBiZDNEID0gbm9ybWFsaXplKCBsaWdodFRvUG9zaXRpb24gKTsKCQkJdmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvICggc2hhZG93TWFwU2l6ZSAqIHZlYzIoIDQuMCwgMi4wICkgKTsKCQkJI2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApIHx8IGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfVlNNICkKCQkJCXZlYzIgb2Zmc2V0ID0gdmVjMiggLSAxLCAxICkgKiBzaGFkb3dSYWRpdXMgKiB0ZXhlbFNpemUueTsKCQkJCXNoYWRvdyA9ICgKCQkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArCgkJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eXksIHRleGVsU2l6ZS55ICksIGRwICkgKwoJCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl4LCB0ZXhlbFNpemUueSApLCBkcCApICsKCQkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArCgkJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArCgkJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHksIHRleGVsU2l6ZS55ICksIGRwICkgKwoJCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXh5LCB0ZXhlbFNpemUueSApLCBkcCApICsKCQkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArCgkJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHgsIHRleGVsU2l6ZS55ICksIGRwICkKCQkJCSkgKiAoIDEuMCAvIDkuMCApOwoJCQkjZWxzZQoJCQkJc2hhZG93ID0gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKTsKCQkJI2VuZGlmCgkJfQoJCXJldHVybiBtaXgoIDEuMCwgc2hhZG93LCBzaGFkb3dJbnRlbnNpdHkgKTsKCX0KI2VuZGlmYCxTbD1gI2lmIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyA+IDAKCXVuaWZvcm0gbWF0NCBzcG90TGlnaHRNYXRyaXhbIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyBdOwoJdmFyeWluZyB2ZWM0IHZTcG90TGlnaHRDb29yZFsgTlVNX1NQT1RfTElHSFRfQ09PUkRTIF07CiNlbmRpZgojaWZkZWYgVVNFX1NIQURPV01BUAoJI2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDAKCQl1bmlmb3JtIG1hdDQgZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdOwoJCXZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07CgkJc3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgewoJCQlmbG9hdCBzaGFkb3dJbnRlbnNpdHk7CgkJCWZsb2F0IHNoYWRvd0JpYXM7CgkJCWZsb2F0IHNoYWRvd05vcm1hbEJpYXM7CgkJCWZsb2F0IHNoYWRvd1JhZGl1czsKCQkJdmVjMiBzaGFkb3dNYXBTaXplOwoJCX07CgkJdW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTsKCSNlbmRpZgoJI2lmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwCgkJc3RydWN0IFNwb3RMaWdodFNoYWRvdyB7CgkJCWZsb2F0IHNoYWRvd0ludGVuc2l0eTsKCQkJZmxvYXQgc2hhZG93QmlhczsKCQkJZmxvYXQgc2hhZG93Tm9ybWFsQmlhczsKCQkJZmxvYXQgc2hhZG93UmFkaXVzOwoJCQl2ZWMyIHNoYWRvd01hcFNpemU7CgkJfTsKCQl1bmlmb3JtIFNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHRTaGFkb3dzWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07CgkjZW5kaWYKCSNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDAKCQl1bmlmb3JtIG1hdDQgcG9pbnRTaGFkb3dNYXRyaXhbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07CgkJdmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdOwoJCXN0cnVjdCBQb2ludExpZ2h0U2hhZG93IHsKCQkJZmxvYXQgc2hhZG93SW50ZW5zaXR5OwoJCQlmbG9hdCBzaGFkb3dCaWFzOwoJCQlmbG9hdCBzaGFkb3dOb3JtYWxCaWFzOwoJCQlmbG9hdCBzaGFkb3dSYWRpdXM7CgkJCXZlYzIgc2hhZG93TWFwU2l6ZTsKCQkJZmxvYXQgc2hhZG93Q2FtZXJhTmVhcjsKCQkJZmxvYXQgc2hhZG93Q2FtZXJhRmFyOwoJCX07CgkJdW5pZm9ybSBQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3dzWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdOwoJI2VuZGlmCiNlbmRpZmAsRWw9YCNpZiAoIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiAoIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDAgfHwgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwICkgKSB8fCAoIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyA+IDAgKQoJdmVjMyBzaGFkb3dXb3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHRyYW5zZm9ybWVkTm9ybWFsLCB2aWV3TWF0cml4ICk7Cgl2ZWM0IHNoYWRvd1dvcmxkUG9zaXRpb247CiNlbmRpZgojaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApCgkjaWYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMAoJCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCQlmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7CgkJCXNoYWRvd1dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uICsgdmVjNCggc2hhZG93V29ybGROb3JtYWwgKiBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdLnNoYWRvd05vcm1hbEJpYXMsIDAgKTsKCQkJdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSA9IGRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBpIF0gKiBzaGFkb3dXb3JsZFBvc2l0aW9uOwoJCX0KCQkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJI2VuZGlmCgkjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwCgkJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJCWZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTOyBpICsrICkgewoJCQlzaGFkb3dXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbiArIHZlYzQoIHNoYWRvd1dvcmxkTm9ybWFsICogcG9pbnRMaWdodFNoYWRvd3NbIGkgXS5zaGFkb3dOb3JtYWxCaWFzLCAwICk7CgkJCXZQb2ludFNoYWRvd0Nvb3JkWyBpIF0gPSBwb2ludFNoYWRvd01hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjsKCQl9CgkJI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQKCSNlbmRpZgojZW5kaWYKI2lmIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyA+IDAKCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCWZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUX0NPT1JEUzsgaSArKyApIHsKCQlzaGFkb3dXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbjsKCQkjaWYgKCBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgKQoJCQlzaGFkb3dXb3JsZFBvc2l0aW9uLnh5eiArPSBzaGFkb3dXb3JsZE5vcm1hbCAqIHNwb3RMaWdodFNoYWRvd3NbIGkgXS5zaGFkb3dOb3JtYWxCaWFzOwoJCSNlbmRpZgoJCXZTcG90TGlnaHRDb29yZFsgaSBdID0gc3BvdExpZ2h0TWF0cml4WyBpIF0gKiBzaGFkb3dXb3JsZFBvc2l0aW9uOwoJfQoJI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQKI2VuZGlmYCx5bD1gZmxvYXQgZ2V0U2hhZG93TWFzaygpIHsKCWZsb2F0IHNoYWRvdyA9IDEuMDsKCSNpZmRlZiBVU0VfU0hBRE9XTUFQCgkjaWYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMAoJRGlyZWN0aW9uYWxMaWdodFNoYWRvdyBkaXJlY3Rpb25hbExpZ2h0OwoJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJZm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTOyBpICsrICkgewoJCWRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdOwoJCXNoYWRvdyAqPSByZWNlaXZlU2hhZG93ID8gZ2V0U2hhZG93KCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgaSBdLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd01hcFNpemUsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93SW50ZW5zaXR5LCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7Cgl9CgkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJI2VuZGlmCgkjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDAKCVNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHQ7CgkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTOyBpICsrICkgewoJCXNwb3RMaWdodCA9IHNwb3RMaWdodFNoYWRvd3NbIGkgXTsKCQlzaGFkb3cgKj0gcmVjZWl2ZVNoYWRvdyA/IGdldFNoYWRvdyggc3BvdFNoYWRvd01hcFsgaSBdLCBzcG90TGlnaHQuc2hhZG93TWFwU2l6ZSwgc3BvdExpZ2h0LnNoYWRvd0ludGVuc2l0eSwgc3BvdExpZ2h0LnNoYWRvd0JpYXMsIHNwb3RMaWdodC5zaGFkb3dSYWRpdXMsIHZTcG90TGlnaHRDb29yZFsgaSBdICkgOiAxLjA7Cgl9CgkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJI2VuZGlmCgkjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwCglQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHQ7CgkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUzsgaSArKyApIHsKCQlwb2ludExpZ2h0ID0gcG9pbnRMaWdodFNoYWRvd3NbIGkgXTsKCQlzaGFkb3cgKj0gcmVjZWl2ZVNoYWRvdyA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHQuc2hhZG93SW50ZW5zaXR5LCBwb2ludExpZ2h0LnNoYWRvd0JpYXMsIHBvaW50TGlnaHQuc2hhZG93UmFkaXVzLCB2UG9pbnRTaGFkb3dDb29yZFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd0NhbWVyYU5lYXIsIHBvaW50TGlnaHQuc2hhZG93Q2FtZXJhRmFyICkgOiAxLjA7Cgl9CgkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJI2VuZGlmCgkjZW5kaWYKCXJldHVybiBzaGFkb3c7Cn1gLFRsPWAjaWZkZWYgVVNFX1NLSU5OSU5HCgltYXQ0IGJvbmVNYXRYID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnggKTsKCW1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApOwoJbWF0NCBib25lTWF0WiA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC56ICk7CgltYXQ0IGJvbmVNYXRXID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LncgKTsKI2VuZGlmYCxBbD1gI2lmZGVmIFVTRV9TS0lOTklORwoJdW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXg7Cgl1bmlmb3JtIG1hdDQgYmluZE1hdHJpeEludmVyc2U7Cgl1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBib25lVGV4dHVyZTsKCW1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHsKCQlpbnQgc2l6ZSA9IHRleHR1cmVTaXplKCBib25lVGV4dHVyZSwgMCApLng7CgkJaW50IGogPSBpbnQoIGkgKSAqIDQ7CgkJaW50IHggPSBqICUgc2l6ZTsKCQlpbnQgeSA9IGogLyBzaXplOwoJCXZlYzQgdjEgPSB0ZXhlbEZldGNoKCBib25lVGV4dHVyZSwgaXZlYzIoIHgsIHkgKSwgMCApOwoJCXZlYzQgdjIgPSB0ZXhlbEZldGNoKCBib25lVGV4dHVyZSwgaXZlYzIoIHggKyAxLCB5ICksIDAgKTsKCQl2ZWM0IHYzID0gdGV4ZWxGZXRjaCggYm9uZVRleHR1cmUsIGl2ZWMyKCB4ICsgMiwgeSApLCAwICk7CgkJdmVjNCB2NCA9IHRleGVsRmV0Y2goIGJvbmVUZXh0dXJlLCBpdmVjMiggeCArIDMsIHkgKSwgMCApOwoJCXJldHVybiBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApOwoJfQojZW5kaWZgLHdsPWAjaWZkZWYgVVNFX1NLSU5OSU5HCgl2ZWM0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApOwoJdmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7Cglza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDsKCXNraW5uZWQgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55OwoJc2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7Cglza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudzsKCXRyYW5zZm9ybWVkID0gKCBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5uZWQgKS54eXo7CiNlbmRpZmAsYmw9YCNpZmRlZiBVU0VfU0tJTk5JTkcKCW1hdDQgc2tpbk1hdHJpeCA9IG1hdDQoIDAuMCApOwoJc2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnggKiBib25lTWF0WDsKCXNraW5NYXRyaXggKz0gc2tpbldlaWdodC55ICogYm9uZU1hdFk7Cglza2luTWF0cml4ICs9IHNraW5XZWlnaHQueiAqIGJvbmVNYXRaOwoJc2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LncgKiBib25lTWF0VzsKCXNraW5NYXRyaXggPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5NYXRyaXggKiBiaW5kTWF0cml4OwoJb2JqZWN0Tm9ybWFsID0gdmVjNCggc2tpbk1hdHJpeCAqIHZlYzQoIG9iamVjdE5vcm1hbCwgMC4wICkgKS54eXo7CgkjaWZkZWYgVVNFX1RBTkdFTlQKCQlvYmplY3RUYW5nZW50ID0gdmVjNCggc2tpbk1hdHJpeCAqIHZlYzQoIG9iamVjdFRhbmdlbnQsIDAuMCApICkueHl6OwoJI2VuZGlmCiNlbmRpZmAsUmw9YGZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7CiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVAKCXZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZTcGVjdWxhck1hcFV2ICk7CglzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yOwojZWxzZQoJc3BlY3VsYXJTdHJlbmd0aCA9IDEuMDsKI2VuZGlmYCxDbD1gI2lmZGVmIFVTRV9TUEVDVUxBUk1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJNYXA7CiNlbmRpZmAsUGw9YCNpZiBkZWZpbmVkKCBUT05FX01BUFBJTkcgKQoJZ2xfRnJhZ0NvbG9yLnJnYiA9IHRvbmVNYXBwaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7CiNlbmRpZmAsRGw9YCNpZm5kZWYgc2F0dXJhdGUKI2RlZmluZSBzYXR1cmF0ZSggYSApIGNsYW1wKCBhLCAwLjAsIDEuMCApCiNlbmRpZgp1bmlmb3JtIGZsb2F0IHRvbmVNYXBwaW5nRXhwb3N1cmU7CnZlYzMgTGluZWFyVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7CglyZXR1cm4gc2F0dXJhdGUoIHRvbmVNYXBwaW5nRXhwb3N1cmUgKiBjb2xvciApOwp9CnZlYzMgUmVpbmhhcmRUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHsKCWNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7CglyZXR1cm4gc2F0dXJhdGUoIGNvbG9yIC8gKCB2ZWMzKCAxLjAgKSArIGNvbG9yICkgKTsKfQp2ZWMzIENpbmVvblRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkgewoJY29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTsKCWNvbG9yID0gbWF4KCB2ZWMzKCAwLjAgKSwgY29sb3IgLSAwLjAwNCApOwoJcmV0dXJuIHBvdyggKCBjb2xvciAqICggNi4yICogY29sb3IgKyAwLjUgKSApIC8gKCBjb2xvciAqICggNi4yICogY29sb3IgKyAxLjcgKSArIDAuMDYgKSwgdmVjMyggMi4yICkgKTsKfQp2ZWMzIFJSVEFuZE9EVEZpdCggdmVjMyB2ICkgewoJdmVjMyBhID0gdiAqICggdiArIDAuMDI0NTc4NiApIC0gMC4wMDAwOTA1Mzc7Cgl2ZWMzIGIgPSB2ICogKCAwLjk4MzcyOSAqIHYgKyAwLjQzMjk1MTAgKSArIDAuMjM4MDgxOwoJcmV0dXJuIGEgLyBiOwp9CnZlYzMgQUNFU0ZpbG1pY1RvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkgewoJY29uc3QgbWF0MyBBQ0VTSW5wdXRNYXQgPSBtYXQzKAoJCXZlYzMoIDAuNTk3MTksIDAuMDc2MDAsIDAuMDI4NDAgKSwJCXZlYzMoIDAuMzU0NTgsIDAuOTA4MzQsIDAuMTMzODMgKSwKCQl2ZWMzKCAwLjA0ODIzLCAwLjAxNTY2LCAwLjgzNzc3ICkKCSk7Cgljb25zdCBtYXQzIEFDRVNPdXRwdXRNYXQgPSBtYXQzKAoJCXZlYzMoICAxLjYwNDc1LCAtMC4xMDIwOCwgLTAuMDAzMjcgKSwJCXZlYzMoIC0wLjUzMTA4LCAgMS4xMDgxMywgLTAuMDcyNzYgKSwKCQl2ZWMzKCAtMC4wNzM2NywgLTAuMDA2MDUsICAxLjA3NjAyICkKCSk7Cgljb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlIC8gMC42OwoJY29sb3IgPSBBQ0VTSW5wdXRNYXQgKiBjb2xvcjsKCWNvbG9yID0gUlJUQW5kT0RURml0KCBjb2xvciApOwoJY29sb3IgPSBBQ0VTT3V0cHV0TWF0ICogY29sb3I7CglyZXR1cm4gc2F0dXJhdGUoIGNvbG9yICk7Cn0KY29uc3QgbWF0MyBMSU5FQVJfUkVDMjAyMF9UT19MSU5FQVJfU1JHQiA9IG1hdDMoCgl2ZWMzKCAxLjY2MDUsIC0gMC4xMjQ2LCAtIDAuMDE4MiApLAoJdmVjMyggLSAwLjU4NzYsIDEuMTMyOSwgLSAwLjEwMDYgKSwKCXZlYzMoIC0gMC4wNzI4LCAtIDAuMDA4MywgMS4xMTg3ICkKKTsKY29uc3QgbWF0MyBMSU5FQVJfU1JHQl9UT19MSU5FQVJfUkVDMjAyMCA9IG1hdDMoCgl2ZWMzKCAwLjYyNzQsIDAuMDY5MSwgMC4wMTY0ICksCgl2ZWMzKCAwLjMyOTMsIDAuOTE5NSwgMC4wODgwICksCgl2ZWMzKCAwLjA0MzMsIDAuMDExMywgMC44OTU2ICkKKTsKdmVjMyBhZ3hEZWZhdWx0Q29udHJhc3RBcHByb3goIHZlYzMgeCApIHsKCXZlYzMgeDIgPSB4ICogeDsKCXZlYzMgeDQgPSB4MiAqIHgyOwoJcmV0dXJuICsgMTUuNSAqIHg0ICogeDIKCQktIDQwLjE0ICogeDQgKiB4CgkJKyAzMS45NiAqIHg0CgkJLSA2Ljg2OCAqIHgyICogeAoJCSsgMC40Mjk4ICogeDIKCQkrIDAuMTE5MSAqIHgKCQktIDAuMDAyMzI7Cn0KdmVjMyBBZ1hUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHsKCWNvbnN0IG1hdDMgQWdYSW5zZXRNYXRyaXggPSBtYXQzKAoJCXZlYzMoIDAuODU2NjI3MTUzMzE1OTgzLCAwLjEzNzMxODk3MjkyOTg0NywgMC4xMTE4OTgyMTI5OTk5NSApLAoJCXZlYzMoIDAuMDk1MTIxMjQwNTM4MTU4OCwgMC43NjEyNDE5OTA2MDI1OTEsIDAuMDc2Nzk5NDE4NjAzMTkwMyApLAoJCXZlYzMoIDAuMDQ4MjUxNjA2MTQ1ODU4MywgMC4xMDE0MzkwMzY0Njc1NjIsIDAuODExMzAyMzY4Mzk2ODU5ICkKCSk7Cgljb25zdCBtYXQzIEFnWE91dHNldE1hdHJpeCA9IG1hdDMoCgkJdmVjMyggMS4xMjcxMDA1ODE4MTQ0MzY4LCAtIDAuMTQxMzI5NzYzNDk4NDM4MywgLSAwLjE0MTMyOTc2MzQ5ODQzODI2ICksCgkJdmVjMyggLSAwLjExMDYwNjY0MzA5NjYwMzIzLCAxLjE1NzgyMzcwMjIxNjI3MiwgLSAwLjExMDYwNjY0MzA5NjYwMjk0ICksCgkJdmVjMyggLSAwLjAxNjQ5MzkzODcxNzgzNDU3MywgLSAwLjAxNjQ5MzkzODcxNzgzNDI1NywgMS4yNTE5MzY0MDY1OTUwNDA1ICkKCSk7Cgljb25zdCBmbG9hdCBBZ3hNaW5FdiA9IC0gMTIuNDczOTM7CWNvbnN0IGZsb2F0IEFneE1heEV2ID0gNC4wMjYwNjk7Cgljb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlOwoJY29sb3IgPSBMSU5FQVJfU1JHQl9UT19MSU5FQVJfUkVDMjAyMCAqIGNvbG9yOwoJY29sb3IgPSBBZ1hJbnNldE1hdHJpeCAqIGNvbG9yOwoJY29sb3IgPSBtYXgoIGNvbG9yLCAxZS0xMCApOwljb2xvciA9IGxvZzIoIGNvbG9yICk7Cgljb2xvciA9ICggY29sb3IgLSBBZ3hNaW5FdiApIC8gKCBBZ3hNYXhFdiAtIEFneE1pbkV2ICk7Cgljb2xvciA9IGNsYW1wKCBjb2xvciwgMC4wLCAxLjAgKTsKCWNvbG9yID0gYWd4RGVmYXVsdENvbnRyYXN0QXBwcm94KCBjb2xvciApOwoJY29sb3IgPSBBZ1hPdXRzZXRNYXRyaXggKiBjb2xvcjsKCWNvbG9yID0gcG93KCBtYXgoIHZlYzMoIDAuMCApLCBjb2xvciApLCB2ZWMzKCAyLjIgKSApOwoJY29sb3IgPSBMSU5FQVJfUkVDMjAyMF9UT19MSU5FQVJfU1JHQiAqIGNvbG9yOwoJY29sb3IgPSBjbGFtcCggY29sb3IsIDAuMCwgMS4wICk7CglyZXR1cm4gY29sb3I7Cn0KdmVjMyBOZXV0cmFsVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7Cgljb25zdCBmbG9hdCBTdGFydENvbXByZXNzaW9uID0gMC44IC0gMC4wNDsKCWNvbnN0IGZsb2F0IERlc2F0dXJhdGlvbiA9IDAuMTU7Cgljb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlOwoJZmxvYXQgeCA9IG1pbiggY29sb3IuciwgbWluKCBjb2xvci5nLCBjb2xvci5iICkgKTsKCWZsb2F0IG9mZnNldCA9IHggPCAwLjA4ID8geCAtIDYuMjUgKiB4ICogeCA6IDAuMDQ7Cgljb2xvciAtPSBvZmZzZXQ7CglmbG9hdCBwZWFrID0gbWF4KCBjb2xvci5yLCBtYXgoIGNvbG9yLmcsIGNvbG9yLmIgKSApOwoJaWYgKCBwZWFrIDwgU3RhcnRDb21wcmVzc2lvbiApIHJldHVybiBjb2xvcjsKCWZsb2F0IGQgPSAxLiAtIFN0YXJ0Q29tcHJlc3Npb247CglmbG9hdCBuZXdQZWFrID0gMS4gLSBkICogZCAvICggcGVhayArIGQgLSBTdGFydENvbXByZXNzaW9uICk7Cgljb2xvciAqPSBuZXdQZWFrIC8gcGVhazsKCWZsb2F0IGcgPSAxLiAtIDEuIC8gKCBEZXNhdHVyYXRpb24gKiAoIHBlYWsgLSBuZXdQZWFrICkgKyAxLiApOwoJcmV0dXJuIG1peCggY29sb3IsIHZlYzMoIG5ld1BlYWsgKSwgZyApOwp9CnZlYzMgQ3VzdG9tVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7IHJldHVybiBjb2xvcjsgfWAsTGw9YCNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OCgltYXRlcmlhbC50cmFuc21pc3Npb24gPSB0cmFuc21pc3Npb247CgltYXRlcmlhbC50cmFuc21pc3Npb25BbHBoYSA9IDEuMDsKCW1hdGVyaWFsLnRoaWNrbmVzcyA9IHRoaWNrbmVzczsKCW1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBhdHRlbnVhdGlvbkRpc3RhbmNlOwoJbWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvciA9IGF0dGVudWF0aW9uQ29sb3I7CgkjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUAoJCW1hdGVyaWFsLnRyYW5zbWlzc2lvbiAqPSB0ZXh0dXJlMkQoIHRyYW5zbWlzc2lvbk1hcCwgdlRyYW5zbWlzc2lvbk1hcFV2ICkucjsKCSNlbmRpZgoJI2lmZGVmIFVTRV9USElDS05FU1NNQVAKCQltYXRlcmlhbC50aGlja25lc3MgKj0gdGV4dHVyZTJEKCB0aGlja25lc3NNYXAsIHZUaGlja25lc3NNYXBVdiApLmc7CgkjZW5kaWYKCXZlYzMgcG9zID0gdldvcmxkUG9zaXRpb247Cgl2ZWMzIHYgPSBub3JtYWxpemUoIGNhbWVyYVBvc2l0aW9uIC0gcG9zICk7Cgl2ZWMzIG4gPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTsKCXZlYzQgdHJhbnNtaXR0ZWQgPSBnZXRJQkxWb2x1bWVSZWZyYWN0aW9uKAoJCW4sIHYsIG1hdGVyaWFsLnJvdWdobmVzcywgbWF0ZXJpYWwuZGlmZnVzZUNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCwKCQlwb3MsIG1vZGVsTWF0cml4LCB2aWV3TWF0cml4LCBwcm9qZWN0aW9uTWF0cml4LCBtYXRlcmlhbC5kaXNwZXJzaW9uLCBtYXRlcmlhbC5pb3IsIG1hdGVyaWFsLnRoaWNrbmVzcywKCQltYXRlcmlhbC5hdHRlbnVhdGlvbkNvbG9yLCBtYXRlcmlhbC5hdHRlbnVhdGlvbkRpc3RhbmNlICk7CgltYXRlcmlhbC50cmFuc21pc3Npb25BbHBoYSA9IG1peCggbWF0ZXJpYWwudHJhbnNtaXNzaW9uQWxwaGEsIHRyYW5zbWl0dGVkLmEsIG1hdGVyaWFsLnRyYW5zbWlzc2lvbiApOwoJdG90YWxEaWZmdXNlID0gbWl4KCB0b3RhbERpZmZ1c2UsIHRyYW5zbWl0dGVkLnJnYiwgbWF0ZXJpYWwudHJhbnNtaXNzaW9uICk7CiNlbmRpZmAsVWw9YCNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OCgl1bmlmb3JtIGZsb2F0IHRyYW5zbWlzc2lvbjsKCXVuaWZvcm0gZmxvYXQgdGhpY2tuZXNzOwoJdW5pZm9ybSBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlOwoJdW5pZm9ybSB2ZWMzIGF0dGVudWF0aW9uQ29sb3I7CgkjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUAoJCXVuaWZvcm0gc2FtcGxlcjJEIHRyYW5zbWlzc2lvbk1hcDsKCSNlbmRpZgoJI2lmZGVmIFVTRV9USElDS05FU1NNQVAKCQl1bmlmb3JtIHNhbXBsZXIyRCB0aGlja25lc3NNYXA7CgkjZW5kaWYKCXVuaWZvcm0gdmVjMiB0cmFuc21pc3Npb25TYW1wbGVyU2l6ZTsKCXVuaWZvcm0gc2FtcGxlcjJEIHRyYW5zbWlzc2lvblNhbXBsZXJNYXA7Cgl1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7Cgl1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsKCXZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjsKCWZsb2F0IHcwKCBmbG9hdCBhICkgewoJCXJldHVybiAoIDEuMCAvIDYuMCApICogKCBhICogKCBhICogKCAtIGEgKyAzLjAgKSAtIDMuMCApICsgMS4wICk7Cgl9CglmbG9hdCB3MSggZmxvYXQgYSApIHsKCQlyZXR1cm4gKCAxLjAgLyA2LjAgKSAqICggYSAqICBhICogKCAzLjAgKiBhIC0gNi4wICkgKyA0LjAgKTsKCX0KCWZsb2F0IHcyKCBmbG9hdCBhICl7CgkJcmV0dXJuICggMS4wIC8gNi4wICkgKiAoIGEgKiAoIGEgKiAoIC0gMy4wICogYSArIDMuMCApICsgMy4wICkgKyAxLjAgKTsKCX0KCWZsb2F0IHczKCBmbG9hdCBhICkgewoJCXJldHVybiAoIDEuMCAvIDYuMCApICogKCBhICogYSAqIGEgKTsKCX0KCWZsb2F0IGcwKCBmbG9hdCBhICkgewoJCXJldHVybiB3MCggYSApICsgdzEoIGEgKTsKCX0KCWZsb2F0IGcxKCBmbG9hdCBhICkgewoJCXJldHVybiB3MiggYSApICsgdzMoIGEgKTsKCX0KCWZsb2F0IGgwKCBmbG9hdCBhICkgewoJCXJldHVybiAtIDEuMCArIHcxKCBhICkgLyAoIHcwKCBhICkgKyB3MSggYSApICk7Cgl9CglmbG9hdCBoMSggZmxvYXQgYSApIHsKCQlyZXR1cm4gMS4wICsgdzMoIGEgKSAvICggdzIoIGEgKSArIHczKCBhICkgKTsKCX0KCXZlYzQgYmljdWJpYyggc2FtcGxlcjJEIHRleCwgdmVjMiB1diwgdmVjNCB0ZXhlbFNpemUsIGZsb2F0IGxvZCApIHsKCQl1diA9IHV2ICogdGV4ZWxTaXplLnp3ICsgMC41OwoJCXZlYzIgaXV2ID0gZmxvb3IoIHV2ICk7CgkJdmVjMiBmdXYgPSBmcmFjdCggdXYgKTsKCQlmbG9hdCBnMHggPSBnMCggZnV2LnggKTsKCQlmbG9hdCBnMXggPSBnMSggZnV2LnggKTsKCQlmbG9hdCBoMHggPSBoMCggZnV2LnggKTsKCQlmbG9hdCBoMXggPSBoMSggZnV2LnggKTsKCQlmbG9hdCBoMHkgPSBoMCggZnV2LnkgKTsKCQlmbG9hdCBoMXkgPSBoMSggZnV2LnkgKTsKCQl2ZWMyIHAwID0gKCB2ZWMyKCBpdXYueCArIGgweCwgaXV2LnkgKyBoMHkgKSAtIDAuNSApICogdGV4ZWxTaXplLnh5OwoJCXZlYzIgcDEgPSAoIHZlYzIoIGl1di54ICsgaDF4LCBpdXYueSArIGgweSApIC0gMC41ICkgKiB0ZXhlbFNpemUueHk7CgkJdmVjMiBwMiA9ICggdmVjMiggaXV2LnggKyBoMHgsIGl1di55ICsgaDF5ICkgLSAwLjUgKSAqIHRleGVsU2l6ZS54eTsKCQl2ZWMyIHAzID0gKCB2ZWMyKCBpdXYueCArIGgxeCwgaXV2LnkgKyBoMXkgKSAtIDAuNSApICogdGV4ZWxTaXplLnh5OwoJCXJldHVybiBnMCggZnV2LnkgKSAqICggZzB4ICogdGV4dHVyZUxvZCggdGV4LCBwMCwgbG9kICkgKyBnMXggKiB0ZXh0dXJlTG9kKCB0ZXgsIHAxLCBsb2QgKSApICsKCQkJZzEoIGZ1di55ICkgKiAoIGcweCAqIHRleHR1cmVMb2QoIHRleCwgcDIsIGxvZCApICsgZzF4ICogdGV4dHVyZUxvZCggdGV4LCBwMywgbG9kICkgKTsKCX0KCXZlYzQgdGV4dHVyZUJpY3ViaWMoIHNhbXBsZXIyRCBzYW1wbGVyLCB2ZWMyIHV2LCBmbG9hdCBsb2QgKSB7CgkJdmVjMiBmTG9kU2l6ZSA9IHZlYzIoIHRleHR1cmVTaXplKCBzYW1wbGVyLCBpbnQoIGxvZCApICkgKTsKCQl2ZWMyIGNMb2RTaXplID0gdmVjMiggdGV4dHVyZVNpemUoIHNhbXBsZXIsIGludCggbG9kICsgMS4wICkgKSApOwoJCXZlYzIgZkxvZFNpemVJbnYgPSAxLjAgLyBmTG9kU2l6ZTsKCQl2ZWMyIGNMb2RTaXplSW52ID0gMS4wIC8gY0xvZFNpemU7CgkJdmVjNCBmU2FtcGxlID0gYmljdWJpYyggc2FtcGxlciwgdXYsIHZlYzQoIGZMb2RTaXplSW52LCBmTG9kU2l6ZSApLCBmbG9vciggbG9kICkgKTsKCQl2ZWM0IGNTYW1wbGUgPSBiaWN1YmljKCBzYW1wbGVyLCB1diwgdmVjNCggY0xvZFNpemVJbnYsIGNMb2RTaXplICksIGNlaWwoIGxvZCApICk7CgkJcmV0dXJuIG1peCggZlNhbXBsZSwgY1NhbXBsZSwgZnJhY3QoIGxvZCApICk7Cgl9Cgl2ZWMzIGdldFZvbHVtZVRyYW5zbWlzc2lvblJheSggY29uc3QgaW4gdmVjMyBuLCBjb25zdCBpbiB2ZWMzIHYsIGNvbnN0IGluIGZsb2F0IHRoaWNrbmVzcywgY29uc3QgaW4gZmxvYXQgaW9yLCBjb25zdCBpbiBtYXQ0IG1vZGVsTWF0cml4ICkgewoJCXZlYzMgcmVmcmFjdGlvblZlY3RvciA9IHJlZnJhY3QoIC0gdiwgbm9ybWFsaXplKCBuICksIDEuMCAvIGlvciApOwoJCXZlYzMgbW9kZWxTY2FsZTsKCQltb2RlbFNjYWxlLnggPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAwIF0ueHl6ICkgKTsKCQltb2RlbFNjYWxlLnkgPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAxIF0ueHl6ICkgKTsKCQltb2RlbFNjYWxlLnogPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAyIF0ueHl6ICkgKTsKCQlyZXR1cm4gbm9ybWFsaXplKCByZWZyYWN0aW9uVmVjdG9yICkgKiB0aGlja25lc3MgKiBtb2RlbFNjYWxlOwoJfQoJZmxvYXQgYXBwbHlJb3JUb1JvdWdobmVzcyggY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBjb25zdCBpbiBmbG9hdCBpb3IgKSB7CgkJcmV0dXJuIHJvdWdobmVzcyAqIGNsYW1wKCBpb3IgKiAyLjAgLSAyLjAsIDAuMCwgMS4wICk7Cgl9Cgl2ZWM0IGdldFRyYW5zbWlzc2lvblNhbXBsZSggY29uc3QgaW4gdmVjMiBmcmFnQ29vcmQsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gZmxvYXQgaW9yICkgewoJCWZsb2F0IGxvZCA9IGxvZzIoIHRyYW5zbWlzc2lvblNhbXBsZXJTaXplLnggKSAqIGFwcGx5SW9yVG9Sb3VnaG5lc3MoIHJvdWdobmVzcywgaW9yICk7CgkJcmV0dXJuIHRleHR1cmVCaWN1YmljKCB0cmFuc21pc3Npb25TYW1wbGVyTWFwLCBmcmFnQ29vcmQueHksIGxvZCApOwoJfQoJdmVjMyB2b2x1bWVBdHRlbnVhdGlvbiggY29uc3QgaW4gZmxvYXQgdHJhbnNtaXNzaW9uRGlzdGFuY2UsIGNvbnN0IGluIHZlYzMgYXR0ZW51YXRpb25Db2xvciwgY29uc3QgaW4gZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZSApIHsKCQlpZiAoIGlzaW5mKCBhdHRlbnVhdGlvbkRpc3RhbmNlICkgKSB7CgkJCXJldHVybiB2ZWMzKCAxLjAgKTsKCQl9IGVsc2UgewoJCQl2ZWMzIGF0dGVudWF0aW9uQ29lZmZpY2llbnQgPSAtbG9nKCBhdHRlbnVhdGlvbkNvbG9yICkgLyBhdHRlbnVhdGlvbkRpc3RhbmNlOwoJCQl2ZWMzIHRyYW5zbWl0dGFuY2UgPSBleHAoIC0gYXR0ZW51YXRpb25Db2VmZmljaWVudCAqIHRyYW5zbWlzc2lvbkRpc3RhbmNlICk7CQkJcmV0dXJuIHRyYW5zbWl0dGFuY2U7CgkJfQoJfQoJdmVjNCBnZXRJQkxWb2x1bWVSZWZyYWN0aW9uKCBjb25zdCBpbiB2ZWMzIG4sIGNvbnN0IGluIHZlYzMgdiwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBjb25zdCBpbiB2ZWMzIGRpZmZ1c2VDb2xvciwKCQljb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNwZWN1bGFyRjkwLCBjb25zdCBpbiB2ZWMzIHBvc2l0aW9uLCBjb25zdCBpbiBtYXQ0IG1vZGVsTWF0cml4LAoJCWNvbnN0IGluIG1hdDQgdmlld01hdHJpeCwgY29uc3QgaW4gbWF0NCBwcm9qTWF0cml4LCBjb25zdCBpbiBmbG9hdCBkaXNwZXJzaW9uLCBjb25zdCBpbiBmbG9hdCBpb3IsIGNvbnN0IGluIGZsb2F0IHRoaWNrbmVzcywKCQljb25zdCBpbiB2ZWMzIGF0dGVudWF0aW9uQ29sb3IsIGNvbnN0IGluIGZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2UgKSB7CgkJdmVjNCB0cmFuc21pdHRlZExpZ2h0OwoJCXZlYzMgdHJhbnNtaXR0YW5jZTsKCQkjaWZkZWYgVVNFX0RJU1BFUlNJT04KCQkJZmxvYXQgaGFsZlNwcmVhZCA9ICggaW9yIC0gMS4wICkgKiAwLjAyNSAqIGRpc3BlcnNpb247CgkJCXZlYzMgaW9ycyA9IHZlYzMoIGlvciAtIGhhbGZTcHJlYWQsIGlvciwgaW9yICsgaGFsZlNwcmVhZCApOwoJCQlmb3IgKCBpbnQgaSA9IDA7IGkgPCAzOyBpICsrICkgewoJCQkJdmVjMyB0cmFuc21pc3Npb25SYXkgPSBnZXRWb2x1bWVUcmFuc21pc3Npb25SYXkoIG4sIHYsIHRoaWNrbmVzcywgaW9yc1sgaSBdLCBtb2RlbE1hdHJpeCApOwoJCQkJdmVjMyByZWZyYWN0ZWRSYXlFeGl0ID0gcG9zaXRpb24gKyB0cmFuc21pc3Npb25SYXk7CgkJCgkJCQl2ZWM0IG5kY1BvcyA9IHByb2pNYXRyaXggKiB2aWV3TWF0cml4ICogdmVjNCggcmVmcmFjdGVkUmF5RXhpdCwgMS4wICk7CgkJCQl2ZWMyIHJlZnJhY3Rpb25Db29yZHMgPSBuZGNQb3MueHkgLyBuZGNQb3MudzsKCQkJCXJlZnJhY3Rpb25Db29yZHMgKz0gMS4wOwoJCQkJcmVmcmFjdGlvbkNvb3JkcyAvPSAyLjA7CgkJCgkJCQl2ZWM0IHRyYW5zbWlzc2lvblNhbXBsZSA9IGdldFRyYW5zbWlzc2lvblNhbXBsZSggcmVmcmFjdGlvbkNvb3Jkcywgcm91Z2huZXNzLCBpb3JzWyBpIF0gKTsKCQkJCXRyYW5zbWl0dGVkTGlnaHRbIGkgXSA9IHRyYW5zbWlzc2lvblNhbXBsZVsgaSBdOwoJCQkJdHJhbnNtaXR0ZWRMaWdodC5hICs9IHRyYW5zbWlzc2lvblNhbXBsZS5hOwoJCQkJdHJhbnNtaXR0YW5jZVsgaSBdID0gZGlmZnVzZUNvbG9yWyBpIF0gKiB2b2x1bWVBdHRlbnVhdGlvbiggbGVuZ3RoKCB0cmFuc21pc3Npb25SYXkgKSwgYXR0ZW51YXRpb25Db2xvciwgYXR0ZW51YXRpb25EaXN0YW5jZSApWyBpIF07CgkJCX0KCQkJdHJhbnNtaXR0ZWRMaWdodC5hIC89IDMuMDsKCQkKCQkjZWxzZQoJCQoJCQl2ZWMzIHRyYW5zbWlzc2lvblJheSA9IGdldFZvbHVtZVRyYW5zbWlzc2lvblJheSggbiwgdiwgdGhpY2tuZXNzLCBpb3IsIG1vZGVsTWF0cml4ICk7CgkJCXZlYzMgcmVmcmFjdGVkUmF5RXhpdCA9IHBvc2l0aW9uICsgdHJhbnNtaXNzaW9uUmF5OwoJCQl2ZWM0IG5kY1BvcyA9IHByb2pNYXRyaXggKiB2aWV3TWF0cml4ICogdmVjNCggcmVmcmFjdGVkUmF5RXhpdCwgMS4wICk7CgkJCXZlYzIgcmVmcmFjdGlvbkNvb3JkcyA9IG5kY1Bvcy54eSAvIG5kY1Bvcy53OwoJCQlyZWZyYWN0aW9uQ29vcmRzICs9IDEuMDsKCQkJcmVmcmFjdGlvbkNvb3JkcyAvPSAyLjA7CgkJCXRyYW5zbWl0dGVkTGlnaHQgPSBnZXRUcmFuc21pc3Npb25TYW1wbGUoIHJlZnJhY3Rpb25Db29yZHMsIHJvdWdobmVzcywgaW9yICk7CgkJCXRyYW5zbWl0dGFuY2UgPSBkaWZmdXNlQ29sb3IgKiB2b2x1bWVBdHRlbnVhdGlvbiggbGVuZ3RoKCB0cmFuc21pc3Npb25SYXkgKSwgYXR0ZW51YXRpb25Db2xvciwgYXR0ZW51YXRpb25EaXN0YW5jZSApOwoJCQoJCSNlbmRpZgoJCXZlYzMgYXR0ZW51YXRlZENvbG9yID0gdHJhbnNtaXR0YW5jZSAqIHRyYW5zbWl0dGVkTGlnaHQucmdiOwoJCXZlYzMgRiA9IEVudmlyb25tZW50QlJERiggbiwgdiwgc3BlY3VsYXJDb2xvciwgc3BlY3VsYXJGOTAsIHJvdWdobmVzcyApOwoJCWZsb2F0IHRyYW5zbWl0dGFuY2VGYWN0b3IgPSAoIHRyYW5zbWl0dGFuY2UuciArIHRyYW5zbWl0dGFuY2UuZyArIHRyYW5zbWl0dGFuY2UuYiApIC8gMy4wOwoJCXJldHVybiB2ZWM0KCAoIDEuMCAtIEYgKSAqIGF0dGVudWF0ZWRDb2xvciwgMS4wIC0gKCAxLjAgLSB0cmFuc21pdHRlZExpZ2h0LmEgKSAqIHRyYW5zbWl0dGFuY2VGYWN0b3IgKTsKCX0KI2VuZGlmYCxGbD1gI2lmIGRlZmluZWQoIFVTRV9VViApIHx8IGRlZmluZWQoIFVTRV9BTklTT1RST1BZICkKCXZhcnlpbmcgdmVjMiB2VXY7CiNlbmRpZgojaWZkZWYgVVNFX01BUAoJdmFyeWluZyB2ZWMyIHZNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQUxQSEFNQVAKCXZhcnlpbmcgdmVjMiB2QWxwaGFNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfTElHSFRNQVAKCXZhcnlpbmcgdmVjMiB2TGlnaHRNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQU9NQVAKCXZhcnlpbmcgdmVjMiB2QW9NYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQlVNUE1BUAoJdmFyeWluZyB2ZWMyIHZCdW1wTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX05PUk1BTE1BUAoJdmFyeWluZyB2ZWMyIHZOb3JtYWxNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfRU1JU1NJVkVNQVAKCXZhcnlpbmcgdmVjMiB2RW1pc3NpdmVNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQCgl2YXJ5aW5nIHZlYzIgdk1ldGFsbmVzc01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVAKCXZhcnlpbmcgdmVjMiB2Um91Z2huZXNzTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0FOSVNPVFJPUFlNQVAKCXZhcnlpbmcgdmVjMiB2QW5pc290cm9weU1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRNQVAKCXZhcnlpbmcgdmVjMiB2Q2xlYXJjb2F0TWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAKCXZhcnlpbmcgdmVjMiB2Q2xlYXJjb2F0Tm9ybWFsTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAKCXZhcnlpbmcgdmVjMiB2Q2xlYXJjb2F0Um91Z2huZXNzTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0lSSURFU0NFTkNFTUFQCgl2YXJ5aW5nIHZlYzIgdklyaWRlc2NlbmNlTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUAoJdmFyeWluZyB2ZWMyIHZJcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUAoJdmFyeWluZyB2ZWMyIHZTaGVlbkNvbG9yTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1NIRUVOX1JPVUdITkVTU01BUAoJdmFyeWluZyB2ZWMyIHZTaGVlblJvdWdobmVzc01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9TUEVDVUxBUk1BUAoJdmFyeWluZyB2ZWMyIHZTcGVjdWxhck1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9TUEVDVUxBUl9DT0xPUk1BUAoJdmFyeWluZyB2ZWMyIHZTcGVjdWxhckNvbG9yTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUAoJdmFyeWluZyB2ZWMyIHZTcGVjdWxhckludGVuc2l0eU1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVAKCXVuaWZvcm0gbWF0MyB0cmFuc21pc3Npb25NYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdlRyYW5zbWlzc2lvbk1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9USElDS05FU1NNQVAKCXVuaWZvcm0gbWF0MyB0aGlja25lc3NNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdlRoaWNrbmVzc01hcFV2OwojZW5kaWZgLElsPWAjaWYgZGVmaW5lZCggVVNFX1VWICkgfHwgZGVmaW5lZCggVVNFX0FOSVNPVFJPUFkgKQoJdmFyeWluZyB2ZWMyIHZVdjsKI2VuZGlmCiNpZmRlZiBVU0VfTUFQCgl1bmlmb3JtIG1hdDMgbWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQUxQSEFNQVAKCXVuaWZvcm0gbWF0MyBhbHBoYU1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2QWxwaGFNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfTElHSFRNQVAKCXVuaWZvcm0gbWF0MyBsaWdodE1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2TGlnaHRNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQU9NQVAKCXVuaWZvcm0gbWF0MyBhb01hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2QW9NYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQlVNUE1BUAoJdW5pZm9ybSBtYXQzIGJ1bXBNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdkJ1bXBNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfTk9STUFMTUFQCgl1bmlmb3JtIG1hdDMgbm9ybWFsTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZOb3JtYWxNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQCgl1bmlmb3JtIG1hdDMgZGlzcGxhY2VtZW50TWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZEaXNwbGFjZW1lbnRNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfRU1JU1NJVkVNQVAKCXVuaWZvcm0gbWF0MyBlbWlzc2l2ZU1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2RW1pc3NpdmVNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQCgl1bmlmb3JtIG1hdDMgbWV0YWxuZXNzTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZNZXRhbG5lc3NNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQCgl1bmlmb3JtIG1hdDMgcm91Z2huZXNzTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZSb3VnaG5lc3NNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUAoJdW5pZm9ybSBtYXQzIGFuaXNvdHJvcHlNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdkFuaXNvdHJvcHlNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQCgl1bmlmb3JtIG1hdDMgY2xlYXJjb2F0TWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZDbGVhcmNvYXRNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUAoJdW5pZm9ybSBtYXQzIGNsZWFyY29hdE5vcm1hbE1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2Q2xlYXJjb2F0Tm9ybWFsTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAKCXVuaWZvcm0gbWF0MyBjbGVhcmNvYXRSb3VnaG5lc3NNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdkNsZWFyY29hdFJvdWdobmVzc01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUAoJdW5pZm9ybSBtYXQzIHNoZWVuQ29sb3JNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdlNoZWVuQ29sb3JNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQCgl1bmlmb3JtIG1hdDMgc2hlZW5Sb3VnaG5lc3NNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdlNoZWVuUm91Z2huZXNzTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0lSSURFU0NFTkNFTUFQCgl1bmlmb3JtIG1hdDMgaXJpZGVzY2VuY2VNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdklyaWRlc2NlbmNlTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUAoJdW5pZm9ybSBtYXQzIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZJcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9TUEVDVUxBUk1BUAoJdW5pZm9ybSBtYXQzIHNwZWN1bGFyTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZTcGVjdWxhck1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9TUEVDVUxBUl9DT0xPUk1BUAoJdW5pZm9ybSBtYXQzIHNwZWN1bGFyQ29sb3JNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdlNwZWN1bGFyQ29sb3JNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfU1BFQ1VMQVJfSU5URU5TSVRZTUFQCgl1bmlmb3JtIG1hdDMgc3BlY3VsYXJJbnRlbnNpdHlNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdlNwZWN1bGFySW50ZW5zaXR5TWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUAoJdW5pZm9ybSBtYXQzIHRyYW5zbWlzc2lvbk1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2VHJhbnNtaXNzaW9uTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1RISUNLTkVTU01BUAoJdW5pZm9ybSBtYXQzIHRoaWNrbmVzc01hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2VGhpY2tuZXNzTWFwVXY7CiNlbmRpZmAsTmw9YCNpZiBkZWZpbmVkKCBVU0VfVVYgKSB8fCBkZWZpbmVkKCBVU0VfQU5JU09UUk9QWSApCgl2VXYgPSB2ZWMzKCB1diwgMSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9NQVAKCXZNYXBVdiA9ICggbWFwVHJhbnNmb3JtICogdmVjMyggTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfQUxQSEFNQVAKCXZBbHBoYU1hcFV2ID0gKCBhbHBoYU1hcFRyYW5zZm9ybSAqIHZlYzMoIEFMUEhBTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfTElHSFRNQVAKCXZMaWdodE1hcFV2ID0gKCBsaWdodE1hcFRyYW5zZm9ybSAqIHZlYzMoIExJR0hUTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfQU9NQVAKCXZBb01hcFV2ID0gKCBhb01hcFRyYW5zZm9ybSAqIHZlYzMoIEFPTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfQlVNUE1BUAoJdkJ1bXBNYXBVdiA9ICggYnVtcE1hcFRyYW5zZm9ybSAqIHZlYzMoIEJVTVBNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9OT1JNQUxNQVAKCXZOb3JtYWxNYXBVdiA9ICggbm9ybWFsTWFwVHJhbnNmb3JtICogdmVjMyggTk9STUFMTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQCgl2RGlzcGxhY2VtZW50TWFwVXYgPSAoIGRpc3BsYWNlbWVudE1hcFRyYW5zZm9ybSAqIHZlYzMoIERJU1BMQUNFTUVOVE1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX0VNSVNTSVZFTUFQCgl2RW1pc3NpdmVNYXBVdiA9ICggZW1pc3NpdmVNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBFTUlTU0lWRU1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX01FVEFMTkVTU01BUAoJdk1ldGFsbmVzc01hcFV2ID0gKCBtZXRhbG5lc3NNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBNRVRBTE5FU1NNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVAKCXZSb3VnaG5lc3NNYXBVdiA9ICggcm91Z2huZXNzTWFwVHJhbnNmb3JtICogdmVjMyggUk9VR0hORVNTTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUAoJdkFuaXNvdHJvcHlNYXBVdiA9ICggYW5pc290cm9weU1hcFRyYW5zZm9ybSAqIHZlYzMoIEFOSVNPVFJPUFlNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRNQVAKCXZDbGVhcmNvYXRNYXBVdiA9ICggY2xlYXJjb2F0TWFwVHJhbnNmb3JtICogdmVjMyggQ0xFQVJDT0FUTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUAoJdkNsZWFyY29hdE5vcm1hbE1hcFV2ID0gKCBjbGVhcmNvYXROb3JtYWxNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBDTEVBUkNPQVRfTk9STUFMTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUAoJdkNsZWFyY29hdFJvdWdobmVzc01hcFV2ID0gKCBjbGVhcmNvYXRSb3VnaG5lc3NNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBDTEVBUkNPQVRfUk9VR0hORVNTTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VNQVAKCXZJcmlkZXNjZW5jZU1hcFV2ID0gKCBpcmlkZXNjZW5jZU1hcFRyYW5zZm9ybSAqIHZlYzMoIElSSURFU0NFTkNFTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQCgl2SXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdiA9ICggaXJpZGVzY2VuY2VUaGlja25lc3NNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBJUklERVNDRU5DRV9USElDS05FU1NNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUAoJdlNoZWVuQ29sb3JNYXBVdiA9ICggc2hlZW5Db2xvck1hcFRyYW5zZm9ybSAqIHZlYzMoIFNIRUVOX0NPTE9STUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQCgl2U2hlZW5Sb3VnaG5lc3NNYXBVdiA9ICggc2hlZW5Sb3VnaG5lc3NNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBTSEVFTl9ST1VHSE5FU1NNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9TUEVDVUxBUk1BUAoJdlNwZWN1bGFyTWFwVXYgPSAoIHNwZWN1bGFyTWFwVHJhbnNmb3JtICogdmVjMyggU1BFQ1VMQVJNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9TUEVDVUxBUl9DT0xPUk1BUAoJdlNwZWN1bGFyQ29sb3JNYXBVdiA9ICggc3BlY3VsYXJDb2xvck1hcFRyYW5zZm9ybSAqIHZlYzMoIFNQRUNVTEFSX0NPTE9STUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfU1BFQ1VMQVJfSU5URU5TSVRZTUFQCgl2U3BlY3VsYXJJbnRlbnNpdHlNYXBVdiA9ICggc3BlY3VsYXJJbnRlbnNpdHlNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBTUEVDVUxBUl9JTlRFTlNJVFlNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVAKCXZUcmFuc21pc3Npb25NYXBVdiA9ICggdHJhbnNtaXNzaW9uTWFwVHJhbnNmb3JtICogdmVjMyggVFJBTlNNSVNTSU9OTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQCgl2VGhpY2tuZXNzTWFwVXYgPSAoIHRoaWNrbmVzc01hcFRyYW5zZm9ybSAqIHZlYzMoIFRISUNLTkVTU01BUF9VViwgMSApICkueHk7CiNlbmRpZmAsT2w9YCNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggRElTVEFOQ0UgKSB8fCBkZWZpbmVkICggVVNFX1NIQURPV01BUCApIHx8IGRlZmluZWQgKCBVU0VfVFJBTlNNSVNTSU9OICkgfHwgTlVNX1NQT1RfTElHSFRfQ09PUkRTID4gMAoJdmVjNCB3b3JsZFBvc2l0aW9uID0gdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApOwoJI2lmZGVmIFVTRV9CQVRDSElORwoJCXdvcmxkUG9zaXRpb24gPSBiYXRjaGluZ01hdHJpeCAqIHdvcmxkUG9zaXRpb247CgkjZW5kaWYKCSNpZmRlZiBVU0VfSU5TVEFOQ0lORwoJCXdvcmxkUG9zaXRpb24gPSBpbnN0YW5jZU1hdHJpeCAqIHdvcmxkUG9zaXRpb247CgkjZW5kaWYKCXdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHdvcmxkUG9zaXRpb247CiNlbmRpZmA7Y29uc3QgRGU9e2FscGhhaGFzaF9mcmFnbWVudDpCYSxhbHBoYWhhc2hfcGFyc19mcmFnbWVudDp6YSxhbHBoYW1hcF9mcmFnbWVudDpHYSxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50OkhhLGFscGhhdGVzdF9mcmFnbWVudDpWYSxhbHBoYXRlc3RfcGFyc19mcmFnbWVudDprYSxhb21hcF9mcmFnbWVudDpXYSxhb21hcF9wYXJzX2ZyYWdtZW50OlhhLGJhdGNoaW5nX3BhcnNfdmVydGV4OnFhLGJhdGNoaW5nX3ZlcnRleDpZYSxiZWdpbl92ZXJ0ZXg6JGEsYmVnaW5ub3JtYWxfdmVydGV4OkthLGJzZGZzOlphLGlyaWRlc2NlbmNlX2ZyYWdtZW50OmphLGJ1bXBtYXBfcGFyc19mcmFnbWVudDpKYSxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ6UWEsY2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ6ZW8sY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4OnRvLGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg6bm8sY29sb3JfZnJhZ21lbnQ6aW8sY29sb3JfcGFyc19mcmFnbWVudDpybyxjb2xvcl9wYXJzX3ZlcnRleDpzbyxjb2xvcl92ZXJ0ZXg6YW8sY29tbW9uOm9vLGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudDpsbyxkZWZhdWx0bm9ybWFsX3ZlcnRleDpjbyxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg6dW8sZGlzcGxhY2VtZW50bWFwX3ZlcnRleDpobyxlbWlzc2l2ZW1hcF9mcmFnbWVudDpmbyxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50OnBvLGNvbG9yc3BhY2VfZnJhZ21lbnQ6bW8sY29sb3JzcGFjZV9wYXJzX2ZyYWdtZW50OmdvLGVudm1hcF9mcmFnbWVudDpfbyxlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ6dm8sZW52bWFwX3BhcnNfZnJhZ21lbnQ6eG8sZW52bWFwX3BhcnNfdmVydGV4Ok1vLGVudm1hcF9waHlzaWNhbF9wYXJzX2ZyYWdtZW50OkRvLGVudm1hcF92ZXJ0ZXg6U28sZm9nX3ZlcnRleDpFbyxmb2dfcGFyc192ZXJ0ZXg6eW8sZm9nX2ZyYWdtZW50OlRvLGZvZ19wYXJzX2ZyYWdtZW50OkFvLGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQ6d28sbGlnaHRtYXBfcGFyc19mcmFnbWVudDpibyxsaWdodHNfbGFtYmVydF9mcmFnbWVudDpSbyxsaWdodHNfbGFtYmVydF9wYXJzX2ZyYWdtZW50OkNvLGxpZ2h0c19wYXJzX2JlZ2luOlBvLGxpZ2h0c190b29uX2ZyYWdtZW50OkxvLGxpZ2h0c190b29uX3BhcnNfZnJhZ21lbnQ6VW8sbGlnaHRzX3Bob25nX2ZyYWdtZW50OkZvLGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50OklvLGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudDpObyxsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudDpPbyxsaWdodHNfZnJhZ21lbnRfYmVnaW46Qm8sbGlnaHRzX2ZyYWdtZW50X21hcHM6em8sbGlnaHRzX2ZyYWdtZW50X2VuZDpHbyxsb2dkZXB0aGJ1Zl9mcmFnbWVudDpIbyxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50OlZvLGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4OmtvLGxvZ2RlcHRoYnVmX3ZlcnRleDpXbyxtYXBfZnJhZ21lbnQ6WG8sbWFwX3BhcnNfZnJhZ21lbnQ6cW8sbWFwX3BhcnRpY2xlX2ZyYWdtZW50OllvLG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50OiRvLG1ldGFsbmVzc21hcF9mcmFnbWVudDpLbyxtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudDpabyxtb3JwaGluc3RhbmNlX3ZlcnRleDpqbyxtb3JwaGNvbG9yX3ZlcnRleDpKbyxtb3JwaG5vcm1hbF92ZXJ0ZXg6UW8sbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg6ZWwsbW9ycGh0YXJnZXRfdmVydGV4OnRsLG5vcm1hbF9mcmFnbWVudF9iZWdpbjpubCxub3JtYWxfZnJhZ21lbnRfbWFwczppbCxub3JtYWxfcGFyc19mcmFnbWVudDpybCxub3JtYWxfcGFyc192ZXJ0ZXg6c2wsbm9ybWFsX3ZlcnRleDphbCxub3JtYWxtYXBfcGFyc19mcmFnbWVudDpvbCxjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X2JlZ2luOmxsLGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwczpjbCxjbGVhcmNvYXRfcGFyc19mcmFnbWVudDp1bCxpcmlkZXNjZW5jZV9wYXJzX2ZyYWdtZW50OmhsLG9wYXF1ZV9mcmFnbWVudDpkbCxwYWNraW5nOmZsLHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ6cGwscHJvamVjdF92ZXJ0ZXg6bWwsZGl0aGVyaW5nX2ZyYWdtZW50OmdsLGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50Ol9sLHJvdWdobmVzc21hcF9mcmFnbWVudDp2bCxyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudDp4bCxzaGFkb3dtYXBfcGFyc19mcmFnbWVudDpNbCxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg6U2wsc2hhZG93bWFwX3ZlcnRleDpFbCxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ6eWwsc2tpbmJhc2VfdmVydGV4OlRsLHNraW5uaW5nX3BhcnNfdmVydGV4OkFsLHNraW5uaW5nX3ZlcnRleDp3bCxza2lubm9ybWFsX3ZlcnRleDpibCxzcGVjdWxhcm1hcF9mcmFnbWVudDpSbCxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50OkNsLHRvbmVtYXBwaW5nX2ZyYWdtZW50OlBsLHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQ6RGwsdHJhbnNtaXNzaW9uX2ZyYWdtZW50OkxsLHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50OlVsLHV2X3BhcnNfZnJhZ21lbnQ6RmwsdXZfcGFyc192ZXJ0ZXg6SWwsdXZfdmVydGV4Ok5sLHdvcmxkcG9zX3ZlcnRleDpPbCxiYWNrZ3JvdW5kX3ZlcnQ6YHZhcnlpbmcgdmVjMiB2VXY7CnVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTsKdm9pZCBtYWluKCkgewoJdlV2ID0gKCB1dlRyYW5zZm9ybSAqIHZlYzMoIHV2LCAxICkgKS54eTsKCWdsX1Bvc2l0aW9uID0gdmVjNCggcG9zaXRpb24ueHksIDEuMCwgMS4wICk7Cn1gLGJhY2tncm91bmRfZnJhZzpgdW5pZm9ybSBzYW1wbGVyMkQgdDJEOwp1bmlmb3JtIGZsb2F0IGJhY2tncm91bmRJbnRlbnNpdHk7CnZhcnlpbmcgdmVjMiB2VXY7CnZvaWQgbWFpbigpIHsKCXZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQoIHQyRCwgdlV2ICk7CgkjaWZkZWYgREVDT0RFX1ZJREVPX1RFWFRVUkUKCQl0ZXhDb2xvciA9IHZlYzQoIG1peCggcG93KCB0ZXhDb2xvci5yZ2IgKiAwLjk0Nzg2NzI5ODYgKyB2ZWMzKCAwLjA1MjEzMjcwMTQgKSwgdmVjMyggMi40ICkgKSwgdGV4Q29sb3IucmdiICogMC4wNzczOTkzODA4LCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB0ZXhDb2xvci5yZ2IsIHZlYzMoIDAuMDQwNDUgKSApICkgKSwgdGV4Q29sb3IudyApOwoJI2VuZGlmCgl0ZXhDb2xvci5yZ2IgKj0gYmFja2dyb3VuZEludGVuc2l0eTsKCWdsX0ZyYWdDb2xvciA9IHRleENvbG9yOwoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+Cn1gLGJhY2tncm91bmRDdWJlX3ZlcnQ6YHZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247CiNpbmNsdWRlIDxjb21tb24+CnZvaWQgbWFpbigpIHsKCXZXb3JsZERpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJZ2xfUG9zaXRpb24ueiA9IGdsX1Bvc2l0aW9uLnc7Cn1gLGJhY2tncm91bmRDdWJlX2ZyYWc6YCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFCgl1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDsKI2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApCgl1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7CiNlbmRpZgp1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7CnVuaWZvcm0gZmxvYXQgYmFja2dyb3VuZEJsdXJyaW5lc3M7CnVuaWZvcm0gZmxvYXQgYmFja2dyb3VuZEludGVuc2l0eTsKdW5pZm9ybSBtYXQzIGJhY2tncm91bmRSb3RhdGlvbjsKdmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjsKI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD4Kdm9pZCBtYWluKCkgewoJI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkUKCQl2ZWM0IHRleENvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgYmFja2dyb3VuZFJvdGF0aW9uICogdmVjMyggZmxpcEVudk1hcCAqIHZXb3JsZERpcmVjdGlvbi54LCB2V29ybGREaXJlY3Rpb24ueXogKSApOwoJI2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApCgkJdmVjNCB0ZXhDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgYmFja2dyb3VuZFJvdGF0aW9uICogdldvcmxkRGlyZWN0aW9uLCBiYWNrZ3JvdW5kQmx1cnJpbmVzcyApOwoJI2Vsc2UKCQl2ZWM0IHRleENvbG9yID0gdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7CgkjZW5kaWYKCXRleENvbG9yLnJnYiAqPSBiYWNrZ3JvdW5kSW50ZW5zaXR5OwoJZ2xfRnJhZ0NvbG9yID0gdGV4Q29sb3I7CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KfWAsY3ViZV92ZXJ0OmB2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uOwojaW5jbHVkZSA8Y29tbW9uPgp2b2lkIG1haW4oKSB7Cgl2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApOwoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCWdsX1Bvc2l0aW9uLnogPSBnbF9Qb3NpdGlvbi53Owp9YCxjdWJlX2ZyYWc6YHVuaWZvcm0gc2FtcGxlckN1YmUgdEN1YmU7CnVuaWZvcm0gZmxvYXQgdEZsaXA7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKdmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjsKdm9pZCBtYWluKCkgewoJdmVjNCB0ZXhDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGREaXJlY3Rpb24ueCwgdldvcmxkRGlyZWN0aW9uLnl6ICkgKTsKCWdsX0ZyYWdDb2xvciA9IHRleENvbG9yOwoJZ2xfRnJhZ0NvbG9yLmEgKj0gb3BhY2l0eTsKCSNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50Pgp9YCxkZXB0aF92ZXJ0OmAjaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4KdmFyeWluZyB2ZWMyIHZIaWdoUHJlY2lzaW9uWlc7CnZvaWQgbWFpbigpIHsKCSNpbmNsdWRlIDx1dl92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD4KCSNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQCgkJI2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD4KCQkjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PgoJCSNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD4KCSNlbmRpZgoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PgoJI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PgoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+Cgl2SGlnaFByZWNpc2lvblpXID0gZ2xfUG9zaXRpb24uenc7Cn1gLGRlcHRoX2ZyYWc6YCNpZiBERVBUSF9QQUNLSU5HID09IDMyMDAKCXVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2VuZGlmCiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxwYWNraW5nPgojaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZhcnlpbmcgdmVjMiB2SGlnaFByZWNpc2lvblpXOwp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDEuMCApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCSNpZiBERVBUSF9QQUNLSU5HID09IDMyMDAKCQlkaWZmdXNlQ29sb3IuYSA9IG9wYWNpdHk7CgkjZW5kaWYKCSNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD4KCWZsb2F0IGZyYWdDb29yZFogPSAwLjUgKiB2SGlnaFByZWNpc2lvblpXWzBdIC8gdkhpZ2hQcmVjaXNpb25aV1sxXSArIDAuNTsKCSNpZiBERVBUSF9QQUNLSU5HID09IDMyMDAKCQlnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCAxLjAgLSBmcmFnQ29vcmRaICksIG9wYWNpdHkgKTsKCSNlbGlmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMQoJCWdsX0ZyYWdDb2xvciA9IHBhY2tEZXB0aFRvUkdCQSggZnJhZ0Nvb3JkWiApOwoJI2VsaWYgREVQVEhfUEFDS0lORyA9PSAzMjAyCgkJZ2xfRnJhZ0NvbG9yID0gdmVjNCggcGFja0RlcHRoVG9SR0IoIGZyYWdDb29yZFogKSwgMS4wICk7CgkjZWxpZiBERVBUSF9QQUNLSU5HID09IDMyMDMKCQlnbF9GcmFnQ29sb3IgPSB2ZWM0KCBwYWNrRGVwdGhUb1JHKCBmcmFnQ29vcmRaICksIDAuMCwgMS4wICk7CgkjZW5kaWYKfWAsZGlzdGFuY2VSR0JBX3ZlcnQ6YCNkZWZpbmUgRElTVEFOQ0UKdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uOwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+CnZvaWQgbWFpbigpIHsKCSNpbmNsdWRlIDx1dl92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD4KCSNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQCgkJI2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD4KCQkjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PgoJCSNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD4KCSNlbmRpZgoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PgoJI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CgkjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PgoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+Cgl2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6Owp9YCxkaXN0YW5jZVJHQkFfZnJhZzpgI2RlZmluZSBESVNUQU5DRQp1bmlmb3JtIHZlYzMgcmVmZXJlbmNlUG9zaXRpb247CnVuaWZvcm0gZmxvYXQgbmVhckRpc3RhbmNlOwp1bmlmb3JtIGZsb2F0IGZhckRpc3RhbmNlOwp2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxwYWNraW5nPgojaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD4Kdm9pZCBtYWluICgpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggMS4wICk7CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJZmxvYXQgZGlzdCA9IGxlbmd0aCggdldvcmxkUG9zaXRpb24gLSByZWZlcmVuY2VQb3NpdGlvbiApOwoJZGlzdCA9ICggZGlzdCAtIG5lYXJEaXN0YW5jZSApIC8gKCBmYXJEaXN0YW5jZSAtIG5lYXJEaXN0YW5jZSApOwoJZGlzdCA9IHNhdHVyYXRlKCBkaXN0ICk7CglnbF9GcmFnQ29sb3IgPSBwYWNrRGVwdGhUb1JHQkEoIGRpc3QgKTsKfWAsZXF1aXJlY3RfdmVydDpgdmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4Kdm9pZCBtYWluKCkgewoJdldvcmxkRGlyZWN0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTsKCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+Cn1gLGVxdWlyZWN0X2ZyYWc6YHVuaWZvcm0gc2FtcGxlcjJEIHRFcXVpcmVjdDsKdmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4Kdm9pZCBtYWluKCkgewoJdmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHZXb3JsZERpcmVjdGlvbiApOwoJdmVjMiBzYW1wbGVVViA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApOwoJZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KfWAsbGluZWRhc2hlZF92ZXJ0OmB1bmlmb3JtIGZsb2F0IHNjYWxlOwphdHRyaWJ1dGUgZmxvYXQgbGluZURpc3RhbmNlOwp2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJdkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlOwoJI2luY2x1ZGUgPHV2X3ZlcnRleD4KCSNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KCSNpbmNsdWRlIDxmb2dfdmVydGV4Pgp9YCxsaW5lZGFzaGVkX2ZyYWc6YHVuaWZvcm0gdmVjMyBkaWZmdXNlOwp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CnVuaWZvcm0gZmxvYXQgZGFzaFNpemU7CnVuaWZvcm0gZmxvYXQgdG90YWxTaXplOwp2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCWlmICggbW9kKCB2TGluZURpc3RhbmNlLCB0b3RhbFNpemUgKSA+IGRhc2hTaXplICkgewoJCWRpc2NhcmQ7Cgl9Cgl2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTsKCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD4KCSNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+CglvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjsKCSNpbmNsdWRlIDxvcGFxdWVfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KCSNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD4KfWAsbWVzaGJhc2ljX3ZlcnQ6YCNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxiYXRjaGluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+CnZvaWQgbWFpbigpIHsKCSNpbmNsdWRlIDx1dl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD4KCSNpZiBkZWZpbmVkICggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQgKCBVU0VfU0tJTk5JTkcgKQoJCSNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+CgkJI2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD4KCQkjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PgoJCSNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD4KCQkjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+CgkjZW5kaWYKCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KCSNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+CgkjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxmb2dfdmVydGV4Pgp9YCxtZXNoYmFzaWNfZnJhZzpgdW5pZm9ybSB2ZWMzIGRpZmZ1c2U7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2lmbmRlZiBGTEFUX1NIQURFRAoJdmFyeWluZyB2ZWMzIHZOb3JtYWw7CiNlbmRpZgojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Pgp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTsKCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+CglSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApOwoJI2lmZGVmIFVTRV9MSUdIVE1BUAoJCXZlYzQgbGlnaHRNYXBUZXhlbCA9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZMaWdodE1hcFV2ICk7CgkJcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGxpZ2h0TWFwVGV4ZWwucmdiICogbGlnaHRNYXBJbnRlbnNpdHkgKiBSRUNJUFJPQ0FMX1BJOwoJI2Vsc2UKCQlyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gdmVjMyggMS4wICk7CgkjZW5kaWYKCSNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD4KCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBkaWZmdXNlQ29sb3IucmdiOwoJdmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlOwoJI2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxvcGFxdWVfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KCSNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD4KCSNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+Cn1gLG1lc2hsYW1iZXJ0X3ZlcnQ6YCNkZWZpbmUgTEFNQkVSVAp2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPHV2X3ZlcnRleD4KCSNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KCXZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6OwoJI2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD4KCSNpbmNsdWRlIDxlbnZtYXBfdmVydGV4PgoJI2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8Zm9nX3ZlcnRleD4KfWAsbWVzaGxhbWJlcnRfZnJhZzpgI2RlZmluZSBMQU1CRVJUCnVuaWZvcm0gdmVjMyBkaWZmdXNlOwp1bmlmb3JtIHZlYzMgZW1pc3NpdmU7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPHBhY2tpbmc+CiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxic2Rmcz4KI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodHNfbGFtYmVydF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCVJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7Cgl2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlOwoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj4KCSNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz4KCSNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfbGFtYmVydF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfYmVnaW4+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD4KCSNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD4KCXZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7CgkjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD4KCSNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGZvZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD4KfWAsbWVzaG1hdGNhcF92ZXJ0OmAjZGVmaW5lIE1BVENBUAp2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPHV2X3ZlcnRleD4KCSNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KCSNpbmNsdWRlIDxmb2dfdmVydGV4PgoJdlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7Cn1gLG1lc2htYXRjYXBfZnJhZzpgI2RlZmluZSBNQVRDQVAKdW5pZm9ybSB2ZWMzIGRpZmZ1c2U7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKdW5pZm9ybSBzYW1wbGVyMkQgbWF0Y2FwOwp2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Pgp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTsKCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPgoJdmVjMyB2aWV3RGlyID0gbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7Cgl2ZWMzIHggPSBub3JtYWxpemUoIHZlYzMoIHZpZXdEaXIueiwgMC4wLCAtIHZpZXdEaXIueCApICk7Cgl2ZWMzIHkgPSBjcm9zcyggdmlld0RpciwgeCApOwoJdmVjMiB1diA9IHZlYzIoIGRvdCggeCwgbm9ybWFsICksIGRvdCggeSwgbm9ybWFsICkgKSAqIDAuNDk1ICsgMC41OwoJI2lmZGVmIFVTRV9NQVRDQVAKCQl2ZWM0IG1hdGNhcENvbG9yID0gdGV4dHVyZTJEKCBtYXRjYXAsIHV2ICk7CgkjZWxzZQoJCXZlYzQgbWF0Y2FwQ29sb3IgPSB2ZWM0KCB2ZWMzKCBtaXgoIDAuMiwgMC44LCB1di55ICkgKSwgMS4wICk7CgkjZW5kaWYKCXZlYzMgb3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2IgKiBtYXRjYXBDb2xvci5yZ2I7CgkjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Pgp9YCxtZXNobm9ybWFsX3ZlcnQ6YCNkZWZpbmUgTk9STUFMCiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUF9UQU5HRU5UU1BBQ0UgKQoJdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CiNlbmRpZgojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPHV2X3ZlcnRleD4KCSNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD4KCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PgojaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFICkKCXZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6OwojZW5kaWYKfWAsbWVzaG5vcm1hbF9mcmFnOmAjZGVmaW5lIE5PUk1BTAp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUF9UQU5HRU5UU1BBQ0UgKQoJdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CiNlbmRpZgojaW5jbHVkZSA8cGFja2luZz4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Pgp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDAuMCwgMC4wLCAwLjAsIG9wYWNpdHkgKTsKCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPgoJZ2xfRnJhZ0NvbG9yID0gdmVjNCggcGFja05vcm1hbFRvUkdCKCBub3JtYWwgKSwgZGlmZnVzZUNvbG9yLmEgKTsKCSNpZmRlZiBPUEFRVUUKCQlnbF9GcmFnQ29sb3IuYSA9IDEuMDsKCSNlbmRpZgp9YCxtZXNocGhvbmdfdmVydDpgI2RlZmluZSBQSE9ORwp2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPHV2X3ZlcnRleD4KCSNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KCXZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6OwoJI2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD4KCSNpbmNsdWRlIDxlbnZtYXBfdmVydGV4PgoJI2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8Zm9nX3ZlcnRleD4KfWAsbWVzaHBob25nX2ZyYWc6YCNkZWZpbmUgUEhPTkcKdW5pZm9ybSB2ZWMzIGRpZmZ1c2U7CnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTsKdW5pZm9ybSB2ZWMzIHNwZWN1bGFyOwp1bmlmb3JtIGZsb2F0IHNoaW5pbmVzczsKdW5pZm9ybSBmbG9hdCBvcGFjaXR5OwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8cGFja2luZz4KI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGJzZGZzPgojaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+CiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCVJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7Cgl2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlOwoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj4KCSNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz4KCSNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfcGhvbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPgoJI2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9tYXBzPgoJI2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+CgkjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+Cgl2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlOwoJI2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxvcGFxdWVfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KCSNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD4KCSNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+Cn1gLG1lc2hwaHlzaWNhbF92ZXJ0OmAjZGVmaW5lIFNUQU5EQVJECnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uOwojaWZkZWYgVVNFX1RSQU5TTUlTU0lPTgoJdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uOwojZW5kaWYKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPHV2X3ZlcnRleD4KCSNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KCXZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6OwoJI2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD4KCSNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PgoJI2luY2x1ZGUgPGZvZ192ZXJ0ZXg+CiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OCgl2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6OwojZW5kaWYKfWAsbWVzaHBoeXNpY2FsX2ZyYWc6YCNkZWZpbmUgU1RBTkRBUkQKI2lmZGVmIFBIWVNJQ0FMCgkjZGVmaW5lIElPUgoJI2RlZmluZSBVU0VfU1BFQ1VMQVIKI2VuZGlmCnVuaWZvcm0gdmVjMyBkaWZmdXNlOwp1bmlmb3JtIHZlYzMgZW1pc3NpdmU7CnVuaWZvcm0gZmxvYXQgcm91Z2huZXNzOwp1bmlmb3JtIGZsb2F0IG1ldGFsbmVzczsKdW5pZm9ybSBmbG9hdCBvcGFjaXR5OwojaWZkZWYgSU9SCgl1bmlmb3JtIGZsb2F0IGlvcjsKI2VuZGlmCiNpZmRlZiBVU0VfU1BFQ1VMQVIKCXVuaWZvcm0gZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHk7Cgl1bmlmb3JtIHZlYzMgc3BlY3VsYXJDb2xvcjsKCSNpZmRlZiBVU0VfU1BFQ1VMQVJfQ09MT1JNQVAKCQl1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhckNvbG9yTWFwOwoJI2VuZGlmCgkjaWZkZWYgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUAoJCXVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFySW50ZW5zaXR5TWFwOwoJI2VuZGlmCiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVAoJdW5pZm9ybSBmbG9hdCBjbGVhcmNvYXQ7Cgl1bmlmb3JtIGZsb2F0IGNsZWFyY29hdFJvdWdobmVzczsKI2VuZGlmCiNpZmRlZiBVU0VfRElTUEVSU0lPTgoJdW5pZm9ybSBmbG9hdCBkaXNwZXJzaW9uOwojZW5kaWYKI2lmZGVmIFVTRV9JUklERVNDRU5DRQoJdW5pZm9ybSBmbG9hdCBpcmlkZXNjZW5jZTsKCXVuaWZvcm0gZmxvYXQgaXJpZGVzY2VuY2VJT1I7Cgl1bmlmb3JtIGZsb2F0IGlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bTsKCXVuaWZvcm0gZmxvYXQgaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtOwojZW5kaWYKI2lmZGVmIFVTRV9TSEVFTgoJdW5pZm9ybSB2ZWMzIHNoZWVuQ29sb3I7Cgl1bmlmb3JtIGZsb2F0IHNoZWVuUm91Z2huZXNzOwoJI2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUAoJCXVuaWZvcm0gc2FtcGxlcjJEIHNoZWVuQ29sb3JNYXA7CgkjZW5kaWYKCSNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQCgkJdW5pZm9ybSBzYW1wbGVyMkQgc2hlZW5Sb3VnaG5lc3NNYXA7CgkjZW5kaWYKI2VuZGlmCiNpZmRlZiBVU0VfQU5JU09UUk9QWQoJdW5pZm9ybSB2ZWMyIGFuaXNvdHJvcHlWZWN0b3I7CgkjaWZkZWYgVVNFX0FOSVNPVFJPUFlNQVAKCQl1bmlmb3JtIHNhbXBsZXIyRCBhbmlzb3Ryb3B5TWFwOwoJI2VuZGlmCiNlbmRpZgp2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPHBhY2tpbmc+CiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGlyaWRlc2NlbmNlX2ZyYWdtZW50PgojaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW52bWFwX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsZWFyY29hdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8aXJpZGVzY2VuY2VfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCVJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7Cgl2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlOwoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHJvdWdobmVzc21hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPgoJI2luY2x1ZGUgPGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfYmVnaW4+CgkjaW5jbHVkZSA8Y2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9tYXBzPgoJI2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfYmVnaW4+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD4KCSNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD4KCXZlYzMgdG90YWxEaWZmdXNlID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTsKCXZlYzMgdG90YWxTcGVjdWxhciA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhcjsKCSNpbmNsdWRlIDx0cmFuc21pc3Npb25fZnJhZ21lbnQ+Cgl2ZWMzIG91dGdvaW5nTGlnaHQgPSB0b3RhbERpZmZ1c2UgKyB0b3RhbFNwZWN1bGFyICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlOwoJI2lmZGVmIFVTRV9TSEVFTgoJCWZsb2F0IHNoZWVuRW5lcmd5Q29tcCA9IDEuMCAtIDAuMTU3ICogbWF4MyggbWF0ZXJpYWwuc2hlZW5Db2xvciApOwoJCW91dGdvaW5nTGlnaHQgPSBvdXRnb2luZ0xpZ2h0ICogc2hlZW5FbmVyZ3lDb21wICsgc2hlZW5TcGVjdWxhckRpcmVjdCArIHNoZWVuU3BlY3VsYXJJbmRpcmVjdDsKCSNlbmRpZgoJI2lmZGVmIFVTRV9DTEVBUkNPQVQKCQlmbG9hdCBkb3ROVmNjID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGdlb21ldHJ5Vmlld0RpciApICk7CgkJdmVjMyBGY2MgPSBGX1NjaGxpY2soIG1hdGVyaWFsLmNsZWFyY29hdEYwLCBtYXRlcmlhbC5jbGVhcmNvYXRGOTAsIGRvdE5WY2MgKTsKCQlvdXRnb2luZ0xpZ2h0ID0gb3V0Z29pbmdMaWdodCAqICggMS4wIC0gbWF0ZXJpYWwuY2xlYXJjb2F0ICogRmNjICkgKyAoIGNsZWFyY29hdFNwZWN1bGFyRGlyZWN0ICsgY2xlYXJjb2F0U3BlY3VsYXJJbmRpcmVjdCApICogbWF0ZXJpYWwuY2xlYXJjb2F0OwoJI2VuZGlmCgkjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Pgp9YCxtZXNodG9vbl92ZXJ0OmAjZGVmaW5lIFRPT04KdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxiYXRjaGluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+CnZvaWQgbWFpbigpIHsKCSNpbmNsdWRlIDx1dl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PgoJI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PgoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+Cgl2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejsKCSNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+CgkjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxmb2dfdmVydGV4Pgp9YCxtZXNodG9vbl9mcmFnOmAjZGVmaW5lIFRPT04KdW5pZm9ybSB2ZWMzIGRpZmZ1c2U7CnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTsKdW5pZm9ybSBmbG9hdCBvcGFjaXR5OwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8cGFja2luZz4KI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Z3JhZGllbnRtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YnNkZnM+CiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bGlnaHRzX3Rvb25fcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCVJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7Cgl2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlOwoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj4KCSNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz4KCSNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfdG9vbl9mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfYmVnaW4+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD4KCSNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD4KCXZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7CgkjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Pgp9YCxwb2ludHNfdmVydDpgdW5pZm9ybSBmbG9hdCBzaXplOwp1bmlmb3JtIGZsb2F0IHNjYWxlOwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PgojaWZkZWYgVVNFX1BPSU5UU19VVgoJdmFyeWluZyB2ZWMyIHZVdjsKCXVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTsKI2VuZGlmCnZvaWQgbWFpbigpIHsKCSNpZmRlZiBVU0VfUE9JTlRTX1VWCgkJdlV2ID0gKCB1dlRyYW5zZm9ybSAqIHZlYzMoIHV2LCAxICkgKS54eTsKCSNlbmRpZgoJI2luY2x1ZGUgPGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJZ2xfUG9pbnRTaXplID0gc2l6ZTsKCSNpZmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OCgkJYm9vbCBpc1BlcnNwZWN0aXZlID0gaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApOwoJCWlmICggaXNQZXJzcGVjdGl2ZSApIGdsX1BvaW50U2l6ZSAqPSAoIHNjYWxlIC8gLSBtdlBvc2l0aW9uLnogKTsKCSNlbmRpZgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD4KCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PgoJI2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD4KCSNpbmNsdWRlIDxmb2dfdmVydGV4Pgp9YCxwb2ludHNfZnJhZzpgdW5pZm9ybSB2ZWMzIGRpZmZ1c2U7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD4Kdm9pZCBtYWluKCkgewoJdmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PgoJdmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bWFwX3BhcnRpY2xlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+CglvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjsKCSNpbmNsdWRlIDxvcGFxdWVfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KCSNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD4KfWAsc2hhZG93X3ZlcnQ6YCNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxiYXRjaGluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PgoJI2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8Zm9nX3ZlcnRleD4KfWAsc2hhZG93X2ZyYWc6YHVuaWZvcm0gdmVjMyBjb2xvcjsKdW5pZm9ybSBmbG9hdCBvcGFjaXR5OwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8cGFja2luZz4KI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YnNkZnM+CiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHNoYWRvd21hc2tfcGFyc19mcmFnbWVudD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJZ2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IsIG9wYWNpdHkgKiAoIDEuMCAtIGdldFNoYWRvd01hc2soKSApICk7CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KCSNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+Cn1gLHNwcml0ZV92ZXJ0OmB1bmlmb3JtIGZsb2F0IHJvdGF0aW9uOwp1bmlmb3JtIHZlYzIgY2VudGVyOwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPHV2X3ZlcnRleD4KCXZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeFsgMyBdOwoJdmVjMiBzY2FsZSA9IHZlYzIoIGxlbmd0aCggbW9kZWxNYXRyaXhbIDAgXS54eXogKSwgbGVuZ3RoKCBtb2RlbE1hdHJpeFsgMSBdLnh5eiApICk7CgkjaWZuZGVmIFVTRV9TSVpFQVRURU5VQVRJT04KCQlib29sIGlzUGVyc3BlY3RpdmUgPSBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICk7CgkJaWYgKCBpc1BlcnNwZWN0aXZlICkgc2NhbGUgKj0gLSBtdlBvc2l0aW9uLno7CgkjZW5kaWYKCXZlYzIgYWxpZ25lZFBvc2l0aW9uID0gKCBwb3NpdGlvbi54eSAtICggY2VudGVyIC0gdmVjMiggMC41ICkgKSApICogc2NhbGU7Cgl2ZWMyIHJvdGF0ZWRQb3NpdGlvbjsKCXJvdGF0ZWRQb3NpdGlvbi54ID0gY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsKCXJvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsKCW12UG9zaXRpb24ueHkgKz0gcm90YXRlZFBvc2l0aW9uOwoJZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjsKCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KCSNpbmNsdWRlIDxmb2dfdmVydGV4Pgp9YCxzcHJpdGVfZnJhZzpgdW5pZm9ybSB2ZWMzIGRpZmZ1c2U7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCXZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApOwoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJb3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7CgkjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50Pgp9YH0sdGU9e2NvbW1vbjp7ZGlmZnVzZTp7dmFsdWU6bmV3IFZlKDE2Nzc3MjE1KX0sb3BhY2l0eTp7dmFsdWU6MX0sbWFwOnt2YWx1ZTpudWxsfSxtYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX0sYWxwaGFNYXA6e3ZhbHVlOm51bGx9LGFscGhhTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9LGFscGhhVGVzdDp7dmFsdWU6MH19LHNwZWN1bGFybWFwOntzcGVjdWxhck1hcDp7dmFsdWU6bnVsbH0sc3BlY3VsYXJNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX19LGVudm1hcDp7ZW52TWFwOnt2YWx1ZTpudWxsfSxlbnZNYXBSb3RhdGlvbjp7dmFsdWU6bmV3IGJlfSxmbGlwRW52TWFwOnt2YWx1ZTotMX0scmVmbGVjdGl2aXR5Ont2YWx1ZToxfSxpb3I6e3ZhbHVlOjEuNX0scmVmcmFjdGlvblJhdGlvOnt2YWx1ZTouOTh9fSxhb21hcDp7YW9NYXA6e3ZhbHVlOm51bGx9LGFvTWFwSW50ZW5zaXR5Ont2YWx1ZToxfSxhb01hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfX0sbGlnaHRtYXA6e2xpZ2h0TWFwOnt2YWx1ZTpudWxsfSxsaWdodE1hcEludGVuc2l0eTp7dmFsdWU6MX0sbGlnaHRNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX19LGJ1bXBtYXA6e2J1bXBNYXA6e3ZhbHVlOm51bGx9LGJ1bXBNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX0sYnVtcFNjYWxlOnt2YWx1ZToxfX0sbm9ybWFsbWFwOntub3JtYWxNYXA6e3ZhbHVlOm51bGx9LG5vcm1hbE1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfSxub3JtYWxTY2FsZTp7dmFsdWU6bmV3IFBlKDEsMSl9fSxkaXNwbGFjZW1lbnRtYXA6e2Rpc3BsYWNlbWVudE1hcDp7dmFsdWU6bnVsbH0sZGlzcGxhY2VtZW50TWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9LGRpc3BsYWNlbWVudFNjYWxlOnt2YWx1ZToxfSxkaXNwbGFjZW1lbnRCaWFzOnt2YWx1ZTowfX0sZW1pc3NpdmVtYXA6e2VtaXNzaXZlTWFwOnt2YWx1ZTpudWxsfSxlbWlzc2l2ZU1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfX0sbWV0YWxuZXNzbWFwOnttZXRhbG5lc3NNYXA6e3ZhbHVlOm51bGx9LG1ldGFsbmVzc01hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfX0scm91Z2huZXNzbWFwOntyb3VnaG5lc3NNYXA6e3ZhbHVlOm51bGx9LHJvdWdobmVzc01hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfX0sZ3JhZGllbnRtYXA6e2dyYWRpZW50TWFwOnt2YWx1ZTpudWxsfX0sZm9nOntmb2dEZW5zaXR5Ont2YWx1ZToyNWUtNX0sZm9nTmVhcjp7dmFsdWU6MX0sZm9nRmFyOnt2YWx1ZToyZTN9LGZvZ0NvbG9yOnt2YWx1ZTpuZXcgVmUoMTY3NzcyMTUpfX0sbGlnaHRzOnthbWJpZW50TGlnaHRDb2xvcjp7dmFsdWU6W119LGxpZ2h0UHJvYmU6e3ZhbHVlOltdfSxkaXJlY3Rpb25hbExpZ2h0czp7dmFsdWU6W10scHJvcGVydGllczp7ZGlyZWN0aW9uOnt9LGNvbG9yOnt9fX0sZGlyZWN0aW9uYWxMaWdodFNoYWRvd3M6e3ZhbHVlOltdLHByb3BlcnRpZXM6e3NoYWRvd0ludGVuc2l0eToxLHNoYWRvd0JpYXM6e30sc2hhZG93Tm9ybWFsQmlhczp7fSxzaGFkb3dSYWRpdXM6e30sc2hhZG93TWFwU2l6ZTp7fX19LGRpcmVjdGlvbmFsU2hhZG93TWFwOnt2YWx1ZTpbXX0sZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg6e3ZhbHVlOltdfSxzcG90TGlnaHRzOnt2YWx1ZTpbXSxwcm9wZXJ0aWVzOntjb2xvcjp7fSxwb3NpdGlvbjp7fSxkaXJlY3Rpb246e30sZGlzdGFuY2U6e30sY29uZUNvczp7fSxwZW51bWJyYUNvczp7fSxkZWNheTp7fX19LHNwb3RMaWdodFNoYWRvd3M6e3ZhbHVlOltdLHByb3BlcnRpZXM6e3NoYWRvd0ludGVuc2l0eToxLHNoYWRvd0JpYXM6e30sc2hhZG93Tm9ybWFsQmlhczp7fSxzaGFkb3dSYWRpdXM6e30sc2hhZG93TWFwU2l6ZTp7fX19LHNwb3RMaWdodE1hcDp7dmFsdWU6W119LHNwb3RTaGFkb3dNYXA6e3ZhbHVlOltdfSxzcG90TGlnaHRNYXRyaXg6e3ZhbHVlOltdfSxwb2ludExpZ2h0czp7dmFsdWU6W10scHJvcGVydGllczp7Y29sb3I6e30scG9zaXRpb246e30sZGVjYXk6e30sZGlzdGFuY2U6e319fSxwb2ludExpZ2h0U2hhZG93czp7dmFsdWU6W10scHJvcGVydGllczp7c2hhZG93SW50ZW5zaXR5OjEsc2hhZG93Qmlhczp7fSxzaGFkb3dOb3JtYWxCaWFzOnt9LHNoYWRvd1JhZGl1czp7fSxzaGFkb3dNYXBTaXplOnt9LHNoYWRvd0NhbWVyYU5lYXI6e30sc2hhZG93Q2FtZXJhRmFyOnt9fX0scG9pbnRTaGFkb3dNYXA6e3ZhbHVlOltdfSxwb2ludFNoYWRvd01hdHJpeDp7dmFsdWU6W119LGhlbWlzcGhlcmVMaWdodHM6e3ZhbHVlOltdLHByb3BlcnRpZXM6e2RpcmVjdGlvbjp7fSxza3lDb2xvcjp7fSxncm91bmRDb2xvcjp7fX19LHJlY3RBcmVhTGlnaHRzOnt2YWx1ZTpbXSxwcm9wZXJ0aWVzOntjb2xvcjp7fSxwb3NpdGlvbjp7fSx3aWR0aDp7fSxoZWlnaHQ6e319fSxsdGNfMTp7dmFsdWU6bnVsbH0sbHRjXzI6e3ZhbHVlOm51bGx9fSxwb2ludHM6e2RpZmZ1c2U6e3ZhbHVlOm5ldyBWZSgxNjc3NzIxNSl9LG9wYWNpdHk6e3ZhbHVlOjF9LHNpemU6e3ZhbHVlOjF9LHNjYWxlOnt2YWx1ZToxfSxtYXA6e3ZhbHVlOm51bGx9LGFscGhhTWFwOnt2YWx1ZTpudWxsfSxhbHBoYU1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfSxhbHBoYVRlc3Q6e3ZhbHVlOjB9LHV2VHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9fSxzcHJpdGU6e2RpZmZ1c2U6e3ZhbHVlOm5ldyBWZSgxNjc3NzIxNSl9LG9wYWNpdHk6e3ZhbHVlOjF9LGNlbnRlcjp7dmFsdWU6bmV3IFBlKC41LC41KX0scm90YXRpb246e3ZhbHVlOjB9LG1hcDp7dmFsdWU6bnVsbH0sbWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9LGFscGhhTWFwOnt2YWx1ZTpudWxsfSxhbHBoYU1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfSxhbHBoYVRlc3Q6e3ZhbHVlOjB9fX0senQ9e2Jhc2ljOnt1bmlmb3Jtczp4dChbdGUuY29tbW9uLHRlLnNwZWN1bGFybWFwLHRlLmVudm1hcCx0ZS5hb21hcCx0ZS5saWdodG1hcCx0ZS5mb2ddKSx2ZXJ0ZXhTaGFkZXI6RGUubWVzaGJhc2ljX3ZlcnQsZnJhZ21lbnRTaGFkZXI6RGUubWVzaGJhc2ljX2ZyYWd9LGxhbWJlcnQ6e3VuaWZvcm1zOnh0KFt0ZS5jb21tb24sdGUuc3BlY3VsYXJtYXAsdGUuZW52bWFwLHRlLmFvbWFwLHRlLmxpZ2h0bWFwLHRlLmVtaXNzaXZlbWFwLHRlLmJ1bXBtYXAsdGUubm9ybWFsbWFwLHRlLmRpc3BsYWNlbWVudG1hcCx0ZS5mb2csdGUubGlnaHRzLHtlbWlzc2l2ZTp7dmFsdWU6bmV3IFZlKDApfX1dKSx2ZXJ0ZXhTaGFkZXI6RGUubWVzaGxhbWJlcnRfdmVydCxmcmFnbWVudFNoYWRlcjpEZS5tZXNobGFtYmVydF9mcmFnfSxwaG9uZzp7dW5pZm9ybXM6eHQoW3RlLmNvbW1vbix0ZS5zcGVjdWxhcm1hcCx0ZS5lbnZtYXAsdGUuYW9tYXAsdGUubGlnaHRtYXAsdGUuZW1pc3NpdmVtYXAsdGUuYnVtcG1hcCx0ZS5ub3JtYWxtYXAsdGUuZGlzcGxhY2VtZW50bWFwLHRlLmZvZyx0ZS5saWdodHMse2VtaXNzaXZlOnt2YWx1ZTpuZXcgVmUoMCl9LHNwZWN1bGFyOnt2YWx1ZTpuZXcgVmUoMTExODQ4MSl9LHNoaW5pbmVzczp7dmFsdWU6MzB9fV0pLHZlcnRleFNoYWRlcjpEZS5tZXNocGhvbmdfdmVydCxmcmFnbWVudFNoYWRlcjpEZS5tZXNocGhvbmdfZnJhZ30sc3RhbmRhcmQ6e3VuaWZvcm1zOnh0KFt0ZS5jb21tb24sdGUuZW52bWFwLHRlLmFvbWFwLHRlLmxpZ2h0bWFwLHRlLmVtaXNzaXZlbWFwLHRlLmJ1bXBtYXAsdGUubm9ybWFsbWFwLHRlLmRpc3BsYWNlbWVudG1hcCx0ZS5yb3VnaG5lc3NtYXAsdGUubWV0YWxuZXNzbWFwLHRlLmZvZyx0ZS5saWdodHMse2VtaXNzaXZlOnt2YWx1ZTpuZXcgVmUoMCl9LHJvdWdobmVzczp7dmFsdWU6MX0sbWV0YWxuZXNzOnt2YWx1ZTowfSxlbnZNYXBJbnRlbnNpdHk6e3ZhbHVlOjF9fV0pLHZlcnRleFNoYWRlcjpEZS5tZXNocGh5c2ljYWxfdmVydCxmcmFnbWVudFNoYWRlcjpEZS5tZXNocGh5c2ljYWxfZnJhZ30sdG9vbjp7dW5pZm9ybXM6eHQoW3RlLmNvbW1vbix0ZS5hb21hcCx0ZS5saWdodG1hcCx0ZS5lbWlzc2l2ZW1hcCx0ZS5idW1wbWFwLHRlLm5vcm1hbG1hcCx0ZS5kaXNwbGFjZW1lbnRtYXAsdGUuZ3JhZGllbnRtYXAsdGUuZm9nLHRlLmxpZ2h0cyx7ZW1pc3NpdmU6e3ZhbHVlOm5ldyBWZSgwKX19XSksdmVydGV4U2hhZGVyOkRlLm1lc2h0b29uX3ZlcnQsZnJhZ21lbnRTaGFkZXI6RGUubWVzaHRvb25fZnJhZ30sbWF0Y2FwOnt1bmlmb3Jtczp4dChbdGUuY29tbW9uLHRlLmJ1bXBtYXAsdGUubm9ybWFsbWFwLHRlLmRpc3BsYWNlbWVudG1hcCx0ZS5mb2cse21hdGNhcDp7dmFsdWU6bnVsbH19XSksdmVydGV4U2hhZGVyOkRlLm1lc2htYXRjYXBfdmVydCxmcmFnbWVudFNoYWRlcjpEZS5tZXNobWF0Y2FwX2ZyYWd9LHBvaW50czp7dW5pZm9ybXM6eHQoW3RlLnBvaW50cyx0ZS5mb2ddKSx2ZXJ0ZXhTaGFkZXI6RGUucG9pbnRzX3ZlcnQsZnJhZ21lbnRTaGFkZXI6RGUucG9pbnRzX2ZyYWd9LGRhc2hlZDp7dW5pZm9ybXM6eHQoW3RlLmNvbW1vbix0ZS5mb2cse3NjYWxlOnt2YWx1ZToxfSxkYXNoU2l6ZTp7dmFsdWU6MX0sdG90YWxTaXplOnt2YWx1ZToyfX1dKSx2ZXJ0ZXhTaGFkZXI6RGUubGluZWRhc2hlZF92ZXJ0LGZyYWdtZW50U2hhZGVyOkRlLmxpbmVkYXNoZWRfZnJhZ30sZGVwdGg6e3VuaWZvcm1zOnh0KFt0ZS5jb21tb24sdGUuZGlzcGxhY2VtZW50bWFwXSksdmVydGV4U2hhZGVyOkRlLmRlcHRoX3ZlcnQsZnJhZ21lbnRTaGFkZXI6RGUuZGVwdGhfZnJhZ30sbm9ybWFsOnt1bmlmb3Jtczp4dChbdGUuY29tbW9uLHRlLmJ1bXBtYXAsdGUubm9ybWFsbWFwLHRlLmRpc3BsYWNlbWVudG1hcCx7b3BhY2l0eTp7dmFsdWU6MX19XSksdmVydGV4U2hhZGVyOkRlLm1lc2hub3JtYWxfdmVydCxmcmFnbWVudFNoYWRlcjpEZS5tZXNobm9ybWFsX2ZyYWd9LHNwcml0ZTp7dW5pZm9ybXM6eHQoW3RlLnNwcml0ZSx0ZS5mb2ddKSx2ZXJ0ZXhTaGFkZXI6RGUuc3ByaXRlX3ZlcnQsZnJhZ21lbnRTaGFkZXI6RGUuc3ByaXRlX2ZyYWd9LGJhY2tncm91bmQ6e3VuaWZvcm1zOnt1dlRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfSx0MkQ6e3ZhbHVlOm51bGx9LGJhY2tncm91bmRJbnRlbnNpdHk6e3ZhbHVlOjF9fSx2ZXJ0ZXhTaGFkZXI6RGUuYmFja2dyb3VuZF92ZXJ0LGZyYWdtZW50U2hhZGVyOkRlLmJhY2tncm91bmRfZnJhZ30sYmFja2dyb3VuZEN1YmU6e3VuaWZvcm1zOntlbnZNYXA6e3ZhbHVlOm51bGx9LGZsaXBFbnZNYXA6e3ZhbHVlOi0xfSxiYWNrZ3JvdW5kQmx1cnJpbmVzczp7dmFsdWU6MH0sYmFja2dyb3VuZEludGVuc2l0eTp7dmFsdWU6MX0sYmFja2dyb3VuZFJvdGF0aW9uOnt2YWx1ZTpuZXcgYmV9fSx2ZXJ0ZXhTaGFkZXI6RGUuYmFja2dyb3VuZEN1YmVfdmVydCxmcmFnbWVudFNoYWRlcjpEZS5iYWNrZ3JvdW5kQ3ViZV9mcmFnfSxjdWJlOnt1bmlmb3Jtczp7dEN1YmU6e3ZhbHVlOm51bGx9LHRGbGlwOnt2YWx1ZTotMX0sb3BhY2l0eTp7dmFsdWU6MX19LHZlcnRleFNoYWRlcjpEZS5jdWJlX3ZlcnQsZnJhZ21lbnRTaGFkZXI6RGUuY3ViZV9mcmFnfSxlcXVpcmVjdDp7dW5pZm9ybXM6e3RFcXVpcmVjdDp7dmFsdWU6bnVsbH19LHZlcnRleFNoYWRlcjpEZS5lcXVpcmVjdF92ZXJ0LGZyYWdtZW50U2hhZGVyOkRlLmVxdWlyZWN0X2ZyYWd9LGRpc3RhbmNlUkdCQTp7dW5pZm9ybXM6eHQoW3RlLmNvbW1vbix0ZS5kaXNwbGFjZW1lbnRtYXAse3JlZmVyZW5jZVBvc2l0aW9uOnt2YWx1ZTpuZXcgT30sbmVhckRpc3RhbmNlOnt2YWx1ZToxfSxmYXJEaXN0YW5jZTp7dmFsdWU6MWUzfX1dKSx2ZXJ0ZXhTaGFkZXI6RGUuZGlzdGFuY2VSR0JBX3ZlcnQsZnJhZ21lbnRTaGFkZXI6RGUuZGlzdGFuY2VSR0JBX2ZyYWd9LHNoYWRvdzp7dW5pZm9ybXM6eHQoW3RlLmxpZ2h0cyx0ZS5mb2cse2NvbG9yOnt2YWx1ZTpuZXcgVmUoMCl9LG9wYWNpdHk6e3ZhbHVlOjF9fV0pLHZlcnRleFNoYWRlcjpEZS5zaGFkb3dfdmVydCxmcmFnbWVudFNoYWRlcjpEZS5zaGFkb3dfZnJhZ319O3p0LnBoeXNpY2FsPXt1bmlmb3Jtczp4dChbenQuc3RhbmRhcmQudW5pZm9ybXMse2NsZWFyY29hdDp7dmFsdWU6MH0sY2xlYXJjb2F0TWFwOnt2YWx1ZTpudWxsfSxjbGVhcmNvYXRNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX0sY2xlYXJjb2F0Tm9ybWFsTWFwOnt2YWx1ZTpudWxsfSxjbGVhcmNvYXROb3JtYWxNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX0sY2xlYXJjb2F0Tm9ybWFsU2NhbGU6e3ZhbHVlOm5ldyBQZSgxLDEpfSxjbGVhcmNvYXRSb3VnaG5lc3M6e3ZhbHVlOjB9LGNsZWFyY29hdFJvdWdobmVzc01hcDp7dmFsdWU6bnVsbH0sY2xlYXJjb2F0Um91Z2huZXNzTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9LGRpc3BlcnNpb246e3ZhbHVlOjB9LGlyaWRlc2NlbmNlOnt2YWx1ZTowfSxpcmlkZXNjZW5jZU1hcDp7dmFsdWU6bnVsbH0saXJpZGVzY2VuY2VNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX0saXJpZGVzY2VuY2VJT1I6e3ZhbHVlOjEuM30saXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtOnt2YWx1ZToxMDB9LGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTp7dmFsdWU6NDAwfSxpcmlkZXNjZW5jZVRoaWNrbmVzc01hcDp7dmFsdWU6bnVsbH0saXJpZGVzY2VuY2VUaGlja25lc3NNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX0sc2hlZW46e3ZhbHVlOjB9LHNoZWVuQ29sb3I6e3ZhbHVlOm5ldyBWZSgwKX0sc2hlZW5Db2xvck1hcDp7dmFsdWU6bnVsbH0sc2hlZW5Db2xvck1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfSxzaGVlblJvdWdobmVzczp7dmFsdWU6MX0sc2hlZW5Sb3VnaG5lc3NNYXA6e3ZhbHVlOm51bGx9LHNoZWVuUm91Z2huZXNzTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgYmV9LHRyYW5zbWlzc2lvbjp7dmFsdWU6MH0sdHJhbnNtaXNzaW9uTWFwOnt2YWx1ZTpudWxsfSx0cmFuc21pc3Npb25NYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX0sdHJhbnNtaXNzaW9uU2FtcGxlclNpemU6e3ZhbHVlOm5ldyBQZX0sdHJhbnNtaXNzaW9uU2FtcGxlck1hcDp7dmFsdWU6bnVsbH0sdGhpY2tuZXNzOnt2YWx1ZTowfSx0aGlja25lc3NNYXA6e3ZhbHVlOm51bGx9LHRoaWNrbmVzc01hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfSxhdHRlbnVhdGlvbkRpc3RhbmNlOnt2YWx1ZTowfSxhdHRlbnVhdGlvbkNvbG9yOnt2YWx1ZTpuZXcgVmUoMCl9LHNwZWN1bGFyQ29sb3I6e3ZhbHVlOm5ldyBWZSgxLDEsMSl9LHNwZWN1bGFyQ29sb3JNYXA6e3ZhbHVlOm51bGx9LHNwZWN1bGFyQ29sb3JNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX0sc3BlY3VsYXJJbnRlbnNpdHk6e3ZhbHVlOjF9LHNwZWN1bGFySW50ZW5zaXR5TWFwOnt2YWx1ZTpudWxsfSxzcGVjdWxhckludGVuc2l0eU1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGJlfSxhbmlzb3Ryb3B5VmVjdG9yOnt2YWx1ZTpuZXcgUGV9LGFuaXNvdHJvcHlNYXA6e3ZhbHVlOm51bGx9LGFuaXNvdHJvcHlNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBiZX19XSksdmVydGV4U2hhZGVyOkRlLm1lc2hwaHlzaWNhbF92ZXJ0LGZyYWdtZW50U2hhZGVyOkRlLm1lc2hwaHlzaWNhbF9mcmFnfTtjb25zdCB5aT17cjowLGI6MCxnOjB9LHBuPW5ldyBYdCxCbD1uZXcgc3Q7ZnVuY3Rpb24gemwoaSxlLHQsbixyLHMsYSl7Y29uc3Qgbz1uZXcgVmUoMCk7bGV0IGw9cz09PSEwPzA6MSxjLGgsZD1udWxsLGY9MCxwPW51bGw7ZnVuY3Rpb24gXyhUKXtsZXQgeT1ULmlzU2NlbmU9PT0hMD9ULmJhY2tncm91bmQ6bnVsbDtyZXR1cm4geSYmeS5pc1RleHR1cmUmJih5PShULmJhY2tncm91bmRCbHVycmluZXNzPjA/dDplKS5nZXQoeSkpLHl9ZnVuY3Rpb24geChUKXtsZXQgeT0hMTtjb25zdCBnPV8oVCk7Zz09PW51bGw/dShvLGwpOmcmJmcuaXNDb2xvciYmKHUoZywxKSx5PSEwKTtjb25zdCBQPWkueHIuZ2V0RW52aXJvbm1lbnRCbGVuZE1vZGUoKTtQPT09ImFkZGl0aXZlIj9uLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoMCwwLDAsMSxhKTpQPT09ImFscGhhLWJsZW5kIiYmbi5idWZmZXJzLmNvbG9yLnNldENsZWFyKDAsMCwwLDAsYSksKGkuYXV0b0NsZWFyfHx5KSYmKG4uYnVmZmVycy5kZXB0aC5zZXRUZXN0KCEwKSxuLmJ1ZmZlcnMuZGVwdGguc2V0TWFzayghMCksbi5idWZmZXJzLmNvbG9yLnNldE1hc2soITApLGkuY2xlYXIoaS5hdXRvQ2xlYXJDb2xvcixpLmF1dG9DbGVhckRlcHRoLGkuYXV0b0NsZWFyU3RlbmNpbCkpfWZ1bmN0aW9uIG0oVCx5KXtjb25zdCBnPV8oeSk7ZyYmKGcuaXNDdWJlVGV4dHVyZXx8Zy5tYXBwaW5nPT09MzA2KT8oaD09PXZvaWQgMCYmKGg9bmV3IHR0KG5ldyBRbigxLDEsMSksbmV3IGx0KHtuYW1lOiJCYWNrZ3JvdW5kQ3ViZU1hdGVyaWFsIix1bmlmb3JtczpGbih6dC5iYWNrZ3JvdW5kQ3ViZS51bmlmb3JtcyksdmVydGV4U2hhZGVyOnp0LmJhY2tncm91bmRDdWJlLnZlcnRleFNoYWRlcixmcmFnbWVudFNoYWRlcjp6dC5iYWNrZ3JvdW5kQ3ViZS5mcmFnbWVudFNoYWRlcixzaWRlOjEsZGVwdGhUZXN0OiExLGRlcHRoV3JpdGU6ITEsZm9nOiExfSkpLGguZ2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKCJub3JtYWwiKSxoLmdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSgidXYiKSxoLm9uQmVmb3JlUmVuZGVyPWZ1bmN0aW9uKFAsdyxiKXt0aGlzLm1hdHJpeFdvcmxkLmNvcHlQb3NpdGlvbihiLm1hdHJpeFdvcmxkKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGgubWF0ZXJpYWwsImVudk1hcCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLmVudk1hcC52YWx1ZX19KSxyLnVwZGF0ZShoKSkscG4uY29weSh5LmJhY2tncm91bmRSb3RhdGlvbikscG4ueCo9LTEscG4ueSo9LTEscG4ueio9LTEsZy5pc0N1YmVUZXh0dXJlJiZnLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT09PSExJiYocG4ueSo9LTEscG4ueio9LTEpLGgubWF0ZXJpYWwudW5pZm9ybXMuZW52TWFwLnZhbHVlPWcsaC5tYXRlcmlhbC51bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlPWcuaXNDdWJlVGV4dHVyZSYmZy5pc1JlbmRlclRhcmdldFRleHR1cmU9PT0hMT8tMToxLGgubWF0ZXJpYWwudW5pZm9ybXMuYmFja2dyb3VuZEJsdXJyaW5lc3MudmFsdWU9eS5iYWNrZ3JvdW5kQmx1cnJpbmVzcyxoLm1hdGVyaWFsLnVuaWZvcm1zLmJhY2tncm91bmRJbnRlbnNpdHkudmFsdWU9eS5iYWNrZ3JvdW5kSW50ZW5zaXR5LGgubWF0ZXJpYWwudW5pZm9ybXMuYmFja2dyb3VuZFJvdGF0aW9uLnZhbHVlLnNldEZyb21NYXRyaXg0KEJsLm1ha2VSb3RhdGlvbkZyb21FdWxlcihwbikpLGgubWF0ZXJpYWwudG9uZU1hcHBlZD1CZS5nZXRUcmFuc2ZlcihnLmNvbG9yU3BhY2UpIT09cWUsKGQhPT1nfHxmIT09Zy52ZXJzaW9ufHxwIT09aS50b25lTWFwcGluZykmJihoLm1hdGVyaWFsLm5lZWRzVXBkYXRlPSEwLGQ9ZyxmPWcudmVyc2lvbixwPWkudG9uZU1hcHBpbmcpLGgubGF5ZXJzLmVuYWJsZUFsbCgpLFQudW5zaGlmdChoLGguZ2VvbWV0cnksaC5tYXRlcmlhbCwwLDAsbnVsbCkpOmcmJmcuaXNUZXh0dXJlJiYoYz09PXZvaWQgMCYmKGM9bmV3IHR0KG5ldyBldCgyLDIpLG5ldyBsdCh7bmFtZToiQmFja2dyb3VuZE1hdGVyaWFsIix1bmlmb3JtczpGbih6dC5iYWNrZ3JvdW5kLnVuaWZvcm1zKSx2ZXJ0ZXhTaGFkZXI6enQuYmFja2dyb3VuZC52ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXI6enQuYmFja2dyb3VuZC5mcmFnbWVudFNoYWRlcixzaWRlOjAsZGVwdGhUZXN0OiExLGRlcHRoV3JpdGU6ITEsZm9nOiExfSkpLGMuZ2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKCJub3JtYWwiKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYy5tYXRlcmlhbCwibWFwIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMudDJELnZhbHVlfX0pLHIudXBkYXRlKGMpKSxjLm1hdGVyaWFsLnVuaWZvcm1zLnQyRC52YWx1ZT1nLGMubWF0ZXJpYWwudW5pZm9ybXMuYmFja2dyb3VuZEludGVuc2l0eS52YWx1ZT15LmJhY2tncm91bmRJbnRlbnNpdHksYy5tYXRlcmlhbC50b25lTWFwcGVkPUJlLmdldFRyYW5zZmVyKGcuY29sb3JTcGFjZSkhPT1xZSxnLm1hdHJpeEF1dG9VcGRhdGU9PT0hMCYmZy51cGRhdGVNYXRyaXgoKSxjLm1hdGVyaWFsLnVuaWZvcm1zLnV2VHJhbnNmb3JtLnZhbHVlLmNvcHkoZy5tYXRyaXgpLChkIT09Z3x8ZiE9PWcudmVyc2lvbnx8cCE9PWkudG9uZU1hcHBpbmcpJiYoYy5tYXRlcmlhbC5uZWVkc1VwZGF0ZT0hMCxkPWcsZj1nLnZlcnNpb24scD1pLnRvbmVNYXBwaW5nKSxjLmxheWVycy5lbmFibGVBbGwoKSxULnVuc2hpZnQoYyxjLmdlb21ldHJ5LGMubWF0ZXJpYWwsMCwwLG51bGwpKX1mdW5jdGlvbiB1KFQseSl7VC5nZXRSR0IoeWksWXIoaSkpLG4uYnVmZmVycy5jb2xvci5zZXRDbGVhcih5aS5yLHlpLmcseWkuYix5LGEpfXJldHVybntnZXRDbGVhckNvbG9yOmZ1bmN0aW9uKCl7cmV0dXJuIG99LHNldENsZWFyQ29sb3I6ZnVuY3Rpb24oVCx5PTEpe28uc2V0KFQpLGw9eSx1KG8sbCl9LGdldENsZWFyQWxwaGE6ZnVuY3Rpb24oKXtyZXR1cm4gbH0sc2V0Q2xlYXJBbHBoYTpmdW5jdGlvbihUKXtsPVQsdShvLGwpfSxyZW5kZXI6eCxhZGRUb1JlbmRlckxpc3Q6bX19ZnVuY3Rpb24gR2woaSxlKXtjb25zdCB0PWkuZ2V0UGFyYW1ldGVyKGkuTUFYX1ZFUlRFWF9BVFRSSUJTKSxuPXt9LHI9ZihudWxsKTtsZXQgcz1yLGE9ITE7ZnVuY3Rpb24gbyhTLFIscSx6LFcpe2xldCBaPSExO2NvbnN0IFY9ZCh6LHEsUik7cyE9PVYmJihzPVYsYyhzLm9iamVjdCkpLFo9cChTLHoscSxXKSxaJiZfKFMseixxLFcpLFchPT1udWxsJiZlLnVwZGF0ZShXLGkuRUxFTUVOVF9BUlJBWV9CVUZGRVIpLChafHxhKSYmKGE9ITEsZyhTLFIscSx6KSxXIT09bnVsbCYmaS5iaW5kQnVmZmVyKGkuRUxFTUVOVF9BUlJBWV9CVUZGRVIsZS5nZXQoVykuYnVmZmVyKSl9ZnVuY3Rpb24gbCgpe3JldHVybiBpLmNyZWF0ZVZlcnRleEFycmF5KCl9ZnVuY3Rpb24gYyhTKXtyZXR1cm4gaS5iaW5kVmVydGV4QXJyYXkoUyl9ZnVuY3Rpb24gaChTKXtyZXR1cm4gaS5kZWxldGVWZXJ0ZXhBcnJheShTKX1mdW5jdGlvbiBkKFMsUixxKXtjb25zdCB6PXEud2lyZWZyYW1lPT09ITA7bGV0IFc9bltTLmlkXTtXPT09dm9pZCAwJiYoVz17fSxuW1MuaWRdPVcpO2xldCBaPVdbUi5pZF07Wj09PXZvaWQgMCYmKFo9e30sV1tSLmlkXT1aKTtsZXQgVj1aW3pdO3JldHVybiBWPT09dm9pZCAwJiYoVj1mKGwoKSksWlt6XT1WKSxWfWZ1bmN0aW9uIGYoUyl7Y29uc3QgUj1bXSxxPVtdLHo9W107Zm9yKGxldCBXPTA7Vzx0O1crKylSW1ddPTAscVtXXT0wLHpbV109MDtyZXR1cm57Z2VvbWV0cnk6bnVsbCxwcm9ncmFtOm51bGwsd2lyZWZyYW1lOiExLG5ld0F0dHJpYnV0ZXM6UixlbmFibGVkQXR0cmlidXRlczpxLGF0dHJpYnV0ZURpdmlzb3JzOnosb2JqZWN0OlMsYXR0cmlidXRlczp7fSxpbmRleDpudWxsfX1mdW5jdGlvbiBwKFMsUixxLHope2NvbnN0IFc9cy5hdHRyaWJ1dGVzLFo9Ui5hdHRyaWJ1dGVzO2xldCBWPTA7Y29uc3QgUT1xLmdldEF0dHJpYnV0ZXMoKTtmb3IoY29uc3QgSCBpbiBRKWlmKFFbSF0ubG9jYXRpb24+PTApe2NvbnN0IGNlPVdbSF07bGV0IHhlPVpbSF07aWYoeGU9PT12b2lkIDAmJihIPT09Imluc3RhbmNlTWF0cml4IiYmUy5pbnN0YW5jZU1hdHJpeCYmKHhlPVMuaW5zdGFuY2VNYXRyaXgpLEg9PT0iaW5zdGFuY2VDb2xvciImJlMuaW5zdGFuY2VDb2xvciYmKHhlPVMuaW5zdGFuY2VDb2xvcikpLGNlPT09dm9pZCAwfHxjZS5hdHRyaWJ1dGUhPT14ZXx8eGUmJmNlLmRhdGEhPT14ZS5kYXRhKXJldHVybiEwO1YrK31yZXR1cm4gcy5hdHRyaWJ1dGVzTnVtIT09Vnx8cy5pbmRleCE9PXp9ZnVuY3Rpb24gXyhTLFIscSx6KXtjb25zdCBXPXt9LFo9Ui5hdHRyaWJ1dGVzO2xldCBWPTA7Y29uc3QgUT1xLmdldEF0dHJpYnV0ZXMoKTtmb3IoY29uc3QgSCBpbiBRKWlmKFFbSF0ubG9jYXRpb24+PTApe2xldCBjZT1aW0hdO2NlPT09dm9pZCAwJiYoSD09PSJpbnN0YW5jZU1hdHJpeCImJlMuaW5zdGFuY2VNYXRyaXgmJihjZT1TLmluc3RhbmNlTWF0cml4KSxIPT09Imluc3RhbmNlQ29sb3IiJiZTLmluc3RhbmNlQ29sb3ImJihjZT1TLmluc3RhbmNlQ29sb3IpKTtjb25zdCB4ZT17fTt4ZS5hdHRyaWJ1dGU9Y2UsY2UmJmNlLmRhdGEmJih4ZS5kYXRhPWNlLmRhdGEpLFdbSF09eGUsVisrfXMuYXR0cmlidXRlcz1XLHMuYXR0cmlidXRlc051bT1WLHMuaW5kZXg9en1mdW5jdGlvbiB4KCl7Y29uc3QgUz1zLm5ld0F0dHJpYnV0ZXM7Zm9yKGxldCBSPTAscT1TLmxlbmd0aDtSPHE7UisrKVNbUl09MH1mdW5jdGlvbiBtKFMpe3UoUywwKX1mdW5jdGlvbiB1KFMsUil7Y29uc3QgcT1zLm5ld0F0dHJpYnV0ZXMsej1zLmVuYWJsZWRBdHRyaWJ1dGVzLFc9cy5hdHRyaWJ1dGVEaXZpc29ycztxW1NdPTEseltTXT09PTAmJihpLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KFMpLHpbU109MSksV1tTXSE9PVImJihpLnZlcnRleEF0dHJpYkRpdmlzb3IoUyxSKSxXW1NdPVIpfWZ1bmN0aW9uIFQoKXtjb25zdCBTPXMubmV3QXR0cmlidXRlcyxSPXMuZW5hYmxlZEF0dHJpYnV0ZXM7Zm9yKGxldCBxPTAsej1SLmxlbmd0aDtxPHo7cSsrKVJbcV0hPT1TW3FdJiYoaS5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkocSksUltxXT0wKX1mdW5jdGlvbiB5KFMsUixxLHosVyxaLFYpe1Y9PT0hMD9pLnZlcnRleEF0dHJpYklQb2ludGVyKFMsUixxLFcsWik6aS52ZXJ0ZXhBdHRyaWJQb2ludGVyKFMsUixxLHosVyxaKX1mdW5jdGlvbiBnKFMsUixxLHope3goKTtjb25zdCBXPXouYXR0cmlidXRlcyxaPXEuZ2V0QXR0cmlidXRlcygpLFY9Ui5kZWZhdWx0QXR0cmlidXRlVmFsdWVzO2Zvcihjb25zdCBRIGluIFope2NvbnN0IEg9WltRXTtpZihILmxvY2F0aW9uPj0wKXtsZXQgaWU9V1tRXTtpZihpZT09PXZvaWQgMCYmKFE9PT0iaW5zdGFuY2VNYXRyaXgiJiZTLmluc3RhbmNlTWF0cml4JiYoaWU9Uy5pbnN0YW5jZU1hdHJpeCksUT09PSJpbnN0YW5jZUNvbG9yIiYmUy5pbnN0YW5jZUNvbG9yJiYoaWU9Uy5pbnN0YW5jZUNvbG9yKSksaWUhPT12b2lkIDApe2NvbnN0IGNlPWllLm5vcm1hbGl6ZWQseGU9aWUuaXRlbVNpemUsVWU9ZS5nZXQoaWUpO2lmKFVlPT09dm9pZCAwKWNvbnRpbnVlO2NvbnN0IFllPVVlLmJ1ZmZlcixYPVVlLnR5cGUsZWU9VWUuYnl0ZXNQZXJFbGVtZW50LGdlPVg9PT1pLklOVHx8WD09PWkuVU5TSUdORURfSU5UfHxpZS5ncHVUeXBlPT09MTAxMztpZihpZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKXtjb25zdCByZT1pZS5kYXRhLHllPXJlLnN0cmlkZSx3ZT1pZS5vZmZzZXQ7aWYocmUuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcil7Zm9yKGxldCBGZT0wO0ZlPEgubG9jYXRpb25TaXplO0ZlKyspdShILmxvY2F0aW9uK0ZlLHJlLm1lc2hQZXJBdHRyaWJ1dGUpO1MuaXNJbnN0YW5jZWRNZXNoIT09ITAmJnouX21heEluc3RhbmNlQ291bnQ9PT12b2lkIDAmJih6Ll9tYXhJbnN0YW5jZUNvdW50PXJlLm1lc2hQZXJBdHRyaWJ1dGUqcmUuY291bnQpfWVsc2UgZm9yKGxldCBGZT0wO0ZlPEgubG9jYXRpb25TaXplO0ZlKyspbShILmxvY2F0aW9uK0ZlKTtpLmJpbmRCdWZmZXIoaS5BUlJBWV9CVUZGRVIsWWUpO2ZvcihsZXQgRmU9MDtGZTxILmxvY2F0aW9uU2l6ZTtGZSsrKXkoSC5sb2NhdGlvbitGZSx4ZS9ILmxvY2F0aW9uU2l6ZSxYLGNlLHllKmVlLCh3ZSt4ZS9ILmxvY2F0aW9uU2l6ZSpGZSkqZWUsZ2UpfWVsc2V7aWYoaWUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUpe2ZvcihsZXQgcmU9MDtyZTxILmxvY2F0aW9uU2l6ZTtyZSsrKXUoSC5sb2NhdGlvbityZSxpZS5tZXNoUGVyQXR0cmlidXRlKTtTLmlzSW5zdGFuY2VkTWVzaCE9PSEwJiZ6Ll9tYXhJbnN0YW5jZUNvdW50PT09dm9pZCAwJiYoei5fbWF4SW5zdGFuY2VDb3VudD1pZS5tZXNoUGVyQXR0cmlidXRlKmllLmNvdW50KX1lbHNlIGZvcihsZXQgcmU9MDtyZTxILmxvY2F0aW9uU2l6ZTtyZSsrKW0oSC5sb2NhdGlvbityZSk7aS5iaW5kQnVmZmVyKGkuQVJSQVlfQlVGRkVSLFllKTtmb3IobGV0IHJlPTA7cmU8SC5sb2NhdGlvblNpemU7cmUrKyl5KEgubG9jYXRpb24rcmUseGUvSC5sb2NhdGlvblNpemUsWCxjZSx4ZSplZSx4ZS9ILmxvY2F0aW9uU2l6ZSpyZSplZSxnZSl9fWVsc2UgaWYoViE9PXZvaWQgMCl7Y29uc3QgY2U9VltRXTtpZihjZSE9PXZvaWQgMClzd2l0Y2goY2UubGVuZ3RoKXtjYXNlIDI6aS52ZXJ0ZXhBdHRyaWIyZnYoSC5sb2NhdGlvbixjZSk7YnJlYWs7Y2FzZSAzOmkudmVydGV4QXR0cmliM2Z2KEgubG9jYXRpb24sY2UpO2JyZWFrO2Nhc2UgNDppLnZlcnRleEF0dHJpYjRmdihILmxvY2F0aW9uLGNlKTticmVhaztkZWZhdWx0OmkudmVydGV4QXR0cmliMWZ2KEgubG9jYXRpb24sY2UpfX19fVQoKX1mdW5jdGlvbiBQKCl7RigpO2Zvcihjb25zdCBTIGluIG4pe2NvbnN0IFI9bltTXTtmb3IoY29uc3QgcSBpbiBSKXtjb25zdCB6PVJbcV07Zm9yKGNvbnN0IFcgaW4geiloKHpbV10ub2JqZWN0KSxkZWxldGUgeltXXTtkZWxldGUgUltxXX1kZWxldGUgbltTXX19ZnVuY3Rpb24gdyhTKXtpZihuW1MuaWRdPT09dm9pZCAwKXJldHVybjtjb25zdCBSPW5bUy5pZF07Zm9yKGNvbnN0IHEgaW4gUil7Y29uc3Qgej1SW3FdO2Zvcihjb25zdCBXIGluIHopaCh6W1ddLm9iamVjdCksZGVsZXRlIHpbV107ZGVsZXRlIFJbcV19ZGVsZXRlIG5bUy5pZF19ZnVuY3Rpb24gYihTKXtmb3IoY29uc3QgUiBpbiBuKXtjb25zdCBxPW5bUl07aWYocVtTLmlkXT09PXZvaWQgMCljb250aW51ZTtjb25zdCB6PXFbUy5pZF07Zm9yKGNvbnN0IFcgaW4geiloKHpbV10ub2JqZWN0KSxkZWxldGUgeltXXTtkZWxldGUgcVtTLmlkXX19ZnVuY3Rpb24gRigpe0UoKSxhPSEwLHMhPT1yJiYocz1yLGMocy5vYmplY3QpKX1mdW5jdGlvbiBFKCl7ci5nZW9tZXRyeT1udWxsLHIucHJvZ3JhbT1udWxsLHIud2lyZWZyYW1lPSExfXJldHVybntzZXR1cDpvLHJlc2V0OkYscmVzZXREZWZhdWx0U3RhdGU6RSxkaXNwb3NlOlAscmVsZWFzZVN0YXRlc09mR2VvbWV0cnk6dyxyZWxlYXNlU3RhdGVzT2ZQcm9ncmFtOmIsaW5pdEF0dHJpYnV0ZXM6eCxlbmFibGVBdHRyaWJ1dGU6bSxkaXNhYmxlVW51c2VkQXR0cmlidXRlczpUfX1mdW5jdGlvbiBIbChpLGUsdCl7bGV0IG47ZnVuY3Rpb24gcihjKXtuPWN9ZnVuY3Rpb24gcyhjLGgpe2kuZHJhd0FycmF5cyhuLGMsaCksdC51cGRhdGUoaCxuLDEpfWZ1bmN0aW9uIGEoYyxoLGQpe2QhPT0wJiYoaS5kcmF3QXJyYXlzSW5zdGFuY2VkKG4sYyxoLGQpLHQudXBkYXRlKGgsbixkKSl9ZnVuY3Rpb24gbyhjLGgsZCl7aWYoZD09PTApcmV0dXJuO2UuZ2V0KCJXRUJHTF9tdWx0aV9kcmF3IikubXVsdGlEcmF3QXJyYXlzV0VCR0wobixjLDAsaCwwLGQpO2xldCBwPTA7Zm9yKGxldCBfPTA7XzxkO18rKylwKz1oW19dO3QudXBkYXRlKHAsbiwxKX1mdW5jdGlvbiBsKGMsaCxkLGYpe2lmKGQ9PT0wKXJldHVybjtjb25zdCBwPWUuZ2V0KCJXRUJHTF9tdWx0aV9kcmF3Iik7aWYocD09PW51bGwpZm9yKGxldCBfPTA7XzxjLmxlbmd0aDtfKyspYShjW19dLGhbX10sZltfXSk7ZWxzZXtwLm11bHRpRHJhd0FycmF5c0luc3RhbmNlZFdFQkdMKG4sYywwLGgsMCxmLDAsZCk7bGV0IF89MDtmb3IobGV0IHg9MDt4PGQ7eCsrKV8rPWhbeF0qZlt4XTt0LnVwZGF0ZShfLG4sMSl9fXRoaXMuc2V0TW9kZT1yLHRoaXMucmVuZGVyPXMsdGhpcy5yZW5kZXJJbnN0YW5jZXM9YSx0aGlzLnJlbmRlck11bHRpRHJhdz1vLHRoaXMucmVuZGVyTXVsdGlEcmF3SW5zdGFuY2VzPWx9ZnVuY3Rpb24gVmwoaSxlLHQsbil7bGV0IHI7ZnVuY3Rpb24gcygpe2lmKHIhPT12b2lkIDApcmV0dXJuIHI7aWYoZS5oYXMoIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyIpPT09ITApe2NvbnN0IGI9ZS5nZXQoIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyIpO3I9aS5nZXRQYXJhbWV0ZXIoYi5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQpfWVsc2Ugcj0wO3JldHVybiByfWZ1bmN0aW9uIGEoYil7cmV0dXJuIShiIT09MTAyMyYmbi5jb252ZXJ0KGIpIT09aS5nZXRQYXJhbWV0ZXIoaS5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX0ZPUk1BVCkpfWZ1bmN0aW9uIG8oYil7Y29uc3QgRj1iPT09MTAxNiYmKGUuaGFzKCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQiKXx8ZS5oYXMoIkVYVF9jb2xvcl9idWZmZXJfZmxvYXQiKSk7cmV0dXJuIShiIT09MTAwOSYmbi5jb252ZXJ0KGIpIT09aS5nZXRQYXJhbWV0ZXIoaS5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX1RZUEUpJiZiIT09MTAxNSYmIUYpfWZ1bmN0aW9uIGwoYil7aWYoYj09PSJoaWdocCIpe2lmKGkuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGkuVkVSVEVYX1NIQURFUixpLkhJR0hfRkxPQVQpLnByZWNpc2lvbj4wJiZpLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChpLkZSQUdNRU5UX1NIQURFUixpLkhJR0hfRkxPQVQpLnByZWNpc2lvbj4wKXJldHVybiJoaWdocCI7Yj0ibWVkaXVtcCJ9cmV0dXJuIGI9PT0ibWVkaXVtcCImJmkuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGkuVkVSVEVYX1NIQURFUixpLk1FRElVTV9GTE9BVCkucHJlY2lzaW9uPjAmJmkuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGkuRlJBR01FTlRfU0hBREVSLGkuTUVESVVNX0ZMT0FUKS5wcmVjaXNpb24+MD8ibWVkaXVtcCI6Imxvd3AifWxldCBjPXQucHJlY2lzaW9uIT09dm9pZCAwP3QucHJlY2lzaW9uOiJoaWdocCI7Y29uc3QgaD1sKGMpO2ghPT1jJiYoY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiIsYywibm90IHN1cHBvcnRlZCwgdXNpbmciLGgsImluc3RlYWQuIiksYz1oKTtjb25zdCBkPXQubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcj09PSEwLGY9dC5yZXZlcnNlRGVwdGhCdWZmZXI9PT0hMCYmZS5oYXMoIkVYVF9jbGlwX2NvbnRyb2wiKSxwPWkuZ2V0UGFyYW1ldGVyKGkuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLF89aS5nZXRQYXJhbWV0ZXIoaS5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLHg9aS5nZXRQYXJhbWV0ZXIoaS5NQVhfVEVYVFVSRV9TSVpFKSxtPWkuZ2V0UGFyYW1ldGVyKGkuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSksdT1pLmdldFBhcmFtZXRlcihpLk1BWF9WRVJURVhfQVRUUklCUyksVD1pLmdldFBhcmFtZXRlcihpLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTKSx5PWkuZ2V0UGFyYW1ldGVyKGkuTUFYX1ZBUllJTkdfVkVDVE9SUyksZz1pLmdldFBhcmFtZXRlcihpLk1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMpLFA9Xz4wLHc9aS5nZXRQYXJhbWV0ZXIoaS5NQVhfU0FNUExFUyk7cmV0dXJue2lzV2ViR0wyOiEwLGdldE1heEFuaXNvdHJvcHk6cyxnZXRNYXhQcmVjaXNpb246bCx0ZXh0dXJlRm9ybWF0UmVhZGFibGU6YSx0ZXh0dXJlVHlwZVJlYWRhYmxlOm8scHJlY2lzaW9uOmMsbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjpkLHJldmVyc2VEZXB0aEJ1ZmZlcjpmLG1heFRleHR1cmVzOnAsbWF4VmVydGV4VGV4dHVyZXM6XyxtYXhUZXh0dXJlU2l6ZTp4LG1heEN1YmVtYXBTaXplOm0sbWF4QXR0cmlidXRlczp1LG1heFZlcnRleFVuaWZvcm1zOlQsbWF4VmFyeWluZ3M6eSxtYXhGcmFnbWVudFVuaWZvcm1zOmcsdmVydGV4VGV4dHVyZXM6UCxtYXhTYW1wbGVzOnd9fWZ1bmN0aW9uIGtsKGkpe2NvbnN0IGU9dGhpcztsZXQgdD1udWxsLG49MCxyPSExLHM9ITE7Y29uc3QgYT1uZXcgZG4sbz1uZXcgYmUsbD17dmFsdWU6bnVsbCxuZWVkc1VwZGF0ZTohMX07dGhpcy51bmlmb3JtPWwsdGhpcy5udW1QbGFuZXM9MCx0aGlzLm51bUludGVyc2VjdGlvbj0wLHRoaXMuaW5pdD1mdW5jdGlvbihkLGYpe2NvbnN0IHA9ZC5sZW5ndGghPT0wfHxmfHxuIT09MHx8cjtyZXR1cm4gcj1mLG49ZC5sZW5ndGgscH0sdGhpcy5iZWdpblNoYWRvd3M9ZnVuY3Rpb24oKXtzPSEwLGgobnVsbCl9LHRoaXMuZW5kU2hhZG93cz1mdW5jdGlvbigpe3M9ITF9LHRoaXMuc2V0R2xvYmFsU3RhdGU9ZnVuY3Rpb24oZCxmKXt0PWgoZCxmLDApfSx0aGlzLnNldFN0YXRlPWZ1bmN0aW9uKGQsZixwKXtjb25zdCBfPWQuY2xpcHBpbmdQbGFuZXMseD1kLmNsaXBJbnRlcnNlY3Rpb24sbT1kLmNsaXBTaGFkb3dzLHU9aS5nZXQoZCk7aWYoIXJ8fF89PT1udWxsfHxfLmxlbmd0aD09PTB8fHMmJiFtKXM/aChudWxsKTpjKCk7ZWxzZXtjb25zdCBUPXM/MDpuLHk9VCo0O2xldCBnPXUuY2xpcHBpbmdTdGF0ZXx8bnVsbDtsLnZhbHVlPWcsZz1oKF8sZix5LHApO2ZvcihsZXQgUD0wO1AhPT15OysrUClnW1BdPXRbUF07dS5jbGlwcGluZ1N0YXRlPWcsdGhpcy5udW1JbnRlcnNlY3Rpb249eD90aGlzLm51bVBsYW5lczowLHRoaXMubnVtUGxhbmVzKz1UfX07ZnVuY3Rpb24gYygpe2wudmFsdWUhPT10JiYobC52YWx1ZT10LGwubmVlZHNVcGRhdGU9bj4wKSxlLm51bVBsYW5lcz1uLGUubnVtSW50ZXJzZWN0aW9uPTB9ZnVuY3Rpb24gaChkLGYscCxfKXtjb25zdCB4PWQhPT1udWxsP2QubGVuZ3RoOjA7bGV0IG09bnVsbDtpZih4IT09MCl7aWYobT1sLnZhbHVlLF8hPT0hMHx8bT09PW51bGwpe2NvbnN0IHU9cCt4KjQsVD1mLm1hdHJpeFdvcmxkSW52ZXJzZTtvLmdldE5vcm1hbE1hdHJpeChUKSwobT09PW51bGx8fG0ubGVuZ3RoPHUpJiYobT1uZXcgRmxvYXQzMkFycmF5KHUpKTtmb3IobGV0IHk9MCxnPXA7eSE9PXg7Kyt5LGcrPTQpYS5jb3B5KGRbeV0pLmFwcGx5TWF0cml4NChULG8pLGEubm9ybWFsLnRvQXJyYXkobSxnKSxtW2crM109YS5jb25zdGFudH1sLnZhbHVlPW0sbC5uZWVkc1VwZGF0ZT0hMH1yZXR1cm4gZS5udW1QbGFuZXM9eCxlLm51bUludGVyc2VjdGlvbj0wLG19fWZ1bmN0aW9uIFdsKGkpe2xldCBlPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIHQoYSxvKXtyZXR1cm4gbz09PTMwMz9hLm1hcHBpbmc9MzAxOm89PT0zMDQmJihhLm1hcHBpbmc9MzAyKSxhfWZ1bmN0aW9uIG4oYSl7aWYoYSYmYS5pc1RleHR1cmUpe2NvbnN0IG89YS5tYXBwaW5nO2lmKG89PT0zMDN8fG89PT0zMDQpaWYoZS5oYXMoYSkpe2NvbnN0IGw9ZS5nZXQoYSkudGV4dHVyZTtyZXR1cm4gdChsLGEubWFwcGluZyl9ZWxzZXtjb25zdCBsPWEuaW1hZ2U7aWYobCYmbC5oZWlnaHQ+MCl7Y29uc3QgYz1uZXcgRmEobC5oZWlnaHQpO3JldHVybiBjLmZyb21FcXVpcmVjdGFuZ3VsYXJUZXh0dXJlKGksYSksZS5zZXQoYSxjKSxhLmFkZEV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLHIpLHQoYy50ZXh0dXJlLGEubWFwcGluZyl9ZWxzZSByZXR1cm4gbnVsbH19cmV0dXJuIGF9ZnVuY3Rpb24gcihhKXtjb25zdCBvPWEudGFyZ2V0O28ucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIscik7Y29uc3QgbD1lLmdldChvKTtsIT09dm9pZCAwJiYoZS5kZWxldGUobyksbC5kaXNwb3NlKCkpfWZ1bmN0aW9uIHMoKXtlPW5ldyBXZWFrTWFwfXJldHVybntnZXQ6bixkaXNwb3NlOnN9fWNsYXNzIHJyIGV4dGVuZHMgJHJ7Y29uc3RydWN0b3IoZT0tMSx0PTEsbj0xLHI9LTEscz0uMSxhPTJlMyl7c3VwZXIoKSx0aGlzLmlzT3J0aG9ncmFwaGljQ2FtZXJhPSEwLHRoaXMudHlwZT0iT3J0aG9ncmFwaGljQ2FtZXJhIix0aGlzLnpvb209MSx0aGlzLnZpZXc9bnVsbCx0aGlzLmxlZnQ9ZSx0aGlzLnJpZ2h0PXQsdGhpcy50b3A9bix0aGlzLmJvdHRvbT1yLHRoaXMubmVhcj1zLHRoaXMuZmFyPWEsdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9Y29weShlLHQpe3JldHVybiBzdXBlci5jb3B5KGUsdCksdGhpcy5sZWZ0PWUubGVmdCx0aGlzLnJpZ2h0PWUucmlnaHQsdGhpcy50b3A9ZS50b3AsdGhpcy5ib3R0b209ZS5ib3R0b20sdGhpcy5uZWFyPWUubmVhcix0aGlzLmZhcj1lLmZhcix0aGlzLnpvb209ZS56b29tLHRoaXMudmlldz1lLnZpZXc9PT1udWxsP251bGw6T2JqZWN0LmFzc2lnbih7fSxlLnZpZXcpLHRoaXN9c2V0Vmlld09mZnNldChlLHQsbixyLHMsYSl7dGhpcy52aWV3PT09bnVsbCYmKHRoaXMudmlldz17ZW5hYmxlZDohMCxmdWxsV2lkdGg6MSxmdWxsSGVpZ2h0OjEsb2Zmc2V0WDowLG9mZnNldFk6MCx3aWR0aDoxLGhlaWdodDoxfSksdGhpcy52aWV3LmVuYWJsZWQ9ITAsdGhpcy52aWV3LmZ1bGxXaWR0aD1lLHRoaXMudmlldy5mdWxsSGVpZ2h0PXQsdGhpcy52aWV3Lm9mZnNldFg9bix0aGlzLnZpZXcub2Zmc2V0WT1yLHRoaXMudmlldy53aWR0aD1zLHRoaXMudmlldy5oZWlnaHQ9YSx0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX1jbGVhclZpZXdPZmZzZXQoKXt0aGlzLnZpZXchPT1udWxsJiYodGhpcy52aWV3LmVuYWJsZWQ9ITEpLHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfXVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKXtjb25zdCBlPSh0aGlzLnJpZ2h0LXRoaXMubGVmdCkvKDIqdGhpcy56b29tKSx0PSh0aGlzLnRvcC10aGlzLmJvdHRvbSkvKDIqdGhpcy56b29tKSxuPSh0aGlzLnJpZ2h0K3RoaXMubGVmdCkvMixyPSh0aGlzLnRvcCt0aGlzLmJvdHRvbSkvMjtsZXQgcz1uLWUsYT1uK2Usbz1yK3QsbD1yLXQ7aWYodGhpcy52aWV3IT09bnVsbCYmdGhpcy52aWV3LmVuYWJsZWQpe2NvbnN0IGM9KHRoaXMucmlnaHQtdGhpcy5sZWZ0KS90aGlzLnZpZXcuZnVsbFdpZHRoL3RoaXMuem9vbSxoPSh0aGlzLnRvcC10aGlzLmJvdHRvbSkvdGhpcy52aWV3LmZ1bGxIZWlnaHQvdGhpcy56b29tO3MrPWMqdGhpcy52aWV3Lm9mZnNldFgsYT1zK2MqdGhpcy52aWV3LndpZHRoLG8tPWgqdGhpcy52aWV3Lm9mZnNldFksbD1vLWgqdGhpcy52aWV3LmhlaWdodH10aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZU9ydGhvZ3JhcGhpYyhzLGEsbyxsLHRoaXMubmVhcix0aGlzLmZhcix0aGlzLmNvb3JkaW5hdGVTeXN0ZW0pLHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSh0aGlzLnByb2plY3Rpb25NYXRyaXgpLmludmVydCgpfXRvSlNPTihlKXtjb25zdCB0PXN1cGVyLnRvSlNPTihlKTtyZXR1cm4gdC5vYmplY3Quem9vbT10aGlzLnpvb20sdC5vYmplY3QubGVmdD10aGlzLmxlZnQsdC5vYmplY3QucmlnaHQ9dGhpcy5yaWdodCx0Lm9iamVjdC50b3A9dGhpcy50b3AsdC5vYmplY3QuYm90dG9tPXRoaXMuYm90dG9tLHQub2JqZWN0Lm5lYXI9dGhpcy5uZWFyLHQub2JqZWN0LmZhcj10aGlzLmZhcix0aGlzLnZpZXchPT1udWxsJiYodC5vYmplY3Qudmlldz1PYmplY3QuYXNzaWduKHt9LHRoaXMudmlldykpLHR9fWNvbnN0IE9uPTQsZXM9Wy4xMjUsLjIxNSwuMzUsLjQ0NiwuNTI2LC41ODJdLG1uPTIwLHNyPW5ldyBycix0cz1uZXcgVmU7bGV0IGFyPW51bGwsb3I9MCxscj0wLGNyPSExO2NvbnN0IGduPSgxK01hdGguc3FydCg1KSkvMixCbj0xL2duLG5zPVtuZXcgTygtZ24sQm4sMCksbmV3IE8oZ24sQm4sMCksbmV3IE8oLUJuLDAsZ24pLG5ldyBPKEJuLDAsZ24pLG5ldyBPKDAsZ24sLUJuKSxuZXcgTygwLGduLEJuKSxuZXcgTygtMSwxLC0xKSxuZXcgTygxLDEsLTEpLG5ldyBPKC0xLDEsMSksbmV3IE8oMSwxLDEpXTtjbGFzcyBpc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9yZW5kZXJlcj1lLHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0PW51bGwsdGhpcy5fbG9kTWF4PTAsdGhpcy5fY3ViZVNpemU9MCx0aGlzLl9sb2RQbGFuZXM9W10sdGhpcy5fc2l6ZUxvZHM9W10sdGhpcy5fc2lnbWFzPVtdLHRoaXMuX2JsdXJNYXRlcmlhbD1udWxsLHRoaXMuX2N1YmVtYXBNYXRlcmlhbD1udWxsLHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWw9bnVsbCx0aGlzLl9jb21waWxlTWF0ZXJpYWwodGhpcy5fYmx1ck1hdGVyaWFsKX1mcm9tU2NlbmUoZSx0PTAsbj0uMSxyPTEwMCl7YXI9dGhpcy5fcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCksb3I9dGhpcy5fcmVuZGVyZXIuZ2V0QWN0aXZlQ3ViZUZhY2UoKSxscj10aGlzLl9yZW5kZXJlci5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpLGNyPXRoaXMuX3JlbmRlcmVyLnhyLmVuYWJsZWQsdGhpcy5fcmVuZGVyZXIueHIuZW5hYmxlZD0hMSx0aGlzLl9zZXRTaXplKDI1Nik7Y29uc3Qgcz10aGlzLl9hbGxvY2F0ZVRhcmdldHMoKTtyZXR1cm4gcy5kZXB0aEJ1ZmZlcj0hMCx0aGlzLl9zY2VuZVRvQ3ViZVVWKGUsbixyLHMpLHQ+MCYmdGhpcy5fYmx1cihzLDAsMCx0KSx0aGlzLl9hcHBseVBNUkVNKHMpLHRoaXMuX2NsZWFudXAocyksc31mcm9tRXF1aXJlY3Rhbmd1bGFyKGUsdD1udWxsKXtyZXR1cm4gdGhpcy5fZnJvbVRleHR1cmUoZSx0KX1mcm9tQ3ViZW1hcChlLHQ9bnVsbCl7cmV0dXJuIHRoaXMuX2Zyb21UZXh0dXJlKGUsdCl9Y29tcGlsZUN1YmVtYXBTaGFkZXIoKXt0aGlzLl9jdWJlbWFwTWF0ZXJpYWw9PT1udWxsJiYodGhpcy5fY3ViZW1hcE1hdGVyaWFsPWFzKCksdGhpcy5fY29tcGlsZU1hdGVyaWFsKHRoaXMuX2N1YmVtYXBNYXRlcmlhbCkpfWNvbXBpbGVFcXVpcmVjdGFuZ3VsYXJTaGFkZXIoKXt0aGlzLl9lcXVpcmVjdE1hdGVyaWFsPT09bnVsbCYmKHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWw9c3MoKSx0aGlzLl9jb21waWxlTWF0ZXJpYWwodGhpcy5fZXF1aXJlY3RNYXRlcmlhbCkpfWRpc3Bvc2UoKXt0aGlzLl9kaXNwb3NlKCksdGhpcy5fY3ViZW1hcE1hdGVyaWFsIT09bnVsbCYmdGhpcy5fY3ViZW1hcE1hdGVyaWFsLmRpc3Bvc2UoKSx0aGlzLl9lcXVpcmVjdE1hdGVyaWFsIT09bnVsbCYmdGhpcy5fZXF1aXJlY3RNYXRlcmlhbC5kaXNwb3NlKCl9X3NldFNpemUoZSl7dGhpcy5fbG9kTWF4PU1hdGguZmxvb3IoTWF0aC5sb2cyKGUpKSx0aGlzLl9jdWJlU2l6ZT1NYXRoLnBvdygyLHRoaXMuX2xvZE1heCl9X2Rpc3Bvc2UoKXt0aGlzLl9ibHVyTWF0ZXJpYWwhPT1udWxsJiZ0aGlzLl9ibHVyTWF0ZXJpYWwuZGlzcG9zZSgpLHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0IT09bnVsbCYmdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQuZGlzcG9zZSgpO2ZvcihsZXQgZT0wO2U8dGhpcy5fbG9kUGxhbmVzLmxlbmd0aDtlKyspdGhpcy5fbG9kUGxhbmVzW2VdLmRpc3Bvc2UoKX1fY2xlYW51cChlKXt0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoYXIsb3IsbHIpLHRoaXMuX3JlbmRlcmVyLnhyLmVuYWJsZWQ9Y3IsZS5zY2lzc29yVGVzdD0hMSxUaShlLDAsMCxlLndpZHRoLGUuaGVpZ2h0KX1fZnJvbVRleHR1cmUoZSx0KXtlLm1hcHBpbmc9PT0zMDF8fGUubWFwcGluZz09PTMwMj90aGlzLl9zZXRTaXplKGUuaW1hZ2UubGVuZ3RoPT09MD8xNjplLmltYWdlWzBdLndpZHRofHxlLmltYWdlWzBdLmltYWdlLndpZHRoKTp0aGlzLl9zZXRTaXplKGUuaW1hZ2Uud2lkdGgvNCksYXI9dGhpcy5fcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCksb3I9dGhpcy5fcmVuZGVyZXIuZ2V0QWN0aXZlQ3ViZUZhY2UoKSxscj10aGlzLl9yZW5kZXJlci5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpLGNyPXRoaXMuX3JlbmRlcmVyLnhyLmVuYWJsZWQsdGhpcy5fcmVuZGVyZXIueHIuZW5hYmxlZD0hMTtjb25zdCBuPXR8fHRoaXMuX2FsbG9jYXRlVGFyZ2V0cygpO3JldHVybiB0aGlzLl90ZXh0dXJlVG9DdWJlVVYoZSxuKSx0aGlzLl9hcHBseVBNUkVNKG4pLHRoaXMuX2NsZWFudXAobiksbn1fYWxsb2NhdGVUYXJnZXRzKCl7Y29uc3QgZT0zKk1hdGgubWF4KHRoaXMuX2N1YmVTaXplLDExMiksdD00KnRoaXMuX2N1YmVTaXplLG49e21hZ0ZpbHRlcjoxMDA2LG1pbkZpbHRlcjoxMDA2LGdlbmVyYXRlTWlwbWFwczohMSx0eXBlOjEwMTYsZm9ybWF0OjEwMjMsY29sb3JTcGFjZTp4bixkZXB0aEJ1ZmZlcjohMX0scj1ycyhlLHQsbik7aWYodGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQ9PT1udWxsfHx0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldC53aWR0aCE9PWV8fHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0LmhlaWdodCE9PXQpe3RoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0IT09bnVsbCYmdGhpcy5fZGlzcG9zZSgpLHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0PXJzKGUsdCxuKTtjb25zdHtfbG9kTWF4OnN9PXRoaXM7KHtzaXplTG9kczp0aGlzLl9zaXplTG9kcyxsb2RQbGFuZXM6dGhpcy5fbG9kUGxhbmVzLHNpZ21hczp0aGlzLl9zaWdtYXN9PVhsKHMpKSx0aGlzLl9ibHVyTWF0ZXJpYWw9cWwocyxlLHQpfXJldHVybiByfV9jb21waWxlTWF0ZXJpYWwoZSl7Y29uc3QgdD1uZXcgdHQodGhpcy5fbG9kUGxhbmVzWzBdLGUpO3RoaXMuX3JlbmRlcmVyLmNvbXBpbGUodCxzcil9X3NjZW5lVG9DdWJlVVYoZSx0LG4scil7Y29uc3Qgbz1uZXcgTnQoOTAsMSx0LG4pLGw9WzEsLTEsMSwxLDEsMV0sYz1bMSwxLDEsLTEsLTEsLTFdLGg9dGhpcy5fcmVuZGVyZXIsZD1oLmF1dG9DbGVhcixmPWgudG9uZU1hcHBpbmc7aC5nZXRDbGVhckNvbG9yKHRzKSxoLnRvbmVNYXBwaW5nPTAsaC5hdXRvQ2xlYXI9ITE7Y29uc3QgcD1uZXcgam4oe25hbWU6IlBNUkVNLkJhY2tncm91bmQiLHNpZGU6MSxkZXB0aFdyaXRlOiExLGRlcHRoVGVzdDohMX0pLF89bmV3IHR0KG5ldyBRbixwKTtsZXQgeD0hMTtjb25zdCBtPWUuYmFja2dyb3VuZDttP20uaXNDb2xvciYmKHAuY29sb3IuY29weShtKSxlLmJhY2tncm91bmQ9bnVsbCx4PSEwKToocC5jb2xvci5jb3B5KHRzKSx4PSEwKTtmb3IobGV0IHU9MDt1PDY7dSsrKXtjb25zdCBUPXUlMztUPT09MD8oby51cC5zZXQoMCxsW3VdLDApLG8ubG9va0F0KGNbdV0sMCwwKSk6VD09PTE/KG8udXAuc2V0KDAsMCxsW3VdKSxvLmxvb2tBdCgwLGNbdV0sMCkpOihvLnVwLnNldCgwLGxbdV0sMCksby5sb29rQXQoMCwwLGNbdV0pKTtjb25zdCB5PXRoaXMuX2N1YmVTaXplO1RpKHIsVCp5LHU+Mj95OjAseSx5KSxoLnNldFJlbmRlclRhcmdldChyKSx4JiZoLnJlbmRlcihfLG8pLGgucmVuZGVyKGUsbyl9Xy5nZW9tZXRyeS5kaXNwb3NlKCksXy5tYXRlcmlhbC5kaXNwb3NlKCksaC50b25lTWFwcGluZz1mLGguYXV0b0NsZWFyPWQsZS5iYWNrZ3JvdW5kPW19X3RleHR1cmVUb0N1YmVVVihlLHQpe2NvbnN0IG49dGhpcy5fcmVuZGVyZXIscj1lLm1hcHBpbmc9PT0zMDF8fGUubWFwcGluZz09PTMwMjtyPyh0aGlzLl9jdWJlbWFwTWF0ZXJpYWw9PT1udWxsJiYodGhpcy5fY3ViZW1hcE1hdGVyaWFsPWFzKCkpLHRoaXMuX2N1YmVtYXBNYXRlcmlhbC51bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlPWUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlPT09ITE/LTE6MSk6dGhpcy5fZXF1aXJlY3RNYXRlcmlhbD09PW51bGwmJih0aGlzLl9lcXVpcmVjdE1hdGVyaWFsPXNzKCkpO2NvbnN0IHM9cj90aGlzLl9jdWJlbWFwTWF0ZXJpYWw6dGhpcy5fZXF1aXJlY3RNYXRlcmlhbCxhPW5ldyB0dCh0aGlzLl9sb2RQbGFuZXNbMF0scyksbz1zLnVuaWZvcm1zO28uZW52TWFwLnZhbHVlPWU7Y29uc3QgbD10aGlzLl9jdWJlU2l6ZTtUaSh0LDAsMCwzKmwsMipsKSxuLnNldFJlbmRlclRhcmdldCh0KSxuLnJlbmRlcihhLHNyKX1fYXBwbHlQTVJFTShlKXtjb25zdCB0PXRoaXMuX3JlbmRlcmVyLG49dC5hdXRvQ2xlYXI7dC5hdXRvQ2xlYXI9ITE7Y29uc3Qgcj10aGlzLl9sb2RQbGFuZXMubGVuZ3RoO2ZvcihsZXQgcz0xO3M8cjtzKyspe2NvbnN0IGE9TWF0aC5zcXJ0KHRoaXMuX3NpZ21hc1tzXSp0aGlzLl9zaWdtYXNbc10tdGhpcy5fc2lnbWFzW3MtMV0qdGhpcy5fc2lnbWFzW3MtMV0pLG89bnNbKHItcy0xKSVucy5sZW5ndGhdO3RoaXMuX2JsdXIoZSxzLTEscyxhLG8pfXQuYXV0b0NsZWFyPW59X2JsdXIoZSx0LG4scixzKXtjb25zdCBhPXRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0O3RoaXMuX2hhbGZCbHVyKGUsYSx0LG4sciwibGF0aXR1ZGluYWwiLHMpLHRoaXMuX2hhbGZCbHVyKGEsZSxuLG4sciwibG9uZ2l0dWRpbmFsIixzKX1faGFsZkJsdXIoZSx0LG4scixzLGEsbyl7Y29uc3QgbD10aGlzLl9yZW5kZXJlcixjPXRoaXMuX2JsdXJNYXRlcmlhbDthIT09ImxhdGl0dWRpbmFsIiYmYSE9PSJsb25naXR1ZGluYWwiJiZjb25zb2xlLmVycm9yKCJibHVyIGRpcmVjdGlvbiBtdXN0IGJlIGVpdGhlciBsYXRpdHVkaW5hbCBvciBsb25naXR1ZGluYWwhIik7Y29uc3QgaD0zLGQ9bmV3IHR0KHRoaXMuX2xvZFBsYW5lc1tyXSxjKSxmPWMudW5pZm9ybXMscD10aGlzLl9zaXplTG9kc1tuXS0xLF89aXNGaW5pdGUocyk/TWF0aC5QSS8oMipwKToyKk1hdGguUEkvKDIqbW4tMSkseD1zL18sbT1pc0Zpbml0ZShzKT8xK01hdGguZmxvb3IoaCp4KTptbjttPm1uJiZjb25zb2xlLndhcm4oYHNpZ21hUmFkaWFucywgJHtzfSwgaXMgdG9vIGxhcmdlIGFuZCB3aWxsIGNsaXAsIGFzIGl0IHJlcXVlc3RlZCAke219IHNhbXBsZXMgd2hlbiB0aGUgbWF4aW11bSBpcyBzZXQgdG8gJHttbn1gKTtjb25zdCB1PVtdO2xldCBUPTA7Zm9yKGxldCBiPTA7YjxtbjsrK2Ipe2NvbnN0IEY9Yi94LEU9TWF0aC5leHAoLUYqRi8yKTt1LnB1c2goRSksYj09PTA/VCs9RTpiPG0mJihUKz0yKkUpfWZvcihsZXQgYj0wO2I8dS5sZW5ndGg7YisrKXVbYl09dVtiXS9UO2YuZW52TWFwLnZhbHVlPWUudGV4dHVyZSxmLnNhbXBsZXMudmFsdWU9bSxmLndlaWdodHMudmFsdWU9dSxmLmxhdGl0dWRpbmFsLnZhbHVlPWE9PT0ibGF0aXR1ZGluYWwiLG8mJihmLnBvbGVBeGlzLnZhbHVlPW8pO2NvbnN0e19sb2RNYXg6eX09dGhpcztmLmRUaGV0YS52YWx1ZT1fLGYubWlwSW50LnZhbHVlPXktbjtjb25zdCBnPXRoaXMuX3NpemVMb2RzW3JdLFA9MypnKihyPnktT24/ci15K09uOjApLHc9NCoodGhpcy5fY3ViZVNpemUtZyk7VGkodCxQLHcsMypnLDIqZyksbC5zZXRSZW5kZXJUYXJnZXQodCksbC5yZW5kZXIoZCxzcil9fWZ1bmN0aW9uIFhsKGkpe2NvbnN0IGU9W10sdD1bXSxuPVtdO2xldCByPWk7Y29uc3Qgcz1pLU9uKzErZXMubGVuZ3RoO2ZvcihsZXQgYT0wO2E8czthKyspe2NvbnN0IG89TWF0aC5wb3coMixyKTt0LnB1c2gobyk7bGV0IGw9MS9vO2E+aS1Pbj9sPWVzW2EtaStPbi0xXTphPT09MCYmKGw9MCksbi5wdXNoKGwpO2NvbnN0IGM9MS8oby0yKSxoPS1jLGQ9MStjLGY9W2gsaCxkLGgsZCxkLGgsaCxkLGQsaCxkXSxwPTYsXz02LHg9MyxtPTIsdT0xLFQ9bmV3IEZsb2F0MzJBcnJheSh4Kl8qcCkseT1uZXcgRmxvYXQzMkFycmF5KG0qXypwKSxnPW5ldyBGbG9hdDMyQXJyYXkodSpfKnApO2ZvcihsZXQgdz0wO3c8cDt3Kyspe2NvbnN0IGI9dyUzKjIvMy0xLEY9dz4yPzA6LTEsRT1bYixGLDAsYisyLzMsRiwwLGIrMi8zLEYrMSwwLGIsRiwwLGIrMi8zLEYrMSwwLGIsRisxLDBdO1Quc2V0KEUseCpfKncpLHkuc2V0KGYsbSpfKncpO2NvbnN0IFM9W3csdyx3LHcsdyx3XTtnLnNldChTLHUqXyp3KX1jb25zdCBQPW5ldyBDdDtQLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBTdChULHgpKSxQLnNldEF0dHJpYnV0ZSgidXYiLG5ldyBTdCh5LG0pKSxQLnNldEF0dHJpYnV0ZSgiZmFjZUluZGV4IixuZXcgU3QoZyx1KSksZS5wdXNoKFApLHI+T24mJnItLX1yZXR1cm57bG9kUGxhbmVzOmUsc2l6ZUxvZHM6dCxzaWdtYXM6bn19ZnVuY3Rpb24gcnMoaSxlLHQpe2NvbnN0IG49bmV3IEp0KGksZSx0KTtyZXR1cm4gbi50ZXh0dXJlLm1hcHBpbmc9MzA2LG4udGV4dHVyZS5uYW1lPSJQTVJFTS5jdWJlVXYiLG4uc2Npc3NvclRlc3Q9ITAsbn1mdW5jdGlvbiBUaShpLGUsdCxuLHIpe2kudmlld3BvcnQuc2V0KGUsdCxuLHIpLGkuc2Npc3Nvci5zZXQoZSx0LG4scil9ZnVuY3Rpb24gcWwoaSxlLHQpe2NvbnN0IG49bmV3IEZsb2F0MzJBcnJheShtbikscj1uZXcgTygwLDEsMCk7cmV0dXJuIG5ldyBsdCh7bmFtZToiU3BoZXJpY2FsR2F1c3NpYW5CbHVyIixkZWZpbmVzOntuOm1uLENVQkVVVl9URVhFTF9XSURUSDoxL2UsQ1VCRVVWX1RFWEVMX0hFSUdIVDoxL3QsQ1VCRVVWX01BWF9NSVA6YCR7aX0uMGB9LHVuaWZvcm1zOntlbnZNYXA6e3ZhbHVlOm51bGx9LHNhbXBsZXM6e3ZhbHVlOjF9LHdlaWdodHM6e3ZhbHVlOm59LGxhdGl0dWRpbmFsOnt2YWx1ZTohMX0sZFRoZXRhOnt2YWx1ZTowfSxtaXBJbnQ6e3ZhbHVlOjB9LHBvbGVBeGlzOnt2YWx1ZTpyfX0sdmVydGV4U2hhZGVyOnVyKCksZnJhZ21lbnRTaGFkZXI6YAoKCQkJcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CgkJCXByZWNpc2lvbiBtZWRpdW1wIGludDsKCgkJCXZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uOwoKCQkJdW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwOwoJCQl1bmlmb3JtIGludCBzYW1wbGVzOwoJCQl1bmlmb3JtIGZsb2F0IHdlaWdodHNbIG4gXTsKCQkJdW5pZm9ybSBib29sIGxhdGl0dWRpbmFsOwoJCQl1bmlmb3JtIGZsb2F0IGRUaGV0YTsKCQkJdW5pZm9ybSBmbG9hdCBtaXBJbnQ7CgkJCXVuaWZvcm0gdmVjMyBwb2xlQXhpczsKCgkJCSNkZWZpbmUgRU5WTUFQX1RZUEVfQ1VCRV9VVgoJCQkjaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PgoKCQkJdmVjMyBnZXRTYW1wbGUoIGZsb2F0IHRoZXRhLCB2ZWMzIGF4aXMgKSB7CgoJCQkJZmxvYXQgY29zVGhldGEgPSBjb3MoIHRoZXRhICk7CgkJCQkvLyBSb2RyaWd1ZXMnIGF4aXMtYW5nbGUgcm90YXRpb24KCQkJCXZlYzMgc2FtcGxlRGlyZWN0aW9uID0gdk91dHB1dERpcmVjdGlvbiAqIGNvc1RoZXRhCgkJCQkJKyBjcm9zcyggYXhpcywgdk91dHB1dERpcmVjdGlvbiApICogc2luKCB0aGV0YSApCgkJCQkJKyBheGlzICogZG90KCBheGlzLCB2T3V0cHV0RGlyZWN0aW9uICkgKiAoIDEuMCAtIGNvc1RoZXRhICk7CgoJCQkJcmV0dXJuIGJpbGluZWFyQ3ViZVVWKCBlbnZNYXAsIHNhbXBsZURpcmVjdGlvbiwgbWlwSW50ICk7CgoJCQl9CgoJCQl2b2lkIG1haW4oKSB7CgoJCQkJdmVjMyBheGlzID0gbGF0aXR1ZGluYWwgPyBwb2xlQXhpcyA6IGNyb3NzKCBwb2xlQXhpcywgdk91dHB1dERpcmVjdGlvbiApOwoKCQkJCWlmICggYWxsKCBlcXVhbCggYXhpcywgdmVjMyggMC4wICkgKSApICkgewoKCQkJCQlheGlzID0gdmVjMyggdk91dHB1dERpcmVjdGlvbi56LCAwLjAsIC0gdk91dHB1dERpcmVjdGlvbi54ICk7CgoJCQkJfQoKCQkJCWF4aXMgPSBub3JtYWxpemUoIGF4aXMgKTsKCgkJCQlnbF9GcmFnQ29sb3IgPSB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTsKCQkJCWdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgMCBdICogZ2V0U2FtcGxlKCAwLjAsIGF4aXMgKTsKCgkJCQlmb3IgKCBpbnQgaSA9IDE7IGkgPCBuOyBpKysgKSB7CgoJCQkJCWlmICggaSA+PSBzYW1wbGVzICkgewoKCQkJCQkJYnJlYWs7CgoJCQkJCX0KCgkJCQkJZmxvYXQgdGhldGEgPSBkVGhldGEgKiBmbG9hdCggaSApOwoJCQkJCWdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgaSBdICogZ2V0U2FtcGxlKCAtMS4wICogdGhldGEsIGF4aXMgKTsKCQkJCQlnbF9GcmFnQ29sb3IucmdiICs9IHdlaWdodHNbIGkgXSAqIGdldFNhbXBsZSggdGhldGEsIGF4aXMgKTsKCgkJCQl9CgoJCQl9CgkJYCxibGVuZGluZzowLGRlcHRoVGVzdDohMSxkZXB0aFdyaXRlOiExfSl9ZnVuY3Rpb24gc3MoKXtyZXR1cm4gbmV3IGx0KHtuYW1lOiJFcXVpcmVjdGFuZ3VsYXJUb0N1YmVVViIsdW5pZm9ybXM6e2Vudk1hcDp7dmFsdWU6bnVsbH19LHZlcnRleFNoYWRlcjp1cigpLGZyYWdtZW50U2hhZGVyOmAKCgkJCXByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwoJCQlwcmVjaXNpb24gbWVkaXVtcCBpbnQ7CgoJCQl2YXJ5aW5nIHZlYzMgdk91dHB1dERpcmVjdGlvbjsKCgkJCXVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDsKCgkJCSNpbmNsdWRlIDxjb21tb24+CgoJCQl2b2lkIG1haW4oKSB7CgoJCQkJdmVjMyBvdXRwdXREaXJlY3Rpb24gPSBub3JtYWxpemUoIHZPdXRwdXREaXJlY3Rpb24gKTsKCQkJCXZlYzIgdXYgPSBlcXVpcmVjdFV2KCBvdXRwdXREaXJlY3Rpb24gKTsKCgkJCQlnbF9GcmFnQ29sb3IgPSB2ZWM0KCB0ZXh0dXJlMkQgKCBlbnZNYXAsIHV2ICkucmdiLCAxLjAgKTsKCgkJCX0KCQlgLGJsZW5kaW5nOjAsZGVwdGhUZXN0OiExLGRlcHRoV3JpdGU6ITF9KX1mdW5jdGlvbiBhcygpe3JldHVybiBuZXcgbHQoe25hbWU6IkN1YmVtYXBUb0N1YmVVViIsdW5pZm9ybXM6e2Vudk1hcDp7dmFsdWU6bnVsbH0sZmxpcEVudk1hcDp7dmFsdWU6LTF9fSx2ZXJ0ZXhTaGFkZXI6dXIoKSxmcmFnbWVudFNoYWRlcjpgCgoJCQlwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKCQkJcHJlY2lzaW9uIG1lZGl1bXAgaW50OwoKCQkJdW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwOwoKCQkJdmFyeWluZyB2ZWMzIHZPdXRwdXREaXJlY3Rpb247CgoJCQl1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDsKCgkJCXZvaWQgbWFpbigpIHsKCgkJCQlnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCB2ZWMzKCBmbGlwRW52TWFwICogdk91dHB1dERpcmVjdGlvbi54LCB2T3V0cHV0RGlyZWN0aW9uLnl6ICkgKTsKCgkJCX0KCQlgLGJsZW5kaW5nOjAsZGVwdGhUZXN0OiExLGRlcHRoV3JpdGU6ITF9KX1mdW5jdGlvbiB1cigpe3JldHVybmAKCgkJcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CgkJcHJlY2lzaW9uIG1lZGl1bXAgaW50OwoKCQlhdHRyaWJ1dGUgZmxvYXQgZmFjZUluZGV4OwoKCQl2YXJ5aW5nIHZlYzMgdk91dHB1dERpcmVjdGlvbjsKCgkJLy8gUkggY29vcmRpbmF0ZSBzeXN0ZW07IFBNUkVNIGZhY2UtaW5kZXhpbmcgY29udmVudGlvbgoJCXZlYzMgZ2V0RGlyZWN0aW9uKCB2ZWMyIHV2LCBmbG9hdCBmYWNlICkgewoKCQkJdXYgPSAyLjAgKiB1diAtIDEuMDsKCgkJCXZlYzMgZGlyZWN0aW9uID0gdmVjMyggdXYsIDEuMCApOwoKCQkJaWYgKCBmYWNlID09IDAuMCApIHsKCgkJCQlkaXJlY3Rpb24gPSBkaXJlY3Rpb24uenl4OyAvLyAoIDEsIHYsIHUgKSBwb3MgeAoKCQkJfSBlbHNlIGlmICggZmFjZSA9PSAxLjAgKSB7CgoJCQkJZGlyZWN0aW9uID0gZGlyZWN0aW9uLnh6eTsKCQkJCWRpcmVjdGlvbi54eiAqPSAtMS4wOyAvLyAoIC11LCAxLCAtdiApIHBvcyB5CgoJCQl9IGVsc2UgaWYgKCBmYWNlID09IDIuMCApIHsKCgkJCQlkaXJlY3Rpb24ueCAqPSAtMS4wOyAvLyAoIC11LCB2LCAxICkgcG9zIHoKCgkJCX0gZWxzZSBpZiAoIGZhY2UgPT0gMy4wICkgewoKCQkJCWRpcmVjdGlvbiA9IGRpcmVjdGlvbi56eXg7CgkJCQlkaXJlY3Rpb24ueHogKj0gLTEuMDsgLy8gKCAtMSwgdiwgLXUgKSBuZWcgeAoKCQkJfSBlbHNlIGlmICggZmFjZSA9PSA0LjAgKSB7CgoJCQkJZGlyZWN0aW9uID0gZGlyZWN0aW9uLnh6eTsKCQkJCWRpcmVjdGlvbi54eSAqPSAtMS4wOyAvLyAoIC11LCAtMSwgdiApIG5lZyB5CgoJCQl9IGVsc2UgaWYgKCBmYWNlID09IDUuMCApIHsKCgkJCQlkaXJlY3Rpb24ueiAqPSAtMS4wOyAvLyAoIHUsIHYsIC0xICkgbmVnIHoKCgkJCX0KCgkJCXJldHVybiBkaXJlY3Rpb247CgoJCX0KCgkJdm9pZCBtYWluKCkgewoKCQkJdk91dHB1dERpcmVjdGlvbiA9IGdldERpcmVjdGlvbiggdXYsIGZhY2VJbmRleCApOwoJCQlnbF9Qb3NpdGlvbiA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTsKCgkJfQoJYH1mdW5jdGlvbiBZbChpKXtsZXQgZT1uZXcgV2Vha01hcCx0PW51bGw7ZnVuY3Rpb24gbihvKXtpZihvJiZvLmlzVGV4dHVyZSl7Y29uc3QgbD1vLm1hcHBpbmcsYz1sPT09MzAzfHxsPT09MzA0LGg9bD09PTMwMXx8bD09PTMwMjtpZihjfHxoKXtsZXQgZD1lLmdldChvKTtjb25zdCBmPWQhPT12b2lkIDA/ZC50ZXh0dXJlLnBtcmVtVmVyc2lvbjowO2lmKG8uaXNSZW5kZXJUYXJnZXRUZXh0dXJlJiZvLnBtcmVtVmVyc2lvbiE9PWYpcmV0dXJuIHQ9PT1udWxsJiYodD1uZXcgaXMoaSkpLGQ9Yz90LmZyb21FcXVpcmVjdGFuZ3VsYXIobyxkKTp0LmZyb21DdWJlbWFwKG8sZCksZC50ZXh0dXJlLnBtcmVtVmVyc2lvbj1vLnBtcmVtVmVyc2lvbixlLnNldChvLGQpLGQudGV4dHVyZTtpZihkIT09dm9pZCAwKXJldHVybiBkLnRleHR1cmU7e2NvbnN0IHA9by5pbWFnZTtyZXR1cm4gYyYmcCYmcC5oZWlnaHQ+MHx8aCYmcCYmcihwKT8odD09PW51bGwmJih0PW5ldyBpcyhpKSksZD1jP3QuZnJvbUVxdWlyZWN0YW5ndWxhcihvKTp0LmZyb21DdWJlbWFwKG8pLGQudGV4dHVyZS5wbXJlbVZlcnNpb249by5wbXJlbVZlcnNpb24sZS5zZXQobyxkKSxvLmFkZEV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLHMpLGQudGV4dHVyZSk6bnVsbH19fXJldHVybiBvfWZ1bmN0aW9uIHIobyl7bGV0IGw9MDtjb25zdCBjPTY7Zm9yKGxldCBoPTA7aDxjO2grKylvW2hdIT09dm9pZCAwJiZsKys7cmV0dXJuIGw9PT1jfWZ1bmN0aW9uIHMobyl7Y29uc3QgbD1vLnRhcmdldDtsLnJlbW92ZUV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLHMpO2NvbnN0IGM9ZS5nZXQobCk7YyE9PXZvaWQgMCYmKGUuZGVsZXRlKGwpLGMuZGlzcG9zZSgpKX1mdW5jdGlvbiBhKCl7ZT1uZXcgV2Vha01hcCx0IT09bnVsbCYmKHQuZGlzcG9zZSgpLHQ9bnVsbCl9cmV0dXJue2dldDpuLGRpc3Bvc2U6YX19ZnVuY3Rpb24gJGwoaSl7Y29uc3QgZT17fTtmdW5jdGlvbiB0KG4pe2lmKGVbbl0hPT12b2lkIDApcmV0dXJuIGVbbl07bGV0IHI7c3dpdGNoKG4pe2Nhc2UiV0VCR0xfZGVwdGhfdGV4dHVyZSI6cj1pLmdldEV4dGVuc2lvbigiV0VCR0xfZGVwdGhfdGV4dHVyZSIpfHxpLmdldEV4dGVuc2lvbigiTU9aX1dFQkdMX2RlcHRoX3RleHR1cmUiKXx8aS5nZXRFeHRlbnNpb24oIldFQktJVF9XRUJHTF9kZXB0aF90ZXh0dXJlIik7YnJlYWs7Y2FzZSJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMiOnI9aS5nZXRFeHRlbnNpb24oIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyIpfHxpLmdldEV4dGVuc2lvbigiTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyIpfHxpLmdldEV4dGVuc2lvbigiV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyIpO2JyZWFrO2Nhc2UiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMiOnI9aS5nZXRFeHRlbnNpb24oIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjIil8fGkuZ2V0RXh0ZW5zaW9uKCJNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMiKXx8aS5nZXRFeHRlbnNpb24oIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YyIpO2JyZWFrO2Nhc2UiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjIjpyPWkuZ2V0RXh0ZW5zaW9uKCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMiKXx8aS5nZXRFeHRlbnNpb24oIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMiKTticmVhaztkZWZhdWx0OnI9aS5nZXRFeHRlbnNpb24obil9cmV0dXJuIGVbbl09cixyfXJldHVybntoYXM6ZnVuY3Rpb24obil7cmV0dXJuIHQobikhPT1udWxsfSxpbml0OmZ1bmN0aW9uKCl7dCgiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCIpLHQoIldFQkdMX2NsaXBfY3VsbF9kaXN0YW5jZSIpLHQoIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhciIpLHQoIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCIpLHQoIldFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZSIpLHQoIldFQkdMX3JlbmRlcl9zaGFyZWRfZXhwb25lbnQiKX0sZ2V0OmZ1bmN0aW9uKG4pe2NvbnN0IHI9dChuKTtyZXR1cm4gcj09PW51bGwmJlduKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAiK24rIiBleHRlbnNpb24gbm90IHN1cHBvcnRlZC4iKSxyfX19ZnVuY3Rpb24gS2woaSxlLHQsbil7Y29uc3Qgcj17fSxzPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIGEoZCl7Y29uc3QgZj1kLnRhcmdldDtmLmluZGV4IT09bnVsbCYmZS5yZW1vdmUoZi5pbmRleCk7Zm9yKGNvbnN0IF8gaW4gZi5hdHRyaWJ1dGVzKWUucmVtb3ZlKGYuYXR0cmlidXRlc1tfXSk7Zm9yKGNvbnN0IF8gaW4gZi5tb3JwaEF0dHJpYnV0ZXMpe2NvbnN0IHg9Zi5tb3JwaEF0dHJpYnV0ZXNbX107Zm9yKGxldCBtPTAsdT14Lmxlbmd0aDttPHU7bSsrKWUucmVtb3ZlKHhbbV0pfWYucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsYSksZGVsZXRlIHJbZi5pZF07Y29uc3QgcD1zLmdldChmKTtwJiYoZS5yZW1vdmUocCkscy5kZWxldGUoZikpLG4ucmVsZWFzZVN0YXRlc09mR2VvbWV0cnkoZiksZi5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5PT09ITAmJmRlbGV0ZSBmLl9tYXhJbnN0YW5jZUNvdW50LHQubWVtb3J5Lmdlb21ldHJpZXMtLX1mdW5jdGlvbiBvKGQsZil7cmV0dXJuIHJbZi5pZF09PT0hMHx8KGYuYWRkRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsYSkscltmLmlkXT0hMCx0Lm1lbW9yeS5nZW9tZXRyaWVzKyspLGZ9ZnVuY3Rpb24gbChkKXtjb25zdCBmPWQuYXR0cmlidXRlcztmb3IoY29uc3QgXyBpbiBmKWUudXBkYXRlKGZbX10saS5BUlJBWV9CVUZGRVIpO2NvbnN0IHA9ZC5tb3JwaEF0dHJpYnV0ZXM7Zm9yKGNvbnN0IF8gaW4gcCl7Y29uc3QgeD1wW19dO2ZvcihsZXQgbT0wLHU9eC5sZW5ndGg7bTx1O20rKyllLnVwZGF0ZSh4W21dLGkuQVJSQVlfQlVGRkVSKX19ZnVuY3Rpb24gYyhkKXtjb25zdCBmPVtdLHA9ZC5pbmRleCxfPWQuYXR0cmlidXRlcy5wb3NpdGlvbjtsZXQgeD0wO2lmKHAhPT1udWxsKXtjb25zdCBUPXAuYXJyYXk7eD1wLnZlcnNpb247Zm9yKGxldCB5PTAsZz1ULmxlbmd0aDt5PGc7eSs9Myl7Y29uc3QgUD1UW3krMF0sdz1UW3krMV0sYj1UW3krMl07Zi5wdXNoKFAsdyx3LGIsYixQKX19ZWxzZSBpZihfIT09dm9pZCAwKXtjb25zdCBUPV8uYXJyYXk7eD1fLnZlcnNpb247Zm9yKGxldCB5PTAsZz1ULmxlbmd0aC8zLTE7eTxnO3krPTMpe2NvbnN0IFA9eSswLHc9eSsxLGI9eSsyO2YucHVzaChQLHcsdyxiLGIsUCl9fWVsc2UgcmV0dXJuO2NvbnN0IG09bmV3KFNyKGYpP2tyOlZyKShmLDEpO20udmVyc2lvbj14O2NvbnN0IHU9cy5nZXQoZCk7dSYmZS5yZW1vdmUodSkscy5zZXQoZCxtKX1mdW5jdGlvbiBoKGQpe2NvbnN0IGY9cy5nZXQoZCk7aWYoZil7Y29uc3QgcD1kLmluZGV4O3AhPT1udWxsJiZmLnZlcnNpb248cC52ZXJzaW9uJiZjKGQpfWVsc2UgYyhkKTtyZXR1cm4gcy5nZXQoZCl9cmV0dXJue2dldDpvLHVwZGF0ZTpsLGdldFdpcmVmcmFtZUF0dHJpYnV0ZTpofX1mdW5jdGlvbiBabChpLGUsdCl7bGV0IG47ZnVuY3Rpb24gcihmKXtuPWZ9bGV0IHMsYTtmdW5jdGlvbiBvKGYpe3M9Zi50eXBlLGE9Zi5ieXRlc1BlckVsZW1lbnR9ZnVuY3Rpb24gbChmLHApe2kuZHJhd0VsZW1lbnRzKG4scCxzLGYqYSksdC51cGRhdGUocCxuLDEpfWZ1bmN0aW9uIGMoZixwLF8pe18hPT0wJiYoaS5kcmF3RWxlbWVudHNJbnN0YW5jZWQobixwLHMsZiphLF8pLHQudXBkYXRlKHAsbixfKSl9ZnVuY3Rpb24gaChmLHAsXyl7aWYoXz09PTApcmV0dXJuO2UuZ2V0KCJXRUJHTF9tdWx0aV9kcmF3IikubXVsdGlEcmF3RWxlbWVudHNXRUJHTChuLHAsMCxzLGYsMCxfKTtsZXQgbT0wO2ZvcihsZXQgdT0wO3U8Xzt1KyspbSs9cFt1XTt0LnVwZGF0ZShtLG4sMSl9ZnVuY3Rpb24gZChmLHAsXyx4KXtpZihfPT09MClyZXR1cm47Y29uc3QgbT1lLmdldCgiV0VCR0xfbXVsdGlfZHJhdyIpO2lmKG09PT1udWxsKWZvcihsZXQgdT0wO3U8Zi5sZW5ndGg7dSsrKWMoZlt1XS9hLHBbdV0seFt1XSk7ZWxzZXttLm11bHRpRHJhd0VsZW1lbnRzSW5zdGFuY2VkV0VCR0wobixwLDAscyxmLDAseCwwLF8pO2xldCB1PTA7Zm9yKGxldCBUPTA7VDxfO1QrKyl1Kz1wW1RdKnhbVF07dC51cGRhdGUodSxuLDEpfX10aGlzLnNldE1vZGU9cix0aGlzLnNldEluZGV4PW8sdGhpcy5yZW5kZXI9bCx0aGlzLnJlbmRlckluc3RhbmNlcz1jLHRoaXMucmVuZGVyTXVsdGlEcmF3PWgsdGhpcy5yZW5kZXJNdWx0aURyYXdJbnN0YW5jZXM9ZH1mdW5jdGlvbiBqbChpKXtjb25zdCBlPXtnZW9tZXRyaWVzOjAsdGV4dHVyZXM6MH0sdD17ZnJhbWU6MCxjYWxsczowLHRyaWFuZ2xlczowLHBvaW50czowLGxpbmVzOjB9O2Z1bmN0aW9uIG4ocyxhLG8pe3N3aXRjaCh0LmNhbGxzKyssYSl7Y2FzZSBpLlRSSUFOR0xFUzp0LnRyaWFuZ2xlcys9byoocy8zKTticmVhaztjYXNlIGkuTElORVM6dC5saW5lcys9byoocy8yKTticmVhaztjYXNlIGkuTElORV9TVFJJUDp0LmxpbmVzKz1vKihzLTEpO2JyZWFrO2Nhc2UgaS5MSU5FX0xPT1A6dC5saW5lcys9bypzO2JyZWFrO2Nhc2UgaS5QT0lOVFM6dC5wb2ludHMrPW8qczticmVhaztkZWZhdWx0OmNvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMSW5mbzogVW5rbm93biBkcmF3IG1vZGU6IixhKTticmVha319ZnVuY3Rpb24gcigpe3QuY2FsbHM9MCx0LnRyaWFuZ2xlcz0wLHQucG9pbnRzPTAsdC5saW5lcz0wfXJldHVybnttZW1vcnk6ZSxyZW5kZXI6dCxwcm9ncmFtczpudWxsLGF1dG9SZXNldDohMCxyZXNldDpyLHVwZGF0ZTpufX1mdW5jdGlvbiBKbChpLGUsdCl7Y29uc3Qgbj1uZXcgV2Vha01hcCxyPW5ldyBydDtmdW5jdGlvbiBzKGEsbyxsKXtjb25zdCBjPWEubW9ycGhUYXJnZXRJbmZsdWVuY2VzLGg9by5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb258fG8ubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbHx8by5tb3JwaEF0dHJpYnV0ZXMuY29sb3IsZD1oIT09dm9pZCAwP2gubGVuZ3RoOjA7bGV0IGY9bi5nZXQobyk7aWYoZj09PXZvaWQgMHx8Zi5jb3VudCE9PWQpe2xldCBFPWZ1bmN0aW9uKCl7Yi5kaXNwb3NlKCksbi5kZWxldGUobyksby5yZW1vdmVFdmVudExpc3RlbmVyKCJkaXNwb3NlIixFKX07ZiE9PXZvaWQgMCYmZi50ZXh0dXJlLmRpc3Bvc2UoKTtjb25zdCBwPW8ubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uIT09dm9pZCAwLF89by5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsIT09dm9pZCAwLHg9by5tb3JwaEF0dHJpYnV0ZXMuY29sb3IhPT12b2lkIDAsbT1vLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbnx8W10sdT1vLm1vcnBoQXR0cmlidXRlcy5ub3JtYWx8fFtdLFQ9by5tb3JwaEF0dHJpYnV0ZXMuY29sb3J8fFtdO2xldCB5PTA7cD09PSEwJiYoeT0xKSxfPT09ITAmJih5PTIpLHg9PT0hMCYmKHk9Myk7bGV0IGc9by5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50KnksUD0xO2c+ZS5tYXhUZXh0dXJlU2l6ZSYmKFA9TWF0aC5jZWlsKGcvZS5tYXhUZXh0dXJlU2l6ZSksZz1lLm1heFRleHR1cmVTaXplKTtjb25zdCB3PW5ldyBGbG9hdDMyQXJyYXkoZypQKjQqZCksYj1uZXcgQ3IodyxnLFAsZCk7Yi50eXBlPTEwMTUsYi5uZWVkc1VwZGF0ZT0hMDtjb25zdCBGPXkqNDtmb3IobGV0IFM9MDtTPGQ7UysrKXtjb25zdCBSPW1bU10scT11W1NdLHo9VFtTXSxXPWcqUCo0KlM7Zm9yKGxldCBaPTA7WjxSLmNvdW50O1orKyl7Y29uc3QgVj1aKkY7cD09PSEwJiYoci5mcm9tQnVmZmVyQXR0cmlidXRlKFIsWiksd1tXK1YrMF09ci54LHdbVytWKzFdPXIueSx3W1crVisyXT1yLnosd1tXK1YrM109MCksXz09PSEwJiYoci5mcm9tQnVmZmVyQXR0cmlidXRlKHEsWiksd1tXK1YrNF09ci54LHdbVytWKzVdPXIueSx3W1crVis2XT1yLnosd1tXK1YrN109MCkseD09PSEwJiYoci5mcm9tQnVmZmVyQXR0cmlidXRlKHosWiksd1tXK1YrOF09ci54LHdbVytWKzldPXIueSx3W1crVisxMF09ci56LHdbVytWKzExXT16Lml0ZW1TaXplPT09ND9yLnc6MSl9fWY9e2NvdW50OmQsdGV4dHVyZTpiLHNpemU6bmV3IFBlKGcsUCl9LG4uc2V0KG8sZiksby5hZGRFdmVudExpc3RlbmVyKCJkaXNwb3NlIixFKX1pZihhLmlzSW5zdGFuY2VkTWVzaD09PSEwJiZhLm1vcnBoVGV4dHVyZSE9PW51bGwpbC5nZXRVbmlmb3JtcygpLnNldFZhbHVlKGksIm1vcnBoVGV4dHVyZSIsYS5tb3JwaFRleHR1cmUsdCk7ZWxzZXtsZXQgcD0wO2ZvcihsZXQgeD0wO3g8Yy5sZW5ndGg7eCsrKXArPWNbeF07Y29uc3QgXz1vLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPzE6MS1wO2wuZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShpLCJtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2UiLF8pLGwuZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShpLCJtb3JwaFRhcmdldEluZmx1ZW5jZXMiLGMpfWwuZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShpLCJtb3JwaFRhcmdldHNUZXh0dXJlIixmLnRleHR1cmUsdCksbC5nZXRVbmlmb3JtcygpLnNldFZhbHVlKGksIm1vcnBoVGFyZ2V0c1RleHR1cmVTaXplIixmLnNpemUpfXJldHVybnt1cGRhdGU6c319ZnVuY3Rpb24gUWwoaSxlLHQsbil7bGV0IHI9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gcyhsKXtjb25zdCBjPW4ucmVuZGVyLmZyYW1lLGg9bC5nZW9tZXRyeSxkPWUuZ2V0KGwsaCk7aWYoci5nZXQoZCkhPT1jJiYoZS51cGRhdGUoZCksci5zZXQoZCxjKSksbC5pc0luc3RhbmNlZE1lc2gmJihsLmhhc0V2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLG8pPT09ITEmJmwuYWRkRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsbyksci5nZXQobCkhPT1jJiYodC51cGRhdGUobC5pbnN0YW5jZU1hdHJpeCxpLkFSUkFZX0JVRkZFUiksbC5pbnN0YW5jZUNvbG9yIT09bnVsbCYmdC51cGRhdGUobC5pbnN0YW5jZUNvbG9yLGkuQVJSQVlfQlVGRkVSKSxyLnNldChsLGMpKSksbC5pc1NraW5uZWRNZXNoKXtjb25zdCBmPWwuc2tlbGV0b247ci5nZXQoZikhPT1jJiYoZi51cGRhdGUoKSxyLnNldChmLGMpKX1yZXR1cm4gZH1mdW5jdGlvbiBhKCl7cj1uZXcgV2Vha01hcH1mdW5jdGlvbiBvKGwpe2NvbnN0IGM9bC50YXJnZXQ7Yy5yZW1vdmVFdmVudExpc3RlbmVyKCJkaXNwb3NlIixvKSx0LnJlbW92ZShjLmluc3RhbmNlTWF0cml4KSxjLmluc3RhbmNlQ29sb3IhPT1udWxsJiZ0LnJlbW92ZShjLmluc3RhbmNlQ29sb3IpfXJldHVybnt1cGRhdGU6cyxkaXNwb3NlOmF9fWNsYXNzIG9zIGV4dGVuZHMgdnR7Y29uc3RydWN0b3IoZSx0LG4scixzLGEsbyxsLGMsaD0xMDI2KXtpZihoIT09MTAyNiYmaCE9PTEwMjcpdGhyb3cgbmV3IEVycm9yKCJEZXB0aFRleHR1cmUgZm9ybWF0IG11c3QgYmUgZWl0aGVyIFRIUkVFLkRlcHRoRm9ybWF0IG9yIFRIUkVFLkRlcHRoU3RlbmNpbEZvcm1hdCIpO249PT12b2lkIDAmJmg9PT0xMDI2JiYobj0xMDE0KSxuPT09dm9pZCAwJiZoPT09MTAyNyYmKG49MTAyMCksc3VwZXIobnVsbCxyLHMsYSxvLGwsaCxuLGMpLHRoaXMuaXNEZXB0aFRleHR1cmU9ITAsdGhpcy5pbWFnZT17d2lkdGg6ZSxoZWlnaHQ6dH0sdGhpcy5tYWdGaWx0ZXI9byE9PXZvaWQgMD9vOjEwMDMsdGhpcy5taW5GaWx0ZXI9bCE9PXZvaWQgMD9sOjEwMDMsdGhpcy5mbGlwWT0hMSx0aGlzLmdlbmVyYXRlTWlwbWFwcz0hMSx0aGlzLmNvbXBhcmVGdW5jdGlvbj1udWxsfWNvcHkoZSl7cmV0dXJuIHN1cGVyLmNvcHkoZSksdGhpcy5jb21wYXJlRnVuY3Rpb249ZS5jb21wYXJlRnVuY3Rpb24sdGhpc310b0pTT04oZSl7Y29uc3QgdD1zdXBlci50b0pTT04oZSk7cmV0dXJuIHRoaXMuY29tcGFyZUZ1bmN0aW9uIT09bnVsbCYmKHQuY29tcGFyZUZ1bmN0aW9uPXRoaXMuY29tcGFyZUZ1bmN0aW9uKSx0fX1jb25zdCBscz1uZXcgdnQsY3M9bmV3IG9zKDEsMSksdXM9bmV3IENyLGhzPW5ldyB2YSxkcz1uZXcganIsZnM9W10scHM9W10sbXM9bmV3IEZsb2F0MzJBcnJheSgxNiksZ3M9bmV3IEZsb2F0MzJBcnJheSg5KSxfcz1uZXcgRmxvYXQzMkFycmF5KDQpO2Z1bmN0aW9uIHpuKGksZSx0KXtjb25zdCBuPWlbMF07aWYobjw9MHx8bj4wKXJldHVybiBpO2NvbnN0IHI9ZSp0O2xldCBzPWZzW3JdO2lmKHM9PT12b2lkIDAmJihzPW5ldyBGbG9hdDMyQXJyYXkociksZnNbcl09cyksZSE9PTApe24udG9BcnJheShzLDApO2ZvcihsZXQgYT0xLG89MDthIT09ZTsrK2Epbys9dCxpW2FdLnRvQXJyYXkocyxvKX1yZXR1cm4gc31mdW5jdGlvbiBjdChpLGUpe2lmKGkubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCB0PTAsbj1pLmxlbmd0aDt0PG47dCsrKWlmKGlbdF0hPT1lW3RdKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIHV0KGksZSl7Zm9yKGxldCB0PTAsbj1lLmxlbmd0aDt0PG47dCsrKWlbdF09ZVt0XX1mdW5jdGlvbiBBaShpLGUpe2xldCB0PXBzW2VdO3Q9PT12b2lkIDAmJih0PW5ldyBJbnQzMkFycmF5KGUpLHBzW2VdPXQpO2ZvcihsZXQgbj0wO24hPT1lOysrbil0W25dPWkuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO3JldHVybiB0fWZ1bmN0aW9uIGVjKGksZSl7Y29uc3QgdD10aGlzLmNhY2hlO3RbMF0hPT1lJiYoaS51bmlmb3JtMWYodGhpcy5hZGRyLGUpLHRbMF09ZSl9ZnVuY3Rpb24gdGMoaSxlKXtjb25zdCB0PXRoaXMuY2FjaGU7aWYoZS54IT09dm9pZCAwKSh0WzBdIT09ZS54fHx0WzFdIT09ZS55KSYmKGkudW5pZm9ybTJmKHRoaXMuYWRkcixlLngsZS55KSx0WzBdPWUueCx0WzFdPWUueSk7ZWxzZXtpZihjdCh0LGUpKXJldHVybjtpLnVuaWZvcm0yZnYodGhpcy5hZGRyLGUpLHV0KHQsZSl9fWZ1bmN0aW9uIG5jKGksZSl7Y29uc3QgdD10aGlzLmNhY2hlO2lmKGUueCE9PXZvaWQgMCkodFswXSE9PWUueHx8dFsxXSE9PWUueXx8dFsyXSE9PWUueikmJihpLnVuaWZvcm0zZih0aGlzLmFkZHIsZS54LGUueSxlLnopLHRbMF09ZS54LHRbMV09ZS55LHRbMl09ZS56KTtlbHNlIGlmKGUuciE9PXZvaWQgMCkodFswXSE9PWUucnx8dFsxXSE9PWUuZ3x8dFsyXSE9PWUuYikmJihpLnVuaWZvcm0zZih0aGlzLmFkZHIsZS5yLGUuZyxlLmIpLHRbMF09ZS5yLHRbMV09ZS5nLHRbMl09ZS5iKTtlbHNle2lmKGN0KHQsZSkpcmV0dXJuO2kudW5pZm9ybTNmdih0aGlzLmFkZHIsZSksdXQodCxlKX19ZnVuY3Rpb24gaWMoaSxlKXtjb25zdCB0PXRoaXMuY2FjaGU7aWYoZS54IT09dm9pZCAwKSh0WzBdIT09ZS54fHx0WzFdIT09ZS55fHx0WzJdIT09ZS56fHx0WzNdIT09ZS53KSYmKGkudW5pZm9ybTRmKHRoaXMuYWRkcixlLngsZS55LGUueixlLncpLHRbMF09ZS54LHRbMV09ZS55LHRbMl09ZS56LHRbM109ZS53KTtlbHNle2lmKGN0KHQsZSkpcmV0dXJuO2kudW5pZm9ybTRmdih0aGlzLmFkZHIsZSksdXQodCxlKX19ZnVuY3Rpb24gcmMoaSxlKXtjb25zdCB0PXRoaXMuY2FjaGUsbj1lLmVsZW1lbnRzO2lmKG49PT12b2lkIDApe2lmKGN0KHQsZSkpcmV0dXJuO2kudW5pZm9ybU1hdHJpeDJmdih0aGlzLmFkZHIsITEsZSksdXQodCxlKX1lbHNle2lmKGN0KHQsbikpcmV0dXJuO19zLnNldChuKSxpLnVuaWZvcm1NYXRyaXgyZnYodGhpcy5hZGRyLCExLF9zKSx1dCh0LG4pfX1mdW5jdGlvbiBzYyhpLGUpe2NvbnN0IHQ9dGhpcy5jYWNoZSxuPWUuZWxlbWVudHM7aWYobj09PXZvaWQgMCl7aWYoY3QodCxlKSlyZXR1cm47aS51bmlmb3JtTWF0cml4M2Z2KHRoaXMuYWRkciwhMSxlKSx1dCh0LGUpfWVsc2V7aWYoY3QodCxuKSlyZXR1cm47Z3Muc2V0KG4pLGkudW5pZm9ybU1hdHJpeDNmdih0aGlzLmFkZHIsITEsZ3MpLHV0KHQsbil9fWZ1bmN0aW9uIGFjKGksZSl7Y29uc3QgdD10aGlzLmNhY2hlLG49ZS5lbGVtZW50cztpZihuPT09dm9pZCAwKXtpZihjdCh0LGUpKXJldHVybjtpLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5hZGRyLCExLGUpLHV0KHQsZSl9ZWxzZXtpZihjdCh0LG4pKXJldHVybjttcy5zZXQobiksaS51bmlmb3JtTWF0cml4NGZ2KHRoaXMuYWRkciwhMSxtcyksdXQodCxuKX19ZnVuY3Rpb24gb2MoaSxlKXtjb25zdCB0PXRoaXMuY2FjaGU7dFswXSE9PWUmJihpLnVuaWZvcm0xaSh0aGlzLmFkZHIsZSksdFswXT1lKX1mdW5jdGlvbiBsYyhpLGUpe2NvbnN0IHQ9dGhpcy5jYWNoZTtpZihlLnghPT12b2lkIDApKHRbMF0hPT1lLnh8fHRbMV0hPT1lLnkpJiYoaS51bmlmb3JtMmkodGhpcy5hZGRyLGUueCxlLnkpLHRbMF09ZS54LHRbMV09ZS55KTtlbHNle2lmKGN0KHQsZSkpcmV0dXJuO2kudW5pZm9ybTJpdih0aGlzLmFkZHIsZSksdXQodCxlKX19ZnVuY3Rpb24gY2MoaSxlKXtjb25zdCB0PXRoaXMuY2FjaGU7aWYoZS54IT09dm9pZCAwKSh0WzBdIT09ZS54fHx0WzFdIT09ZS55fHx0WzJdIT09ZS56KSYmKGkudW5pZm9ybTNpKHRoaXMuYWRkcixlLngsZS55LGUueiksdFswXT1lLngsdFsxXT1lLnksdFsyXT1lLnopO2Vsc2V7aWYoY3QodCxlKSlyZXR1cm47aS51bmlmb3JtM2l2KHRoaXMuYWRkcixlKSx1dCh0LGUpfX1mdW5jdGlvbiB1YyhpLGUpe2NvbnN0IHQ9dGhpcy5jYWNoZTtpZihlLnghPT12b2lkIDApKHRbMF0hPT1lLnh8fHRbMV0hPT1lLnl8fHRbMl0hPT1lLnp8fHRbM10hPT1lLncpJiYoaS51bmlmb3JtNGkodGhpcy5hZGRyLGUueCxlLnksZS56LGUudyksdFswXT1lLngsdFsxXT1lLnksdFsyXT1lLnosdFszXT1lLncpO2Vsc2V7aWYoY3QodCxlKSlyZXR1cm47aS51bmlmb3JtNGl2KHRoaXMuYWRkcixlKSx1dCh0LGUpfX1mdW5jdGlvbiBoYyhpLGUpe2NvbnN0IHQ9dGhpcy5jYWNoZTt0WzBdIT09ZSYmKGkudW5pZm9ybTF1aSh0aGlzLmFkZHIsZSksdFswXT1lKX1mdW5jdGlvbiBkYyhpLGUpe2NvbnN0IHQ9dGhpcy5jYWNoZTtpZihlLnghPT12b2lkIDApKHRbMF0hPT1lLnh8fHRbMV0hPT1lLnkpJiYoaS51bmlmb3JtMnVpKHRoaXMuYWRkcixlLngsZS55KSx0WzBdPWUueCx0WzFdPWUueSk7ZWxzZXtpZihjdCh0LGUpKXJldHVybjtpLnVuaWZvcm0ydWl2KHRoaXMuYWRkcixlKSx1dCh0LGUpfX1mdW5jdGlvbiBmYyhpLGUpe2NvbnN0IHQ9dGhpcy5jYWNoZTtpZihlLnghPT12b2lkIDApKHRbMF0hPT1lLnh8fHRbMV0hPT1lLnl8fHRbMl0hPT1lLnopJiYoaS51bmlmb3JtM3VpKHRoaXMuYWRkcixlLngsZS55LGUueiksdFswXT1lLngsdFsxXT1lLnksdFsyXT1lLnopO2Vsc2V7aWYoY3QodCxlKSlyZXR1cm47aS51bmlmb3JtM3Vpdih0aGlzLmFkZHIsZSksdXQodCxlKX19ZnVuY3Rpb24gcGMoaSxlKXtjb25zdCB0PXRoaXMuY2FjaGU7aWYoZS54IT09dm9pZCAwKSh0WzBdIT09ZS54fHx0WzFdIT09ZS55fHx0WzJdIT09ZS56fHx0WzNdIT09ZS53KSYmKGkudW5pZm9ybTR1aSh0aGlzLmFkZHIsZS54LGUueSxlLnosZS53KSx0WzBdPWUueCx0WzFdPWUueSx0WzJdPWUueix0WzNdPWUudyk7ZWxzZXtpZihjdCh0LGUpKXJldHVybjtpLnVuaWZvcm00dWl2KHRoaXMuYWRkcixlKSx1dCh0LGUpfX1mdW5jdGlvbiBtYyhpLGUsdCl7Y29uc3Qgbj10aGlzLmNhY2hlLHI9dC5hbGxvY2F0ZVRleHR1cmVVbml0KCk7blswXSE9PXImJihpLnVuaWZvcm0xaSh0aGlzLmFkZHIsciksblswXT1yKTtsZXQgczt0aGlzLnR5cGU9PT1pLlNBTVBMRVJfMkRfU0hBRE9XPyhjcy5jb21wYXJlRnVuY3Rpb249NTE1LHM9Y3MpOnM9bHMsdC5zZXRUZXh0dXJlMkQoZXx8cyxyKX1mdW5jdGlvbiBnYyhpLGUsdCl7Y29uc3Qgbj10aGlzLmNhY2hlLHI9dC5hbGxvY2F0ZVRleHR1cmVVbml0KCk7blswXSE9PXImJihpLnVuaWZvcm0xaSh0aGlzLmFkZHIsciksblswXT1yKSx0LnNldFRleHR1cmUzRChlfHxocyxyKX1mdW5jdGlvbiBfYyhpLGUsdCl7Y29uc3Qgbj10aGlzLmNhY2hlLHI9dC5hbGxvY2F0ZVRleHR1cmVVbml0KCk7blswXSE9PXImJihpLnVuaWZvcm0xaSh0aGlzLmFkZHIsciksblswXT1yKSx0LnNldFRleHR1cmVDdWJlKGV8fGRzLHIpfWZ1bmN0aW9uIHZjKGksZSx0KXtjb25zdCBuPXRoaXMuY2FjaGUscj10LmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtuWzBdIT09ciYmKGkudW5pZm9ybTFpKHRoaXMuYWRkcixyKSxuWzBdPXIpLHQuc2V0VGV4dHVyZTJEQXJyYXkoZXx8dXMscil9ZnVuY3Rpb24geGMoaSl7c3dpdGNoKGkpe2Nhc2UgNTEyNjpyZXR1cm4gZWM7Y2FzZSAzNTY2NDpyZXR1cm4gdGM7Y2FzZSAzNTY2NTpyZXR1cm4gbmM7Y2FzZSAzNTY2NjpyZXR1cm4gaWM7Y2FzZSAzNTY3NDpyZXR1cm4gcmM7Y2FzZSAzNTY3NTpyZXR1cm4gc2M7Y2FzZSAzNTY3NjpyZXR1cm4gYWM7Y2FzZSA1MTI0OmNhc2UgMzU2NzA6cmV0dXJuIG9jO2Nhc2UgMzU2Njc6Y2FzZSAzNTY3MTpyZXR1cm4gbGM7Y2FzZSAzNTY2ODpjYXNlIDM1NjcyOnJldHVybiBjYztjYXNlIDM1NjY5OmNhc2UgMzU2NzM6cmV0dXJuIHVjO2Nhc2UgNTEyNTpyZXR1cm4gaGM7Y2FzZSAzNjI5NDpyZXR1cm4gZGM7Y2FzZSAzNjI5NTpyZXR1cm4gZmM7Y2FzZSAzNjI5NjpyZXR1cm4gcGM7Y2FzZSAzNTY3ODpjYXNlIDM2MTk4OmNhc2UgMzYyOTg6Y2FzZSAzNjMwNjpjYXNlIDM1NjgyOnJldHVybiBtYztjYXNlIDM1Njc5OmNhc2UgMzYyOTk6Y2FzZSAzNjMwNzpyZXR1cm4gZ2M7Y2FzZSAzNTY4MDpjYXNlIDM2MzAwOmNhc2UgMzYzMDg6Y2FzZSAzNjI5MzpyZXR1cm4gX2M7Y2FzZSAzNjI4OTpjYXNlIDM2MzAzOmNhc2UgMzYzMTE6Y2FzZSAzNjI5MjpyZXR1cm4gdmN9fWZ1bmN0aW9uIE1jKGksZSl7aS51bmlmb3JtMWZ2KHRoaXMuYWRkcixlKX1mdW5jdGlvbiBTYyhpLGUpe2NvbnN0IHQ9em4oZSx0aGlzLnNpemUsMik7aS51bmlmb3JtMmZ2KHRoaXMuYWRkcix0KX1mdW5jdGlvbiBFYyhpLGUpe2NvbnN0IHQ9em4oZSx0aGlzLnNpemUsMyk7aS51bmlmb3JtM2Z2KHRoaXMuYWRkcix0KX1mdW5jdGlvbiB5YyhpLGUpe2NvbnN0IHQ9em4oZSx0aGlzLnNpemUsNCk7aS51bmlmb3JtNGZ2KHRoaXMuYWRkcix0KX1mdW5jdGlvbiBUYyhpLGUpe2NvbnN0IHQ9em4oZSx0aGlzLnNpemUsNCk7aS51bmlmb3JtTWF0cml4MmZ2KHRoaXMuYWRkciwhMSx0KX1mdW5jdGlvbiBBYyhpLGUpe2NvbnN0IHQ9em4oZSx0aGlzLnNpemUsOSk7aS51bmlmb3JtTWF0cml4M2Z2KHRoaXMuYWRkciwhMSx0KX1mdW5jdGlvbiB3YyhpLGUpe2NvbnN0IHQ9em4oZSx0aGlzLnNpemUsMTYpO2kudW5pZm9ybU1hdHJpeDRmdih0aGlzLmFkZHIsITEsdCl9ZnVuY3Rpb24gYmMoaSxlKXtpLnVuaWZvcm0xaXYodGhpcy5hZGRyLGUpfWZ1bmN0aW9uIFJjKGksZSl7aS51bmlmb3JtMml2KHRoaXMuYWRkcixlKX1mdW5jdGlvbiBDYyhpLGUpe2kudW5pZm9ybTNpdih0aGlzLmFkZHIsZSl9ZnVuY3Rpb24gUGMoaSxlKXtpLnVuaWZvcm00aXYodGhpcy5hZGRyLGUpfWZ1bmN0aW9uIERjKGksZSl7aS51bmlmb3JtMXVpdih0aGlzLmFkZHIsZSl9ZnVuY3Rpb24gTGMoaSxlKXtpLnVuaWZvcm0ydWl2KHRoaXMuYWRkcixlKX1mdW5jdGlvbiBVYyhpLGUpe2kudW5pZm9ybTN1aXYodGhpcy5hZGRyLGUpfWZ1bmN0aW9uIEZjKGksZSl7aS51bmlmb3JtNHVpdih0aGlzLmFkZHIsZSl9ZnVuY3Rpb24gSWMoaSxlLHQpe2NvbnN0IG49dGhpcy5jYWNoZSxyPWUubGVuZ3RoLHM9QWkodCxyKTtjdChuLHMpfHwoaS51bmlmb3JtMWl2KHRoaXMuYWRkcixzKSx1dChuLHMpKTtmb3IobGV0IGE9MDthIT09cjsrK2EpdC5zZXRUZXh0dXJlMkQoZVthXXx8bHMsc1thXSl9ZnVuY3Rpb24gTmMoaSxlLHQpe2NvbnN0IG49dGhpcy5jYWNoZSxyPWUubGVuZ3RoLHM9QWkodCxyKTtjdChuLHMpfHwoaS51bmlmb3JtMWl2KHRoaXMuYWRkcixzKSx1dChuLHMpKTtmb3IobGV0IGE9MDthIT09cjsrK2EpdC5zZXRUZXh0dXJlM0QoZVthXXx8aHMsc1thXSl9ZnVuY3Rpb24gT2MoaSxlLHQpe2NvbnN0IG49dGhpcy5jYWNoZSxyPWUubGVuZ3RoLHM9QWkodCxyKTtjdChuLHMpfHwoaS51bmlmb3JtMWl2KHRoaXMuYWRkcixzKSx1dChuLHMpKTtmb3IobGV0IGE9MDthIT09cjsrK2EpdC5zZXRUZXh0dXJlQ3ViZShlW2FdfHxkcyxzW2FdKX1mdW5jdGlvbiBCYyhpLGUsdCl7Y29uc3Qgbj10aGlzLmNhY2hlLHI9ZS5sZW5ndGgscz1BaSh0LHIpO2N0KG4scyl8fChpLnVuaWZvcm0xaXYodGhpcy5hZGRyLHMpLHV0KG4scykpO2ZvcihsZXQgYT0wO2EhPT1yOysrYSl0LnNldFRleHR1cmUyREFycmF5KGVbYV18fHVzLHNbYV0pfWZ1bmN0aW9uIHpjKGkpe3N3aXRjaChpKXtjYXNlIDUxMjY6cmV0dXJuIE1jO2Nhc2UgMzU2NjQ6cmV0dXJuIFNjO2Nhc2UgMzU2NjU6cmV0dXJuIEVjO2Nhc2UgMzU2NjY6cmV0dXJuIHljO2Nhc2UgMzU2NzQ6cmV0dXJuIFRjO2Nhc2UgMzU2NzU6cmV0dXJuIEFjO2Nhc2UgMzU2NzY6cmV0dXJuIHdjO2Nhc2UgNTEyNDpjYXNlIDM1NjcwOnJldHVybiBiYztjYXNlIDM1NjY3OmNhc2UgMzU2NzE6cmV0dXJuIFJjO2Nhc2UgMzU2Njg6Y2FzZSAzNTY3MjpyZXR1cm4gQ2M7Y2FzZSAzNTY2OTpjYXNlIDM1NjczOnJldHVybiBQYztjYXNlIDUxMjU6cmV0dXJuIERjO2Nhc2UgMzYyOTQ6cmV0dXJuIExjO2Nhc2UgMzYyOTU6cmV0dXJuIFVjO2Nhc2UgMzYyOTY6cmV0dXJuIEZjO2Nhc2UgMzU2Nzg6Y2FzZSAzNjE5ODpjYXNlIDM2Mjk4OmNhc2UgMzYzMDY6Y2FzZSAzNTY4MjpyZXR1cm4gSWM7Y2FzZSAzNTY3OTpjYXNlIDM2Mjk5OmNhc2UgMzYzMDc6cmV0dXJuIE5jO2Nhc2UgMzU2ODA6Y2FzZSAzNjMwMDpjYXNlIDM2MzA4OmNhc2UgMzYyOTM6cmV0dXJuIE9jO2Nhc2UgMzYyODk6Y2FzZSAzNjMwMzpjYXNlIDM2MzExOmNhc2UgMzYyOTI6cmV0dXJuIEJjfX1jbGFzcyBHY3tjb25zdHJ1Y3RvcihlLHQsbil7dGhpcy5pZD1lLHRoaXMuYWRkcj1uLHRoaXMuY2FjaGU9W10sdGhpcy50eXBlPXQudHlwZSx0aGlzLnNldFZhbHVlPXhjKHQudHlwZSl9fWNsYXNzIEhje2NvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLmlkPWUsdGhpcy5hZGRyPW4sdGhpcy5jYWNoZT1bXSx0aGlzLnR5cGU9dC50eXBlLHRoaXMuc2l6ZT10LnNpemUsdGhpcy5zZXRWYWx1ZT16Yyh0LnR5cGUpfX1jbGFzcyBWY3tjb25zdHJ1Y3RvcihlKXt0aGlzLmlkPWUsdGhpcy5zZXE9W10sdGhpcy5tYXA9e319c2V0VmFsdWUoZSx0LG4pe2NvbnN0IHI9dGhpcy5zZXE7Zm9yKGxldCBzPTAsYT1yLmxlbmd0aDtzIT09YTsrK3Mpe2NvbnN0IG89cltzXTtvLnNldFZhbHVlKGUsdFtvLmlkXSxuKX19fWNvbnN0IGhyPS8oXHcrKShcXSk/KFxbfFwuKT8vZztmdW5jdGlvbiB2cyhpLGUpe2kuc2VxLnB1c2goZSksaS5tYXBbZS5pZF09ZX1mdW5jdGlvbiBrYyhpLGUsdCl7Y29uc3Qgbj1pLm5hbWUscj1uLmxlbmd0aDtmb3IoaHIubGFzdEluZGV4PTA7Oyl7Y29uc3Qgcz1oci5leGVjKG4pLGE9aHIubGFzdEluZGV4O2xldCBvPXNbMV07Y29uc3QgbD1zWzJdPT09Il0iLGM9c1szXTtpZihsJiYobz1vfDApLGM9PT12b2lkIDB8fGM9PT0iWyImJmErMj09PXIpe3ZzKHQsYz09PXZvaWQgMD9uZXcgR2MobyxpLGUpOm5ldyBIYyhvLGksZSkpO2JyZWFrfWVsc2V7bGV0IGQ9dC5tYXBbb107ZD09PXZvaWQgMCYmKGQ9bmV3IFZjKG8pLHZzKHQsZCkpLHQ9ZH19fWNsYXNzIHdpe2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5zZXE9W10sdGhpcy5tYXA9e307Y29uc3Qgbj1lLmdldFByb2dyYW1QYXJhbWV0ZXIodCxlLkFDVElWRV9VTklGT1JNUyk7Zm9yKGxldCByPTA7cjxuOysrcil7Y29uc3Qgcz1lLmdldEFjdGl2ZVVuaWZvcm0odCxyKSxhPWUuZ2V0VW5pZm9ybUxvY2F0aW9uKHQscy5uYW1lKTtrYyhzLGEsdGhpcyl9fXNldFZhbHVlKGUsdCxuLHIpe2NvbnN0IHM9dGhpcy5tYXBbdF07cyE9PXZvaWQgMCYmcy5zZXRWYWx1ZShlLG4scil9c2V0T3B0aW9uYWwoZSx0LG4pe2NvbnN0IHI9dFtuXTtyIT09dm9pZCAwJiZ0aGlzLnNldFZhbHVlKGUsbixyKX1zdGF0aWMgdXBsb2FkKGUsdCxuLHIpe2ZvcihsZXQgcz0wLGE9dC5sZW5ndGg7cyE9PWE7KytzKXtjb25zdCBvPXRbc10sbD1uW28uaWRdO2wubmVlZHNVcGRhdGUhPT0hMSYmby5zZXRWYWx1ZShlLGwudmFsdWUscil9fXN0YXRpYyBzZXFXaXRoVmFsdWUoZSx0KXtjb25zdCBuPVtdO2ZvcihsZXQgcj0wLHM9ZS5sZW5ndGg7ciE9PXM7KytyKXtjb25zdCBhPWVbcl07YS5pZCBpbiB0JiZuLnB1c2goYSl9cmV0dXJuIG59fWZ1bmN0aW9uIHhzKGksZSx0KXtjb25zdCBuPWkuY3JlYXRlU2hhZGVyKGUpO3JldHVybiBpLnNoYWRlclNvdXJjZShuLHQpLGkuY29tcGlsZVNoYWRlcihuKSxufWNvbnN0IFdjPTM3Mjk3O2xldCBYYz0wO2Z1bmN0aW9uIHFjKGksZSl7Y29uc3QgdD1pLnNwbGl0KGAKYCksbj1bXSxyPU1hdGgubWF4KGUtNiwwKSxzPU1hdGgubWluKGUrNix0Lmxlbmd0aCk7Zm9yKGxldCBhPXI7YTxzO2ErKyl7Y29uc3Qgbz1hKzE7bi5wdXNoKGAke289PT1lPyI+IjoiICJ9ICR7b306ICR7dFthXX1gKX1yZXR1cm4gbi5qb2luKGAKYCl9Y29uc3QgTXM9bmV3IGJlO2Z1bmN0aW9uIFljKGkpe0JlLl9nZXRNYXRyaXgoTXMsQmUud29ya2luZ0NvbG9yU3BhY2UsaSk7Y29uc3QgZT1gbWF0MyggJHtNcy5lbGVtZW50cy5tYXAodD0+dC50b0ZpeGVkKDQpKX0gKWA7c3dpdGNoKEJlLmdldFRyYW5zZmVyKGkpKXtjYXNlIGlpOnJldHVybltlLCJMaW5lYXJUcmFuc2Zlck9FVEYiXTtjYXNlIHFlOnJldHVybltlLCJzUkdCVHJhbnNmZXJPRVRGIl07ZGVmYXVsdDpyZXR1cm4gY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFByb2dyYW06IFVuc3VwcG9ydGVkIGNvbG9yIHNwYWNlOiAiLGkpLFtlLCJMaW5lYXJUcmFuc2Zlck9FVEYiXX19ZnVuY3Rpb24gU3MoaSxlLHQpe2NvbnN0IG49aS5nZXRTaGFkZXJQYXJhbWV0ZXIoZSxpLkNPTVBJTEVfU1RBVFVTKSxyPWkuZ2V0U2hhZGVySW5mb0xvZyhlKS50cmltKCk7aWYobiYmcj09PSIiKXJldHVybiIiO2NvbnN0IHM9L0VSUk9SOiAwOihcZCspLy5leGVjKHIpO2lmKHMpe2NvbnN0IGE9cGFyc2VJbnQoc1sxXSk7cmV0dXJuIHQudG9VcHBlckNhc2UoKStgCgpgK3IrYAoKYCtxYyhpLmdldFNoYWRlclNvdXJjZShlKSxhKX1lbHNlIHJldHVybiByfWZ1bmN0aW9uICRjKGksZSl7Y29uc3QgdD1ZYyhlKTtyZXR1cm5bYHZlYzQgJHtpfSggdmVjNCB2YWx1ZSApIHtgLGAJcmV0dXJuICR7dFsxXX0oIHZlYzQoIHZhbHVlLnJnYiAqICR7dFswXX0sIHZhbHVlLmEgKSApO2AsIn0iXS5qb2luKGAKYCl9ZnVuY3Rpb24gS2MoaSxlKXtsZXQgdDtzd2l0Y2goZSl7Y2FzZSAxOnQ9IkxpbmVhciI7YnJlYWs7Y2FzZSAyOnQ9IlJlaW5oYXJkIjticmVhaztjYXNlIDM6dD0iQ2luZW9uIjticmVhaztjYXNlIDQ6dD0iQUNFU0ZpbG1pYyI7YnJlYWs7Y2FzZSA2OnQ9IkFnWCI7YnJlYWs7Y2FzZSA3OnQ9Ik5ldXRyYWwiO2JyZWFrO2Nhc2UgNTp0PSJDdXN0b20iO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFByb2dyYW06IFVuc3VwcG9ydGVkIHRvbmVNYXBwaW5nOiIsZSksdD0iTGluZWFyIn1yZXR1cm4idmVjMyAiK2krIiggdmVjMyBjb2xvciApIHsgcmV0dXJuICIrdCsiVG9uZU1hcHBpbmcoIGNvbG9yICk7IH0ifWNvbnN0IGJpPW5ldyBPO2Z1bmN0aW9uIFpjKCl7QmUuZ2V0THVtaW5hbmNlQ29lZmZpY2llbnRzKGJpKTtjb25zdCBpPWJpLngudG9GaXhlZCg0KSxlPWJpLnkudG9GaXhlZCg0KSx0PWJpLnoudG9GaXhlZCg0KTtyZXR1cm5bImZsb2F0IGx1bWluYW5jZSggY29uc3QgaW4gdmVjMyByZ2IgKSB7IixgCWNvbnN0IHZlYzMgd2VpZ2h0cyA9IHZlYzMoICR7aX0sICR7ZX0sICR7dH0gKTtgLCIJcmV0dXJuIGRvdCggd2VpZ2h0cywgcmdiICk7IiwifSJdLmpvaW4oYApgKX1mdW5jdGlvbiBqYyhpKXtyZXR1cm5baS5leHRlbnNpb25DbGlwQ3VsbERpc3RhbmNlPyIjZXh0ZW5zaW9uIEdMX0FOR0xFX2NsaXBfY3VsbF9kaXN0YW5jZSA6IHJlcXVpcmUiOiIiLGkuZXh0ZW5zaW9uTXVsdGlEcmF3PyIjZXh0ZW5zaW9uIEdMX0FOR0xFX211bHRpX2RyYXcgOiByZXF1aXJlIjoiIl0uZmlsdGVyKGVpKS5qb2luKGAKYCl9ZnVuY3Rpb24gSmMoaSl7Y29uc3QgZT1bXTtmb3IoY29uc3QgdCBpbiBpKXtjb25zdCBuPWlbdF07biE9PSExJiZlLnB1c2goIiNkZWZpbmUgIit0KyIgIituKX1yZXR1cm4gZS5qb2luKGAKYCl9ZnVuY3Rpb24gUWMoaSxlKXtjb25zdCB0PXt9LG49aS5nZXRQcm9ncmFtUGFyYW1ldGVyKGUsaS5BQ1RJVkVfQVRUUklCVVRFUyk7Zm9yKGxldCByPTA7cjxuO3IrKyl7Y29uc3Qgcz1pLmdldEFjdGl2ZUF0dHJpYihlLHIpLGE9cy5uYW1lO2xldCBvPTE7cy50eXBlPT09aS5GTE9BVF9NQVQyJiYobz0yKSxzLnR5cGU9PT1pLkZMT0FUX01BVDMmJihvPTMpLHMudHlwZT09PWkuRkxPQVRfTUFUNCYmKG89NCksdFthXT17dHlwZTpzLnR5cGUsbG9jYXRpb246aS5nZXRBdHRyaWJMb2NhdGlvbihlLGEpLGxvY2F0aW9uU2l6ZTpvfX1yZXR1cm4gdH1mdW5jdGlvbiBlaShpKXtyZXR1cm4gaSE9PSIifWZ1bmN0aW9uIEVzKGksZSl7Y29uc3QgdD1lLm51bVNwb3RMaWdodFNoYWRvd3MrZS5udW1TcG90TGlnaHRNYXBzLWUubnVtU3BvdExpZ2h0U2hhZG93c1dpdGhNYXBzO3JldHVybiBpLnJlcGxhY2UoL05VTV9ESVJfTElHSFRTL2csZS5udW1EaXJMaWdodHMpLnJlcGxhY2UoL05VTV9TUE9UX0xJR0hUUy9nLGUubnVtU3BvdExpZ2h0cykucmVwbGFjZSgvTlVNX1NQT1RfTElHSFRfTUFQUy9nLGUubnVtU3BvdExpZ2h0TWFwcykucmVwbGFjZSgvTlVNX1NQT1RfTElHSFRfQ09PUkRTL2csdCkucmVwbGFjZSgvTlVNX1JFQ1RfQVJFQV9MSUdIVFMvZyxlLm51bVJlY3RBcmVhTGlnaHRzKS5yZXBsYWNlKC9OVU1fUE9JTlRfTElHSFRTL2csZS5udW1Qb2ludExpZ2h0cykucmVwbGFjZSgvTlVNX0hFTUlfTElHSFRTL2csZS5udW1IZW1pTGlnaHRzKS5yZXBsYWNlKC9OVU1fRElSX0xJR0hUX1NIQURPV1MvZyxlLm51bURpckxpZ2h0U2hhZG93cykucmVwbGFjZSgvTlVNX1NQT1RfTElHSFRfU0hBRE9XU19XSVRIX01BUFMvZyxlLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcykucmVwbGFjZSgvTlVNX1NQT1RfTElHSFRfU0hBRE9XUy9nLGUubnVtU3BvdExpZ2h0U2hhZG93cykucmVwbGFjZSgvTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MvZyxlLm51bVBvaW50TGlnaHRTaGFkb3dzKX1mdW5jdGlvbiB5cyhpLGUpe3JldHVybiBpLnJlcGxhY2UoL05VTV9DTElQUElOR19QTEFORVMvZyxlLm51bUNsaXBwaW5nUGxhbmVzKS5yZXBsYWNlKC9VTklPTl9DTElQUElOR19QTEFORVMvZyxlLm51bUNsaXBwaW5nUGxhbmVzLWUubnVtQ2xpcEludGVyc2VjdGlvbil9Y29uc3QgZXU9L15bIFx0XSojaW5jbHVkZSArPChbXHdcZC4vXSspPi9nbTtmdW5jdGlvbiBkcihpKXtyZXR1cm4gaS5yZXBsYWNlKGV1LG51KX1jb25zdCB0dT1uZXcgTWFwO2Z1bmN0aW9uIG51KGksZSl7bGV0IHQ9RGVbZV07aWYodD09PXZvaWQgMCl7Y29uc3Qgbj10dS5nZXQoZSk7aWYobiE9PXZvaWQgMCl0PURlW25dLGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogU2hhZGVyIGNodW5rICIlcyIgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlICIlcyIgaW5zdGVhZC4nLGUsbik7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIkNhbiBub3QgcmVzb2x2ZSAjaW5jbHVkZSA8IitlKyI+Iil9cmV0dXJuIGRyKHQpfWNvbnN0IGl1PS8jcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XHMrZm9yXHMqXChccyppbnRccytpXHMqPVxzKihcZCspXHMqO1xzKmlccyo8XHMqKFxkKylccyo7XHMqaVxzKlwrXCtccypcKVxzKnsoW1xzXFNdKz8pfVxzKyNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kL2c7ZnVuY3Rpb24gVHMoaSl7cmV0dXJuIGkucmVwbGFjZShpdSxydSl9ZnVuY3Rpb24gcnUoaSxlLHQsbil7bGV0IHI9IiI7Zm9yKGxldCBzPXBhcnNlSW50KGUpO3M8cGFyc2VJbnQodCk7cysrKXIrPW4ucmVwbGFjZSgvXFtccyppXHMqXF0vZywiWyAiK3MrIiBdIikucmVwbGFjZSgvVU5ST0xMRURfTE9PUF9JTkRFWC9nLHMpO3JldHVybiByfWZ1bmN0aW9uIEFzKGkpe2xldCBlPWBwcmVjaXNpb24gJHtpLnByZWNpc2lvbn0gZmxvYXQ7CglwcmVjaXNpb24gJHtpLnByZWNpc2lvbn0gaW50OwoJcHJlY2lzaW9uICR7aS5wcmVjaXNpb259IHNhbXBsZXIyRDsKCXByZWNpc2lvbiAke2kucHJlY2lzaW9ufSBzYW1wbGVyQ3ViZTsKCXByZWNpc2lvbiAke2kucHJlY2lzaW9ufSBzYW1wbGVyM0Q7CglwcmVjaXNpb24gJHtpLnByZWNpc2lvbn0gc2FtcGxlcjJEQXJyYXk7CglwcmVjaXNpb24gJHtpLnByZWNpc2lvbn0gc2FtcGxlcjJEU2hhZG93OwoJcHJlY2lzaW9uICR7aS5wcmVjaXNpb259IHNhbXBsZXJDdWJlU2hhZG93OwoJcHJlY2lzaW9uICR7aS5wcmVjaXNpb259IHNhbXBsZXIyREFycmF5U2hhZG93OwoJcHJlY2lzaW9uICR7aS5wcmVjaXNpb259IGlzYW1wbGVyMkQ7CglwcmVjaXNpb24gJHtpLnByZWNpc2lvbn0gaXNhbXBsZXIzRDsKCXByZWNpc2lvbiAke2kucHJlY2lzaW9ufSBpc2FtcGxlckN1YmU7CglwcmVjaXNpb24gJHtpLnByZWNpc2lvbn0gaXNhbXBsZXIyREFycmF5OwoJcHJlY2lzaW9uICR7aS5wcmVjaXNpb259IHVzYW1wbGVyMkQ7CglwcmVjaXNpb24gJHtpLnByZWNpc2lvbn0gdXNhbXBsZXIzRDsKCXByZWNpc2lvbiAke2kucHJlY2lzaW9ufSB1c2FtcGxlckN1YmU7CglwcmVjaXNpb24gJHtpLnByZWNpc2lvbn0gdXNhbXBsZXIyREFycmF5OwoJYDtyZXR1cm4gaS5wcmVjaXNpb249PT0iaGlnaHAiP2UrPWAKI2RlZmluZSBISUdIX1BSRUNJU0lPTmA6aS5wcmVjaXNpb249PT0ibWVkaXVtcCI/ZSs9YAojZGVmaW5lIE1FRElVTV9QUkVDSVNJT05gOmkucHJlY2lzaW9uPT09Imxvd3AiJiYoZSs9YAojZGVmaW5lIExPV19QUkVDSVNJT05gKSxlfWZ1bmN0aW9uIHN1KGkpe2xldCBlPSJTSEFET1dNQVBfVFlQRV9CQVNJQyI7cmV0dXJuIGkuc2hhZG93TWFwVHlwZT09PTE/ZT0iU0hBRE9XTUFQX1RZUEVfUENGIjppLnNoYWRvd01hcFR5cGU9PT0yP2U9IlNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIjppLnNoYWRvd01hcFR5cGU9PT0zJiYoZT0iU0hBRE9XTUFQX1RZUEVfVlNNIiksZX1mdW5jdGlvbiBhdShpKXtsZXQgZT0iRU5WTUFQX1RZUEVfQ1VCRSI7aWYoaS5lbnZNYXApc3dpdGNoKGkuZW52TWFwTW9kZSl7Y2FzZSAzMDE6Y2FzZSAzMDI6ZT0iRU5WTUFQX1RZUEVfQ1VCRSI7YnJlYWs7Y2FzZSAzMDY6ZT0iRU5WTUFQX1RZUEVfQ1VCRV9VViI7YnJlYWt9cmV0dXJuIGV9ZnVuY3Rpb24gb3UoaSl7bGV0IGU9IkVOVk1BUF9NT0RFX1JFRkxFQ1RJT04iO2lmKGkuZW52TWFwKXN3aXRjaChpLmVudk1hcE1vZGUpe2Nhc2UgMzAyOmU9IkVOVk1BUF9NT0RFX1JFRlJBQ1RJT04iO2JyZWFrfXJldHVybiBlfWZ1bmN0aW9uIGx1KGkpe2xldCBlPSJFTlZNQVBfQkxFTkRJTkdfTk9ORSI7aWYoaS5lbnZNYXApc3dpdGNoKGkuY29tYmluZSl7Y2FzZSAwOmU9IkVOVk1BUF9CTEVORElOR19NVUxUSVBMWSI7YnJlYWs7Y2FzZSAxOmU9IkVOVk1BUF9CTEVORElOR19NSVgiO2JyZWFrO2Nhc2UgMjplPSJFTlZNQVBfQkxFTkRJTkdfQUREIjticmVha31yZXR1cm4gZX1mdW5jdGlvbiBjdShpKXtjb25zdCBlPWkuZW52TWFwQ3ViZVVWSGVpZ2h0O2lmKGU9PT1udWxsKXJldHVybiBudWxsO2NvbnN0IHQ9TWF0aC5sb2cyKGUpLTIsbj0xL2U7cmV0dXJue3RleGVsV2lkdGg6MS8oMypNYXRoLm1heChNYXRoLnBvdygyLHQpLDcqMTYpKSx0ZXhlbEhlaWdodDpuLG1heE1pcDp0fX1mdW5jdGlvbiB1dShpLGUsdCxuKXtjb25zdCByPWkuZ2V0Q29udGV4dCgpLHM9dC5kZWZpbmVzO2xldCBhPXQudmVydGV4U2hhZGVyLG89dC5mcmFnbWVudFNoYWRlcjtjb25zdCBsPXN1KHQpLGM9YXUodCksaD1vdSh0KSxkPWx1KHQpLGY9Y3UodCkscD1qYyh0KSxfPUpjKHMpLHg9ci5jcmVhdGVQcm9ncmFtKCk7bGV0IG0sdSxUPXQuZ2xzbFZlcnNpb24/IiN2ZXJzaW9uICIrdC5nbHNsVmVyc2lvbitgCmA6IiI7dC5pc1Jhd1NoYWRlck1hdGVyaWFsPyhtPVsiI2RlZmluZSBTSEFERVJfVFlQRSAiK3Quc2hhZGVyVHlwZSwiI2RlZmluZSBTSEFERVJfTkFNRSAiK3Quc2hhZGVyTmFtZSxfXS5maWx0ZXIoZWkpLmpvaW4oYApgKSxtLmxlbmd0aD4wJiYobSs9YApgKSx1PVsiI2RlZmluZSBTSEFERVJfVFlQRSAiK3Quc2hhZGVyVHlwZSwiI2RlZmluZSBTSEFERVJfTkFNRSAiK3Quc2hhZGVyTmFtZSxfXS5maWx0ZXIoZWkpLmpvaW4oYApgKSx1Lmxlbmd0aD4wJiYodSs9YApgKSk6KG09W0FzKHQpLCIjZGVmaW5lIFNIQURFUl9UWVBFICIrdC5zaGFkZXJUeXBlLCIjZGVmaW5lIFNIQURFUl9OQU1FICIrdC5zaGFkZXJOYW1lLF8sdC5leHRlbnNpb25DbGlwQ3VsbERpc3RhbmNlPyIjZGVmaW5lIFVTRV9DTElQX0RJU1RBTkNFIjoiIix0LmJhdGNoaW5nPyIjZGVmaW5lIFVTRV9CQVRDSElORyI6IiIsdC5iYXRjaGluZ0NvbG9yPyIjZGVmaW5lIFVTRV9CQVRDSElOR19DT0xPUiI6IiIsdC5pbnN0YW5jaW5nPyIjZGVmaW5lIFVTRV9JTlNUQU5DSU5HIjoiIix0Lmluc3RhbmNpbmdDb2xvcj8iI2RlZmluZSBVU0VfSU5TVEFOQ0lOR19DT0xPUiI6IiIsdC5pbnN0YW5jaW5nTW9ycGg/IiNkZWZpbmUgVVNFX0lOU1RBTkNJTkdfTU9SUEgiOiIiLHQudXNlRm9nJiZ0LmZvZz8iI2RlZmluZSBVU0VfRk9HIjoiIix0LnVzZUZvZyYmdC5mb2dFeHAyPyIjZGVmaW5lIEZPR19FWFAyIjoiIix0Lm1hcD8iI2RlZmluZSBVU0VfTUFQIjoiIix0LmVudk1hcD8iI2RlZmluZSBVU0VfRU5WTUFQIjoiIix0LmVudk1hcD8iI2RlZmluZSAiK2g6IiIsdC5saWdodE1hcD8iI2RlZmluZSBVU0VfTElHSFRNQVAiOiIiLHQuYW9NYXA/IiNkZWZpbmUgVVNFX0FPTUFQIjoiIix0LmJ1bXBNYXA/IiNkZWZpbmUgVVNFX0JVTVBNQVAiOiIiLHQubm9ybWFsTWFwPyIjZGVmaW5lIFVTRV9OT1JNQUxNQVAiOiIiLHQubm9ybWFsTWFwT2JqZWN0U3BhY2U/IiNkZWZpbmUgVVNFX05PUk1BTE1BUF9PQkpFQ1RTUEFDRSI6IiIsdC5ub3JtYWxNYXBUYW5nZW50U3BhY2U/IiNkZWZpbmUgVVNFX05PUk1BTE1BUF9UQU5HRU5UU1BBQ0UiOiIiLHQuZGlzcGxhY2VtZW50TWFwPyIjZGVmaW5lIFVTRV9ESVNQTEFDRU1FTlRNQVAiOiIiLHQuZW1pc3NpdmVNYXA/IiNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQIjoiIix0LmFuaXNvdHJvcHk/IiNkZWZpbmUgVVNFX0FOSVNPVFJPUFkiOiIiLHQuYW5pc290cm9weU1hcD8iI2RlZmluZSBVU0VfQU5JU09UUk9QWU1BUCI6IiIsdC5jbGVhcmNvYXRNYXA/IiNkZWZpbmUgVVNFX0NMRUFSQ09BVE1BUCI6IiIsdC5jbGVhcmNvYXRSb3VnaG5lc3NNYXA/IiNkZWZpbmUgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAiOiIiLHQuY2xlYXJjb2F0Tm9ybWFsTWFwPyIjZGVmaW5lIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQIjoiIix0LmlyaWRlc2NlbmNlTWFwPyIjZGVmaW5lIFVTRV9JUklERVNDRU5DRU1BUCI6IiIsdC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcD8iI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQIjoiIix0LnNwZWN1bGFyTWFwPyIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCI6IiIsdC5zcGVjdWxhckNvbG9yTWFwPyIjZGVmaW5lIFVTRV9TUEVDVUxBUl9DT0xPUk1BUCI6IiIsdC5zcGVjdWxhckludGVuc2l0eU1hcD8iI2RlZmluZSBVU0VfU1BFQ1VMQVJfSU5URU5TSVRZTUFQIjoiIix0LnJvdWdobmVzc01hcD8iI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQIjoiIix0Lm1ldGFsbmVzc01hcD8iI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQIjoiIix0LmFscGhhTWFwPyIjZGVmaW5lIFVTRV9BTFBIQU1BUCI6IiIsdC5hbHBoYUhhc2g/IiNkZWZpbmUgVVNFX0FMUEhBSEFTSCI6IiIsdC50cmFuc21pc3Npb24/IiNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTiI6IiIsdC50cmFuc21pc3Npb25NYXA/IiNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTk1BUCI6IiIsdC50aGlja25lc3NNYXA/IiNkZWZpbmUgVVNFX1RISUNLTkVTU01BUCI6IiIsdC5zaGVlbkNvbG9yTWFwPyIjZGVmaW5lIFVTRV9TSEVFTl9DT0xPUk1BUCI6IiIsdC5zaGVlblJvdWdobmVzc01hcD8iI2RlZmluZSBVU0VfU0hFRU5fUk9VR0hORVNTTUFQIjoiIix0Lm1hcFV2PyIjZGVmaW5lIE1BUF9VViAiK3QubWFwVXY6IiIsdC5hbHBoYU1hcFV2PyIjZGVmaW5lIEFMUEhBTUFQX1VWICIrdC5hbHBoYU1hcFV2OiIiLHQubGlnaHRNYXBVdj8iI2RlZmluZSBMSUdIVE1BUF9VViAiK3QubGlnaHRNYXBVdjoiIix0LmFvTWFwVXY/IiNkZWZpbmUgQU9NQVBfVVYgIit0LmFvTWFwVXY6IiIsdC5lbWlzc2l2ZU1hcFV2PyIjZGVmaW5lIEVNSVNTSVZFTUFQX1VWICIrdC5lbWlzc2l2ZU1hcFV2OiIiLHQuYnVtcE1hcFV2PyIjZGVmaW5lIEJVTVBNQVBfVVYgIit0LmJ1bXBNYXBVdjoiIix0Lm5vcm1hbE1hcFV2PyIjZGVmaW5lIE5PUk1BTE1BUF9VViAiK3Qubm9ybWFsTWFwVXY6IiIsdC5kaXNwbGFjZW1lbnRNYXBVdj8iI2RlZmluZSBESVNQTEFDRU1FTlRNQVBfVVYgIit0LmRpc3BsYWNlbWVudE1hcFV2OiIiLHQubWV0YWxuZXNzTWFwVXY/IiNkZWZpbmUgTUVUQUxORVNTTUFQX1VWICIrdC5tZXRhbG5lc3NNYXBVdjoiIix0LnJvdWdobmVzc01hcFV2PyIjZGVmaW5lIFJPVUdITkVTU01BUF9VViAiK3Qucm91Z2huZXNzTWFwVXY6IiIsdC5hbmlzb3Ryb3B5TWFwVXY/IiNkZWZpbmUgQU5JU09UUk9QWU1BUF9VViAiK3QuYW5pc290cm9weU1hcFV2OiIiLHQuY2xlYXJjb2F0TWFwVXY/IiNkZWZpbmUgQ0xFQVJDT0FUTUFQX1VWICIrdC5jbGVhcmNvYXRNYXBVdjoiIix0LmNsZWFyY29hdE5vcm1hbE1hcFV2PyIjZGVmaW5lIENMRUFSQ09BVF9OT1JNQUxNQVBfVVYgIit0LmNsZWFyY29hdE5vcm1hbE1hcFV2OiIiLHQuY2xlYXJjb2F0Um91Z2huZXNzTWFwVXY/IiNkZWZpbmUgQ0xFQVJDT0FUX1JPVUdITkVTU01BUF9VViAiK3QuY2xlYXJjb2F0Um91Z2huZXNzTWFwVXY6IiIsdC5pcmlkZXNjZW5jZU1hcFV2PyIjZGVmaW5lIElSSURFU0NFTkNFTUFQX1VWICIrdC5pcmlkZXNjZW5jZU1hcFV2OiIiLHQuaXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdj8iI2RlZmluZSBJUklERVNDRU5DRV9USElDS05FU1NNQVBfVVYgIit0LmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXY6IiIsdC5zaGVlbkNvbG9yTWFwVXY/IiNkZWZpbmUgU0hFRU5fQ09MT1JNQVBfVVYgIit0LnNoZWVuQ29sb3JNYXBVdjoiIix0LnNoZWVuUm91Z2huZXNzTWFwVXY/IiNkZWZpbmUgU0hFRU5fUk9VR0hORVNTTUFQX1VWICIrdC5zaGVlblJvdWdobmVzc01hcFV2OiIiLHQuc3BlY3VsYXJNYXBVdj8iI2RlZmluZSBTUEVDVUxBUk1BUF9VViAiK3Quc3BlY3VsYXJNYXBVdjoiIix0LnNwZWN1bGFyQ29sb3JNYXBVdj8iI2RlZmluZSBTUEVDVUxBUl9DT0xPUk1BUF9VViAiK3Quc3BlY3VsYXJDb2xvck1hcFV2OiIiLHQuc3BlY3VsYXJJbnRlbnNpdHlNYXBVdj8iI2RlZmluZSBTUEVDVUxBUl9JTlRFTlNJVFlNQVBfVVYgIit0LnNwZWN1bGFySW50ZW5zaXR5TWFwVXY6IiIsdC50cmFuc21pc3Npb25NYXBVdj8iI2RlZmluZSBUUkFOU01JU1NJT05NQVBfVVYgIit0LnRyYW5zbWlzc2lvbk1hcFV2OiIiLHQudGhpY2tuZXNzTWFwVXY/IiNkZWZpbmUgVEhJQ0tORVNTTUFQX1VWICIrdC50aGlja25lc3NNYXBVdjoiIix0LnZlcnRleFRhbmdlbnRzJiZ0LmZsYXRTaGFkaW5nPT09ITE/IiNkZWZpbmUgVVNFX1RBTkdFTlQiOiIiLHQudmVydGV4Q29sb3JzPyIjZGVmaW5lIFVTRV9DT0xPUiI6IiIsdC52ZXJ0ZXhBbHBoYXM/IiNkZWZpbmUgVVNFX0NPTE9SX0FMUEhBIjoiIix0LnZlcnRleFV2MXM/IiNkZWZpbmUgVVNFX1VWMSI6IiIsdC52ZXJ0ZXhVdjJzPyIjZGVmaW5lIFVTRV9VVjIiOiIiLHQudmVydGV4VXYzcz8iI2RlZmluZSBVU0VfVVYzIjoiIix0LnBvaW50c1V2cz8iI2RlZmluZSBVU0VfUE9JTlRTX1VWIjoiIix0LmZsYXRTaGFkaW5nPyIjZGVmaW5lIEZMQVRfU0hBREVEIjoiIix0LnNraW5uaW5nPyIjZGVmaW5lIFVTRV9TS0lOTklORyI6IiIsdC5tb3JwaFRhcmdldHM/IiNkZWZpbmUgVVNFX01PUlBIVEFSR0VUUyI6IiIsdC5tb3JwaE5vcm1hbHMmJnQuZmxhdFNoYWRpbmc9PT0hMT8iI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTIjoiIix0Lm1vcnBoQ29sb3JzPyIjZGVmaW5lIFVTRV9NT1JQSENPTE9SUyI6IiIsdC5tb3JwaFRhcmdldHNDb3VudD4wPyIjZGVmaW5lIE1PUlBIVEFSR0VUU19URVhUVVJFX1NUUklERSAiK3QubW9ycGhUZXh0dXJlU3RyaWRlOiIiLHQubW9ycGhUYXJnZXRzQ291bnQ+MD8iI2RlZmluZSBNT1JQSFRBUkdFVFNfQ09VTlQgIit0Lm1vcnBoVGFyZ2V0c0NvdW50OiIiLHQuZG91YmxlU2lkZWQ/IiNkZWZpbmUgRE9VQkxFX1NJREVEIjoiIix0LmZsaXBTaWRlZD8iI2RlZmluZSBGTElQX1NJREVEIjoiIix0LnNoYWRvd01hcEVuYWJsZWQ/IiNkZWZpbmUgVVNFX1NIQURPV01BUCI6IiIsdC5zaGFkb3dNYXBFbmFibGVkPyIjZGVmaW5lICIrbDoiIix0LnNpemVBdHRlbnVhdGlvbj8iI2RlZmluZSBVU0VfU0laRUFUVEVOVUFUSU9OIjoiIix0Lm51bUxpZ2h0UHJvYmVzPjA/IiNkZWZpbmUgVVNFX0xJR0hUX1BST0JFUyI6IiIsdC5sb2dhcml0aG1pY0RlcHRoQnVmZmVyPyIjZGVmaW5lIFVTRV9MT0dERVBUSEJVRiI6IiIsdC5yZXZlcnNlRGVwdGhCdWZmZXI/IiNkZWZpbmUgVVNFX1JFVkVSU0VERVBUSEJVRiI6IiIsInVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDsiLCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4OyIsInVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OyIsInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4OyIsInVuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7IiwidW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOyIsInVuaWZvcm0gYm9vbCBpc09ydGhvZ3JhcGhpYzsiLCIjaWZkZWYgVVNFX0lOU1RBTkNJTkciLCIJYXR0cmlidXRlIG1hdDQgaW5zdGFuY2VNYXRyaXg7IiwiI2VuZGlmIiwiI2lmZGVmIFVTRV9JTlNUQU5DSU5HX0NPTE9SIiwiCWF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlQ29sb3I7IiwiI2VuZGlmIiwiI2lmZGVmIFVTRV9JTlNUQU5DSU5HX01PUlBIIiwiCXVuaWZvcm0gc2FtcGxlcjJEIG1vcnBoVGV4dHVyZTsiLCIjZW5kaWYiLCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjsiLCJhdHRyaWJ1dGUgdmVjMyBub3JtYWw7IiwiYXR0cmlidXRlIHZlYzIgdXY7IiwiI2lmZGVmIFVTRV9VVjEiLCIJYXR0cmlidXRlIHZlYzIgdXYxOyIsIiNlbmRpZiIsIiNpZmRlZiBVU0VfVVYyIiwiCWF0dHJpYnV0ZSB2ZWMyIHV2MjsiLCIjZW5kaWYiLCIjaWZkZWYgVVNFX1VWMyIsIglhdHRyaWJ1dGUgdmVjMiB1djM7IiwiI2VuZGlmIiwiI2lmZGVmIFVTRV9UQU5HRU5UIiwiCWF0dHJpYnV0ZSB2ZWM0IHRhbmdlbnQ7IiwiI2VuZGlmIiwiI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApIiwiCWF0dHJpYnV0ZSB2ZWM0IGNvbG9yOyIsIiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApIiwiCWF0dHJpYnV0ZSB2ZWMzIGNvbG9yOyIsIiNlbmRpZiIsIiNpZmRlZiBVU0VfU0tJTk5JTkciLCIJYXR0cmlidXRlIHZlYzQgc2tpbkluZGV4OyIsIglhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0OyIsIiNlbmRpZiIsYApgXS5maWx0ZXIoZWkpLmpvaW4oYApgKSx1PVtBcyh0KSwiI2RlZmluZSBTSEFERVJfVFlQRSAiK3Quc2hhZGVyVHlwZSwiI2RlZmluZSBTSEFERVJfTkFNRSAiK3Quc2hhZGVyTmFtZSxfLHQudXNlRm9nJiZ0LmZvZz8iI2RlZmluZSBVU0VfRk9HIjoiIix0LnVzZUZvZyYmdC5mb2dFeHAyPyIjZGVmaW5lIEZPR19FWFAyIjoiIix0LmFscGhhVG9Db3ZlcmFnZT8iI2RlZmluZSBBTFBIQV9UT19DT1ZFUkFHRSI6IiIsdC5tYXA/IiNkZWZpbmUgVVNFX01BUCI6IiIsdC5tYXRjYXA/IiNkZWZpbmUgVVNFX01BVENBUCI6IiIsdC5lbnZNYXA/IiNkZWZpbmUgVVNFX0VOVk1BUCI6IiIsdC5lbnZNYXA/IiNkZWZpbmUgIitjOiIiLHQuZW52TWFwPyIjZGVmaW5lICIraDoiIix0LmVudk1hcD8iI2RlZmluZSAiK2Q6IiIsZj8iI2RlZmluZSBDVUJFVVZfVEVYRUxfV0lEVEggIitmLnRleGVsV2lkdGg6IiIsZj8iI2RlZmluZSBDVUJFVVZfVEVYRUxfSEVJR0hUICIrZi50ZXhlbEhlaWdodDoiIixmPyIjZGVmaW5lIENVQkVVVl9NQVhfTUlQICIrZi5tYXhNaXArIi4wIjoiIix0LmxpZ2h0TWFwPyIjZGVmaW5lIFVTRV9MSUdIVE1BUCI6IiIsdC5hb01hcD8iI2RlZmluZSBVU0VfQU9NQVAiOiIiLHQuYnVtcE1hcD8iI2RlZmluZSBVU0VfQlVNUE1BUCI6IiIsdC5ub3JtYWxNYXA/IiNkZWZpbmUgVVNFX05PUk1BTE1BUCI6IiIsdC5ub3JtYWxNYXBPYmplY3RTcGFjZT8iI2RlZmluZSBVU0VfTk9STUFMTUFQX09CSkVDVFNQQUNFIjoiIix0Lm5vcm1hbE1hcFRhbmdlbnRTcGFjZT8iI2RlZmluZSBVU0VfTk9STUFMTUFQX1RBTkdFTlRTUEFDRSI6IiIsdC5lbWlzc2l2ZU1hcD8iI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAiOiIiLHQuYW5pc290cm9weT8iI2RlZmluZSBVU0VfQU5JU09UUk9QWSI6IiIsdC5hbmlzb3Ryb3B5TWFwPyIjZGVmaW5lIFVTRV9BTklTT1RST1BZTUFQIjoiIix0LmNsZWFyY29hdD8iI2RlZmluZSBVU0VfQ0xFQVJDT0FUIjoiIix0LmNsZWFyY29hdE1hcD8iI2RlZmluZSBVU0VfQ0xFQVJDT0FUTUFQIjoiIix0LmNsZWFyY29hdFJvdWdobmVzc01hcD8iI2RlZmluZSBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUCI6IiIsdC5jbGVhcmNvYXROb3JtYWxNYXA/IiNkZWZpbmUgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAiOiIiLHQuZGlzcGVyc2lvbj8iI2RlZmluZSBVU0VfRElTUEVSU0lPTiI6IiIsdC5pcmlkZXNjZW5jZT8iI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0UiOiIiLHQuaXJpZGVzY2VuY2VNYXA/IiNkZWZpbmUgVVNFX0lSSURFU0NFTkNFTUFQIjoiIix0LmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwPyIjZGVmaW5lIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVAiOiIiLHQuc3BlY3VsYXJNYXA/IiNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQIjoiIix0LnNwZWN1bGFyQ29sb3JNYXA/IiNkZWZpbmUgVVNFX1NQRUNVTEFSX0NPTE9STUFQIjoiIix0LnNwZWN1bGFySW50ZW5zaXR5TWFwPyIjZGVmaW5lIFVTRV9TUEVDVUxBUl9JTlRFTlNJVFlNQVAiOiIiLHQucm91Z2huZXNzTWFwPyIjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAiOiIiLHQubWV0YWxuZXNzTWFwPyIjZGVmaW5lIFVTRV9NRVRBTE5FU1NNQVAiOiIiLHQuYWxwaGFNYXA/IiNkZWZpbmUgVVNFX0FMUEhBTUFQIjoiIix0LmFscGhhVGVzdD8iI2RlZmluZSBVU0VfQUxQSEFURVNUIjoiIix0LmFscGhhSGFzaD8iI2RlZmluZSBVU0VfQUxQSEFIQVNIIjoiIix0LnNoZWVuPyIjZGVmaW5lIFVTRV9TSEVFTiI6IiIsdC5zaGVlbkNvbG9yTWFwPyIjZGVmaW5lIFVTRV9TSEVFTl9DT0xPUk1BUCI6IiIsdC5zaGVlblJvdWdobmVzc01hcD8iI2RlZmluZSBVU0VfU0hFRU5fUk9VR0hORVNTTUFQIjoiIix0LnRyYW5zbWlzc2lvbj8iI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OIjoiIix0LnRyYW5zbWlzc2lvbk1hcD8iI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OTUFQIjoiIix0LnRoaWNrbmVzc01hcD8iI2RlZmluZSBVU0VfVEhJQ0tORVNTTUFQIjoiIix0LnZlcnRleFRhbmdlbnRzJiZ0LmZsYXRTaGFkaW5nPT09ITE/IiNkZWZpbmUgVVNFX1RBTkdFTlQiOiIiLHQudmVydGV4Q29sb3JzfHx0Lmluc3RhbmNpbmdDb2xvcnx8dC5iYXRjaGluZ0NvbG9yPyIjZGVmaW5lIFVTRV9DT0xPUiI6IiIsdC52ZXJ0ZXhBbHBoYXM/IiNkZWZpbmUgVVNFX0NPTE9SX0FMUEhBIjoiIix0LnZlcnRleFV2MXM/IiNkZWZpbmUgVVNFX1VWMSI6IiIsdC52ZXJ0ZXhVdjJzPyIjZGVmaW5lIFVTRV9VVjIiOiIiLHQudmVydGV4VXYzcz8iI2RlZmluZSBVU0VfVVYzIjoiIix0LnBvaW50c1V2cz8iI2RlZmluZSBVU0VfUE9JTlRTX1VWIjoiIix0LmdyYWRpZW50TWFwPyIjZGVmaW5lIFVTRV9HUkFESUVOVE1BUCI6IiIsdC5mbGF0U2hhZGluZz8iI2RlZmluZSBGTEFUX1NIQURFRCI6IiIsdC5kb3VibGVTaWRlZD8iI2RlZmluZSBET1VCTEVfU0lERUQiOiIiLHQuZmxpcFNpZGVkPyIjZGVmaW5lIEZMSVBfU0lERUQiOiIiLHQuc2hhZG93TWFwRW5hYmxlZD8iI2RlZmluZSBVU0VfU0hBRE9XTUFQIjoiIix0LnNoYWRvd01hcEVuYWJsZWQ/IiNkZWZpbmUgIitsOiIiLHQucHJlbXVsdGlwbGllZEFscGhhPyIjZGVmaW5lIFBSRU1VTFRJUExJRURfQUxQSEEiOiIiLHQubnVtTGlnaHRQcm9iZXM+MD8iI2RlZmluZSBVU0VfTElHSFRfUFJPQkVTIjoiIix0LmRlY29kZVZpZGVvVGV4dHVyZT8iI2RlZmluZSBERUNPREVfVklERU9fVEVYVFVSRSI6IiIsdC5kZWNvZGVWaWRlb1RleHR1cmVFbWlzc2l2ZT8iI2RlZmluZSBERUNPREVfVklERU9fVEVYVFVSRV9FTUlTU0lWRSI6IiIsdC5sb2dhcml0aG1pY0RlcHRoQnVmZmVyPyIjZGVmaW5lIFVTRV9MT0dERVBUSEJVRiI6IiIsdC5yZXZlcnNlRGVwdGhCdWZmZXI/IiNkZWZpbmUgVVNFX1JFVkVSU0VERVBUSEJVRiI6IiIsInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4OyIsInVuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsiLCJ1bmlmb3JtIGJvb2wgaXNPcnRob2dyYXBoaWM7Iix0LnRvbmVNYXBwaW5nIT09MD8iI2RlZmluZSBUT05FX01BUFBJTkciOiIiLHQudG9uZU1hcHBpbmchPT0wP0RlLnRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQ6IiIsdC50b25lTWFwcGluZyE9PTA/S2MoInRvbmVNYXBwaW5nIix0LnRvbmVNYXBwaW5nKToiIix0LmRpdGhlcmluZz8iI2RlZmluZSBESVRIRVJJTkciOiIiLHQub3BhcXVlPyIjZGVmaW5lIE9QQVFVRSI6IiIsRGUuY29sb3JzcGFjZV9wYXJzX2ZyYWdtZW50LCRjKCJsaW5lYXJUb091dHB1dFRleGVsIix0Lm91dHB1dENvbG9yU3BhY2UpLFpjKCksdC51c2VEZXB0aFBhY2tpbmc/IiNkZWZpbmUgREVQVEhfUEFDS0lORyAiK3QuZGVwdGhQYWNraW5nOiIiLGAKYF0uZmlsdGVyKGVpKS5qb2luKGAKYCkpLGE9ZHIoYSksYT1FcyhhLHQpLGE9eXMoYSx0KSxvPWRyKG8pLG89RXMobyx0KSxvPXlzKG8sdCksYT1UcyhhKSxvPVRzKG8pLHQuaXNSYXdTaGFkZXJNYXRlcmlhbCE9PSEwJiYoVD1gI3ZlcnNpb24gMzAwIGVzCmAsbT1bcCwiI2RlZmluZSBhdHRyaWJ1dGUgaW4iLCIjZGVmaW5lIHZhcnlpbmcgb3V0IiwiI2RlZmluZSB0ZXh0dXJlMkQgdGV4dHVyZSJdLmpvaW4oYApgKStgCmArbSx1PVsiI2RlZmluZSB2YXJ5aW5nIGluIix0Lmdsc2xWZXJzaW9uPT09eHI/IiI6ImxheW91dChsb2NhdGlvbiA9IDApIG91dCBoaWdocCB2ZWM0IHBjX2ZyYWdDb2xvcjsiLHQuZ2xzbFZlcnNpb249PT14cj8iIjoiI2RlZmluZSBnbF9GcmFnQ29sb3IgcGNfZnJhZ0NvbG9yIiwiI2RlZmluZSBnbF9GcmFnRGVwdGhFWFQgZ2xfRnJhZ0RlcHRoIiwiI2RlZmluZSB0ZXh0dXJlMkQgdGV4dHVyZSIsIiNkZWZpbmUgdGV4dHVyZUN1YmUgdGV4dHVyZSIsIiNkZWZpbmUgdGV4dHVyZTJEUHJvaiB0ZXh0dXJlUHJvaiIsIiNkZWZpbmUgdGV4dHVyZTJETG9kRVhUIHRleHR1cmVMb2QiLCIjZGVmaW5lIHRleHR1cmUyRFByb2pMb2RFWFQgdGV4dHVyZVByb2pMb2QiLCIjZGVmaW5lIHRleHR1cmVDdWJlTG9kRVhUIHRleHR1cmVMb2QiLCIjZGVmaW5lIHRleHR1cmUyREdyYWRFWFQgdGV4dHVyZUdyYWQiLCIjZGVmaW5lIHRleHR1cmUyRFByb2pHcmFkRVhUIHRleHR1cmVQcm9qR3JhZCIsIiNkZWZpbmUgdGV4dHVyZUN1YmVHcmFkRVhUIHRleHR1cmVHcmFkIl0uam9pbihgCmApK2AKYCt1KTtjb25zdCB5PVQrbSthLGc9VCt1K28sUD14cyhyLHIuVkVSVEVYX1NIQURFUix5KSx3PXhzKHIsci5GUkFHTUVOVF9TSEFERVIsZyk7ci5hdHRhY2hTaGFkZXIoeCxQKSxyLmF0dGFjaFNoYWRlcih4LHcpLHQuaW5kZXgwQXR0cmlidXRlTmFtZSE9PXZvaWQgMD9yLmJpbmRBdHRyaWJMb2NhdGlvbih4LDAsdC5pbmRleDBBdHRyaWJ1dGVOYW1lKTp0Lm1vcnBoVGFyZ2V0cz09PSEwJiZyLmJpbmRBdHRyaWJMb2NhdGlvbih4LDAsInBvc2l0aW9uIiksci5saW5rUHJvZ3JhbSh4KTtmdW5jdGlvbiBiKFIpe2lmKGkuZGVidWcuY2hlY2tTaGFkZXJFcnJvcnMpe2NvbnN0IHE9ci5nZXRQcm9ncmFtSW5mb0xvZyh4KS50cmltKCksej1yLmdldFNoYWRlckluZm9Mb2coUCkudHJpbSgpLFc9ci5nZXRTaGFkZXJJbmZvTG9nKHcpLnRyaW0oKTtsZXQgWj0hMCxWPSEwO2lmKHIuZ2V0UHJvZ3JhbVBhcmFtZXRlcih4LHIuTElOS19TVEFUVVMpPT09ITEpaWYoWj0hMSx0eXBlb2YgaS5kZWJ1Zy5vblNoYWRlckVycm9yPT0iZnVuY3Rpb24iKWkuZGVidWcub25TaGFkZXJFcnJvcihyLHgsUCx3KTtlbHNle2NvbnN0IFE9U3MocixQLCJ2ZXJ0ZXgiKSxIPVNzKHIsdywiZnJhZ21lbnQiKTtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFByb2dyYW06IFNoYWRlciBFcnJvciAiK3IuZ2V0RXJyb3IoKSsiIC0gVkFMSURBVEVfU1RBVFVTICIrci5nZXRQcm9ncmFtUGFyYW1ldGVyKHgsci5WQUxJREFURV9TVEFUVVMpK2AKCk1hdGVyaWFsIE5hbWU6IGArUi5uYW1lK2AKTWF0ZXJpYWwgVHlwZTogYCtSLnR5cGUrYAoKUHJvZ3JhbSBJbmZvIExvZzogYCtxK2AKYCtRK2AKYCtIKX1lbHNlIHEhPT0iIj9jb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUHJvZ3JhbTogUHJvZ3JhbSBJbmZvIExvZzoiLHEpOih6PT09IiJ8fFc9PT0iIikmJihWPSExKTtWJiYoUi5kaWFnbm9zdGljcz17cnVubmFibGU6Wixwcm9ncmFtTG9nOnEsdmVydGV4U2hhZGVyOntsb2c6eixwcmVmaXg6bX0sZnJhZ21lbnRTaGFkZXI6e2xvZzpXLHByZWZpeDp1fX0pfXIuZGVsZXRlU2hhZGVyKFApLHIuZGVsZXRlU2hhZGVyKHcpLEY9bmV3IHdpKHIseCksRT1RYyhyLHgpfWxldCBGO3RoaXMuZ2V0VW5pZm9ybXM9ZnVuY3Rpb24oKXtyZXR1cm4gRj09PXZvaWQgMCYmYih0aGlzKSxGfTtsZXQgRTt0aGlzLmdldEF0dHJpYnV0ZXM9ZnVuY3Rpb24oKXtyZXR1cm4gRT09PXZvaWQgMCYmYih0aGlzKSxFfTtsZXQgUz10LnJlbmRlcmVyRXh0ZW5zaW9uUGFyYWxsZWxTaGFkZXJDb21waWxlPT09ITE7cmV0dXJuIHRoaXMuaXNSZWFkeT1mdW5jdGlvbigpe3JldHVybiBTPT09ITEmJihTPXIuZ2V0UHJvZ3JhbVBhcmFtZXRlcih4LFdjKSksU30sdGhpcy5kZXN0cm95PWZ1bmN0aW9uKCl7bi5yZWxlYXNlU3RhdGVzT2ZQcm9ncmFtKHRoaXMpLHIuZGVsZXRlUHJvZ3JhbSh4KSx0aGlzLnByb2dyYW09dm9pZCAwfSx0aGlzLnR5cGU9dC5zaGFkZXJUeXBlLHRoaXMubmFtZT10LnNoYWRlck5hbWUsdGhpcy5pZD1YYysrLHRoaXMuY2FjaGVLZXk9ZSx0aGlzLnVzZWRUaW1lcz0xLHRoaXMucHJvZ3JhbT14LHRoaXMudmVydGV4U2hhZGVyPVAsdGhpcy5mcmFnbWVudFNoYWRlcj13LHRoaXN9bGV0IGh1PTA7Y2xhc3MgZHV7Y29uc3RydWN0b3IoKXt0aGlzLnNoYWRlckNhY2hlPW5ldyBNYXAsdGhpcy5tYXRlcmlhbENhY2hlPW5ldyBNYXB9dXBkYXRlKGUpe2NvbnN0IHQ9ZS52ZXJ0ZXhTaGFkZXIsbj1lLmZyYWdtZW50U2hhZGVyLHI9dGhpcy5fZ2V0U2hhZGVyU3RhZ2UodCkscz10aGlzLl9nZXRTaGFkZXJTdGFnZShuKSxhPXRoaXMuX2dldFNoYWRlckNhY2hlRm9yTWF0ZXJpYWwoZSk7cmV0dXJuIGEuaGFzKHIpPT09ITEmJihhLmFkZChyKSxyLnVzZWRUaW1lcysrKSxhLmhhcyhzKT09PSExJiYoYS5hZGQocykscy51c2VkVGltZXMrKyksdGhpc31yZW1vdmUoZSl7Y29uc3QgdD10aGlzLm1hdGVyaWFsQ2FjaGUuZ2V0KGUpO2Zvcihjb25zdCBuIG9mIHQpbi51c2VkVGltZXMtLSxuLnVzZWRUaW1lcz09PTAmJnRoaXMuc2hhZGVyQ2FjaGUuZGVsZXRlKG4uY29kZSk7cmV0dXJuIHRoaXMubWF0ZXJpYWxDYWNoZS5kZWxldGUoZSksdGhpc31nZXRWZXJ0ZXhTaGFkZXJJRChlKXtyZXR1cm4gdGhpcy5fZ2V0U2hhZGVyU3RhZ2UoZS52ZXJ0ZXhTaGFkZXIpLmlkfWdldEZyYWdtZW50U2hhZGVySUQoZSl7cmV0dXJuIHRoaXMuX2dldFNoYWRlclN0YWdlKGUuZnJhZ21lbnRTaGFkZXIpLmlkfWRpc3Bvc2UoKXt0aGlzLnNoYWRlckNhY2hlLmNsZWFyKCksdGhpcy5tYXRlcmlhbENhY2hlLmNsZWFyKCl9X2dldFNoYWRlckNhY2hlRm9yTWF0ZXJpYWwoZSl7Y29uc3QgdD10aGlzLm1hdGVyaWFsQ2FjaGU7bGV0IG49dC5nZXQoZSk7cmV0dXJuIG49PT12b2lkIDAmJihuPW5ldyBTZXQsdC5zZXQoZSxuKSksbn1fZ2V0U2hhZGVyU3RhZ2UoZSl7Y29uc3QgdD10aGlzLnNoYWRlckNhY2hlO2xldCBuPXQuZ2V0KGUpO3JldHVybiBuPT09dm9pZCAwJiYobj1uZXcgZnUoZSksdC5zZXQoZSxuKSksbn19Y2xhc3MgZnV7Y29uc3RydWN0b3IoZSl7dGhpcy5pZD1odSsrLHRoaXMuY29kZT1lLHRoaXMudXNlZFRpbWVzPTB9fWZ1bmN0aW9uIHB1KGksZSx0LG4scixzLGEpe2NvbnN0IG89bmV3IEZyLGw9bmV3IGR1LGM9bmV3IFNldCxoPVtdLGQ9ci5sb2dhcml0aG1pY0RlcHRoQnVmZmVyLGY9ci52ZXJ0ZXhUZXh0dXJlcztsZXQgcD1yLnByZWNpc2lvbjtjb25zdCBfPXtNZXNoRGVwdGhNYXRlcmlhbDoiZGVwdGgiLE1lc2hEaXN0YW5jZU1hdGVyaWFsOiJkaXN0YW5jZVJHQkEiLE1lc2hOb3JtYWxNYXRlcmlhbDoibm9ybWFsIixNZXNoQmFzaWNNYXRlcmlhbDoiYmFzaWMiLE1lc2hMYW1iZXJ0TWF0ZXJpYWw6ImxhbWJlcnQiLE1lc2hQaG9uZ01hdGVyaWFsOiJwaG9uZyIsTWVzaFRvb25NYXRlcmlhbDoidG9vbiIsTWVzaFN0YW5kYXJkTWF0ZXJpYWw6InBoeXNpY2FsIixNZXNoUGh5c2ljYWxNYXRlcmlhbDoicGh5c2ljYWwiLE1lc2hNYXRjYXBNYXRlcmlhbDoibWF0Y2FwIixMaW5lQmFzaWNNYXRlcmlhbDoiYmFzaWMiLExpbmVEYXNoZWRNYXRlcmlhbDoiZGFzaGVkIixQb2ludHNNYXRlcmlhbDoicG9pbnRzIixTaGFkb3dNYXRlcmlhbDoic2hhZG93IixTcHJpdGVNYXRlcmlhbDoic3ByaXRlIn07ZnVuY3Rpb24geChFKXtyZXR1cm4gYy5hZGQoRSksRT09PTA/InV2IjpgdXYke0V9YH1mdW5jdGlvbiBtKEUsUyxSLHEseil7Y29uc3QgVz1xLmZvZyxaPXouZ2VvbWV0cnksVj1FLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWw/cS5lbnZpcm9ubWVudDpudWxsLFE9KEUuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbD90OmUpLmdldChFLmVudk1hcHx8ViksSD1RJiZRLm1hcHBpbmc9PT0zMDY/US5pbWFnZS5oZWlnaHQ6bnVsbCxpZT1fW0UudHlwZV07RS5wcmVjaXNpb24hPT1udWxsJiYocD1yLmdldE1heFByZWNpc2lvbihFLnByZWNpc2lvbikscCE9PUUucHJlY2lzaW9uJiZjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUHJvZ3JhbS5nZXRQYXJhbWV0ZXJzOiIsRS5wcmVjaXNpb24sIm5vdCBzdXBwb3J0ZWQsIHVzaW5nIixwLCJpbnN0ZWFkLiIpKTtjb25zdCBjZT1aLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbnx8Wi5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsfHxaLm1vcnBoQXR0cmlidXRlcy5jb2xvcix4ZT1jZSE9PXZvaWQgMD9jZS5sZW5ndGg6MDtsZXQgVWU9MDtaLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiE9PXZvaWQgMCYmKFVlPTEpLFoubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCE9PXZvaWQgMCYmKFVlPTIpLFoubW9ycGhBdHRyaWJ1dGVzLmNvbG9yIT09dm9pZCAwJiYoVWU9Myk7bGV0IFllLFgsZWUsZ2U7aWYoaWUpe2NvbnN0IFhlPXp0W2llXTtZZT1YZS52ZXJ0ZXhTaGFkZXIsWD1YZS5mcmFnbWVudFNoYWRlcn1lbHNlIFllPUUudmVydGV4U2hhZGVyLFg9RS5mcmFnbWVudFNoYWRlcixsLnVwZGF0ZShFKSxlZT1sLmdldFZlcnRleFNoYWRlcklEKEUpLGdlPWwuZ2V0RnJhZ21lbnRTaGFkZXJJRChFKTtjb25zdCByZT1pLmdldFJlbmRlclRhcmdldCgpLHllPWkuc3RhdGUuYnVmZmVycy5kZXB0aC5nZXRSZXZlcnNlZCgpLHdlPXouaXNJbnN0YW5jZWRNZXNoPT09ITAsRmU9ei5pc0JhdGNoZWRNZXNoPT09ITAsbnQ9ISFFLm1hcCx6ZT0hIUUubWF0Y2FwLGF0PSEhUSxVPSEhRS5hb01hcCxQdD0hIUUubGlnaHRNYXAsSWU9ISFFLmJ1bXBNYXAsTmU9ISFFLm5vcm1hbE1hcCxTZT0hIUUuZGlzcGxhY2VtZW50TWFwLGplPSEhRS5lbWlzc2l2ZU1hcCxNZT0hIUUubWV0YWxuZXNzTWFwLEE9ISFFLnJvdWdobmVzc01hcCx2PUUuYW5pc290cm9weT4wLEk9RS5jbGVhcmNvYXQ+MCxZPUUuZGlzcGVyc2lvbj4wLEs9RS5pcmlkZXNjZW5jZT4wLGs9RS5zaGVlbj4wLF9lPUUudHJhbnNtaXNzaW9uPjAsc2U9diYmISFFLmFuaXNvdHJvcHlNYXAsdWU9SSYmISFFLmNsZWFyY29hdE1hcCxHZT1JJiYhIUUuY2xlYXJjb2F0Tm9ybWFsTWFwLGo9SSYmISFFLmNsZWFyY29hdFJvdWdobmVzc01hcCxoZT1LJiYhIUUuaXJpZGVzY2VuY2VNYXAsRWU9SyYmISFFLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLFRlPWsmJiEhRS5zaGVlbkNvbG9yTWFwLGRlPWsmJiEhRS5zaGVlblJvdWdobmVzc01hcCxPZT0hIUUuc3BlY3VsYXJNYXAsTGU9ISFFLnNwZWN1bGFyQ29sb3JNYXAsS2U9ISFFLnNwZWN1bGFySW50ZW5zaXR5TWFwLEM9X2UmJiEhRS50cmFuc21pc3Npb25NYXAsbmU9X2UmJiEhRS50aGlja25lc3NNYXAsRz0hIUUuZ3JhZGllbnRNYXAsJD0hIUUuYWxwaGFNYXAsbGU9RS5hbHBoYVRlc3Q+MCxhZT0hIUUuYWxwaGFIYXNoLFJlPSEhRS5leHRlbnNpb25zO2xldCBpdD0wO0UudG9uZU1hcHBlZCYmKHJlPT09bnVsbHx8cmUuaXNYUlJlbmRlclRhcmdldD09PSEwKSYmKGl0PWkudG9uZU1hcHBpbmcpO2NvbnN0IG10PXtzaGFkZXJJRDppZSxzaGFkZXJUeXBlOkUudHlwZSxzaGFkZXJOYW1lOkUubmFtZSx2ZXJ0ZXhTaGFkZXI6WWUsZnJhZ21lbnRTaGFkZXI6WCxkZWZpbmVzOkUuZGVmaW5lcyxjdXN0b21WZXJ0ZXhTaGFkZXJJRDplZSxjdXN0b21GcmFnbWVudFNoYWRlcklEOmdlLGlzUmF3U2hhZGVyTWF0ZXJpYWw6RS5pc1Jhd1NoYWRlck1hdGVyaWFsPT09ITAsZ2xzbFZlcnNpb246RS5nbHNsVmVyc2lvbixwcmVjaXNpb246cCxiYXRjaGluZzpGZSxiYXRjaGluZ0NvbG9yOkZlJiZ6Ll9jb2xvcnNUZXh0dXJlIT09bnVsbCxpbnN0YW5jaW5nOndlLGluc3RhbmNpbmdDb2xvcjp3ZSYmei5pbnN0YW5jZUNvbG9yIT09bnVsbCxpbnN0YW5jaW5nTW9ycGg6d2UmJnoubW9ycGhUZXh0dXJlIT09bnVsbCxzdXBwb3J0c1ZlcnRleFRleHR1cmVzOmYsb3V0cHV0Q29sb3JTcGFjZTpyZT09PW51bGw/aS5vdXRwdXRDb2xvclNwYWNlOnJlLmlzWFJSZW5kZXJUYXJnZXQ9PT0hMD9yZS50ZXh0dXJlLmNvbG9yU3BhY2U6eG4sYWxwaGFUb0NvdmVyYWdlOiEhRS5hbHBoYVRvQ292ZXJhZ2UsbWFwOm50LG1hdGNhcDp6ZSxlbnZNYXA6YXQsZW52TWFwTW9kZTphdCYmUS5tYXBwaW5nLGVudk1hcEN1YmVVVkhlaWdodDpILGFvTWFwOlUsbGlnaHRNYXA6UHQsYnVtcE1hcDpJZSxub3JtYWxNYXA6TmUsZGlzcGxhY2VtZW50TWFwOmYmJlNlLGVtaXNzaXZlTWFwOmplLG5vcm1hbE1hcE9iamVjdFNwYWNlOk5lJiZFLm5vcm1hbE1hcFR5cGU9PT0xLG5vcm1hbE1hcFRhbmdlbnRTcGFjZTpOZSYmRS5ub3JtYWxNYXBUeXBlPT09MCxtZXRhbG5lc3NNYXA6TWUscm91Z2huZXNzTWFwOkEsYW5pc290cm9weTp2LGFuaXNvdHJvcHlNYXA6c2UsY2xlYXJjb2F0OkksY2xlYXJjb2F0TWFwOnVlLGNsZWFyY29hdE5vcm1hbE1hcDpHZSxjbGVhcmNvYXRSb3VnaG5lc3NNYXA6aixkaXNwZXJzaW9uOlksaXJpZGVzY2VuY2U6SyxpcmlkZXNjZW5jZU1hcDpoZSxpcmlkZXNjZW5jZVRoaWNrbmVzc01hcDpFZSxzaGVlbjprLHNoZWVuQ29sb3JNYXA6VGUsc2hlZW5Sb3VnaG5lc3NNYXA6ZGUsc3BlY3VsYXJNYXA6T2Usc3BlY3VsYXJDb2xvck1hcDpMZSxzcGVjdWxhckludGVuc2l0eU1hcDpLZSx0cmFuc21pc3Npb246X2UsdHJhbnNtaXNzaW9uTWFwOkMsdGhpY2tuZXNzTWFwOm5lLGdyYWRpZW50TWFwOkcsb3BhcXVlOkUudHJhbnNwYXJlbnQ9PT0hMSYmRS5ibGVuZGluZz09PTEmJkUuYWxwaGFUb0NvdmVyYWdlPT09ITEsYWxwaGFNYXA6JCxhbHBoYVRlc3Q6bGUsYWxwaGFIYXNoOmFlLGNvbWJpbmU6RS5jb21iaW5lLG1hcFV2Om50JiZ4KEUubWFwLmNoYW5uZWwpLGFvTWFwVXY6VSYmeChFLmFvTWFwLmNoYW5uZWwpLGxpZ2h0TWFwVXY6UHQmJngoRS5saWdodE1hcC5jaGFubmVsKSxidW1wTWFwVXY6SWUmJngoRS5idW1wTWFwLmNoYW5uZWwpLG5vcm1hbE1hcFV2Ok5lJiZ4KEUubm9ybWFsTWFwLmNoYW5uZWwpLGRpc3BsYWNlbWVudE1hcFV2OlNlJiZ4KEUuZGlzcGxhY2VtZW50TWFwLmNoYW5uZWwpLGVtaXNzaXZlTWFwVXY6amUmJngoRS5lbWlzc2l2ZU1hcC5jaGFubmVsKSxtZXRhbG5lc3NNYXBVdjpNZSYmeChFLm1ldGFsbmVzc01hcC5jaGFubmVsKSxyb3VnaG5lc3NNYXBVdjpBJiZ4KEUucm91Z2huZXNzTWFwLmNoYW5uZWwpLGFuaXNvdHJvcHlNYXBVdjpzZSYmeChFLmFuaXNvdHJvcHlNYXAuY2hhbm5lbCksY2xlYXJjb2F0TWFwVXY6dWUmJngoRS5jbGVhcmNvYXRNYXAuY2hhbm5lbCksY2xlYXJjb2F0Tm9ybWFsTWFwVXY6R2UmJngoRS5jbGVhcmNvYXROb3JtYWxNYXAuY2hhbm5lbCksY2xlYXJjb2F0Um91Z2huZXNzTWFwVXY6aiYmeChFLmNsZWFyY29hdFJvdWdobmVzc01hcC5jaGFubmVsKSxpcmlkZXNjZW5jZU1hcFV2OmhlJiZ4KEUuaXJpZGVzY2VuY2VNYXAuY2hhbm5lbCksaXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdjpFZSYmeChFLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLmNoYW5uZWwpLHNoZWVuQ29sb3JNYXBVdjpUZSYmeChFLnNoZWVuQ29sb3JNYXAuY2hhbm5lbCksc2hlZW5Sb3VnaG5lc3NNYXBVdjpkZSYmeChFLnNoZWVuUm91Z2huZXNzTWFwLmNoYW5uZWwpLHNwZWN1bGFyTWFwVXY6T2UmJngoRS5zcGVjdWxhck1hcC5jaGFubmVsKSxzcGVjdWxhckNvbG9yTWFwVXY6TGUmJngoRS5zcGVjdWxhckNvbG9yTWFwLmNoYW5uZWwpLHNwZWN1bGFySW50ZW5zaXR5TWFwVXY6S2UmJngoRS5zcGVjdWxhckludGVuc2l0eU1hcC5jaGFubmVsKSx0cmFuc21pc3Npb25NYXBVdjpDJiZ4KEUudHJhbnNtaXNzaW9uTWFwLmNoYW5uZWwpLHRoaWNrbmVzc01hcFV2Om5lJiZ4KEUudGhpY2tuZXNzTWFwLmNoYW5uZWwpLGFscGhhTWFwVXY6JCYmeChFLmFscGhhTWFwLmNoYW5uZWwpLHZlcnRleFRhbmdlbnRzOiEhWi5hdHRyaWJ1dGVzLnRhbmdlbnQmJihOZXx8diksdmVydGV4Q29sb3JzOkUudmVydGV4Q29sb3JzLHZlcnRleEFscGhhczpFLnZlcnRleENvbG9ycz09PSEwJiYhIVouYXR0cmlidXRlcy5jb2xvciYmWi5hdHRyaWJ1dGVzLmNvbG9yLml0ZW1TaXplPT09NCxwb2ludHNVdnM6ei5pc1BvaW50cz09PSEwJiYhIVouYXR0cmlidXRlcy51diYmKG50fHwkKSxmb2c6ISFXLHVzZUZvZzpFLmZvZz09PSEwLGZvZ0V4cDI6ISFXJiZXLmlzRm9nRXhwMixmbGF0U2hhZGluZzpFLmZsYXRTaGFkaW5nPT09ITAsc2l6ZUF0dGVudWF0aW9uOkUuc2l6ZUF0dGVudWF0aW9uPT09ITAsbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjpkLHJldmVyc2VEZXB0aEJ1ZmZlcjp5ZSxza2lubmluZzp6LmlzU2tpbm5lZE1lc2g9PT0hMCxtb3JwaFRhcmdldHM6Wi5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24hPT12b2lkIDAsbW9ycGhOb3JtYWxzOloubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCE9PXZvaWQgMCxtb3JwaENvbG9yczpaLm1vcnBoQXR0cmlidXRlcy5jb2xvciE9PXZvaWQgMCxtb3JwaFRhcmdldHNDb3VudDp4ZSxtb3JwaFRleHR1cmVTdHJpZGU6VWUsbnVtRGlyTGlnaHRzOlMuZGlyZWN0aW9uYWwubGVuZ3RoLG51bVBvaW50TGlnaHRzOlMucG9pbnQubGVuZ3RoLG51bVNwb3RMaWdodHM6Uy5zcG90Lmxlbmd0aCxudW1TcG90TGlnaHRNYXBzOlMuc3BvdExpZ2h0TWFwLmxlbmd0aCxudW1SZWN0QXJlYUxpZ2h0czpTLnJlY3RBcmVhLmxlbmd0aCxudW1IZW1pTGlnaHRzOlMuaGVtaS5sZW5ndGgsbnVtRGlyTGlnaHRTaGFkb3dzOlMuZGlyZWN0aW9uYWxTaGFkb3dNYXAubGVuZ3RoLG51bVBvaW50TGlnaHRTaGFkb3dzOlMucG9pbnRTaGFkb3dNYXAubGVuZ3RoLG51bVNwb3RMaWdodFNoYWRvd3M6Uy5zcG90U2hhZG93TWFwLmxlbmd0aCxudW1TcG90TGlnaHRTaGFkb3dzV2l0aE1hcHM6Uy5udW1TcG90TGlnaHRTaGFkb3dzV2l0aE1hcHMsbnVtTGlnaHRQcm9iZXM6Uy5udW1MaWdodFByb2JlcyxudW1DbGlwcGluZ1BsYW5lczphLm51bVBsYW5lcyxudW1DbGlwSW50ZXJzZWN0aW9uOmEubnVtSW50ZXJzZWN0aW9uLGRpdGhlcmluZzpFLmRpdGhlcmluZyxzaGFkb3dNYXBFbmFibGVkOmkuc2hhZG93TWFwLmVuYWJsZWQmJlIubGVuZ3RoPjAsc2hhZG93TWFwVHlwZTppLnNoYWRvd01hcC50eXBlLHRvbmVNYXBwaW5nOml0LGRlY29kZVZpZGVvVGV4dHVyZTpudCYmRS5tYXAuaXNWaWRlb1RleHR1cmU9PT0hMCYmQmUuZ2V0VHJhbnNmZXIoRS5tYXAuY29sb3JTcGFjZSk9PT1xZSxkZWNvZGVWaWRlb1RleHR1cmVFbWlzc2l2ZTpqZSYmRS5lbWlzc2l2ZU1hcC5pc1ZpZGVvVGV4dHVyZT09PSEwJiZCZS5nZXRUcmFuc2ZlcihFLmVtaXNzaXZlTWFwLmNvbG9yU3BhY2UpPT09cWUscHJlbXVsdGlwbGllZEFscGhhOkUucHJlbXVsdGlwbGllZEFscGhhLGRvdWJsZVNpZGVkOkUuc2lkZT09PTIsZmxpcFNpZGVkOkUuc2lkZT09PTEsdXNlRGVwdGhQYWNraW5nOkUuZGVwdGhQYWNraW5nPj0wLGRlcHRoUGFja2luZzpFLmRlcHRoUGFja2luZ3x8MCxpbmRleDBBdHRyaWJ1dGVOYW1lOkUuaW5kZXgwQXR0cmlidXRlTmFtZSxleHRlbnNpb25DbGlwQ3VsbERpc3RhbmNlOlJlJiZFLmV4dGVuc2lvbnMuY2xpcEN1bGxEaXN0YW5jZT09PSEwJiZuLmhhcygiV0VCR0xfY2xpcF9jdWxsX2Rpc3RhbmNlIiksZXh0ZW5zaW9uTXVsdGlEcmF3OihSZSYmRS5leHRlbnNpb25zLm11bHRpRHJhdz09PSEwfHxGZSkmJm4uaGFzKCJXRUJHTF9tdWx0aV9kcmF3IikscmVuZGVyZXJFeHRlbnNpb25QYXJhbGxlbFNoYWRlckNvbXBpbGU6bi5oYXMoIktIUl9wYXJhbGxlbF9zaGFkZXJfY29tcGlsZSIpLGN1c3RvbVByb2dyYW1DYWNoZUtleTpFLmN1c3RvbVByb2dyYW1DYWNoZUtleSgpfTtyZXR1cm4gbXQudmVydGV4VXYxcz1jLmhhcygxKSxtdC52ZXJ0ZXhVdjJzPWMuaGFzKDIpLG10LnZlcnRleFV2M3M9Yy5oYXMoMyksYy5jbGVhcigpLG10fWZ1bmN0aW9uIHUoRSl7Y29uc3QgUz1bXTtpZihFLnNoYWRlcklEP1MucHVzaChFLnNoYWRlcklEKTooUy5wdXNoKEUuY3VzdG9tVmVydGV4U2hhZGVySUQpLFMucHVzaChFLmN1c3RvbUZyYWdtZW50U2hhZGVySUQpKSxFLmRlZmluZXMhPT12b2lkIDApZm9yKGNvbnN0IFIgaW4gRS5kZWZpbmVzKVMucHVzaChSKSxTLnB1c2goRS5kZWZpbmVzW1JdKTtyZXR1cm4gRS5pc1Jhd1NoYWRlck1hdGVyaWFsPT09ITEmJihUKFMsRSkseShTLEUpLFMucHVzaChpLm91dHB1dENvbG9yU3BhY2UpKSxTLnB1c2goRS5jdXN0b21Qcm9ncmFtQ2FjaGVLZXkpLFMuam9pbigpfWZ1bmN0aW9uIFQoRSxTKXtFLnB1c2goUy5wcmVjaXNpb24pLEUucHVzaChTLm91dHB1dENvbG9yU3BhY2UpLEUucHVzaChTLmVudk1hcE1vZGUpLEUucHVzaChTLmVudk1hcEN1YmVVVkhlaWdodCksRS5wdXNoKFMubWFwVXYpLEUucHVzaChTLmFscGhhTWFwVXYpLEUucHVzaChTLmxpZ2h0TWFwVXYpLEUucHVzaChTLmFvTWFwVXYpLEUucHVzaChTLmJ1bXBNYXBVdiksRS5wdXNoKFMubm9ybWFsTWFwVXYpLEUucHVzaChTLmRpc3BsYWNlbWVudE1hcFV2KSxFLnB1c2goUy5lbWlzc2l2ZU1hcFV2KSxFLnB1c2goUy5tZXRhbG5lc3NNYXBVdiksRS5wdXNoKFMucm91Z2huZXNzTWFwVXYpLEUucHVzaChTLmFuaXNvdHJvcHlNYXBVdiksRS5wdXNoKFMuY2xlYXJjb2F0TWFwVXYpLEUucHVzaChTLmNsZWFyY29hdE5vcm1hbE1hcFV2KSxFLnB1c2goUy5jbGVhcmNvYXRSb3VnaG5lc3NNYXBVdiksRS5wdXNoKFMuaXJpZGVzY2VuY2VNYXBVdiksRS5wdXNoKFMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdiksRS5wdXNoKFMuc2hlZW5Db2xvck1hcFV2KSxFLnB1c2goUy5zaGVlblJvdWdobmVzc01hcFV2KSxFLnB1c2goUy5zcGVjdWxhck1hcFV2KSxFLnB1c2goUy5zcGVjdWxhckNvbG9yTWFwVXYpLEUucHVzaChTLnNwZWN1bGFySW50ZW5zaXR5TWFwVXYpLEUucHVzaChTLnRyYW5zbWlzc2lvbk1hcFV2KSxFLnB1c2goUy50aGlja25lc3NNYXBVdiksRS5wdXNoKFMuY29tYmluZSksRS5wdXNoKFMuZm9nRXhwMiksRS5wdXNoKFMuc2l6ZUF0dGVudWF0aW9uKSxFLnB1c2goUy5tb3JwaFRhcmdldHNDb3VudCksRS5wdXNoKFMubW9ycGhBdHRyaWJ1dGVDb3VudCksRS5wdXNoKFMubnVtRGlyTGlnaHRzKSxFLnB1c2goUy5udW1Qb2ludExpZ2h0cyksRS5wdXNoKFMubnVtU3BvdExpZ2h0cyksRS5wdXNoKFMubnVtU3BvdExpZ2h0TWFwcyksRS5wdXNoKFMubnVtSGVtaUxpZ2h0cyksRS5wdXNoKFMubnVtUmVjdEFyZWFMaWdodHMpLEUucHVzaChTLm51bURpckxpZ2h0U2hhZG93cyksRS5wdXNoKFMubnVtUG9pbnRMaWdodFNoYWRvd3MpLEUucHVzaChTLm51bVNwb3RMaWdodFNoYWRvd3MpLEUucHVzaChTLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcyksRS5wdXNoKFMubnVtTGlnaHRQcm9iZXMpLEUucHVzaChTLnNoYWRvd01hcFR5cGUpLEUucHVzaChTLnRvbmVNYXBwaW5nKSxFLnB1c2goUy5udW1DbGlwcGluZ1BsYW5lcyksRS5wdXNoKFMubnVtQ2xpcEludGVyc2VjdGlvbiksRS5wdXNoKFMuZGVwdGhQYWNraW5nKX1mdW5jdGlvbiB5KEUsUyl7by5kaXNhYmxlQWxsKCksUy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzJiZvLmVuYWJsZSgwKSxTLmluc3RhbmNpbmcmJm8uZW5hYmxlKDEpLFMuaW5zdGFuY2luZ0NvbG9yJiZvLmVuYWJsZSgyKSxTLmluc3RhbmNpbmdNb3JwaCYmby5lbmFibGUoMyksUy5tYXRjYXAmJm8uZW5hYmxlKDQpLFMuZW52TWFwJiZvLmVuYWJsZSg1KSxTLm5vcm1hbE1hcE9iamVjdFNwYWNlJiZvLmVuYWJsZSg2KSxTLm5vcm1hbE1hcFRhbmdlbnRTcGFjZSYmby5lbmFibGUoNyksUy5jbGVhcmNvYXQmJm8uZW5hYmxlKDgpLFMuaXJpZGVzY2VuY2UmJm8uZW5hYmxlKDkpLFMuYWxwaGFUZXN0JiZvLmVuYWJsZSgxMCksUy52ZXJ0ZXhDb2xvcnMmJm8uZW5hYmxlKDExKSxTLnZlcnRleEFscGhhcyYmby5lbmFibGUoMTIpLFMudmVydGV4VXYxcyYmby5lbmFibGUoMTMpLFMudmVydGV4VXYycyYmby5lbmFibGUoMTQpLFMudmVydGV4VXYzcyYmby5lbmFibGUoMTUpLFMudmVydGV4VGFuZ2VudHMmJm8uZW5hYmxlKDE2KSxTLmFuaXNvdHJvcHkmJm8uZW5hYmxlKDE3KSxTLmFscGhhSGFzaCYmby5lbmFibGUoMTgpLFMuYmF0Y2hpbmcmJm8uZW5hYmxlKDE5KSxTLmRpc3BlcnNpb24mJm8uZW5hYmxlKDIwKSxTLmJhdGNoaW5nQ29sb3ImJm8uZW5hYmxlKDIxKSxFLnB1c2goby5tYXNrKSxvLmRpc2FibGVBbGwoKSxTLmZvZyYmby5lbmFibGUoMCksUy51c2VGb2cmJm8uZW5hYmxlKDEpLFMuZmxhdFNoYWRpbmcmJm8uZW5hYmxlKDIpLFMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciYmby5lbmFibGUoMyksUy5yZXZlcnNlRGVwdGhCdWZmZXImJm8uZW5hYmxlKDQpLFMuc2tpbm5pbmcmJm8uZW5hYmxlKDUpLFMubW9ycGhUYXJnZXRzJiZvLmVuYWJsZSg2KSxTLm1vcnBoTm9ybWFscyYmby5lbmFibGUoNyksUy5tb3JwaENvbG9ycyYmby5lbmFibGUoOCksUy5wcmVtdWx0aXBsaWVkQWxwaGEmJm8uZW5hYmxlKDkpLFMuc2hhZG93TWFwRW5hYmxlZCYmby5lbmFibGUoMTApLFMuZG91YmxlU2lkZWQmJm8uZW5hYmxlKDExKSxTLmZsaXBTaWRlZCYmby5lbmFibGUoMTIpLFMudXNlRGVwdGhQYWNraW5nJiZvLmVuYWJsZSgxMyksUy5kaXRoZXJpbmcmJm8uZW5hYmxlKDE0KSxTLnRyYW5zbWlzc2lvbiYmby5lbmFibGUoMTUpLFMuc2hlZW4mJm8uZW5hYmxlKDE2KSxTLm9wYXF1ZSYmby5lbmFibGUoMTcpLFMucG9pbnRzVXZzJiZvLmVuYWJsZSgxOCksUy5kZWNvZGVWaWRlb1RleHR1cmUmJm8uZW5hYmxlKDE5KSxTLmRlY29kZVZpZGVvVGV4dHVyZUVtaXNzaXZlJiZvLmVuYWJsZSgyMCksUy5hbHBoYVRvQ292ZXJhZ2UmJm8uZW5hYmxlKDIxKSxFLnB1c2goby5tYXNrKX1mdW5jdGlvbiBnKEUpe2NvbnN0IFM9X1tFLnR5cGVdO2xldCBSO2lmKFMpe2NvbnN0IHE9enRbU107Uj1QYS5jbG9uZShxLnVuaWZvcm1zKX1lbHNlIFI9RS51bmlmb3JtcztyZXR1cm4gUn1mdW5jdGlvbiBQKEUsUyl7bGV0IFI7Zm9yKGxldCBxPTAsej1oLmxlbmd0aDtxPHo7cSsrKXtjb25zdCBXPWhbcV07aWYoVy5jYWNoZUtleT09PVMpe1I9VywrK1IudXNlZFRpbWVzO2JyZWFrfX1yZXR1cm4gUj09PXZvaWQgMCYmKFI9bmV3IHV1KGksUyxFLHMpLGgucHVzaChSKSksUn1mdW5jdGlvbiB3KEUpe2lmKC0tRS51c2VkVGltZXM9PT0wKXtjb25zdCBTPWguaW5kZXhPZihFKTtoW1NdPWhbaC5sZW5ndGgtMV0saC5wb3AoKSxFLmRlc3Ryb3koKX19ZnVuY3Rpb24gYihFKXtsLnJlbW92ZShFKX1mdW5jdGlvbiBGKCl7bC5kaXNwb3NlKCl9cmV0dXJue2dldFBhcmFtZXRlcnM6bSxnZXRQcm9ncmFtQ2FjaGVLZXk6dSxnZXRVbmlmb3JtczpnLGFjcXVpcmVQcm9ncmFtOlAscmVsZWFzZVByb2dyYW06dyxyZWxlYXNlU2hhZGVyQ2FjaGU6Yixwcm9ncmFtczpoLGRpc3Bvc2U6Rn19ZnVuY3Rpb24gbXUoKXtsZXQgaT1uZXcgV2Vha01hcDtmdW5jdGlvbiBlKGEpe3JldHVybiBpLmhhcyhhKX1mdW5jdGlvbiB0KGEpe2xldCBvPWkuZ2V0KGEpO3JldHVybiBvPT09dm9pZCAwJiYobz17fSxpLnNldChhLG8pKSxvfWZ1bmN0aW9uIG4oYSl7aS5kZWxldGUoYSl9ZnVuY3Rpb24gcihhLG8sbCl7aS5nZXQoYSlbb109bH1mdW5jdGlvbiBzKCl7aT1uZXcgV2Vha01hcH1yZXR1cm57aGFzOmUsZ2V0OnQscmVtb3ZlOm4sdXBkYXRlOnIsZGlzcG9zZTpzfX1mdW5jdGlvbiBndShpLGUpe3JldHVybiBpLmdyb3VwT3JkZXIhPT1lLmdyb3VwT3JkZXI/aS5ncm91cE9yZGVyLWUuZ3JvdXBPcmRlcjppLnJlbmRlck9yZGVyIT09ZS5yZW5kZXJPcmRlcj9pLnJlbmRlck9yZGVyLWUucmVuZGVyT3JkZXI6aS5tYXRlcmlhbC5pZCE9PWUubWF0ZXJpYWwuaWQ/aS5tYXRlcmlhbC5pZC1lLm1hdGVyaWFsLmlkOmkueiE9PWUuej9pLnotZS56OmkuaWQtZS5pZH1mdW5jdGlvbiB3cyhpLGUpe3JldHVybiBpLmdyb3VwT3JkZXIhPT1lLmdyb3VwT3JkZXI/aS5ncm91cE9yZGVyLWUuZ3JvdXBPcmRlcjppLnJlbmRlck9yZGVyIT09ZS5yZW5kZXJPcmRlcj9pLnJlbmRlck9yZGVyLWUucmVuZGVyT3JkZXI6aS56IT09ZS56P2Uuei1pLno6aS5pZC1lLmlkfWZ1bmN0aW9uIGJzKCl7Y29uc3QgaT1bXTtsZXQgZT0wO2NvbnN0IHQ9W10sbj1bXSxyPVtdO2Z1bmN0aW9uIHMoKXtlPTAsdC5sZW5ndGg9MCxuLmxlbmd0aD0wLHIubGVuZ3RoPTB9ZnVuY3Rpb24gYShkLGYscCxfLHgsbSl7bGV0IHU9aVtlXTtyZXR1cm4gdT09PXZvaWQgMD8odT17aWQ6ZC5pZCxvYmplY3Q6ZCxnZW9tZXRyeTpmLG1hdGVyaWFsOnAsZ3JvdXBPcmRlcjpfLHJlbmRlck9yZGVyOmQucmVuZGVyT3JkZXIsejp4LGdyb3VwOm19LGlbZV09dSk6KHUuaWQ9ZC5pZCx1Lm9iamVjdD1kLHUuZ2VvbWV0cnk9Zix1Lm1hdGVyaWFsPXAsdS5ncm91cE9yZGVyPV8sdS5yZW5kZXJPcmRlcj1kLnJlbmRlck9yZGVyLHUuej14LHUuZ3JvdXA9bSksZSsrLHV9ZnVuY3Rpb24gbyhkLGYscCxfLHgsbSl7Y29uc3QgdT1hKGQsZixwLF8seCxtKTtwLnRyYW5zbWlzc2lvbj4wP24ucHVzaCh1KTpwLnRyYW5zcGFyZW50PT09ITA/ci5wdXNoKHUpOnQucHVzaCh1KX1mdW5jdGlvbiBsKGQsZixwLF8seCxtKXtjb25zdCB1PWEoZCxmLHAsXyx4LG0pO3AudHJhbnNtaXNzaW9uPjA/bi51bnNoaWZ0KHUpOnAudHJhbnNwYXJlbnQ9PT0hMD9yLnVuc2hpZnQodSk6dC51bnNoaWZ0KHUpfWZ1bmN0aW9uIGMoZCxmKXt0Lmxlbmd0aD4xJiZ0LnNvcnQoZHx8Z3UpLG4ubGVuZ3RoPjEmJm4uc29ydChmfHx3cyksci5sZW5ndGg+MSYmci5zb3J0KGZ8fHdzKX1mdW5jdGlvbiBoKCl7Zm9yKGxldCBkPWUsZj1pLmxlbmd0aDtkPGY7ZCsrKXtjb25zdCBwPWlbZF07aWYocC5pZD09PW51bGwpYnJlYWs7cC5pZD1udWxsLHAub2JqZWN0PW51bGwscC5nZW9tZXRyeT1udWxsLHAubWF0ZXJpYWw9bnVsbCxwLmdyb3VwPW51bGx9fXJldHVybntvcGFxdWU6dCx0cmFuc21pc3NpdmU6bix0cmFuc3BhcmVudDpyLGluaXQ6cyxwdXNoOm8sdW5zaGlmdDpsLGZpbmlzaDpoLHNvcnQ6Y319ZnVuY3Rpb24gX3UoKXtsZXQgaT1uZXcgV2Vha01hcDtmdW5jdGlvbiBlKG4scil7Y29uc3Qgcz1pLmdldChuKTtsZXQgYTtyZXR1cm4gcz09PXZvaWQgMD8oYT1uZXcgYnMsaS5zZXQobixbYV0pKTpyPj1zLmxlbmd0aD8oYT1uZXcgYnMscy5wdXNoKGEpKTphPXNbcl0sYX1mdW5jdGlvbiB0KCl7aT1uZXcgV2Vha01hcH1yZXR1cm57Z2V0OmUsZGlzcG9zZTp0fX1mdW5jdGlvbiB2dSgpe2NvbnN0IGk9e307cmV0dXJue2dldDpmdW5jdGlvbihlKXtpZihpW2UuaWRdIT09dm9pZCAwKXJldHVybiBpW2UuaWRdO2xldCB0O3N3aXRjaChlLnR5cGUpe2Nhc2UiRGlyZWN0aW9uYWxMaWdodCI6dD17ZGlyZWN0aW9uOm5ldyBPLGNvbG9yOm5ldyBWZX07YnJlYWs7Y2FzZSJTcG90TGlnaHQiOnQ9e3Bvc2l0aW9uOm5ldyBPLGRpcmVjdGlvbjpuZXcgTyxjb2xvcjpuZXcgVmUsZGlzdGFuY2U6MCxjb25lQ29zOjAscGVudW1icmFDb3M6MCxkZWNheTowfTticmVhaztjYXNlIlBvaW50TGlnaHQiOnQ9e3Bvc2l0aW9uOm5ldyBPLGNvbG9yOm5ldyBWZSxkaXN0YW5jZTowLGRlY2F5OjB9O2JyZWFrO2Nhc2UiSGVtaXNwaGVyZUxpZ2h0Ijp0PXtkaXJlY3Rpb246bmV3IE8sc2t5Q29sb3I6bmV3IFZlLGdyb3VuZENvbG9yOm5ldyBWZX07YnJlYWs7Y2FzZSJSZWN0QXJlYUxpZ2h0Ijp0PXtjb2xvcjpuZXcgVmUscG9zaXRpb246bmV3IE8saGFsZldpZHRoOm5ldyBPLGhhbGZIZWlnaHQ6bmV3IE99O2JyZWFrfXJldHVybiBpW2UuaWRdPXQsdH19fWZ1bmN0aW9uIHh1KCl7Y29uc3QgaT17fTtyZXR1cm57Z2V0OmZ1bmN0aW9uKGUpe2lmKGlbZS5pZF0hPT12b2lkIDApcmV0dXJuIGlbZS5pZF07bGV0IHQ7c3dpdGNoKGUudHlwZSl7Y2FzZSJEaXJlY3Rpb25hbExpZ2h0Ijp0PXtzaGFkb3dJbnRlbnNpdHk6MSxzaGFkb3dCaWFzOjAsc2hhZG93Tm9ybWFsQmlhczowLHNoYWRvd1JhZGl1czoxLHNoYWRvd01hcFNpemU6bmV3IFBlfTticmVhaztjYXNlIlNwb3RMaWdodCI6dD17c2hhZG93SW50ZW5zaXR5OjEsc2hhZG93QmlhczowLHNoYWRvd05vcm1hbEJpYXM6MCxzaGFkb3dSYWRpdXM6MSxzaGFkb3dNYXBTaXplOm5ldyBQZX07YnJlYWs7Y2FzZSJQb2ludExpZ2h0Ijp0PXtzaGFkb3dJbnRlbnNpdHk6MSxzaGFkb3dCaWFzOjAsc2hhZG93Tm9ybWFsQmlhczowLHNoYWRvd1JhZGl1czoxLHNoYWRvd01hcFNpemU6bmV3IFBlLHNoYWRvd0NhbWVyYU5lYXI6MSxzaGFkb3dDYW1lcmFGYXI6MWUzfTticmVha31yZXR1cm4gaVtlLmlkXT10LHR9fX1sZXQgTXU9MDtmdW5jdGlvbiBTdShpLGUpe3JldHVybihlLmNhc3RTaGFkb3c/MjowKS0oaS5jYXN0U2hhZG93PzI6MCkrKGUubWFwPzE6MCktKGkubWFwPzE6MCl9ZnVuY3Rpb24gRXUoaSl7Y29uc3QgZT1uZXcgdnUsdD14dSgpLG49e3ZlcnNpb246MCxoYXNoOntkaXJlY3Rpb25hbExlbmd0aDotMSxwb2ludExlbmd0aDotMSxzcG90TGVuZ3RoOi0xLHJlY3RBcmVhTGVuZ3RoOi0xLGhlbWlMZW5ndGg6LTEsbnVtRGlyZWN0aW9uYWxTaGFkb3dzOi0xLG51bVBvaW50U2hhZG93czotMSxudW1TcG90U2hhZG93czotMSxudW1TcG90TWFwczotMSxudW1MaWdodFByb2JlczotMX0sYW1iaWVudDpbMCwwLDBdLHByb2JlOltdLGRpcmVjdGlvbmFsOltdLGRpcmVjdGlvbmFsU2hhZG93OltdLGRpcmVjdGlvbmFsU2hhZG93TWFwOltdLGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OltdLHNwb3Q6W10sc3BvdExpZ2h0TWFwOltdLHNwb3RTaGFkb3c6W10sc3BvdFNoYWRvd01hcDpbXSxzcG90TGlnaHRNYXRyaXg6W10scmVjdEFyZWE6W10scmVjdEFyZWFMVEMxOm51bGwscmVjdEFyZWFMVEMyOm51bGwscG9pbnQ6W10scG9pbnRTaGFkb3c6W10scG9pbnRTaGFkb3dNYXA6W10scG9pbnRTaGFkb3dNYXRyaXg6W10saGVtaTpbXSxudW1TcG90TGlnaHRTaGFkb3dzV2l0aE1hcHM6MCxudW1MaWdodFByb2JlczowfTtmb3IobGV0IGM9MDtjPDk7YysrKW4ucHJvYmUucHVzaChuZXcgTyk7Y29uc3Qgcj1uZXcgTyxzPW5ldyBzdCxhPW5ldyBzdDtmdW5jdGlvbiBvKGMpe2xldCBoPTAsZD0wLGY9MDtmb3IobGV0IEU9MDtFPDk7RSsrKW4ucHJvYmVbRV0uc2V0KDAsMCwwKTtsZXQgcD0wLF89MCx4PTAsbT0wLHU9MCxUPTAseT0wLGc9MCxQPTAsdz0wLGI9MDtjLnNvcnQoU3UpO2ZvcihsZXQgRT0wLFM9Yy5sZW5ndGg7RTxTO0UrKyl7Y29uc3QgUj1jW0VdLHE9Ui5jb2xvcix6PVIuaW50ZW5zaXR5LFc9Ui5kaXN0YW5jZSxaPVIuc2hhZG93JiZSLnNoYWRvdy5tYXA/Ui5zaGFkb3cubWFwLnRleHR1cmU6bnVsbDtpZihSLmlzQW1iaWVudExpZ2h0KWgrPXEucip6LGQrPXEuZyp6LGYrPXEuYip6O2Vsc2UgaWYoUi5pc0xpZ2h0UHJvYmUpe2ZvcihsZXQgVj0wO1Y8OTtWKyspbi5wcm9iZVtWXS5hZGRTY2FsZWRWZWN0b3IoUi5zaC5jb2VmZmljaWVudHNbVl0seik7YisrfWVsc2UgaWYoUi5pc0RpcmVjdGlvbmFsTGlnaHQpe2NvbnN0IFY9ZS5nZXQoUik7aWYoVi5jb2xvci5jb3B5KFIuY29sb3IpLm11bHRpcGx5U2NhbGFyKFIuaW50ZW5zaXR5KSxSLmNhc3RTaGFkb3cpe2NvbnN0IFE9Ui5zaGFkb3csSD10LmdldChSKTtILnNoYWRvd0ludGVuc2l0eT1RLmludGVuc2l0eSxILnNoYWRvd0JpYXM9US5iaWFzLEguc2hhZG93Tm9ybWFsQmlhcz1RLm5vcm1hbEJpYXMsSC5zaGFkb3dSYWRpdXM9US5yYWRpdXMsSC5zaGFkb3dNYXBTaXplPVEubWFwU2l6ZSxuLmRpcmVjdGlvbmFsU2hhZG93W3BdPUgsbi5kaXJlY3Rpb25hbFNoYWRvd01hcFtwXT1aLG4uZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbcF09Ui5zaGFkb3cubWF0cml4LFQrK31uLmRpcmVjdGlvbmFsW3BdPVYscCsrfWVsc2UgaWYoUi5pc1Nwb3RMaWdodCl7Y29uc3QgVj1lLmdldChSKTtWLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihSLm1hdHJpeFdvcmxkKSxWLmNvbG9yLmNvcHkocSkubXVsdGlwbHlTY2FsYXIoeiksVi5kaXN0YW5jZT1XLFYuY29uZUNvcz1NYXRoLmNvcyhSLmFuZ2xlKSxWLnBlbnVtYnJhQ29zPU1hdGguY29zKFIuYW5nbGUqKDEtUi5wZW51bWJyYSkpLFYuZGVjYXk9Ui5kZWNheSxuLnNwb3RbeF09Vjtjb25zdCBRPVIuc2hhZG93O2lmKFIubWFwJiYobi5zcG90TGlnaHRNYXBbUF09Ui5tYXAsUCsrLFEudXBkYXRlTWF0cmljZXMoUiksUi5jYXN0U2hhZG93JiZ3KyspLG4uc3BvdExpZ2h0TWF0cml4W3hdPVEubWF0cml4LFIuY2FzdFNoYWRvdyl7Y29uc3QgSD10LmdldChSKTtILnNoYWRvd0ludGVuc2l0eT1RLmludGVuc2l0eSxILnNoYWRvd0JpYXM9US5iaWFzLEguc2hhZG93Tm9ybWFsQmlhcz1RLm5vcm1hbEJpYXMsSC5zaGFkb3dSYWRpdXM9US5yYWRpdXMsSC5zaGFkb3dNYXBTaXplPVEubWFwU2l6ZSxuLnNwb3RTaGFkb3dbeF09SCxuLnNwb3RTaGFkb3dNYXBbeF09WixnKyt9eCsrfWVsc2UgaWYoUi5pc1JlY3RBcmVhTGlnaHQpe2NvbnN0IFY9ZS5nZXQoUik7Vi5jb2xvci5jb3B5KHEpLm11bHRpcGx5U2NhbGFyKHopLFYuaGFsZldpZHRoLnNldChSLndpZHRoKi41LDAsMCksVi5oYWxmSGVpZ2h0LnNldCgwLFIuaGVpZ2h0Ki41LDApLG4ucmVjdEFyZWFbbV09VixtKyt9ZWxzZSBpZihSLmlzUG9pbnRMaWdodCl7Y29uc3QgVj1lLmdldChSKTtpZihWLmNvbG9yLmNvcHkoUi5jb2xvcikubXVsdGlwbHlTY2FsYXIoUi5pbnRlbnNpdHkpLFYuZGlzdGFuY2U9Ui5kaXN0YW5jZSxWLmRlY2F5PVIuZGVjYXksUi5jYXN0U2hhZG93KXtjb25zdCBRPVIuc2hhZG93LEg9dC5nZXQoUik7SC5zaGFkb3dJbnRlbnNpdHk9US5pbnRlbnNpdHksSC5zaGFkb3dCaWFzPVEuYmlhcyxILnNoYWRvd05vcm1hbEJpYXM9US5ub3JtYWxCaWFzLEguc2hhZG93UmFkaXVzPVEucmFkaXVzLEguc2hhZG93TWFwU2l6ZT1RLm1hcFNpemUsSC5zaGFkb3dDYW1lcmFOZWFyPVEuY2FtZXJhLm5lYXIsSC5zaGFkb3dDYW1lcmFGYXI9US5jYW1lcmEuZmFyLG4ucG9pbnRTaGFkb3dbX109SCxuLnBvaW50U2hhZG93TWFwW19dPVosbi5wb2ludFNoYWRvd01hdHJpeFtfXT1SLnNoYWRvdy5tYXRyaXgseSsrfW4ucG9pbnRbX109VixfKyt9ZWxzZSBpZihSLmlzSGVtaXNwaGVyZUxpZ2h0KXtjb25zdCBWPWUuZ2V0KFIpO1Yuc2t5Q29sb3IuY29weShSLmNvbG9yKS5tdWx0aXBseVNjYWxhcih6KSxWLmdyb3VuZENvbG9yLmNvcHkoUi5ncm91bmRDb2xvcikubXVsdGlwbHlTY2FsYXIoeiksbi5oZW1pW3VdPVYsdSsrfX1tPjAmJihpLmhhcygiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyIik9PT0hMD8obi5yZWN0QXJlYUxUQzE9dGUuTFRDX0ZMT0FUXzEsbi5yZWN0QXJlYUxUQzI9dGUuTFRDX0ZMT0FUXzIpOihuLnJlY3RBcmVhTFRDMT10ZS5MVENfSEFMRl8xLG4ucmVjdEFyZWFMVEMyPXRlLkxUQ19IQUxGXzIpKSxuLmFtYmllbnRbMF09aCxuLmFtYmllbnRbMV09ZCxuLmFtYmllbnRbMl09Zjtjb25zdCBGPW4uaGFzaDsoRi5kaXJlY3Rpb25hbExlbmd0aCE9PXB8fEYucG9pbnRMZW5ndGghPT1ffHxGLnNwb3RMZW5ndGghPT14fHxGLnJlY3RBcmVhTGVuZ3RoIT09bXx8Ri5oZW1pTGVuZ3RoIT09dXx8Ri5udW1EaXJlY3Rpb25hbFNoYWRvd3MhPT1UfHxGLm51bVBvaW50U2hhZG93cyE9PXl8fEYubnVtU3BvdFNoYWRvd3MhPT1nfHxGLm51bVNwb3RNYXBzIT09UHx8Ri5udW1MaWdodFByb2JlcyE9PWIpJiYobi5kaXJlY3Rpb25hbC5sZW5ndGg9cCxuLnNwb3QubGVuZ3RoPXgsbi5yZWN0QXJlYS5sZW5ndGg9bSxuLnBvaW50Lmxlbmd0aD1fLG4uaGVtaS5sZW5ndGg9dSxuLmRpcmVjdGlvbmFsU2hhZG93Lmxlbmd0aD1ULG4uZGlyZWN0aW9uYWxTaGFkb3dNYXAubGVuZ3RoPVQsbi5wb2ludFNoYWRvdy5sZW5ndGg9eSxuLnBvaW50U2hhZG93TWFwLmxlbmd0aD15LG4uc3BvdFNoYWRvdy5sZW5ndGg9ZyxuLnNwb3RTaGFkb3dNYXAubGVuZ3RoPWcsbi5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeC5sZW5ndGg9VCxuLnBvaW50U2hhZG93TWF0cml4Lmxlbmd0aD15LG4uc3BvdExpZ2h0TWF0cml4Lmxlbmd0aD1nK1AtdyxuLnNwb3RMaWdodE1hcC5sZW5ndGg9UCxuLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcz13LG4ubnVtTGlnaHRQcm9iZXM9YixGLmRpcmVjdGlvbmFsTGVuZ3RoPXAsRi5wb2ludExlbmd0aD1fLEYuc3BvdExlbmd0aD14LEYucmVjdEFyZWFMZW5ndGg9bSxGLmhlbWlMZW5ndGg9dSxGLm51bURpcmVjdGlvbmFsU2hhZG93cz1ULEYubnVtUG9pbnRTaGFkb3dzPXksRi5udW1TcG90U2hhZG93cz1nLEYubnVtU3BvdE1hcHM9UCxGLm51bUxpZ2h0UHJvYmVzPWIsbi52ZXJzaW9uPU11KyspfWZ1bmN0aW9uIGwoYyxoKXtsZXQgZD0wLGY9MCxwPTAsXz0wLHg9MDtjb25zdCBtPWgubWF0cml4V29ybGRJbnZlcnNlO2ZvcihsZXQgdT0wLFQ9Yy5sZW5ndGg7dTxUO3UrKyl7Y29uc3QgeT1jW3VdO2lmKHkuaXNEaXJlY3Rpb25hbExpZ2h0KXtjb25zdCBnPW4uZGlyZWN0aW9uYWxbZF07Zy5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHkubWF0cml4V29ybGQpLHIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHkudGFyZ2V0Lm1hdHJpeFdvcmxkKSxnLmRpcmVjdGlvbi5zdWIociksZy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKG0pLGQrK31lbHNlIGlmKHkuaXNTcG90TGlnaHQpe2NvbnN0IGc9bi5zcG90W3BdO2cucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHkubWF0cml4V29ybGQpLGcucG9zaXRpb24uYXBwbHlNYXRyaXg0KG0pLGcuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbih5Lm1hdHJpeFdvcmxkKSxyLnNldEZyb21NYXRyaXhQb3NpdGlvbih5LnRhcmdldC5tYXRyaXhXb3JsZCksZy5kaXJlY3Rpb24uc3ViKHIpLGcuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbihtKSxwKyt9ZWxzZSBpZih5LmlzUmVjdEFyZWFMaWdodCl7Y29uc3QgZz1uLnJlY3RBcmVhW19dO2cucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHkubWF0cml4V29ybGQpLGcucG9zaXRpb24uYXBwbHlNYXRyaXg0KG0pLGEuaWRlbnRpdHkoKSxzLmNvcHkoeS5tYXRyaXhXb3JsZCkscy5wcmVtdWx0aXBseShtKSxhLmV4dHJhY3RSb3RhdGlvbihzKSxnLmhhbGZXaWR0aC5zZXQoeS53aWR0aCouNSwwLDApLGcuaGFsZkhlaWdodC5zZXQoMCx5LmhlaWdodCouNSwwKSxnLmhhbGZXaWR0aC5hcHBseU1hdHJpeDQoYSksZy5oYWxmSGVpZ2h0LmFwcGx5TWF0cml4NChhKSxfKyt9ZWxzZSBpZih5LmlzUG9pbnRMaWdodCl7Y29uc3QgZz1uLnBvaW50W2ZdO2cucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHkubWF0cml4V29ybGQpLGcucG9zaXRpb24uYXBwbHlNYXRyaXg0KG0pLGYrK31lbHNlIGlmKHkuaXNIZW1pc3BoZXJlTGlnaHQpe2NvbnN0IGc9bi5oZW1pW3hdO2cuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbih5Lm1hdHJpeFdvcmxkKSxnLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24obSkseCsrfX19cmV0dXJue3NldHVwOm8sc2V0dXBWaWV3Omwsc3RhdGU6bn19ZnVuY3Rpb24gUnMoaSl7Y29uc3QgZT1uZXcgRXUoaSksdD1bXSxuPVtdO2Z1bmN0aW9uIHIoaCl7Yy5jYW1lcmE9aCx0Lmxlbmd0aD0wLG4ubGVuZ3RoPTB9ZnVuY3Rpb24gcyhoKXt0LnB1c2goaCl9ZnVuY3Rpb24gYShoKXtuLnB1c2goaCl9ZnVuY3Rpb24gbygpe2Uuc2V0dXAodCl9ZnVuY3Rpb24gbChoKXtlLnNldHVwVmlldyh0LGgpfWNvbnN0IGM9e2xpZ2h0c0FycmF5OnQsc2hhZG93c0FycmF5Om4sY2FtZXJhOm51bGwsbGlnaHRzOmUsdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0Ont9fTtyZXR1cm57aW5pdDpyLHN0YXRlOmMsc2V0dXBMaWdodHM6byxzZXR1cExpZ2h0c1ZpZXc6bCxwdXNoTGlnaHQ6cyxwdXNoU2hhZG93OmF9fWZ1bmN0aW9uIHl1KGkpe2xldCBlPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIHQocixzPTApe2NvbnN0IGE9ZS5nZXQocik7bGV0IG87cmV0dXJuIGE9PT12b2lkIDA/KG89bmV3IFJzKGkpLGUuc2V0KHIsW29dKSk6cz49YS5sZW5ndGg/KG89bmV3IFJzKGkpLGEucHVzaChvKSk6bz1hW3NdLG99ZnVuY3Rpb24gbigpe2U9bmV3IFdlYWtNYXB9cmV0dXJue2dldDp0LGRpc3Bvc2U6bn19Y2xhc3MgVHUgZXh0ZW5kcyBabntzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iTWVzaERlcHRoTWF0ZXJpYWwifWNvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5pc01lc2hEZXB0aE1hdGVyaWFsPSEwLHRoaXMuZGVwdGhQYWNraW5nPTMyMDAsdGhpcy5tYXA9bnVsbCx0aGlzLmFscGhhTWFwPW51bGwsdGhpcy5kaXNwbGFjZW1lbnRNYXA9bnVsbCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPTEsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPTAsdGhpcy53aXJlZnJhbWU9ITEsdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9MSx0aGlzLnNldFZhbHVlcyhlKX1jb3B5KGUpe3JldHVybiBzdXBlci5jb3B5KGUpLHRoaXMuZGVwdGhQYWNraW5nPWUuZGVwdGhQYWNraW5nLHRoaXMubWFwPWUubWFwLHRoaXMuYWxwaGFNYXA9ZS5hbHBoYU1hcCx0aGlzLmRpc3BsYWNlbWVudE1hcD1lLmRpc3BsYWNlbWVudE1hcCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPWUuZGlzcGxhY2VtZW50U2NhbGUsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPWUuZGlzcGxhY2VtZW50Qmlhcyx0aGlzLndpcmVmcmFtZT1lLndpcmVmcmFtZSx0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD1lLndpcmVmcmFtZUxpbmV3aWR0aCx0aGlzfX1jbGFzcyBBdSBleHRlbmRzIFpue3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJNZXNoRGlzdGFuY2VNYXRlcmlhbCJ9Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWw9ITAsdGhpcy5tYXA9bnVsbCx0aGlzLmFscGhhTWFwPW51bGwsdGhpcy5kaXNwbGFjZW1lbnRNYXA9bnVsbCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPTEsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPTAsdGhpcy5zZXRWYWx1ZXMoZSl9Y29weShlKXtyZXR1cm4gc3VwZXIuY29weShlKSx0aGlzLm1hcD1lLm1hcCx0aGlzLmFscGhhTWFwPWUuYWxwaGFNYXAsdGhpcy5kaXNwbGFjZW1lbnRNYXA9ZS5kaXNwbGFjZW1lbnRNYXAsdGhpcy5kaXNwbGFjZW1lbnRTY2FsZT1lLmRpc3BsYWNlbWVudFNjYWxlLHRoaXMuZGlzcGxhY2VtZW50Qmlhcz1lLmRpc3BsYWNlbWVudEJpYXMsdGhpc319Y29uc3Qgd3U9YHZvaWQgbWFpbigpIHsKCWdsX1Bvc2l0aW9uID0gdmVjNCggcG9zaXRpb24sIDEuMCApOwp9YCxidT1gdW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93X3Bhc3M7CnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uOwp1bmlmb3JtIGZsb2F0IHJhZGl1czsKI2luY2x1ZGUgPHBhY2tpbmc+CnZvaWQgbWFpbigpIHsKCWNvbnN0IGZsb2F0IHNhbXBsZXMgPSBmbG9hdCggVlNNX1NBTVBMRVMgKTsKCWZsb2F0IG1lYW4gPSAwLjA7CglmbG9hdCBzcXVhcmVkX21lYW4gPSAwLjA7CglmbG9hdCB1dlN0cmlkZSA9IHNhbXBsZXMgPD0gMS4wID8gMC4wIDogMi4wIC8gKCBzYW1wbGVzIC0gMS4wICk7CglmbG9hdCB1dlN0YXJ0ID0gc2FtcGxlcyA8PSAxLjAgPyAwLjAgOiAtIDEuMDsKCWZvciAoIGZsb2F0IGkgPSAwLjA7IGkgPCBzYW1wbGVzOyBpICsrICkgewoJCWZsb2F0IHV2T2Zmc2V0ID0gdXZTdGFydCArIGkgKiB1dlN0cmlkZTsKCQkjaWZkZWYgSE9SSVpPTlRBTF9QQVNTCgkJCXZlYzIgZGlzdHJpYnV0aW9uID0gdW5wYWNrUkdCQVRvMkhhbGYoIHRleHR1cmUyRCggc2hhZG93X3Bhc3MsICggZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMiggdXZPZmZzZXQsIDAuMCApICogcmFkaXVzICkgLyByZXNvbHV0aW9uICkgKTsKCQkJbWVhbiArPSBkaXN0cmlidXRpb24ueDsKCQkJc3F1YXJlZF9tZWFuICs9IGRpc3RyaWJ1dGlvbi55ICogZGlzdHJpYnV0aW9uLnkgKyBkaXN0cmlidXRpb24ueCAqIGRpc3RyaWJ1dGlvbi54OwoJCSNlbHNlCgkJCWZsb2F0IGRlcHRoID0gdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggc2hhZG93X3Bhc3MsICggZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMiggMC4wLCB1dk9mZnNldCApICogcmFkaXVzICkgLyByZXNvbHV0aW9uICkgKTsKCQkJbWVhbiArPSBkZXB0aDsKCQkJc3F1YXJlZF9tZWFuICs9IGRlcHRoICogZGVwdGg7CgkJI2VuZGlmCgl9CgltZWFuID0gbWVhbiAvIHNhbXBsZXM7CglzcXVhcmVkX21lYW4gPSBzcXVhcmVkX21lYW4gLyBzYW1wbGVzOwoJZmxvYXQgc3RkX2RldiA9IHNxcnQoIHNxdWFyZWRfbWVhbiAtIG1lYW4gKiBtZWFuICk7CglnbF9GcmFnQ29sb3IgPSBwYWNrMkhhbGZUb1JHQkEoIHZlYzIoIG1lYW4sIHN0ZF9kZXYgKSApOwp9YDtmdW5jdGlvbiBSdShpLGUsdCl7bGV0IG49bmV3IEpyO2NvbnN0IHI9bmV3IFBlLHM9bmV3IFBlLGE9bmV3IHJ0LG89bmV3IFR1KHtkZXB0aFBhY2tpbmc6MzIwMX0pLGw9bmV3IEF1LGM9e30saD10Lm1heFRleHR1cmVTaXplLGQ9ezA6MSwxOjAsMjoyfSxmPW5ldyBsdCh7ZGVmaW5lczp7VlNNX1NBTVBMRVM6OH0sdW5pZm9ybXM6e3NoYWRvd19wYXNzOnt2YWx1ZTpudWxsfSxyZXNvbHV0aW9uOnt2YWx1ZTpuZXcgUGV9LHJhZGl1czp7dmFsdWU6NH19LHZlcnRleFNoYWRlcjp3dSxmcmFnbWVudFNoYWRlcjpidX0pLHA9Zi5jbG9uZSgpO3AuZGVmaW5lcy5IT1JJWk9OVEFMX1BBU1M9MTtjb25zdCBfPW5ldyBDdDtfLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBTdChuZXcgRmxvYXQzMkFycmF5KFstMSwtMSwuNSwzLC0xLC41LC0xLDMsLjVdKSwzKSk7Y29uc3QgeD1uZXcgdHQoXyxmKSxtPXRoaXM7dGhpcy5lbmFibGVkPSExLHRoaXMuYXV0b1VwZGF0ZT0hMCx0aGlzLm5lZWRzVXBkYXRlPSExLHRoaXMudHlwZT0xO2xldCB1PXRoaXMudHlwZTt0aGlzLnJlbmRlcj1mdW5jdGlvbih3LGIsRil7aWYobS5lbmFibGVkPT09ITF8fG0uYXV0b1VwZGF0ZT09PSExJiZtLm5lZWRzVXBkYXRlPT09ITF8fHcubGVuZ3RoPT09MClyZXR1cm47Y29uc3QgRT1pLmdldFJlbmRlclRhcmdldCgpLFM9aS5nZXRBY3RpdmVDdWJlRmFjZSgpLFI9aS5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpLHE9aS5zdGF0ZTtxLnNldEJsZW5kaW5nKDApLHEuYnVmZmVycy5jb2xvci5zZXRDbGVhcigxLDEsMSwxKSxxLmJ1ZmZlcnMuZGVwdGguc2V0VGVzdCghMCkscS5zZXRTY2lzc29yVGVzdCghMSk7Y29uc3Qgej11IT09MyYmdGhpcy50eXBlPT09MyxXPXU9PT0zJiZ0aGlzLnR5cGUhPT0zO2ZvcihsZXQgWj0wLFY9dy5sZW5ndGg7WjxWO1orKyl7Y29uc3QgUT13W1pdLEg9US5zaGFkb3c7aWYoSD09PXZvaWQgMCl7Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFNoYWRvd01hcDoiLFEsImhhcyBubyBzaGFkb3cuIik7Y29udGludWV9aWYoSC5hdXRvVXBkYXRlPT09ITEmJkgubmVlZHNVcGRhdGU9PT0hMSljb250aW51ZTtyLmNvcHkoSC5tYXBTaXplKTtjb25zdCBpZT1ILmdldEZyYW1lRXh0ZW50cygpO2lmKHIubXVsdGlwbHkoaWUpLHMuY29weShILm1hcFNpemUpLChyLng+aHx8ci55PmgpJiYoci54PmgmJihzLng9TWF0aC5mbG9vcihoL2llLngpLHIueD1zLngqaWUueCxILm1hcFNpemUueD1zLngpLHIueT5oJiYocy55PU1hdGguZmxvb3IoaC9pZS55KSxyLnk9cy55KmllLnksSC5tYXBTaXplLnk9cy55KSksSC5tYXA9PT1udWxsfHx6PT09ITB8fFc9PT0hMCl7Y29uc3QgeGU9dGhpcy50eXBlIT09Mz97bWluRmlsdGVyOjEwMDMsbWFnRmlsdGVyOjEwMDN9Ont9O0gubWFwIT09bnVsbCYmSC5tYXAuZGlzcG9zZSgpLEgubWFwPW5ldyBKdChyLngsci55LHhlKSxILm1hcC50ZXh0dXJlLm5hbWU9US5uYW1lKyIuc2hhZG93TWFwIixILmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9aS5zZXRSZW5kZXJUYXJnZXQoSC5tYXApLGkuY2xlYXIoKTtjb25zdCBjZT1ILmdldFZpZXdwb3J0Q291bnQoKTtmb3IobGV0IHhlPTA7eGU8Y2U7eGUrKyl7Y29uc3QgVWU9SC5nZXRWaWV3cG9ydCh4ZSk7YS5zZXQocy54KlVlLngscy55KlVlLnkscy54KlVlLnoscy55KlVlLncpLHEudmlld3BvcnQoYSksSC51cGRhdGVNYXRyaWNlcyhRLHhlKSxuPUguZ2V0RnJ1c3R1bSgpLGcoYixGLEguY2FtZXJhLFEsdGhpcy50eXBlKX1ILmlzUG9pbnRMaWdodFNoYWRvdyE9PSEwJiZ0aGlzLnR5cGU9PT0zJiZUKEgsRiksSC5uZWVkc1VwZGF0ZT0hMX11PXRoaXMudHlwZSxtLm5lZWRzVXBkYXRlPSExLGkuc2V0UmVuZGVyVGFyZ2V0KEUsUyxSKX07ZnVuY3Rpb24gVCh3LGIpe2NvbnN0IEY9ZS51cGRhdGUoeCk7Zi5kZWZpbmVzLlZTTV9TQU1QTEVTIT09dy5ibHVyU2FtcGxlcyYmKGYuZGVmaW5lcy5WU01fU0FNUExFUz13LmJsdXJTYW1wbGVzLHAuZGVmaW5lcy5WU01fU0FNUExFUz13LmJsdXJTYW1wbGVzLGYubmVlZHNVcGRhdGU9ITAscC5uZWVkc1VwZGF0ZT0hMCksdy5tYXBQYXNzPT09bnVsbCYmKHcubWFwUGFzcz1uZXcgSnQoci54LHIueSkpLGYudW5pZm9ybXMuc2hhZG93X3Bhc3MudmFsdWU9dy5tYXAudGV4dHVyZSxmLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWU9dy5tYXBTaXplLGYudW5pZm9ybXMucmFkaXVzLnZhbHVlPXcucmFkaXVzLGkuc2V0UmVuZGVyVGFyZ2V0KHcubWFwUGFzcyksaS5jbGVhcigpLGkucmVuZGVyQnVmZmVyRGlyZWN0KGIsbnVsbCxGLGYseCxudWxsKSxwLnVuaWZvcm1zLnNoYWRvd19wYXNzLnZhbHVlPXcubWFwUGFzcy50ZXh0dXJlLHAudW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZT13Lm1hcFNpemUscC51bmlmb3Jtcy5yYWRpdXMudmFsdWU9dy5yYWRpdXMsaS5zZXRSZW5kZXJUYXJnZXQody5tYXApLGkuY2xlYXIoKSxpLnJlbmRlckJ1ZmZlckRpcmVjdChiLG51bGwsRixwLHgsbnVsbCl9ZnVuY3Rpb24geSh3LGIsRixFKXtsZXQgUz1udWxsO2NvbnN0IFI9Ri5pc1BvaW50TGlnaHQ9PT0hMD93LmN1c3RvbURpc3RhbmNlTWF0ZXJpYWw6dy5jdXN0b21EZXB0aE1hdGVyaWFsO2lmKFIhPT12b2lkIDApUz1SO2Vsc2UgaWYoUz1GLmlzUG9pbnRMaWdodD09PSEwP2w6byxpLmxvY2FsQ2xpcHBpbmdFbmFibGVkJiZiLmNsaXBTaGFkb3dzPT09ITAmJkFycmF5LmlzQXJyYXkoYi5jbGlwcGluZ1BsYW5lcykmJmIuY2xpcHBpbmdQbGFuZXMubGVuZ3RoIT09MHx8Yi5kaXNwbGFjZW1lbnRNYXAmJmIuZGlzcGxhY2VtZW50U2NhbGUhPT0wfHxiLmFscGhhTWFwJiZiLmFscGhhVGVzdD4wfHxiLm1hcCYmYi5hbHBoYVRlc3Q+MCl7Y29uc3QgcT1TLnV1aWQsej1iLnV1aWQ7bGV0IFc9Y1txXTtXPT09dm9pZCAwJiYoVz17fSxjW3FdPVcpO2xldCBaPVdbel07Wj09PXZvaWQgMCYmKFo9Uy5jbG9uZSgpLFdbel09WixiLmFkZEV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLFApKSxTPVp9aWYoUy52aXNpYmxlPWIudmlzaWJsZSxTLndpcmVmcmFtZT1iLndpcmVmcmFtZSxFPT09Mz9TLnNpZGU9Yi5zaGFkb3dTaWRlIT09bnVsbD9iLnNoYWRvd1NpZGU6Yi5zaWRlOlMuc2lkZT1iLnNoYWRvd1NpZGUhPT1udWxsP2Iuc2hhZG93U2lkZTpkW2Iuc2lkZV0sUy5hbHBoYU1hcD1iLmFscGhhTWFwLFMuYWxwaGFUZXN0PWIuYWxwaGFUZXN0LFMubWFwPWIubWFwLFMuY2xpcFNoYWRvd3M9Yi5jbGlwU2hhZG93cyxTLmNsaXBwaW5nUGxhbmVzPWIuY2xpcHBpbmdQbGFuZXMsUy5jbGlwSW50ZXJzZWN0aW9uPWIuY2xpcEludGVyc2VjdGlvbixTLmRpc3BsYWNlbWVudE1hcD1iLmRpc3BsYWNlbWVudE1hcCxTLmRpc3BsYWNlbWVudFNjYWxlPWIuZGlzcGxhY2VtZW50U2NhbGUsUy5kaXNwbGFjZW1lbnRCaWFzPWIuZGlzcGxhY2VtZW50QmlhcyxTLndpcmVmcmFtZUxpbmV3aWR0aD1iLndpcmVmcmFtZUxpbmV3aWR0aCxTLmxpbmV3aWR0aD1iLmxpbmV3aWR0aCxGLmlzUG9pbnRMaWdodD09PSEwJiZTLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWw9PT0hMCl7Y29uc3QgcT1pLnByb3BlcnRpZXMuZ2V0KFMpO3EubGlnaHQ9Rn1yZXR1cm4gU31mdW5jdGlvbiBnKHcsYixGLEUsUyl7aWYody52aXNpYmxlPT09ITEpcmV0dXJuO2lmKHcubGF5ZXJzLnRlc3QoYi5sYXllcnMpJiYody5pc01lc2h8fHcuaXNMaW5lfHx3LmlzUG9pbnRzKSYmKHcuY2FzdFNoYWRvd3x8dy5yZWNlaXZlU2hhZG93JiZTPT09MykmJighdy5mcnVzdHVtQ3VsbGVkfHxuLmludGVyc2VjdHNPYmplY3QodykpKXt3Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKEYubWF0cml4V29ybGRJbnZlcnNlLHcubWF0cml4V29ybGQpO2NvbnN0IHo9ZS51cGRhdGUodyksVz13Lm1hdGVyaWFsO2lmKEFycmF5LmlzQXJyYXkoVykpe2NvbnN0IFo9ei5ncm91cHM7Zm9yKGxldCBWPTAsUT1aLmxlbmd0aDtWPFE7VisrKXtjb25zdCBIPVpbVl0saWU9V1tILm1hdGVyaWFsSW5kZXhdO2lmKGllJiZpZS52aXNpYmxlKXtjb25zdCBjZT15KHcsaWUsRSxTKTt3Lm9uQmVmb3JlU2hhZG93KGksdyxiLEYseixjZSxIKSxpLnJlbmRlckJ1ZmZlckRpcmVjdChGLG51bGwseixjZSx3LEgpLHcub25BZnRlclNoYWRvdyhpLHcsYixGLHosY2UsSCl9fX1lbHNlIGlmKFcudmlzaWJsZSl7Y29uc3QgWj15KHcsVyxFLFMpO3cub25CZWZvcmVTaGFkb3coaSx3LGIsRix6LFosbnVsbCksaS5yZW5kZXJCdWZmZXJEaXJlY3QoRixudWxsLHosWix3LG51bGwpLHcub25BZnRlclNoYWRvdyhpLHcsYixGLHosWixudWxsKX19Y29uc3QgcT13LmNoaWxkcmVuO2ZvcihsZXQgej0wLFc9cS5sZW5ndGg7ejxXO3orKylnKHFbel0sYixGLEUsUyl9ZnVuY3Rpb24gUCh3KXt3LnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCJkaXNwb3NlIixQKTtmb3IoY29uc3QgRiBpbiBjKXtjb25zdCBFPWNbRl0sUz13LnRhcmdldC51dWlkO1MgaW4gRSYmKEVbU10uZGlzcG9zZSgpLGRlbGV0ZSBFW1NdKX19fWNvbnN0IEN1PXswOjEsMjo2LDQ6NywzOjUsMTowLDY6Miw3OjQsNTozfTtmdW5jdGlvbiBQdShpLGUpe2Z1bmN0aW9uIHQoKXtsZXQgQz0hMTtjb25zdCBuZT1uZXcgcnQ7bGV0IEc9bnVsbDtjb25zdCAkPW5ldyBydCgwLDAsMCwwKTtyZXR1cm57c2V0TWFzazpmdW5jdGlvbihsZSl7RyE9PWxlJiYhQyYmKGkuY29sb3JNYXNrKGxlLGxlLGxlLGxlKSxHPWxlKX0sc2V0TG9ja2VkOmZ1bmN0aW9uKGxlKXtDPWxlfSxzZXRDbGVhcjpmdW5jdGlvbihsZSxhZSxSZSxpdCxtdCl7bXQ9PT0hMCYmKGxlKj1pdCxhZSo9aXQsUmUqPWl0KSxuZS5zZXQobGUsYWUsUmUsaXQpLCQuZXF1YWxzKG5lKT09PSExJiYoaS5jbGVhckNvbG9yKGxlLGFlLFJlLGl0KSwkLmNvcHkobmUpKX0scmVzZXQ6ZnVuY3Rpb24oKXtDPSExLEc9bnVsbCwkLnNldCgtMSwwLDAsMCl9fX1mdW5jdGlvbiBuKCl7bGV0IEM9ITEsbmU9ITEsRz1udWxsLCQ9bnVsbCxsZT1udWxsO3JldHVybntzZXRSZXZlcnNlZDpmdW5jdGlvbihhZSl7aWYobmUhPT1hZSl7Y29uc3QgUmU9ZS5nZXQoIkVYVF9jbGlwX2NvbnRyb2wiKTtuZT9SZS5jbGlwQ29udHJvbEVYVChSZS5MT1dFUl9MRUZUX0VYVCxSZS5aRVJPX1RPX09ORV9FWFQpOlJlLmNsaXBDb250cm9sRVhUKFJlLkxPV0VSX0xFRlRfRVhULFJlLk5FR0FUSVZFX09ORV9UT19PTkVfRVhUKTtjb25zdCBpdD1sZTtsZT1udWxsLHRoaXMuc2V0Q2xlYXIoaXQpfW5lPWFlfSxnZXRSZXZlcnNlZDpmdW5jdGlvbigpe3JldHVybiBuZX0sc2V0VGVzdDpmdW5jdGlvbihhZSl7YWU/cmUoaS5ERVBUSF9URVNUKTp5ZShpLkRFUFRIX1RFU1QpfSxzZXRNYXNrOmZ1bmN0aW9uKGFlKXtHIT09YWUmJiFDJiYoaS5kZXB0aE1hc2soYWUpLEc9YWUpfSxzZXRGdW5jOmZ1bmN0aW9uKGFlKXtpZihuZSYmKGFlPUN1W2FlXSksJCE9PWFlKXtzd2l0Y2goYWUpe2Nhc2UgMDppLmRlcHRoRnVuYyhpLk5FVkVSKTticmVhaztjYXNlIDE6aS5kZXB0aEZ1bmMoaS5BTFdBWVMpO2JyZWFrO2Nhc2UgMjppLmRlcHRoRnVuYyhpLkxFU1MpO2JyZWFrO2Nhc2UgMzppLmRlcHRoRnVuYyhpLkxFUVVBTCk7YnJlYWs7Y2FzZSA0OmkuZGVwdGhGdW5jKGkuRVFVQUwpO2JyZWFrO2Nhc2UgNTppLmRlcHRoRnVuYyhpLkdFUVVBTCk7YnJlYWs7Y2FzZSA2OmkuZGVwdGhGdW5jKGkuR1JFQVRFUik7YnJlYWs7Y2FzZSA3OmkuZGVwdGhGdW5jKGkuTk9URVFVQUwpO2JyZWFrO2RlZmF1bHQ6aS5kZXB0aEZ1bmMoaS5MRVFVQUwpfSQ9YWV9fSxzZXRMb2NrZWQ6ZnVuY3Rpb24oYWUpe0M9YWV9LHNldENsZWFyOmZ1bmN0aW9uKGFlKXtsZSE9PWFlJiYobmUmJihhZT0xLWFlKSxpLmNsZWFyRGVwdGgoYWUpLGxlPWFlKX0scmVzZXQ6ZnVuY3Rpb24oKXtDPSExLEc9bnVsbCwkPW51bGwsbGU9bnVsbCxuZT0hMX19fWZ1bmN0aW9uIHIoKXtsZXQgQz0hMSxuZT1udWxsLEc9bnVsbCwkPW51bGwsbGU9bnVsbCxhZT1udWxsLFJlPW51bGwsaXQ9bnVsbCxtdD1udWxsO3JldHVybntzZXRUZXN0OmZ1bmN0aW9uKFhlKXtDfHwoWGU/cmUoaS5TVEVOQ0lMX1RFU1QpOnllKGkuU1RFTkNJTF9URVNUKSl9LHNldE1hc2s6ZnVuY3Rpb24oWGUpe25lIT09WGUmJiFDJiYoaS5zdGVuY2lsTWFzayhYZSksbmU9WGUpfSxzZXRGdW5jOmZ1bmN0aW9uKFhlLE90LEt0KXsoRyE9PVhlfHwkIT09T3R8fGxlIT09S3QpJiYoaS5zdGVuY2lsRnVuYyhYZSxPdCxLdCksRz1YZSwkPU90LGxlPUt0KX0sc2V0T3A6ZnVuY3Rpb24oWGUsT3QsS3QpeyhhZSE9PVhlfHxSZSE9PU90fHxpdCE9PUt0KSYmKGkuc3RlbmNpbE9wKFhlLE90LEt0KSxhZT1YZSxSZT1PdCxpdD1LdCl9LHNldExvY2tlZDpmdW5jdGlvbihYZSl7Qz1YZX0sc2V0Q2xlYXI6ZnVuY3Rpb24oWGUpe210IT09WGUmJihpLmNsZWFyU3RlbmNpbChYZSksbXQ9WGUpfSxyZXNldDpmdW5jdGlvbigpe0M9ITEsbmU9bnVsbCxHPW51bGwsJD1udWxsLGxlPW51bGwsYWU9bnVsbCxSZT1udWxsLGl0PW51bGwsbXQ9bnVsbH19fWNvbnN0IHM9bmV3IHQsYT1uZXcgbixvPW5ldyByLGw9bmV3IFdlYWtNYXAsYz1uZXcgV2Vha01hcDtsZXQgaD17fSxkPXt9LGY9bmV3IFdlYWtNYXAscD1bXSxfPW51bGwseD0hMSxtPW51bGwsdT1udWxsLFQ9bnVsbCx5PW51bGwsZz1udWxsLFA9bnVsbCx3PW51bGwsYj1uZXcgVmUoMCwwLDApLEY9MCxFPSExLFM9bnVsbCxSPW51bGwscT1udWxsLHo9bnVsbCxXPW51bGw7Y29uc3QgWj1pLmdldFBhcmFtZXRlcihpLk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTKTtsZXQgVj0hMSxRPTA7Y29uc3QgSD1pLmdldFBhcmFtZXRlcihpLlZFUlNJT04pO0guaW5kZXhPZigiV2ViR0wiKSE9PS0xPyhRPXBhcnNlRmxvYXQoL15XZWJHTCAoXGQpLy5leGVjKEgpWzFdKSxWPVE+PTEpOkguaW5kZXhPZigiT3BlbkdMIEVTIikhPT0tMSYmKFE9cGFyc2VGbG9hdCgvXk9wZW5HTCBFUyAoXGQpLy5leGVjKEgpWzFdKSxWPVE+PTIpO2xldCBpZT1udWxsLGNlPXt9O2NvbnN0IHhlPWkuZ2V0UGFyYW1ldGVyKGkuU0NJU1NPUl9CT1gpLFVlPWkuZ2V0UGFyYW1ldGVyKGkuVklFV1BPUlQpLFllPW5ldyBydCgpLmZyb21BcnJheSh4ZSksWD1uZXcgcnQoKS5mcm9tQXJyYXkoVWUpO2Z1bmN0aW9uIGVlKEMsbmUsRywkKXtjb25zdCBsZT1uZXcgVWludDhBcnJheSg0KSxhZT1pLmNyZWF0ZVRleHR1cmUoKTtpLmJpbmRUZXh0dXJlKEMsYWUpLGkudGV4UGFyYW1ldGVyaShDLGkuVEVYVFVSRV9NSU5fRklMVEVSLGkuTkVBUkVTVCksaS50ZXhQYXJhbWV0ZXJpKEMsaS5URVhUVVJFX01BR19GSUxURVIsaS5ORUFSRVNUKTtmb3IobGV0IFJlPTA7UmU8RztSZSsrKUM9PT1pLlRFWFRVUkVfM0R8fEM9PT1pLlRFWFRVUkVfMkRfQVJSQVk/aS50ZXhJbWFnZTNEKG5lLDAsaS5SR0JBLDEsMSwkLDAsaS5SR0JBLGkuVU5TSUdORURfQllURSxsZSk6aS50ZXhJbWFnZTJEKG5lK1JlLDAsaS5SR0JBLDEsMSwwLGkuUkdCQSxpLlVOU0lHTkVEX0JZVEUsbGUpO3JldHVybiBhZX1jb25zdCBnZT17fTtnZVtpLlRFWFRVUkVfMkRdPWVlKGkuVEVYVFVSRV8yRCxpLlRFWFRVUkVfMkQsMSksZ2VbaS5URVhUVVJFX0NVQkVfTUFQXT1lZShpLlRFWFRVUkVfQ1VCRV9NQVAsaS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsNiksZ2VbaS5URVhUVVJFXzJEX0FSUkFZXT1lZShpLlRFWFRVUkVfMkRfQVJSQVksaS5URVhUVVJFXzJEX0FSUkFZLDEsMSksZ2VbaS5URVhUVVJFXzNEXT1lZShpLlRFWFRVUkVfM0QsaS5URVhUVVJFXzNELDEsMSkscy5zZXRDbGVhcigwLDAsMCwxKSxhLnNldENsZWFyKDEpLG8uc2V0Q2xlYXIoMCkscmUoaS5ERVBUSF9URVNUKSxhLnNldEZ1bmMoMyksSWUoITEpLE5lKDEpLHJlKGkuQ1VMTF9GQUNFKSxVKDApO2Z1bmN0aW9uIHJlKEMpe2hbQ10hPT0hMCYmKGkuZW5hYmxlKEMpLGhbQ109ITApfWZ1bmN0aW9uIHllKEMpe2hbQ10hPT0hMSYmKGkuZGlzYWJsZShDKSxoW0NdPSExKX1mdW5jdGlvbiB3ZShDLG5lKXtyZXR1cm4gZFtDXSE9PW5lPyhpLmJpbmRGcmFtZWJ1ZmZlcihDLG5lKSxkW0NdPW5lLEM9PT1pLkRSQVdfRlJBTUVCVUZGRVImJihkW2kuRlJBTUVCVUZGRVJdPW5lKSxDPT09aS5GUkFNRUJVRkZFUiYmKGRbaS5EUkFXX0ZSQU1FQlVGRkVSXT1uZSksITApOiExfWZ1bmN0aW9uIEZlKEMsbmUpe2xldCBHPXAsJD0hMTtpZihDKXtHPWYuZ2V0KG5lKSxHPT09dm9pZCAwJiYoRz1bXSxmLnNldChuZSxHKSk7Y29uc3QgbGU9Qy50ZXh0dXJlcztpZihHLmxlbmd0aCE9PWxlLmxlbmd0aHx8R1swXSE9PWkuQ09MT1JfQVRUQUNITUVOVDApe2ZvcihsZXQgYWU9MCxSZT1sZS5sZW5ndGg7YWU8UmU7YWUrKylHW2FlXT1pLkNPTE9SX0FUVEFDSE1FTlQwK2FlO0cubGVuZ3RoPWxlLmxlbmd0aCwkPSEwfX1lbHNlIEdbMF0hPT1pLkJBQ0smJihHWzBdPWkuQkFDSywkPSEwKTskJiZpLmRyYXdCdWZmZXJzKEcpfWZ1bmN0aW9uIG50KEMpe3JldHVybiBfIT09Qz8oaS51c2VQcm9ncmFtKEMpLF89QywhMCk6ITF9Y29uc3QgemU9ezEwMDppLkZVTkNfQURELDEwMTppLkZVTkNfU1VCVFJBQ1QsMTAyOmkuRlVOQ19SRVZFUlNFX1NVQlRSQUNUfTt6ZVsxMDNdPWkuTUlOLHplWzEwNF09aS5NQVg7Y29uc3QgYXQ9ezIwMDppLlpFUk8sMjAxOmkuT05FLDIwMjppLlNSQ19DT0xPUiwyMDQ6aS5TUkNfQUxQSEEsMjEwOmkuU1JDX0FMUEhBX1NBVFVSQVRFLDIwODppLkRTVF9DT0xPUiwyMDY6aS5EU1RfQUxQSEEsMjAzOmkuT05FX01JTlVTX1NSQ19DT0xPUiwyMDU6aS5PTkVfTUlOVVNfU1JDX0FMUEhBLDIwOTppLk9ORV9NSU5VU19EU1RfQ09MT1IsMjA3OmkuT05FX01JTlVTX0RTVF9BTFBIQSwyMTE6aS5DT05TVEFOVF9DT0xPUiwyMTI6aS5PTkVfTUlOVVNfQ09OU1RBTlRfQ09MT1IsMjEzOmkuQ09OU1RBTlRfQUxQSEEsMjE0OmkuT05FX01JTlVTX0NPTlNUQU5UX0FMUEhBfTtmdW5jdGlvbiBVKEMsbmUsRywkLGxlLGFlLFJlLGl0LG10LFhlKXtpZihDPT09MCl7eD09PSEwJiYoeWUoaS5CTEVORCkseD0hMSk7cmV0dXJufWlmKHg9PT0hMSYmKHJlKGkuQkxFTkQpLHg9ITApLEMhPT01KXtpZihDIT09bXx8WGUhPT1FKXtpZigodSE9PTEwMHx8ZyE9PTEwMCkmJihpLmJsZW5kRXF1YXRpb24oaS5GVU5DX0FERCksdT0xMDAsZz0xMDApLFhlKXN3aXRjaChDKXtjYXNlIDE6aS5ibGVuZEZ1bmNTZXBhcmF0ZShpLk9ORSxpLk9ORV9NSU5VU19TUkNfQUxQSEEsaS5PTkUsaS5PTkVfTUlOVVNfU1JDX0FMUEhBKTticmVhaztjYXNlIDI6aS5ibGVuZEZ1bmMoaS5PTkUsaS5PTkUpO2JyZWFrO2Nhc2UgMzppLmJsZW5kRnVuY1NlcGFyYXRlKGkuWkVSTyxpLk9ORV9NSU5VU19TUkNfQ09MT1IsaS5aRVJPLGkuT05FKTticmVhaztjYXNlIDQ6aS5ibGVuZEZ1bmNTZXBhcmF0ZShpLlpFUk8saS5TUkNfQ09MT1IsaS5aRVJPLGkuU1JDX0FMUEhBKTticmVhaztkZWZhdWx0OmNvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMU3RhdGU6IEludmFsaWQgYmxlbmRpbmc6ICIsQyk7YnJlYWt9ZWxzZSBzd2l0Y2goQyl7Y2FzZSAxOmkuYmxlbmRGdW5jU2VwYXJhdGUoaS5TUkNfQUxQSEEsaS5PTkVfTUlOVVNfU1JDX0FMUEhBLGkuT05FLGkuT05FX01JTlVTX1NSQ19BTFBIQSk7YnJlYWs7Y2FzZSAyOmkuYmxlbmRGdW5jKGkuU1JDX0FMUEhBLGkuT05FKTticmVhaztjYXNlIDM6aS5ibGVuZEZ1bmNTZXBhcmF0ZShpLlpFUk8saS5PTkVfTUlOVVNfU1JDX0NPTE9SLGkuWkVSTyxpLk9ORSk7YnJlYWs7Y2FzZSA0OmkuYmxlbmRGdW5jKGkuWkVSTyxpLlNSQ19DT0xPUik7YnJlYWs7ZGVmYXVsdDpjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFN0YXRlOiBJbnZhbGlkIGJsZW5kaW5nOiAiLEMpO2JyZWFrfVQ9bnVsbCx5PW51bGwsUD1udWxsLHc9bnVsbCxiLnNldCgwLDAsMCksRj0wLG09QyxFPVhlfXJldHVybn1sZT1sZXx8bmUsYWU9YWV8fEcsUmU9UmV8fCQsKG5lIT09dXx8bGUhPT1nKSYmKGkuYmxlbmRFcXVhdGlvblNlcGFyYXRlKHplW25lXSx6ZVtsZV0pLHU9bmUsZz1sZSksKEchPT1UfHwkIT09eXx8YWUhPT1QfHxSZSE9PXcpJiYoaS5ibGVuZEZ1bmNTZXBhcmF0ZShhdFtHXSxhdFskXSxhdFthZV0sYXRbUmVdKSxUPUcseT0kLFA9YWUsdz1SZSksKGl0LmVxdWFscyhiKT09PSExfHxtdCE9PUYpJiYoaS5ibGVuZENvbG9yKGl0LnIsaXQuZyxpdC5iLG10KSxiLmNvcHkoaXQpLEY9bXQpLG09QyxFPSExfWZ1bmN0aW9uIFB0KEMsbmUpe0Muc2lkZT09PTI/eWUoaS5DVUxMX0ZBQ0UpOnJlKGkuQ1VMTF9GQUNFKTtsZXQgRz1DLnNpZGU9PT0xO25lJiYoRz0hRyksSWUoRyksQy5ibGVuZGluZz09PTEmJkMudHJhbnNwYXJlbnQ9PT0hMT9VKDApOlUoQy5ibGVuZGluZyxDLmJsZW5kRXF1YXRpb24sQy5ibGVuZFNyYyxDLmJsZW5kRHN0LEMuYmxlbmRFcXVhdGlvbkFscGhhLEMuYmxlbmRTcmNBbHBoYSxDLmJsZW5kRHN0QWxwaGEsQy5ibGVuZENvbG9yLEMuYmxlbmRBbHBoYSxDLnByZW11bHRpcGxpZWRBbHBoYSksYS5zZXRGdW5jKEMuZGVwdGhGdW5jKSxhLnNldFRlc3QoQy5kZXB0aFRlc3QpLGEuc2V0TWFzayhDLmRlcHRoV3JpdGUpLHMuc2V0TWFzayhDLmNvbG9yV3JpdGUpO2NvbnN0ICQ9Qy5zdGVuY2lsV3JpdGU7by5zZXRUZXN0KCQpLCQmJihvLnNldE1hc2soQy5zdGVuY2lsV3JpdGVNYXNrKSxvLnNldEZ1bmMoQy5zdGVuY2lsRnVuYyxDLnN0ZW5jaWxSZWYsQy5zdGVuY2lsRnVuY01hc2spLG8uc2V0T3AoQy5zdGVuY2lsRmFpbCxDLnN0ZW5jaWxaRmFpbCxDLnN0ZW5jaWxaUGFzcykpLGplKEMucG9seWdvbk9mZnNldCxDLnBvbHlnb25PZmZzZXRGYWN0b3IsQy5wb2x5Z29uT2Zmc2V0VW5pdHMpLEMuYWxwaGFUb0NvdmVyYWdlPT09ITA/cmUoaS5TQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UpOnllKGkuU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFKX1mdW5jdGlvbiBJZShDKXtTIT09QyYmKEM/aS5mcm9udEZhY2UoaS5DVyk6aS5mcm9udEZhY2UoaS5DQ1cpLFM9Qyl9ZnVuY3Rpb24gTmUoQyl7QyE9PTA/KHJlKGkuQ1VMTF9GQUNFKSxDIT09UiYmKEM9PT0xP2kuY3VsbEZhY2UoaS5CQUNLKTpDPT09Mj9pLmN1bGxGYWNlKGkuRlJPTlQpOmkuY3VsbEZhY2UoaS5GUk9OVF9BTkRfQkFDSykpKTp5ZShpLkNVTExfRkFDRSksUj1DfWZ1bmN0aW9uIFNlKEMpe0MhPT1xJiYoViYmaS5saW5lV2lkdGgoQykscT1DKX1mdW5jdGlvbiBqZShDLG5lLEcpe0M/KHJlKGkuUE9MWUdPTl9PRkZTRVRfRklMTCksKHohPT1uZXx8VyE9PUcpJiYoaS5wb2x5Z29uT2Zmc2V0KG5lLEcpLHo9bmUsVz1HKSk6eWUoaS5QT0xZR09OX09GRlNFVF9GSUxMKX1mdW5jdGlvbiBNZShDKXtDP3JlKGkuU0NJU1NPUl9URVNUKTp5ZShpLlNDSVNTT1JfVEVTVCl9ZnVuY3Rpb24gQShDKXtDPT09dm9pZCAwJiYoQz1pLlRFWFRVUkUwK1otMSksaWUhPT1DJiYoaS5hY3RpdmVUZXh0dXJlKEMpLGllPUMpfWZ1bmN0aW9uIHYoQyxuZSxHKXtHPT09dm9pZCAwJiYoaWU9PT1udWxsP0c9aS5URVhUVVJFMCtaLTE6Rz1pZSk7bGV0ICQ9Y2VbR107JD09PXZvaWQgMCYmKCQ9e3R5cGU6dm9pZCAwLHRleHR1cmU6dm9pZCAwfSxjZVtHXT0kKSwoJC50eXBlIT09Q3x8JC50ZXh0dXJlIT09bmUpJiYoaWUhPT1HJiYoaS5hY3RpdmVUZXh0dXJlKEcpLGllPUcpLGkuYmluZFRleHR1cmUoQyxuZXx8Z2VbQ10pLCQudHlwZT1DLCQudGV4dHVyZT1uZSl9ZnVuY3Rpb24gSSgpe2NvbnN0IEM9Y2VbaWVdO0MhPT12b2lkIDAmJkMudHlwZSE9PXZvaWQgMCYmKGkuYmluZFRleHR1cmUoQy50eXBlLG51bGwpLEMudHlwZT12b2lkIDAsQy50ZXh0dXJlPXZvaWQgMCl9ZnVuY3Rpb24gWSgpe3RyeXtpLmNvbXByZXNzZWRUZXhJbWFnZTJELmFwcGx5KGksYXJndW1lbnRzKX1jYXRjaChDKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFN0YXRlOiIsQyl9fWZ1bmN0aW9uIEsoKXt0cnl7aS5jb21wcmVzc2VkVGV4SW1hZ2UzRC5hcHBseShpLGFyZ3VtZW50cyl9Y2F0Y2goQyl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZToiLEMpfX1mdW5jdGlvbiBrKCl7dHJ5e2kudGV4U3ViSW1hZ2UyRC5hcHBseShpLGFyZ3VtZW50cyl9Y2F0Y2goQyl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZToiLEMpfX1mdW5jdGlvbiBfZSgpe3RyeXtpLnRleFN1YkltYWdlM0QuYXBwbHkoaSxhcmd1bWVudHMpfWNhdGNoKEMpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMU3RhdGU6IixDKX19ZnVuY3Rpb24gc2UoKXt0cnl7aS5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRC5hcHBseShpLGFyZ3VtZW50cyl9Y2F0Y2goQyl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZToiLEMpfX1mdW5jdGlvbiB1ZSgpe3RyeXtpLmNvbXByZXNzZWRUZXhTdWJJbWFnZTNELmFwcGx5KGksYXJndW1lbnRzKX1jYXRjaChDKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFN0YXRlOiIsQyl9fWZ1bmN0aW9uIEdlKCl7dHJ5e2kudGV4U3RvcmFnZTJELmFwcGx5KGksYXJndW1lbnRzKX1jYXRjaChDKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFN0YXRlOiIsQyl9fWZ1bmN0aW9uIGooKXt0cnl7aS50ZXhTdG9yYWdlM0QuYXBwbHkoaSxhcmd1bWVudHMpfWNhdGNoKEMpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMU3RhdGU6IixDKX19ZnVuY3Rpb24gaGUoKXt0cnl7aS50ZXhJbWFnZTJELmFwcGx5KGksYXJndW1lbnRzKX1jYXRjaChDKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFN0YXRlOiIsQyl9fWZ1bmN0aW9uIEVlKCl7dHJ5e2kudGV4SW1hZ2UzRC5hcHBseShpLGFyZ3VtZW50cyl9Y2F0Y2goQyl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZToiLEMpfX1mdW5jdGlvbiBUZShDKXtZZS5lcXVhbHMoQyk9PT0hMSYmKGkuc2Npc3NvcihDLngsQy55LEMueixDLncpLFllLmNvcHkoQykpfWZ1bmN0aW9uIGRlKEMpe1guZXF1YWxzKEMpPT09ITEmJihpLnZpZXdwb3J0KEMueCxDLnksQy56LEMudyksWC5jb3B5KEMpKX1mdW5jdGlvbiBPZShDLG5lKXtsZXQgRz1jLmdldChuZSk7Rz09PXZvaWQgMCYmKEc9bmV3IFdlYWtNYXAsYy5zZXQobmUsRykpO2xldCAkPUcuZ2V0KEMpOyQ9PT12b2lkIDAmJigkPWkuZ2V0VW5pZm9ybUJsb2NrSW5kZXgobmUsQy5uYW1lKSxHLnNldChDLCQpKX1mdW5jdGlvbiBMZShDLG5lKXtjb25zdCAkPWMuZ2V0KG5lKS5nZXQoQyk7bC5nZXQobmUpIT09JCYmKGkudW5pZm9ybUJsb2NrQmluZGluZyhuZSwkLEMuX19iaW5kaW5nUG9pbnRJbmRleCksbC5zZXQobmUsJCkpfWZ1bmN0aW9uIEtlKCl7aS5kaXNhYmxlKGkuQkxFTkQpLGkuZGlzYWJsZShpLkNVTExfRkFDRSksaS5kaXNhYmxlKGkuREVQVEhfVEVTVCksaS5kaXNhYmxlKGkuUE9MWUdPTl9PRkZTRVRfRklMTCksaS5kaXNhYmxlKGkuU0NJU1NPUl9URVNUKSxpLmRpc2FibGUoaS5TVEVOQ0lMX1RFU1QpLGkuZGlzYWJsZShpLlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSksaS5ibGVuZEVxdWF0aW9uKGkuRlVOQ19BREQpLGkuYmxlbmRGdW5jKGkuT05FLGkuWkVSTyksaS5ibGVuZEZ1bmNTZXBhcmF0ZShpLk9ORSxpLlpFUk8saS5PTkUsaS5aRVJPKSxpLmJsZW5kQ29sb3IoMCwwLDAsMCksaS5jb2xvck1hc2soITAsITAsITAsITApLGkuY2xlYXJDb2xvcigwLDAsMCwwKSxpLmRlcHRoTWFzayghMCksaS5kZXB0aEZ1bmMoaS5MRVNTKSxhLnNldFJldmVyc2VkKCExKSxpLmNsZWFyRGVwdGgoMSksaS5zdGVuY2lsTWFzayg0Mjk0OTY3Mjk1KSxpLnN0ZW5jaWxGdW5jKGkuQUxXQVlTLDAsNDI5NDk2NzI5NSksaS5zdGVuY2lsT3AoaS5LRUVQLGkuS0VFUCxpLktFRVApLGkuY2xlYXJTdGVuY2lsKDApLGkuY3VsbEZhY2UoaS5CQUNLKSxpLmZyb250RmFjZShpLkNDVyksaS5wb2x5Z29uT2Zmc2V0KDAsMCksaS5hY3RpdmVUZXh0dXJlKGkuVEVYVFVSRTApLGkuYmluZEZyYW1lYnVmZmVyKGkuRlJBTUVCVUZGRVIsbnVsbCksaS5iaW5kRnJhbWVidWZmZXIoaS5EUkFXX0ZSQU1FQlVGRkVSLG51bGwpLGkuYmluZEZyYW1lYnVmZmVyKGkuUkVBRF9GUkFNRUJVRkZFUixudWxsKSxpLnVzZVByb2dyYW0obnVsbCksaS5saW5lV2lkdGgoMSksaS5zY2lzc29yKDAsMCxpLmNhbnZhcy53aWR0aCxpLmNhbnZhcy5oZWlnaHQpLGkudmlld3BvcnQoMCwwLGkuY2FudmFzLndpZHRoLGkuY2FudmFzLmhlaWdodCksaD17fSxpZT1udWxsLGNlPXt9LGQ9e30sZj1uZXcgV2Vha01hcCxwPVtdLF89bnVsbCx4PSExLG09bnVsbCx1PW51bGwsVD1udWxsLHk9bnVsbCxnPW51bGwsUD1udWxsLHc9bnVsbCxiPW5ldyBWZSgwLDAsMCksRj0wLEU9ITEsUz1udWxsLFI9bnVsbCxxPW51bGwsej1udWxsLFc9bnVsbCxZZS5zZXQoMCwwLGkuY2FudmFzLndpZHRoLGkuY2FudmFzLmhlaWdodCksWC5zZXQoMCwwLGkuY2FudmFzLndpZHRoLGkuY2FudmFzLmhlaWdodCkscy5yZXNldCgpLGEucmVzZXQoKSxvLnJlc2V0KCl9cmV0dXJue2J1ZmZlcnM6e2NvbG9yOnMsZGVwdGg6YSxzdGVuY2lsOm99LGVuYWJsZTpyZSxkaXNhYmxlOnllLGJpbmRGcmFtZWJ1ZmZlcjp3ZSxkcmF3QnVmZmVyczpGZSx1c2VQcm9ncmFtOm50LHNldEJsZW5kaW5nOlUsc2V0TWF0ZXJpYWw6UHQsc2V0RmxpcFNpZGVkOkllLHNldEN1bGxGYWNlOk5lLHNldExpbmVXaWR0aDpTZSxzZXRQb2x5Z29uT2Zmc2V0OmplLHNldFNjaXNzb3JUZXN0Ok1lLGFjdGl2ZVRleHR1cmU6QSxiaW5kVGV4dHVyZTp2LHVuYmluZFRleHR1cmU6SSxjb21wcmVzc2VkVGV4SW1hZ2UyRDpZLGNvbXByZXNzZWRUZXhJbWFnZTNEOkssdGV4SW1hZ2UyRDpoZSx0ZXhJbWFnZTNEOkVlLHVwZGF0ZVVCT01hcHBpbmc6T2UsdW5pZm9ybUJsb2NrQmluZGluZzpMZSx0ZXhTdG9yYWdlMkQ6R2UsdGV4U3RvcmFnZTNEOmosdGV4U3ViSW1hZ2UyRDprLHRleFN1YkltYWdlM0Q6X2UsY29tcHJlc3NlZFRleFN1YkltYWdlMkQ6c2UsY29tcHJlc3NlZFRleFN1YkltYWdlM0Q6dWUsc2Npc3NvcjpUZSx2aWV3cG9ydDpkZSxyZXNldDpLZX19ZnVuY3Rpb24gQ3MoaSxlLHQsbil7Y29uc3Qgcj1EdShuKTtzd2l0Y2godCl7Y2FzZSAxMDIxOnJldHVybiBpKmU7Y2FzZSAxMDI0OnJldHVybiBpKmU7Y2FzZSAxMDI1OnJldHVybiBpKmUqMjtjYXNlIDEwMjg6cmV0dXJuIGkqZS9yLmNvbXBvbmVudHMqci5ieXRlTGVuZ3RoO2Nhc2UgMTAyOTpyZXR1cm4gaSplL3IuY29tcG9uZW50cypyLmJ5dGVMZW5ndGg7Y2FzZSAxMDMwOnJldHVybiBpKmUqMi9yLmNvbXBvbmVudHMqci5ieXRlTGVuZ3RoO2Nhc2UgMTAzMTpyZXR1cm4gaSplKjIvci5jb21wb25lbnRzKnIuYnl0ZUxlbmd0aDtjYXNlIDEwMjI6cmV0dXJuIGkqZSozL3IuY29tcG9uZW50cypyLmJ5dGVMZW5ndGg7Y2FzZSAxMDIzOnJldHVybiBpKmUqNC9yLmNvbXBvbmVudHMqci5ieXRlTGVuZ3RoO2Nhc2UgMTAzMzpyZXR1cm4gaSplKjQvci5jb21wb25lbnRzKnIuYnl0ZUxlbmd0aDtjYXNlIDMzNzc2OmNhc2UgMzM3Nzc6cmV0dXJuIE1hdGguZmxvb3IoKGkrMykvNCkqTWF0aC5mbG9vcigoZSszKS80KSo4O2Nhc2UgMzM3Nzg6Y2FzZSAzMzc3OTpyZXR1cm4gTWF0aC5mbG9vcigoaSszKS80KSpNYXRoLmZsb29yKChlKzMpLzQpKjE2O2Nhc2UgMzU4NDE6Y2FzZSAzNTg0MzpyZXR1cm4gTWF0aC5tYXgoaSwxNikqTWF0aC5tYXgoZSw4KS80O2Nhc2UgMzU4NDA6Y2FzZSAzNTg0MjpyZXR1cm4gTWF0aC5tYXgoaSw4KSpNYXRoLm1heChlLDgpLzI7Y2FzZSAzNjE5NjpjYXNlIDM3NDkyOnJldHVybiBNYXRoLmZsb29yKChpKzMpLzQpKk1hdGguZmxvb3IoKGUrMykvNCkqODtjYXNlIDM3NDk2OnJldHVybiBNYXRoLmZsb29yKChpKzMpLzQpKk1hdGguZmxvb3IoKGUrMykvNCkqMTY7Y2FzZSAzNzgwODpyZXR1cm4gTWF0aC5mbG9vcigoaSszKS80KSpNYXRoLmZsb29yKChlKzMpLzQpKjE2O2Nhc2UgMzc4MDk6cmV0dXJuIE1hdGguZmxvb3IoKGkrNCkvNSkqTWF0aC5mbG9vcigoZSszKS80KSoxNjtjYXNlIDM3ODEwOnJldHVybiBNYXRoLmZsb29yKChpKzQpLzUpKk1hdGguZmxvb3IoKGUrNCkvNSkqMTY7Y2FzZSAzNzgxMTpyZXR1cm4gTWF0aC5mbG9vcigoaSs1KS82KSpNYXRoLmZsb29yKChlKzQpLzUpKjE2O2Nhc2UgMzc4MTI6cmV0dXJuIE1hdGguZmxvb3IoKGkrNSkvNikqTWF0aC5mbG9vcigoZSs1KS82KSoxNjtjYXNlIDM3ODEzOnJldHVybiBNYXRoLmZsb29yKChpKzcpLzgpKk1hdGguZmxvb3IoKGUrNCkvNSkqMTY7Y2FzZSAzNzgxNDpyZXR1cm4gTWF0aC5mbG9vcigoaSs3KS84KSpNYXRoLmZsb29yKChlKzUpLzYpKjE2O2Nhc2UgMzc4MTU6cmV0dXJuIE1hdGguZmxvb3IoKGkrNykvOCkqTWF0aC5mbG9vcigoZSs3KS84KSoxNjtjYXNlIDM3ODE2OnJldHVybiBNYXRoLmZsb29yKChpKzkpLzEwKSpNYXRoLmZsb29yKChlKzQpLzUpKjE2O2Nhc2UgMzc4MTc6cmV0dXJuIE1hdGguZmxvb3IoKGkrOSkvMTApKk1hdGguZmxvb3IoKGUrNSkvNikqMTY7Y2FzZSAzNzgxODpyZXR1cm4gTWF0aC5mbG9vcigoaSs5KS8xMCkqTWF0aC5mbG9vcigoZSs3KS84KSoxNjtjYXNlIDM3ODE5OnJldHVybiBNYXRoLmZsb29yKChpKzkpLzEwKSpNYXRoLmZsb29yKChlKzkpLzEwKSoxNjtjYXNlIDM3ODIwOnJldHVybiBNYXRoLmZsb29yKChpKzExKS8xMikqTWF0aC5mbG9vcigoZSs5KS8xMCkqMTY7Y2FzZSAzNzgyMTpyZXR1cm4gTWF0aC5mbG9vcigoaSsxMSkvMTIpKk1hdGguZmxvb3IoKGUrMTEpLzEyKSoxNjtjYXNlIDM2NDkyOmNhc2UgMzY0OTQ6Y2FzZSAzNjQ5NTpyZXR1cm4gTWF0aC5jZWlsKGkvNCkqTWF0aC5jZWlsKGUvNCkqMTY7Y2FzZSAzNjI4MzpjYXNlIDM2Mjg0OnJldHVybiBNYXRoLmNlaWwoaS80KSpNYXRoLmNlaWwoZS80KSo4O2Nhc2UgMzYyODU6Y2FzZSAzNjI4NjpyZXR1cm4gTWF0aC5jZWlsKGkvNCkqTWF0aC5jZWlsKGUvNCkqMTZ9dGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZGV0ZXJtaW5lIHRleHR1cmUgYnl0ZSBsZW5ndGggZm9yICR7dH0gZm9ybWF0LmApfWZ1bmN0aW9uIER1KGkpe3N3aXRjaChpKXtjYXNlIDEwMDk6Y2FzZSAxMDEwOnJldHVybntieXRlTGVuZ3RoOjEsY29tcG9uZW50czoxfTtjYXNlIDEwMTI6Y2FzZSAxMDExOmNhc2UgMTAxNjpyZXR1cm57Ynl0ZUxlbmd0aDoyLGNvbXBvbmVudHM6MX07Y2FzZSAxMDE3OmNhc2UgMTAxODpyZXR1cm57Ynl0ZUxlbmd0aDoyLGNvbXBvbmVudHM6NH07Y2FzZSAxMDE0OmNhc2UgMTAxMzpjYXNlIDEwMTU6cmV0dXJue2J5dGVMZW5ndGg6NCxjb21wb25lbnRzOjF9O2Nhc2UgMzU5MDI6cmV0dXJue2J5dGVMZW5ndGg6NCxjb21wb25lbnRzOjN9fXRocm93IG5ldyBFcnJvcihgVW5rbm93biB0ZXh0dXJlIHR5cGUgJHtpfS5gKX1mdW5jdGlvbiBMdShpLGUsdCxuLHIscyxhKXtjb25zdCBvPWUuaGFzKCJXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUiKT9lLmdldCgiV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlIik6bnVsbCxsPXR5cGVvZiBuYXZpZ2F0b3I+InUiPyExOi9PY3VsdXNCcm93c2VyL2cudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxjPW5ldyBQZSxoPW5ldyBXZWFrTWFwO2xldCBkO2NvbnN0IGY9bmV3IFdlYWtNYXA7bGV0IHA9ITE7dHJ5e3A9dHlwZW9mIE9mZnNjcmVlbkNhbnZhczwidSImJm5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKS5nZXRDb250ZXh0KCIyZCIpIT09bnVsbH1jYXRjaHt9ZnVuY3Rpb24gXyhBLHYpe3JldHVybiBwP25ldyBPZmZzY3JlZW5DYW52YXMoQSx2KTpyaSgiY2FudmFzIil9ZnVuY3Rpb24geChBLHYsSSl7bGV0IFk9MTtjb25zdCBLPU1lKEEpO2lmKChLLndpZHRoPkl8fEsuaGVpZ2h0PkkpJiYoWT1JL01hdGgubWF4KEsud2lkdGgsSy5oZWlnaHQpKSxZPDEpaWYodHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQ8InUiJiZBIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudHx8dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50PCJ1IiYmQSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50fHx0eXBlb2YgSW1hZ2VCaXRtYXA8InUiJiZBIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXB8fHR5cGVvZiBWaWRlb0ZyYW1lPCJ1IiYmQSBpbnN0YW5jZW9mIFZpZGVvRnJhbWUpe2NvbnN0IGs9TWF0aC5mbG9vcihZKksud2lkdGgpLF9lPU1hdGguZmxvb3IoWSpLLmhlaWdodCk7ZD09PXZvaWQgMCYmKGQ9XyhrLF9lKSk7Y29uc3Qgc2U9dj9fKGssX2UpOmQ7cmV0dXJuIHNlLndpZHRoPWssc2UuaGVpZ2h0PV9lLHNlLmdldENvbnRleHQoIjJkIikuZHJhd0ltYWdlKEEsMCwwLGssX2UpLGNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBoYXMgYmVlbiByZXNpemVkIGZyb20gKCIrSy53aWR0aCsieCIrSy5oZWlnaHQrIikgdG8gKCIraysieCIrX2UrIikuIiksc2V9ZWxzZSByZXR1cm4iZGF0YSJpbiBBJiZjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IEltYWdlIGluIERhdGFUZXh0dXJlIGlzIHRvbyBiaWcgKCIrSy53aWR0aCsieCIrSy5oZWlnaHQrIikuIiksQTtyZXR1cm4gQX1mdW5jdGlvbiBtKEEpe3JldHVybiBBLmdlbmVyYXRlTWlwbWFwc31mdW5jdGlvbiB1KEEpe2kuZ2VuZXJhdGVNaXBtYXAoQSl9ZnVuY3Rpb24gVChBKXtyZXR1cm4gQS5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldD9pLlRFWFRVUkVfQ1VCRV9NQVA6QS5pc1dlYkdMM0RSZW5kZXJUYXJnZXQ/aS5URVhUVVJFXzNEOkEuaXNXZWJHTEFycmF5UmVuZGVyVGFyZ2V0fHxBLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZT9pLlRFWFRVUkVfMkRfQVJSQVk6aS5URVhUVVJFXzJEfWZ1bmN0aW9uIHkoQSx2LEksWSxLPSExKXtpZihBIT09bnVsbCl7aWYoaVtBXSE9PXZvaWQgMClyZXR1cm4gaVtBXTtjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gdXNlIG5vbi1leGlzdGluZyBXZWJHTCBpbnRlcm5hbCBmb3JtYXQgJyIrQSsiJyIpfWxldCBrPXY7aWYodj09PWkuUkVEJiYoST09PWkuRkxPQVQmJihrPWkuUjMyRiksST09PWkuSEFMRl9GTE9BVCYmKGs9aS5SMTZGKSxJPT09aS5VTlNJR05FRF9CWVRFJiYoaz1pLlI4KSksdj09PWkuUkVEX0lOVEVHRVImJihJPT09aS5VTlNJR05FRF9CWVRFJiYoaz1pLlI4VUkpLEk9PT1pLlVOU0lHTkVEX1NIT1JUJiYoaz1pLlIxNlVJKSxJPT09aS5VTlNJR05FRF9JTlQmJihrPWkuUjMyVUkpLEk9PT1pLkJZVEUmJihrPWkuUjhJKSxJPT09aS5TSE9SVCYmKGs9aS5SMTZJKSxJPT09aS5JTlQmJihrPWkuUjMySSkpLHY9PT1pLlJHJiYoST09PWkuRkxPQVQmJihrPWkuUkczMkYpLEk9PT1pLkhBTEZfRkxPQVQmJihrPWkuUkcxNkYpLEk9PT1pLlVOU0lHTkVEX0JZVEUmJihrPWkuUkc4KSksdj09PWkuUkdfSU5URUdFUiYmKEk9PT1pLlVOU0lHTkVEX0JZVEUmJihrPWkuUkc4VUkpLEk9PT1pLlVOU0lHTkVEX1NIT1JUJiYoaz1pLlJHMTZVSSksST09PWkuVU5TSUdORURfSU5UJiYoaz1pLlJHMzJVSSksST09PWkuQllURSYmKGs9aS5SRzhJKSxJPT09aS5TSE9SVCYmKGs9aS5SRzE2SSksST09PWkuSU5UJiYoaz1pLlJHMzJJKSksdj09PWkuUkdCX0lOVEVHRVImJihJPT09aS5VTlNJR05FRF9CWVRFJiYoaz1pLlJHQjhVSSksST09PWkuVU5TSUdORURfU0hPUlQmJihrPWkuUkdCMTZVSSksST09PWkuVU5TSUdORURfSU5UJiYoaz1pLlJHQjMyVUkpLEk9PT1pLkJZVEUmJihrPWkuUkdCOEkpLEk9PT1pLlNIT1JUJiYoaz1pLlJHQjE2SSksST09PWkuSU5UJiYoaz1pLlJHQjMySSkpLHY9PT1pLlJHQkFfSU5URUdFUiYmKEk9PT1pLlVOU0lHTkVEX0JZVEUmJihrPWkuUkdCQThVSSksST09PWkuVU5TSUdORURfU0hPUlQmJihrPWkuUkdCQTE2VUkpLEk9PT1pLlVOU0lHTkVEX0lOVCYmKGs9aS5SR0JBMzJVSSksST09PWkuQllURSYmKGs9aS5SR0JBOEkpLEk9PT1pLlNIT1JUJiYoaz1pLlJHQkExNkkpLEk9PT1pLklOVCYmKGs9aS5SR0JBMzJJKSksdj09PWkuUkdCJiZJPT09aS5VTlNJR05FRF9JTlRfNV85XzlfOV9SRVYmJihrPWkuUkdCOV9FNSksdj09PWkuUkdCQSl7Y29uc3QgX2U9Sz9paTpCZS5nZXRUcmFuc2ZlcihZKTtJPT09aS5GTE9BVCYmKGs9aS5SR0JBMzJGKSxJPT09aS5IQUxGX0ZMT0FUJiYoaz1pLlJHQkExNkYpLEk9PT1pLlVOU0lHTkVEX0JZVEUmJihrPV9lPT09cWU/aS5TUkdCOF9BTFBIQTg6aS5SR0JBOCksST09PWkuVU5TSUdORURfU0hPUlRfNF80XzRfNCYmKGs9aS5SR0JBNCksST09PWkuVU5TSUdORURfU0hPUlRfNV81XzVfMSYmKGs9aS5SR0I1X0ExKX1yZXR1cm4oaz09PWkuUjE2Rnx8az09PWkuUjMyRnx8az09PWkuUkcxNkZ8fGs9PT1pLlJHMzJGfHxrPT09aS5SR0JBMTZGfHxrPT09aS5SR0JBMzJGKSYmZS5nZXQoIkVYVF9jb2xvcl9idWZmZXJfZmxvYXQiKSxrfWZ1bmN0aW9uIGcoQSx2KXtsZXQgSTtyZXR1cm4gQT92PT09bnVsbHx8dj09PTEwMTR8fHY9PT0xMDIwP0k9aS5ERVBUSDI0X1NURU5DSUw4OnY9PT0xMDE1P0k9aS5ERVBUSDMyRl9TVEVOQ0lMODp2PT09MTAxMiYmKEk9aS5ERVBUSDI0X1NURU5DSUw4LGNvbnNvbGUud2FybigiRGVwdGhUZXh0dXJlOiAxNiBiaXQgZGVwdGggYXR0YWNobWVudCBpcyBub3Qgc3VwcG9ydGVkIHdpdGggc3RlbmNpbC4gVXNpbmcgMjQtYml0IGF0dGFjaG1lbnQuIikpOnY9PT1udWxsfHx2PT09MTAxNHx8dj09PTEwMjA/ST1pLkRFUFRIX0NPTVBPTkVOVDI0OnY9PT0xMDE1P0k9aS5ERVBUSF9DT01QT05FTlQzMkY6dj09PTEwMTImJihJPWkuREVQVEhfQ09NUE9ORU5UMTYpLEl9ZnVuY3Rpb24gUChBLHYpe3JldHVybiBtKEEpPT09ITB8fEEuaXNGcmFtZWJ1ZmZlclRleHR1cmUmJkEubWluRmlsdGVyIT09MTAwMyYmQS5taW5GaWx0ZXIhPT0xMDA2P01hdGgubG9nMihNYXRoLm1heCh2LndpZHRoLHYuaGVpZ2h0KSkrMTpBLm1pcG1hcHMhPT12b2lkIDAmJkEubWlwbWFwcy5sZW5ndGg+MD9BLm1pcG1hcHMubGVuZ3RoOkEuaXNDb21wcmVzc2VkVGV4dHVyZSYmQXJyYXkuaXNBcnJheShBLmltYWdlKT92Lm1pcG1hcHMubGVuZ3RoOjF9ZnVuY3Rpb24gdyhBKXtjb25zdCB2PUEudGFyZ2V0O3YucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsdyksRih2KSx2LmlzVmlkZW9UZXh0dXJlJiZoLmRlbGV0ZSh2KX1mdW5jdGlvbiBiKEEpe2NvbnN0IHY9QS50YXJnZXQ7di5yZW1vdmVFdmVudExpc3RlbmVyKCJkaXNwb3NlIixiKSxTKHYpfWZ1bmN0aW9uIEYoQSl7Y29uc3Qgdj1uLmdldChBKTtpZih2Ll9fd2ViZ2xJbml0PT09dm9pZCAwKXJldHVybjtjb25zdCBJPUEuc291cmNlLFk9Zi5nZXQoSSk7aWYoWSl7Y29uc3QgSz1ZW3YuX19jYWNoZUtleV07Sy51c2VkVGltZXMtLSxLLnVzZWRUaW1lcz09PTAmJkUoQSksT2JqZWN0LmtleXMoWSkubGVuZ3RoPT09MCYmZi5kZWxldGUoSSl9bi5yZW1vdmUoQSl9ZnVuY3Rpb24gRShBKXtjb25zdCB2PW4uZ2V0KEEpO2kuZGVsZXRlVGV4dHVyZSh2Ll9fd2ViZ2xUZXh0dXJlKTtjb25zdCBJPUEuc291cmNlLFk9Zi5nZXQoSSk7ZGVsZXRlIFlbdi5fX2NhY2hlS2V5XSxhLm1lbW9yeS50ZXh0dXJlcy0tfWZ1bmN0aW9uIFMoQSl7Y29uc3Qgdj1uLmdldChBKTtpZihBLmRlcHRoVGV4dHVyZSYmKEEuZGVwdGhUZXh0dXJlLmRpc3Bvc2UoKSxuLnJlbW92ZShBLmRlcHRoVGV4dHVyZSkpLEEuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQpZm9yKGxldCBZPTA7WTw2O1krKyl7aWYoQXJyYXkuaXNBcnJheSh2Ll9fd2ViZ2xGcmFtZWJ1ZmZlcltZXSkpZm9yKGxldCBLPTA7Szx2Ll9fd2ViZ2xGcmFtZWJ1ZmZlcltZXS5sZW5ndGg7SysrKWkuZGVsZXRlRnJhbWVidWZmZXIodi5fX3dlYmdsRnJhbWVidWZmZXJbWV1bS10pO2Vsc2UgaS5kZWxldGVGcmFtZWJ1ZmZlcih2Ll9fd2ViZ2xGcmFtZWJ1ZmZlcltZXSk7di5fX3dlYmdsRGVwdGhidWZmZXImJmkuZGVsZXRlUmVuZGVyYnVmZmVyKHYuX193ZWJnbERlcHRoYnVmZmVyW1ldKX1lbHNle2lmKEFycmF5LmlzQXJyYXkodi5fX3dlYmdsRnJhbWVidWZmZXIpKWZvcihsZXQgWT0wO1k8di5fX3dlYmdsRnJhbWVidWZmZXIubGVuZ3RoO1krKylpLmRlbGV0ZUZyYW1lYnVmZmVyKHYuX193ZWJnbEZyYW1lYnVmZmVyW1ldKTtlbHNlIGkuZGVsZXRlRnJhbWVidWZmZXIodi5fX3dlYmdsRnJhbWVidWZmZXIpO2lmKHYuX193ZWJnbERlcHRoYnVmZmVyJiZpLmRlbGV0ZVJlbmRlcmJ1ZmZlcih2Ll9fd2ViZ2xEZXB0aGJ1ZmZlciksdi5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXImJmkuZGVsZXRlRnJhbWVidWZmZXIodi5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpLHYuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyKWZvcihsZXQgWT0wO1k8di5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXIubGVuZ3RoO1krKyl2Ll9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcltZXSYmaS5kZWxldGVSZW5kZXJidWZmZXIodi5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbWV0pO3YuX193ZWJnbERlcHRoUmVuZGVyYnVmZmVyJiZpLmRlbGV0ZVJlbmRlcmJ1ZmZlcih2Ll9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlcil9Y29uc3QgST1BLnRleHR1cmVzO2ZvcihsZXQgWT0wLEs9SS5sZW5ndGg7WTxLO1krKyl7Y29uc3Qgaz1uLmdldChJW1ldKTtrLl9fd2ViZ2xUZXh0dXJlJiYoaS5kZWxldGVUZXh0dXJlKGsuX193ZWJnbFRleHR1cmUpLGEubWVtb3J5LnRleHR1cmVzLS0pLG4ucmVtb3ZlKElbWV0pfW4ucmVtb3ZlKEEpfWxldCBSPTA7ZnVuY3Rpb24gcSgpe1I9MH1mdW5jdGlvbiB6KCl7Y29uc3QgQT1SO3JldHVybiBBPj1yLm1heFRleHR1cmVzJiZjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMVGV4dHVyZXM6IFRyeWluZyB0byB1c2UgIitBKyIgdGV4dHVyZSB1bml0cyB3aGlsZSB0aGlzIEdQVSBzdXBwb3J0cyBvbmx5ICIrci5tYXhUZXh0dXJlcyksUis9MSxBfWZ1bmN0aW9uIFcoQSl7Y29uc3Qgdj1bXTtyZXR1cm4gdi5wdXNoKEEud3JhcFMpLHYucHVzaChBLndyYXBUKSx2LnB1c2goQS53cmFwUnx8MCksdi5wdXNoKEEubWFnRmlsdGVyKSx2LnB1c2goQS5taW5GaWx0ZXIpLHYucHVzaChBLmFuaXNvdHJvcHkpLHYucHVzaChBLmludGVybmFsRm9ybWF0KSx2LnB1c2goQS5mb3JtYXQpLHYucHVzaChBLnR5cGUpLHYucHVzaChBLmdlbmVyYXRlTWlwbWFwcyksdi5wdXNoKEEucHJlbXVsdGlwbHlBbHBoYSksdi5wdXNoKEEuZmxpcFkpLHYucHVzaChBLnVucGFja0FsaWdubWVudCksdi5wdXNoKEEuY29sb3JTcGFjZSksdi5qb2luKCl9ZnVuY3Rpb24gWihBLHYpe2NvbnN0IEk9bi5nZXQoQSk7aWYoQS5pc1ZpZGVvVGV4dHVyZSYmU2UoQSksQS5pc1JlbmRlclRhcmdldFRleHR1cmU9PT0hMSYmQS52ZXJzaW9uPjAmJkkuX192ZXJzaW9uIT09QS52ZXJzaW9uKXtjb25zdCBZPUEuaW1hZ2U7aWYoWT09PW51bGwpY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBubyBpbWFnZSBkYXRhIGZvdW5kLiIpO2Vsc2UgaWYoWS5jb21wbGV0ZT09PSExKWNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgaW5jb21wbGV0ZSIpO2Vsc2V7WChJLEEsdik7cmV0dXJufX10LmJpbmRUZXh0dXJlKGkuVEVYVFVSRV8yRCxJLl9fd2ViZ2xUZXh0dXJlLGkuVEVYVFVSRTArdil9ZnVuY3Rpb24gVihBLHYpe2NvbnN0IEk9bi5nZXQoQSk7aWYoQS52ZXJzaW9uPjAmJkkuX192ZXJzaW9uIT09QS52ZXJzaW9uKXtYKEksQSx2KTtyZXR1cm59dC5iaW5kVGV4dHVyZShpLlRFWFRVUkVfMkRfQVJSQVksSS5fX3dlYmdsVGV4dHVyZSxpLlRFWFRVUkUwK3YpfWZ1bmN0aW9uIFEoQSx2KXtjb25zdCBJPW4uZ2V0KEEpO2lmKEEudmVyc2lvbj4wJiZJLl9fdmVyc2lvbiE9PUEudmVyc2lvbil7WChJLEEsdik7cmV0dXJufXQuYmluZFRleHR1cmUoaS5URVhUVVJFXzNELEkuX193ZWJnbFRleHR1cmUsaS5URVhUVVJFMCt2KX1mdW5jdGlvbiBIKEEsdil7Y29uc3QgST1uLmdldChBKTtpZihBLnZlcnNpb24+MCYmSS5fX3ZlcnNpb24hPT1BLnZlcnNpb24pe2VlKEksQSx2KTtyZXR1cm59dC5iaW5kVGV4dHVyZShpLlRFWFRVUkVfQ1VCRV9NQVAsSS5fX3dlYmdsVGV4dHVyZSxpLlRFWFRVUkUwK3YpfWNvbnN0IGllPXsxZTM6aS5SRVBFQVQsMTAwMTppLkNMQU1QX1RPX0VER0UsMTAwMjppLk1JUlJPUkVEX1JFUEVBVH0sY2U9ezEwMDM6aS5ORUFSRVNULDEwMDQ6aS5ORUFSRVNUX01JUE1BUF9ORUFSRVNULDEwMDU6aS5ORUFSRVNUX01JUE1BUF9MSU5FQVIsMTAwNjppLkxJTkVBUiwxMDA3OmkuTElORUFSX01JUE1BUF9ORUFSRVNULDEwMDg6aS5MSU5FQVJfTUlQTUFQX0xJTkVBUn0seGU9ezUxMjppLk5FVkVSLDUxOTppLkFMV0FZUyw1MTM6aS5MRVNTLDUxNTppLkxFUVVBTCw1MTQ6aS5FUVVBTCw1MTg6aS5HRVFVQUwsNTE2OmkuR1JFQVRFUiw1MTc6aS5OT1RFUVVBTH07ZnVuY3Rpb24gVWUoQSx2KXtpZih2LnR5cGU9PT0xMDE1JiZlLmhhcygiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyIik9PT0hMSYmKHYubWFnRmlsdGVyPT09MTAwNnx8di5tYWdGaWx0ZXI9PT0xMDA3fHx2Lm1hZ0ZpbHRlcj09PTEwMDV8fHYubWFnRmlsdGVyPT09MTAwOHx8di5taW5GaWx0ZXI9PT0xMDA2fHx2Lm1pbkZpbHRlcj09PTEwMDd8fHYubWluRmlsdGVyPT09MTAwNXx8di5taW5GaWx0ZXI9PT0xMDA4KSYmY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBVbmFibGUgdG8gdXNlIGxpbmVhciBmaWx0ZXJpbmcgd2l0aCBmbG9hdGluZyBwb2ludCB0ZXh0dXJlcy4gT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2UuIiksaS50ZXhQYXJhbWV0ZXJpKEEsaS5URVhUVVJFX1dSQVBfUyxpZVt2LndyYXBTXSksaS50ZXhQYXJhbWV0ZXJpKEEsaS5URVhUVVJFX1dSQVBfVCxpZVt2LndyYXBUXSksKEE9PT1pLlRFWFRVUkVfM0R8fEE9PT1pLlRFWFRVUkVfMkRfQVJSQVkpJiZpLnRleFBhcmFtZXRlcmkoQSxpLlRFWFRVUkVfV1JBUF9SLGllW3Yud3JhcFJdKSxpLnRleFBhcmFtZXRlcmkoQSxpLlRFWFRVUkVfTUFHX0ZJTFRFUixjZVt2Lm1hZ0ZpbHRlcl0pLGkudGV4UGFyYW1ldGVyaShBLGkuVEVYVFVSRV9NSU5fRklMVEVSLGNlW3YubWluRmlsdGVyXSksdi5jb21wYXJlRnVuY3Rpb24mJihpLnRleFBhcmFtZXRlcmkoQSxpLlRFWFRVUkVfQ09NUEFSRV9NT0RFLGkuQ09NUEFSRV9SRUZfVE9fVEVYVFVSRSksaS50ZXhQYXJhbWV0ZXJpKEEsaS5URVhUVVJFX0NPTVBBUkVfRlVOQyx4ZVt2LmNvbXBhcmVGdW5jdGlvbl0pKSxlLmhhcygiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljIik9PT0hMCl7aWYodi5tYWdGaWx0ZXI9PT0xMDAzfHx2Lm1pbkZpbHRlciE9PTEwMDUmJnYubWluRmlsdGVyIT09MTAwOHx8di50eXBlPT09MTAxNSYmZS5oYXMoIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhciIpPT09ITEpcmV0dXJuO2lmKHYuYW5pc290cm9weT4xfHxuLmdldCh2KS5fX2N1cnJlbnRBbmlzb3Ryb3B5KXtjb25zdCBJPWUuZ2V0KCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMiKTtpLnRleFBhcmFtZXRlcmYoQSxJLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULE1hdGgubWluKHYuYW5pc290cm9weSxyLmdldE1heEFuaXNvdHJvcHkoKSkpLG4uZ2V0KHYpLl9fY3VycmVudEFuaXNvdHJvcHk9di5hbmlzb3Ryb3B5fX19ZnVuY3Rpb24gWWUoQSx2KXtsZXQgST0hMTtBLl9fd2ViZ2xJbml0PT09dm9pZCAwJiYoQS5fX3dlYmdsSW5pdD0hMCx2LmFkZEV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLHcpKTtjb25zdCBZPXYuc291cmNlO2xldCBLPWYuZ2V0KFkpO0s9PT12b2lkIDAmJihLPXt9LGYuc2V0KFksSykpO2NvbnN0IGs9Vyh2KTtpZihrIT09QS5fX2NhY2hlS2V5KXtLW2tdPT09dm9pZCAwJiYoS1trXT17dGV4dHVyZTppLmNyZWF0ZVRleHR1cmUoKSx1c2VkVGltZXM6MH0sYS5tZW1vcnkudGV4dHVyZXMrKyxJPSEwKSxLW2tdLnVzZWRUaW1lcysrO2NvbnN0IF9lPUtbQS5fX2NhY2hlS2V5XTtfZSE9PXZvaWQgMCYmKEtbQS5fX2NhY2hlS2V5XS51c2VkVGltZXMtLSxfZS51c2VkVGltZXM9PT0wJiZFKHYpKSxBLl9fY2FjaGVLZXk9ayxBLl9fd2ViZ2xUZXh0dXJlPUtba10udGV4dHVyZX1yZXR1cm4gSX1mdW5jdGlvbiBYKEEsdixJKXtsZXQgWT1pLlRFWFRVUkVfMkQ7KHYuaXNEYXRhQXJyYXlUZXh0dXJlfHx2LmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSkmJihZPWkuVEVYVFVSRV8yRF9BUlJBWSksdi5pc0RhdGEzRFRleHR1cmUmJihZPWkuVEVYVFVSRV8zRCk7Y29uc3QgSz1ZZShBLHYpLGs9di5zb3VyY2U7dC5iaW5kVGV4dHVyZShZLEEuX193ZWJnbFRleHR1cmUsaS5URVhUVVJFMCtJKTtjb25zdCBfZT1uLmdldChrKTtpZihrLnZlcnNpb24hPT1fZS5fX3ZlcnNpb258fEs9PT0hMCl7dC5hY3RpdmVUZXh0dXJlKGkuVEVYVFVSRTArSSk7Y29uc3Qgc2U9QmUuZ2V0UHJpbWFyaWVzKEJlLndvcmtpbmdDb2xvclNwYWNlKSx1ZT12LmNvbG9yU3BhY2U9PT1qdD9udWxsOkJlLmdldFByaW1hcmllcyh2LmNvbG9yU3BhY2UpLEdlPXYuY29sb3JTcGFjZT09PWp0fHxzZT09PXVlP2kuTk9ORTppLkJST1dTRVJfREVGQVVMVF9XRUJHTDtpLnBpeGVsU3RvcmVpKGkuVU5QQUNLX0ZMSVBfWV9XRUJHTCx2LmZsaXBZKSxpLnBpeGVsU3RvcmVpKGkuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLHYucHJlbXVsdGlwbHlBbHBoYSksaS5waXhlbFN0b3JlaShpLlVOUEFDS19BTElHTk1FTlQsdi51bnBhY2tBbGlnbm1lbnQpLGkucGl4ZWxTdG9yZWkoaS5VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLEdlKTtsZXQgaj14KHYuaW1hZ2UsITEsci5tYXhUZXh0dXJlU2l6ZSk7aj1qZSh2LGopO2NvbnN0IGhlPXMuY29udmVydCh2LmZvcm1hdCx2LmNvbG9yU3BhY2UpLEVlPXMuY29udmVydCh2LnR5cGUpO2xldCBUZT15KHYuaW50ZXJuYWxGb3JtYXQsaGUsRWUsdi5jb2xvclNwYWNlLHYuaXNWaWRlb1RleHR1cmUpO1VlKFksdik7bGV0IGRlO2NvbnN0IE9lPXYubWlwbWFwcyxMZT12LmlzVmlkZW9UZXh0dXJlIT09ITAsS2U9X2UuX192ZXJzaW9uPT09dm9pZCAwfHxLPT09ITAsQz1rLmRhdGFSZWFkeSxuZT1QKHYsaik7aWYodi5pc0RlcHRoVGV4dHVyZSlUZT1nKHYuZm9ybWF0PT09MTAyNyx2LnR5cGUpLEtlJiYoTGU/dC50ZXhTdG9yYWdlMkQoaS5URVhUVVJFXzJELDEsVGUsai53aWR0aCxqLmhlaWdodCk6dC50ZXhJbWFnZTJEKGkuVEVYVFVSRV8yRCwwLFRlLGoud2lkdGgsai5oZWlnaHQsMCxoZSxFZSxudWxsKSk7ZWxzZSBpZih2LmlzRGF0YVRleHR1cmUpaWYoT2UubGVuZ3RoPjApe0xlJiZLZSYmdC50ZXhTdG9yYWdlMkQoaS5URVhUVVJFXzJELG5lLFRlLE9lWzBdLndpZHRoLE9lWzBdLmhlaWdodCk7Zm9yKGxldCBHPTAsJD1PZS5sZW5ndGg7RzwkO0crKylkZT1PZVtHXSxMZT9DJiZ0LnRleFN1YkltYWdlMkQoaS5URVhUVVJFXzJELEcsMCwwLGRlLndpZHRoLGRlLmhlaWdodCxoZSxFZSxkZS5kYXRhKTp0LnRleEltYWdlMkQoaS5URVhUVVJFXzJELEcsVGUsZGUud2lkdGgsZGUuaGVpZ2h0LDAsaGUsRWUsZGUuZGF0YSk7di5nZW5lcmF0ZU1pcG1hcHM9ITF9ZWxzZSBMZT8oS2UmJnQudGV4U3RvcmFnZTJEKGkuVEVYVFVSRV8yRCxuZSxUZSxqLndpZHRoLGouaGVpZ2h0KSxDJiZ0LnRleFN1YkltYWdlMkQoaS5URVhUVVJFXzJELDAsMCwwLGoud2lkdGgsai5oZWlnaHQsaGUsRWUsai5kYXRhKSk6dC50ZXhJbWFnZTJEKGkuVEVYVFVSRV8yRCwwLFRlLGoud2lkdGgsai5oZWlnaHQsMCxoZSxFZSxqLmRhdGEpO2Vsc2UgaWYodi5pc0NvbXByZXNzZWRUZXh0dXJlKWlmKHYuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlKXtMZSYmS2UmJnQudGV4U3RvcmFnZTNEKGkuVEVYVFVSRV8yRF9BUlJBWSxuZSxUZSxPZVswXS53aWR0aCxPZVswXS5oZWlnaHQsai5kZXB0aCk7Zm9yKGxldCBHPTAsJD1PZS5sZW5ndGg7RzwkO0crKylpZihkZT1PZVtHXSx2LmZvcm1hdCE9PTEwMjMpaWYoaGUhPT1udWxsKWlmKExlKXtpZihDKWlmKHYubGF5ZXJVcGRhdGVzLnNpemU+MCl7Y29uc3QgbGU9Q3MoZGUud2lkdGgsZGUuaGVpZ2h0LHYuZm9ybWF0LHYudHlwZSk7Zm9yKGNvbnN0IGFlIG9mIHYubGF5ZXJVcGRhdGVzKXtjb25zdCBSZT1kZS5kYXRhLnN1YmFycmF5KGFlKmxlL2RlLmRhdGEuQllURVNfUEVSX0VMRU1FTlQsKGFlKzEpKmxlL2RlLmRhdGEuQllURVNfUEVSX0VMRU1FTlQpO3QuY29tcHJlc3NlZFRleFN1YkltYWdlM0QoaS5URVhUVVJFXzJEX0FSUkFZLEcsMCwwLGFlLGRlLndpZHRoLGRlLmhlaWdodCwxLGhlLFJlKX12LmNsZWFyTGF5ZXJVcGRhdGVzKCl9ZWxzZSB0LmNvbXByZXNzZWRUZXhTdWJJbWFnZTNEKGkuVEVYVFVSRV8yRF9BUlJBWSxHLDAsMCwwLGRlLndpZHRoLGRlLmhlaWdodCxqLmRlcHRoLGhlLGRlLmRhdGEpfWVsc2UgdC5jb21wcmVzc2VkVGV4SW1hZ2UzRChpLlRFWFRVUkVfMkRfQVJSQVksRyxUZSxkZS53aWR0aCxkZS5oZWlnaHQsai5kZXB0aCwwLGRlLmRhdGEsMCwwKTtlbHNlIGNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnVwbG9hZFRleHR1cmUoKSIpO2Vsc2UgTGU/QyYmdC50ZXhTdWJJbWFnZTNEKGkuVEVYVFVSRV8yRF9BUlJBWSxHLDAsMCwwLGRlLndpZHRoLGRlLmhlaWdodCxqLmRlcHRoLGhlLEVlLGRlLmRhdGEpOnQudGV4SW1hZ2UzRChpLlRFWFRVUkVfMkRfQVJSQVksRyxUZSxkZS53aWR0aCxkZS5oZWlnaHQsai5kZXB0aCwwLGhlLEVlLGRlLmRhdGEpfWVsc2V7TGUmJktlJiZ0LnRleFN0b3JhZ2UyRChpLlRFWFRVUkVfMkQsbmUsVGUsT2VbMF0ud2lkdGgsT2VbMF0uaGVpZ2h0KTtmb3IobGV0IEc9MCwkPU9lLmxlbmd0aDtHPCQ7RysrKWRlPU9lW0ddLHYuZm9ybWF0IT09MTAyMz9oZSE9PW51bGw/TGU/QyYmdC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRChpLlRFWFRVUkVfMkQsRywwLDAsZGUud2lkdGgsZGUuaGVpZ2h0LGhlLGRlLmRhdGEpOnQuY29tcHJlc3NlZFRleEltYWdlMkQoaS5URVhUVVJFXzJELEcsVGUsZGUud2lkdGgsZGUuaGVpZ2h0LDAsZGUuZGF0YSk6Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpIik6TGU/QyYmdC50ZXhTdWJJbWFnZTJEKGkuVEVYVFVSRV8yRCxHLDAsMCxkZS53aWR0aCxkZS5oZWlnaHQsaGUsRWUsZGUuZGF0YSk6dC50ZXhJbWFnZTJEKGkuVEVYVFVSRV8yRCxHLFRlLGRlLndpZHRoLGRlLmhlaWdodCwwLGhlLEVlLGRlLmRhdGEpfWVsc2UgaWYodi5pc0RhdGFBcnJheVRleHR1cmUpaWYoTGUpe2lmKEtlJiZ0LnRleFN0b3JhZ2UzRChpLlRFWFRVUkVfMkRfQVJSQVksbmUsVGUsai53aWR0aCxqLmhlaWdodCxqLmRlcHRoKSxDKWlmKHYubGF5ZXJVcGRhdGVzLnNpemU+MCl7Y29uc3QgRz1DcyhqLndpZHRoLGouaGVpZ2h0LHYuZm9ybWF0LHYudHlwZSk7Zm9yKGNvbnN0ICQgb2Ygdi5sYXllclVwZGF0ZXMpe2NvbnN0IGxlPWouZGF0YS5zdWJhcnJheSgkKkcvai5kYXRhLkJZVEVTX1BFUl9FTEVNRU5ULCgkKzEpKkcvai5kYXRhLkJZVEVTX1BFUl9FTEVNRU5UKTt0LnRleFN1YkltYWdlM0QoaS5URVhUVVJFXzJEX0FSUkFZLDAsMCwwLCQsai53aWR0aCxqLmhlaWdodCwxLGhlLEVlLGxlKX12LmNsZWFyTGF5ZXJVcGRhdGVzKCl9ZWxzZSB0LnRleFN1YkltYWdlM0QoaS5URVhUVVJFXzJEX0FSUkFZLDAsMCwwLDAsai53aWR0aCxqLmhlaWdodCxqLmRlcHRoLGhlLEVlLGouZGF0YSl9ZWxzZSB0LnRleEltYWdlM0QoaS5URVhUVVJFXzJEX0FSUkFZLDAsVGUsai53aWR0aCxqLmhlaWdodCxqLmRlcHRoLDAsaGUsRWUsai5kYXRhKTtlbHNlIGlmKHYuaXNEYXRhM0RUZXh0dXJlKUxlPyhLZSYmdC50ZXhTdG9yYWdlM0QoaS5URVhUVVJFXzNELG5lLFRlLGoud2lkdGgsai5oZWlnaHQsai5kZXB0aCksQyYmdC50ZXhTdWJJbWFnZTNEKGkuVEVYVFVSRV8zRCwwLDAsMCwwLGoud2lkdGgsai5oZWlnaHQsai5kZXB0aCxoZSxFZSxqLmRhdGEpKTp0LnRleEltYWdlM0QoaS5URVhUVVJFXzNELDAsVGUsai53aWR0aCxqLmhlaWdodCxqLmRlcHRoLDAsaGUsRWUsai5kYXRhKTtlbHNlIGlmKHYuaXNGcmFtZWJ1ZmZlclRleHR1cmUpe2lmKEtlKWlmKExlKXQudGV4U3RvcmFnZTJEKGkuVEVYVFVSRV8yRCxuZSxUZSxqLndpZHRoLGouaGVpZ2h0KTtlbHNle2xldCBHPWoud2lkdGgsJD1qLmhlaWdodDtmb3IobGV0IGxlPTA7bGU8bmU7bGUrKyl0LnRleEltYWdlMkQoaS5URVhUVVJFXzJELGxlLFRlLEcsJCwwLGhlLEVlLG51bGwpLEc+Pj0xLCQ+Pj0xfX1lbHNlIGlmKE9lLmxlbmd0aD4wKXtpZihMZSYmS2Upe2NvbnN0IEc9TWUoT2VbMF0pO3QudGV4U3RvcmFnZTJEKGkuVEVYVFVSRV8yRCxuZSxUZSxHLndpZHRoLEcuaGVpZ2h0KX1mb3IobGV0IEc9MCwkPU9lLmxlbmd0aDtHPCQ7RysrKWRlPU9lW0ddLExlP0MmJnQudGV4U3ViSW1hZ2UyRChpLlRFWFRVUkVfMkQsRywwLDAsaGUsRWUsZGUpOnQudGV4SW1hZ2UyRChpLlRFWFRVUkVfMkQsRyxUZSxoZSxFZSxkZSk7di5nZW5lcmF0ZU1pcG1hcHM9ITF9ZWxzZSBpZihMZSl7aWYoS2Upe2NvbnN0IEc9TWUoaik7dC50ZXhTdG9yYWdlMkQoaS5URVhUVVJFXzJELG5lLFRlLEcud2lkdGgsRy5oZWlnaHQpfUMmJnQudGV4U3ViSW1hZ2UyRChpLlRFWFRVUkVfMkQsMCwwLDAsaGUsRWUsail9ZWxzZSB0LnRleEltYWdlMkQoaS5URVhUVVJFXzJELDAsVGUsaGUsRWUsaik7bSh2KSYmdShZKSxfZS5fX3ZlcnNpb249ay52ZXJzaW9uLHYub25VcGRhdGUmJnYub25VcGRhdGUodil9QS5fX3ZlcnNpb249di52ZXJzaW9ufWZ1bmN0aW9uIGVlKEEsdixJKXtpZih2LmltYWdlLmxlbmd0aCE9PTYpcmV0dXJuO2NvbnN0IFk9WWUoQSx2KSxLPXYuc291cmNlO3QuYmluZFRleHR1cmUoaS5URVhUVVJFX0NVQkVfTUFQLEEuX193ZWJnbFRleHR1cmUsaS5URVhUVVJFMCtJKTtjb25zdCBrPW4uZ2V0KEspO2lmKEsudmVyc2lvbiE9PWsuX192ZXJzaW9ufHxZPT09ITApe3QuYWN0aXZlVGV4dHVyZShpLlRFWFRVUkUwK0kpO2NvbnN0IF9lPUJlLmdldFByaW1hcmllcyhCZS53b3JraW5nQ29sb3JTcGFjZSksc2U9di5jb2xvclNwYWNlPT09anQ/bnVsbDpCZS5nZXRQcmltYXJpZXModi5jb2xvclNwYWNlKSx1ZT12LmNvbG9yU3BhY2U9PT1qdHx8X2U9PT1zZT9pLk5PTkU6aS5CUk9XU0VSX0RFRkFVTFRfV0VCR0w7aS5waXhlbFN0b3JlaShpLlVOUEFDS19GTElQX1lfV0VCR0wsdi5mbGlwWSksaS5waXhlbFN0b3JlaShpLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCx2LnByZW11bHRpcGx5QWxwaGEpLGkucGl4ZWxTdG9yZWkoaS5VTlBBQ0tfQUxJR05NRU5ULHYudW5wYWNrQWxpZ25tZW50KSxpLnBpeGVsU3RvcmVpKGkuVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCx1ZSk7Y29uc3QgR2U9di5pc0NvbXByZXNzZWRUZXh0dXJlfHx2LmltYWdlWzBdLmlzQ29tcHJlc3NlZFRleHR1cmUsaj12LmltYWdlWzBdJiZ2LmltYWdlWzBdLmlzRGF0YVRleHR1cmUsaGU9W107Zm9yKGxldCAkPTA7JDw2OyQrKykhR2UmJiFqP2hlWyRdPXgodi5pbWFnZVskXSwhMCxyLm1heEN1YmVtYXBTaXplKTpoZVskXT1qP3YuaW1hZ2VbJF0uaW1hZ2U6di5pbWFnZVskXSxoZVskXT1qZSh2LGhlWyRdKTtjb25zdCBFZT1oZVswXSxUZT1zLmNvbnZlcnQodi5mb3JtYXQsdi5jb2xvclNwYWNlKSxkZT1zLmNvbnZlcnQodi50eXBlKSxPZT15KHYuaW50ZXJuYWxGb3JtYXQsVGUsZGUsdi5jb2xvclNwYWNlKSxMZT12LmlzVmlkZW9UZXh0dXJlIT09ITAsS2U9ay5fX3ZlcnNpb249PT12b2lkIDB8fFk9PT0hMCxDPUsuZGF0YVJlYWR5O2xldCBuZT1QKHYsRWUpO1VlKGkuVEVYVFVSRV9DVUJFX01BUCx2KTtsZXQgRztpZihHZSl7TGUmJktlJiZ0LnRleFN0b3JhZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVAsbmUsT2UsRWUud2lkdGgsRWUuaGVpZ2h0KTtmb3IobGV0ICQ9MDskPDY7JCsrKXtHPWhlWyRdLm1pcG1hcHM7Zm9yKGxldCBsZT0wO2xlPEcubGVuZ3RoO2xlKyspe2NvbnN0IGFlPUdbbGVdO3YuZm9ybWF0IT09MTAyMz9UZSE9PW51bGw/TGU/QyYmdC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCskLGxlLDAsMCxhZS53aWR0aCxhZS5oZWlnaHQsVGUsYWUuZGF0YSk6dC5jb21wcmVzc2VkVGV4SW1hZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCskLGxlLE9lLGFlLndpZHRoLGFlLmhlaWdodCwwLGFlLmRhdGEpOmNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnNldFRleHR1cmVDdWJlKCkiKTpMZT9DJiZ0LnRleFN1YkltYWdlMkQoaS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grJCxsZSwwLDAsYWUud2lkdGgsYWUuaGVpZ2h0LFRlLGRlLGFlLmRhdGEpOnQudGV4SW1hZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCskLGxlLE9lLGFlLndpZHRoLGFlLmhlaWdodCwwLFRlLGRlLGFlLmRhdGEpfX19ZWxzZXtpZihHPXYubWlwbWFwcyxMZSYmS2Upe0cubGVuZ3RoPjAmJm5lKys7Y29uc3QgJD1NZShoZVswXSk7dC50ZXhTdG9yYWdlMkQoaS5URVhUVVJFX0NVQkVfTUFQLG5lLE9lLCQud2lkdGgsJC5oZWlnaHQpfWZvcihsZXQgJD0wOyQ8NjskKyspaWYoail7TGU/QyYmdC50ZXhTdWJJbWFnZTJEKGkuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YKyQsMCwwLDAsaGVbJF0ud2lkdGgsaGVbJF0uaGVpZ2h0LFRlLGRlLGhlWyRdLmRhdGEpOnQudGV4SW1hZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCskLDAsT2UsaGVbJF0ud2lkdGgsaGVbJF0uaGVpZ2h0LDAsVGUsZGUsaGVbJF0uZGF0YSk7Zm9yKGxldCBsZT0wO2xlPEcubGVuZ3RoO2xlKyspe2NvbnN0IFJlPUdbbGVdLmltYWdlWyRdLmltYWdlO0xlP0MmJnQudGV4U3ViSW1hZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCskLGxlKzEsMCwwLFJlLndpZHRoLFJlLmhlaWdodCxUZSxkZSxSZS5kYXRhKTp0LnRleEltYWdlMkQoaS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grJCxsZSsxLE9lLFJlLndpZHRoLFJlLmhlaWdodCwwLFRlLGRlLFJlLmRhdGEpfX1lbHNle0xlP0MmJnQudGV4U3ViSW1hZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCskLDAsMCwwLFRlLGRlLGhlWyRdKTp0LnRleEltYWdlMkQoaS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grJCwwLE9lLFRlLGRlLGhlWyRdKTtmb3IobGV0IGxlPTA7bGU8Ry5sZW5ndGg7bGUrKyl7Y29uc3QgYWU9R1tsZV07TGU/QyYmdC50ZXhTdWJJbWFnZTJEKGkuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YKyQsbGUrMSwwLDAsVGUsZGUsYWUuaW1hZ2VbJF0pOnQudGV4SW1hZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCskLGxlKzEsT2UsVGUsZGUsYWUuaW1hZ2VbJF0pfX19bSh2KSYmdShpLlRFWFRVUkVfQ1VCRV9NQVApLGsuX192ZXJzaW9uPUsudmVyc2lvbix2Lm9uVXBkYXRlJiZ2Lm9uVXBkYXRlKHYpfUEuX192ZXJzaW9uPXYudmVyc2lvbn1mdW5jdGlvbiBnZShBLHYsSSxZLEssayl7Y29uc3QgX2U9cy5jb252ZXJ0KEkuZm9ybWF0LEkuY29sb3JTcGFjZSksc2U9cy5jb252ZXJ0KEkudHlwZSksdWU9eShJLmludGVybmFsRm9ybWF0LF9lLHNlLEkuY29sb3JTcGFjZSksR2U9bi5nZXQodiksaj1uLmdldChJKTtpZihqLl9fcmVuZGVyVGFyZ2V0PXYsIUdlLl9faGFzRXh0ZXJuYWxUZXh0dXJlcyl7Y29uc3QgaGU9TWF0aC5tYXgoMSx2LndpZHRoPj5rKSxFZT1NYXRoLm1heCgxLHYuaGVpZ2h0Pj5rKTtLPT09aS5URVhUVVJFXzNEfHxLPT09aS5URVhUVVJFXzJEX0FSUkFZP3QudGV4SW1hZ2UzRChLLGssdWUsaGUsRWUsdi5kZXB0aCwwLF9lLHNlLG51bGwpOnQudGV4SW1hZ2UyRChLLGssdWUsaGUsRWUsMCxfZSxzZSxudWxsKX10LmJpbmRGcmFtZWJ1ZmZlcihpLkZSQU1FQlVGRkVSLEEpLE5lKHYpP28uZnJhbWVidWZmZXJUZXh0dXJlMkRNdWx0aXNhbXBsZUVYVChpLkZSQU1FQlVGRkVSLFksSyxqLl9fd2ViZ2xUZXh0dXJlLDAsSWUodikpOihLPT09aS5URVhUVVJFXzJEfHxLPj1pLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCYmSzw9aS5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1opJiZpLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGkuRlJBTUVCVUZGRVIsWSxLLGouX193ZWJnbFRleHR1cmUsayksdC5iaW5kRnJhbWVidWZmZXIoaS5GUkFNRUJVRkZFUixudWxsKX1mdW5jdGlvbiByZShBLHYsSSl7aWYoaS5iaW5kUmVuZGVyYnVmZmVyKGkuUkVOREVSQlVGRkVSLEEpLHYuZGVwdGhCdWZmZXIpe2NvbnN0IFk9di5kZXB0aFRleHR1cmUsSz1ZJiZZLmlzRGVwdGhUZXh0dXJlP1kudHlwZTpudWxsLGs9Zyh2LnN0ZW5jaWxCdWZmZXIsSyksX2U9di5zdGVuY2lsQnVmZmVyP2kuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UOmkuREVQVEhfQVRUQUNITUVOVCxzZT1JZSh2KTtOZSh2KT9vLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZUVYVChpLlJFTkRFUkJVRkZFUixzZSxrLHYud2lkdGgsdi5oZWlnaHQpOkk/aS5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoaS5SRU5ERVJCVUZGRVIsc2Usayx2LndpZHRoLHYuaGVpZ2h0KTppLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoaS5SRU5ERVJCVUZGRVIsayx2LndpZHRoLHYuaGVpZ2h0KSxpLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGkuRlJBTUVCVUZGRVIsX2UsaS5SRU5ERVJCVUZGRVIsQSl9ZWxzZXtjb25zdCBZPXYudGV4dHVyZXM7Zm9yKGxldCBLPTA7SzxZLmxlbmd0aDtLKyspe2NvbnN0IGs9WVtLXSxfZT1zLmNvbnZlcnQoay5mb3JtYXQsay5jb2xvclNwYWNlKSxzZT1zLmNvbnZlcnQoay50eXBlKSx1ZT15KGsuaW50ZXJuYWxGb3JtYXQsX2Usc2Usay5jb2xvclNwYWNlKSxHZT1JZSh2KTtJJiZOZSh2KT09PSExP2kucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKGkuUkVOREVSQlVGRkVSLEdlLHVlLHYud2lkdGgsdi5oZWlnaHQpOk5lKHYpP28ucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlRVhUKGkuUkVOREVSQlVGRkVSLEdlLHVlLHYud2lkdGgsdi5oZWlnaHQpOmkucmVuZGVyYnVmZmVyU3RvcmFnZShpLlJFTkRFUkJVRkZFUix1ZSx2LndpZHRoLHYuaGVpZ2h0KX19aS5iaW5kUmVuZGVyYnVmZmVyKGkuUkVOREVSQlVGRkVSLG51bGwpfWZ1bmN0aW9uIHllKEEsdil7aWYodiYmdi5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCl0aHJvdyBuZXcgRXJyb3IoIkRlcHRoIFRleHR1cmUgd2l0aCBjdWJlIHJlbmRlciB0YXJnZXRzIGlzIG5vdCBzdXBwb3J0ZWQiKTtpZih0LmJpbmRGcmFtZWJ1ZmZlcihpLkZSQU1FQlVGRkVSLEEpLCEodi5kZXB0aFRleHR1cmUmJnYuZGVwdGhUZXh0dXJlLmlzRGVwdGhUZXh0dXJlKSl0aHJvdyBuZXcgRXJyb3IoInJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBUSFJFRS5EZXB0aFRleHR1cmUiKTtjb25zdCBZPW4uZ2V0KHYuZGVwdGhUZXh0dXJlKTtZLl9fcmVuZGVyVGFyZ2V0PXYsKCFZLl9fd2ViZ2xUZXh0dXJlfHx2LmRlcHRoVGV4dHVyZS5pbWFnZS53aWR0aCE9PXYud2lkdGh8fHYuZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodCE9PXYuaGVpZ2h0KSYmKHYuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoPXYud2lkdGgsdi5kZXB0aFRleHR1cmUuaW1hZ2UuaGVpZ2h0PXYuaGVpZ2h0LHYuZGVwdGhUZXh0dXJlLm5lZWRzVXBkYXRlPSEwKSxaKHYuZGVwdGhUZXh0dXJlLDApO2NvbnN0IEs9WS5fX3dlYmdsVGV4dHVyZSxrPUllKHYpO2lmKHYuZGVwdGhUZXh0dXJlLmZvcm1hdD09PTEwMjYpTmUodik/by5mcmFtZWJ1ZmZlclRleHR1cmUyRE11bHRpc2FtcGxlRVhUKGkuRlJBTUVCVUZGRVIsaS5ERVBUSF9BVFRBQ0hNRU5ULGkuVEVYVFVSRV8yRCxLLDAsayk6aS5mcmFtZWJ1ZmZlclRleHR1cmUyRChpLkZSQU1FQlVGRkVSLGkuREVQVEhfQVRUQUNITUVOVCxpLlRFWFRVUkVfMkQsSywwKTtlbHNlIGlmKHYuZGVwdGhUZXh0dXJlLmZvcm1hdD09PTEwMjcpTmUodik/by5mcmFtZWJ1ZmZlclRleHR1cmUyRE11bHRpc2FtcGxlRVhUKGkuRlJBTUVCVUZGRVIsaS5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsaS5URVhUVVJFXzJELEssMCxrKTppLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGkuRlJBTUVCVUZGRVIsaS5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsaS5URVhUVVJFXzJELEssMCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIlVua25vd24gZGVwdGhUZXh0dXJlIGZvcm1hdCIpfWZ1bmN0aW9uIHdlKEEpe2NvbnN0IHY9bi5nZXQoQSksST1BLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0PT09ITA7aWYodi5fX2JvdW5kRGVwdGhUZXh0dXJlIT09QS5kZXB0aFRleHR1cmUpe2NvbnN0IFk9QS5kZXB0aFRleHR1cmU7aWYodi5fX2RlcHRoRGlzcG9zZUNhbGxiYWNrJiZ2Ll9fZGVwdGhEaXNwb3NlQ2FsbGJhY2soKSxZKXtjb25zdCBLPSgpPT57ZGVsZXRlIHYuX19ib3VuZERlcHRoVGV4dHVyZSxkZWxldGUgdi5fX2RlcHRoRGlzcG9zZUNhbGxiYWNrLFkucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsSyl9O1kuYWRkRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsSyksdi5fX2RlcHRoRGlzcG9zZUNhbGxiYWNrPUt9di5fX2JvdW5kRGVwdGhUZXh0dXJlPVl9aWYoQS5kZXB0aFRleHR1cmUmJiF2Ll9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXIpe2lmKEkpdGhyb3cgbmV3IEVycm9yKCJ0YXJnZXQuZGVwdGhUZXh0dXJlIG5vdCBzdXBwb3J0ZWQgaW4gQ3ViZSByZW5kZXIgdGFyZ2V0cyIpO3llKHYuX193ZWJnbEZyYW1lYnVmZmVyLEEpfWVsc2UgaWYoSSl7di5fX3dlYmdsRGVwdGhidWZmZXI9W107Zm9yKGxldCBZPTA7WTw2O1krKylpZih0LmJpbmRGcmFtZWJ1ZmZlcihpLkZSQU1FQlVGRkVSLHYuX193ZWJnbEZyYW1lYnVmZmVyW1ldKSx2Ll9fd2ViZ2xEZXB0aGJ1ZmZlcltZXT09PXZvaWQgMCl2Ll9fd2ViZ2xEZXB0aGJ1ZmZlcltZXT1pLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLHJlKHYuX193ZWJnbERlcHRoYnVmZmVyW1ldLEEsITEpO2Vsc2V7Y29uc3QgSz1BLnN0ZW5jaWxCdWZmZXI/aS5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQ6aS5ERVBUSF9BVFRBQ0hNRU5ULGs9di5fX3dlYmdsRGVwdGhidWZmZXJbWV07aS5iaW5kUmVuZGVyYnVmZmVyKGkuUkVOREVSQlVGRkVSLGspLGkuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoaS5GUkFNRUJVRkZFUixLLGkuUkVOREVSQlVGRkVSLGspfX1lbHNlIGlmKHQuYmluZEZyYW1lYnVmZmVyKGkuRlJBTUVCVUZGRVIsdi5fX3dlYmdsRnJhbWVidWZmZXIpLHYuX193ZWJnbERlcHRoYnVmZmVyPT09dm9pZCAwKXYuX193ZWJnbERlcHRoYnVmZmVyPWkuY3JlYXRlUmVuZGVyYnVmZmVyKCkscmUodi5fX3dlYmdsRGVwdGhidWZmZXIsQSwhMSk7ZWxzZXtjb25zdCBZPUEuc3RlbmNpbEJ1ZmZlcj9pLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVDppLkRFUFRIX0FUVEFDSE1FTlQsSz12Ll9fd2ViZ2xEZXB0aGJ1ZmZlcjtpLmJpbmRSZW5kZXJidWZmZXIoaS5SRU5ERVJCVUZGRVIsSyksaS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihpLkZSQU1FQlVGRkVSLFksaS5SRU5ERVJCVUZGRVIsSyl9dC5iaW5kRnJhbWVidWZmZXIoaS5GUkFNRUJVRkZFUixudWxsKX1mdW5jdGlvbiBGZShBLHYsSSl7Y29uc3QgWT1uLmdldChBKTt2IT09dm9pZCAwJiZnZShZLl9fd2ViZ2xGcmFtZWJ1ZmZlcixBLEEudGV4dHVyZSxpLkNPTE9SX0FUVEFDSE1FTlQwLGkuVEVYVFVSRV8yRCwwKSxJIT09dm9pZCAwJiZ3ZShBKX1mdW5jdGlvbiBudChBKXtjb25zdCB2PUEudGV4dHVyZSxJPW4uZ2V0KEEpLFk9bi5nZXQodik7QS5hZGRFdmVudExpc3RlbmVyKCJkaXNwb3NlIixiKTtjb25zdCBLPUEudGV4dHVyZXMsaz1BLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0PT09ITAsX2U9Sy5sZW5ndGg+MTtpZihfZXx8KFkuX193ZWJnbFRleHR1cmU9PT12b2lkIDAmJihZLl9fd2ViZ2xUZXh0dXJlPWkuY3JlYXRlVGV4dHVyZSgpKSxZLl9fdmVyc2lvbj12LnZlcnNpb24sYS5tZW1vcnkudGV4dHVyZXMrKyksayl7SS5fX3dlYmdsRnJhbWVidWZmZXI9W107Zm9yKGxldCBzZT0wO3NlPDY7c2UrKylpZih2Lm1pcG1hcHMmJnYubWlwbWFwcy5sZW5ndGg+MCl7SS5fX3dlYmdsRnJhbWVidWZmZXJbc2VdPVtdO2ZvcihsZXQgdWU9MDt1ZTx2Lm1pcG1hcHMubGVuZ3RoO3VlKyspSS5fX3dlYmdsRnJhbWVidWZmZXJbc2VdW3VlXT1pLmNyZWF0ZUZyYW1lYnVmZmVyKCl9ZWxzZSBJLl9fd2ViZ2xGcmFtZWJ1ZmZlcltzZV09aS5jcmVhdGVGcmFtZWJ1ZmZlcigpfWVsc2V7aWYodi5taXBtYXBzJiZ2Lm1pcG1hcHMubGVuZ3RoPjApe0kuX193ZWJnbEZyYW1lYnVmZmVyPVtdO2ZvcihsZXQgc2U9MDtzZTx2Lm1pcG1hcHMubGVuZ3RoO3NlKyspSS5fX3dlYmdsRnJhbWVidWZmZXJbc2VdPWkuY3JlYXRlRnJhbWVidWZmZXIoKX1lbHNlIEkuX193ZWJnbEZyYW1lYnVmZmVyPWkuY3JlYXRlRnJhbWVidWZmZXIoKTtpZihfZSlmb3IobGV0IHNlPTAsdWU9Sy5sZW5ndGg7c2U8dWU7c2UrKyl7Y29uc3QgR2U9bi5nZXQoS1tzZV0pO0dlLl9fd2ViZ2xUZXh0dXJlPT09dm9pZCAwJiYoR2UuX193ZWJnbFRleHR1cmU9aS5jcmVhdGVUZXh0dXJlKCksYS5tZW1vcnkudGV4dHVyZXMrKyl9aWYoQS5zYW1wbGVzPjAmJk5lKEEpPT09ITEpe0kuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyPWkuY3JlYXRlRnJhbWVidWZmZXIoKSxJLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcj1bXSx0LmJpbmRGcmFtZWJ1ZmZlcihpLkZSQU1FQlVGRkVSLEkuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKTtmb3IobGV0IHNlPTA7c2U8Sy5sZW5ndGg7c2UrKyl7Y29uc3QgdWU9S1tzZV07SS5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbc2VdPWkuY3JlYXRlUmVuZGVyYnVmZmVyKCksaS5iaW5kUmVuZGVyYnVmZmVyKGkuUkVOREVSQlVGRkVSLEkuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyW3NlXSk7Y29uc3QgR2U9cy5jb252ZXJ0KHVlLmZvcm1hdCx1ZS5jb2xvclNwYWNlKSxqPXMuY29udmVydCh1ZS50eXBlKSxoZT15KHVlLmludGVybmFsRm9ybWF0LEdlLGosdWUuY29sb3JTcGFjZSxBLmlzWFJSZW5kZXJUYXJnZXQ9PT0hMCksRWU9SWUoQSk7aS5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoaS5SRU5ERVJCVUZGRVIsRWUsaGUsQS53aWR0aCxBLmhlaWdodCksaS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihpLkZSQU1FQlVGRkVSLGkuQ09MT1JfQVRUQUNITUVOVDArc2UsaS5SRU5ERVJCVUZGRVIsSS5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbc2VdKX1pLmJpbmRSZW5kZXJidWZmZXIoaS5SRU5ERVJCVUZGRVIsbnVsbCksQS5kZXB0aEJ1ZmZlciYmKEkuX193ZWJnbERlcHRoUmVuZGVyYnVmZmVyPWkuY3JlYXRlUmVuZGVyYnVmZmVyKCkscmUoSS5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIsQSwhMCkpLHQuYmluZEZyYW1lYnVmZmVyKGkuRlJBTUVCVUZGRVIsbnVsbCl9fWlmKGspe3QuYmluZFRleHR1cmUoaS5URVhUVVJFX0NVQkVfTUFQLFkuX193ZWJnbFRleHR1cmUpLFVlKGkuVEVYVFVSRV9DVUJFX01BUCx2KTtmb3IobGV0IHNlPTA7c2U8NjtzZSsrKWlmKHYubWlwbWFwcyYmdi5taXBtYXBzLmxlbmd0aD4wKWZvcihsZXQgdWU9MDt1ZTx2Lm1pcG1hcHMubGVuZ3RoO3VlKyspZ2UoSS5fX3dlYmdsRnJhbWVidWZmZXJbc2VdW3VlXSxBLHYsaS5DT0xPUl9BVFRBQ0hNRU5UMCxpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtzZSx1ZSk7ZWxzZSBnZShJLl9fd2ViZ2xGcmFtZWJ1ZmZlcltzZV0sQSx2LGkuQ09MT1JfQVRUQUNITUVOVDAsaS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grc2UsMCk7bSh2KSYmdShpLlRFWFRVUkVfQ1VCRV9NQVApLHQudW5iaW5kVGV4dHVyZSgpfWVsc2UgaWYoX2Upe2ZvcihsZXQgc2U9MCx1ZT1LLmxlbmd0aDtzZTx1ZTtzZSsrKXtjb25zdCBHZT1LW3NlXSxqPW4uZ2V0KEdlKTt0LmJpbmRUZXh0dXJlKGkuVEVYVFVSRV8yRCxqLl9fd2ViZ2xUZXh0dXJlKSxVZShpLlRFWFRVUkVfMkQsR2UpLGdlKEkuX193ZWJnbEZyYW1lYnVmZmVyLEEsR2UsaS5DT0xPUl9BVFRBQ0hNRU5UMCtzZSxpLlRFWFRVUkVfMkQsMCksbShHZSkmJnUoaS5URVhUVVJFXzJEKX10LnVuYmluZFRleHR1cmUoKX1lbHNle2xldCBzZT1pLlRFWFRVUkVfMkQ7aWYoKEEuaXNXZWJHTDNEUmVuZGVyVGFyZ2V0fHxBLmlzV2ViR0xBcnJheVJlbmRlclRhcmdldCkmJihzZT1BLmlzV2ViR0wzRFJlbmRlclRhcmdldD9pLlRFWFRVUkVfM0Q6aS5URVhUVVJFXzJEX0FSUkFZKSx0LmJpbmRUZXh0dXJlKHNlLFkuX193ZWJnbFRleHR1cmUpLFVlKHNlLHYpLHYubWlwbWFwcyYmdi5taXBtYXBzLmxlbmd0aD4wKWZvcihsZXQgdWU9MDt1ZTx2Lm1pcG1hcHMubGVuZ3RoO3VlKyspZ2UoSS5fX3dlYmdsRnJhbWVidWZmZXJbdWVdLEEsdixpLkNPTE9SX0FUVEFDSE1FTlQwLHNlLHVlKTtlbHNlIGdlKEkuX193ZWJnbEZyYW1lYnVmZmVyLEEsdixpLkNPTE9SX0FUVEFDSE1FTlQwLHNlLDApO20odikmJnUoc2UpLHQudW5iaW5kVGV4dHVyZSgpfUEuZGVwdGhCdWZmZXImJndlKEEpfWZ1bmN0aW9uIHplKEEpe2NvbnN0IHY9QS50ZXh0dXJlcztmb3IobGV0IEk9MCxZPXYubGVuZ3RoO0k8WTtJKyspe2NvbnN0IEs9dltJXTtpZihtKEspKXtjb25zdCBrPVQoQSksX2U9bi5nZXQoSykuX193ZWJnbFRleHR1cmU7dC5iaW5kVGV4dHVyZShrLF9lKSx1KGspLHQudW5iaW5kVGV4dHVyZSgpfX19Y29uc3QgYXQ9W10sVT1bXTtmdW5jdGlvbiBQdChBKXtpZihBLnNhbXBsZXM+MCl7aWYoTmUoQSk9PT0hMSl7Y29uc3Qgdj1BLnRleHR1cmVzLEk9QS53aWR0aCxZPUEuaGVpZ2h0O2xldCBLPWkuQ09MT1JfQlVGRkVSX0JJVDtjb25zdCBrPUEuc3RlbmNpbEJ1ZmZlcj9pLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVDppLkRFUFRIX0FUVEFDSE1FTlQsX2U9bi5nZXQoQSksc2U9di5sZW5ndGg+MTtpZihzZSlmb3IobGV0IHVlPTA7dWU8di5sZW5ndGg7dWUrKyl0LmJpbmRGcmFtZWJ1ZmZlcihpLkZSQU1FQlVGRkVSLF9lLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciksaS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihpLkZSQU1FQlVGRkVSLGkuQ09MT1JfQVRUQUNITUVOVDArdWUsaS5SRU5ERVJCVUZGRVIsbnVsbCksdC5iaW5kRnJhbWVidWZmZXIoaS5GUkFNRUJVRkZFUixfZS5fX3dlYmdsRnJhbWVidWZmZXIpLGkuZnJhbWVidWZmZXJUZXh0dXJlMkQoaS5EUkFXX0ZSQU1FQlVGRkVSLGkuQ09MT1JfQVRUQUNITUVOVDArdWUsaS5URVhUVVJFXzJELG51bGwsMCk7dC5iaW5kRnJhbWVidWZmZXIoaS5SRUFEX0ZSQU1FQlVGRkVSLF9lLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciksdC5iaW5kRnJhbWVidWZmZXIoaS5EUkFXX0ZSQU1FQlVGRkVSLF9lLl9fd2ViZ2xGcmFtZWJ1ZmZlcik7Zm9yKGxldCB1ZT0wO3VlPHYubGVuZ3RoO3VlKyspe2lmKEEucmVzb2x2ZURlcHRoQnVmZmVyJiYoQS5kZXB0aEJ1ZmZlciYmKEt8PWkuREVQVEhfQlVGRkVSX0JJVCksQS5zdGVuY2lsQnVmZmVyJiZBLnJlc29sdmVTdGVuY2lsQnVmZmVyJiYoS3w9aS5TVEVOQ0lMX0JVRkZFUl9CSVQpKSxzZSl7aS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihpLlJFQURfRlJBTUVCVUZGRVIsaS5DT0xPUl9BVFRBQ0hNRU5UMCxpLlJFTkRFUkJVRkZFUixfZS5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbdWVdKTtjb25zdCBHZT1uLmdldCh2W3VlXSkuX193ZWJnbFRleHR1cmU7aS5mcmFtZWJ1ZmZlclRleHR1cmUyRChpLkRSQVdfRlJBTUVCVUZGRVIsaS5DT0xPUl9BVFRBQ0hNRU5UMCxpLlRFWFRVUkVfMkQsR2UsMCl9aS5ibGl0RnJhbWVidWZmZXIoMCwwLEksWSwwLDAsSSxZLEssaS5ORUFSRVNUKSxsPT09ITAmJihhdC5sZW5ndGg9MCxVLmxlbmd0aD0wLGF0LnB1c2goaS5DT0xPUl9BVFRBQ0hNRU5UMCt1ZSksQS5kZXB0aEJ1ZmZlciYmQS5yZXNvbHZlRGVwdGhCdWZmZXI9PT0hMSYmKGF0LnB1c2goayksVS5wdXNoKGspLGkuaW52YWxpZGF0ZUZyYW1lYnVmZmVyKGkuRFJBV19GUkFNRUJVRkZFUixVKSksaS5pbnZhbGlkYXRlRnJhbWVidWZmZXIoaS5SRUFEX0ZSQU1FQlVGRkVSLGF0KSl9aWYodC5iaW5kRnJhbWVidWZmZXIoaS5SRUFEX0ZSQU1FQlVGRkVSLG51bGwpLHQuYmluZEZyYW1lYnVmZmVyKGkuRFJBV19GUkFNRUJVRkZFUixudWxsKSxzZSlmb3IobGV0IHVlPTA7dWU8di5sZW5ndGg7dWUrKyl7dC5iaW5kRnJhbWVidWZmZXIoaS5GUkFNRUJVRkZFUixfZS5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpLGkuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoaS5GUkFNRUJVRkZFUixpLkNPTE9SX0FUVEFDSE1FTlQwK3VlLGkuUkVOREVSQlVGRkVSLF9lLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlclt1ZV0pO2NvbnN0IEdlPW4uZ2V0KHZbdWVdKS5fX3dlYmdsVGV4dHVyZTt0LmJpbmRGcmFtZWJ1ZmZlcihpLkZSQU1FQlVGRkVSLF9lLl9fd2ViZ2xGcmFtZWJ1ZmZlciksaS5mcmFtZWJ1ZmZlclRleHR1cmUyRChpLkRSQVdfRlJBTUVCVUZGRVIsaS5DT0xPUl9BVFRBQ0hNRU5UMCt1ZSxpLlRFWFRVUkVfMkQsR2UsMCl9dC5iaW5kRnJhbWVidWZmZXIoaS5EUkFXX0ZSQU1FQlVGRkVSLF9lLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcil9ZWxzZSBpZihBLmRlcHRoQnVmZmVyJiZBLnJlc29sdmVEZXB0aEJ1ZmZlcj09PSExJiZsKXtjb25zdCB2PUEuc3RlbmNpbEJ1ZmZlcj9pLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVDppLkRFUFRIX0FUVEFDSE1FTlQ7aS5pbnZhbGlkYXRlRnJhbWVidWZmZXIoaS5EUkFXX0ZSQU1FQlVGRkVSLFt2XSl9fX1mdW5jdGlvbiBJZShBKXtyZXR1cm4gTWF0aC5taW4oci5tYXhTYW1wbGVzLEEuc2FtcGxlcyl9ZnVuY3Rpb24gTmUoQSl7Y29uc3Qgdj1uLmdldChBKTtyZXR1cm4gQS5zYW1wbGVzPjAmJmUuaGFzKCJXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUiKT09PSEwJiZ2Ll9fdXNlUmVuZGVyVG9UZXh0dXJlIT09ITF9ZnVuY3Rpb24gU2UoQSl7Y29uc3Qgdj1hLnJlbmRlci5mcmFtZTtoLmdldChBKSE9PXYmJihoLnNldChBLHYpLEEudXBkYXRlKCkpfWZ1bmN0aW9uIGplKEEsdil7Y29uc3QgST1BLmNvbG9yU3BhY2UsWT1BLmZvcm1hdCxLPUEudHlwZTtyZXR1cm4gQS5pc0NvbXByZXNzZWRUZXh0dXJlPT09ITB8fEEuaXNWaWRlb1RleHR1cmU9PT0hMHx8SSE9PXhuJiZJIT09anQmJihCZS5nZXRUcmFuc2ZlcihJKT09PXFlPyhZIT09MTAyM3x8SyE9PTEwMDkpJiZjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMVGV4dHVyZXM6IHNSR0IgZW5jb2RlZCB0ZXh0dXJlcyBoYXZlIHRvIHVzZSBSR0JBRm9ybWF0IGFuZCBVbnNpZ25lZEJ5dGVUeXBlLiIpOmNvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMVGV4dHVyZXM6IFVuc3VwcG9ydGVkIHRleHR1cmUgY29sb3Igc3BhY2U6IixJKSksdn1mdW5jdGlvbiBNZShBKXtyZXR1cm4gdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQ8InUiJiZBIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudD8oYy53aWR0aD1BLm5hdHVyYWxXaWR0aHx8QS53aWR0aCxjLmhlaWdodD1BLm5hdHVyYWxIZWlnaHR8fEEuaGVpZ2h0KTp0eXBlb2YgVmlkZW9GcmFtZTwidSImJkEgaW5zdGFuY2VvZiBWaWRlb0ZyYW1lPyhjLndpZHRoPUEuZGlzcGxheVdpZHRoLGMuaGVpZ2h0PUEuZGlzcGxheUhlaWdodCk6KGMud2lkdGg9QS53aWR0aCxjLmhlaWdodD1BLmhlaWdodCksY310aGlzLmFsbG9jYXRlVGV4dHVyZVVuaXQ9eix0aGlzLnJlc2V0VGV4dHVyZVVuaXRzPXEsdGhpcy5zZXRUZXh0dXJlMkQ9Wix0aGlzLnNldFRleHR1cmUyREFycmF5PVYsdGhpcy5zZXRUZXh0dXJlM0Q9USx0aGlzLnNldFRleHR1cmVDdWJlPUgsdGhpcy5yZWJpbmRUZXh0dXJlcz1GZSx0aGlzLnNldHVwUmVuZGVyVGFyZ2V0PW50LHRoaXMudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwPXplLHRoaXMudXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQ9UHQsdGhpcy5zZXR1cERlcHRoUmVuZGVyYnVmZmVyPXdlLHRoaXMuc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmU9Z2UsdGhpcy51c2VNdWx0aXNhbXBsZWRSVFQ9TmV9ZnVuY3Rpb24gVXUoaSxlKXtmdW5jdGlvbiB0KG4scj1qdCl7bGV0IHM7Y29uc3QgYT1CZS5nZXRUcmFuc2ZlcihyKTtpZihuPT09MTAwOSlyZXR1cm4gaS5VTlNJR05FRF9CWVRFO2lmKG49PT0xMDE3KXJldHVybiBpLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7aWYobj09PTEwMTgpcmV0dXJuIGkuVU5TSUdORURfU0hPUlRfNV81XzVfMTtpZihuPT09MzU5MDIpcmV0dXJuIGkuVU5TSUdORURfSU5UXzVfOV85XzlfUkVWO2lmKG49PT0xMDEwKXJldHVybiBpLkJZVEU7aWYobj09PTEwMTEpcmV0dXJuIGkuU0hPUlQ7aWYobj09PTEwMTIpcmV0dXJuIGkuVU5TSUdORURfU0hPUlQ7aWYobj09PTEwMTMpcmV0dXJuIGkuSU5UO2lmKG49PT0xMDE0KXJldHVybiBpLlVOU0lHTkVEX0lOVDtpZihuPT09MTAxNSlyZXR1cm4gaS5GTE9BVDtpZihuPT09MTAxNilyZXR1cm4gaS5IQUxGX0ZMT0FUO2lmKG49PT0xMDIxKXJldHVybiBpLkFMUEhBO2lmKG49PT0xMDIyKXJldHVybiBpLlJHQjtpZihuPT09MTAyMylyZXR1cm4gaS5SR0JBO2lmKG49PT0xMDI0KXJldHVybiBpLkxVTUlOQU5DRTtpZihuPT09MTAyNSlyZXR1cm4gaS5MVU1JTkFOQ0VfQUxQSEE7aWYobj09PTEwMjYpcmV0dXJuIGkuREVQVEhfQ09NUE9ORU5UO2lmKG49PT0xMDI3KXJldHVybiBpLkRFUFRIX1NURU5DSUw7aWYobj09PTEwMjgpcmV0dXJuIGkuUkVEO2lmKG49PT0xMDI5KXJldHVybiBpLlJFRF9JTlRFR0VSO2lmKG49PT0xMDMwKXJldHVybiBpLlJHO2lmKG49PT0xMDMxKXJldHVybiBpLlJHX0lOVEVHRVI7aWYobj09PTEwMzMpcmV0dXJuIGkuUkdCQV9JTlRFR0VSO2lmKG49PT0zMzc3Nnx8bj09PTMzNzc3fHxuPT09MzM3Nzh8fG49PT0zMzc3OSlpZihhPT09cWUpaWYocz1lLmdldCgiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNfc3JnYiIpLHMhPT1udWxsKXtpZihuPT09MzM3NzYpcmV0dXJuIHMuQ09NUFJFU1NFRF9TUkdCX1MzVENfRFhUMV9FWFQ7aWYobj09PTMzNzc3KXJldHVybiBzLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDFfRVhUO2lmKG49PT0zMzc3OClyZXR1cm4gcy5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQzX0VYVDtpZihuPT09MzM3NzkpcmV0dXJuIHMuQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUNV9FWFR9ZWxzZSByZXR1cm4gbnVsbDtlbHNlIGlmKHM9ZS5nZXQoIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjIikscyE9PW51bGwpe2lmKG49PT0zMzc3NilyZXR1cm4gcy5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO2lmKG49PT0zMzc3NylyZXR1cm4gcy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDtpZihuPT09MzM3NzgpcmV0dXJuIHMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQ7aWYobj09PTMzNzc5KXJldHVybiBzLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUfWVsc2UgcmV0dXJuIG51bGw7aWYobj09PTM1ODQwfHxuPT09MzU4NDF8fG49PT0zNTg0Mnx8bj09PTM1ODQzKWlmKHM9ZS5nZXQoIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YyIpLHMhPT1udWxsKXtpZihuPT09MzU4NDApcmV0dXJuIHMuQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztpZihuPT09MzU4NDEpcmV0dXJuIHMuQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRztpZihuPT09MzU4NDIpcmV0dXJuIHMuQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUc7aWYobj09PTM1ODQzKXJldHVybiBzLkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HfWVsc2UgcmV0dXJuIG51bGw7aWYobj09PTM2MTk2fHxuPT09Mzc0OTJ8fG49PT0zNzQ5NilpZihzPWUuZ2V0KCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjIikscyE9PW51bGwpe2lmKG49PT0zNjE5Nnx8bj09PTM3NDkyKXJldHVybiBhPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0VUQzI6cy5DT01QUkVTU0VEX1JHQjhfRVRDMjtpZihuPT09Mzc0OTYpcmV0dXJuIGE9PT1xZT9zLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0VUQzJfRUFDOnMuQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQ31lbHNlIHJldHVybiBudWxsO2lmKG49PT0zNzgwOHx8bj09PTM3ODA5fHxuPT09Mzc4MTB8fG49PT0zNzgxMXx8bj09PTM3ODEyfHxuPT09Mzc4MTN8fG49PT0zNzgxNHx8bj09PTM3ODE1fHxuPT09Mzc4MTZ8fG49PT0zNzgxN3x8bj09PTM3ODE4fHxuPT09Mzc4MTl8fG49PT0zNzgyMHx8bj09PTM3ODIxKWlmKHM9ZS5nZXQoIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hc3RjIikscyE9PW51bGwpe2lmKG49PT0zNzgwOClyZXR1cm4gYT09PXFlP3MuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ180eDRfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfNHg0X0tIUjtpZihuPT09Mzc4MDkpcmV0dXJuIGE9PT1xZT9zLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNXg0X0tIUjpzLkNPTVBSRVNTRURfUkdCQV9BU1RDXzV4NF9LSFI7aWYobj09PTM3ODEwKXJldHVybiBhPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzV4NV9LSFI6cy5DT01QUkVTU0VEX1JHQkFfQVNUQ181eDVfS0hSO2lmKG49PT0zNzgxMSlyZXR1cm4gYT09PXFlP3MuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ182eDVfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfNng1X0tIUjtpZihuPT09Mzc4MTIpcmV0dXJuIGE9PT1xZT9zLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNng2X0tIUjpzLkNPTVBSRVNTRURfUkdCQV9BU1RDXzZ4Nl9LSFI7aWYobj09PTM3ODEzKXJldHVybiBhPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzh4NV9LSFI6cy5DT01QUkVTU0VEX1JHQkFfQVNUQ184eDVfS0hSO2lmKG49PT0zNzgxNClyZXR1cm4gYT09PXFlP3MuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDZfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfOHg2X0tIUjtpZihuPT09Mzc4MTUpcmV0dXJuIGE9PT1xZT9zLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfOHg4X0tIUjpzLkNPTVBSRVNTRURfUkdCQV9BU1RDXzh4OF9LSFI7aWYobj09PTM3ODE2KXJldHVybiBhPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDVfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4NV9LSFI7aWYobj09PTM3ODE3KXJldHVybiBhPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDZfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4Nl9LSFI7aWYobj09PTM3ODE4KXJldHVybiBhPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDhfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4OF9LSFI7aWYobj09PTM3ODE5KXJldHVybiBhPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDEwX0tIUjpzLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDEwX0tIUjtpZihuPT09Mzc4MjApcmV0dXJuIGE9PT1xZT9zLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTJ4MTBfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfMTJ4MTBfS0hSO2lmKG49PT0zNzgyMSlyZXR1cm4gYT09PXFlP3MuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMngxMl9LSFI6cy5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMngxMl9LSFJ9ZWxzZSByZXR1cm4gbnVsbDtpZihuPT09MzY0OTJ8fG49PT0zNjQ5NHx8bj09PTM2NDk1KWlmKHM9ZS5nZXQoIkVYVF90ZXh0dXJlX2NvbXByZXNzaW9uX2JwdGMiKSxzIT09bnVsbCl7aWYobj09PTM2NDkyKXJldHVybiBhPT09cWU/cy5DT01QUkVTU0VEX1NSR0JfQUxQSEFfQlBUQ19VTk9STV9FWFQ6cy5DT01QUkVTU0VEX1JHQkFfQlBUQ19VTk9STV9FWFQ7aWYobj09PTM2NDk0KXJldHVybiBzLkNPTVBSRVNTRURfUkdCX0JQVENfU0lHTkVEX0ZMT0FUX0VYVDtpZihuPT09MzY0OTUpcmV0dXJuIHMuQ09NUFJFU1NFRF9SR0JfQlBUQ19VTlNJR05FRF9GTE9BVF9FWFR9ZWxzZSByZXR1cm4gbnVsbDtpZihuPT09MzYyODN8fG49PT0zNjI4NHx8bj09PTM2Mjg1fHxuPT09MzYyODYpaWYocz1lLmdldCgiRVhUX3RleHR1cmVfY29tcHJlc3Npb25fcmd0YyIpLHMhPT1udWxsKXtpZihuPT09MzY0OTIpcmV0dXJuIHMuQ09NUFJFU1NFRF9SRURfUkdUQzFfRVhUO2lmKG49PT0zNjI4NClyZXR1cm4gcy5DT01QUkVTU0VEX1NJR05FRF9SRURfUkdUQzFfRVhUO2lmKG49PT0zNjI4NSlyZXR1cm4gcy5DT01QUkVTU0VEX1JFRF9HUkVFTl9SR1RDMl9FWFQ7aWYobj09PTM2Mjg2KXJldHVybiBzLkNPTVBSRVNTRURfU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9FWFR9ZWxzZSByZXR1cm4gbnVsbDtyZXR1cm4gbj09PTEwMjA/aS5VTlNJR05FRF9JTlRfMjRfODppW25dIT09dm9pZCAwP2lbbl06bnVsbH1yZXR1cm57Y29udmVydDp0fX1jbGFzcyBGdSBleHRlbmRzIE50e2NvbnN0cnVjdG9yKGU9W10pe3N1cGVyKCksdGhpcy5pc0FycmF5Q2FtZXJhPSEwLHRoaXMuY2FtZXJhcz1lfX1jbGFzcyBkdCBleHRlbmRzIE10e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmlzR3JvdXA9ITAsdGhpcy50eXBlPSJHcm91cCJ9fWNvbnN0IEl1PXt0eXBlOiJtb3ZlIn07Y2xhc3MgZnJ7Y29uc3RydWN0b3IoKXt0aGlzLl90YXJnZXRSYXk9bnVsbCx0aGlzLl9ncmlwPW51bGwsdGhpcy5faGFuZD1udWxsfWdldEhhbmRTcGFjZSgpe3JldHVybiB0aGlzLl9oYW5kPT09bnVsbCYmKHRoaXMuX2hhbmQ9bmV3IGR0LHRoaXMuX2hhbmQubWF0cml4QXV0b1VwZGF0ZT0hMSx0aGlzLl9oYW5kLnZpc2libGU9ITEsdGhpcy5faGFuZC5qb2ludHM9e30sdGhpcy5faGFuZC5pbnB1dFN0YXRlPXtwaW5jaGluZzohMX0pLHRoaXMuX2hhbmR9Z2V0VGFyZ2V0UmF5U3BhY2UoKXtyZXR1cm4gdGhpcy5fdGFyZ2V0UmF5PT09bnVsbCYmKHRoaXMuX3RhcmdldFJheT1uZXcgZHQsdGhpcy5fdGFyZ2V0UmF5Lm1hdHJpeEF1dG9VcGRhdGU9ITEsdGhpcy5fdGFyZ2V0UmF5LnZpc2libGU9ITEsdGhpcy5fdGFyZ2V0UmF5Lmhhc0xpbmVhclZlbG9jaXR5PSExLHRoaXMuX3RhcmdldFJheS5saW5lYXJWZWxvY2l0eT1uZXcgTyx0aGlzLl90YXJnZXRSYXkuaGFzQW5ndWxhclZlbG9jaXR5PSExLHRoaXMuX3RhcmdldFJheS5hbmd1bGFyVmVsb2NpdHk9bmV3IE8pLHRoaXMuX3RhcmdldFJheX1nZXRHcmlwU3BhY2UoKXtyZXR1cm4gdGhpcy5fZ3JpcD09PW51bGwmJih0aGlzLl9ncmlwPW5ldyBkdCx0aGlzLl9ncmlwLm1hdHJpeEF1dG9VcGRhdGU9ITEsdGhpcy5fZ3JpcC52aXNpYmxlPSExLHRoaXMuX2dyaXAuaGFzTGluZWFyVmVsb2NpdHk9ITEsdGhpcy5fZ3JpcC5saW5lYXJWZWxvY2l0eT1uZXcgTyx0aGlzLl9ncmlwLmhhc0FuZ3VsYXJWZWxvY2l0eT0hMSx0aGlzLl9ncmlwLmFuZ3VsYXJWZWxvY2l0eT1uZXcgTyksdGhpcy5fZ3JpcH1kaXNwYXRjaEV2ZW50KGUpe3JldHVybiB0aGlzLl90YXJnZXRSYXkhPT1udWxsJiZ0aGlzLl90YXJnZXRSYXkuZGlzcGF0Y2hFdmVudChlKSx0aGlzLl9ncmlwIT09bnVsbCYmdGhpcy5fZ3JpcC5kaXNwYXRjaEV2ZW50KGUpLHRoaXMuX2hhbmQhPT1udWxsJiZ0aGlzLl9oYW5kLmRpc3BhdGNoRXZlbnQoZSksdGhpc31jb25uZWN0KGUpe2lmKGUmJmUuaGFuZCl7Y29uc3QgdD10aGlzLl9oYW5kO2lmKHQpZm9yKGNvbnN0IG4gb2YgZS5oYW5kLnZhbHVlcygpKXRoaXMuX2dldEhhbmRKb2ludCh0LG4pfXJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImNvbm5lY3RlZCIsZGF0YTplfSksdGhpc31kaXNjb25uZWN0KGUpe3JldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImRpc2Nvbm5lY3RlZCIsZGF0YTplfSksdGhpcy5fdGFyZ2V0UmF5IT09bnVsbCYmKHRoaXMuX3RhcmdldFJheS52aXNpYmxlPSExKSx0aGlzLl9ncmlwIT09bnVsbCYmKHRoaXMuX2dyaXAudmlzaWJsZT0hMSksdGhpcy5faGFuZCE9PW51bGwmJih0aGlzLl9oYW5kLnZpc2libGU9ITEpLHRoaXN9dXBkYXRlKGUsdCxuKXtsZXQgcj1udWxsLHM9bnVsbCxhPW51bGw7Y29uc3Qgbz10aGlzLl90YXJnZXRSYXksbD10aGlzLl9ncmlwLGM9dGhpcy5faGFuZDtpZihlJiZ0LnNlc3Npb24udmlzaWJpbGl0eVN0YXRlIT09InZpc2libGUtYmx1cnJlZCIpe2lmKGMmJmUuaGFuZCl7YT0hMDtmb3IoY29uc3QgeCBvZiBlLmhhbmQudmFsdWVzKCkpe2NvbnN0IG09dC5nZXRKb2ludFBvc2UoeCxuKSx1PXRoaXMuX2dldEhhbmRKb2ludChjLHgpO20hPT1udWxsJiYodS5tYXRyaXguZnJvbUFycmF5KG0udHJhbnNmb3JtLm1hdHJpeCksdS5tYXRyaXguZGVjb21wb3NlKHUucG9zaXRpb24sdS5yb3RhdGlvbix1LnNjYWxlKSx1Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITAsdS5qb2ludFJhZGl1cz1tLnJhZGl1cyksdS52aXNpYmxlPW0hPT1udWxsfWNvbnN0IGg9Yy5qb2ludHNbImluZGV4LWZpbmdlci10aXAiXSxkPWMuam9pbnRzWyJ0aHVtYi10aXAiXSxmPWgucG9zaXRpb24uZGlzdGFuY2VUbyhkLnBvc2l0aW9uKSxwPS4wMixfPS4wMDU7Yy5pbnB1dFN0YXRlLnBpbmNoaW5nJiZmPnArXz8oYy5pbnB1dFN0YXRlLnBpbmNoaW5nPSExLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicGluY2hlbmQiLGhhbmRlZG5lc3M6ZS5oYW5kZWRuZXNzLHRhcmdldDp0aGlzfSkpOiFjLmlucHV0U3RhdGUucGluY2hpbmcmJmY8PXAtXyYmKGMuaW5wdXRTdGF0ZS5waW5jaGluZz0hMCx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6InBpbmNoc3RhcnQiLGhhbmRlZG5lc3M6ZS5oYW5kZWRuZXNzLHRhcmdldDp0aGlzfSkpfWVsc2UgbCE9PW51bGwmJmUuZ3JpcFNwYWNlJiYocz10LmdldFBvc2UoZS5ncmlwU3BhY2UsbikscyE9PW51bGwmJihsLm1hdHJpeC5mcm9tQXJyYXkocy50cmFuc2Zvcm0ubWF0cml4KSxsLm1hdHJpeC5kZWNvbXBvc2UobC5wb3NpdGlvbixsLnJvdGF0aW9uLGwuc2NhbGUpLGwubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMCxzLmxpbmVhclZlbG9jaXR5PyhsLmhhc0xpbmVhclZlbG9jaXR5PSEwLGwubGluZWFyVmVsb2NpdHkuY29weShzLmxpbmVhclZlbG9jaXR5KSk6bC5oYXNMaW5lYXJWZWxvY2l0eT0hMSxzLmFuZ3VsYXJWZWxvY2l0eT8obC5oYXNBbmd1bGFyVmVsb2NpdHk9ITAsbC5hbmd1bGFyVmVsb2NpdHkuY29weShzLmFuZ3VsYXJWZWxvY2l0eSkpOmwuaGFzQW5ndWxhclZlbG9jaXR5PSExKSk7byE9PW51bGwmJihyPXQuZ2V0UG9zZShlLnRhcmdldFJheVNwYWNlLG4pLHI9PT1udWxsJiZzIT09bnVsbCYmKHI9cyksciE9PW51bGwmJihvLm1hdHJpeC5mcm9tQXJyYXkoci50cmFuc2Zvcm0ubWF0cml4KSxvLm1hdHJpeC5kZWNvbXBvc2Uoby5wb3NpdGlvbixvLnJvdGF0aW9uLG8uc2NhbGUpLG8ubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMCxyLmxpbmVhclZlbG9jaXR5PyhvLmhhc0xpbmVhclZlbG9jaXR5PSEwLG8ubGluZWFyVmVsb2NpdHkuY29weShyLmxpbmVhclZlbG9jaXR5KSk6by5oYXNMaW5lYXJWZWxvY2l0eT0hMSxyLmFuZ3VsYXJWZWxvY2l0eT8oby5oYXNBbmd1bGFyVmVsb2NpdHk9ITAsby5hbmd1bGFyVmVsb2NpdHkuY29weShyLmFuZ3VsYXJWZWxvY2l0eSkpOm8uaGFzQW5ndWxhclZlbG9jaXR5PSExLHRoaXMuZGlzcGF0Y2hFdmVudChJdSkpKX1yZXR1cm4gbyE9PW51bGwmJihvLnZpc2libGU9ciE9PW51bGwpLGwhPT1udWxsJiYobC52aXNpYmxlPXMhPT1udWxsKSxjIT09bnVsbCYmKGMudmlzaWJsZT1hIT09bnVsbCksdGhpc31fZ2V0SGFuZEpvaW50KGUsdCl7aWYoZS5qb2ludHNbdC5qb2ludE5hbWVdPT09dm9pZCAwKXtjb25zdCBuPW5ldyBkdDtuLm1hdHJpeEF1dG9VcGRhdGU9ITEsbi52aXNpYmxlPSExLGUuam9pbnRzW3Quam9pbnROYW1lXT1uLGUuYWRkKG4pfXJldHVybiBlLmpvaW50c1t0LmpvaW50TmFtZV19fWNvbnN0IE51PWAKdm9pZCBtYWluKCkgewoKCWdsX1Bvc2l0aW9uID0gdmVjNCggcG9zaXRpb24sIDEuMCApOwoKfWAsT3U9YAp1bmlmb3JtIHNhbXBsZXIyREFycmF5IGRlcHRoQ29sb3I7CnVuaWZvcm0gZmxvYXQgZGVwdGhXaWR0aDsKdW5pZm9ybSBmbG9hdCBkZXB0aEhlaWdodDsKCnZvaWQgbWFpbigpIHsKCgl2ZWMyIGNvb3JkID0gdmVjMiggZ2xfRnJhZ0Nvb3JkLnggLyBkZXB0aFdpZHRoLCBnbF9GcmFnQ29vcmQueSAvIGRlcHRoSGVpZ2h0ICk7CgoJaWYgKCBjb29yZC54ID49IDEuMCApIHsKCgkJZ2xfRnJhZ0RlcHRoID0gdGV4dHVyZSggZGVwdGhDb2xvciwgdmVjMyggY29vcmQueCAtIDEuMCwgY29vcmQueSwgMSApICkucjsKCgl9IGVsc2UgewoKCQlnbF9GcmFnRGVwdGggPSB0ZXh0dXJlKCBkZXB0aENvbG9yLCB2ZWMzKCBjb29yZC54LCBjb29yZC55LCAwICkgKS5yOwoKCX0KCn1gO2NsYXNzIEJ1e2NvbnN0cnVjdG9yKCl7dGhpcy50ZXh0dXJlPW51bGwsdGhpcy5tZXNoPW51bGwsdGhpcy5kZXB0aE5lYXI9MCx0aGlzLmRlcHRoRmFyPTB9aW5pdChlLHQsbil7aWYodGhpcy50ZXh0dXJlPT09bnVsbCl7Y29uc3Qgcj1uZXcgdnQscz1lLnByb3BlcnRpZXMuZ2V0KHIpO3MuX193ZWJnbFRleHR1cmU9dC50ZXh0dXJlLCh0LmRlcHRoTmVhciE9bi5kZXB0aE5lYXJ8fHQuZGVwdGhGYXIhPW4uZGVwdGhGYXIpJiYodGhpcy5kZXB0aE5lYXI9dC5kZXB0aE5lYXIsdGhpcy5kZXB0aEZhcj10LmRlcHRoRmFyKSx0aGlzLnRleHR1cmU9cn19Z2V0TWVzaChlKXtpZih0aGlzLnRleHR1cmUhPT1udWxsJiZ0aGlzLm1lc2g9PT1udWxsKXtjb25zdCB0PWUuY2FtZXJhc1swXS52aWV3cG9ydCxuPW5ldyBsdCh7dmVydGV4U2hhZGVyOk51LGZyYWdtZW50U2hhZGVyOk91LHVuaWZvcm1zOntkZXB0aENvbG9yOnt2YWx1ZTp0aGlzLnRleHR1cmV9LGRlcHRoV2lkdGg6e3ZhbHVlOnQuen0sZGVwdGhIZWlnaHQ6e3ZhbHVlOnQud319fSk7dGhpcy5tZXNoPW5ldyB0dChuZXcgZXQoMjAsMjApLG4pfXJldHVybiB0aGlzLm1lc2h9cmVzZXQoKXt0aGlzLnRleHR1cmU9bnVsbCx0aGlzLm1lc2g9bnVsbH1nZXREZXB0aFRleHR1cmUoKXtyZXR1cm4gdGhpcy50ZXh0dXJlfX1jbGFzcyB6dSBleHRlbmRzIE1ue2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoKTtjb25zdCBuPXRoaXM7bGV0IHI9bnVsbCxzPTEsYT1udWxsLG89ImxvY2FsLWZsb29yIixsPTEsYz1udWxsLGg9bnVsbCxkPW51bGwsZj1udWxsLHA9bnVsbCxfPW51bGw7Y29uc3QgeD1uZXcgQnUsbT10LmdldENvbnRleHRBdHRyaWJ1dGVzKCk7bGV0IHU9bnVsbCxUPW51bGw7Y29uc3QgeT1bXSxnPVtdLFA9bmV3IFBlO2xldCB3PW51bGw7Y29uc3QgYj1uZXcgTnQ7Yi52aWV3cG9ydD1uZXcgcnQ7Y29uc3QgRj1uZXcgTnQ7Ri52aWV3cG9ydD1uZXcgcnQ7Y29uc3QgRT1bYixGXSxTPW5ldyBGdTtsZXQgUj1udWxsLHE9bnVsbDt0aGlzLmNhbWVyYUF1dG9VcGRhdGU9ITAsdGhpcy5lbmFibGVkPSExLHRoaXMuaXNQcmVzZW50aW5nPSExLHRoaXMuZ2V0Q29udHJvbGxlcj1mdW5jdGlvbihYKXtsZXQgZWU9eVtYXTtyZXR1cm4gZWU9PT12b2lkIDAmJihlZT1uZXcgZnIseVtYXT1lZSksZWUuZ2V0VGFyZ2V0UmF5U3BhY2UoKX0sdGhpcy5nZXRDb250cm9sbGVyR3JpcD1mdW5jdGlvbihYKXtsZXQgZWU9eVtYXTtyZXR1cm4gZWU9PT12b2lkIDAmJihlZT1uZXcgZnIseVtYXT1lZSksZWUuZ2V0R3JpcFNwYWNlKCl9LHRoaXMuZ2V0SGFuZD1mdW5jdGlvbihYKXtsZXQgZWU9eVtYXTtyZXR1cm4gZWU9PT12b2lkIDAmJihlZT1uZXcgZnIseVtYXT1lZSksZWUuZ2V0SGFuZFNwYWNlKCl9O2Z1bmN0aW9uIHooWCl7Y29uc3QgZWU9Zy5pbmRleE9mKFguaW5wdXRTb3VyY2UpO2lmKGVlPT09LTEpcmV0dXJuO2NvbnN0IGdlPXlbZWVdO2dlIT09dm9pZCAwJiYoZ2UudXBkYXRlKFguaW5wdXRTb3VyY2UsWC5mcmFtZSxjfHxhKSxnZS5kaXNwYXRjaEV2ZW50KHt0eXBlOlgudHlwZSxkYXRhOlguaW5wdXRTb3VyY2V9KSl9ZnVuY3Rpb24gVygpe3IucmVtb3ZlRXZlbnRMaXN0ZW5lcigic2VsZWN0Iix6KSxyLnJlbW92ZUV2ZW50TGlzdGVuZXIoInNlbGVjdHN0YXJ0Iix6KSxyLnJlbW92ZUV2ZW50TGlzdGVuZXIoInNlbGVjdGVuZCIseiksci5yZW1vdmVFdmVudExpc3RlbmVyKCJzcXVlZXplIix6KSxyLnJlbW92ZUV2ZW50TGlzdGVuZXIoInNxdWVlemVzdGFydCIseiksci5yZW1vdmVFdmVudExpc3RlbmVyKCJzcXVlZXplZW5kIix6KSxyLnJlbW92ZUV2ZW50TGlzdGVuZXIoImVuZCIsVyksci5yZW1vdmVFdmVudExpc3RlbmVyKCJpbnB1dHNvdXJjZXNjaGFuZ2UiLFopO2ZvcihsZXQgWD0wO1g8eS5sZW5ndGg7WCsrKXtjb25zdCBlZT1nW1hdO2VlIT09bnVsbCYmKGdbWF09bnVsbCx5W1hdLmRpc2Nvbm5lY3QoZWUpKX1SPW51bGwscT1udWxsLHgucmVzZXQoKSxlLnNldFJlbmRlclRhcmdldCh1KSxwPW51bGwsZj1udWxsLGQ9bnVsbCxyPW51bGwsVD1udWxsLFllLnN0b3AoKSxuLmlzUHJlc2VudGluZz0hMSxlLnNldFBpeGVsUmF0aW8odyksZS5zZXRTaXplKFAud2lkdGgsUC5oZWlnaHQsITEpLG4uZGlzcGF0Y2hFdmVudCh7dHlwZToic2Vzc2lvbmVuZCJ9KX10aGlzLnNldEZyYW1lYnVmZmVyU2NhbGVGYWN0b3I9ZnVuY3Rpb24oWCl7cz1YLG4uaXNQcmVzZW50aW5nPT09ITAmJmNvbnNvbGUud2FybigiVEhSRUUuV2ViWFJNYW5hZ2VyOiBDYW5ub3QgY2hhbmdlIGZyYW1lYnVmZmVyIHNjYWxlIHdoaWxlIHByZXNlbnRpbmcuIil9LHRoaXMuc2V0UmVmZXJlbmNlU3BhY2VUeXBlPWZ1bmN0aW9uKFgpe289WCxuLmlzUHJlc2VudGluZz09PSEwJiZjb25zb2xlLndhcm4oIlRIUkVFLldlYlhSTWFuYWdlcjogQ2Fubm90IGNoYW5nZSByZWZlcmVuY2Ugc3BhY2UgdHlwZSB3aGlsZSBwcmVzZW50aW5nLiIpfSx0aGlzLmdldFJlZmVyZW5jZVNwYWNlPWZ1bmN0aW9uKCl7cmV0dXJuIGN8fGF9LHRoaXMuc2V0UmVmZXJlbmNlU3BhY2U9ZnVuY3Rpb24oWCl7Yz1YfSx0aGlzLmdldEJhc2VMYXllcj1mdW5jdGlvbigpe3JldHVybiBmIT09bnVsbD9mOnB9LHRoaXMuZ2V0QmluZGluZz1mdW5jdGlvbigpe3JldHVybiBkfSx0aGlzLmdldEZyYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIF99LHRoaXMuZ2V0U2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybiByfSx0aGlzLnNldFNlc3Npb249YXN5bmMgZnVuY3Rpb24oWCl7aWYocj1YLHIhPT1udWxsKXtpZih1PWUuZ2V0UmVuZGVyVGFyZ2V0KCksci5hZGRFdmVudExpc3RlbmVyKCJzZWxlY3QiLHopLHIuYWRkRXZlbnRMaXN0ZW5lcigic2VsZWN0c3RhcnQiLHopLHIuYWRkRXZlbnRMaXN0ZW5lcigic2VsZWN0ZW5kIix6KSxyLmFkZEV2ZW50TGlzdGVuZXIoInNxdWVlemUiLHopLHIuYWRkRXZlbnRMaXN0ZW5lcigic3F1ZWV6ZXN0YXJ0Iix6KSxyLmFkZEV2ZW50TGlzdGVuZXIoInNxdWVlemVlbmQiLHopLHIuYWRkRXZlbnRMaXN0ZW5lcigiZW5kIixXKSxyLmFkZEV2ZW50TGlzdGVuZXIoImlucHV0c291cmNlc2NoYW5nZSIsWiksbS54ckNvbXBhdGlibGUhPT0hMCYmYXdhaXQgdC5tYWtlWFJDb21wYXRpYmxlKCksdz1lLmdldFBpeGVsUmF0aW8oKSxlLmdldFNpemUoUCksci5yZW5kZXJTdGF0ZS5sYXllcnM9PT12b2lkIDApe2NvbnN0IGVlPXthbnRpYWxpYXM6bS5hbnRpYWxpYXMsYWxwaGE6ITAsZGVwdGg6bS5kZXB0aCxzdGVuY2lsOm0uc3RlbmNpbCxmcmFtZWJ1ZmZlclNjYWxlRmFjdG9yOnN9O3A9bmV3IFhSV2ViR0xMYXllcihyLHQsZWUpLHIudXBkYXRlUmVuZGVyU3RhdGUoe2Jhc2VMYXllcjpwfSksZS5zZXRQaXhlbFJhdGlvKDEpLGUuc2V0U2l6ZShwLmZyYW1lYnVmZmVyV2lkdGgscC5mcmFtZWJ1ZmZlckhlaWdodCwhMSksVD1uZXcgSnQocC5mcmFtZWJ1ZmZlcldpZHRoLHAuZnJhbWVidWZmZXJIZWlnaHQse2Zvcm1hdDoxMDIzLHR5cGU6MTAwOSxjb2xvclNwYWNlOmUub3V0cHV0Q29sb3JTcGFjZSxzdGVuY2lsQnVmZmVyOm0uc3RlbmNpbH0pfWVsc2V7bGV0IGVlPW51bGwsZ2U9bnVsbCxyZT1udWxsO20uZGVwdGgmJihyZT1tLnN0ZW5jaWw/dC5ERVBUSDI0X1NURU5DSUw4OnQuREVQVEhfQ09NUE9ORU5UMjQsZWU9bS5zdGVuY2lsPzEwMjc6MTAyNixnZT1tLnN0ZW5jaWw/MTAyMDoxMDE0KTtjb25zdCB5ZT17Y29sb3JGb3JtYXQ6dC5SR0JBOCxkZXB0aEZvcm1hdDpyZSxzY2FsZUZhY3RvcjpzfTtkPW5ldyBYUldlYkdMQmluZGluZyhyLHQpLGY9ZC5jcmVhdGVQcm9qZWN0aW9uTGF5ZXIoeWUpLHIudXBkYXRlUmVuZGVyU3RhdGUoe2xheWVyczpbZl19KSxlLnNldFBpeGVsUmF0aW8oMSksZS5zZXRTaXplKGYudGV4dHVyZVdpZHRoLGYudGV4dHVyZUhlaWdodCwhMSksVD1uZXcgSnQoZi50ZXh0dXJlV2lkdGgsZi50ZXh0dXJlSGVpZ2h0LHtmb3JtYXQ6MTAyMyx0eXBlOjEwMDksZGVwdGhUZXh0dXJlOm5ldyBvcyhmLnRleHR1cmVXaWR0aCxmLnRleHR1cmVIZWlnaHQsZ2Usdm9pZCAwLHZvaWQgMCx2b2lkIDAsdm9pZCAwLHZvaWQgMCx2b2lkIDAsZWUpLHN0ZW5jaWxCdWZmZXI6bS5zdGVuY2lsLGNvbG9yU3BhY2U6ZS5vdXRwdXRDb2xvclNwYWNlLHNhbXBsZXM6bS5hbnRpYWxpYXM/NDowLHJlc29sdmVEZXB0aEJ1ZmZlcjpmLmlnbm9yZURlcHRoVmFsdWVzPT09ITF9KX1ULmlzWFJSZW5kZXJUYXJnZXQ9ITAsdGhpcy5zZXRGb3ZlYXRpb24obCksYz1udWxsLGE9YXdhaXQgci5yZXF1ZXN0UmVmZXJlbmNlU3BhY2UobyksWWUuc2V0Q29udGV4dChyKSxZZS5zdGFydCgpLG4uaXNQcmVzZW50aW5nPSEwLG4uZGlzcGF0Y2hFdmVudCh7dHlwZToic2Vzc2lvbnN0YXJ0In0pfX0sdGhpcy5nZXRFbnZpcm9ubWVudEJsZW5kTW9kZT1mdW5jdGlvbigpe2lmKHIhPT1udWxsKXJldHVybiByLmVudmlyb25tZW50QmxlbmRNb2RlfSx0aGlzLmdldERlcHRoVGV4dHVyZT1mdW5jdGlvbigpe3JldHVybiB4LmdldERlcHRoVGV4dHVyZSgpfTtmdW5jdGlvbiBaKFgpe2ZvcihsZXQgZWU9MDtlZTxYLnJlbW92ZWQubGVuZ3RoO2VlKyspe2NvbnN0IGdlPVgucmVtb3ZlZFtlZV0scmU9Zy5pbmRleE9mKGdlKTtyZT49MCYmKGdbcmVdPW51bGwseVtyZV0uZGlzY29ubmVjdChnZSkpfWZvcihsZXQgZWU9MDtlZTxYLmFkZGVkLmxlbmd0aDtlZSsrKXtjb25zdCBnZT1YLmFkZGVkW2VlXTtsZXQgcmU9Zy5pbmRleE9mKGdlKTtpZihyZT09PS0xKXtmb3IobGV0IHdlPTA7d2U8eS5sZW5ndGg7d2UrKylpZih3ZT49Zy5sZW5ndGgpe2cucHVzaChnZSkscmU9d2U7YnJlYWt9ZWxzZSBpZihnW3dlXT09PW51bGwpe2dbd2VdPWdlLHJlPXdlO2JyZWFrfWlmKHJlPT09LTEpYnJlYWt9Y29uc3QgeWU9eVtyZV07eWUmJnllLmNvbm5lY3QoZ2UpfX1jb25zdCBWPW5ldyBPLFE9bmV3IE87ZnVuY3Rpb24gSChYLGVlLGdlKXtWLnNldEZyb21NYXRyaXhQb3NpdGlvbihlZS5tYXRyaXhXb3JsZCksUS5zZXRGcm9tTWF0cml4UG9zaXRpb24oZ2UubWF0cml4V29ybGQpO2NvbnN0IHJlPVYuZGlzdGFuY2VUbyhRKSx5ZT1lZS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzLHdlPWdlLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMsRmU9eWVbMTRdLyh5ZVsxMF0tMSksbnQ9eWVbMTRdLyh5ZVsxMF0rMSksemU9KHllWzldKzEpL3llWzVdLGF0PSh5ZVs5XS0xKS95ZVs1XSxVPSh5ZVs4XS0xKS95ZVswXSxQdD0od2VbOF0rMSkvd2VbMF0sSWU9RmUqVSxOZT1GZSpQdCxTZT1yZS8oLVUrUHQpLGplPVNlKi1VO2lmKGVlLm1hdHJpeFdvcmxkLmRlY29tcG9zZShYLnBvc2l0aW9uLFgucXVhdGVybmlvbixYLnNjYWxlKSxYLnRyYW5zbGF0ZVgoamUpLFgudHJhbnNsYXRlWihTZSksWC5tYXRyaXhXb3JsZC5jb21wb3NlKFgucG9zaXRpb24sWC5xdWF0ZXJuaW9uLFguc2NhbGUpLFgubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoWC5tYXRyaXhXb3JsZCkuaW52ZXJ0KCkseWVbMTBdPT09LTEpWC5wcm9qZWN0aW9uTWF0cml4LmNvcHkoZWUucHJvamVjdGlvbk1hdHJpeCksWC5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KGVlLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKTtlbHNle2NvbnN0IE1lPUZlK1NlLEE9bnQrU2Usdj1JZS1qZSxJPU5lKyhyZS1qZSksWT16ZSpudC9BKk1lLEs9YXQqbnQvQSpNZTtYLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKHYsSSxZLEssTWUsQSksWC5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KFgucHJvamVjdGlvbk1hdHJpeCkuaW52ZXJ0KCl9fWZ1bmN0aW9uIGllKFgsZWUpe2VlPT09bnVsbD9YLm1hdHJpeFdvcmxkLmNvcHkoWC5tYXRyaXgpOlgubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyhlZS5tYXRyaXhXb3JsZCxYLm1hdHJpeCksWC5tYXRyaXhXb3JsZEludmVyc2UuY29weShYLm1hdHJpeFdvcmxkKS5pbnZlcnQoKX10aGlzLnVwZGF0ZUNhbWVyYT1mdW5jdGlvbihYKXtpZihyPT09bnVsbClyZXR1cm47bGV0IGVlPVgubmVhcixnZT1YLmZhcjt4LnRleHR1cmUhPT1udWxsJiYoeC5kZXB0aE5lYXI+MCYmKGVlPXguZGVwdGhOZWFyKSx4LmRlcHRoRmFyPjAmJihnZT14LmRlcHRoRmFyKSksUy5uZWFyPUYubmVhcj1iLm5lYXI9ZWUsUy5mYXI9Ri5mYXI9Yi5mYXI9Z2UsKFIhPT1TLm5lYXJ8fHEhPT1TLmZhcikmJihyLnVwZGF0ZVJlbmRlclN0YXRlKHtkZXB0aE5lYXI6Uy5uZWFyLGRlcHRoRmFyOlMuZmFyfSksUj1TLm5lYXIscT1TLmZhciksYi5sYXllcnMubWFzaz1YLmxheWVycy5tYXNrfDIsRi5sYXllcnMubWFzaz1YLmxheWVycy5tYXNrfDQsUy5sYXllcnMubWFzaz1iLmxheWVycy5tYXNrfEYubGF5ZXJzLm1hc2s7Y29uc3QgcmU9WC5wYXJlbnQseWU9Uy5jYW1lcmFzO2llKFMscmUpO2ZvcihsZXQgd2U9MDt3ZTx5ZS5sZW5ndGg7d2UrKylpZSh5ZVt3ZV0scmUpO3llLmxlbmd0aD09PTI/SChTLGIsRik6Uy5wcm9qZWN0aW9uTWF0cml4LmNvcHkoYi5wcm9qZWN0aW9uTWF0cml4KSxjZShYLFMscmUpfTtmdW5jdGlvbiBjZShYLGVlLGdlKXtnZT09PW51bGw/WC5tYXRyaXguY29weShlZS5tYXRyaXhXb3JsZCk6KFgubWF0cml4LmNvcHkoZ2UubWF0cml4V29ybGQpLFgubWF0cml4LmludmVydCgpLFgubWF0cml4Lm11bHRpcGx5KGVlLm1hdHJpeFdvcmxkKSksWC5tYXRyaXguZGVjb21wb3NlKFgucG9zaXRpb24sWC5xdWF0ZXJuaW9uLFguc2NhbGUpLFgudXBkYXRlTWF0cml4V29ybGQoITApLFgucHJvamVjdGlvbk1hdHJpeC5jb3B5KGVlLnByb2plY3Rpb25NYXRyaXgpLFgucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weShlZS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSksWC5pc1BlcnNwZWN0aXZlQ2FtZXJhJiYoWC5mb3Y9Vm4qMipNYXRoLmF0YW4oMS9YLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbNV0pLFguem9vbT0xKX10aGlzLmdldENhbWVyYT1mdW5jdGlvbigpe3JldHVybiBTfSx0aGlzLmdldEZvdmVhdGlvbj1mdW5jdGlvbigpe2lmKCEoZj09PW51bGwmJnA9PT1udWxsKSlyZXR1cm4gbH0sdGhpcy5zZXRGb3ZlYXRpb249ZnVuY3Rpb24oWCl7bD1YLGYhPT1udWxsJiYoZi5maXhlZEZvdmVhdGlvbj1YKSxwIT09bnVsbCYmcC5maXhlZEZvdmVhdGlvbiE9PXZvaWQgMCYmKHAuZml4ZWRGb3ZlYXRpb249WCl9LHRoaXMuaGFzRGVwdGhTZW5zaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHgudGV4dHVyZSE9PW51bGx9LHRoaXMuZ2V0RGVwdGhTZW5zaW5nTWVzaD1mdW5jdGlvbigpe3JldHVybiB4LmdldE1lc2goUyl9O2xldCB4ZT1udWxsO2Z1bmN0aW9uIFVlKFgsZWUpe2lmKGg9ZWUuZ2V0Vmlld2VyUG9zZShjfHxhKSxfPWVlLGghPT1udWxsKXtjb25zdCBnZT1oLnZpZXdzO3AhPT1udWxsJiYoZS5zZXRSZW5kZXJUYXJnZXRGcmFtZWJ1ZmZlcihULHAuZnJhbWVidWZmZXIpLGUuc2V0UmVuZGVyVGFyZ2V0KFQpKTtsZXQgcmU9ITE7Z2UubGVuZ3RoIT09Uy5jYW1lcmFzLmxlbmd0aCYmKFMuY2FtZXJhcy5sZW5ndGg9MCxyZT0hMCk7Zm9yKGxldCB3ZT0wO3dlPGdlLmxlbmd0aDt3ZSsrKXtjb25zdCBGZT1nZVt3ZV07bGV0IG50PW51bGw7aWYocCE9PW51bGwpbnQ9cC5nZXRWaWV3cG9ydChGZSk7ZWxzZXtjb25zdCBhdD1kLmdldFZpZXdTdWJJbWFnZShmLEZlKTtudD1hdC52aWV3cG9ydCx3ZT09PTAmJihlLnNldFJlbmRlclRhcmdldFRleHR1cmVzKFQsYXQuY29sb3JUZXh0dXJlLGYuaWdub3JlRGVwdGhWYWx1ZXM/dm9pZCAwOmF0LmRlcHRoU3RlbmNpbFRleHR1cmUpLGUuc2V0UmVuZGVyVGFyZ2V0KFQpKX1sZXQgemU9RVt3ZV07emU9PT12b2lkIDAmJih6ZT1uZXcgTnQsemUubGF5ZXJzLmVuYWJsZSh3ZSksemUudmlld3BvcnQ9bmV3IHJ0LEVbd2VdPXplKSx6ZS5tYXRyaXguZnJvbUFycmF5KEZlLnRyYW5zZm9ybS5tYXRyaXgpLHplLm1hdHJpeC5kZWNvbXBvc2UoemUucG9zaXRpb24semUucXVhdGVybmlvbix6ZS5zY2FsZSksemUucHJvamVjdGlvbk1hdHJpeC5mcm9tQXJyYXkoRmUucHJvamVjdGlvbk1hdHJpeCksemUucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSh6ZS5wcm9qZWN0aW9uTWF0cml4KS5pbnZlcnQoKSx6ZS52aWV3cG9ydC5zZXQobnQueCxudC55LG50LndpZHRoLG50LmhlaWdodCksd2U9PT0wJiYoUy5tYXRyaXguY29weSh6ZS5tYXRyaXgpLFMubWF0cml4LmRlY29tcG9zZShTLnBvc2l0aW9uLFMucXVhdGVybmlvbixTLnNjYWxlKSkscmU9PT0hMCYmUy5jYW1lcmFzLnB1c2goemUpfWNvbnN0IHllPXIuZW5hYmxlZEZlYXR1cmVzO2lmKHllJiZ5ZS5pbmNsdWRlcygiZGVwdGgtc2Vuc2luZyIpKXtjb25zdCB3ZT1kLmdldERlcHRoSW5mb3JtYXRpb24oZ2VbMF0pO3dlJiZ3ZS5pc1ZhbGlkJiZ3ZS50ZXh0dXJlJiZ4LmluaXQoZSx3ZSxyLnJlbmRlclN0YXRlKX19Zm9yKGxldCBnZT0wO2dlPHkubGVuZ3RoO2dlKyspe2NvbnN0IHJlPWdbZ2VdLHllPXlbZ2VdO3JlIT09bnVsbCYmeWUhPT12b2lkIDAmJnllLnVwZGF0ZShyZSxlZSxjfHxhKX14ZSYmeGUoWCxlZSksZWUuZGV0ZWN0ZWRQbGFuZXMmJm4uZGlzcGF0Y2hFdmVudCh7dHlwZToicGxhbmVzZGV0ZWN0ZWQiLGRhdGE6ZWV9KSxfPW51bGx9Y29uc3QgWWU9bmV3IFFyO1llLnNldEFuaW1hdGlvbkxvb3AoVWUpLHRoaXMuc2V0QW5pbWF0aW9uTG9vcD1mdW5jdGlvbihYKXt4ZT1YfSx0aGlzLmRpc3Bvc2U9ZnVuY3Rpb24oKXt9fX1jb25zdCBfbj1uZXcgWHQsR3U9bmV3IHN0O2Z1bmN0aW9uIEh1KGksZSl7ZnVuY3Rpb24gdChtLHUpe20ubWF0cml4QXV0b1VwZGF0ZT09PSEwJiZtLnVwZGF0ZU1hdHJpeCgpLHUudmFsdWUuY29weShtLm1hdHJpeCl9ZnVuY3Rpb24gbihtLHUpe3UuY29sb3IuZ2V0UkdCKG0uZm9nQ29sb3IudmFsdWUsWXIoaSkpLHUuaXNGb2c/KG0uZm9nTmVhci52YWx1ZT11Lm5lYXIsbS5mb2dGYXIudmFsdWU9dS5mYXIpOnUuaXNGb2dFeHAyJiYobS5mb2dEZW5zaXR5LnZhbHVlPXUuZGVuc2l0eSl9ZnVuY3Rpb24gcihtLHUsVCx5LGcpe3UuaXNNZXNoQmFzaWNNYXRlcmlhbHx8dS5pc01lc2hMYW1iZXJ0TWF0ZXJpYWw/cyhtLHUpOnUuaXNNZXNoVG9vbk1hdGVyaWFsPyhzKG0sdSksZChtLHUpKTp1LmlzTWVzaFBob25nTWF0ZXJpYWw/KHMobSx1KSxoKG0sdSkpOnUuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbD8ocyhtLHUpLGYobSx1KSx1LmlzTWVzaFBoeXNpY2FsTWF0ZXJpYWwmJnAobSx1LGcpKTp1LmlzTWVzaE1hdGNhcE1hdGVyaWFsPyhzKG0sdSksXyhtLHUpKTp1LmlzTWVzaERlcHRoTWF0ZXJpYWw/cyhtLHUpOnUuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbD8ocyhtLHUpLHgobSx1KSk6dS5pc01lc2hOb3JtYWxNYXRlcmlhbD9zKG0sdSk6dS5pc0xpbmVCYXNpY01hdGVyaWFsPyhhKG0sdSksdS5pc0xpbmVEYXNoZWRNYXRlcmlhbCYmbyhtLHUpKTp1LmlzUG9pbnRzTWF0ZXJpYWw/bChtLHUsVCx5KTp1LmlzU3ByaXRlTWF0ZXJpYWw/YyhtLHUpOnUuaXNTaGFkb3dNYXRlcmlhbD8obS5jb2xvci52YWx1ZS5jb3B5KHUuY29sb3IpLG0ub3BhY2l0eS52YWx1ZT11Lm9wYWNpdHkpOnUuaXNTaGFkZXJNYXRlcmlhbCYmKHUudW5pZm9ybXNOZWVkVXBkYXRlPSExKX1mdW5jdGlvbiBzKG0sdSl7bS5vcGFjaXR5LnZhbHVlPXUub3BhY2l0eSx1LmNvbG9yJiZtLmRpZmZ1c2UudmFsdWUuY29weSh1LmNvbG9yKSx1LmVtaXNzaXZlJiZtLmVtaXNzaXZlLnZhbHVlLmNvcHkodS5lbWlzc2l2ZSkubXVsdGlwbHlTY2FsYXIodS5lbWlzc2l2ZUludGVuc2l0eSksdS5tYXAmJihtLm1hcC52YWx1ZT11Lm1hcCx0KHUubWFwLG0ubWFwVHJhbnNmb3JtKSksdS5hbHBoYU1hcCYmKG0uYWxwaGFNYXAudmFsdWU9dS5hbHBoYU1hcCx0KHUuYWxwaGFNYXAsbS5hbHBoYU1hcFRyYW5zZm9ybSkpLHUuYnVtcE1hcCYmKG0uYnVtcE1hcC52YWx1ZT11LmJ1bXBNYXAsdCh1LmJ1bXBNYXAsbS5idW1wTWFwVHJhbnNmb3JtKSxtLmJ1bXBTY2FsZS52YWx1ZT11LmJ1bXBTY2FsZSx1LnNpZGU9PT0xJiYobS5idW1wU2NhbGUudmFsdWUqPS0xKSksdS5ub3JtYWxNYXAmJihtLm5vcm1hbE1hcC52YWx1ZT11Lm5vcm1hbE1hcCx0KHUubm9ybWFsTWFwLG0ubm9ybWFsTWFwVHJhbnNmb3JtKSxtLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkodS5ub3JtYWxTY2FsZSksdS5zaWRlPT09MSYmbS5ub3JtYWxTY2FsZS52YWx1ZS5uZWdhdGUoKSksdS5kaXNwbGFjZW1lbnRNYXAmJihtLmRpc3BsYWNlbWVudE1hcC52YWx1ZT11LmRpc3BsYWNlbWVudE1hcCx0KHUuZGlzcGxhY2VtZW50TWFwLG0uZGlzcGxhY2VtZW50TWFwVHJhbnNmb3JtKSxtLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlPXUuZGlzcGxhY2VtZW50U2NhbGUsbS5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlPXUuZGlzcGxhY2VtZW50QmlhcyksdS5lbWlzc2l2ZU1hcCYmKG0uZW1pc3NpdmVNYXAudmFsdWU9dS5lbWlzc2l2ZU1hcCx0KHUuZW1pc3NpdmVNYXAsbS5lbWlzc2l2ZU1hcFRyYW5zZm9ybSkpLHUuc3BlY3VsYXJNYXAmJihtLnNwZWN1bGFyTWFwLnZhbHVlPXUuc3BlY3VsYXJNYXAsdCh1LnNwZWN1bGFyTWFwLG0uc3BlY3VsYXJNYXBUcmFuc2Zvcm0pKSx1LmFscGhhVGVzdD4wJiYobS5hbHBoYVRlc3QudmFsdWU9dS5hbHBoYVRlc3QpO2NvbnN0IFQ9ZS5nZXQodSkseT1ULmVudk1hcCxnPVQuZW52TWFwUm90YXRpb247eSYmKG0uZW52TWFwLnZhbHVlPXksX24uY29weShnKSxfbi54Kj0tMSxfbi55Kj0tMSxfbi56Kj0tMSx5LmlzQ3ViZVRleHR1cmUmJnkuaXNSZW5kZXJUYXJnZXRUZXh0dXJlPT09ITEmJihfbi55Kj0tMSxfbi56Kj0tMSksbS5lbnZNYXBSb3RhdGlvbi52YWx1ZS5zZXRGcm9tTWF0cml4NChHdS5tYWtlUm90YXRpb25Gcm9tRXVsZXIoX24pKSxtLmZsaXBFbnZNYXAudmFsdWU9eS5pc0N1YmVUZXh0dXJlJiZ5LmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT09PSExPy0xOjEsbS5yZWZsZWN0aXZpdHkudmFsdWU9dS5yZWZsZWN0aXZpdHksbS5pb3IudmFsdWU9dS5pb3IsbS5yZWZyYWN0aW9uUmF0aW8udmFsdWU9dS5yZWZyYWN0aW9uUmF0aW8pLHUubGlnaHRNYXAmJihtLmxpZ2h0TWFwLnZhbHVlPXUubGlnaHRNYXAsbS5saWdodE1hcEludGVuc2l0eS52YWx1ZT11LmxpZ2h0TWFwSW50ZW5zaXR5LHQodS5saWdodE1hcCxtLmxpZ2h0TWFwVHJhbnNmb3JtKSksdS5hb01hcCYmKG0uYW9NYXAudmFsdWU9dS5hb01hcCxtLmFvTWFwSW50ZW5zaXR5LnZhbHVlPXUuYW9NYXBJbnRlbnNpdHksdCh1LmFvTWFwLG0uYW9NYXBUcmFuc2Zvcm0pKX1mdW5jdGlvbiBhKG0sdSl7bS5kaWZmdXNlLnZhbHVlLmNvcHkodS5jb2xvciksbS5vcGFjaXR5LnZhbHVlPXUub3BhY2l0eSx1Lm1hcCYmKG0ubWFwLnZhbHVlPXUubWFwLHQodS5tYXAsbS5tYXBUcmFuc2Zvcm0pKX1mdW5jdGlvbiBvKG0sdSl7bS5kYXNoU2l6ZS52YWx1ZT11LmRhc2hTaXplLG0udG90YWxTaXplLnZhbHVlPXUuZGFzaFNpemUrdS5nYXBTaXplLG0uc2NhbGUudmFsdWU9dS5zY2FsZX1mdW5jdGlvbiBsKG0sdSxULHkpe20uZGlmZnVzZS52YWx1ZS5jb3B5KHUuY29sb3IpLG0ub3BhY2l0eS52YWx1ZT11Lm9wYWNpdHksbS5zaXplLnZhbHVlPXUuc2l6ZSpULG0uc2NhbGUudmFsdWU9eSouNSx1Lm1hcCYmKG0ubWFwLnZhbHVlPXUubWFwLHQodS5tYXAsbS51dlRyYW5zZm9ybSkpLHUuYWxwaGFNYXAmJihtLmFscGhhTWFwLnZhbHVlPXUuYWxwaGFNYXAsdCh1LmFscGhhTWFwLG0uYWxwaGFNYXBUcmFuc2Zvcm0pKSx1LmFscGhhVGVzdD4wJiYobS5hbHBoYVRlc3QudmFsdWU9dS5hbHBoYVRlc3QpfWZ1bmN0aW9uIGMobSx1KXttLmRpZmZ1c2UudmFsdWUuY29weSh1LmNvbG9yKSxtLm9wYWNpdHkudmFsdWU9dS5vcGFjaXR5LG0ucm90YXRpb24udmFsdWU9dS5yb3RhdGlvbix1Lm1hcCYmKG0ubWFwLnZhbHVlPXUubWFwLHQodS5tYXAsbS5tYXBUcmFuc2Zvcm0pKSx1LmFscGhhTWFwJiYobS5hbHBoYU1hcC52YWx1ZT11LmFscGhhTWFwLHQodS5hbHBoYU1hcCxtLmFscGhhTWFwVHJhbnNmb3JtKSksdS5hbHBoYVRlc3Q+MCYmKG0uYWxwaGFUZXN0LnZhbHVlPXUuYWxwaGFUZXN0KX1mdW5jdGlvbiBoKG0sdSl7bS5zcGVjdWxhci52YWx1ZS5jb3B5KHUuc3BlY3VsYXIpLG0uc2hpbmluZXNzLnZhbHVlPU1hdGgubWF4KHUuc2hpbmluZXNzLDFlLTQpfWZ1bmN0aW9uIGQobSx1KXt1LmdyYWRpZW50TWFwJiYobS5ncmFkaWVudE1hcC52YWx1ZT11LmdyYWRpZW50TWFwKX1mdW5jdGlvbiBmKG0sdSl7bS5tZXRhbG5lc3MudmFsdWU9dS5tZXRhbG5lc3MsdS5tZXRhbG5lc3NNYXAmJihtLm1ldGFsbmVzc01hcC52YWx1ZT11Lm1ldGFsbmVzc01hcCx0KHUubWV0YWxuZXNzTWFwLG0ubWV0YWxuZXNzTWFwVHJhbnNmb3JtKSksbS5yb3VnaG5lc3MudmFsdWU9dS5yb3VnaG5lc3MsdS5yb3VnaG5lc3NNYXAmJihtLnJvdWdobmVzc01hcC52YWx1ZT11LnJvdWdobmVzc01hcCx0KHUucm91Z2huZXNzTWFwLG0ucm91Z2huZXNzTWFwVHJhbnNmb3JtKSksdS5lbnZNYXAmJihtLmVudk1hcEludGVuc2l0eS52YWx1ZT11LmVudk1hcEludGVuc2l0eSl9ZnVuY3Rpb24gcChtLHUsVCl7bS5pb3IudmFsdWU9dS5pb3IsdS5zaGVlbj4wJiYobS5zaGVlbkNvbG9yLnZhbHVlLmNvcHkodS5zaGVlbkNvbG9yKS5tdWx0aXBseVNjYWxhcih1LnNoZWVuKSxtLnNoZWVuUm91Z2huZXNzLnZhbHVlPXUuc2hlZW5Sb3VnaG5lc3MsdS5zaGVlbkNvbG9yTWFwJiYobS5zaGVlbkNvbG9yTWFwLnZhbHVlPXUuc2hlZW5Db2xvck1hcCx0KHUuc2hlZW5Db2xvck1hcCxtLnNoZWVuQ29sb3JNYXBUcmFuc2Zvcm0pKSx1LnNoZWVuUm91Z2huZXNzTWFwJiYobS5zaGVlblJvdWdobmVzc01hcC52YWx1ZT11LnNoZWVuUm91Z2huZXNzTWFwLHQodS5zaGVlblJvdWdobmVzc01hcCxtLnNoZWVuUm91Z2huZXNzTWFwVHJhbnNmb3JtKSkpLHUuY2xlYXJjb2F0PjAmJihtLmNsZWFyY29hdC52YWx1ZT11LmNsZWFyY29hdCxtLmNsZWFyY29hdFJvdWdobmVzcy52YWx1ZT11LmNsZWFyY29hdFJvdWdobmVzcyx1LmNsZWFyY29hdE1hcCYmKG0uY2xlYXJjb2F0TWFwLnZhbHVlPXUuY2xlYXJjb2F0TWFwLHQodS5jbGVhcmNvYXRNYXAsbS5jbGVhcmNvYXRNYXBUcmFuc2Zvcm0pKSx1LmNsZWFyY29hdFJvdWdobmVzc01hcCYmKG0uY2xlYXJjb2F0Um91Z2huZXNzTWFwLnZhbHVlPXUuY2xlYXJjb2F0Um91Z2huZXNzTWFwLHQodS5jbGVhcmNvYXRSb3VnaG5lc3NNYXAsbS5jbGVhcmNvYXRSb3VnaG5lc3NNYXBUcmFuc2Zvcm0pKSx1LmNsZWFyY29hdE5vcm1hbE1hcCYmKG0uY2xlYXJjb2F0Tm9ybWFsTWFwLnZhbHVlPXUuY2xlYXJjb2F0Tm9ybWFsTWFwLHQodS5jbGVhcmNvYXROb3JtYWxNYXAsbS5jbGVhcmNvYXROb3JtYWxNYXBUcmFuc2Zvcm0pLG0uY2xlYXJjb2F0Tm9ybWFsU2NhbGUudmFsdWUuY29weSh1LmNsZWFyY29hdE5vcm1hbFNjYWxlKSx1LnNpZGU9PT0xJiZtLmNsZWFyY29hdE5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpKSksdS5kaXNwZXJzaW9uPjAmJihtLmRpc3BlcnNpb24udmFsdWU9dS5kaXNwZXJzaW9uKSx1LmlyaWRlc2NlbmNlPjAmJihtLmlyaWRlc2NlbmNlLnZhbHVlPXUuaXJpZGVzY2VuY2UsbS5pcmlkZXNjZW5jZUlPUi52YWx1ZT11LmlyaWRlc2NlbmNlSU9SLG0uaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtLnZhbHVlPXUuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZVswXSxtLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bS52YWx1ZT11LmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbMV0sdS5pcmlkZXNjZW5jZU1hcCYmKG0uaXJpZGVzY2VuY2VNYXAudmFsdWU9dS5pcmlkZXNjZW5jZU1hcCx0KHUuaXJpZGVzY2VuY2VNYXAsbS5pcmlkZXNjZW5jZU1hcFRyYW5zZm9ybSkpLHUuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAmJihtLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLnZhbHVlPXUuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAsdCh1LmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLG0uaXJpZGVzY2VuY2VUaGlja25lc3NNYXBUcmFuc2Zvcm0pKSksdS50cmFuc21pc3Npb24+MCYmKG0udHJhbnNtaXNzaW9uLnZhbHVlPXUudHJhbnNtaXNzaW9uLG0udHJhbnNtaXNzaW9uU2FtcGxlck1hcC52YWx1ZT1ULnRleHR1cmUsbS50cmFuc21pc3Npb25TYW1wbGVyU2l6ZS52YWx1ZS5zZXQoVC53aWR0aCxULmhlaWdodCksdS50cmFuc21pc3Npb25NYXAmJihtLnRyYW5zbWlzc2lvbk1hcC52YWx1ZT11LnRyYW5zbWlzc2lvbk1hcCx0KHUudHJhbnNtaXNzaW9uTWFwLG0udHJhbnNtaXNzaW9uTWFwVHJhbnNmb3JtKSksbS50aGlja25lc3MudmFsdWU9dS50aGlja25lc3MsdS50aGlja25lc3NNYXAmJihtLnRoaWNrbmVzc01hcC52YWx1ZT11LnRoaWNrbmVzc01hcCx0KHUudGhpY2tuZXNzTWFwLG0udGhpY2tuZXNzTWFwVHJhbnNmb3JtKSksbS5hdHRlbnVhdGlvbkRpc3RhbmNlLnZhbHVlPXUuYXR0ZW51YXRpb25EaXN0YW5jZSxtLmF0dGVudWF0aW9uQ29sb3IudmFsdWUuY29weSh1LmF0dGVudWF0aW9uQ29sb3IpKSx1LmFuaXNvdHJvcHk+MCYmKG0uYW5pc290cm9weVZlY3Rvci52YWx1ZS5zZXQodS5hbmlzb3Ryb3B5Kk1hdGguY29zKHUuYW5pc290cm9weVJvdGF0aW9uKSx1LmFuaXNvdHJvcHkqTWF0aC5zaW4odS5hbmlzb3Ryb3B5Um90YXRpb24pKSx1LmFuaXNvdHJvcHlNYXAmJihtLmFuaXNvdHJvcHlNYXAudmFsdWU9dS5hbmlzb3Ryb3B5TWFwLHQodS5hbmlzb3Ryb3B5TWFwLG0uYW5pc290cm9weU1hcFRyYW5zZm9ybSkpKSxtLnNwZWN1bGFySW50ZW5zaXR5LnZhbHVlPXUuc3BlY3VsYXJJbnRlbnNpdHksbS5zcGVjdWxhckNvbG9yLnZhbHVlLmNvcHkodS5zcGVjdWxhckNvbG9yKSx1LnNwZWN1bGFyQ29sb3JNYXAmJihtLnNwZWN1bGFyQ29sb3JNYXAudmFsdWU9dS5zcGVjdWxhckNvbG9yTWFwLHQodS5zcGVjdWxhckNvbG9yTWFwLG0uc3BlY3VsYXJDb2xvck1hcFRyYW5zZm9ybSkpLHUuc3BlY3VsYXJJbnRlbnNpdHlNYXAmJihtLnNwZWN1bGFySW50ZW5zaXR5TWFwLnZhbHVlPXUuc3BlY3VsYXJJbnRlbnNpdHlNYXAsdCh1LnNwZWN1bGFySW50ZW5zaXR5TWFwLG0uc3BlY3VsYXJJbnRlbnNpdHlNYXBUcmFuc2Zvcm0pKX1mdW5jdGlvbiBfKG0sdSl7dS5tYXRjYXAmJihtLm1hdGNhcC52YWx1ZT11Lm1hdGNhcCl9ZnVuY3Rpb24geChtLHUpe2NvbnN0IFQ9ZS5nZXQodSkubGlnaHQ7bS5yZWZlcmVuY2VQb3NpdGlvbi52YWx1ZS5zZXRGcm9tTWF0cml4UG9zaXRpb24oVC5tYXRyaXhXb3JsZCksbS5uZWFyRGlzdGFuY2UudmFsdWU9VC5zaGFkb3cuY2FtZXJhLm5lYXIsbS5mYXJEaXN0YW5jZS52YWx1ZT1ULnNoYWRvdy5jYW1lcmEuZmFyfXJldHVybntyZWZyZXNoRm9nVW5pZm9ybXM6bixyZWZyZXNoTWF0ZXJpYWxVbmlmb3JtczpyfX1mdW5jdGlvbiBWdShpLGUsdCxuKXtsZXQgcj17fSxzPXt9LGE9W107Y29uc3Qgbz1pLmdldFBhcmFtZXRlcihpLk1BWF9VTklGT1JNX0JVRkZFUl9CSU5ESU5HUyk7ZnVuY3Rpb24gbChULHkpe2NvbnN0IGc9eS5wcm9ncmFtO24udW5pZm9ybUJsb2NrQmluZGluZyhULGcpfWZ1bmN0aW9uIGMoVCx5KXtsZXQgZz1yW1QuaWRdO2c9PT12b2lkIDAmJihfKFQpLGc9aChUKSxyW1QuaWRdPWcsVC5hZGRFdmVudExpc3RlbmVyKCJkaXNwb3NlIixtKSk7Y29uc3QgUD15LnByb2dyYW07bi51cGRhdGVVQk9NYXBwaW5nKFQsUCk7Y29uc3Qgdz1lLnJlbmRlci5mcmFtZTtzW1QuaWRdIT09dyYmKGYoVCksc1tULmlkXT13KX1mdW5jdGlvbiBoKFQpe2NvbnN0IHk9ZCgpO1QuX19iaW5kaW5nUG9pbnRJbmRleD15O2NvbnN0IGc9aS5jcmVhdGVCdWZmZXIoKSxQPVQuX19zaXplLHc9VC51c2FnZTtyZXR1cm4gaS5iaW5kQnVmZmVyKGkuVU5JRk9STV9CVUZGRVIsZyksaS5idWZmZXJEYXRhKGkuVU5JRk9STV9CVUZGRVIsUCx3KSxpLmJpbmRCdWZmZXIoaS5VTklGT1JNX0JVRkZFUixudWxsKSxpLmJpbmRCdWZmZXJCYXNlKGkuVU5JRk9STV9CVUZGRVIseSxnKSxnfWZ1bmN0aW9uIGQoKXtmb3IobGV0IFQ9MDtUPG87VCsrKWlmKGEuaW5kZXhPZihUKT09PS0xKXJldHVybiBhLnB1c2goVCksVDtyZXR1cm4gY29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xSZW5kZXJlcjogTWF4aW11bSBudW1iZXIgb2Ygc2ltdWx0YW5lb3VzbHkgdXNhYmxlIHVuaWZvcm1zIGdyb3VwcyByZWFjaGVkLiIpLDB9ZnVuY3Rpb24gZihUKXtjb25zdCB5PXJbVC5pZF0sZz1ULnVuaWZvcm1zLFA9VC5fX2NhY2hlO2kuYmluZEJ1ZmZlcihpLlVOSUZPUk1fQlVGRkVSLHkpO2ZvcihsZXQgdz0wLGI9Zy5sZW5ndGg7dzxiO3crKyl7Y29uc3QgRj1BcnJheS5pc0FycmF5KGdbd10pP2dbd106W2dbd11dO2ZvcihsZXQgRT0wLFM9Ri5sZW5ndGg7RTxTO0UrKyl7Y29uc3QgUj1GW0VdO2lmKHAoUix3LEUsUCk9PT0hMCl7Y29uc3QgcT1SLl9fb2Zmc2V0LHo9QXJyYXkuaXNBcnJheShSLnZhbHVlKT9SLnZhbHVlOltSLnZhbHVlXTtsZXQgVz0wO2ZvcihsZXQgWj0wO1o8ei5sZW5ndGg7WisrKXtjb25zdCBWPXpbWl0sUT14KFYpO3R5cGVvZiBWPT0ibnVtYmVyInx8dHlwZW9mIFY9PSJib29sZWFuIj8oUi5fX2RhdGFbMF09VixpLmJ1ZmZlclN1YkRhdGEoaS5VTklGT1JNX0JVRkZFUixxK1csUi5fX2RhdGEpKTpWLmlzTWF0cml4Mz8oUi5fX2RhdGFbMF09Vi5lbGVtZW50c1swXSxSLl9fZGF0YVsxXT1WLmVsZW1lbnRzWzFdLFIuX19kYXRhWzJdPVYuZWxlbWVudHNbMl0sUi5fX2RhdGFbM109MCxSLl9fZGF0YVs0XT1WLmVsZW1lbnRzWzNdLFIuX19kYXRhWzVdPVYuZWxlbWVudHNbNF0sUi5fX2RhdGFbNl09Vi5lbGVtZW50c1s1XSxSLl9fZGF0YVs3XT0wLFIuX19kYXRhWzhdPVYuZWxlbWVudHNbNl0sUi5fX2RhdGFbOV09Vi5lbGVtZW50c1s3XSxSLl9fZGF0YVsxMF09Vi5lbGVtZW50c1s4XSxSLl9fZGF0YVsxMV09MCk6KFYudG9BcnJheShSLl9fZGF0YSxXKSxXKz1RLnN0b3JhZ2UvRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKX1pLmJ1ZmZlclN1YkRhdGEoaS5VTklGT1JNX0JVRkZFUixxLFIuX19kYXRhKX19fWkuYmluZEJ1ZmZlcihpLlVOSUZPUk1fQlVGRkVSLG51bGwpfWZ1bmN0aW9uIHAoVCx5LGcsUCl7Y29uc3Qgdz1ULnZhbHVlLGI9eSsiXyIrZztpZihQW2JdPT09dm9pZCAwKXJldHVybiB0eXBlb2Ygdz09Im51bWJlciJ8fHR5cGVvZiB3PT0iYm9vbGVhbiI/UFtiXT13OlBbYl09dy5jbG9uZSgpLCEwO3tjb25zdCBGPVBbYl07aWYodHlwZW9mIHc9PSJudW1iZXIifHx0eXBlb2Ygdz09ImJvb2xlYW4iKXtpZihGIT09dylyZXR1cm4gUFtiXT13LCEwfWVsc2UgaWYoRi5lcXVhbHModyk9PT0hMSlyZXR1cm4gRi5jb3B5KHcpLCEwfXJldHVybiExfWZ1bmN0aW9uIF8oVCl7Y29uc3QgeT1ULnVuaWZvcm1zO2xldCBnPTA7Y29uc3QgUD0xNjtmb3IobGV0IGI9MCxGPXkubGVuZ3RoO2I8RjtiKyspe2NvbnN0IEU9QXJyYXkuaXNBcnJheSh5W2JdKT95W2JdOlt5W2JdXTtmb3IobGV0IFM9MCxSPUUubGVuZ3RoO1M8UjtTKyspe2NvbnN0IHE9RVtTXSx6PUFycmF5LmlzQXJyYXkocS52YWx1ZSk/cS52YWx1ZTpbcS52YWx1ZV07Zm9yKGxldCBXPTAsWj16Lmxlbmd0aDtXPFo7VysrKXtjb25zdCBWPXpbV10sUT14KFYpLEg9ZyVQLGllPUglUS5ib3VuZGFyeSxjZT1IK2llO2crPWllLGNlIT09MCYmUC1jZTxRLnN0b3JhZ2UmJihnKz1QLWNlKSxxLl9fZGF0YT1uZXcgRmxvYXQzMkFycmF5KFEuc3RvcmFnZS9GbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpLHEuX19vZmZzZXQ9ZyxnKz1RLnN0b3JhZ2V9fX1jb25zdCB3PWclUDtyZXR1cm4gdz4wJiYoZys9UC13KSxULl9fc2l6ZT1nLFQuX19jYWNoZT17fSx0aGlzfWZ1bmN0aW9uIHgoVCl7Y29uc3QgeT17Ym91bmRhcnk6MCxzdG9yYWdlOjB9O3JldHVybiB0eXBlb2YgVD09Im51bWJlciJ8fHR5cGVvZiBUPT0iYm9vbGVhbiI/KHkuYm91bmRhcnk9NCx5LnN0b3JhZ2U9NCk6VC5pc1ZlY3RvcjI/KHkuYm91bmRhcnk9OCx5LnN0b3JhZ2U9OCk6VC5pc1ZlY3RvcjN8fFQuaXNDb2xvcj8oeS5ib3VuZGFyeT0xNix5LnN0b3JhZ2U9MTIpOlQuaXNWZWN0b3I0Pyh5LmJvdW5kYXJ5PTE2LHkuc3RvcmFnZT0xNik6VC5pc01hdHJpeDM/KHkuYm91bmRhcnk9NDgseS5zdG9yYWdlPTQ4KTpULmlzTWF0cml4ND8oeS5ib3VuZGFyeT02NCx5LnN0b3JhZ2U9NjQpOlQuaXNUZXh0dXJlP2NvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBzYW1wbGVycyBjYW4gbm90IGJlIHBhcnQgb2YgYW4gdW5pZm9ybXMgZ3JvdXAuIik6Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBVbnN1cHBvcnRlZCB1bmlmb3JtIHZhbHVlIHR5cGUuIixUKSx5fWZ1bmN0aW9uIG0oVCl7Y29uc3QgeT1ULnRhcmdldDt5LnJlbW92ZUV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLG0pO2NvbnN0IGc9YS5pbmRleE9mKHkuX19iaW5kaW5nUG9pbnRJbmRleCk7YS5zcGxpY2UoZywxKSxpLmRlbGV0ZUJ1ZmZlcihyW3kuaWRdKSxkZWxldGUgclt5LmlkXSxkZWxldGUgc1t5LmlkXX1mdW5jdGlvbiB1KCl7Zm9yKGNvbnN0IFQgaW4gcilpLmRlbGV0ZUJ1ZmZlcihyW1RdKTthPVtdLHI9e30scz17fX1yZXR1cm57YmluZDpsLHVwZGF0ZTpjLGRpc3Bvc2U6dX19Y2xhc3Mga3V7Y29uc3RydWN0b3IoZT17fSl7Y29uc3R7Y2FudmFzOnQ9dWEoKSxjb250ZXh0Om49bnVsbCxkZXB0aDpyPSEwLHN0ZW5jaWw6cz0hMSxhbHBoYTphPSExLGFudGlhbGlhczpvPSExLHByZW11bHRpcGxpZWRBbHBoYTpsPSEwLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjpjPSExLHBvd2VyUHJlZmVyZW5jZTpoPSJkZWZhdWx0IixmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OmQ9ITEscmV2ZXJzZURlcHRoQnVmZmVyOmY9ITF9PWU7dGhpcy5pc1dlYkdMUmVuZGVyZXI9ITA7bGV0IHA7aWYobiE9PW51bGwpe2lmKHR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ8InUiJiZuIGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0KXRocm93IG5ldyBFcnJvcigiVEhSRUUuV2ViR0xSZW5kZXJlcjogV2ViR0wgMSBpcyBub3Qgc3VwcG9ydGVkIHNpbmNlIHIxNjMuIik7cD1uLmdldENvbnRleHRBdHRyaWJ1dGVzKCkuYWxwaGF9ZWxzZSBwPWE7Y29uc3QgXz1uZXcgVWludDMyQXJyYXkoNCkseD1uZXcgSW50MzJBcnJheSg0KTtsZXQgbT1udWxsLHU9bnVsbDtjb25zdCBUPVtdLHk9W107dGhpcy5kb21FbGVtZW50PXQsdGhpcy5kZWJ1Zz17Y2hlY2tTaGFkZXJFcnJvcnM6ITAsb25TaGFkZXJFcnJvcjpudWxsfSx0aGlzLmF1dG9DbGVhcj0hMCx0aGlzLmF1dG9DbGVhckNvbG9yPSEwLHRoaXMuYXV0b0NsZWFyRGVwdGg9ITAsdGhpcy5hdXRvQ2xlYXJTdGVuY2lsPSEwLHRoaXMuc29ydE9iamVjdHM9ITAsdGhpcy5jbGlwcGluZ1BsYW5lcz1bXSx0aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkPSExLHRoaXMuX291dHB1dENvbG9yU3BhY2U9YnQsdGhpcy50b25lTWFwcGluZz0wLHRoaXMudG9uZU1hcHBpbmdFeHBvc3VyZT0xO2NvbnN0IGc9dGhpcztsZXQgUD0hMSx3PTAsYj0wLEY9bnVsbCxFPS0xLFM9bnVsbDtjb25zdCBSPW5ldyBydCxxPW5ldyBydDtsZXQgej1udWxsO2NvbnN0IFc9bmV3IFZlKDApO2xldCBaPTAsVj10LndpZHRoLFE9dC5oZWlnaHQsSD0xLGllPW51bGwsY2U9bnVsbDtjb25zdCB4ZT1uZXcgcnQoMCwwLFYsUSksVWU9bmV3IHJ0KDAsMCxWLFEpO2xldCBZZT0hMTtjb25zdCBYPW5ldyBKcjtsZXQgZWU9ITEsZ2U9ITE7Y29uc3QgcmU9bmV3IHN0LHllPW5ldyBzdCx3ZT1uZXcgTyxGZT1uZXcgcnQsbnQ9e2JhY2tncm91bmQ6bnVsbCxmb2c6bnVsbCxlbnZpcm9ubWVudDpudWxsLG92ZXJyaWRlTWF0ZXJpYWw6bnVsbCxpc1NjZW5lOiEwfTtsZXQgemU9ITE7ZnVuY3Rpb24gYXQoKXtyZXR1cm4gRj09PW51bGw/SDoxfWxldCBVPW47ZnVuY3Rpb24gUHQoTSxEKXtyZXR1cm4gdC5nZXRDb250ZXh0KE0sRCl9dHJ5e2NvbnN0IE09e2FscGhhOiEwLGRlcHRoOnIsc3RlbmNpbDpzLGFudGlhbGlhczpvLHByZW11bHRpcGxpZWRBbHBoYTpsLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjpjLHBvd2VyUHJlZmVyZW5jZTpoLGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6ZH07aWYoInNldEF0dHJpYnV0ZSJpbiB0JiZ0LnNldEF0dHJpYnV0ZSgiZGF0YS1lbmdpbmUiLGB0aHJlZS5qcyByJHtOaX1gKSx0LmFkZEV2ZW50TGlzdGVuZXIoIndlYmdsY29udGV4dGxvc3QiLCQsITEpLHQuYWRkRXZlbnRMaXN0ZW5lcigid2ViZ2xjb250ZXh0cmVzdG9yZWQiLGxlLCExKSx0LmFkZEV2ZW50TGlzdGVuZXIoIndlYmdsY29udGV4dGNyZWF0aW9uZXJyb3IiLGFlLCExKSxVPT09bnVsbCl7Y29uc3QgRD0id2ViZ2wyIjtpZihVPVB0KEQsTSksVT09PW51bGwpdGhyb3cgUHQoRCk/bmV3IEVycm9yKCJFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLiIpOm5ldyBFcnJvcigiRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4iKX19Y2F0Y2goTSl7dGhyb3cgY29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xSZW5kZXJlcjogIitNLm1lc3NhZ2UpLE19bGV0IEllLE5lLFNlLGplLE1lLEEsdixJLFksSyxrLF9lLHNlLHVlLEdlLGosaGUsRWUsVGUsZGUsT2UsTGUsS2UsQztmdW5jdGlvbiBuZSgpe0llPW5ldyAkbChVKSxJZS5pbml0KCksTGU9bmV3IFV1KFUsSWUpLE5lPW5ldyBWbChVLEllLGUsTGUpLFNlPW5ldyBQdShVLEllKSxOZS5yZXZlcnNlRGVwdGhCdWZmZXImJmYmJlNlLmJ1ZmZlcnMuZGVwdGguc2V0UmV2ZXJzZWQoITApLGplPW5ldyBqbChVKSxNZT1uZXcgbXUsQT1uZXcgTHUoVSxJZSxTZSxNZSxOZSxMZSxqZSksdj1uZXcgV2woZyksST1uZXcgWWwoZyksWT1uZXcgT2EoVSksS2U9bmV3IEdsKFUsWSksSz1uZXcgS2woVSxZLGplLEtlKSxrPW5ldyBRbChVLEssWSxqZSksVGU9bmV3IEpsKFUsTmUsQSksaj1uZXcga2woTWUpLF9lPW5ldyBwdShnLHYsSSxJZSxOZSxLZSxqKSxzZT1uZXcgSHUoZyxNZSksdWU9bmV3IF91LEdlPW5ldyB5dShJZSksRWU9bmV3IHpsKGcsdixJLFNlLGsscCxsKSxoZT1uZXcgUnUoZyxrLE5lKSxDPW5ldyBWdShVLGplLE5lLFNlKSxkZT1uZXcgSGwoVSxJZSxqZSksT2U9bmV3IFpsKFUsSWUsamUpLGplLnByb2dyYW1zPV9lLnByb2dyYW1zLGcuY2FwYWJpbGl0aWVzPU5lLGcuZXh0ZW5zaW9ucz1JZSxnLnByb3BlcnRpZXM9TWUsZy5yZW5kZXJMaXN0cz11ZSxnLnNoYWRvd01hcD1oZSxnLnN0YXRlPVNlLGcuaW5mbz1qZX1uZSgpO2NvbnN0IEc9bmV3IHp1KGcsVSk7dGhpcy54cj1HLHRoaXMuZ2V0Q29udGV4dD1mdW5jdGlvbigpe3JldHVybiBVfSx0aGlzLmdldENvbnRleHRBdHRyaWJ1dGVzPWZ1bmN0aW9uKCl7cmV0dXJuIFUuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKX0sdGhpcy5mb3JjZUNvbnRleHRMb3NzPWZ1bmN0aW9uKCl7Y29uc3QgTT1JZS5nZXQoIldFQkdMX2xvc2VfY29udGV4dCIpO00mJk0ubG9zZUNvbnRleHQoKX0sdGhpcy5mb3JjZUNvbnRleHRSZXN0b3JlPWZ1bmN0aW9uKCl7Y29uc3QgTT1JZS5nZXQoIldFQkdMX2xvc2VfY29udGV4dCIpO00mJk0ucmVzdG9yZUNvbnRleHQoKX0sdGhpcy5nZXRQaXhlbFJhdGlvPWZ1bmN0aW9uKCl7cmV0dXJuIEh9LHRoaXMuc2V0UGl4ZWxSYXRpbz1mdW5jdGlvbihNKXtNIT09dm9pZCAwJiYoSD1NLHRoaXMuc2V0U2l6ZShWLFEsITEpKX0sdGhpcy5nZXRTaXplPWZ1bmN0aW9uKE0pe3JldHVybiBNLnNldChWLFEpfSx0aGlzLnNldFNpemU9ZnVuY3Rpb24oTSxELE49ITApe2lmKEcuaXNQcmVzZW50aW5nKXtjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IENhbid0IGNoYW5nZSBzaXplIHdoaWxlIFZSIGRldmljZSBpcyBwcmVzZW50aW5nLiIpO3JldHVybn1WPU0sUT1ELHQud2lkdGg9TWF0aC5mbG9vcihNKkgpLHQuaGVpZ2h0PU1hdGguZmxvb3IoRCpIKSxOPT09ITAmJih0LnN0eWxlLndpZHRoPU0rInB4Iix0LnN0eWxlLmhlaWdodD1EKyJweCIpLHRoaXMuc2V0Vmlld3BvcnQoMCwwLE0sRCl9LHRoaXMuZ2V0RHJhd2luZ0J1ZmZlclNpemU9ZnVuY3Rpb24oTSl7cmV0dXJuIE0uc2V0KFYqSCxRKkgpLmZsb29yKCl9LHRoaXMuc2V0RHJhd2luZ0J1ZmZlclNpemU9ZnVuY3Rpb24oTSxELE4pe1Y9TSxRPUQsSD1OLHQud2lkdGg9TWF0aC5mbG9vcihNKk4pLHQuaGVpZ2h0PU1hdGguZmxvb3IoRCpOKSx0aGlzLnNldFZpZXdwb3J0KDAsMCxNLEQpfSx0aGlzLmdldEN1cnJlbnRWaWV3cG9ydD1mdW5jdGlvbihNKXtyZXR1cm4gTS5jb3B5KFIpfSx0aGlzLmdldFZpZXdwb3J0PWZ1bmN0aW9uKE0pe3JldHVybiBNLmNvcHkoeGUpfSx0aGlzLnNldFZpZXdwb3J0PWZ1bmN0aW9uKE0sRCxOLEIpe00uaXNWZWN0b3I0P3hlLnNldChNLngsTS55LE0ueixNLncpOnhlLnNldChNLEQsTixCKSxTZS52aWV3cG9ydChSLmNvcHkoeGUpLm11bHRpcGx5U2NhbGFyKEgpLnJvdW5kKCkpfSx0aGlzLmdldFNjaXNzb3I9ZnVuY3Rpb24oTSl7cmV0dXJuIE0uY29weShVZSl9LHRoaXMuc2V0U2Npc3Nvcj1mdW5jdGlvbihNLEQsTixCKXtNLmlzVmVjdG9yND9VZS5zZXQoTS54LE0ueSxNLnosTS53KTpVZS5zZXQoTSxELE4sQiksU2Uuc2Npc3NvcihxLmNvcHkoVWUpLm11bHRpcGx5U2NhbGFyKEgpLnJvdW5kKCkpfSx0aGlzLmdldFNjaXNzb3JUZXN0PWZ1bmN0aW9uKCl7cmV0dXJuIFllfSx0aGlzLnNldFNjaXNzb3JUZXN0PWZ1bmN0aW9uKE0pe1NlLnNldFNjaXNzb3JUZXN0KFllPU0pfSx0aGlzLnNldE9wYXF1ZVNvcnQ9ZnVuY3Rpb24oTSl7aWU9TX0sdGhpcy5zZXRUcmFuc3BhcmVudFNvcnQ9ZnVuY3Rpb24oTSl7Y2U9TX0sdGhpcy5nZXRDbGVhckNvbG9yPWZ1bmN0aW9uKE0pe3JldHVybiBNLmNvcHkoRWUuZ2V0Q2xlYXJDb2xvcigpKX0sdGhpcy5zZXRDbGVhckNvbG9yPWZ1bmN0aW9uKCl7RWUuc2V0Q2xlYXJDb2xvci5hcHBseShFZSxhcmd1bWVudHMpfSx0aGlzLmdldENsZWFyQWxwaGE9ZnVuY3Rpb24oKXtyZXR1cm4gRWUuZ2V0Q2xlYXJBbHBoYSgpfSx0aGlzLnNldENsZWFyQWxwaGE9ZnVuY3Rpb24oKXtFZS5zZXRDbGVhckFscGhhLmFwcGx5KEVlLGFyZ3VtZW50cyl9LHRoaXMuY2xlYXI9ZnVuY3Rpb24oTT0hMCxEPSEwLE49ITApe2xldCBCPTA7aWYoTSl7bGV0IEw9ITE7aWYoRiE9PW51bGwpe2NvbnN0IEo9Ri50ZXh0dXJlLmZvcm1hdDtMPUo9PT0xMDMzfHxKPT09MTAzMXx8Sj09PTEwMjl9aWYoTCl7Y29uc3QgSj1GLnRleHR1cmUudHlwZSxvZT1KPT09MTAwOXx8Sj09PTEwMTR8fEo9PT0xMDEyfHxKPT09MTAyMHx8Sj09PTEwMTd8fEo9PT0xMDE4LGZlPUVlLmdldENsZWFyQ29sb3IoKSxwZT1FZS5nZXRDbGVhckFscGhhKCksQWU9ZmUucixDZT1mZS5nLG1lPWZlLmI7b2U/KF9bMF09QWUsX1sxXT1DZSxfWzJdPW1lLF9bM109cGUsVS5jbGVhckJ1ZmZlcnVpdihVLkNPTE9SLDAsXykpOih4WzBdPUFlLHhbMV09Q2UseFsyXT1tZSx4WzNdPXBlLFUuY2xlYXJCdWZmZXJpdihVLkNPTE9SLDAseCkpfWVsc2UgQnw9VS5DT0xPUl9CVUZGRVJfQklUfUQmJihCfD1VLkRFUFRIX0JVRkZFUl9CSVQpLE4mJihCfD1VLlNURU5DSUxfQlVGRkVSX0JJVCx0aGlzLnN0YXRlLmJ1ZmZlcnMuc3RlbmNpbC5zZXRNYXNrKDQyOTQ5NjcyOTUpKSxVLmNsZWFyKEIpfSx0aGlzLmNsZWFyQ29sb3I9ZnVuY3Rpb24oKXt0aGlzLmNsZWFyKCEwLCExLCExKX0sdGhpcy5jbGVhckRlcHRoPWZ1bmN0aW9uKCl7dGhpcy5jbGVhcighMSwhMCwhMSl9LHRoaXMuY2xlYXJTdGVuY2lsPWZ1bmN0aW9uKCl7dGhpcy5jbGVhcighMSwhMSwhMCl9LHRoaXMuZGlzcG9zZT1mdW5jdGlvbigpe3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigid2ViZ2xjb250ZXh0bG9zdCIsJCwhMSksdC5yZW1vdmVFdmVudExpc3RlbmVyKCJ3ZWJnbGNvbnRleHRyZXN0b3JlZCIsbGUsITEpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcigid2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvciIsYWUsITEpLHVlLmRpc3Bvc2UoKSxHZS5kaXNwb3NlKCksTWUuZGlzcG9zZSgpLHYuZGlzcG9zZSgpLEkuZGlzcG9zZSgpLGsuZGlzcG9zZSgpLEtlLmRpc3Bvc2UoKSxDLmRpc3Bvc2UoKSxfZS5kaXNwb3NlKCksRy5kaXNwb3NlKCksRy5yZW1vdmVFdmVudExpc3RlbmVyKCJzZXNzaW9uc3RhcnQiLEdzKSxHLnJlbW92ZUV2ZW50TGlzdGVuZXIoInNlc3Npb25lbmQiLEhzKSx2bi5zdG9wKCl9O2Z1bmN0aW9uICQoTSl7TS5wcmV2ZW50RGVmYXVsdCgpLGNvbnNvbGUubG9nKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBDb250ZXh0IExvc3QuIiksUD0hMH1mdW5jdGlvbiBsZSgpe2NvbnNvbGUubG9nKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBDb250ZXh0IFJlc3RvcmVkLiIpLFA9ITE7Y29uc3QgTT1qZS5hdXRvUmVzZXQsRD1oZS5lbmFibGVkLE49aGUuYXV0b1VwZGF0ZSxCPWhlLm5lZWRzVXBkYXRlLEw9aGUudHlwZTtuZSgpLGplLmF1dG9SZXNldD1NLGhlLmVuYWJsZWQ9RCxoZS5hdXRvVXBkYXRlPU4saGUubmVlZHNVcGRhdGU9QixoZS50eXBlPUx9ZnVuY3Rpb24gYWUoTSl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xSZW5kZXJlcjogQSBXZWJHTCBjb250ZXh0IGNvdWxkIG5vdCBiZSBjcmVhdGVkLiBSZWFzb246ICIsTS5zdGF0dXNNZXNzYWdlKX1mdW5jdGlvbiBSZShNKXtjb25zdCBEPU0udGFyZ2V0O0QucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsUmUpLGl0KEQpfWZ1bmN0aW9uIGl0KE0pe210KE0pLE1lLnJlbW92ZShNKX1mdW5jdGlvbiBtdChNKXtjb25zdCBEPU1lLmdldChNKS5wcm9ncmFtcztEIT09dm9pZCAwJiYoRC5mb3JFYWNoKGZ1bmN0aW9uKE4pe19lLnJlbGVhc2VQcm9ncmFtKE4pfSksTS5pc1NoYWRlck1hdGVyaWFsJiZfZS5yZWxlYXNlU2hhZGVyQ2FjaGUoTSkpfXRoaXMucmVuZGVyQnVmZmVyRGlyZWN0PWZ1bmN0aW9uKE0sRCxOLEIsTCxKKXtEPT09bnVsbCYmKEQ9bnQpO2NvbnN0IG9lPUwuaXNNZXNoJiZMLm1hdHJpeFdvcmxkLmRldGVybWluYW50KCk8MCxmZT12aChNLEQsTixCLEwpO1NlLnNldE1hdGVyaWFsKEIsb2UpO2xldCBwZT1OLmluZGV4LEFlPTE7aWYoQi53aXJlZnJhbWU9PT0hMCl7aWYocGU9Sy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUoTikscGU9PT12b2lkIDApcmV0dXJuO0FlPTJ9Y29uc3QgQ2U9Ti5kcmF3UmFuZ2UsbWU9Ti5hdHRyaWJ1dGVzLnBvc2l0aW9uO2xldCBIZT1DZS5zdGFydCpBZSxaZT0oQ2Uuc3RhcnQrQ2UuY291bnQpKkFlO0ohPT1udWxsJiYoSGU9TWF0aC5tYXgoSGUsSi5zdGFydCpBZSksWmU9TWF0aC5taW4oWmUsKEouc3RhcnQrSi5jb3VudCkqQWUpKSxwZSE9PW51bGw/KEhlPU1hdGgubWF4KEhlLDApLFplPU1hdGgubWluKFplLHBlLmNvdW50KSk6bWUhPW51bGwmJihIZT1NYXRoLm1heChIZSwwKSxaZT1NYXRoLm1pbihaZSxtZS5jb3VudCkpO2NvbnN0IEplPVplLUhlO2lmKEplPDB8fEplPT09MS8wKXJldHVybjtLZS5zZXR1cChMLEIsZmUsTixwZSk7bGV0IEV0LGtlPWRlO2lmKHBlIT09bnVsbCYmKEV0PVkuZ2V0KHBlKSxrZT1PZSxrZS5zZXRJbmRleChFdCkpLEwuaXNNZXNoKUIud2lyZWZyYW1lPT09ITA/KFNlLnNldExpbmVXaWR0aChCLndpcmVmcmFtZUxpbmV3aWR0aCphdCgpKSxrZS5zZXRNb2RlKFUuTElORVMpKTprZS5zZXRNb2RlKFUuVFJJQU5HTEVTKTtlbHNlIGlmKEwuaXNMaW5lKXtsZXQgdmU9Qi5saW5ld2lkdGg7dmU9PT12b2lkIDAmJih2ZT0xKSxTZS5zZXRMaW5lV2lkdGgodmUqYXQoKSksTC5pc0xpbmVTZWdtZW50cz9rZS5zZXRNb2RlKFUuTElORVMpOkwuaXNMaW5lTG9vcD9rZS5zZXRNb2RlKFUuTElORV9MT09QKTprZS5zZXRNb2RlKFUuTElORV9TVFJJUCl9ZWxzZSBMLmlzUG9pbnRzP2tlLnNldE1vZGUoVS5QT0lOVFMpOkwuaXNTcHJpdGUmJmtlLnNldE1vZGUoVS5UUklBTkdMRVMpO2lmKEwuaXNCYXRjaGVkTWVzaClpZihMLl9tdWx0aURyYXdJbnN0YW5jZXMhPT1udWxsKWtlLnJlbmRlck11bHRpRHJhd0luc3RhbmNlcyhMLl9tdWx0aURyYXdTdGFydHMsTC5fbXVsdGlEcmF3Q291bnRzLEwuX211bHRpRHJhd0NvdW50LEwuX211bHRpRHJhd0luc3RhbmNlcyk7ZWxzZSBpZihJZS5nZXQoIldFQkdMX211bHRpX2RyYXciKSlrZS5yZW5kZXJNdWx0aURyYXcoTC5fbXVsdGlEcmF3U3RhcnRzLEwuX211bHRpRHJhd0NvdW50cyxMLl9tdWx0aURyYXdDb3VudCk7ZWxzZXtjb25zdCB2ZT1MLl9tdWx0aURyYXdTdGFydHMsWnQ9TC5fbXVsdGlEcmF3Q291bnRzLFdlPUwuX211bHRpRHJhd0NvdW50LEJ0PXBlP1kuZ2V0KHBlKS5ieXRlc1BlckVsZW1lbnQ6MSxHbj1NZS5nZXQoQikuY3VycmVudFByb2dyYW0uZ2V0VW5pZm9ybXMoKTtmb3IobGV0IHd0PTA7d3Q8V2U7d3QrKylHbi5zZXRWYWx1ZShVLCJfZ2xfRHJhd0lEIix3dCksa2UucmVuZGVyKHZlW3d0XS9CdCxadFt3dF0pfWVsc2UgaWYoTC5pc0luc3RhbmNlZE1lc2gpa2UucmVuZGVySW5zdGFuY2VzKEhlLEplLEwuY291bnQpO2Vsc2UgaWYoTi5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KXtjb25zdCB2ZT1OLl9tYXhJbnN0YW5jZUNvdW50IT09dm9pZCAwP04uX21heEluc3RhbmNlQ291bnQ6MS8wLFp0PU1hdGgubWluKE4uaW5zdGFuY2VDb3VudCx2ZSk7a2UucmVuZGVySW5zdGFuY2VzKEhlLEplLFp0KX1lbHNlIGtlLnJlbmRlcihIZSxKZSl9O2Z1bmN0aW9uIFhlKE0sRCxOKXtNLnRyYW5zcGFyZW50PT09ITAmJk0uc2lkZT09PTImJk0uZm9yY2VTaW5nbGVQYXNzPT09ITE/KE0uc2lkZT0xLE0ubmVlZHNVcGRhdGU9ITAsSWkoTSxELE4pLE0uc2lkZT0wLE0ubmVlZHNVcGRhdGU9ITAsSWkoTSxELE4pLE0uc2lkZT0yKTpJaShNLEQsTil9dGhpcy5jb21waWxlPWZ1bmN0aW9uKE0sRCxOPW51bGwpe049PT1udWxsJiYoTj1NKSx1PUdlLmdldChOKSx1LmluaXQoRCkseS5wdXNoKHUpLE4udHJhdmVyc2VWaXNpYmxlKGZ1bmN0aW9uKEwpe0wuaXNMaWdodCYmTC5sYXllcnMudGVzdChELmxheWVycykmJih1LnB1c2hMaWdodChMKSxMLmNhc3RTaGFkb3cmJnUucHVzaFNoYWRvdyhMKSl9KSxNIT09TiYmTS50cmF2ZXJzZVZpc2libGUoZnVuY3Rpb24oTCl7TC5pc0xpZ2h0JiZMLmxheWVycy50ZXN0KEQubGF5ZXJzKSYmKHUucHVzaExpZ2h0KEwpLEwuY2FzdFNoYWRvdyYmdS5wdXNoU2hhZG93KEwpKX0pLHUuc2V0dXBMaWdodHMoKTtjb25zdCBCPW5ldyBTZXQ7cmV0dXJuIE0udHJhdmVyc2UoZnVuY3Rpb24oTCl7aWYoIShMLmlzTWVzaHx8TC5pc1BvaW50c3x8TC5pc0xpbmV8fEwuaXNTcHJpdGUpKXJldHVybjtjb25zdCBKPUwubWF0ZXJpYWw7aWYoSilpZihBcnJheS5pc0FycmF5KEopKWZvcihsZXQgb2U9MDtvZTxKLmxlbmd0aDtvZSsrKXtjb25zdCBmZT1KW29lXTtYZShmZSxOLEwpLEIuYWRkKGZlKX1lbHNlIFhlKEosTixMKSxCLmFkZChKKX0pLHkucG9wKCksdT1udWxsLEJ9LHRoaXMuY29tcGlsZUFzeW5jPWZ1bmN0aW9uKE0sRCxOPW51bGwpe2NvbnN0IEI9dGhpcy5jb21waWxlKE0sRCxOKTtyZXR1cm4gbmV3IFByb21pc2UoTD0+e2Z1bmN0aW9uIEooKXtpZihCLmZvckVhY2goZnVuY3Rpb24ob2Upe01lLmdldChvZSkuY3VycmVudFByb2dyYW0uaXNSZWFkeSgpJiZCLmRlbGV0ZShvZSl9KSxCLnNpemU9PT0wKXtMKE0pO3JldHVybn1zZXRUaW1lb3V0KEosMTApfUllLmdldCgiS0hSX3BhcmFsbGVsX3NoYWRlcl9jb21waWxlIikhPT1udWxsP0ooKTpzZXRUaW1lb3V0KEosMTApfSl9O2xldCBPdD1udWxsO2Z1bmN0aW9uIEt0KE0pe090JiZPdChNKX1mdW5jdGlvbiBHcygpe3ZuLnN0b3AoKX1mdW5jdGlvbiBIcygpe3ZuLnN0YXJ0KCl9Y29uc3Qgdm49bmV3IFFyO3ZuLnNldEFuaW1hdGlvbkxvb3AoS3QpLHR5cGVvZiBzZWxmPCJ1IiYmdm4uc2V0Q29udGV4dChzZWxmKSx0aGlzLnNldEFuaW1hdGlvbkxvb3A9ZnVuY3Rpb24oTSl7T3Q9TSxHLnNldEFuaW1hdGlvbkxvb3AoTSksTT09PW51bGw/dm4uc3RvcCgpOnZuLnN0YXJ0KCl9LEcuYWRkRXZlbnRMaXN0ZW5lcigic2Vzc2lvbnN0YXJ0IixHcyksRy5hZGRFdmVudExpc3RlbmVyKCJzZXNzaW9uZW5kIixIcyksdGhpcy5yZW5kZXI9ZnVuY3Rpb24oTSxEKXtpZihEIT09dm9pZCAwJiZELmlzQ2FtZXJhIT09ITApe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXIucmVuZGVyOiBjYW1lcmEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkNhbWVyYS4iKTtyZXR1cm59aWYoUD09PSEwKXJldHVybjtpZihNLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZT09PSEwJiZNLnVwZGF0ZU1hdHJpeFdvcmxkKCksRC5wYXJlbnQ9PT1udWxsJiZELm1hdHJpeFdvcmxkQXV0b1VwZGF0ZT09PSEwJiZELnVwZGF0ZU1hdHJpeFdvcmxkKCksRy5lbmFibGVkPT09ITAmJkcuaXNQcmVzZW50aW5nPT09ITAmJihHLmNhbWVyYUF1dG9VcGRhdGU9PT0hMCYmRy51cGRhdGVDYW1lcmEoRCksRD1HLmdldENhbWVyYSgpKSxNLmlzU2NlbmU9PT0hMCYmTS5vbkJlZm9yZVJlbmRlcihnLE0sRCxGKSx1PUdlLmdldChNLHkubGVuZ3RoKSx1LmluaXQoRCkseS5wdXNoKHUpLHllLm11bHRpcGx5TWF0cmljZXMoRC5wcm9qZWN0aW9uTWF0cml4LEQubWF0cml4V29ybGRJbnZlcnNlKSxYLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KHllKSxnZT10aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkLGVlPWouaW5pdCh0aGlzLmNsaXBwaW5nUGxhbmVzLGdlKSxtPXVlLmdldChNLFQubGVuZ3RoKSxtLmluaXQoKSxULnB1c2gobSksRy5lbmFibGVkPT09ITAmJkcuaXNQcmVzZW50aW5nPT09ITApe2NvbnN0IEo9Zy54ci5nZXREZXB0aFNlbnNpbmdNZXNoKCk7SiE9PW51bGwmJnZyKEosRCwtMS8wLGcuc29ydE9iamVjdHMpfXZyKE0sRCwwLGcuc29ydE9iamVjdHMpLG0uZmluaXNoKCksZy5zb3J0T2JqZWN0cz09PSEwJiZtLnNvcnQoaWUsY2UpLHplPUcuZW5hYmxlZD09PSExfHxHLmlzUHJlc2VudGluZz09PSExfHxHLmhhc0RlcHRoU2Vuc2luZygpPT09ITEsemUmJkVlLmFkZFRvUmVuZGVyTGlzdChtLE0pLHRoaXMuaW5mby5yZW5kZXIuZnJhbWUrKyxlZT09PSEwJiZqLmJlZ2luU2hhZG93cygpO2NvbnN0IE49dS5zdGF0ZS5zaGFkb3dzQXJyYXk7aGUucmVuZGVyKE4sTSxEKSxlZT09PSEwJiZqLmVuZFNoYWRvd3MoKSx0aGlzLmluZm8uYXV0b1Jlc2V0PT09ITAmJnRoaXMuaW5mby5yZXNldCgpO2NvbnN0IEI9bS5vcGFxdWUsTD1tLnRyYW5zbWlzc2l2ZTtpZih1LnNldHVwTGlnaHRzKCksRC5pc0FycmF5Q2FtZXJhKXtjb25zdCBKPUQuY2FtZXJhcztpZihMLmxlbmd0aD4wKWZvcihsZXQgb2U9MCxmZT1KLmxlbmd0aDtvZTxmZTtvZSsrKXtjb25zdCBwZT1KW29lXTtrcyhCLEwsTSxwZSl9emUmJkVlLnJlbmRlcihNKTtmb3IobGV0IG9lPTAsZmU9Si5sZW5ndGg7b2U8ZmU7b2UrKyl7Y29uc3QgcGU9SltvZV07VnMobSxNLHBlLHBlLnZpZXdwb3J0KX19ZWxzZSBMLmxlbmd0aD4wJiZrcyhCLEwsTSxEKSx6ZSYmRWUucmVuZGVyKE0pLFZzKG0sTSxEKTtGIT09bnVsbCYmKEEudXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQoRiksQS51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoRikpLE0uaXNTY2VuZT09PSEwJiZNLm9uQWZ0ZXJSZW5kZXIoZyxNLEQpLEtlLnJlc2V0RGVmYXVsdFN0YXRlKCksRT0tMSxTPW51bGwseS5wb3AoKSx5Lmxlbmd0aD4wPyh1PXlbeS5sZW5ndGgtMV0sZWU9PT0hMCYmai5zZXRHbG9iYWxTdGF0ZShnLmNsaXBwaW5nUGxhbmVzLHUuc3RhdGUuY2FtZXJhKSk6dT1udWxsLFQucG9wKCksVC5sZW5ndGg+MD9tPVRbVC5sZW5ndGgtMV06bT1udWxsfTtmdW5jdGlvbiB2cihNLEQsTixCKXtpZihNLnZpc2libGU9PT0hMSlyZXR1cm47aWYoTS5sYXllcnMudGVzdChELmxheWVycykpe2lmKE0uaXNHcm91cClOPU0ucmVuZGVyT3JkZXI7ZWxzZSBpZihNLmlzTE9EKU0uYXV0b1VwZGF0ZT09PSEwJiZNLnVwZGF0ZShEKTtlbHNlIGlmKE0uaXNMaWdodCl1LnB1c2hMaWdodChNKSxNLmNhc3RTaGFkb3cmJnUucHVzaFNoYWRvdyhNKTtlbHNlIGlmKE0uaXNTcHJpdGUpe2lmKCFNLmZydXN0dW1DdWxsZWR8fFguaW50ZXJzZWN0c1Nwcml0ZShNKSl7QiYmRmUuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKE0ubWF0cml4V29ybGQpLmFwcGx5TWF0cml4NCh5ZSk7Y29uc3Qgb2U9ay51cGRhdGUoTSksZmU9TS5tYXRlcmlhbDtmZS52aXNpYmxlJiZtLnB1c2goTSxvZSxmZSxOLEZlLnosbnVsbCl9fWVsc2UgaWYoKE0uaXNNZXNofHxNLmlzTGluZXx8TS5pc1BvaW50cykmJighTS5mcnVzdHVtQ3VsbGVkfHxYLmludGVyc2VjdHNPYmplY3QoTSkpKXtjb25zdCBvZT1rLnVwZGF0ZShNKSxmZT1NLm1hdGVyaWFsO2lmKEImJihNLmJvdW5kaW5nU3BoZXJlIT09dm9pZCAwPyhNLmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmTS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKSxGZS5jb3B5KE0uYm91bmRpbmdTcGhlcmUuY2VudGVyKSk6KG9lLmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmb2UuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksRmUuY29weShvZS5ib3VuZGluZ1NwaGVyZS5jZW50ZXIpKSxGZS5hcHBseU1hdHJpeDQoTS5tYXRyaXhXb3JsZCkuYXBwbHlNYXRyaXg0KHllKSksQXJyYXkuaXNBcnJheShmZSkpe2NvbnN0IHBlPW9lLmdyb3Vwcztmb3IobGV0IEFlPTAsQ2U9cGUubGVuZ3RoO0FlPENlO0FlKyspe2NvbnN0IG1lPXBlW0FlXSxIZT1mZVttZS5tYXRlcmlhbEluZGV4XTtIZSYmSGUudmlzaWJsZSYmbS5wdXNoKE0sb2UsSGUsTixGZS56LG1lKX19ZWxzZSBmZS52aXNpYmxlJiZtLnB1c2goTSxvZSxmZSxOLEZlLnosbnVsbCl9fWNvbnN0IEo9TS5jaGlsZHJlbjtmb3IobGV0IG9lPTAsZmU9Si5sZW5ndGg7b2U8ZmU7b2UrKyl2cihKW29lXSxELE4sQil9ZnVuY3Rpb24gVnMoTSxELE4sQil7Y29uc3QgTD1NLm9wYXF1ZSxKPU0udHJhbnNtaXNzaXZlLG9lPU0udHJhbnNwYXJlbnQ7dS5zZXR1cExpZ2h0c1ZpZXcoTiksZWU9PT0hMCYmai5zZXRHbG9iYWxTdGF0ZShnLmNsaXBwaW5nUGxhbmVzLE4pLEImJlNlLnZpZXdwb3J0KFIuY29weShCKSksTC5sZW5ndGg+MCYmRmkoTCxELE4pLEoubGVuZ3RoPjAmJkZpKEosRCxOKSxvZS5sZW5ndGg+MCYmRmkob2UsRCxOKSxTZS5idWZmZXJzLmRlcHRoLnNldFRlc3QoITApLFNlLmJ1ZmZlcnMuZGVwdGguc2V0TWFzayghMCksU2UuYnVmZmVycy5jb2xvci5zZXRNYXNrKCEwKSxTZS5zZXRQb2x5Z29uT2Zmc2V0KCExKX1mdW5jdGlvbiBrcyhNLEQsTixCKXtpZigoTi5pc1NjZW5lPT09ITA/Ti5vdmVycmlkZU1hdGVyaWFsOm51bGwpIT09bnVsbClyZXR1cm47dS5zdGF0ZS50cmFuc21pc3Npb25SZW5kZXJUYXJnZXRbQi5pZF09PT12b2lkIDAmJih1LnN0YXRlLnRyYW5zbWlzc2lvblJlbmRlclRhcmdldFtCLmlkXT1uZXcgSnQoMSwxLHtnZW5lcmF0ZU1pcG1hcHM6ITAsdHlwZTpJZS5oYXMoIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCIpfHxJZS5oYXMoIkVYVF9jb2xvcl9idWZmZXJfZmxvYXQiKT8xMDE2OjEwMDksbWluRmlsdGVyOjEwMDgsc2FtcGxlczo0LHN0ZW5jaWxCdWZmZXI6cyxyZXNvbHZlRGVwdGhCdWZmZXI6ITEscmVzb2x2ZVN0ZW5jaWxCdWZmZXI6ITEsY29sb3JTcGFjZTpCZS53b3JraW5nQ29sb3JTcGFjZX0pKTtjb25zdCBKPXUuc3RhdGUudHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0W0IuaWRdLG9lPUIudmlld3BvcnR8fFI7Si5zZXRTaXplKG9lLnosb2Uudyk7Y29uc3QgZmU9Zy5nZXRSZW5kZXJUYXJnZXQoKTtnLnNldFJlbmRlclRhcmdldChKKSxnLmdldENsZWFyQ29sb3IoVyksWj1nLmdldENsZWFyQWxwaGEoKSxaPDEmJmcuc2V0Q2xlYXJDb2xvcigxNjc3NzIxNSwuNSksZy5jbGVhcigpLHplJiZFZS5yZW5kZXIoTik7Y29uc3QgcGU9Zy50b25lTWFwcGluZztnLnRvbmVNYXBwaW5nPTA7Y29uc3QgQWU9Qi52aWV3cG9ydDtpZihCLnZpZXdwb3J0IT09dm9pZCAwJiYoQi52aWV3cG9ydD12b2lkIDApLHUuc2V0dXBMaWdodHNWaWV3KEIpLGVlPT09ITAmJmouc2V0R2xvYmFsU3RhdGUoZy5jbGlwcGluZ1BsYW5lcyxCKSxGaShNLE4sQiksQS51cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldChKKSxBLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcChKKSxJZS5oYXMoIldFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZSIpPT09ITEpe2xldCBDZT0hMTtmb3IobGV0IG1lPTAsSGU9RC5sZW5ndGg7bWU8SGU7bWUrKyl7Y29uc3QgWmU9RFttZV0sSmU9WmUub2JqZWN0LEV0PVplLmdlb21ldHJ5LGtlPVplLm1hdGVyaWFsLHZlPVplLmdyb3VwO2lmKGtlLnNpZGU9PT0yJiZKZS5sYXllcnMudGVzdChCLmxheWVycykpe2NvbnN0IFp0PWtlLnNpZGU7a2Uuc2lkZT0xLGtlLm5lZWRzVXBkYXRlPSEwLFdzKEplLE4sQixFdCxrZSx2ZSksa2Uuc2lkZT1adCxrZS5uZWVkc1VwZGF0ZT0hMCxDZT0hMH19Q2U9PT0hMCYmKEEudXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQoSiksQS51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoSikpfWcuc2V0UmVuZGVyVGFyZ2V0KGZlKSxnLnNldENsZWFyQ29sb3IoVyxaKSxBZSE9PXZvaWQgMCYmKEIudmlld3BvcnQ9QWUpLGcudG9uZU1hcHBpbmc9cGV9ZnVuY3Rpb24gRmkoTSxELE4pe2NvbnN0IEI9RC5pc1NjZW5lPT09ITA/RC5vdmVycmlkZU1hdGVyaWFsOm51bGw7Zm9yKGxldCBMPTAsSj1NLmxlbmd0aDtMPEo7TCsrKXtjb25zdCBvZT1NW0xdLGZlPW9lLm9iamVjdCxwZT1vZS5nZW9tZXRyeSxBZT1CPT09bnVsbD9vZS5tYXRlcmlhbDpCLENlPW9lLmdyb3VwO2ZlLmxheWVycy50ZXN0KE4ubGF5ZXJzKSYmV3MoZmUsRCxOLHBlLEFlLENlKX19ZnVuY3Rpb24gV3MoTSxELE4sQixMLEope00ub25CZWZvcmVSZW5kZXIoZyxELE4sQixMLEopLE0ubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoTi5tYXRyaXhXb3JsZEludmVyc2UsTS5tYXRyaXhXb3JsZCksTS5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KE0ubW9kZWxWaWV3TWF0cml4KSxMLm9uQmVmb3JlUmVuZGVyKGcsRCxOLEIsTSxKKSxMLnRyYW5zcGFyZW50PT09ITAmJkwuc2lkZT09PTImJkwuZm9yY2VTaW5nbGVQYXNzPT09ITE/KEwuc2lkZT0xLEwubmVlZHNVcGRhdGU9ITAsZy5yZW5kZXJCdWZmZXJEaXJlY3QoTixELEIsTCxNLEopLEwuc2lkZT0wLEwubmVlZHNVcGRhdGU9ITAsZy5yZW5kZXJCdWZmZXJEaXJlY3QoTixELEIsTCxNLEopLEwuc2lkZT0yKTpnLnJlbmRlckJ1ZmZlckRpcmVjdChOLEQsQixMLE0sSiksTS5vbkFmdGVyUmVuZGVyKGcsRCxOLEIsTCxKKX1mdW5jdGlvbiBJaShNLEQsTil7RC5pc1NjZW5lIT09ITAmJihEPW50KTtjb25zdCBCPU1lLmdldChNKSxMPXUuc3RhdGUubGlnaHRzLEo9dS5zdGF0ZS5zaGFkb3dzQXJyYXksb2U9TC5zdGF0ZS52ZXJzaW9uLGZlPV9lLmdldFBhcmFtZXRlcnMoTSxMLnN0YXRlLEosRCxOKSxwZT1fZS5nZXRQcm9ncmFtQ2FjaGVLZXkoZmUpO2xldCBBZT1CLnByb2dyYW1zO0IuZW52aXJvbm1lbnQ9TS5pc01lc2hTdGFuZGFyZE1hdGVyaWFsP0QuZW52aXJvbm1lbnQ6bnVsbCxCLmZvZz1ELmZvZyxCLmVudk1hcD0oTS5pc01lc2hTdGFuZGFyZE1hdGVyaWFsP0k6dikuZ2V0KE0uZW52TWFwfHxCLmVudmlyb25tZW50KSxCLmVudk1hcFJvdGF0aW9uPUIuZW52aXJvbm1lbnQhPT1udWxsJiZNLmVudk1hcD09PW51bGw/RC5lbnZpcm9ubWVudFJvdGF0aW9uOk0uZW52TWFwUm90YXRpb24sQWU9PT12b2lkIDAmJihNLmFkZEV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLFJlKSxBZT1uZXcgTWFwLEIucHJvZ3JhbXM9QWUpO2xldCBDZT1BZS5nZXQocGUpO2lmKENlIT09dm9pZCAwKXtpZihCLmN1cnJlbnRQcm9ncmFtPT09Q2UmJkIubGlnaHRzU3RhdGVWZXJzaW9uPT09b2UpcmV0dXJuIHFzKE0sZmUpLENlfWVsc2UgZmUudW5pZm9ybXM9X2UuZ2V0VW5pZm9ybXMoTSksTS5vbkJlZm9yZUNvbXBpbGUoZmUsZyksQ2U9X2UuYWNxdWlyZVByb2dyYW0oZmUscGUpLEFlLnNldChwZSxDZSksQi51bmlmb3Jtcz1mZS51bmlmb3Jtcztjb25zdCBtZT1CLnVuaWZvcm1zO3JldHVybighTS5pc1NoYWRlck1hdGVyaWFsJiYhTS5pc1Jhd1NoYWRlck1hdGVyaWFsfHxNLmNsaXBwaW5nPT09ITApJiYobWUuY2xpcHBpbmdQbGFuZXM9ai51bmlmb3JtKSxxcyhNLGZlKSxCLm5lZWRzTGlnaHRzPU1oKE0pLEIubGlnaHRzU3RhdGVWZXJzaW9uPW9lLEIubmVlZHNMaWdodHMmJihtZS5hbWJpZW50TGlnaHRDb2xvci52YWx1ZT1MLnN0YXRlLmFtYmllbnQsbWUubGlnaHRQcm9iZS52YWx1ZT1MLnN0YXRlLnByb2JlLG1lLmRpcmVjdGlvbmFsTGlnaHRzLnZhbHVlPUwuc3RhdGUuZGlyZWN0aW9uYWwsbWUuZGlyZWN0aW9uYWxMaWdodFNoYWRvd3MudmFsdWU9TC5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvdyxtZS5zcG90TGlnaHRzLnZhbHVlPUwuc3RhdGUuc3BvdCxtZS5zcG90TGlnaHRTaGFkb3dzLnZhbHVlPUwuc3RhdGUuc3BvdFNoYWRvdyxtZS5yZWN0QXJlYUxpZ2h0cy52YWx1ZT1MLnN0YXRlLnJlY3RBcmVhLG1lLmx0Y18xLnZhbHVlPUwuc3RhdGUucmVjdEFyZWFMVEMxLG1lLmx0Y18yLnZhbHVlPUwuc3RhdGUucmVjdEFyZWFMVEMyLG1lLnBvaW50TGlnaHRzLnZhbHVlPUwuc3RhdGUucG9pbnQsbWUucG9pbnRMaWdodFNoYWRvd3MudmFsdWU9TC5zdGF0ZS5wb2ludFNoYWRvdyxtZS5oZW1pc3BoZXJlTGlnaHRzLnZhbHVlPUwuc3RhdGUuaGVtaSxtZS5kaXJlY3Rpb25hbFNoYWRvd01hcC52YWx1ZT1MLnN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWFwLG1lLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4LnZhbHVlPUwuc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXgsbWUuc3BvdFNoYWRvd01hcC52YWx1ZT1MLnN0YXRlLnNwb3RTaGFkb3dNYXAsbWUuc3BvdExpZ2h0TWF0cml4LnZhbHVlPUwuc3RhdGUuc3BvdExpZ2h0TWF0cml4LG1lLnNwb3RMaWdodE1hcC52YWx1ZT1MLnN0YXRlLnNwb3RMaWdodE1hcCxtZS5wb2ludFNoYWRvd01hcC52YWx1ZT1MLnN0YXRlLnBvaW50U2hhZG93TWFwLG1lLnBvaW50U2hhZG93TWF0cml4LnZhbHVlPUwuc3RhdGUucG9pbnRTaGFkb3dNYXRyaXgpLEIuY3VycmVudFByb2dyYW09Q2UsQi51bmlmb3Jtc0xpc3Q9bnVsbCxDZX1mdW5jdGlvbiBYcyhNKXtpZihNLnVuaWZvcm1zTGlzdD09PW51bGwpe2NvbnN0IEQ9TS5jdXJyZW50UHJvZ3JhbS5nZXRVbmlmb3JtcygpO00udW5pZm9ybXNMaXN0PXdpLnNlcVdpdGhWYWx1ZShELnNlcSxNLnVuaWZvcm1zKX1yZXR1cm4gTS51bmlmb3Jtc0xpc3R9ZnVuY3Rpb24gcXMoTSxEKXtjb25zdCBOPU1lLmdldChNKTtOLm91dHB1dENvbG9yU3BhY2U9RC5vdXRwdXRDb2xvclNwYWNlLE4uYmF0Y2hpbmc9RC5iYXRjaGluZyxOLmJhdGNoaW5nQ29sb3I9RC5iYXRjaGluZ0NvbG9yLE4uaW5zdGFuY2luZz1ELmluc3RhbmNpbmcsTi5pbnN0YW5jaW5nQ29sb3I9RC5pbnN0YW5jaW5nQ29sb3IsTi5pbnN0YW5jaW5nTW9ycGg9RC5pbnN0YW5jaW5nTW9ycGgsTi5za2lubmluZz1ELnNraW5uaW5nLE4ubW9ycGhUYXJnZXRzPUQubW9ycGhUYXJnZXRzLE4ubW9ycGhOb3JtYWxzPUQubW9ycGhOb3JtYWxzLE4ubW9ycGhDb2xvcnM9RC5tb3JwaENvbG9ycyxOLm1vcnBoVGFyZ2V0c0NvdW50PUQubW9ycGhUYXJnZXRzQ291bnQsTi5udW1DbGlwcGluZ1BsYW5lcz1ELm51bUNsaXBwaW5nUGxhbmVzLE4ubnVtSW50ZXJzZWN0aW9uPUQubnVtQ2xpcEludGVyc2VjdGlvbixOLnZlcnRleEFscGhhcz1ELnZlcnRleEFscGhhcyxOLnZlcnRleFRhbmdlbnRzPUQudmVydGV4VGFuZ2VudHMsTi50b25lTWFwcGluZz1ELnRvbmVNYXBwaW5nfWZ1bmN0aW9uIHZoKE0sRCxOLEIsTCl7RC5pc1NjZW5lIT09ITAmJihEPW50KSxBLnJlc2V0VGV4dHVyZVVuaXRzKCk7Y29uc3QgSj1ELmZvZyxvZT1CLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWw/RC5lbnZpcm9ubWVudDpudWxsLGZlPUY9PT1udWxsP2cub3V0cHV0Q29sb3JTcGFjZTpGLmlzWFJSZW5kZXJUYXJnZXQ9PT0hMD9GLnRleHR1cmUuY29sb3JTcGFjZTp4bixwZT0oQi5pc01lc2hTdGFuZGFyZE1hdGVyaWFsP0k6dikuZ2V0KEIuZW52TWFwfHxvZSksQWU9Qi52ZXJ0ZXhDb2xvcnM9PT0hMCYmISFOLmF0dHJpYnV0ZXMuY29sb3ImJk4uYXR0cmlidXRlcy5jb2xvci5pdGVtU2l6ZT09PTQsQ2U9ISFOLmF0dHJpYnV0ZXMudGFuZ2VudCYmKCEhQi5ub3JtYWxNYXB8fEIuYW5pc290cm9weT4wKSxtZT0hIU4ubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLEhlPSEhTi5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsLFplPSEhTi5tb3JwaEF0dHJpYnV0ZXMuY29sb3I7bGV0IEplPTA7Qi50b25lTWFwcGVkJiYoRj09PW51bGx8fEYuaXNYUlJlbmRlclRhcmdldD09PSEwKSYmKEplPWcudG9uZU1hcHBpbmcpO2NvbnN0IEV0PU4ubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9ufHxOLm1vcnBoQXR0cmlidXRlcy5ub3JtYWx8fE4ubW9ycGhBdHRyaWJ1dGVzLmNvbG9yLGtlPUV0IT09dm9pZCAwP0V0Lmxlbmd0aDowLHZlPU1lLmdldChCKSxadD11LnN0YXRlLmxpZ2h0cztpZihlZT09PSEwJiYoZ2U9PT0hMHx8TSE9PVMpKXtjb25zdCBEdD1NPT09UyYmQi5pZD09PUU7ai5zZXRTdGF0ZShCLE0sRHQpfWxldCBXZT0hMTtCLnZlcnNpb249PT12ZS5fX3ZlcnNpb24/KHZlLm5lZWRzTGlnaHRzJiZ2ZS5saWdodHNTdGF0ZVZlcnNpb24hPT1adC5zdGF0ZS52ZXJzaW9ufHx2ZS5vdXRwdXRDb2xvclNwYWNlIT09ZmV8fEwuaXNCYXRjaGVkTWVzaCYmdmUuYmF0Y2hpbmc9PT0hMXx8IUwuaXNCYXRjaGVkTWVzaCYmdmUuYmF0Y2hpbmc9PT0hMHx8TC5pc0JhdGNoZWRNZXNoJiZ2ZS5iYXRjaGluZ0NvbG9yPT09ITAmJkwuY29sb3JUZXh0dXJlPT09bnVsbHx8TC5pc0JhdGNoZWRNZXNoJiZ2ZS5iYXRjaGluZ0NvbG9yPT09ITEmJkwuY29sb3JUZXh0dXJlIT09bnVsbHx8TC5pc0luc3RhbmNlZE1lc2gmJnZlLmluc3RhbmNpbmc9PT0hMXx8IUwuaXNJbnN0YW5jZWRNZXNoJiZ2ZS5pbnN0YW5jaW5nPT09ITB8fEwuaXNTa2lubmVkTWVzaCYmdmUuc2tpbm5pbmc9PT0hMXx8IUwuaXNTa2lubmVkTWVzaCYmdmUuc2tpbm5pbmc9PT0hMHx8TC5pc0luc3RhbmNlZE1lc2gmJnZlLmluc3RhbmNpbmdDb2xvcj09PSEwJiZMLmluc3RhbmNlQ29sb3I9PT1udWxsfHxMLmlzSW5zdGFuY2VkTWVzaCYmdmUuaW5zdGFuY2luZ0NvbG9yPT09ITEmJkwuaW5zdGFuY2VDb2xvciE9PW51bGx8fEwuaXNJbnN0YW5jZWRNZXNoJiZ2ZS5pbnN0YW5jaW5nTW9ycGg9PT0hMCYmTC5tb3JwaFRleHR1cmU9PT1udWxsfHxMLmlzSW5zdGFuY2VkTWVzaCYmdmUuaW5zdGFuY2luZ01vcnBoPT09ITEmJkwubW9ycGhUZXh0dXJlIT09bnVsbHx8dmUuZW52TWFwIT09cGV8fEIuZm9nPT09ITAmJnZlLmZvZyE9PUp8fHZlLm51bUNsaXBwaW5nUGxhbmVzIT09dm9pZCAwJiYodmUubnVtQ2xpcHBpbmdQbGFuZXMhPT1qLm51bVBsYW5lc3x8dmUubnVtSW50ZXJzZWN0aW9uIT09ai5udW1JbnRlcnNlY3Rpb24pfHx2ZS52ZXJ0ZXhBbHBoYXMhPT1BZXx8dmUudmVydGV4VGFuZ2VudHMhPT1DZXx8dmUubW9ycGhUYXJnZXRzIT09bWV8fHZlLm1vcnBoTm9ybWFscyE9PUhlfHx2ZS5tb3JwaENvbG9ycyE9PVplfHx2ZS50b25lTWFwcGluZyE9PUplfHx2ZS5tb3JwaFRhcmdldHNDb3VudCE9PWtlKSYmKFdlPSEwKTooV2U9ITAsdmUuX192ZXJzaW9uPUIudmVyc2lvbik7bGV0IEJ0PXZlLmN1cnJlbnRQcm9ncmFtO1dlPT09ITAmJihCdD1JaShCLEQsTCkpO2xldCBHbj0hMSx3dD0hMSx0aT0hMTtjb25zdCBRZT1CdC5nZXRVbmlmb3JtcygpLEh0PXZlLnVuaWZvcm1zO2lmKFNlLnVzZVByb2dyYW0oQnQucHJvZ3JhbSkmJihHbj0hMCx3dD0hMCx0aT0hMCksQi5pZCE9PUUmJihFPUIuaWQsd3Q9ITApLEdufHxTIT09TSl7U2UuYnVmZmVycy5kZXB0aC5nZXRSZXZlcnNlZCgpPyhyZS5jb3B5KE0ucHJvamVjdGlvbk1hdHJpeCksZGEocmUpLGZhKHJlKSxRZS5zZXRWYWx1ZShVLCJwcm9qZWN0aW9uTWF0cml4IixyZSkpOlFlLnNldFZhbHVlKFUsInByb2plY3Rpb25NYXRyaXgiLE0ucHJvamVjdGlvbk1hdHJpeCksUWUuc2V0VmFsdWUoVSwidmlld01hdHJpeCIsTS5tYXRyaXhXb3JsZEludmVyc2UpO2NvbnN0IGFuPVFlLm1hcC5jYW1lcmFQb3NpdGlvbjthbiE9PXZvaWQgMCYmYW4uc2V0VmFsdWUoVSx3ZS5zZXRGcm9tTWF0cml4UG9zaXRpb24oTS5tYXRyaXhXb3JsZCkpLE5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXImJlFlLnNldFZhbHVlKFUsImxvZ0RlcHRoQnVmRkMiLDIvKE1hdGgubG9nKE0uZmFyKzEpL01hdGguTE4yKSksKEIuaXNNZXNoUGhvbmdNYXRlcmlhbHx8Qi5pc01lc2hUb29uTWF0ZXJpYWx8fEIuaXNNZXNoTGFtYmVydE1hdGVyaWFsfHxCLmlzTWVzaEJhc2ljTWF0ZXJpYWx8fEIuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbHx8Qi5pc1NoYWRlck1hdGVyaWFsKSYmUWUuc2V0VmFsdWUoVSwiaXNPcnRob2dyYXBoaWMiLE0uaXNPcnRob2dyYXBoaWNDYW1lcmE9PT0hMCksUyE9PU0mJihTPU0sd3Q9ITAsdGk9ITApfWlmKEwuaXNTa2lubmVkTWVzaCl7UWUuc2V0T3B0aW9uYWwoVSxMLCJiaW5kTWF0cml4IiksUWUuc2V0T3B0aW9uYWwoVSxMLCJiaW5kTWF0cml4SW52ZXJzZSIpO2NvbnN0IER0PUwuc2tlbGV0b247RHQmJihEdC5ib25lVGV4dHVyZT09PW51bGwmJkR0LmNvbXB1dGVCb25lVGV4dHVyZSgpLFFlLnNldFZhbHVlKFUsImJvbmVUZXh0dXJlIixEdC5ib25lVGV4dHVyZSxBKSl9TC5pc0JhdGNoZWRNZXNoJiYoUWUuc2V0T3B0aW9uYWwoVSxMLCJiYXRjaGluZ1RleHR1cmUiKSxRZS5zZXRWYWx1ZShVLCJiYXRjaGluZ1RleHR1cmUiLEwuX21hdHJpY2VzVGV4dHVyZSxBKSxRZS5zZXRPcHRpb25hbChVLEwsImJhdGNoaW5nSWRUZXh0dXJlIiksUWUuc2V0VmFsdWUoVSwiYmF0Y2hpbmdJZFRleHR1cmUiLEwuX2luZGlyZWN0VGV4dHVyZSxBKSxRZS5zZXRPcHRpb25hbChVLEwsImJhdGNoaW5nQ29sb3JUZXh0dXJlIiksTC5fY29sb3JzVGV4dHVyZSE9PW51bGwmJlFlLnNldFZhbHVlKFUsImJhdGNoaW5nQ29sb3JUZXh0dXJlIixMLl9jb2xvcnNUZXh0dXJlLEEpKTtjb25zdCBuaT1OLm1vcnBoQXR0cmlidXRlcztpZigobmkucG9zaXRpb24hPT12b2lkIDB8fG5pLm5vcm1hbCE9PXZvaWQgMHx8bmkuY29sb3IhPT12b2lkIDApJiZUZS51cGRhdGUoTCxOLEJ0KSwod3R8fHZlLnJlY2VpdmVTaGFkb3chPT1MLnJlY2VpdmVTaGFkb3cpJiYodmUucmVjZWl2ZVNoYWRvdz1MLnJlY2VpdmVTaGFkb3csUWUuc2V0VmFsdWUoVSwicmVjZWl2ZVNoYWRvdyIsTC5yZWNlaXZlU2hhZG93KSksQi5pc01lc2hHb3VyYXVkTWF0ZXJpYWwmJkIuZW52TWFwIT09bnVsbCYmKEh0LmVudk1hcC52YWx1ZT1wZSxIdC5mbGlwRW52TWFwLnZhbHVlPXBlLmlzQ3ViZVRleHR1cmUmJnBlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT09PSExPy0xOjEpLEIuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCYmQi5lbnZNYXA9PT1udWxsJiZELmVudmlyb25tZW50IT09bnVsbCYmKEh0LmVudk1hcEludGVuc2l0eS52YWx1ZT1ELmVudmlyb25tZW50SW50ZW5zaXR5KSx3dCYmKFFlLnNldFZhbHVlKFUsInRvbmVNYXBwaW5nRXhwb3N1cmUiLGcudG9uZU1hcHBpbmdFeHBvc3VyZSksdmUubmVlZHNMaWdodHMmJnhoKEh0LHRpKSxKJiZCLmZvZz09PSEwJiZzZS5yZWZyZXNoRm9nVW5pZm9ybXMoSHQsSiksc2UucmVmcmVzaE1hdGVyaWFsVW5pZm9ybXMoSHQsQixILFEsdS5zdGF0ZS50cmFuc21pc3Npb25SZW5kZXJUYXJnZXRbTS5pZF0pLHdpLnVwbG9hZChVLFhzKHZlKSxIdCxBKSksQi5pc1NoYWRlck1hdGVyaWFsJiZCLnVuaWZvcm1zTmVlZFVwZGF0ZT09PSEwJiYod2kudXBsb2FkKFUsWHModmUpLEh0LEEpLEIudW5pZm9ybXNOZWVkVXBkYXRlPSExKSxCLmlzU3ByaXRlTWF0ZXJpYWwmJlFlLnNldFZhbHVlKFUsImNlbnRlciIsTC5jZW50ZXIpLFFlLnNldFZhbHVlKFUsIm1vZGVsVmlld01hdHJpeCIsTC5tb2RlbFZpZXdNYXRyaXgpLFFlLnNldFZhbHVlKFUsIm5vcm1hbE1hdHJpeCIsTC5ub3JtYWxNYXRyaXgpLFFlLnNldFZhbHVlKFUsIm1vZGVsTWF0cml4IixMLm1hdHJpeFdvcmxkKSxCLmlzU2hhZGVyTWF0ZXJpYWx8fEIuaXNSYXdTaGFkZXJNYXRlcmlhbCl7Y29uc3QgRHQ9Qi51bmlmb3Jtc0dyb3Vwcztmb3IobGV0IGFuPTAsb249RHQubGVuZ3RoO2FuPG9uO2FuKyspe2NvbnN0IFlzPUR0W2FuXTtDLnVwZGF0ZShZcyxCdCksQy5iaW5kKFlzLEJ0KX19cmV0dXJuIEJ0fWZ1bmN0aW9uIHhoKE0sRCl7TS5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZT1ELE0ubGlnaHRQcm9iZS5uZWVkc1VwZGF0ZT1ELE0uZGlyZWN0aW9uYWxMaWdodHMubmVlZHNVcGRhdGU9RCxNLmRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzLm5lZWRzVXBkYXRlPUQsTS5wb2ludExpZ2h0cy5uZWVkc1VwZGF0ZT1ELE0ucG9pbnRMaWdodFNoYWRvd3MubmVlZHNVcGRhdGU9RCxNLnNwb3RMaWdodHMubmVlZHNVcGRhdGU9RCxNLnNwb3RMaWdodFNoYWRvd3MubmVlZHNVcGRhdGU9RCxNLnJlY3RBcmVhTGlnaHRzLm5lZWRzVXBkYXRlPUQsTS5oZW1pc3BoZXJlTGlnaHRzLm5lZWRzVXBkYXRlPUR9ZnVuY3Rpb24gTWgoTSl7cmV0dXJuIE0uaXNNZXNoTGFtYmVydE1hdGVyaWFsfHxNLmlzTWVzaFRvb25NYXRlcmlhbHx8TS5pc01lc2hQaG9uZ01hdGVyaWFsfHxNLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWx8fE0uaXNTaGFkb3dNYXRlcmlhbHx8TS5pc1NoYWRlck1hdGVyaWFsJiZNLmxpZ2h0cz09PSEwfXRoaXMuZ2V0QWN0aXZlQ3ViZUZhY2U9ZnVuY3Rpb24oKXtyZXR1cm4gd30sdGhpcy5nZXRBY3RpdmVNaXBtYXBMZXZlbD1mdW5jdGlvbigpe3JldHVybiBifSx0aGlzLmdldFJlbmRlclRhcmdldD1mdW5jdGlvbigpe3JldHVybiBGfSx0aGlzLnNldFJlbmRlclRhcmdldFRleHR1cmVzPWZ1bmN0aW9uKE0sRCxOKXtNZS5nZXQoTS50ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZT1ELE1lLmdldChNLmRlcHRoVGV4dHVyZSkuX193ZWJnbFRleHR1cmU9Tjtjb25zdCBCPU1lLmdldChNKTtCLl9faGFzRXh0ZXJuYWxUZXh0dXJlcz0hMCxCLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXI9Tj09PXZvaWQgMCxCLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXJ8fEllLmhhcygiV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlIik9PT0hMCYmKGNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogUmVuZGVyLXRvLXRleHR1cmUgZXh0ZW5zaW9uIHdhcyBkaXNhYmxlZCBiZWNhdXNlIGFuIGV4dGVybmFsIHRleHR1cmUgd2FzIHByb3ZpZGVkIiksQi5fX3VzZVJlbmRlclRvVGV4dHVyZT0hMSl9LHRoaXMuc2V0UmVuZGVyVGFyZ2V0RnJhbWVidWZmZXI9ZnVuY3Rpb24oTSxEKXtjb25zdCBOPU1lLmdldChNKTtOLl9fd2ViZ2xGcmFtZWJ1ZmZlcj1ELE4uX191c2VEZWZhdWx0RnJhbWVidWZmZXI9RD09PXZvaWQgMH0sdGhpcy5zZXRSZW5kZXJUYXJnZXQ9ZnVuY3Rpb24oTSxEPTAsTj0wKXtGPU0sdz1ELGI9TjtsZXQgQj0hMCxMPW51bGwsSj0hMSxvZT0hMTtpZihNKXtjb25zdCBwZT1NZS5nZXQoTSk7aWYocGUuX191c2VEZWZhdWx0RnJhbWVidWZmZXIhPT12b2lkIDApU2UuYmluZEZyYW1lYnVmZmVyKFUuRlJBTUVCVUZGRVIsbnVsbCksQj0hMTtlbHNlIGlmKHBlLl9fd2ViZ2xGcmFtZWJ1ZmZlcj09PXZvaWQgMClBLnNldHVwUmVuZGVyVGFyZ2V0KE0pO2Vsc2UgaWYocGUuX19oYXNFeHRlcm5hbFRleHR1cmVzKUEucmViaW5kVGV4dHVyZXMoTSxNZS5nZXQoTS50ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSxNZS5nZXQoTS5kZXB0aFRleHR1cmUpLl9fd2ViZ2xUZXh0dXJlKTtlbHNlIGlmKE0uZGVwdGhCdWZmZXIpe2NvbnN0IG1lPU0uZGVwdGhUZXh0dXJlO2lmKHBlLl9fYm91bmREZXB0aFRleHR1cmUhPT1tZSl7aWYobWUhPT1udWxsJiZNZS5oYXMobWUpJiYoTS53aWR0aCE9PW1lLmltYWdlLndpZHRofHxNLmhlaWdodCE9PW1lLmltYWdlLmhlaWdodCkpdGhyb3cgbmV3IEVycm9yKCJXZWJHTFJlbmRlclRhcmdldDogQXR0YWNoZWQgRGVwdGhUZXh0dXJlIGlzIGluaXRpYWxpemVkIHRvIHRoZSBpbmNvcnJlY3Qgc2l6ZS4iKTtBLnNldHVwRGVwdGhSZW5kZXJidWZmZXIoTSl9fWNvbnN0IEFlPU0udGV4dHVyZTsoQWUuaXNEYXRhM0RUZXh0dXJlfHxBZS5pc0RhdGFBcnJheVRleHR1cmV8fEFlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSkmJihvZT0hMCk7Y29uc3QgQ2U9TWUuZ2V0KE0pLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtNLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0PyhBcnJheS5pc0FycmF5KENlW0RdKT9MPUNlW0RdW05dOkw9Q2VbRF0sSj0hMCk6TS5zYW1wbGVzPjAmJkEudXNlTXVsdGlzYW1wbGVkUlRUKE0pPT09ITE/TD1NZS5nZXQoTSkuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyOkFycmF5LmlzQXJyYXkoQ2UpP0w9Q2VbTl06TD1DZSxSLmNvcHkoTS52aWV3cG9ydCkscS5jb3B5KE0uc2Npc3Nvciksej1NLnNjaXNzb3JUZXN0fWVsc2UgUi5jb3B5KHhlKS5tdWx0aXBseVNjYWxhcihIKS5mbG9vcigpLHEuY29weShVZSkubXVsdGlwbHlTY2FsYXIoSCkuZmxvb3IoKSx6PVllO2lmKFNlLmJpbmRGcmFtZWJ1ZmZlcihVLkZSQU1FQlVGRkVSLEwpJiZCJiZTZS5kcmF3QnVmZmVycyhNLEwpLFNlLnZpZXdwb3J0KFIpLFNlLnNjaXNzb3IocSksU2Uuc2V0U2Npc3NvclRlc3QoeiksSil7Y29uc3QgcGU9TWUuZ2V0KE0udGV4dHVyZSk7VS5mcmFtZWJ1ZmZlclRleHR1cmUyRChVLkZSQU1FQlVGRkVSLFUuQ09MT1JfQVRUQUNITUVOVDAsVS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grRCxwZS5fX3dlYmdsVGV4dHVyZSxOKX1lbHNlIGlmKG9lKXtjb25zdCBwZT1NZS5nZXQoTS50ZXh0dXJlKSxBZT1EfHwwO1UuZnJhbWVidWZmZXJUZXh0dXJlTGF5ZXIoVS5GUkFNRUJVRkZFUixVLkNPTE9SX0FUVEFDSE1FTlQwLHBlLl9fd2ViZ2xUZXh0dXJlLE58fDAsQWUpfUU9LTF9LHRoaXMucmVhZFJlbmRlclRhcmdldFBpeGVscz1mdW5jdGlvbihNLEQsTixCLEwsSixvZSl7aWYoIShNJiZNLmlzV2ViR0xSZW5kZXJUYXJnZXQpKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuIik7cmV0dXJufWxldCBmZT1NZS5nZXQoTSkuX193ZWJnbEZyYW1lYnVmZmVyO2lmKE0uaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQmJm9lIT09dm9pZCAwJiYoZmU9ZmVbb2VdKSxmZSl7U2UuYmluZEZyYW1lYnVmZmVyKFUuRlJBTUVCVUZGRVIsZmUpO3RyeXtjb25zdCBwZT1NLnRleHR1cmUsQWU9cGUuZm9ybWF0LENlPXBlLnR5cGU7aWYoIU5lLnRleHR1cmVGb3JtYXRSZWFkYWJsZShBZSkpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBSR0JBIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgZm9ybWF0LiIpO3JldHVybn1pZighTmUudGV4dHVyZVR5cGVSZWFkYWJsZShDZSkpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBVbnNpZ25lZEJ5dGVUeXBlIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgdHlwZS4iKTtyZXR1cm59RD49MCYmRDw9TS53aWR0aC1CJiZOPj0wJiZOPD1NLmhlaWdodC1MJiZVLnJlYWRQaXhlbHMoRCxOLEIsTCxMZS5jb252ZXJ0KEFlKSxMZS5jb252ZXJ0KENlKSxKKX1maW5hbGx5e2NvbnN0IHBlPUYhPT1udWxsP01lLmdldChGKS5fX3dlYmdsRnJhbWVidWZmZXI6bnVsbDtTZS5iaW5kRnJhbWVidWZmZXIoVS5GUkFNRUJVRkZFUixwZSl9fX0sdGhpcy5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzQXN5bmM9YXN5bmMgZnVuY3Rpb24oTSxELE4sQixMLEosb2Upe2lmKCEoTSYmTS5pc1dlYkdMUmVuZGVyVGFyZ2V0KSl0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC4iKTtsZXQgZmU9TWUuZ2V0KE0pLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtpZihNLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0JiZvZSE9PXZvaWQgMCYmKGZlPWZlW29lXSksZmUpe2NvbnN0IHBlPU0udGV4dHVyZSxBZT1wZS5mb3JtYXQsQ2U9cGUudHlwZTtpZighTmUudGV4dHVyZUZvcm1hdFJlYWRhYmxlKEFlKSl0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsc0FzeW5jOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFJHQkEgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBmb3JtYXQuIik7aWYoIU5lLnRleHR1cmVUeXBlUmVhZGFibGUoQ2UpKXRocm93IG5ldyBFcnJvcigiVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzQXN5bmM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gVW5zaWduZWRCeXRlVHlwZSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIHR5cGUuIik7aWYoRD49MCYmRDw9TS53aWR0aC1CJiZOPj0wJiZOPD1NLmhlaWdodC1MKXtTZS5iaW5kRnJhbWVidWZmZXIoVS5GUkFNRUJVRkZFUixmZSk7Y29uc3QgbWU9VS5jcmVhdGVCdWZmZXIoKTtVLmJpbmRCdWZmZXIoVS5QSVhFTF9QQUNLX0JVRkZFUixtZSksVS5idWZmZXJEYXRhKFUuUElYRUxfUEFDS19CVUZGRVIsSi5ieXRlTGVuZ3RoLFUuU1RSRUFNX1JFQUQpLFUucmVhZFBpeGVscyhELE4sQixMLExlLmNvbnZlcnQoQWUpLExlLmNvbnZlcnQoQ2UpLDApO2NvbnN0IEhlPUYhPT1udWxsP01lLmdldChGKS5fX3dlYmdsRnJhbWVidWZmZXI6bnVsbDtTZS5iaW5kRnJhbWVidWZmZXIoVS5GUkFNRUJVRkZFUixIZSk7Y29uc3QgWmU9VS5mZW5jZVN5bmMoVS5TWU5DX0dQVV9DT01NQU5EU19DT01QTEVURSwwKTtyZXR1cm4gVS5mbHVzaCgpLGF3YWl0IGhhKFUsWmUsNCksVS5iaW5kQnVmZmVyKFUuUElYRUxfUEFDS19CVUZGRVIsbWUpLFUuZ2V0QnVmZmVyU3ViRGF0YShVLlBJWEVMX1BBQ0tfQlVGRkVSLDAsSiksVS5kZWxldGVCdWZmZXIobWUpLFUuZGVsZXRlU3luYyhaZSksSn1lbHNlIHRocm93IG5ldyBFcnJvcigiVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzQXN5bmM6IHJlcXVlc3RlZCByZWFkIGJvdW5kcyBhcmUgb3V0IG9mIHJhbmdlLiIpfX0sdGhpcy5jb3B5RnJhbWVidWZmZXJUb1RleHR1cmU9ZnVuY3Rpb24oTSxEPW51bGwsTj0wKXtNLmlzVGV4dHVyZSE9PSEwJiYoV24oIldlYkdMUmVuZGVyZXI6IGNvcHlGcmFtZWJ1ZmZlclRvVGV4dHVyZSBmdW5jdGlvbiBzaWduYXR1cmUgaGFzIGNoYW5nZWQuIiksRD1hcmd1bWVudHNbMF18fG51bGwsTT1hcmd1bWVudHNbMV0pO2NvbnN0IEI9TWF0aC5wb3coMiwtTiksTD1NYXRoLmZsb29yKE0uaW1hZ2Uud2lkdGgqQiksSj1NYXRoLmZsb29yKE0uaW1hZ2UuaGVpZ2h0KkIpLG9lPUQhPT1udWxsP0QueDowLGZlPUQhPT1udWxsP0QueTowO0Euc2V0VGV4dHVyZTJEKE0sMCksVS5jb3B5VGV4U3ViSW1hZ2UyRChVLlRFWFRVUkVfMkQsTiwwLDAsb2UsZmUsTCxKKSxTZS51bmJpbmRUZXh0dXJlKCl9LHRoaXMuY29weVRleHR1cmVUb1RleHR1cmU9ZnVuY3Rpb24oTSxELE49bnVsbCxCPW51bGwsTD0wKXtNLmlzVGV4dHVyZSE9PSEwJiYoV24oIldlYkdMUmVuZGVyZXI6IGNvcHlUZXh0dXJlVG9UZXh0dXJlIGZ1bmN0aW9uIHNpZ25hdHVyZSBoYXMgY2hhbmdlZC4iKSxCPWFyZ3VtZW50c1swXXx8bnVsbCxNPWFyZ3VtZW50c1sxXSxEPWFyZ3VtZW50c1syXSxMPWFyZ3VtZW50c1szXXx8MCxOPW51bGwpO2xldCBKLG9lLGZlLHBlLEFlLENlLG1lLEhlLFplO2NvbnN0IEplPU0uaXNDb21wcmVzc2VkVGV4dHVyZT9NLm1pcG1hcHNbTF06TS5pbWFnZTtOIT09bnVsbD8oSj1OLm1heC54LU4ubWluLngsb2U9Ti5tYXgueS1OLm1pbi55LGZlPU4uaXNCb3gzP04ubWF4LnotTi5taW4uejoxLHBlPU4ubWluLngsQWU9Ti5taW4ueSxDZT1OLmlzQm94Mz9OLm1pbi56OjApOihKPUplLndpZHRoLG9lPUplLmhlaWdodCxmZT1KZS5kZXB0aHx8MSxwZT0wLEFlPTAsQ2U9MCksQiE9PW51bGw/KG1lPUIueCxIZT1CLnksWmU9Qi56KToobWU9MCxIZT0wLFplPTApO2NvbnN0IEV0PUxlLmNvbnZlcnQoRC5mb3JtYXQpLGtlPUxlLmNvbnZlcnQoRC50eXBlKTtsZXQgdmU7RC5pc0RhdGEzRFRleHR1cmU/KEEuc2V0VGV4dHVyZTNEKEQsMCksdmU9VS5URVhUVVJFXzNEKTpELmlzRGF0YUFycmF5VGV4dHVyZXx8RC5pc0NvbXByZXNzZWRBcnJheVRleHR1cmU/KEEuc2V0VGV4dHVyZTJEQXJyYXkoRCwwKSx2ZT1VLlRFWFRVUkVfMkRfQVJSQVkpOihBLnNldFRleHR1cmUyRChELDApLHZlPVUuVEVYVFVSRV8yRCksVS5waXhlbFN0b3JlaShVLlVOUEFDS19GTElQX1lfV0VCR0wsRC5mbGlwWSksVS5waXhlbFN0b3JlaShVLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCxELnByZW11bHRpcGx5QWxwaGEpLFUucGl4ZWxTdG9yZWkoVS5VTlBBQ0tfQUxJR05NRU5ULEQudW5wYWNrQWxpZ25tZW50KTtjb25zdCBadD1VLmdldFBhcmFtZXRlcihVLlVOUEFDS19ST1dfTEVOR1RIKSxXZT1VLmdldFBhcmFtZXRlcihVLlVOUEFDS19JTUFHRV9IRUlHSFQpLEJ0PVUuZ2V0UGFyYW1ldGVyKFUuVU5QQUNLX1NLSVBfUElYRUxTKSxHbj1VLmdldFBhcmFtZXRlcihVLlVOUEFDS19TS0lQX1JPV1MpLHd0PVUuZ2V0UGFyYW1ldGVyKFUuVU5QQUNLX1NLSVBfSU1BR0VTKTtVLnBpeGVsU3RvcmVpKFUuVU5QQUNLX1JPV19MRU5HVEgsSmUud2lkdGgpLFUucGl4ZWxTdG9yZWkoVS5VTlBBQ0tfSU1BR0VfSEVJR0hULEplLmhlaWdodCksVS5waXhlbFN0b3JlaShVLlVOUEFDS19TS0lQX1BJWEVMUyxwZSksVS5waXhlbFN0b3JlaShVLlVOUEFDS19TS0lQX1JPV1MsQWUpLFUucGl4ZWxTdG9yZWkoVS5VTlBBQ0tfU0tJUF9JTUFHRVMsQ2UpO2NvbnN0IHRpPU0uaXNEYXRhQXJyYXlUZXh0dXJlfHxNLmlzRGF0YTNEVGV4dHVyZSxRZT1ELmlzRGF0YUFycmF5VGV4dHVyZXx8RC5pc0RhdGEzRFRleHR1cmU7aWYoTS5pc1JlbmRlclRhcmdldFRleHR1cmV8fE0uaXNEZXB0aFRleHR1cmUpe2NvbnN0IEh0PU1lLmdldChNKSxuaT1NZS5nZXQoRCksRHQ9TWUuZ2V0KEh0Ll9fcmVuZGVyVGFyZ2V0KSxhbj1NZS5nZXQobmkuX19yZW5kZXJUYXJnZXQpO1NlLmJpbmRGcmFtZWJ1ZmZlcihVLlJFQURfRlJBTUVCVUZGRVIsRHQuX193ZWJnbEZyYW1lYnVmZmVyKSxTZS5iaW5kRnJhbWVidWZmZXIoVS5EUkFXX0ZSQU1FQlVGRkVSLGFuLl9fd2ViZ2xGcmFtZWJ1ZmZlcik7Zm9yKGxldCBvbj0wO29uPGZlO29uKyspdGkmJlUuZnJhbWVidWZmZXJUZXh0dXJlTGF5ZXIoVS5SRUFEX0ZSQU1FQlVGRkVSLFUuQ09MT1JfQVRUQUNITUVOVDAsTWUuZ2V0KE0pLl9fd2ViZ2xUZXh0dXJlLEwsQ2Urb24pLE0uaXNEZXB0aFRleHR1cmU/KFFlJiZVLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyKFUuRFJBV19GUkFNRUJVRkZFUixVLkNPTE9SX0FUVEFDSE1FTlQwLE1lLmdldChEKS5fX3dlYmdsVGV4dHVyZSxMLFplK29uKSxVLmJsaXRGcmFtZWJ1ZmZlcihwZSxBZSxKLG9lLG1lLEhlLEosb2UsVS5ERVBUSF9CVUZGRVJfQklULFUuTkVBUkVTVCkpOlFlP1UuY29weVRleFN1YkltYWdlM0QodmUsTCxtZSxIZSxaZStvbixwZSxBZSxKLG9lKTpVLmNvcHlUZXhTdWJJbWFnZTJEKHZlLEwsbWUsSGUsWmUrb24scGUsQWUsSixvZSk7U2UuYmluZEZyYW1lYnVmZmVyKFUuUkVBRF9GUkFNRUJVRkZFUixudWxsKSxTZS5iaW5kRnJhbWVidWZmZXIoVS5EUkFXX0ZSQU1FQlVGRkVSLG51bGwpfWVsc2UgUWU/TS5pc0RhdGFUZXh0dXJlfHxNLmlzRGF0YTNEVGV4dHVyZT9VLnRleFN1YkltYWdlM0QodmUsTCxtZSxIZSxaZSxKLG9lLGZlLEV0LGtlLEplLmRhdGEpOkQuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlP1UuY29tcHJlc3NlZFRleFN1YkltYWdlM0QodmUsTCxtZSxIZSxaZSxKLG9lLGZlLEV0LEplLmRhdGEpOlUudGV4U3ViSW1hZ2UzRCh2ZSxMLG1lLEhlLFplLEosb2UsZmUsRXQsa2UsSmUpOk0uaXNEYXRhVGV4dHVyZT9VLnRleFN1YkltYWdlMkQoVS5URVhUVVJFXzJELEwsbWUsSGUsSixvZSxFdCxrZSxKZS5kYXRhKTpNLmlzQ29tcHJlc3NlZFRleHR1cmU/VS5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRChVLlRFWFRVUkVfMkQsTCxtZSxIZSxKZS53aWR0aCxKZS5oZWlnaHQsRXQsSmUuZGF0YSk6VS50ZXhTdWJJbWFnZTJEKFUuVEVYVFVSRV8yRCxMLG1lLEhlLEosb2UsRXQsa2UsSmUpO1UucGl4ZWxTdG9yZWkoVS5VTlBBQ0tfUk9XX0xFTkdUSCxadCksVS5waXhlbFN0b3JlaShVLlVOUEFDS19JTUFHRV9IRUlHSFQsV2UpLFUucGl4ZWxTdG9yZWkoVS5VTlBBQ0tfU0tJUF9QSVhFTFMsQnQpLFUucGl4ZWxTdG9yZWkoVS5VTlBBQ0tfU0tJUF9ST1dTLEduKSxVLnBpeGVsU3RvcmVpKFUuVU5QQUNLX1NLSVBfSU1BR0VTLHd0KSxMPT09MCYmRC5nZW5lcmF0ZU1pcG1hcHMmJlUuZ2VuZXJhdGVNaXBtYXAodmUpLFNlLnVuYmluZFRleHR1cmUoKX0sdGhpcy5jb3B5VGV4dHVyZVRvVGV4dHVyZTNEPWZ1bmN0aW9uKE0sRCxOPW51bGwsQj1udWxsLEw9MCl7cmV0dXJuIE0uaXNUZXh0dXJlIT09ITAmJihXbigiV2ViR0xSZW5kZXJlcjogY29weVRleHR1cmVUb1RleHR1cmUzRCBmdW5jdGlvbiBzaWduYXR1cmUgaGFzIGNoYW5nZWQuIiksTj1hcmd1bWVudHNbMF18fG51bGwsQj1hcmd1bWVudHNbMV18fG51bGwsTT1hcmd1bWVudHNbMl0sRD1hcmd1bWVudHNbM10sTD1hcmd1bWVudHNbNF18fDApLFduKCdXZWJHTFJlbmRlcmVyOiBjb3B5VGV4dHVyZVRvVGV4dHVyZTNEIGZ1bmN0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAiY29weVRleHR1cmVUb1RleHR1cmUiIGluc3RlYWQuJyksdGhpcy5jb3B5VGV4dHVyZVRvVGV4dHVyZShNLEQsTixCLEwpfSx0aGlzLmluaXRSZW5kZXJUYXJnZXQ9ZnVuY3Rpb24oTSl7TWUuZ2V0KE0pLl9fd2ViZ2xGcmFtZWJ1ZmZlcj09PXZvaWQgMCYmQS5zZXR1cFJlbmRlclRhcmdldChNKX0sdGhpcy5pbml0VGV4dHVyZT1mdW5jdGlvbihNKXtNLmlzQ3ViZVRleHR1cmU/QS5zZXRUZXh0dXJlQ3ViZShNLDApOk0uaXNEYXRhM0RUZXh0dXJlP0Euc2V0VGV4dHVyZTNEKE0sMCk6TS5pc0RhdGFBcnJheVRleHR1cmV8fE0uaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlP0Euc2V0VGV4dHVyZTJEQXJyYXkoTSwwKTpBLnNldFRleHR1cmUyRChNLDApLFNlLnVuYmluZFRleHR1cmUoKX0sdGhpcy5yZXNldFN0YXRlPWZ1bmN0aW9uKCl7dz0wLGI9MCxGPW51bGwsU2UucmVzZXQoKSxLZS5yZXNldCgpfSx0eXBlb2YgX19USFJFRV9ERVZUT09MU19fPCJ1IiYmX19USFJFRV9ERVZUT09MU19fLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCJvYnNlcnZlIix7ZGV0YWlsOnRoaXN9KSl9Z2V0IGNvb3JkaW5hdGVTeXN0ZW0oKXtyZXR1cm4gMmUzfWdldCBvdXRwdXRDb2xvclNwYWNlKCl7cmV0dXJuIHRoaXMuX291dHB1dENvbG9yU3BhY2V9c2V0IG91dHB1dENvbG9yU3BhY2UoZSl7dGhpcy5fb3V0cHV0Q29sb3JTcGFjZT1lO2NvbnN0IHQ9dGhpcy5nZXRDb250ZXh0KCk7dC5kcmF3aW5nQnVmZmVyQ29sb3JzcGFjZT1CZS5fZ2V0RHJhd2luZ0J1ZmZlckNvbG9yU3BhY2UoZSksdC51bnBhY2tDb2xvclNwYWNlPUJlLl9nZXRVbnBhY2tDb2xvclNwYWNlKCl9fWNsYXNzIFBzIGV4dGVuZHMgTXR7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuaXNTY2VuZT0hMCx0aGlzLnR5cGU9IlNjZW5lIix0aGlzLmJhY2tncm91bmQ9bnVsbCx0aGlzLmVudmlyb25tZW50PW51bGwsdGhpcy5mb2c9bnVsbCx0aGlzLmJhY2tncm91bmRCbHVycmluZXNzPTAsdGhpcy5iYWNrZ3JvdW5kSW50ZW5zaXR5PTEsdGhpcy5iYWNrZ3JvdW5kUm90YXRpb249bmV3IFh0LHRoaXMuZW52aXJvbm1lbnRJbnRlbnNpdHk9MSx0aGlzLmVudmlyb25tZW50Um90YXRpb249bmV3IFh0LHRoaXMub3ZlcnJpZGVNYXRlcmlhbD1udWxsLHR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX188InUiJiZfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoIm9ic2VydmUiLHtkZXRhaWw6dGhpc30pKX1jb3B5KGUsdCl7cmV0dXJuIHN1cGVyLmNvcHkoZSx0KSxlLmJhY2tncm91bmQhPT1udWxsJiYodGhpcy5iYWNrZ3JvdW5kPWUuYmFja2dyb3VuZC5jbG9uZSgpKSxlLmVudmlyb25tZW50IT09bnVsbCYmKHRoaXMuZW52aXJvbm1lbnQ9ZS5lbnZpcm9ubWVudC5jbG9uZSgpKSxlLmZvZyE9PW51bGwmJih0aGlzLmZvZz1lLmZvZy5jbG9uZSgpKSx0aGlzLmJhY2tncm91bmRCbHVycmluZXNzPWUuYmFja2dyb3VuZEJsdXJyaW5lc3MsdGhpcy5iYWNrZ3JvdW5kSW50ZW5zaXR5PWUuYmFja2dyb3VuZEludGVuc2l0eSx0aGlzLmJhY2tncm91bmRSb3RhdGlvbi5jb3B5KGUuYmFja2dyb3VuZFJvdGF0aW9uKSx0aGlzLmVudmlyb25tZW50SW50ZW5zaXR5PWUuZW52aXJvbm1lbnRJbnRlbnNpdHksdGhpcy5lbnZpcm9ubWVudFJvdGF0aW9uLmNvcHkoZS5lbnZpcm9ubWVudFJvdGF0aW9uKSxlLm92ZXJyaWRlTWF0ZXJpYWwhPT1udWxsJiYodGhpcy5vdmVycmlkZU1hdGVyaWFsPWUub3ZlcnJpZGVNYXRlcmlhbC5jbG9uZSgpKSx0aGlzLm1hdHJpeEF1dG9VcGRhdGU9ZS5tYXRyaXhBdXRvVXBkYXRlLHRoaXN9dG9KU09OKGUpe2NvbnN0IHQ9c3VwZXIudG9KU09OKGUpO3JldHVybiB0aGlzLmZvZyE9PW51bGwmJih0Lm9iamVjdC5mb2c9dGhpcy5mb2cudG9KU09OKCkpLHRoaXMuYmFja2dyb3VuZEJsdXJyaW5lc3M+MCYmKHQub2JqZWN0LmJhY2tncm91bmRCbHVycmluZXNzPXRoaXMuYmFja2dyb3VuZEJsdXJyaW5lc3MpLHRoaXMuYmFja2dyb3VuZEludGVuc2l0eSE9PTEmJih0Lm9iamVjdC5iYWNrZ3JvdW5kSW50ZW5zaXR5PXRoaXMuYmFja2dyb3VuZEludGVuc2l0eSksdC5vYmplY3QuYmFja2dyb3VuZFJvdGF0aW9uPXRoaXMuYmFja2dyb3VuZFJvdGF0aW9uLnRvQXJyYXkoKSx0aGlzLmVudmlyb25tZW50SW50ZW5zaXR5IT09MSYmKHQub2JqZWN0LmVudmlyb25tZW50SW50ZW5zaXR5PXRoaXMuZW52aXJvbm1lbnRJbnRlbnNpdHkpLHQub2JqZWN0LmVudmlyb25tZW50Um90YXRpb249dGhpcy5lbnZpcm9ubWVudFJvdGF0aW9uLnRvQXJyYXkoKSx0fX1jbGFzcyBHdCBleHRlbmRzIFN0e2NvbnN0cnVjdG9yKGUsdCxuLHI9MSl7c3VwZXIoZSx0LG4pLHRoaXMuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU9ITAsdGhpcy5tZXNoUGVyQXR0cmlidXRlPXJ9Y29weShlKXtyZXR1cm4gc3VwZXIuY29weShlKSx0aGlzLm1lc2hQZXJBdHRyaWJ1dGU9ZS5tZXNoUGVyQXR0cmlidXRlLHRoaXN9dG9KU09OKCl7Y29uc3QgZT1zdXBlci50b0pTT04oKTtyZXR1cm4gZS5tZXNoUGVyQXR0cmlidXRlPXRoaXMubWVzaFBlckF0dHJpYnV0ZSxlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlPSEwLGV9fWNsYXNzIFJpIGV4dGVuZHMgWm57c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIlBvaW50c01hdGVyaWFsIn1jb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuaXNQb2ludHNNYXRlcmlhbD0hMCx0aGlzLmNvbG9yPW5ldyBWZSgxNjc3NzIxNSksdGhpcy5tYXA9bnVsbCx0aGlzLmFscGhhTWFwPW51bGwsdGhpcy5zaXplPTEsdGhpcy5zaXplQXR0ZW51YXRpb249ITAsdGhpcy5mb2c9ITAsdGhpcy5zZXRWYWx1ZXMoZSl9Y29weShlKXtyZXR1cm4gc3VwZXIuY29weShlKSx0aGlzLmNvbG9yLmNvcHkoZS5jb2xvciksdGhpcy5tYXA9ZS5tYXAsdGhpcy5hbHBoYU1hcD1lLmFscGhhTWFwLHRoaXMuc2l6ZT1lLnNpemUsdGhpcy5zaXplQXR0ZW51YXRpb249ZS5zaXplQXR0ZW51YXRpb24sdGhpcy5mb2c9ZS5mb2csdGhpc319Y29uc3QgRHM9bmV3IHN0LHByPW5ldyBEcixDaT1uZXcgbGksUGk9bmV3IE87Y2xhc3MgbXIgZXh0ZW5kcyBNdHtjb25zdHJ1Y3RvcihlPW5ldyBDdCx0PW5ldyBSaSl7c3VwZXIoKSx0aGlzLmlzUG9pbnRzPSEwLHRoaXMudHlwZT0iUG9pbnRzIix0aGlzLmdlb21ldHJ5PWUsdGhpcy5tYXRlcmlhbD10LHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCl9Y29weShlLHQpe3JldHVybiBzdXBlci5jb3B5KGUsdCksdGhpcy5tYXRlcmlhbD1BcnJheS5pc0FycmF5KGUubWF0ZXJpYWwpP2UubWF0ZXJpYWwuc2xpY2UoKTplLm1hdGVyaWFsLHRoaXMuZ2VvbWV0cnk9ZS5nZW9tZXRyeSx0aGlzfXJheWNhc3QoZSx0KXtjb25zdCBuPXRoaXMuZ2VvbWV0cnkscj10aGlzLm1hdHJpeFdvcmxkLHM9ZS5wYXJhbXMuUG9pbnRzLnRocmVzaG9sZCxhPW4uZHJhd1JhbmdlO2lmKG4uYm91bmRpbmdTcGhlcmU9PT1udWxsJiZuLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLENpLmNvcHkobi5ib3VuZGluZ1NwaGVyZSksQ2kuYXBwbHlNYXRyaXg0KHIpLENpLnJhZGl1cys9cyxlLnJheS5pbnRlcnNlY3RzU3BoZXJlKENpKT09PSExKXJldHVybjtEcy5jb3B5KHIpLmludmVydCgpLHByLmNvcHkoZS5yYXkpLmFwcGx5TWF0cml4NChEcyk7Y29uc3Qgbz1zLygodGhpcy5zY2FsZS54K3RoaXMuc2NhbGUueSt0aGlzLnNjYWxlLnopLzMpLGw9bypvLGM9bi5pbmRleCxkPW4uYXR0cmlidXRlcy5wb3NpdGlvbjtpZihjIT09bnVsbCl7Y29uc3QgZj1NYXRoLm1heCgwLGEuc3RhcnQpLHA9TWF0aC5taW4oYy5jb3VudCxhLnN0YXJ0K2EuY291bnQpO2ZvcihsZXQgXz1mLHg9cDtfPHg7XysrKXtjb25zdCBtPWMuZ2V0WChfKTtQaS5mcm9tQnVmZmVyQXR0cmlidXRlKGQsbSksTHMoUGksbSxsLHIsZSx0LHRoaXMpfX1lbHNle2NvbnN0IGY9TWF0aC5tYXgoMCxhLnN0YXJ0KSxwPU1hdGgubWluKGQuY291bnQsYS5zdGFydCthLmNvdW50KTtmb3IobGV0IF89Zix4PXA7Xzx4O18rKylQaS5mcm9tQnVmZmVyQXR0cmlidXRlKGQsXyksTHMoUGksXyxsLHIsZSx0LHRoaXMpfX11cGRhdGVNb3JwaFRhcmdldHMoKXtjb25zdCB0PXRoaXMuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLG49T2JqZWN0LmtleXModCk7aWYobi5sZW5ndGg+MCl7Y29uc3Qgcj10W25bMF1dO2lmKHIhPT12b2lkIDApe3RoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzPVtdLHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5PXt9O2ZvcihsZXQgcz0wLGE9ci5sZW5ndGg7czxhO3MrKyl7Y29uc3Qgbz1yW3NdLm5hbWV8fFN0cmluZyhzKTt0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKDApLHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5W29dPXN9fX19fWZ1bmN0aW9uIExzKGksZSx0LG4scixzLGEpe2NvbnN0IG89cHIuZGlzdGFuY2VTcVRvUG9pbnQoaSk7aWYobzx0KXtjb25zdCBsPW5ldyBPO3ByLmNsb3Nlc3RQb2ludFRvUG9pbnQoaSxsKSxsLmFwcGx5TWF0cml4NChuKTtjb25zdCBjPXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKGwpO2lmKGM8ci5uZWFyfHxjPnIuZmFyKXJldHVybjtzLnB1c2goe2Rpc3RhbmNlOmMsZGlzdGFuY2VUb1JheTpNYXRoLnNxcnQobykscG9pbnQ6bCxpbmRleDplLGZhY2U6bnVsbCxmYWNlSW5kZXg6bnVsbCxiYXJ5Y29vcmQ6bnVsbCxvYmplY3Q6YX0pfX1jbGFzcyBXdSBleHRlbmRzIHZ0e2NvbnN0cnVjdG9yKGUsdCxuLHIscyxhLG8sbCxjKXtzdXBlcihlLHQsbixyLHMsYSxvLGwsYyksdGhpcy5pc0NhbnZhc1RleHR1cmU9ITAsdGhpcy5uZWVkc1VwZGF0ZT0hMH19Y2xhc3MgVXMgZXh0ZW5kcyBDdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5PSEwLHRoaXMudHlwZT0iSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkiLHRoaXMuaW5zdGFuY2VDb3VudD0xLzB9Y29weShlKXtyZXR1cm4gc3VwZXIuY29weShlKSx0aGlzLmluc3RhbmNlQ291bnQ9ZS5pbnN0YW5jZUNvdW50LHRoaXN9dG9KU09OKCl7Y29uc3QgZT1zdXBlci50b0pTT04oKTtyZXR1cm4gZS5pbnN0YW5jZUNvdW50PXRoaXMuaW5zdGFuY2VDb3VudCxlLmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnk9ITAsZX19dHlwZW9mIF9fVEhSRUVfREVWVE9PTFNfXzwidSImJl9fVEhSRUVfREVWVE9PTFNfXy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgicmVnaXN0ZXIiLHtkZXRhaWw6e3JldmlzaW9uOk5pfX0pKSx0eXBlb2Ygd2luZG93PCJ1IiYmKHdpbmRvdy5fX1RIUkVFX18/Y29uc29sZS53YXJuKCJXQVJOSU5HOiBNdWx0aXBsZSBpbnN0YW5jZXMgb2YgVGhyZWUuanMgYmVpbmcgaW1wb3J0ZWQuIik6d2luZG93Ll9fVEhSRUVfXz1OaSk7Y29uc3QgZ3I9MTAwLERpPW5ldyBNYXA7bGV0IFh1PTA7Y29uc3QgRnM9dHlwZW9mIGdsb2JhbFRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lPT0iZnVuY3Rpb24iP2k9Pmdsb2JhbFRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGkpOmk9Pntjb25zdCBlPSsrWHUsdD1zZXRUaW1lb3V0KCgpPT57RGkuZGVsZXRlKGUpLGkocGVyZm9ybWFuY2Uubm93KCkpfSwxNik7cmV0dXJuIERpLnNldChlLHQpLGV9LHF1PXR5cGVvZiBnbG9iYWxUaGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lPT0iZnVuY3Rpb24iP2k9Pmdsb2JhbFRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaSk6aT0+e2NvbnN0IGU9RGkuZ2V0KGkpO2UmJihjbGVhclRpbWVvdXQoZSksRGkuZGVsZXRlKGkpKX07ZnVuY3Rpb24gTGkoaSxlPWkpe2lmKHR5cGVvZiBkb2N1bWVudDwidSImJmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpe2NvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIik7dC53aWR0aD1pLHQuaGVpZ2h0PWU7Y29uc3Qgbj10LmdldENvbnRleHQoIjJkIik7aWYoIW4pdGhyb3cgbmV3IEVycm9yKCJVbmFibGUgdG8gZ2V0IDJEIGNvbnRleHQiKTtyZXR1cm57Y2FudmFzOnQsY3R4Om59fWlmKHR5cGVvZiBPZmZzY3JlZW5DYW52YXM8InUiKXtjb25zdCB0PW5ldyBPZmZzY3JlZW5DYW52YXMoaSxlKSxuPXQuZ2V0Q29udGV4dCgiMmQiKTtpZighbil0aHJvdyBuZXcgRXJyb3IoIlVuYWJsZSB0byBnZXQgMkQgY29udGV4dCIpO3JldHVybntjYW52YXM6dCxjdHg6bn19dGhyb3cgbmV3IEVycm9yKCJDYW52YXMgbm90IHN1cHBvcnRlZCIpfWZ1bmN0aW9uIFVpKGkpe3JldHVybiBuZXcgV3UoaSl9ZnVuY3Rpb24gSXMoKXtjb25zdHtjYW52YXM6ZSxjdHg6dH09TGkoMzIsMzIpLG49dC5jcmVhdGVSYWRpYWxHcmFkaWVudCgzMi8yLDMyLzIsMCwzMi8yLDMyLzIsMzIvMik7bi5hZGRDb2xvclN0b3AoMCwicmdiYSgyNTUsIDI1NSwgMjU1LCAxKSIpLG4uYWRkQ29sb3JTdG9wKC40LCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSkiKSxuLmFkZENvbG9yU3RvcCgxLCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDApIiksdC5maWxsU3R5bGU9bix0LmZpbGxSZWN0KDAsMCwzMiwzMik7Y29uc3Qgcj1VaShlKTtyZXR1cm4gci5uZWVkc1VwZGF0ZT0hMCxyfWZ1bmN0aW9uIFl1KCl7Y29uc3R7Y2FudmFzOmUsY3R4OnR9PUxpKDE2LDE2KSxuPXQuY3JlYXRlUmFkaWFsR3JhZGllbnQoMTYvMiwxNi8yLDAsMTYvMiwxNi8yLDE2LzIpO24uYWRkQ29sb3JTdG9wKDAsInJnYmEoMjU1LCAyNTUsIDI1NSwgMSkiKSxuLmFkZENvbG9yU3RvcCguMywicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjYpIiksbi5hZGRDb2xvclN0b3AoMSwicmdiYSgyNTUsIDI1NSwgMjU1LCAwKSIpLHQuZmlsbFN0eWxlPW4sdC5maWxsUmVjdCgwLDAsMTYsMTYpO2NvbnN0IHI9VWkoZSk7cmV0dXJuIHIubmVlZHNVcGRhdGU9ITAscn1jb25zdCBfcj1gCiAgdmFyeWluZyB2ZWMyIHZVdjsKICB2b2lkIG1haW4oKSB7CiAgICB2VXYgPSB1djsKICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7CiAgfQpgO2NsYXNzICR1e2NvbnN0cnVjdG9yKGUpe3RoaXMuY2FudmFzPWUuY2FudmFzLHRoaXMudmlld3BvcnRXaWR0aD1lLnZpZXdwb3J0V2lkdGgsdGhpcy52aWV3cG9ydEhlaWdodD1lLnZpZXdwb3J0SGVpZ2h0LHRoaXMuZGV2aWNlUGl4ZWxSYXRpbz1lLmRldmljZVBpeGVsUmF0aW8/PzEsdGhpcy5pc01vYmlsZT1lLmlzTW9iaWxlPz8hMSx0aGlzLnZpZXdXaWR0aD10aGlzLmNvbXB1dGVWaWV3V2lkdGgoZ3IpLHRoaXMudmlld0hlaWdodD1ncix0aGlzLmNhbWVyYT10aGlzLmNyZWF0ZUNhbWVyYSgpLHRoaXMucmVuZGVyZXI9dGhpcy5jcmVhdGVSZW5kZXJlcigpLHRoaXMuc2NlbmU9bmV3IFBzLHRoaXMuYW5pbWF0aW9uRnJhbWU9bnVsbCx0aGlzLmxhc3RUaW1lc3RhbXA9MCx0aGlzLmN1cnJlbnRFZmZlY3Q9Im5vbmUiLHRoaXMuYWN0aXZlRWZmZWN0PW51bGwsdGhpcy5vcGFjaXR5PTEwMCx0aGlzLmVmZmVjdEV4dHJhcz17fSx0aGlzLmxhc3RBcHBsaWVkRXh0cmFzPXt9LHRoaXMuc25vd1N1cmZhY2VzPVtdLHRoaXMuc21vZ092ZXJsYXk9bnVsbCx0aGlzLndpbmRvd0Ryb3BsZXRzT3ZlcmxheT1udWxsLHRoaXMubGlnaHRuaW5nT3ZlcmxheT1udWxsLHRoaXMuYXVyb3JhT3ZlcmxheT1udWxsLHRoaXMucmVuZGVyVGFyZ2V0PW51bGwsdGhpcy5tYXNrU2NlbmU9bnVsbCx0aGlzLm1hc2tDYW1lcmE9bnVsbCx0aGlzLm1hc2tRdWFkPW51bGwsdGhpcy5yZW5kZXJMb29wPXQ9PnRoaXMucmVuZGVyRnJhbWUodCl9Y29tcHV0ZVZpZXdXaWR0aChlKXtyZXR1cm4gZSoodGhpcy52aWV3cG9ydFdpZHRoL01hdGgubWF4KDEsdGhpcy52aWV3cG9ydEhlaWdodCkpfWNyZWF0ZUNhbWVyYSgpe2NvbnN0IGU9dGhpcy52aWV3V2lkdGgvMix0PXRoaXMudmlld0hlaWdodC8yLG49bmV3IHJyKC1lLGUsdCwtdCwtMWUzLDFlMyk7cmV0dXJuIG4ucG9zaXRpb24uej0xMCxufWNyZWF0ZVJlbmRlcmVyKCl7Y29uc3QgZT1uZXcga3Uoe2NhbnZhczp0aGlzLmNhbnZhcyxhbHBoYTohMCxhbnRpYWxpYXM6IXRoaXMuaXNNb2JpbGUscG93ZXJQcmVmZXJlbmNlOiJoaWdoLXBlcmZvcm1hbmNlIixzdGVuY2lsOiExLGRlcHRoOiExLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMX0pO3JldHVybiBlLnNldFBpeGVsUmF0aW8oTWF0aC5taW4odGhpcy5kZXZpY2VQaXhlbFJhdGlvfHwxLHRoaXMuaXNNb2JpbGU/MToxLjUpKSxlLnNldFNpemUodGhpcy52aWV3cG9ydFdpZHRoLHRoaXMudmlld3BvcnRIZWlnaHQsITEpLGV9c3RhcnQoZSx0LG49e30pe3RoaXMub3BhY2l0eT1NYXRoLm1heCgwLE1hdGgubWluKDEwMCx0KSksdGhpcy5lZmZlY3RFeHRyYXM9bjtjb25zdCByPXRoaXMuZWZmZWN0RXh0cmFzLm1vb25Qb3NpdGlvbixzPXRoaXMubGFzdEFwcGxpZWRFeHRyYXMubW9vblBvc2l0aW9uLGE9cj8ueCE9PXM/Lnh8fHI/LnkhPT1zPy55LG89dGhpcy5sYXN0QXBwbGllZEV4dHJhcy53aW5kQmVhcmluZyE9PXRoaXMuZWZmZWN0RXh0cmFzLndpbmRCZWFyaW5nfHx0aGlzLmxhc3RBcHBsaWVkRXh0cmFzLndpbmRTcGVlZEttaCE9PXRoaXMuZWZmZWN0RXh0cmFzLndpbmRTcGVlZEttaCxsPXRoaXMubGFzdEFwcGxpZWRFeHRyYXMuc25vd0FjY3VtdWxhdGlvbiE9PXRoaXMuZWZmZWN0RXh0cmFzLnNub3dBY2N1bXVsYXRpb258fHRoaXMubGFzdEFwcGxpZWRFeHRyYXMubWF0cml4UmFpbkNvbG9yIT09dGhpcy5lZmZlY3RFeHRyYXMubWF0cml4UmFpbkNvbG9yfHx0aGlzLmxhc3RBcHBsaWVkRXh0cmFzLnNtb2dBY3RpdmUhPT10aGlzLmVmZmVjdEV4dHJhcy5zbW9nQWN0aXZlfHx0aGlzLmxhc3RBcHBsaWVkRXh0cmFzLndpbmRvd0Ryb3BsZXRzIT09dGhpcy5lZmZlY3RFeHRyYXMud2luZG93RHJvcGxldHN8fHRoaXMubGFzdEFwcGxpZWRFeHRyYXMubGlnaHRuaW5nT3ZlcmxheSE9PXRoaXMuZWZmZWN0RXh0cmFzLmxpZ2h0bmluZ092ZXJsYXl8fHRoaXMubGFzdEFwcGxpZWRFeHRyYXMuY2xvdWRDb3ZlcmFnZSE9PXRoaXMuZWZmZWN0RXh0cmFzLmNsb3VkQ292ZXJhZ2V8fHRoaXMubGFzdEFwcGxpZWRFeHRyYXMudGhlbWVNb2RlIT09dGhpcy5lZmZlY3RFeHRyYXMudGhlbWVNb2RlfHx0aGlzLmxhc3RBcHBsaWVkRXh0cmFzLmNsb3VkU3BlZWRNdWx0aXBsaWVyIT09dGhpcy5lZmZlY3RFeHRyYXMuY2xvdWRTcGVlZE11bHRpcGxpZXJ8fHRoaXMubGFzdEFwcGxpZWRFeHRyYXMuYXVyb3JhT3ZlcmxheSE9PXRoaXMuZWZmZWN0RXh0cmFzLmF1cm9yYU92ZXJsYXl8fHRoaXMubGFzdEFwcGxpZWRFeHRyYXMuYXVyb3JhVmlzaWJpbGl0eVNjb3JlIT09dGhpcy5lZmZlY3RFeHRyYXMuYXVyb3JhVmlzaWJpbGl0eVNjb3JlfHx0aGlzLmxhc3RBcHBsaWVkRXh0cmFzLmF1cm9yYVZhcmlhbnQhPT10aGlzLmVmZmVjdEV4dHJhcy5hdXJvcmFWYXJpYW50fHxhfHxvO2lmKHRoaXMuY3VycmVudEVmZmVjdD09PWUmJnRoaXMuYWN0aXZlRWZmZWN0JiYhbCl7dGhpcy5hY3RpdmVFZmZlY3Quc2V0T3BhY2l0eSh0aGlzLm9wYWNpdHkpLHRoaXMudXBkYXRlU21vZ092ZXJsYXkoKSx0aGlzLnVwZGF0ZVdpbmRvd0Ryb3BsZXRzT3ZlcmxheSgpLHRoaXMudXBkYXRlTGlnaHRuaW5nT3ZlcmxheSgpLHRoaXMudXBkYXRlQXVyb3JhT3ZlcmxheSgpLHRoaXMuc3RhcnRMb29wKCk7cmV0dXJufXRoaXMuc2V0RWZmZWN0KGUpfXN0b3AoKXt0aGlzLmRpc3Bvc2VTbW9nT3ZlcmxheSgpLHRoaXMuZGlzcG9zZVdpbmRvd0Ryb3BsZXRzT3ZlcmxheSgpLHRoaXMuZGlzcG9zZUxpZ2h0bmluZ092ZXJsYXkoKSx0aGlzLmRpc3Bvc2VBdXJvcmFPdmVybGF5KCksdGhpcy5kaXNwb3NlQWN0aXZlRWZmZWN0KCksdGhpcy5jdXJyZW50RWZmZWN0PSJub25lIix0aGlzLnN0b3BMb29wKCksdGhpcy5sYXN0QXBwbGllZEV4dHJhcz17fX11cGRhdGVTbW9nT3ZlcmxheSgpe2NvbnN0IGU9ISF0aGlzLmVmZmVjdEV4dHJhcy5zbW9nQWN0aXZlO2UmJiF0aGlzLnNtb2dPdmVybGF5Pyh0aGlzLnNtb2dPdmVybGF5PWxoKHRoaXMpLHRoaXMuc2NlbmUuYWRkKHRoaXMuc21vZ092ZXJsYXkuZ3JvdXApKTohZSYmdGhpcy5zbW9nT3ZlcmxheT90aGlzLmRpc3Bvc2VTbW9nT3ZlcmxheSgpOnRoaXMuc21vZ092ZXJsYXkmJnRoaXMuc21vZ092ZXJsYXkuc2V0T3BhY2l0eSh0aGlzLm9wYWNpdHkpfWRpc3Bvc2VTbW9nT3ZlcmxheSgpe3RoaXMuc21vZ092ZXJsYXkmJih0aGlzLnNjZW5lLnJlbW92ZSh0aGlzLnNtb2dPdmVybGF5Lmdyb3VwKSx0aGlzLnNtb2dPdmVybGF5LmRpc3Bvc2UoKSx0aGlzLnNtb2dPdmVybGF5PW51bGwpfXVwZGF0ZVdpbmRvd0Ryb3BsZXRzT3ZlcmxheSgpe2NvbnN0IGU9ISF0aGlzLmVmZmVjdEV4dHJhcy53aW5kb3dEcm9wbGV0cztlJiYhdGhpcy53aW5kb3dEcm9wbGV0c092ZXJsYXk/KHRoaXMud2luZG93RHJvcGxldHNPdmVybGF5PW9oKHRoaXMpLHRoaXMuc2NlbmUuYWRkKHRoaXMud2luZG93RHJvcGxldHNPdmVybGF5Lmdyb3VwKSk6IWUmJnRoaXMud2luZG93RHJvcGxldHNPdmVybGF5P3RoaXMuZGlzcG9zZVdpbmRvd0Ryb3BsZXRzT3ZlcmxheSgpOnRoaXMud2luZG93RHJvcGxldHNPdmVybGF5JiZ0aGlzLndpbmRvd0Ryb3BsZXRzT3ZlcmxheS5zZXRPcGFjaXR5KHRoaXMub3BhY2l0eSl9ZGlzcG9zZVdpbmRvd0Ryb3BsZXRzT3ZlcmxheSgpe3RoaXMud2luZG93RHJvcGxldHNPdmVybGF5JiYodGhpcy5zY2VuZS5yZW1vdmUodGhpcy53aW5kb3dEcm9wbGV0c092ZXJsYXkuZ3JvdXApLHRoaXMud2luZG93RHJvcGxldHNPdmVybGF5LmRpc3Bvc2UoKSx0aGlzLndpbmRvd0Ryb3BsZXRzT3ZlcmxheT1udWxsKX11cGRhdGVMaWdodG5pbmdPdmVybGF5KCl7Y29uc3QgZT10aGlzLmN1cnJlbnRFZmZlY3Q9PT0icmFpbl9zdG9ybSImJiEhdGhpcy5lZmZlY3RFeHRyYXMubGlnaHRuaW5nRGF0YTtlJiYhdGhpcy5saWdodG5pbmdPdmVybGF5Pyh0aGlzLmxpZ2h0bmluZ092ZXJsYXk9enMoe3ZpZXdXaWR0aDp0aGlzLnZpZXdXaWR0aCx2aWV3SGVpZ2h0OnRoaXMudmlld0hlaWdodCxvcGFjaXR5OnRoaXMub3BhY2l0eSxpc01vYmlsZTp0aGlzLmlzTW9iaWxlfSksdGhpcy5zY2VuZS5hZGQodGhpcy5saWdodG5pbmdPdmVybGF5Lmdyb3VwKSk6IWUmJnRoaXMubGlnaHRuaW5nT3ZlcmxheT90aGlzLmRpc3Bvc2VMaWdodG5pbmdPdmVybGF5KCk6dGhpcy5saWdodG5pbmdPdmVybGF5JiZ0aGlzLmxpZ2h0bmluZ092ZXJsYXkuc2V0T3BhY2l0eSh0aGlzLm9wYWNpdHkpfWRpc3Bvc2VMaWdodG5pbmdPdmVybGF5KCl7dGhpcy5saWdodG5pbmdPdmVybGF5JiYodGhpcy5zY2VuZS5yZW1vdmUodGhpcy5saWdodG5pbmdPdmVybGF5Lmdyb3VwKSx0aGlzLmxpZ2h0bmluZ092ZXJsYXkuZGlzcG9zZSgpLHRoaXMubGlnaHRuaW5nT3ZlcmxheT1udWxsKX11cGRhdGVBdXJvcmFPdmVybGF5KCl7Y29uc3QgZT10aGlzLmN1cnJlbnRFZmZlY3Q9PT0ic3RhcnMiJiYhIXRoaXMuZWZmZWN0RXh0cmFzLmF1cm9yYU92ZXJsYXksdD1NYXRoLm1heCgwLE1hdGgubWluKDEsdGhpcy5lZmZlY3RFeHRyYXMuYXVyb3JhVmlzaWJpbGl0eVNjb3JlPz8wKSksbj10aGlzLmVmZmVjdEV4dHJhcy5hdXJvcmFWYXJpYW50fHwiYmFuZHMiLHI9dGhpcy5hdXJvcmFPdmVybGF5JiZ0aGlzLmxhc3RBcHBsaWVkRXh0cmFzLmF1cm9yYVZhcmlhbnQhPT1uO2UmJighdGhpcy5hdXJvcmFPdmVybGF5fHxyKT8odGhpcy5hdXJvcmFPdmVybGF5JiZ0aGlzLmRpc3Bvc2VBdXJvcmFPdmVybGF5KCksdGhpcy5hdXJvcmFPdmVybGF5PXVoKHRoaXMsdCxuKSx0aGlzLnNjZW5lLmFkZCh0aGlzLmF1cm9yYU92ZXJsYXkuZ3JvdXApKTohZSYmdGhpcy5hdXJvcmFPdmVybGF5P3RoaXMuZGlzcG9zZUF1cm9yYU92ZXJsYXkoKTp0aGlzLmF1cm9yYU92ZXJsYXkmJih0aGlzLmF1cm9yYU92ZXJsYXkuc2V0T3BhY2l0eSh0aGlzLm9wYWNpdHkpLHRoaXMuYXVyb3JhT3ZlcmxheS5zZXRWaXNpYmlsaXR5U2NvcmU/Lih0KSl9ZGlzcG9zZUF1cm9yYU92ZXJsYXkoKXt0aGlzLmF1cm9yYU92ZXJsYXkmJih0aGlzLnNjZW5lLnJlbW92ZSh0aGlzLmF1cm9yYU92ZXJsYXkuZ3JvdXApLHRoaXMuYXVyb3JhT3ZlcmxheS5kaXNwb3NlKCksdGhpcy5hdXJvcmFPdmVybGF5PW51bGwpfXNldE9wYWNpdHkoZSl7dGhpcy5vcGFjaXR5PU1hdGgubWF4KDAsTWF0aC5taW4oMTAwLGUpKSx0aGlzLmFjdGl2ZUVmZmVjdD8uc2V0T3BhY2l0eSh0aGlzLm9wYWNpdHkpfXNldFNub3dTdXJmYWNlcyhlKXt0aGlzLnNub3dTdXJmYWNlcz1lfHxbXSx0aGlzLmFjdGl2ZUVmZmVjdD8uc2V0U25vd1N1cmZhY2VzPy4odGhpcy5zbm93U3VyZmFjZXMpfWdldExhc3RBcHBsaWVkRXh0cmFzKCl7cmV0dXJuey4uLnRoaXMubGFzdEFwcGxpZWRFeHRyYXN9fXJlc2l6ZShlKXtpZih0aGlzLnZpZXdwb3J0V2lkdGg9ZS52aWV3cG9ydFdpZHRoLHRoaXMudmlld3BvcnRIZWlnaHQ9ZS52aWV3cG9ydEhlaWdodCx0aGlzLnJlbmRlclRhcmdldCYmdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZSh0aGlzLnZpZXdwb3J0V2lkdGgsdGhpcy52aWV3cG9ydEhlaWdodCksdGhpcy5kZXZpY2VQaXhlbFJhdGlvPWUuZGV2aWNlUGl4ZWxSYXRpbz8/MSx0aGlzLmlzTW9iaWxlPWUuaXNNb2JpbGU/PyExLHRoaXMudmlld1dpZHRoPXRoaXMuY29tcHV0ZVZpZXdXaWR0aChnciksdGhpcy5jYW1lcmE9dGhpcy5jcmVhdGVDYW1lcmEoKSx0aGlzLnJlbmRlcmVyLnNldFBpeGVsUmF0aW8oTWF0aC5taW4odGhpcy5kZXZpY2VQaXhlbFJhdGlvfHwxLHRoaXMuaXNNb2JpbGU/MToxLjUpKSx0aGlzLnJlbmRlcmVyLnNldFNpemUodGhpcy52aWV3cG9ydFdpZHRoLHRoaXMudmlld3BvcnRIZWlnaHQsITEpLHRoaXMuYWN0aXZlRWZmZWN0Py5vblJlc2l6ZSl0aGlzLmFjdGl2ZUVmZmVjdC5vblJlc2l6ZSh0aGlzLnZpZXdXaWR0aCx0aGlzLnZpZXdIZWlnaHQsdGhpcy5pc01vYmlsZSx0aGlzLnZpZXdwb3J0V2lkdGgsdGhpcy52aWV3cG9ydEhlaWdodCksdGhpcy5hY3RpdmVFZmZlY3Quc2V0U25vd1N1cmZhY2VzPy4odGhpcy5zbm93U3VyZmFjZXMpO2Vsc2UgaWYodGhpcy5jdXJyZW50RWZmZWN0IT09Im5vbmUiKXtjb25zdCB0PXRoaXMuY3VycmVudEVmZmVjdDt0aGlzLmN1cnJlbnRFZmZlY3Q9Im5vbmUiLHRoaXMuc2V0RWZmZWN0KHQpfX1kZXN0cm95KCl7dGhpcy5zdG9wKCksdGhpcy5yZW5kZXJUYXJnZXQmJih0aGlzLnJlbmRlclRhcmdldC5kaXNwb3NlKCksdGhpcy5yZW5kZXJUYXJnZXQ9bnVsbCksdGhpcy5tYXNrUXVhZD8ubWF0ZXJpYWwmJnRoaXMubWFza1F1YWQubWF0ZXJpYWwuZGlzcG9zZSgpLHRoaXMubWFza1NjZW5lPy5jbGVhcigpLHRoaXMucmVuZGVyZXIuZGlzcG9zZSgpLHRoaXMuc2NlbmUuY2xlYXIoKX1zdGFydExvb3AoKXt0aGlzLmFuaW1hdGlvbkZyYW1lPT1udWxsJiYodGhpcy5sYXN0VGltZXN0YW1wPTAsdGhpcy5hbmltYXRpb25GcmFtZT1Gcyh0aGlzLnJlbmRlckxvb3ApKX1zdG9wTG9vcCgpe3RoaXMuYW5pbWF0aW9uRnJhbWUhPW51bGwmJihxdSh0aGlzLmFuaW1hdGlvbkZyYW1lKSx0aGlzLmFuaW1hdGlvbkZyYW1lPW51bGwpfXJlbmRlckZyYW1lKGUpe3RoaXMubGFzdFRpbWVzdGFtcD09PTAmJih0aGlzLmxhc3RUaW1lc3RhbXA9ZSk7Y29uc3QgdD1NYXRoLm1pbigoZS10aGlzLmxhc3RUaW1lc3RhbXApLzFlMywuMDUpO3RoaXMubGFzdFRpbWVzdGFtcD1lLHRoaXMuYWN0aXZlRWZmZWN0Py51cGRhdGUodCxlLzFlMyx0aGlzLmVmZmVjdEV4dHJhcyksdGhpcy5zbW9nT3ZlcmxheT8udXBkYXRlKHQpLHRoaXMud2luZG93RHJvcGxldHNPdmVybGF5Py51cGRhdGUodCksdGhpcy5saWdodG5pbmdPdmVybGF5Py51cGRhdGUodCxlLzFlMyx0aGlzLmVmZmVjdEV4dHJhcyksdGhpcy5hdXJvcmFPdmVybGF5Py51cGRhdGUodCk7Y29uc3Qgbj10aGlzLmVmZmVjdEV4dHJhcy5zcGF0aWFsTW9kZT09PSJncmFkaWVudC1tYXNrIjtuJiYodGhpcy5lbnN1cmVHcmFkaWVudE1hc2tQYXNzKCksdGhpcy5yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUYXJnZXQpKSx0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLHRoaXMuY2FtZXJhKSxuJiYodGhpcy5yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCksdGhpcy5tYXNrUXVhZC5tYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZT10aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMubWFza1NjZW5lLHRoaXMubWFza0NhbWVyYSkpLHRoaXMuYW5pbWF0aW9uRnJhbWU9RnModGhpcy5yZW5kZXJMb29wKX1lbnN1cmVHcmFkaWVudE1hc2tQYXNzKCl7aWYodGhpcy5yZW5kZXJUYXJnZXQpcmV0dXJuO3RoaXMucmVuZGVyVGFyZ2V0PW5ldyBKdCh0aGlzLnZpZXdwb3J0V2lkdGgsdGhpcy52aWV3cG9ydEhlaWdodCx7bWluRmlsdGVyOjEwMDYsbWFnRmlsdGVyOjEwMDYsZm9ybWF0OjEwMjMsdHlwZToxMDA5LHN0ZW5jaWxCdWZmZXI6ITF9KSx0aGlzLm1hc2tDYW1lcmE9bmV3IHJyKC0xLDEsMSwtMSwwLDEpLHRoaXMubWFza1NjZW5lPW5ldyBQcztjb25zdCBlPW5ldyBldCgyLDIpLHQ9bmV3IGx0KHt1bmlmb3Jtczp7dERpZmZ1c2U6e3ZhbHVlOm51bGx9LHVJbm5lcjp7dmFsdWU6LjMyfSx1T3V0ZXI6e3ZhbHVlOi44NX19LHZlcnRleFNoYWRlcjoidmFyeWluZyB2ZWMyIHZVdjsgdm9pZCBtYWluKCkgeyB2VXYgPSB1djsgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTsgfSIsZnJhZ21lbnRTaGFkZXI6YAogICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlOwogICAgICAgIHVuaWZvcm0gZmxvYXQgdUlubmVyOwogICAgICAgIHVuaWZvcm0gZmxvYXQgdU91dGVyOwogICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7CiAgICAgICAgdm9pZCBtYWluKCkgewogICAgICAgICAgdmVjNCB0ZXggPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdik7CiAgICAgICAgICB2ZWMyIGMgPSB2VXYgLSAwLjU7CiAgICAgICAgICBmbG9hdCBkID0gbGVuZ3RoKGMpICogMi4wOwogICAgICAgICAgZmxvYXQgbWFzayA9IHNtb290aHN0ZXAodUlubmVyLCB1T3V0ZXIsIGQpOwogICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh0ZXgucmdiLCB0ZXguYSAqIG1hc2spOwogICAgICAgIH0KICAgICAgYCx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExfSk7dGhpcy5tYXNrUXVhZD1uZXcgdHQoZSx0KSx0aGlzLm1hc2tTY2VuZS5hZGQodGhpcy5tYXNrUXVhZCl9c2V0RWZmZWN0KGUpe2lmKHRoaXMuZGlzcG9zZUFjdGl2ZUVmZmVjdCgpLHRoaXMuY3VycmVudEVmZmVjdD1lLGU9PT0ibm9uZSIpe3RoaXMuc3RvcExvb3AoKTtyZXR1cm59Y29uc3QgdD10aGlzLmNyZWF0ZUVmZmVjdEluc3RhbmNlKGUpO2lmKCF0KXt0aGlzLnN0b3BMb29wKCksdGhpcy5jdXJyZW50RWZmZWN0PSJub25lIjtyZXR1cm59dGhpcy5hY3RpdmVFZmZlY3Q9dCx0aGlzLmFjdGl2ZUVmZmVjdC5zZXRPcGFjaXR5KHRoaXMub3BhY2l0eSksdGhpcy5zbm93U3VyZmFjZXMubGVuZ3RoJiZ0aGlzLmFjdGl2ZUVmZmVjdC5zZXRTbm93U3VyZmFjZXMmJnRoaXMuYWN0aXZlRWZmZWN0LnNldFNub3dTdXJmYWNlcyh0aGlzLnNub3dTdXJmYWNlcyksdGhpcy5zY2VuZS5hZGQodC5ncm91cCksdGhpcy5sYXN0QXBwbGllZEV4dHJhcz17Li4udGhpcy5lZmZlY3RFeHRyYXN9LHRoaXMudXBkYXRlU21vZ092ZXJsYXkoKSx0aGlzLnVwZGF0ZVdpbmRvd0Ryb3BsZXRzT3ZlcmxheSgpLHRoaXMudXBkYXRlTGlnaHRuaW5nT3ZlcmxheSgpLHRoaXMudXBkYXRlQXVyb3JhT3ZlcmxheSgpLHRoaXMuc3RhcnRMb29wKCl9ZGlzcG9zZUFjdGl2ZUVmZmVjdCgpe3RoaXMuYWN0aXZlRWZmZWN0JiYodGhpcy5zY2VuZS5yZW1vdmUodGhpcy5hY3RpdmVFZmZlY3QuZ3JvdXApLHRoaXMuYWN0aXZlRWZmZWN0LmRpc3Bvc2UoKSx0aGlzLmFjdGl2ZUVmZmVjdD1udWxsKX1jcmVhdGVFZmZlY3RJbnN0YW5jZShlKXtjb25zdCB0PXt2aWV3V2lkdGg6dGhpcy52aWV3V2lkdGgsdmlld0hlaWdodDp0aGlzLnZpZXdIZWlnaHQsdmlld3BvcnRXaWR0aDp0aGlzLnZpZXdwb3J0V2lkdGgsdmlld3BvcnRIZWlnaHQ6dGhpcy52aWV3cG9ydEhlaWdodCxpc01vYmlsZTp0aGlzLmlzTW9iaWxlLGVmZmVjdDplLG9wYWNpdHk6dGhpcy5vcGFjaXR5LHNub3dBY2N1bXVsYXRpb246ISF0aGlzLmVmZmVjdEV4dHJhcy5zbm93QWNjdW11bGF0aW9uLHNub3dTdXJmYWNlczp0aGlzLnNub3dTdXJmYWNlcyxtYXRyaXhSYWluQ29sb3I6dGhpcy5lZmZlY3RFeHRyYXMubWF0cml4UmFpbkNvbG9yLG1vb25Qb3NpdGlvbjp0aGlzLmVmZmVjdEV4dHJhcy5tb29uUG9zaXRpb24sd2luZEJlYXJpbmc6dGhpcy5lZmZlY3RFeHRyYXMud2luZEJlYXJpbmcsd2luZFNwZWVkS21oOnRoaXMuZWZmZWN0RXh0cmFzLndpbmRTcGVlZEttaCx3aW5kU3dheUZhY3Rvcjp0aGlzLmVmZmVjdEV4dHJhcy53aW5kU3dheUZhY3RvcixyYWluTWF4VGlsdERlZzp0aGlzLmVmZmVjdEV4dHJhcy5yYWluTWF4VGlsdERlZyxyYWluV2luZE1pbkttaDp0aGlzLmVmZmVjdEV4dHJhcy5yYWluV2luZE1pbkttaCxzdW5Qb3NpdGlvbjp0aGlzLmVmZmVjdEV4dHJhcy5zdW5Qb3NpdGlvbixjbG91ZENvdmVyYWdlOnRoaXMuZWZmZWN0RXh0cmFzLmNsb3VkQ292ZXJhZ2UscHJlY2lwaXRhdGlvbk11bHRpcGxpZXI6dGhpcy5lZmZlY3RFeHRyYXMucHJlY2lwaXRhdGlvbk11bHRpcGxpZXI/PzEsdGhlbWVNb2RlOnRoaXMuZWZmZWN0RXh0cmFzLnRoZW1lTW9kZT8/ImRhcmsiLGNsb3VkU3BlZWRNdWx0aXBsaWVyOnRoaXMuZWZmZWN0RXh0cmFzLmNsb3VkU3BlZWRNdWx0aXBsaWVyPz8xfTtyZXR1cm4gZT09PSJsaWdodG5pbmciP3pzKHQpOmU9PT0ic3VuX2JlYW1zIj9waCh0KTplPT09InN0YXJzIj9zaCh0KTplPT09Im1hdHJpeCI/aWgodCk6ZT09PSJjbG91ZHMiP21oKHQpOmU9PT0iaGFpbCI/Z2godCk6ZS5zdGFydHNXaXRoKCJyYWluIik/WnUodCk6ZT09PSJzbm93X2xheWVyZWQiP1F1KHQpOmUuc3RhcnRzV2l0aCgic25vdyIpP0p1KHQpOmUuc3RhcnRzV2l0aCgiZm9nIik/ZmgodCk6bnVsbH19ZnVuY3Rpb24gS3UoaSxlKXtjb25zdCB0PWU/LjY6MTtyZXR1cm4gaT09PSJyYWluX3N0b3JtIj97Y291bnQ6TWF0aC5mbG9vcig2MDAqdCksbGVuZ3RoOnttaW46MS4xLG1heDoxLjV9LHNwZWVkOnttaW46MS40LG1heDoxLjl9LHRpbWVTY2FsZToxLjIsbGlnaHRuaW5nOiEwLGxpZ2h0bmluZ09ubHk6ITF9Omk9PT0icmFpbl9kcml6emxlIj97Y291bnQ6TWF0aC5mbG9vcigyNTAqdCksbGVuZ3RoOnttaW46LjYsbWF4Oi45fSxzcGVlZDp7bWluOi4zLG1heDouNn0sdGltZVNjYWxlOi42LGxpZ2h0bmluZzohMSxsaWdodG5pbmdPbmx5OiExfTp7Y291bnQ6TWF0aC5mbG9vcig0ODAqdCksbGVuZ3RoOnttaW46LjksbWF4OjEuMn0sc3BlZWQ6e21pbjoxLG1heDoxLjN9LHRpbWVTY2FsZToxLGxpZ2h0bmluZzohMSxsaWdodG5pbmdPbmx5OiExfX1mdW5jdGlvbiBadShpKXtjb25zdCBlPW5ldyBkdCx0PUt1KGkuZWZmZWN0LGkuaXNNb2JpbGUpLG49dC5jb3VudCxyPW5ldyBldCguMDYsMSkscz1uZXcgVXM7cy5pbmRleD1yLmluZGV4LHMuYXR0cmlidXRlcy5wb3NpdGlvbj1yLmF0dHJpYnV0ZXMucG9zaXRpb24scy5hdHRyaWJ1dGVzLnV2PXIuYXR0cmlidXRlcy51dixzLmluc3RhbmNlQ291bnQ9bjtjb25zdCBhPW5ldyBGbG9hdDMyQXJyYXkobiozKSxvPW5ldyBGbG9hdDMyQXJyYXkobiksbD1uZXcgRmxvYXQzMkFycmF5KG4pLGM9bmV3IEZsb2F0MzJBcnJheShuKSxoPW5ldyBGbG9hdDMyQXJyYXkobik7Zm9yKGxldCBnPTA7ZzxuO2crKyl7Y29uc3QgUD1nKjM7YVtQXT0kZS5yYW5kRmxvYXRTcHJlYWQoaS52aWV3V2lkdGgrMTApLGFbUCsxXT0kZS5yYW5kRmxvYXRTcHJlYWQoaS52aWV3SGVpZ2h0KSxhW1ArMl09TWF0aC5yYW5kb20oKSouNSxvW2ddPSRlLnJhbmRGbG9hdCh0LnNwZWVkLm1pbix0LnNwZWVkLm1heCksbFtnXT0kZS5yYW5kRmxvYXQodC5sZW5ndGgubWluLHQubGVuZ3RoLm1heCksY1tnXT0kZS5yYW5kRmxvYXQoLjUsMS41KSxoW2ddPU1hdGgucmFuZG9tKCl9cy5zZXRBdHRyaWJ1dGUoImluc3RhbmNlT2Zmc2V0IixuZXcgR3QoYSwzKSkscy5zZXRBdHRyaWJ1dGUoImluc3RhbmNlU3BlZWQiLG5ldyBHdChvLDEpKSxzLnNldEF0dHJpYnV0ZSgiaW5zdGFuY2VMZW5ndGgiLG5ldyBHdChsLDEpKSxzLnNldEF0dHJpYnV0ZSgiaW5zdGFuY2VTd2F5IixuZXcgR3QoYywxKSkscy5zZXRBdHRyaWJ1dGUoImluc3RhbmNlUGhhc2UiLG5ldyBHdChoLDEpKTtjb25zdCBkPWkucmFpbldpbmRNaW5LbWg/PzMsZj1pLndpbmRTd2F5RmFjdG9yPz8uNyxwPWkud2luZFNwZWVkS21oPz81LF89KGkud2luZEJlYXJpbmc/PzI3MCkqTWF0aC5QSS8xODA7bGV0IHg9MDtwPj1kJiYoeD0tTWF0aC5zaW4oXykqcCouMDYqZik7Y29uc3QgbT14Ki4xNSx1PXt1VGltZTp7dmFsdWU6MH0sdU9wYWNpdHk6e3ZhbHVlOmkub3BhY2l0eS8xMDB9LHVWaWV3U2l6ZTp7dmFsdWU6bmV3IFBlKGkudmlld1dpZHRoLGkudmlld0hlaWdodCl9LHVXaW5kU3dheTp7dmFsdWU6bX19LFQ9bmV3IGx0KHt1bmlmb3Jtczp1LHZlcnRleFNoYWRlcjpgCiAgICAgIGF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlT2Zmc2V0OwogICAgICBhdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VTcGVlZDsKICAgICAgYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlTGVuZ3RoOwogICAgICBhdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VTd2F5OwogICAgICBhdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VQaGFzZTsKICAgICAgdW5pZm9ybSBmbG9hdCB1VGltZTsKICAgICAgdW5pZm9ybSB2ZWMyIHVWaWV3U2l6ZTsKICAgICAgdW5pZm9ybSBmbG9hdCB1V2luZFN3YXk7CiAgICAgIHZhcnlpbmcgZmxvYXQgdkFscGhhOwogICAgICB2b2lkIG1haW4oKSB7CiAgICAgICAgZmxvYXQgcHJvZ3Jlc3MgPSBmcmFjdCh1VGltZSAqIGluc3RhbmNlU3BlZWQgKyBpbnN0YW5jZVBoYXNlKTsKICAgICAgICBmbG9hdCB0cmF2ZWwgPSAodVZpZXdTaXplLnkgKiAwLjUpIC0gcHJvZ3Jlc3MgKiAodVZpZXdTaXplLnkgKyAyMC4wKTsKICAgICAgICB2ZWMzIHRyYW5zZm9ybWVkID0gcG9zaXRpb247CiAgICAgICAgdHJhbnNmb3JtZWQueSAqPSBpbnN0YW5jZUxlbmd0aDsKICAgICAgICB0cmFuc2Zvcm1lZC54ICs9IGluc3RhbmNlT2Zmc2V0LnggKyBzaW4ocHJvZ3Jlc3MgKiA2LjI4MzE4ICsgaW5zdGFuY2VQaGFzZSkgKiBpbnN0YW5jZVN3YXkgKyB1V2luZFN3YXkgKiBwcm9ncmVzcyAqIHVWaWV3U2l6ZS55OwogICAgICAgIHRyYW5zZm9ybWVkLnkgKz0gdHJhdmVsICsgaW5zdGFuY2VPZmZzZXQueTsKICAgICAgICB0cmFuc2Zvcm1lZC56ICs9IC01LjAgKyBpbnN0YW5jZU9mZnNldC56OwogICAgICAgIHZBbHBoYSA9IDEuMCAtIHByb2dyZXNzOwogICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQodHJhbnNmb3JtZWQsIDEuMCk7CiAgICAgIH0KICAgIGAsZnJhZ21lbnRTaGFkZXI6YAogICAgICB1bmlmb3JtIGZsb2F0IHVPcGFjaXR5OwogICAgICB2YXJ5aW5nIGZsb2F0IHZBbHBoYTsKICAgICAgdm9pZCBtYWluKCkgewogICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC42NSwgMC43NSwgMC45LCBjbGFtcCh2QWxwaGEgKiAwLjg1ICogdU9wYWNpdHksIDAuMCwgMS4wKSk7CiAgICAgIH0KICAgIGAsdHJhbnNwYXJlbnQ6ITAsZGVwdGhXcml0ZTohMSxibGVuZGluZzoyfSkseT1uZXcgdHQocyxUKTtyZXR1cm4geS5mcnVzdHVtQ3VsbGVkPSExLGUuYWRkKHkpLHtncm91cDplLHVwZGF0ZShnLFAsdyl7Y29uc3QgYj13Py5wcmVjaXBpdGF0aW9uTXVsdGlwbGllcj8/MTt1LnVUaW1lLnZhbHVlKz1nKnQudGltZVNjYWxlKmIsdS51Vmlld1NpemUudmFsdWUuc2V0KGkudmlld1dpZHRoLGkudmlld0hlaWdodCl9LHNldE9wYWNpdHkoZyl7dS51T3BhY2l0eS52YWx1ZT1NYXRoLm1heCgwLE1hdGgubWluKDEsZy8xMDApKX0sb25SZXNpemUoZyxQKXtpLnZpZXdXaWR0aD1nLGkudmlld0hlaWdodD1QLHUudVZpZXdTaXplLnZhbHVlLnNldChnLFApfSxkaXNwb3NlKCl7cy5kaXNwb3NlKCksVC5kaXNwb3NlKCl9fX1mdW5jdGlvbiBqdShpLGUpe2NvbnN0IHQ9ZT8uNjoxO3JldHVybiBNYXRoLmZsb29yKGk9PT0ic25vd19zdG9ybSI/MWUzKnQ6NjAwKnQpfWZ1bmN0aW9uIEp1KGkpe2NvbnN0IGU9bmV3IGR0LHQ9anUoaS5lZmZlY3QsaS5pc01vYmlsZSksbj1uZXcgRmxvYXQzMkFycmF5KHQqMykscj1uZXcgRmxvYXQzMkFycmF5KHQqMykscz1pLnJhaW5XaW5kTWluS21oPz8zLGE9aS53aW5kU3dheUZhY3Rvcj8/Ljcsbz1pLndpbmRTcGVlZEttaD8/NSxsPShpLndpbmRCZWFyaW5nPz8yNzApKk1hdGguUEkvMTgwLGM9bz49cz8tTWF0aC5zaW4obCkqbyouMDYqYSouODowO2ZvcihsZXQgdT0wO3U8dDt1Kyspe2NvbnN0IFQ9dSozO25bVF09JGUucmFuZEZsb2F0U3ByZWFkKGkudmlld1dpZHRoKzMwKSxuW1QrMV09JGUucmFuZEZsb2F0U3ByZWFkKGkudmlld0hlaWdodCszMCksbltUKzJdPU1hdGgucmFuZG9tKCkqNC0yLHJbVF09JGUucmFuZEZsb2F0KC0uMiwuMikrYyxyW1QrMV09aS5lZmZlY3Q9PT0ic25vd19zdG9ybSI/JGUucmFuZEZsb2F0KC0xLjQsLS45KTokZS5yYW5kRmxvYXQoLS44LC0uNCkscltUKzJdPSRlLnJhbmRGbG9hdCgtLjA1LC4wNSl9Y29uc3QgaD1uZXcgQ3Q7aC5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgU3QobiwzKSk7Y29uc3QgZD1JcygpLGY9aS5lZmZlY3Q9PT0ic25vd19zdG9ybSI/Ljk6Ljc1LF89aS50aGVtZU1vZGU9PT0ibGlnaHQiPzE2Nzc3MjE1OjE1MjY3MDcxLHg9bmV3IFJpKHttYXA6ZCx0cmFuc3BhcmVudDohMCxvcGFjaXR5OmYqKGkub3BhY2l0eS8xMDApLHNpemVBdHRlbnVhdGlvbjohMSxzaXplOmkuZWZmZWN0PT09InNub3dfc3Rvcm0iPzMuNDoyLjYsY29sb3I6XyxkZXB0aFdyaXRlOiExLGRlcHRoVGVzdDohMSxibGVuZGluZzoyfSksbT1uZXcgbXIoaCx4KTtyZXR1cm4gbS5mcnVzdHVtQ3VsbGVkPSExLGUuYWRkKG0pLHtncm91cDplLHVwZGF0ZSh1KXtjb25zdCBUPWguYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtmb3IobGV0IHk9MDt5PFQubGVuZ3RoO3krPTMpe1RbeV0rPXJbeV0qdSoyNSxUW3krMV0rPXJbeSsxXSp1KjI1LFRbeSsyXSs9clt5KzJdKnUqMTA7Y29uc3QgZz1pLnZpZXdXaWR0aC8yKzE1LFA9aS52aWV3SGVpZ2h0LzIrMTU7VFt5KzFdPC1QJiYoVFt5KzFdPVAsVFt5XT0kZS5yYW5kRmxvYXRTcHJlYWQoaS52aWV3V2lkdGgrMzApKSxUW3ldPC1nJiYoVFt5XT1nKSxUW3ldPmcmJihUW3ldPS1nKX1oLmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGU9ITB9LHNldE9wYWNpdHkodSl7eC5vcGFjaXR5PWYqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHUvMTAwKSl9LG9uUmVzaXplKHUsVCl7aS52aWV3V2lkdGg9dSxpLnZpZXdIZWlnaHQ9VH0sZGlzcG9zZSgpe2guZGlzcG9zZSgpLHguZGlzcG9zZSgpLGQuZGlzcG9zZSgpfX19Y29uc3QgTnM9W3tzaXplTWluOjI0LHNpemVNYXg6NDAsc3BlZWRGYWN0b3I6LjEyLHN3YXlBbXBNaW46MTAsc3dheUFtcE1heDozMCxvcGFjaXR5OjEsY29sb3JNaW46MjU1LGNvbG9yTWF4OjI1NX0se3NpemVNaW46MjAsc2l6ZU1heDoyOCxzcGVlZEZhY3RvcjouMDksc3dheUFtcE1pbjoxMCxzd2F5QW1wTWF4OjI1LG9wYWNpdHk6Ljg1LGNvbG9yTWluOjI1NSxjb2xvck1heDoyNTV9LHtzaXplTWluOjE2LHNpemVNYXg6MjQsc3BlZWRGYWN0b3I6LjA3LHN3YXlBbXBNaW46MTAsc3dheUFtcE1heDoyMCxvcGFjaXR5Oi43NSxjb2xvck1pbjoyNTUsY29sb3JNYXg6MjU1fSx7c2l6ZU1pbjoxMixzaXplTWF4OjE4LHNwZWVkRmFjdG9yOi4wNSxzd2F5QW1wTWluOjEwLHN3YXlBbXBNYXg6MjAsb3BhY2l0eTouNjUsY29sb3JNaW46MjIwLGNvbG9yTWF4OjIyOX0se3NpemVNaW46MTAsc2l6ZU1heDoxNCxzcGVlZEZhY3RvcjouMDMsc3dheUFtcE1pbjoxMCxzd2F5QW1wTWF4OjIwLG9wYWNpdHk6LjU1LGNvbG9yTWluOjIxMCxjb2xvck1heDoyMTl9LHtzaXplTWluOjgsc2l6ZU1heDoxMixzcGVlZEZhY3RvcjouMDEsc3dheUFtcE1pbjoxMCxzd2F5QW1wTWF4OjIwLG9wYWNpdHk6LjQsY29sb3JNaW46MjAwLGNvbG9yTWF4OjIwOX1dO2Z1bmN0aW9uIFF1KGkpe2NvbnN0IGU9bmV3IGR0O2xldCB0PWkuaXNNb2JpbGU/MTgwOjMwMDtjb25zdCBuPU1hdGguZmxvb3IodC9Ocy5sZW5ndGgpLHI9SXMoKSxzPWkucmFpbldpbmRNaW5LbWg/PzMsYT1pLndpbmRTd2F5RmFjdG9yPz8uNyxvPWkud2luZFNwZWVkS21oPz81LGw9KGkud2luZEJlYXJpbmc/PzI3MCkqTWF0aC5QSS8xODAsYz1vPj1zPy1NYXRoLnNpbihsKSpvKi4wNiphKi4xMjowLGg9TnMubWFwKGQ9Pntjb25zdCBmPW5ldyBGbG9hdDMyQXJyYXkobiozKSxwPW5ldyBGbG9hdDMyQXJyYXkobiksXz1uZXcgRmxvYXQzMkFycmF5KG4pLHg9bmV3IEZsb2F0MzJBcnJheShuKSxtPW5ldyBGbG9hdDMyQXJyYXkobik7Zm9yKGxldCBQPTA7UDxuO1ArKyl7Y29uc3Qgdz1QKjMsYj1kLnNpemVNaW4rTWF0aC5yYW5kb20oKSooZC5zaXplTWF4LWQuc2l6ZU1pbik7Zlt3XT0kZS5yYW5kRmxvYXRTcHJlYWQoaS52aWV3V2lkdGgrMjApLGZbdysxXT0kZS5yYW5kRmxvYXRTcHJlYWQoaS52aWV3SGVpZ2h0KzIwKSxmW3crMl09TWF0aC5yYW5kb20oKSoyLTEscFtQXT1iKmQuc3BlZWRGYWN0b3IqLjE1K01hdGgucmFuZG9tKCkqLjAyLF9bUF09ZC5zd2F5QW1wTWluK01hdGgucmFuZG9tKCkqKGQuc3dheUFtcE1heC1kLnN3YXlBbXBNaW4pLHhbUF09TWF0aC5yYW5kb20oKSpNYXRoLlBJKjIsbVtQXT0uMDErTWF0aC5yYW5kb20oKSouMDJ9Y29uc3QgdT1uZXcgQ3Q7dS5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgU3QoZiwzKSk7Y29uc3QgVD0oZC5zaXplTWluK2Quc2l6ZU1heCkvMix5PW5ldyBSaSh7bWFwOnIsdHJhbnNwYXJlbnQ6ITAsb3BhY2l0eTpkLm9wYWNpdHkqKGkub3BhY2l0eS8xMDApLHNpemVBdHRlbnVhdGlvbjohMSxzaXplOlQqLjE1LGNvbG9yOjE2Nzc3MjE1LGRlcHRoV3JpdGU6ITEsZGVwdGhUZXN0OiExLGJsZW5kaW5nOjJ9KSxnPW5ldyBtcih1LHkpO3JldHVybiBnLmZydXN0dW1DdWxsZWQ9ITEsZS5hZGQoZykse2dlbzp1LG1hdDp5LGZhbGxTcGVlZHM6cCxzd2F5QW1wczpfLHN3YXlPZmZzZXRzOngsc3dheVNwZWVkczptLGJhc2VPcGFjaXR5OmQub3BhY2l0eX19KTtyZXR1cm57Z3JvdXA6ZSx1cGRhdGUoZCl7aC5mb3JFYWNoKGY9Pntjb25zdCBwPWYuZ2VvLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXksXz1kKjYwO2ZvcihsZXQgeD0wO3g8cC5sZW5ndGgvMzt4Kyspe2NvbnN0IG09eCozO2Yuc3dheU9mZnNldHNbeF0rPWYuc3dheVNwZWVkc1t4XTtjb25zdCB1PU1hdGguc2luKGYuc3dheU9mZnNldHNbeF0pKmYuc3dheUFtcHNbeF0qLjA4O3BbbV0rPSh1K2MpKl8scFttKzFdLT1mLmZhbGxTcGVlZHNbeF0qXztjb25zdCBUPWkudmlld1dpZHRoLzIrMTUseT1pLnZpZXdIZWlnaHQvMisxNTtwW20rMV08LXkmJihwW20rMV09eSxwW21dPSRlLnJhbmRGbG9hdFNwcmVhZChpLnZpZXdXaWR0aCsyMCkpLHBbbV08LVQmJihwW21dPVQpLHBbbV0+VCYmKHBbbV09LVQpfWYuZ2VvLmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGU9ITB9KX0sc2V0T3BhY2l0eShkKXtjb25zdCBmPU1hdGgubWF4KDAsTWF0aC5taW4oMSxkLzEwMCkpO2guZm9yRWFjaChwPT57cC5tYXQub3BhY2l0eT1wLmJhc2VPcGFjaXR5KmZ9KX0sb25SZXNpemUoZCxmKXtpLnZpZXdXaWR0aD1kLGkudmlld0hlaWdodD1mfSxkaXNwb3NlKCl7aC5mb3JFYWNoKGQ9PntkLmdlby5kaXNwb3NlKCksZC5tYXQuZGlzcG9zZSgpfSksci5kaXNwb3NlKCl9fX1jb25zdCBPcz1bIuWckiIsIui/jiIsIuewoSIsIuebiiIsIuWkpyIsIuivtiIsIuavlCIsIuilvyIsIui/qiIsIuS8iiIsIuW8lyIsIuWQiSIsIuWwuiIsIuadsCIsIuW8gCIsIuiJviIsIuWLkiIsIumprCIsIuWonCJdLGVoPSIjMDBmZjQxIix0aD0iIzAwY2MzMyIsbmg9ODU7ZnVuY3Rpb24gaWgoaSl7Y29uc3QgZT1uZXcgZHQsdD1NYXRoLm1heCgyNTYsTWF0aC5mbG9vcihpLnZpZXdwb3J0V2lkdGgvMikpLG49TWF0aC5tYXgoMjU2LE1hdGguZmxvb3IoaS52aWV3cG9ydEhlaWdodC8yKSkse2NhbnZhczpyLGN0eDpzfT1MaSh0LG4pLGE9VWkocik7YS5taW5GaWx0ZXI9MTAwNixhLm1hZ0ZpbHRlcj0xMDA2O2NvbnN0IG89bmV3IGV0KGkudmlld1dpZHRoLGkudmlld0hlaWdodCksbD1uZXcgam4oe21hcDphLHRyYW5zcGFyZW50OiEwLG9wYWNpdHk6LjkqKGkub3BhY2l0eS8xMDApLGRlcHRoV3JpdGU6ITF9KSxjPW5ldyB0dChvLGwpO2UuYWRkKGMpO2NvbnN0IGg9W107bGV0IGQ9MDtyZXR1cm57Z3JvdXA6ZSx1cGRhdGUoZil7Y29uc3QgcD1yLndpZHRoLF89ci5oZWlnaHQseD1wL2kudmlld3BvcnRXaWR0aDtkKz1mKjFlMztjb25zdCBtPV8vMyx1PWguc29tZShnPT5nLnk+bSk7aWYoKGgubGVuZ3RoPT09MHx8dSkmJmQ+PS44JiZoLmxlbmd0aDw2KXtkPTA7Y29uc3QgZz1wKi4yOCxQPXAqLjcyO2xldCB3PTE1LGI7ZG97Yj1NYXRoLnJhbmRvbSgpPC41PzMwK01hdGgucmFuZG9tKCkqKGctNjApOlArMzArTWF0aC5yYW5kb20oKSoocC1QLTYwKTtjb25zdCBFPW5oKihwL2kudmlld3BvcnRXaWR0aCk7aWYoIWguc29tZShSPT5NYXRoLmFicyhSLngtYik8RSkpYnJlYWt9d2hpbGUoLS13PjApO2lmKHc+MCl7Y29uc3QgRj00K01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo4KTtoLnB1c2goe3g6Yix5Oi04MCxjaGFyczpBcnJheS5mcm9tKHtsZW5ndGg6Rn0sKCk9Pk9zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpPcy5sZW5ndGgpXSksc3BlZWQ6KC4xNStNYXRoLnJhbmRvbSgpKi4xMikqeH0pfX1zLmZpbGxTdHlsZT0icmdiYSgwLDAsMCwwLjA4KSIscy5maWxsUmVjdCgwLDAscCxfKSxzLmZvbnQ9YCR7TWF0aC5tYXgoMTIsMTYqeCl9cHggbW9ub3NwYWNlYCxzLnRleHRBbGlnbj0iY2VudGVyIixzLnRleHRCYXNlbGluZT0idG9wIjtjb25zdCB5PXAvMjtmb3IobGV0IGc9aC5sZW5ndGgtMTtnPj0wO2ctLSl7Y29uc3QgUD1oW2ddO2lmKFAueSs9UC5zcGVlZCxQLnk+XysxNTApe2guc3BsaWNlKGcsMSk7Y29udGludWV9Y29uc3Qgdz1NYXRoLmFicyhQLngteSksYj13PHAqLjI/LjUrdy8ocCouMikqLjQ6LjksRj0xNip4O2ZvcihsZXQgRT0wO0U8UC5jaGFycy5sZW5ndGg7RSsrKXtjb25zdCBTPTEtRS9QLmNoYXJzLmxlbmd0aCouNTtzLmdsb2JhbEFscGhhPVMqYixzLmZpbGxTdHlsZT1FPT09MD9laDp0aCxzLmZpbGxUZXh0KFAuY2hhcnNbRV0sUC54LFAueStFKkYpfXMuZ2xvYmFsQWxwaGE9MX1hLm5lZWRzVXBkYXRlPSEwfSxzZXRPcGFjaXR5KGYpe2wub3BhY2l0eT0uOSpNYXRoLm1heCgwLE1hdGgubWluKDEsZi8xMDApKX0sb25SZXNpemUoZixwKXtpLnZpZXdXaWR0aD1mLGkudmlld0hlaWdodD1wLGMuZ2VvbWV0cnkuZGlzcG9zZSgpLGMuZ2VvbWV0cnk9bmV3IGV0KGYscCl9LGRpc3Bvc2UoKXtvLmRpc3Bvc2UoKSxsLmRpc3Bvc2UoKSxhLmRpc3Bvc2UoKX19fWZ1bmN0aW9uIHJoKGkpe3JldHVybiBNYXRoLmZsb29yKGk/NDAwKi42OjQwMCl9ZnVuY3Rpb24gc2goaSl7Y29uc3QgZT1uZXcgZHQsdD1yaChpLmlzTW9iaWxlKSxuPW5ldyBGbG9hdDMyQXJyYXkodCozKSxyPWkubW9vblBvc2l0aW9uO2ZvcihsZXQgZD0wO2Q8dDtkKyspe2NvbnN0IGY9ZCozO25bZl09JGUucmFuZEZsb2F0U3ByZWFkKGkudmlld1dpZHRoKzIwKSxuW2YrMV09JGUucmFuZEZsb2F0U3ByZWFkKGkudmlld0hlaWdodCsyMCksbltmKzJdPU1hdGgucmFuZG9tKCkqMi0xfWNvbnN0IHM9bmV3IEN0O3Muc2V0QXR0cmlidXRlKCJwb3NpdGlvbiIsbmV3IFN0KG4sMykpO2NvbnN0IGE9WXUoKSxvPW5ldyBSaSh7bWFwOmEsdHJhbnNwYXJlbnQ6ITAsb3BhY2l0eTouODUqKGkub3BhY2l0eS8xMDApLHNpemVBdHRlbnVhdGlvbjohMSxzaXplOjIsY29sb3I6MTUyNjcwNzEsZGVwdGhXcml0ZTohMSxkZXB0aFRlc3Q6ITEsYmxlbmRpbmc6Mn0pLGw9bmV3IG1yKHMsbyk7bC5mcnVzdHVtQ3VsbGVkPSExLGUuYWRkKGwpO2xldCBjPW51bGw7aWYociYmdHlwZW9mIHIueD09Im51bWJlciImJnR5cGVvZiByLnk9PSJudW1iZXIiKXtjb25zdCBkPShyLngtLjUpKmkudmlld1dpZHRoLGY9KC41LXIueSkqaS52aWV3SGVpZ2h0LHA9TWF0aC5tYXgoaS52aWV3V2lkdGgsaS52aWV3SGVpZ2h0KSouMzUsXz1uZXcgZXQocCxwKSx4PW5ldyBsdCh7dW5pZm9ybXM6e3VPcGFjaXR5Ont2YWx1ZTouMjIqKGkub3BhY2l0eS8xMDApfX0sdmVydGV4U2hhZGVyOiJ2YXJ5aW5nIHZlYzIgdlV2OyB2b2lkIG1haW4oKSB7IHZVdiA9IHV2OyBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApOyB9IixmcmFnbWVudFNoYWRlcjpgCiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjsKICAgICAgICB1bmlmb3JtIGZsb2F0IHVPcGFjaXR5OwogICAgICAgIHZvaWQgbWFpbigpIHsKICAgICAgICAgIHZlYzIgYyA9IHZVdiAtIDAuNTsKICAgICAgICAgIGZsb2F0IGQgPSBsZW5ndGgoYykgKiAyLjA7CiAgICAgICAgICBmbG9hdCBhbHBoYSA9IGV4cCgtZCAqIGQgKiAyLjgpICogdU9wYWNpdHk7CiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuOTYsIDAuOTcsIDEuMCwgYWxwaGEpOwogICAgICAgIH0KICAgICAgYCx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExLGJsZW5kaW5nOjJ9KTtjPW5ldyB0dChfLHgpLGMucG9zaXRpb24uc2V0KGQsZiwtMSksYy5yZW5kZXJPcmRlcj0xLGUuYWRkKGMpfWxldCBoPTA7cmV0dXJue2dyb3VwOmUsdXBkYXRlKGQpe2grPWQqMS4yLG8ub3BhY2l0eT0uODUqKGkub3BhY2l0eS8xMDApKiguOCsuMipNYXRoLnNpbihoKSl9LHNldE9wYWNpdHkoZCl7by5vcGFjaXR5PS44NSpNYXRoLm1heCgwLE1hdGgubWluKDEsZC8xMDApKX0sb25SZXNpemUoZCxmKXtpLnZpZXdXaWR0aD1kLGkudmlld0hlaWdodD1mfSxkaXNwb3NlKCl7cy5kaXNwb3NlKCksby5kaXNwb3NlKCksYS5kaXNwb3NlKCksYyYmKGMuZ2VvbWV0cnkuZGlzcG9zZSgpLGMubWF0ZXJpYWwuZGlzcG9zZSgpKX19fWNvbnN0IGFoPTU1O2Z1bmN0aW9uIG9oKGkpe2NvbnN0IGU9aS52aWV3V2lkdGgsdD1pLnZpZXdIZWlnaHQse2NhbnZhczpuLGN0eDpyfT1MaShNYXRoLm1heCgyNTYsTWF0aC5mbG9vcihpLnZpZXdwb3J0V2lkdGgvMikpLE1hdGgubWF4KDI1NixNYXRoLmZsb29yKGkudmlld3BvcnRIZWlnaHQvMikpKSxzPVVpKG4pO3MubWluRmlsdGVyPTEwMDYscy5tYWdGaWx0ZXI9MTAwNjtjb25zdCBhPW5ldyBldChlLHQpLG89bmV3IGpuKHttYXA6cyx0cmFuc3BhcmVudDohMCxvcGFjaXR5Oi45NSooaS5vcGFjaXR5LzEwMCksZGVwdGhXcml0ZTohMX0pLGw9bmV3IHR0KGEsbyk7bC5yZW5kZXJPcmRlcj01O2NvbnN0IGM9bmV3IGR0O2MuYWRkKGwpO2NvbnN0IGg9W107bGV0IGQ9MCxmPTA7ZnVuY3Rpb24gcCh4LG0sdSl7Zm9yKGNvbnN0IFQgb2YgaCl7Y29uc3QgeT14LVQueCxnPW0tVC55LFA9YWgrKHUrVC5zaXplKSouNTtpZih5KnkrZypnPFAqUClyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBfKCl7cmV0dXJuIDIyMDArTWF0aC5yYW5kb20oKSoyODAwfXJldHVybntncm91cDpjLHVwZGF0ZSh4KXtjb25zdCBtPW4ud2lkdGgsdT1uLmhlaWdodCxUPU1hdGgubWluKHgqMWUzLDUwKTtpZihkKz1ULGY8PTAmJihmPV8oKSksZD49Zil7ZD0wLGY9XygpO2NvbnN0IHk9LjE4LGc9bSp5LFA9bSooMS15KSx3PU1hdGgucmFuZG9tKCk8LjU/ImxlZnQiOiJyaWdodCIsYj00K01hdGgucmFuZG9tKCkqNjtsZXQgRixFLFM9MTI7ZG8gRj13PT09ImxlZnQiP01hdGgucmFuZG9tKCkqZzpQK01hdGgucmFuZG9tKCkqKG0tUCksRT1NYXRoLnJhbmRvbSgpKnUqLjU1O3doaWxlKC0tUz4wJiZwKEYsRSxiKSk7Uz4wJiZoLnB1c2goe3g6Rix5OkUsc2l6ZTpiLHBoYXNlOiJhcHBlYXIiLG9wYWNpdHk6MCxsaWZlOjAsYXBwZWFyRHVyOjMwMCxyZXN0RHVyOjJlMytNYXRoLnJhbmRvbSgpKjI1MDAsc2xpZGVWZWw6OCtNYXRoLnJhbmRvbSgpKjYsc2xpZGVBY2NlbDouOCtNYXRoLnJhbmRvbSgpKi42fSl9ci5jbGVhclJlY3QoMCwwLG0sdSk7Zm9yKGxldCB5PWgubGVuZ3RoLTE7eT49MDt5LS0pe2NvbnN0IGc9aFt5XTtpZihnLmxpZmUrPVQsZy5waGFzZT09PSJhcHBlYXIiKWcub3BhY2l0eT1NYXRoLm1pbigxLGcubGlmZS9nLmFwcGVhckR1cioxLjgpLGcubGlmZT49Zy5hcHBlYXJEdXImJihnLnBoYXNlPSJyZXN0IixnLmxpZmU9MCxnLm9wYWNpdHk9MSk7ZWxzZSBpZihnLnBoYXNlPT09InJlc3QiKWcubGlmZT49Zy5yZXN0RHVyJiYoZy5waGFzZT0ic2xpZGUiLGcubGlmZT0wKTtlbHNle2NvbnN0IFA9VC8xZTM7Zy5zbGlkZVZlbD0oZy5zbGlkZVZlbHx8OCkrZy5zbGlkZUFjY2VsKlAqNjAsZy55Kz1nLnNsaWRlVmVsKlA7Y29uc3Qgdz1nLnkvdTtpZihnLm9wYWNpdHk9dzwuODU/MTpNYXRoLm1heCgwLCgxLXcpLy4xNSksZy55PnUrZy5zaXplKjIpe2guc3BsaWNlKHksMSk7Y29udGludWV9fWlmKGcueTw9dStnLnNpemUqMil7ci5zYXZlKCksci5nbG9iYWxBbHBoYT1nLm9wYWNpdHk7Y29uc3QgUD1yLmNyZWF0ZVJhZGlhbEdyYWRpZW50KGcueC1nLnNpemUqLjMsZy55LWcuc2l6ZSouMywwLGcueCxnLnksZy5zaXplKjEuNSk7UC5hZGRDb2xvclN0b3AoMCwicmdiYSgyMzAsIDI0MCwgMjU1LCAwLjc1KSIpLFAuYWRkQ29sb3JTdG9wKC4zNSwicmdiYSgyMDAsIDIxOCwgMjQyLCAwLjU1KSIpLFAuYWRkQ29sb3JTdG9wKC43LCJyZ2JhKDE3MCwgMTkwLCAyMTUsIDAuMjUpIiksUC5hZGRDb2xvclN0b3AoMSwicmdiYSgxNTAsIDE3MCwgMTk1LCAwKSIpLHIuZmlsbFN0eWxlPVAsci5iZWdpblBhdGgoKSxyLmVsbGlwc2UoZy54LGcueSxnLnNpemUqLjUsZy5zaXplKjEuMSwwLDAsTWF0aC5QSSoyKSxyLmZpbGwoKTtjb25zdCB3PXIuY3JlYXRlUmFkaWFsR3JhZGllbnQoZy54LWcuc2l6ZSouMjUsZy55LWcuc2l6ZSouNCwwLGcueC1nLnNpemUqLjI1LGcueS1nLnNpemUqLjQsZy5zaXplKi42KTt3LmFkZENvbG9yU3RvcCgwLGByZ2JhKDI1NSwyNTUsMjU1LCR7LjYqZy5vcGFjaXR5fSlgKSx3LmFkZENvbG9yU3RvcCguNSxgcmdiYSgyNTUsMjU1LDI1NSwkey4yKmcub3BhY2l0eX0pYCksdy5hZGRDb2xvclN0b3AoMSwicmdiYSgyNTUsMjU1LDI1NSwwKSIpLHIuZmlsbFN0eWxlPXcsci5iZWdpblBhdGgoKSxyLmVsbGlwc2UoZy54LWcuc2l6ZSouMixnLnktZy5zaXplKi4zNSxnLnNpemUqLjM1LGcuc2l6ZSouNCwwLDAsTWF0aC5QSSoyKSxyLmZpbGwoKSxyLnJlc3RvcmUoKX19cy5uZWVkc1VwZGF0ZT0hMH0sc2V0T3BhY2l0eSh4KXtvLm9wYWNpdHk9Ljk1Kk1hdGgubWF4KDAsTWF0aC5taW4oMSx4LzEwMCkpfSxkaXNwb3NlKCl7YS5kaXNwb3NlKCksby5kaXNwb3NlKCkscy5kaXNwb3NlKCl9fX1mdW5jdGlvbiBsaChpKXtjb25zdCBlPWkudmlld1dpZHRoLHQ9aS52aWV3SGVpZ2h0LG49bmV3IGV0KGUsdCkscj17dVRpbWU6e3ZhbHVlOjB9LHVPcGFjaXR5Ont2YWx1ZTouMTgqKGkub3BhY2l0eS8xMDApfSx1U2NhbGU6e3ZhbHVlOjEuNH0sdVJlc29sdXRpb246e3ZhbHVlOm5ldyBQZShlLHQpfX0scz1uZXcgbHQoe3VuaWZvcm1zOnIsdmVydGV4U2hhZGVyOl9yLGZyYWdtZW50U2hhZGVyOmAKICAgICAgdmFyeWluZyB2ZWMyIHZVdjsKICAgICAgdW5pZm9ybSBmbG9hdCB1VGltZTsKICAgICAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTsKICAgICAgdW5pZm9ybSBmbG9hdCB1U2NhbGU7CiAgICAgIHVuaWZvcm0gdmVjMiB1UmVzb2x1dGlvbjsKICAgICAgZmxvYXQgaGFzaCh2ZWMyIHApIHsgcmV0dXJuIGZyYWN0KHNpbihkb3QocCwgdmVjMigxMjcuMSwgMzExLjcpKSkgKiA0Mzc1OC41NDUzKTsgfQogICAgICBmbG9hdCBub2lzZSh2ZWMyIHApIHsKICAgICAgICB2ZWMyIGkgPSBmbG9vcihwKTsKICAgICAgICB2ZWMyIGYgPSBmcmFjdChwKTsKICAgICAgICB2ZWMyIHUgPSBmICogZiAqICgzLjAgLSAyLjAgKiBmKTsKICAgICAgICByZXR1cm4gbWl4KG1peChoYXNoKGkpLCBoYXNoKGkgKyB2ZWMyKDEsMCkpLCB1LngpLCBtaXgoaGFzaChpICsgdmVjMigwLDEpKSwgaGFzaChpICsgdmVjMigxLDEpKSwgdS54KSwgdS55KTsKICAgICAgfQogICAgICBmbG9hdCBmYm0odmVjMiBwKSB7CiAgICAgICAgZmxvYXQgdiA9IDAuMCwgYW1wID0gMC41OwogICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgNDsgaSsrKSB7CiAgICAgICAgICB2ICs9IGFtcCAqIG5vaXNlKHApOwogICAgICAgICAgcCAqPSAyLjA7CiAgICAgICAgICBhbXAgKj0gMC41OwogICAgICAgIH0KICAgICAgICByZXR1cm4gdjsKICAgICAgfQogICAgICB2b2lkIG1haW4oKSB7CiAgICAgICAgdmVjMiBhc3BlY3QgPSB2ZWMyKHVSZXNvbHV0aW9uLnggLyBtYXgodVJlc29sdXRpb24ueSwgMC4wMDAxKSwgMS4wKTsKICAgICAgICB2ZWMyIHV2ID0gKHZVdiAtIDAuNSkgKiBhc3BlY3QgKyAwLjU7CiAgICAgICAgdXYgKj0gdVNjYWxlOwogICAgICAgIHV2ICs9IHZlYzIoMC4wMTUsIDAuMDYpICogdVRpbWU7CiAgICAgICAgZmxvYXQgZCA9IGZibSh1dik7CiAgICAgICAgZCA9IHNtb290aHN0ZXAoMC4yLCAwLjY1LCBkKTsKICAgICAgICBmbG9hdCB2TWFzayA9IHNtb290aHN0ZXAoMC44NSwgMC4yNSwgdlV2LnkpOwogICAgICAgIHZlYzMgY29sb3IgPSB2ZWMzKDAuNTUsIDAuNTIsIDAuNDgpOwogICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIGQgKiB2TWFzayAqIHVPcGFjaXR5KTsKICAgICAgfQogICAgYCx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExLGJsZW5kaW5nOjF9KSxhPW5ldyB0dChuLHMpO2EucmVuZGVyT3JkZXI9MTA7Y29uc3Qgbz1uZXcgZHQ7cmV0dXJuIG8uYWRkKGEpLHtncm91cDpvLHVwZGF0ZShsKXtyLnVUaW1lLnZhbHVlKz1sKi4xNX0sc2V0T3BhY2l0eShsKXtyLnVPcGFjaXR5LnZhbHVlPS4xOCpNYXRoLm1heCgwLE1hdGgubWluKDEsbC8xMDApKX0sZGlzcG9zZSgpe24uZGlzcG9zZSgpLHMuZGlzcG9zZSgpfX19ZnVuY3Rpb24gY2goaSxlKXtjb25zdCB0PWkudmlld1dpZHRoLG49aS52aWV3SGVpZ2h0LHI9bmV3IGV0KHQqMS4yLG4qMS4yKSxzPXt1VGltZTp7dmFsdWU6MH0sdU9wYWNpdHk6e3ZhbHVlOi41KihlfHwuNSkqKGkub3BhY2l0eS8xMDApfSx1UmVzb2x1dGlvbjp7dmFsdWU6bmV3IFBlKHQsbil9fSxhPW5ldyBsdCh7dW5pZm9ybXM6cyx2ZXJ0ZXhTaGFkZXI6YAogICAgICB2YXJ5aW5nIHZlYzIgdlV2OwogICAgICB2b2lkIG1haW4oKSB7CiAgICAgICAgdlV2ID0gdXY7CiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTsKICAgICAgfQogICAgYCxmcmFnbWVudFNoYWRlcjpgCiAgICAgIHZhcnlpbmcgdmVjMiB2VXY7CiAgICAgIHVuaWZvcm0gZmxvYXQgdVRpbWU7CiAgICAgIHVuaWZvcm0gZmxvYXQgdU9wYWNpdHk7CiAgICAgIHVuaWZvcm0gdmVjMiB1UmVzb2x1dGlvbjsKICAgICAgZmxvYXQgaGFzaCh2ZWMyIHApIHsgcmV0dXJuIGZyYWN0KHNpbihkb3QocCwgdmVjMigxMjcuMSwgMzExLjcpKSkgKiA0Mzc1OC41NDUzKTsgfQogICAgICBmbG9hdCBub2lzZSh2ZWMyIHApIHsKICAgICAgICB2ZWMyIGkgPSBmbG9vcihwKTsgdmVjMiBmID0gZnJhY3QocCk7CiAgICAgICAgdmVjMiB1ID0gZiAqIGYgKiAoMy4wIC0gMi4wICogZik7CiAgICAgICAgcmV0dXJuIG1peChtaXgoaGFzaChpKSwgaGFzaChpK3ZlYzIoMSwwKSksIHUueCksIG1peChoYXNoKGkrdmVjMigwLDEpKSwgaGFzaChpK3ZlYzIoMSwxKSksIHUueCksIHUueSk7CiAgICAgIH0KICAgICAgZmxvYXQgZmJtKHZlYzIgcCkgewogICAgICAgIGZsb2F0IHYgPSAwLjAsIGFtcCA9IDAuNTsKICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDQ7IGkrKykgeyB2ICs9IGFtcCAqIG5vaXNlKHApOyBwICo9IDIuMDsgYW1wICo9IDAuNTsgfQogICAgICAgIHJldHVybiB2OwogICAgICB9CiAgICAgIHZvaWQgbWFpbigpIHsKICAgICAgICB2ZWMyIHV2ID0gdlV2OwogICAgICAgIGZsb2F0IHQgPSB1di54ICogMC42ICsgdXYueSAqIDAuNCArIHVUaW1lICogMC4wMTI7CiAgICAgICAgZmxvYXQgbiA9IGZibSh1diAqIDMuMCArIHVUaW1lICogMC4wMyk7CiAgICAgICAgdCA9IGZyYWN0KHQgKyBuICogMC4xNSk7CiAgICAgICAgdmVjMyBjb2w7CiAgICAgICAgaWYgKHQgPCAwLjIpIGNvbCA9IG1peCh2ZWMzKDAuMzgsIDAuNjUsIDAuOTgpLCB2ZWMzKDAuOTEsIDAuNDcsIDAuOTgpLCB0ICogNS4wKTsKICAgICAgICBlbHNlIGlmICh0IDwgMC40KSBjb2wgPSBtaXgodmVjMygwLjkxLCAwLjQ3LCAwLjk4KSwgdmVjMygwLjM4LCAwLjY1LCAwLjk4KSwgKHQgLSAwLjIpICogNS4wKTsKICAgICAgICBlbHNlIGlmICh0IDwgMC42KSBjb2wgPSBtaXgodmVjMygwLjM4LCAwLjY1LCAwLjk4KSwgdmVjMygwLjM3LCAwLjkyLCAwLjgzKSwgKHQgLSAwLjQpICogNS4wKTsKICAgICAgICBlbHNlIGlmICh0IDwgMC44KSBjb2wgPSBtaXgodmVjMygwLjM3LCAwLjkyLCAwLjgzKSwgdmVjMygwLjM4LCAwLjY1LCAwLjk4KSwgKHQgLSAwLjYpICogNS4wKTsKICAgICAgICBlbHNlIGNvbCA9IG1peCh2ZWMzKDAuMzgsIDAuNjUsIDAuOTgpLCB2ZWMzKDAuOTEsIDAuNDcsIDAuOTgpLCAodCAtIDAuOCkgKiA1LjApOwogICAgICAgIHZlYzIgZnJvbVRvcFJpZ2h0ID0gdXYgLSB2ZWMyKDEuMCwgMC4wKTsKICAgICAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGZyb21Ub3BSaWdodCkgKiAxLjQ7CiAgICAgICAgZmxvYXQgbWFzayA9IDEuMCAtIHNtb290aHN0ZXAoMC4zLCAxLjAsIGRpc3QpOwogICAgICAgIGZsb2F0IGFscGhhID0gbWFzayAqIHVPcGFjaXR5ICogKDAuOSArIDAuMSAqIG4pOwogICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sLCBhbHBoYSk7CiAgICAgIH0KICAgIGAsdHJhbnNwYXJlbnQ6ITAsZGVwdGhXcml0ZTohMSxibGVuZGluZzoyfSksbz1uZXcgdHQocixhKTtvLnBvc2l0aW9uLnNldCgwLDAsLTkpLG8ucmVuZGVyT3JkZXI9OTtjb25zdCBsPW5ldyBkdDtsLmFkZChvKTtsZXQgYz1lfHwuNTtjb25zdCBoPSgpPT57Y29uc3QgZD0uNSpjKk1hdGgubWF4KDAsTWF0aC5taW4oMSxpLm9wYWNpdHkvMTAwKSk7cy51T3BhY2l0eS52YWx1ZT1kfTtyZXR1cm57Z3JvdXA6bCx1cGRhdGUoZCl7cy51VGltZS52YWx1ZSs9ZH0sc2V0T3BhY2l0eSgpe2goKX0sc2V0VmlzaWJpbGl0eVNjb3JlKGQpe2M9ZHx8LjUsaCgpfSxkaXNwb3NlKCl7ci5kaXNwb3NlKCksYS5kaXNwb3NlKCl9fX1jb25zdCBCcz1be3dpZHRoOjEsY29sb3JBOls3MS8yNTUsNjAvMjU1LDEyMC8yNTVdLGNvbG9yQjpbMjQ3LzI1NSw0Mi8yNTUsNTkvMjU1XSxzcGVlZDoxLjI2fSx7d2lkdGg6LjksY29sb3JBOlsyNC8yNTUsMTk2LzI1NSwxNTMvMjU1XSxjb2xvckI6WzIxNi8yNTUsMjQwLzI1NSw5NC8yNTVdLHNwZWVkOjEuNTd9LHt3aWR0aDouOCxjb2xvckE6WzI1NS8yNTUsMjIxLzI1NSwwLzI1NV0sY29sb3JCOls2Mi8yNTUsNTEvMjU1LDI1NS8yNTVdLHNwZWVkOjIuMDl9LHt3aWR0aDouNyxjb2xvckE6WzEyMC8yNTUsMjQvMjU1LDcyLzI1NV0sY29sb3JCOlsyNDIvMjU1LDE4Ny8yNTUsMjMzLzI1NV0sc3BlZWQ6My4xNH0se3dpZHRoOi42LGNvbG9yQTpbNjYvMjU1LDI0Mi8yNTUsMTYxLzI1NV0sY29sb3JCOlsyNDQvMjU1LDI0Ni8yNTUsMTczLzI1NV0sc3BlZWQ6Ni4yOH1dO2Z1bmN0aW9uIHVoKGksZSx0KXtpZih0PT09Im5vcnRoZXJuLWdyYWRpZW50cyIpcmV0dXJuIGNoKGksZSk7Y29uc3Qgbj1pLnZpZXdXaWR0aCxzPWkudmlld0hlaWdodC8yLTIsYT01LG89bmV3IGR0LGw9YAogICAgdmFyeWluZyB2ZWMyIHZVdjsKICAgIHZvaWQgbWFpbigpIHsKICAgICAgdlV2ID0gdXY7CiAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7CiAgICB9CiAgYCxjPWAKICAgIHZhcnlpbmcgdmVjMiB2VXY7CiAgICB1bmlmb3JtIGZsb2F0IHVUaW1lOwogICAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTsKICAgIHVuaWZvcm0gdmVjMyB1Q29sb3JBOwogICAgdW5pZm9ybSB2ZWMzIHVDb2xvckI7CiAgICB1bmlmb3JtIGZsb2F0IHVTcGVlZDsKICAgIHZvaWQgbWFpbigpIHsKICAgICAgZmxvYXQgdCA9IDAuNSArIDAuNSAqIHNpbih1VGltZSAqIHVTcGVlZCk7CiAgICAgIHZlYzMgY29sID0gbWl4KHVDb2xvckEsIHVDb2xvckIsIHQpOwogICAgICBmbG9hdCBkaXN0ID0gYWJzKHZVdi55IC0gMC41KSAqIDIuMDsKICAgICAgZmxvYXQgYWxwaGEgPSAoMS4wIC0gc21vb3Roc3RlcCgwLjMsIDEuMCwgZGlzdCkpICogdU9wYWNpdHk7CiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sLCBhbHBoYSk7CiAgICB9CiAgYDtmb3IobGV0IHA9MDtwPEJzLmxlbmd0aDtwKyspe2NvbnN0IF89QnNbcF0seD1uKl8ud2lkdGgsbT1uZXcgZXQoeCxhKSx1PXt1VGltZTp7dmFsdWU6MH0sdU9wYWNpdHk6e3ZhbHVlOi40KihlfHwuNSkqKGkub3BhY2l0eS8xMDApfSx1Q29sb3JBOnt2YWx1ZTpuZXcgTygpLmZyb21BcnJheShfLmNvbG9yQSl9LHVDb2xvckI6e3ZhbHVlOm5ldyBPKCkuZnJvbUFycmF5KF8uY29sb3JCKX0sdVNwZWVkOnt2YWx1ZTpfLnNwZWVkfX0sVD1uZXcgbHQoe3VuaWZvcm1zOnUsdmVydGV4U2hhZGVyOmwsZnJhZ21lbnRTaGFkZXI6Yyx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExLGJsZW5kaW5nOjJ9KSx5PW5ldyB0dChtLFQpO3kucG9zaXRpb24uc2V0KDAscy1wKihhKzEpLC04KSx5LnJlbmRlck9yZGVyPTksby5hZGQoeSl9bGV0IGg9ZXx8LjU7Y29uc3QgZD1vLmNoaWxkcmVuLGY9KCk9Pntjb25zdCBwPS40KmgqTWF0aC5tYXgoMCxNYXRoLm1pbigxLGkub3BhY2l0eS8xMDApKTtmb3IoY29uc3QgXyBvZiBkKV8ubWF0ZXJpYWwudW5pZm9ybXMudU9wYWNpdHkudmFsdWU9cH07cmV0dXJue2dyb3VwOm8sdXBkYXRlKHApe2Zvcihjb25zdCBfIG9mIGQpXy5tYXRlcmlhbC51bmlmb3Jtcy51VGltZS52YWx1ZSs9cH0sc2V0T3BhY2l0eSgpe2YoKX0sc2V0VmlzaWJpbGl0eVNjb3JlKHApe2g9cHx8LjUsZigpfSxkaXNwb3NlKCl7Zm9yKGNvbnN0IHAgb2YgZClwLmdlb21ldHJ5LmRpc3Bvc2UoKSxwLm1hdGVyaWFsLmRpc3Bvc2UoKX19fWZ1bmN0aW9uIGhoKGksZSl7Y29uc3QgdD1pPT09ImZvZ19kZW5zZSIsbj10Py4yMjU6LjExLHI9ZT8uODU6MSxzPXQ/W3tzY2FsZToxKnIsc3BlZWQ6LjI4LGludGVuc2l0eToxLGZsb3c6bmV3IFBlKC4wOCwuMDIpLGxvdzouMjUsaGlnaDouNzgsY29udHJhc3Q6MS4xLGNvbG9yOlsuODYsLjg5LC45NV19LHtzY2FsZToxLjYqcixzcGVlZDouMzYsaW50ZW5zaXR5Oi44NSxmbG93Om5ldyBQZSgtLjA1LC4wMjUpLGxvdzouMixoaWdoOi43LGNvbnRyYXN0OjEuMjIsY29sb3I6Wy45LC45MiwuOTddfV06W3tzY2FsZToxLjIqcixzcGVlZDouMjIsaW50ZW5zaXR5Oi43NSxmbG93Om5ldyBQZSguMDUsLjAxNSksbG93Oi4zLGhpZ2g6LjgyLGNvbnRyYXN0OjEuMTUsY29sb3I6Wy44OCwuOTEsLjk2XX0se3NjYWxlOjEuOSpyLHNwZWVkOi4zLGludGVuc2l0eTouNTUsZmxvdzpuZXcgUGUoLS4wMywuMDEyKSxsb3c6LjI1LGhpZ2g6Ljc1LGNvbnRyYXN0OjEuMjIsY29sb3I6Wy44LC44NCwuOTJdfV07cmV0dXJue2Jhc2VPcGFjaXR5Om4sbGF5ZXJzOnN9fWNvbnN0IGRoPWAKICB2YXJ5aW5nIHZlYzIgdlV2OwogIHVuaWZvcm0gZmxvYXQgdVRpbWU7CiAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTsKICB1bmlmb3JtIGZsb2F0IHVTY2FsZTsKICB1bmlmb3JtIHZlYzIgdUZsb3c7CiAgdW5pZm9ybSB2ZWMyIHVSZXNvbHV0aW9uOwogIHVuaWZvcm0gZmxvYXQgdUxvdzsKICB1bmlmb3JtIGZsb2F0IHVIaWdoOwogIHVuaWZvcm0gZmxvYXQgdUNvbnRyYXN0OwogIHVuaWZvcm0gdmVjMyB1Q29sb3I7CiAgZmxvYXQgaGFzaCh2ZWMyIHApIHsgcmV0dXJuIGZyYWN0KHNpbihkb3QocCwgdmVjMigxMjcuMSwgMzExLjcpKSkgKiA0Mzc1OC41NDUzMTIzKTsgfQogIGZsb2F0IG5vaXNlKHZlYzIgcCkgewogICAgdmVjMiBpID0gZmxvb3IocCk7CiAgICB2ZWMyIGYgPSBmcmFjdChwKTsKICAgIHZlYzIgdSA9IGYgKiBmICogKDMuMCAtIDIuMCAqIGYpOwogICAgcmV0dXJuIG1peCgKICAgICAgbWl4KGhhc2goaSksIGhhc2goaSArIHZlYzIoMSwwKSksIHUueCksCiAgICAgIG1peChoYXNoKGkgKyB2ZWMyKDAsMSkpLCBoYXNoKGkgKyB2ZWMyKDEsMSkpLCB1LngpLCB1LnkpOwogIH0KICBmbG9hdCBmYm0odmVjMiBwKSB7CiAgICBmbG9hdCB2ID0gMC4wLCBhbXAgPSAwLjU7CiAgICBmb3IgKGludCBpID0gMDsgaSA8IDU7IGkrKykgewogICAgICB2ICs9IGFtcCAqIG5vaXNlKHApOwogICAgICBwICo9IDIuMDsKICAgICAgYW1wICo9IDAuNTsKICAgIH0KICAgIHJldHVybiB2OwogIH0KICB2b2lkIG1haW4oKSB7CiAgICB2ZWMyIGFzcGVjdCA9IHZlYzIodVJlc29sdXRpb24ueCAvIG1heCh1UmVzb2x1dGlvbi55LCAwLjAwMDEpLCAxLjApOwogICAgdmVjMiB1diA9ICh2VXYgLSAwLjUpICogYXNwZWN0ICsgMC41OwogICAgdXYgKj0gdVNjYWxlOwogICAgdXYgKz0gdUZsb3cgKiB1VGltZTsKICAgIGZsb2F0IHByaW1hcnkgPSBmYm0odXYpOwogICAgZmxvYXQgZGV0YWlsID0gZmJtKHV2ICogMS44IC0gdUZsb3cueXggKiAodVRpbWUgKiAwLjM1KSk7CiAgICBmbG9hdCBkZW5zaXR5ID0gbWl4KHByaW1hcnksIGRldGFpbCwgMC4zNSk7CiAgICBkZW5zaXR5ID0gc21vb3Roc3RlcCh1TG93LCB1SGlnaCwgZGVuc2l0eSk7CiAgICBkZW5zaXR5ID0gcG93KGRlbnNpdHksIHVDb250cmFzdCk7CiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVDb2xvciwgZGVuc2l0eSAqIHVPcGFjaXR5KTsKICB9CmA7ZnVuY3Rpb24gZmgoaSl7Y29uc3QgZT1uZXcgZHQsdD1oaChpLmVmZmVjdCxpLmlzTW9iaWxlKSxuPWkuY2xvdWRDb3ZlcmFnZSxyPW4hPW51bGw/LjYrbi8xMDAqLjU6MSxzPXQubGF5ZXJzLm1hcChhPT57Y29uc3Qgbz1uZXcgZXQoaS52aWV3V2lkdGgsaS52aWV3SGVpZ2h0KSxsPXt1VGltZTp7dmFsdWU6MH0sdU9wYWNpdHk6e3ZhbHVlOnQuYmFzZU9wYWNpdHkqYS5pbnRlbnNpdHkqKGkub3BhY2l0eS8xMDApKnJ9LHVTY2FsZTp7dmFsdWU6YS5zY2FsZX0sdUZsb3c6e3ZhbHVlOmEuZmxvdy5jbG9uZSgpfSx1UmVzb2x1dGlvbjp7dmFsdWU6bmV3IFBlKGkudmlld1dpZHRoLGkudmlld0hlaWdodCl9LHVMb3c6e3ZhbHVlOmEubG93fSx1SGlnaDp7dmFsdWU6YS5oaWdofSx1Q29udHJhc3Q6e3ZhbHVlOmEuY29udHJhc3R9LHVDb2xvcjp7dmFsdWU6bmV3IFZlKGEuY29sb3JbMF0sYS5jb2xvclsxXSxhLmNvbG9yWzJdKX19LGM9bmV3IGx0KHt1bmlmb3JtczpsLHZlcnRleFNoYWRlcjpfcixmcmFnbWVudFNoYWRlcjpkaCx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExLGJsZW5kaW5nOjF9KSxoPW5ldyB0dChvLGMpO3JldHVybiBoLnJlbmRlck9yZGVyPS0zLGUuYWRkKGgpLHttZXNoOmgsdW5pZm9ybXM6bCxjb25maWc6YX19KTtyZXR1cm57Z3JvdXA6ZSx1cGRhdGUoYSl7cy5mb3JFYWNoKG89PntvLnVuaWZvcm1zLnVUaW1lLnZhbHVlKz1hKm8uY29uZmlnLnNwZWVkfSl9LHNldE9wYWNpdHkoYSl7Y29uc3Qgbz1NYXRoLm1heCgwLE1hdGgubWluKDEsYS8xMDApKSxsPWkuaXNNb2JpbGU/Ljc1OjE7cy5mb3JFYWNoKGM9PntjLnVuaWZvcm1zLnVPcGFjaXR5LnZhbHVlPXQuYmFzZU9wYWNpdHkqYy5jb25maWcuaW50ZW5zaXR5Km8qbH0pfSxvblJlc2l6ZShhLG8pe2kudmlld1dpZHRoPWEsaS52aWV3SGVpZ2h0PW8scy5mb3JFYWNoKGw9PntsLnVuaWZvcm1zLnVSZXNvbHV0aW9uLnZhbHVlLnNldChhLG8pLGwubWVzaC5nZW9tZXRyeS5kaXNwb3NlKCksbC5tZXNoLmdlb21ldHJ5PW5ldyBldChhLG8pfSl9LGRpc3Bvc2UoKXtzLmZvckVhY2goYT0+e2EubWVzaC5nZW9tZXRyeS5kaXNwb3NlKCksYS5tZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKX0pfX19ZnVuY3Rpb24gcGgoaSl7Y29uc3QgZT1uZXcgZHQ7bGV0IHQ9bmV3IGV0KGkudmlld1dpZHRoLGkudmlld0hlaWdodCk7Y29uc3Qgbj1pLnN1blBvc2l0aW9ufHx7YXppbXV0aDoxODAsZWxldmF0aW9uOjQ1LHV2SW5kZXg6M30scj1NYXRoLm1heCgwLE1hdGgubWluKDEsKG4uYXppbXV0aC05MCkvMTgwKSkscz0uMDgrLjM1KigxLU1hdGgubWluKDkwLE1hdGgubWF4KDAsbi5lbGV2YXRpb24pKS85MCksYT17dVRpbWU6e3ZhbHVlOjB9LHVPcGFjaXR5Ont2YWx1ZTppLm9wYWNpdHkvMTAwfSx1Vmlld1NpemU6e3ZhbHVlOm5ldyBQZShpLnZpZXdXaWR0aCxpLnZpZXdIZWlnaHQpfSx1T3JpZ2luOnt2YWx1ZTpuZXcgUGUocixzKX0sdVV2SW5kZXg6e3ZhbHVlOm4udXZJbmRleH19LG89bmV3IGx0KHt1bmlmb3JtczphLHZlcnRleFNoYWRlcjoidmFyeWluZyB2ZWMzIHZQb3NpdGlvbjsgdm9pZCBtYWluKCkgeyB2UG9zaXRpb24gPSBwb3NpdGlvbjsgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTsgfSIsZnJhZ21lbnRTaGFkZXI6YAogICAgICB2YXJ5aW5nIHZlYzMgdlBvc2l0aW9uOwogICAgICB1bmlmb3JtIHZlYzIgdVZpZXdTaXplOwogICAgICB1bmlmb3JtIHZlYzIgdU9yaWdpbjsKICAgICAgdW5pZm9ybSBmbG9hdCB1VGltZTsKICAgICAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTsKICAgICAgdW5pZm9ybSBmbG9hdCB1VXZJbmRleDsKICAgICAgdm9pZCBtYWluKCkgewogICAgICAgIHZlYzIgdXYgPSB2ZWMyKCh2UG9zaXRpb24ueCAvIHVWaWV3U2l6ZS54KSArIDAuNSwgKHZQb3NpdGlvbi55IC8gdVZpZXdTaXplLnkpICsgMC41KTsKICAgICAgICB2ZWMyIGRpciA9IHVPcmlnaW4gLSB1djsKICAgICAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGRpcik7CiAgICAgICAgZmxvYXQgYW5nbGUgPSBhdGFuKGRpci55LCBkaXIueCk7CiAgICAgICAgZmxvYXQgYmVhbXMgPSBzaW4oYW5nbGUgKiAxOC4wICsgdVRpbWUgKiAwLjgpICogMC41ICsgMC41OwogICAgICAgIGZsb2F0IGludGVuc2l0eSA9IHNtb290aHN0ZXAoMC42LCAwLjAsIGRpc3QpICogYmVhbXM7CiAgICAgICAgZmxvYXQgYWxwaGEgPSBpbnRlbnNpdHkgKiAwLjY1ICogdU9wYWNpdHk7CiAgICAgICAgdmVjMyBjb2xvcjsKICAgICAgICBpZiAodVV2SW5kZXggPj0gNi4wKSB7CiAgICAgICAgICBjb2xvciA9IG1peCh2ZWMzKDEuMCwgMC41LCAwLjE1KSwgdmVjMygxLjAsIDAuMzUsIDAuMSksIGRpc3QpOwogICAgICAgIH0gZWxzZSBpZiAodVV2SW5kZXggPj0gNC4wKSB7CiAgICAgICAgICBjb2xvciA9IG1peCh2ZWMzKDEuMCwgMC43NSwgMC4zNSksIHZlYzMoMS4wLCAwLjU1LCAwLjIpLCBkaXN0KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29sb3IgPSBtaXgodmVjMygxLjAsIDAuOTUsIDAuOCksIHZlYzMoMS4wLCAwLjg1LCAwLjQpLCBkaXN0KTsKICAgICAgICB9CiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgYWxwaGEpOwogICAgICB9CiAgICBgLHRyYW5zcGFyZW50OiEwLGRlcHRoV3JpdGU6ITEsYmxlbmRpbmc6Mn0pLGw9bmV3IHR0KHQsbyk7cmV0dXJuIGwucG9zaXRpb24uc2V0KDAsMCwtMiksZS5hZGQobCkse2dyb3VwOmUsdXBkYXRlKGMsaCxkKXtpZihhLnVUaW1lLnZhbHVlKz1jLGQ/LnN1blBvc2l0aW9uKXtjb25zdCBmPWQuc3VuUG9zaXRpb247YS51T3JpZ2luLnZhbHVlLnNldChNYXRoLm1heCgwLE1hdGgubWluKDEsKGYuYXppbXV0aC05MCkvMTgwKSksLjA4Ky4zNSooMS1NYXRoLm1pbig5MCxNYXRoLm1heCgwLGYuZWxldmF0aW9uKSkvOTApKSxhLnVVdkluZGV4LnZhbHVlPWYudXZJbmRleD8/M319LHNldE9wYWNpdHkoYyl7YS51T3BhY2l0eS52YWx1ZT1NYXRoLm1heCgwLE1hdGgubWluKDEsYy8xMDApKX0sb25SZXNpemUoYyxoKXtpLnZpZXdXaWR0aD1jLGkudmlld0hlaWdodD1oLGEudVZpZXdTaXplLnZhbHVlLnNldChjLGgpLHQuZGlzcG9zZSgpLHQ9bmV3IGV0KGMsaCksbC5nZW9tZXRyeT10fSxkaXNwb3NlKCl7dC5kaXNwb3NlKCksby5kaXNwb3NlKCl9fX1mdW5jdGlvbiBtaChpKXtjb25zdCBlPW5ldyBkdCx0PS42LG49aS5jbG91ZENvdmVyYWdlLHI9biE9bnVsbD8uNStuLzEwMCouNToxLHM9aS5jbG91ZFNwZWVkTXVsdGlwbGllcj8/MTtsZXQgYT1uZXcgZXQoaS52aWV3V2lkdGgsaS52aWV3SGVpZ2h0KnQpO2NvbnN0IG89e3VUaW1lOnt2YWx1ZTowfSx1T3BhY2l0eTp7dmFsdWU6aS5vcGFjaXR5LzEwMCouMjQqcn0sdVZpZXdTaXplOnt2YWx1ZTpuZXcgUGUoaS52aWV3V2lkdGgsaS52aWV3SGVpZ2h0KX0sdVNjYWxlOnt2YWx1ZTppLmlzTW9iaWxlPzEuNToxfX0sbD1gCiAgICB2YXJ5aW5nIHZlYzIgdlV2OwogICAgdW5pZm9ybSBmbG9hdCB1VGltZTsKICAgIHVuaWZvcm0gZmxvYXQgdU9wYWNpdHk7CiAgICB1bmlmb3JtIGZsb2F0IHVTY2FsZTsKICAgIGZsb2F0IGhhc2godmVjMiBwKSB7IHJldHVybiBmcmFjdChzaW4oZG90KHAsIHZlYzIoMTIuOTg5OCwgNzguMjMzKSkpICogNDM3NTguNTQ1Myk7IH0KICAgIGZsb2F0IG5vaXNlKHZlYzIgcCkgewogICAgICB2ZWMyIGkgPSBmbG9vcihwKTsKICAgICAgdmVjMiBmID0gZnJhY3QocCk7CiAgICAgIHZlYzIgdSA9IGYgKiBmICogKDMuMCAtIDIuMCAqIGYpOwogICAgICByZXR1cm4gbWl4KG1peChoYXNoKGkpLCBoYXNoKGkrdmVjMigxLDApKSwgdS54KSwgbWl4KGhhc2goaSt2ZWMyKDAsMSkpLCBoYXNoKGkrdmVjMigxLDEpKSwgdS54KSwgdS55KTsKICAgIH0KICAgIGZsb2F0IGZibSh2ZWMyIHApIHsKICAgICAgZmxvYXQgdiA9IDAuMCwgYW1wID0gMC41LCBmcmVxID0gMS4wOwogICAgICBmb3IgKGludCBpID0gMDsgaSA8IDY7IGkrKykgewogICAgICAgIHYgKz0gYW1wICogbm9pc2UocCAqIGZyZXEpOwogICAgICAgIGFtcCAqPSAwLjU7CiAgICAgICAgZnJlcSAqPSAyLjA7CiAgICAgIH0KICAgICAgcmV0dXJuIHY7CiAgICB9CiAgICB2b2lkIG1haW4oKSB7CiAgICAgIHZlYzIgdXYgPSB2VXYgKiB1U2NhbGU7CiAgICAgIGZsb2F0IHRpbWUgPSB1VGltZSAqIDAuMDU7CiAgICAgIHZlYzIgcSA9IHZlYzIoZmJtKHV2ICsgdmVjMih0aW1lICogMC41LCB0aW1lICogMC4yKSksIGZibSh1diArIHZlYzIoMS4wKSkpOwogICAgICB2ZWMyIHIgPSB2ZWMyKGZibSh1diArIHEgKyB2ZWMyKDEuNywgOS4yKSArIDAuMTUgKiB0aW1lKSwgZmJtKHV2ICsgcSArIHZlYzIoOC4zLCAyLjgpICsgMC4xMjYgKiB0aW1lKSk7CiAgICAgIGZsb2F0IGYgPSBmYm0odXYgKyByKTsKICAgICAgZmxvYXQgY2xvdWQgPSBzbW9vdGhzdGVwKDAuMiwgMC43LCBmKTsKICAgICAgY2xvdWQgKj0gc21vb3Roc3RlcCgwLjAsIDAuMywgdlV2LnkpOwogICAgICBjbG91ZCAqPSBzbW9vdGhzdGVwKDEuMCwgMC44LCB2VXYueSk7CiAgICAgIGZsb2F0IHNoYWRvdyA9IHNtb290aHN0ZXAoMC4zLCAwLjYsIGZibSh1diAqIDIuMCArIHIgKyB2ZWMyKDAuNSkpKTsKICAgICAgdmVjMyBjb2xvciA9IG1peCh2ZWMzKDAuODEsIDAuODIsIDAuODkpLCB2ZWMzKDEuMCksIHNoYWRvdyAqIDAuOCArIDAuMik7CiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIGNsb3VkICogdU9wYWNpdHkpOwogICAgfQogIGAsYz1uZXcgbHQoe3VuaWZvcm1zOm8sdmVydGV4U2hhZGVyOiJ2YXJ5aW5nIHZlYzIgdlV2OyB2b2lkIG1haW4oKSB7IHZVdiA9IHV2OyBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApOyB9IixmcmFnbWVudFNoYWRlcjpsLHRyYW5zcGFyZW50OiEwLGRlcHRoV3JpdGU6ITEsYmxlbmRpbmc6MX0pLGg9bmV3IHR0KGEsYyk7cmV0dXJuIGgucG9zaXRpb24uc2V0KDAsaS52aWV3SGVpZ2h0Ki4yNSwtNiksaC5yZW5kZXJPcmRlcj0tMixlLmFkZChoKSx7Z3JvdXA6ZSx1cGRhdGUoZCl7by51VGltZS52YWx1ZSs9ZCpzfSxzZXRPcGFjaXR5KGQpe28udU9wYWNpdHkudmFsdWU9TWF0aC5tYXgoMCxNYXRoLm1pbigxLGQvMTAwKSl9LG9uUmVzaXplKGQsZixwKXthLmRpc3Bvc2UoKSxhPW5ldyBldChkLGYqdCksaC5nZW9tZXRyeT1hLG8udVZpZXdTaXplLnZhbHVlLnNldChkLGYpLG8udVNjYWxlLnZhbHVlPXA/MS41OjEsaC5wb3NpdGlvbi5zZXQoMCxmKi4yNSwtNil9LGRpc3Bvc2UoKXthLmRpc3Bvc2UoKSxjLmRpc3Bvc2UoKX19fWZ1bmN0aW9uIHpzKGkpe2NvbnN0IGU9bmV3IGR0LHQ9YAogICAgdmFyeWluZyB2ZWMyIHZVdjsKICAgIHVuaWZvcm0gZmxvYXQgdUZsYXNoOwogICAgdW5pZm9ybSB2ZWMyIHVPcmlnaW47CiAgICB1bmlmb3JtIGZsb2F0IHVUaW1lOwogICAgZmxvYXQgaGFzaChmbG9hdCBuKSB7IHJldHVybiBmcmFjdChzaW4obikgKiA0Mzc1OC41NDUzKTsgfQogICAgZmxvYXQgamFnZ2VkTGluZSh2ZWMyIHV2LCBmbG9hdCBhbmNob3IsIGZsb2F0IHNlZWQpIHsKICAgICAgZmxvYXQgc2VnbWVudHMgPSA4LjA7CiAgICAgIGZsb2F0IHByb2dyZXNzID0gY2xhbXAoMS4wIC0gdXYueSwgMC4wLCAwLjk5OSkgKiBzZWdtZW50czsKICAgICAgZmxvYXQgaWR4ID0gZmxvb3IocHJvZ3Jlc3MpOwogICAgICBmbG9hdCBmcmFjID0gZnJhY3QocHJvZ3Jlc3MpOwogICAgICBmbG9hdCBvZmZzZXRBID0gaGFzaChzZWVkICsgaWR4KSAqIDAuMjQgLSAwLjEyOwogICAgICBmbG9hdCBvZmZzZXRCID0gaGFzaChzZWVkICsgaWR4ICsgMS4wKSAqIDAuMjQgLSAwLjEyOwogICAgICBmbG9hdCBvZmZzZXQgPSBtaXgob2Zmc2V0QSwgb2Zmc2V0Qiwgc21vb3Roc3RlcCgwLjAsIDEuMCwgZnJhYykpOwogICAgICBmbG9hdCB3aWR0aCA9IG1peCgwLjAwNiwgMC4wMiwgaGFzaChzZWVkICsgaWR4ICogMS43KSk7CiAgICAgIGZsb2F0IHRhcmdldCA9IGFuY2hvciArIG9mZnNldDsKICAgICAgZmxvYXQgZGlzdCA9IGFicyh1di54IC0gdGFyZ2V0KTsKICAgICAgZmxvYXQgaW50ZW5zaXR5ID0gc21vb3Roc3RlcCh3aWR0aCwgMC4wLCBkaXN0KTsKICAgICAgZmxvYXQgZmFkZSA9IHNtb290aHN0ZXAoMC4wLCAwLjksIDEuMCAtIHV2LnkpOwogICAgICByZXR1cm4gaW50ZW5zaXR5ICogZmFkZTsKICAgIH0KICAgIHZvaWQgbWFpbigpIHsKICAgICAgZmxvYXQgc2VlZCA9IGZsb29yKHVUaW1lICogMTEuMCk7CiAgICAgIGZsb2F0IGNvcmUgPSBqYWdnZWRMaW5lKHZVdiwgdU9yaWdpbi54LCBzZWVkKTsKICAgICAgZmxvYXQgaGFsbyA9IGphZ2dlZExpbmUodlV2LCB1T3JpZ2luLnggKyAwLjAwOCwgc2VlZCArIDIuMCkgKiAwLjQ7CiAgICAgIGZsb2F0IGFscGhhID0gY2xhbXAoKGNvcmUgKyBoYWxvKSAqIHVGbGFzaCwgMC4wLCAxLjApOwogICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMC45OCwgMC45LCBhbHBoYSk7CiAgICB9CiAgYCxuPXt1Rmxhc2g6e3ZhbHVlOjB9LHVPcmlnaW46e3ZhbHVlOm5ldyBQZSguODUsMS4wNSl9LHVUaW1lOnt2YWx1ZTowfX07bGV0IHI9bmV3IGV0KGkudmlld1dpZHRoLGkudmlld0hlaWdodCk7Y29uc3Qgcz1uZXcgbHQoe3VuaWZvcm1zOm4sdmVydGV4U2hhZGVyOl9yLGZyYWdtZW50U2hhZGVyOnQsdHJhbnNwYXJlbnQ6ITAsZGVwdGhXcml0ZTohMSxkZXB0aFRlc3Q6ITEsYmxlbmRpbmc6Mn0pLGE9bmV3IHR0KHIscyk7YS5wb3NpdGlvbi5zZXQoMCwwLC02KSxhLnJlbmRlck9yZGVyPTI1LGUuYWRkKGEpO2xldCBvPW5ldyBldChpLnZpZXdXaWR0aCxpLnZpZXdIZWlnaHQpO2NvbnN0IGw9bmV3IGpuKHtjb2xvcjoxNjc3NzIxNSx0cmFuc3BhcmVudDohMCxvcGFjaXR5OjAsZGVwdGhXcml0ZTohMSxkZXB0aFRlc3Q6ITEsYmxlbmRpbmc6Mn0pLGM9bmV3IHR0KG8sbCk7Yy5wb3NpdGlvbi5zZXQoMCwwLC04KSxjLnJlbmRlck9yZGVyPTMwLGUuYWRkKGMpO2NvbnN0IGg9MjA7bGV0IGQ9JGUucmFuZEZsb2F0KDEsMyksZj0wLHA9LjI1LF89MCx4PS0xO2NvbnN0IG09TWF0aC5tYXgoMCxNYXRoLm1pbigxLGkub3BhY2l0eS8xMDApKSx1PSgpPT57cD0kZS5yYW5kRmxvYXQoLjE4LC4zMiksZj1wLG4udUZsYXNoLnZhbHVlPTEsbi51T3JpZ2luLnZhbHVlLnNldCgkZS5yYW5kRmxvYXQoLjYsLjk1KSwkZS5yYW5kRmxvYXQoLjg1LDEuMDUpKSxsLm9wYWNpdHk9TWF0aC5tYXgobC5vcGFjaXR5LC41NSptKy4xNSl9O3JldHVybntncm91cDplLHVwZGF0ZShULHksZyl7Y29uc3QgUD1nPy5saWdodG5pbmdEYXRhLHc9dHlwZW9mIGc/LnNwZWVkX2ZhY3Rvcl9saWdodG5pbmc9PSJudW1iZXIiP2cuc3BlZWRfZmFjdG9yX2xpZ2h0bmluZzoxO2lmKFAmJihQLnN0cmlrZXNUb1RyaWdnZXI+MHx8UC5kaXN0YW5jZUttPjApKXtpZihQLnN0cmlrZXNUb1RyaWdnZXI+MCYmXzw9MCl7Y29uc3QgYj1QLmRpc3RhbmNlS20qMzt4PXkrYixfPWh9eD4wJiZ5Pj14JiYoeD0tMSx1KCkpLF89TWF0aC5tYXgoMCxfLVQqdyl9ZWxzZSBkLT1UKncsZDw9MCYmKGQ9JGUucmFuZEZsb2F0KDEuNSw0KSx1KCkpO2lmKG4udVRpbWUudmFsdWUrPVQsZj4wKXtmLT1UO2NvbnN0IGI9TWF0aC5tYXgoMCxmL01hdGgubWF4KHAsLjAwMSkpO24udUZsYXNoLnZhbHVlPU1hdGgucG93KGIsMS40KSptfWVsc2Ugbi51Rmxhc2gudmFsdWU+MCYmKG4udUZsYXNoLnZhbHVlPU1hdGgubWF4KDAsbi51Rmxhc2gudmFsdWUtVCo4KSk7bC5vcGFjaXR5PU1hdGgubWF4KDAsbC5vcGFjaXR5LVQqNil9LHNldE9wYWNpdHkoVCl7Y29uc3QgeT1NYXRoLm1heCgwLE1hdGgubWluKDEsVC8xMDApKTtuLnVGbGFzaC52YWx1ZSo9eS9tfSxvblJlc2l6ZShULHkpe2kudmlld1dpZHRoPVQsaS52aWV3SGVpZ2h0PXksci5kaXNwb3NlKCkscj1uZXcgZXQoVCx5KSxhLmdlb21ldHJ5PXIsby5kaXNwb3NlKCksbz1uZXcgZXQoVCx5KSxjLmdlb21ldHJ5PW99LGRpc3Bvc2UoKXtyLmRpc3Bvc2UoKSxzLmRpc3Bvc2UoKSxvLmRpc3Bvc2UoKSxsLmRpc3Bvc2UoKX19fWZ1bmN0aW9uIGdoKGkpe2NvbnN0IGU9bmV3IGR0LHQ9aS5pc01vYmlsZT8xMDoxNSxuPW5ldyBldCguMjUsLjI1KSxyPW5ldyBVcztyLmluZGV4PW4uaW5kZXgsci5hdHRyaWJ1dGVzLnBvc2l0aW9uPW4uYXR0cmlidXRlcy5wb3NpdGlvbixyLmF0dHJpYnV0ZXMudXY9bi5hdHRyaWJ1dGVzLnV2LHIuaW5zdGFuY2VDb3VudD10O2NvbnN0IHM9bmV3IEZsb2F0MzJBcnJheSh0KjMpLGE9bmV3IEZsb2F0MzJBcnJheSh0KSxvPW5ldyBGbG9hdDMyQXJyYXkodCksbD1uZXcgRmxvYXQzMkFycmF5KHQpLGM9bmV3IEZsb2F0MzJBcnJheSh0KTtmb3IobGV0IHA9MDtwPHQ7cCsrKXtjb25zdCBfPXAqMztzW19dPSRlLnJhbmRGbG9hdFNwcmVhZChpLnZpZXdXaWR0aCsxMCksc1tfKzFdPSRlLnJhbmRGbG9hdFNwcmVhZChpLnZpZXdIZWlnaHQpLHNbXysyXT1NYXRoLnJhbmRvbSgpKjIsYVtwXT0kZS5yYW5kRmxvYXQoMi44LDQpLG9bcF09JGUucmFuZEZsb2F0KDEuOCwyLjgpLGxbcF09TWF0aC5yYW5kb20oKSpNYXRoLlBJKjIsY1twXT1NYXRoLnJhbmRvbSgpfXIuc2V0QXR0cmlidXRlKCJpbnN0YW5jZU9mZnNldCIsbmV3IEd0KHMsMykpLHIuc2V0QXR0cmlidXRlKCJpbnN0YW5jZVNwZWVkIixuZXcgR3QoYSwxKSksci5zZXRBdHRyaWJ1dGUoImluc3RhbmNlU2l6ZSIsbmV3IEd0KG8sMSkpLHIuc2V0QXR0cmlidXRlKCJpbnN0YW5jZVJvdGF0aW9uIixuZXcgR3QobCwxKSksci5zZXRBdHRyaWJ1dGUoImluc3RhbmNlUGhhc2UiLG5ldyBHdChjLDEpKTtjb25zdCBoPXt1VGltZTp7dmFsdWU6MH0sdU9wYWNpdHk6e3ZhbHVlOmkub3BhY2l0eS8xMDB9LHVWaWV3U2l6ZTp7dmFsdWU6bmV3IFBlKGkudmlld1dpZHRoLGkudmlld0hlaWdodCl9fSxkPW5ldyBsdCh7dW5pZm9ybXM6aCx2ZXJ0ZXhTaGFkZXI6YAogICAgICBhdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZU9mZnNldDsKICAgICAgYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlU3BlZWQ7CiAgICAgIGF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVNpemU7CiAgICAgIGF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVJvdGF0aW9uOwogICAgICBhdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VQaGFzZTsKICAgICAgdW5pZm9ybSBmbG9hdCB1VGltZTsKICAgICAgdW5pZm9ybSB2ZWMyIHVWaWV3U2l6ZTsKICAgICAgdmFyeWluZyBmbG9hdCB2QWxwaGE7CiAgICAgIHZvaWQgbWFpbigpIHsKICAgICAgICBmbG9hdCBwcm9ncmVzcyA9IGZyYWN0KHVUaW1lICogaW5zdGFuY2VTcGVlZCArIGluc3RhbmNlUGhhc2UpOwogICAgICAgIGZsb2F0IHRyYXZlbCA9ICh1Vmlld1NpemUueSAqIDAuNSkgLSBwcm9ncmVzcyAqICh1Vmlld1NpemUueSArIDIwLjApOwogICAgICAgIGZsb2F0IGFuZ2xlID0gaW5zdGFuY2VSb3RhdGlvbiArIHVUaW1lICogaW5zdGFuY2VTcGVlZCAqIDMuMDsKICAgICAgICB2ZWMyIHJvdGF0ZWQgPSB2ZWMyKHBvc2l0aW9uLnggKiBjb3MoYW5nbGUpIC0gcG9zaXRpb24ueSAqIHNpbihhbmdsZSksIHBvc2l0aW9uLnggKiBzaW4oYW5nbGUpICsgcG9zaXRpb24ueSAqIGNvcyhhbmdsZSkpOwogICAgICAgIHZlYzMgdHJhbnNmb3JtZWQgPSB2ZWMzKHJvdGF0ZWQgKiBpbnN0YW5jZVNpemUsIHBvc2l0aW9uLnopOwogICAgICAgIHRyYW5zZm9ybWVkLnggKz0gaW5zdGFuY2VPZmZzZXQueDsKICAgICAgICB0cmFuc2Zvcm1lZC55ICs9IHRyYXZlbCArIGluc3RhbmNlT2Zmc2V0Lnk7CiAgICAgICAgdHJhbnNmb3JtZWQueiArPSAtNS4wICsgaW5zdGFuY2VPZmZzZXQuejsKICAgICAgICB2QWxwaGEgPSAxLjA7CiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCh0cmFuc2Zvcm1lZCwgMS4wKTsKICAgICAgfQogICAgYCxmcmFnbWVudFNoYWRlcjpgCiAgICAgIHVuaWZvcm0gZmxvYXQgdU9wYWNpdHk7CiAgICAgIHZhcnlpbmcgZmxvYXQgdkFscGhhOwogICAgICB2b2lkIG1haW4oKSB7CiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjk1LCAwLjk4LCAxLjAsIHZBbHBoYSAqIHVPcGFjaXR5KTsKICAgICAgfQogICAgYCx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExLGJsZW5kaW5nOjF9KSxmPW5ldyB0dChyLGQpO3JldHVybiBmLmZydXN0dW1DdWxsZWQ9ITEsZS5hZGQoZikse2dyb3VwOmUsdXBkYXRlKHApe2gudVRpbWUudmFsdWUrPXAsaC51Vmlld1NpemUudmFsdWUuc2V0KGkudmlld1dpZHRoLGkudmlld0hlaWdodCl9LHNldE9wYWNpdHkocCl7aC51T3BhY2l0eS52YWx1ZT1NYXRoLm1heCgwLE1hdGgubWluKDEscC8xMDApKX0sb25SZXNpemUocCxfKXtpLnZpZXdXaWR0aD1wLGkudmlld0hlaWdodD1fLGgudVZpZXdTaXplLnZhbHVlLnNldChwLF8pfSxkaXNwb3NlKCl7ci5kaXNwb3NlKCksZC5kaXNwb3NlKCl9fX1sZXQgQXQ9bnVsbDtzZWxmLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLGk9Pntjb25zdCBlPWkuZGF0YTtzd2l0Y2goZS50eXBlKXtjYXNlIklOSVQiOl9oKGUpO2JyZWFrO2Nhc2UiU1RBUlQiOkF0Py5zdGFydChlLmVmZmVjdCxlLm9wYWNpdHksZS5vcHRpb25zfHx7fSk7YnJlYWs7Y2FzZSJTRVRfT1BBQ0lUWSI6QXQ/LnNldE9wYWNpdHkoZS5vcGFjaXR5KTticmVhaztjYXNlIlJFU0laRSI6QXQmJkF0LnJlc2l6ZSh7dmlld3BvcnRXaWR0aDplLnZpZXdwb3J0V2lkdGgsdmlld3BvcnRIZWlnaHQ6ZS52aWV3cG9ydEhlaWdodCxkZXZpY2VQaXhlbFJhdGlvOmUuZGV2aWNlUGl4ZWxSYXRpbyxpc01vYmlsZTplLmlzTW9iaWxlfSk7YnJlYWs7Y2FzZSJTRVRfU05PV19TVVJGQUNFUyI6QXQ/LnNldFNub3dTdXJmYWNlcyhlLnN1cmZhY2VzfHxbXSk7YnJlYWs7Y2FzZSJTVE9QIjpBdD8uc3RvcCgpO2JyZWFrO2Nhc2UiRElTUE9TRSI6QXQmJihBdC5kZXN0cm95KCksQXQ9bnVsbCk7YnJlYWt9fSk7ZnVuY3Rpb24gX2goaSl7dHJ5e0F0JiYoQXQuZGVzdHJveSgpLEF0PW51bGwpLEF0PW5ldyAkdSh7Y2FudmFzOmkuY2FudmFzLHZpZXdwb3J0V2lkdGg6aS52aWV3cG9ydFdpZHRoLHZpZXdwb3J0SGVpZ2h0Omkudmlld3BvcnRIZWlnaHQsZGV2aWNlUGl4ZWxSYXRpbzppLmRldmljZVBpeGVsUmF0aW8/PzEsaXNNb2JpbGU6aS5pc01vYmlsZT8/ITF9KSxzZWxmLnBvc3RNZXNzYWdlKHt0eXBlOiJSRUFEWSJ9KX1jYXRjaChlKXtzZWxmLnBvc3RNZXNzYWdlKHt0eXBlOiJFUlJPUiIsZXJyb3I6ZSBpbnN0YW5jZW9mIEVycm9yP2UubWVzc2FnZTpTdHJpbmcoZSl9KX19fSkoKTsK",Ub=l=>Uint8Array.from(atob(l),t=>t.charCodeAt(0)),Dd=typeof self<"u"&&self.Blob&&new Blob([Ub(_d)],{type:"text/javascript;charset=utf-8"});function Mb(l){let t;try{if(t=Dd&&(self.URL||self.webkitURL).createObjectURL(Dd),!t)throw"";const e=new Worker(t,{name:l?.name});return e.addEventListener("error",()=>{(self.URL||self.webkitURL).revokeObjectURL(t)}),e}catch{return new Worker("data:text/javascript;base64,"+_d,{name:l?.name})}finally{t&&(self.URL||self.webkitURL).revokeObjectURL(t)}}const Ri=typeof window<"u"&&typeof Worker<"u"&&typeof HTMLCanvasElement<"u"&&"transferControlToOffscreen"in HTMLCanvasElement.prototype;class Tb{constructor(t,e={}){this.container=t,this.canvas=document.createElement("canvas"),this.canvas.style.cssText="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--weather-overlay-z,9998);",this.container.appendChild(this.canvas),this.viewportWidth=e.viewportWidth??window.innerWidth,this.viewportHeight=e.viewportHeight??window.innerHeight,this.isMobile=e.isMobile??(window.innerWidth<600||"ontouchstart"in window),this.devicePixelRatio=e.devicePixelRatio??this.effectiveDpr(),this.worker=null,this.workerState="idle",this.workerQueue=[],this.fallbackCore=null,this.currentEffect="none",this.opacity=100,this.effectOptions={},this.resizeHandler=()=>this.handleResize(),window.addEventListener("resize",this.resizeHandler),Ri?this.initWorker():this.ensureFallbackCore()}effectiveDpr(){const t=window.ForkUWeatherAwareConfig||{};let e=window.devicePixelRatio||1;return this.isMobile&&t.mobile_limit_dpr&&(e=Math.min(e,2)),e}useWorkerPath(){return Ri&&this.workerState==="ready"}shouldUseWorkerOrQueue(){return Ri&&this.workerState!=="failed"}shouldUseFallbackCore(){return!Ri||this.workerState==="failed"}initWorker(){if(!this.worker)try{this.worker=new Mb,this.worker.onmessage=e=>{e.data?.type==="READY"?(this.workerState="ready",this.flushWorkerQueue(),this.currentEffect!=="none"&&this.postWorkerMessage({type:"START",effect:this.currentEffect,opacity:this.opacity,options:this.effectOptions})):e.data?.type==="ERROR"&&(console.error("[Weather Overlay] Worker error:",e.data.error),this.handleWorkerFailure())},this.worker.onerror=e=>{console.error("[Weather Overlay] Worker init failed:",e),this.handleWorkerFailure()};const t=this.canvas.transferControlToOffscreen();this.workerState="pending",this.worker.postMessage({type:"INIT",canvas:t,viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile},[t])}catch(t){console.error("[Weather Overlay] Worker creation failed:",t),this.handleWorkerFailure()}}handleWorkerFailure(){this.workerState="failed",this.worker&&(this.worker.terminate(),this.worker=null),this.flushWorkerQueue(!0),this.recreateCanvas(),this.fallbackCore&&(this.fallbackCore.destroy(),this.fallbackCore=null),this.ensureFallbackCore(),this.currentEffect!=="none"&&this.fallbackCore?.start(this.currentEffect,this.opacity,this.effectOptions)}recreateCanvas(){this.canvas?.parentElement&&this.canvas.parentElement.removeChild(this.canvas),this.canvas=document.createElement("canvas"),this.canvas.style.cssText="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--weather-overlay-z,9998);",this.container.appendChild(this.canvas)}ensureFallbackCore(){this.fallbackCore||(this.fallbackCore=new mb({canvas:this.canvas,viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile}))}postWorkerMessage(t){this.workerState==="ready"&&this.worker?this.worker.postMessage(t):this.workerQueue.push(t)}flushWorkerQueue(t=!1){if(t||!this.worker){this.workerQueue=[];return}for(const e of this.workerQueue)this.worker.postMessage(e);this.workerQueue=[]}handleResize(){this.viewportWidth=window.innerWidth,this.viewportHeight=window.innerHeight,this.isMobile=window.innerWidth<600||"ontouchstart"in window,this.devicePixelRatio=this.effectiveDpr(),this.shouldUseWorkerOrQueue()?this.postWorkerMessage({type:"RESIZE",viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile}):this.shouldUseFallbackCore()&&this.fallbackCore&&this.fallbackCore.resize({viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile})}start(t,e=100,n={}){if(this.opacity=Math.max(0,Math.min(100,e)),this.effectOptions=n,t==="none"){this.stop();return}this.currentEffect=t,this.shouldUseWorkerOrQueue()?this.postWorkerMessage({type:"START",effect:t,opacity:this.opacity,options:this.effectOptions}):this.shouldUseFallbackCore()&&(this.ensureFallbackCore(),this.fallbackCore?.start(t,this.opacity,this.effectOptions))}stop(){this.currentEffect="none",this.shouldUseWorkerOrQueue()?this.postWorkerMessage({type:"STOP"}):this.fallbackCore&&this.fallbackCore.stop()}setOpacity(t){this.opacity=Math.max(0,Math.min(100,t)),this.shouldUseWorkerOrQueue()?this.postWorkerMessage({type:"SET_OPACITY",opacity:this.opacity}):this.fallbackCore&&this.fallbackCore.setOpacity(this.opacity)}resize(t={}){this.viewportWidth=t.viewportWidth??window.innerWidth,this.viewportHeight=t.viewportHeight??window.innerHeight,this.isMobile=t.isMobile??(window.innerWidth<600||"ontouchstart"in window),this.devicePixelRatio=t.devicePixelRatio??this.effectiveDpr(),this.shouldUseWorkerOrQueue()?this.postWorkerMessage({type:"RESIZE",viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile}):this.shouldUseFallbackCore()&&(this.ensureFallbackCore(),this.fallbackCore?.resize({viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile}))}setStyle(t){t&&typeof t=="object"&&Object.assign(this.canvas.style,t)}destroy(){this.stop(),window.removeEventListener("resize",this.resizeHandler),this.worker&&(this.worker.postMessage({type:"DISPOSE"}),this.worker.terminate(),this.worker=null),this.workerState="idle",this.workerQueue=[],this.fallbackCore&&(this.fallbackCore.destroy(),this.fallbackCore=null),this.canvas?.parentNode&&this.canvas.parentNode.removeChild(this.canvas)}}function Od(l){if(!l)return"none";const t=String(l).toLowerCase().replace(/_/g,"-");return t==="lightning-rainy"||t==="lightning_rainy"||t==="pouring"?"rain_storm":t==="rainy-drizzle"||t==="rainy_drizzle"?"rain_drizzle":t==="rainy"?"rain":t==="hail"?"hail":t==="lightning"?"lightning":t==="snowy"||t==="snow"?"snow_gentle":t==="snowy-rainy"||t==="snowy_rainy"?"snow_storm":t==="snowy2"?"snow_layered":t==="snowy3"?"snow_gentle":t==="fog"||t==="foggy"?"fog_light":t==="sunny"||t==="clear"||t==="sunny2"?"sun_beams":t==="clear-night"||t==="clear_night"?"stars":t==="cloudy"||t==="partlycloudy"||t==="partly-cloudy"||t==="partly_cloudy"||t==="windy-variant"||t==="windy_variant"||t==="windy"?"clouds":"none"}const rn=[],qd="",vb="",Jb=!1;function Lr(l,t=null){}function kb(l,t=null){console.warn("[Weather Overlay] ⚠️",l,t??"")}function Un(l,t=null){console.error("[Weather Overlay] ❌",l,t??"")}function Ge(){const l=document.querySelector("home-assistant");return l?.hass?l:null}function Mn(){return(window.ForkUWeatherAwareConfig||{}).weather_entity||"weather.openweathermap"}function $d(){try{const l=Ge();if(!l)return null;const t=window.ForkUWeatherAwareConfig||{},e=Mn();if(t.development_mode&&t.test_effect&&t.test_effect!=="Use Real Weather"){let a=t.test_effect;return a==="snowy"&&t.snowy_variant==="snowy2"&&(a="snowy2"),a}const n=l.hass.states[e];if(!n)return Un(`Weather entity '${e}' not found`),null;let i=(n.state||"").toLowerCase().replace(/_/g,"-");const s=parseFloat(t.drizzle_precipitation_max)||2.5;if(i==="rainy"){const a=n.attributes?.precipitation!=null?parseFloat(n.attributes.precipitation):n.attributes?.precipitation_1h!=null?parseFloat(n.attributes.precipitation_1h):NaN;!isNaN(a)&&a>0&&a<=s&&(i="rainy-drizzle")}return i}catch(l){return Un("Error getting weather state:",l),null}}function tc(){try{if((window.ForkUWeatherAwareConfig||{}).enabled===!1)return!1;if(!qd)return!0;const t=Ge();if(!t)return!0;const e=t.hass.states[qd];return e?e.state==="on":!0}catch(l){return Un("Error checking overlay:",l),!0}}function ec(){if(!rn?.length)return!0;const t=window.location.pathname.split("/").filter(Boolean);if(t.length===0)return rn.includes("lovelace")||rn.includes("home");if(t[0]==="lovelace"){const e=t.length===1?"lovelace":t[1];return rn.includes(e)}for(const e of t)if(rn.includes(e))return!0;return rn.includes(t[t.length-1])}function es(){return window.innerWidth<600||"ontouchstart"in window}function wb(){try{const l=document.createElement("canvas");return!!(l.getContext("webgl2")||l.getContext("webgl")||l.getContext("experimental-webgl"))}catch{return!1}}function lc(){const l=window.ForkUWeatherAwareConfig||{};let t=window.devicePixelRatio||1;return es()&&l.mobile_limit_dpr&&(t=Math.min(t,2)),t}function nc(){const l=window.ForkUWeatherAwareConfig||{},t=l.pm25_entity,e=l.pm4_entity,n=l.pm10_entity,i=l.smog_threshold_pm25??35,s=l.smog_threshold_pm4??50,a=l.smog_threshold_pm10??50,d=Ge();if(!d?.hass)return!1;if(t){const c=d.hass.states[t];if(c&&c.state!=="unavailable"&&c.state!=="unknown"){const o=parseFloat(c.state);if(!isNaN(o)&&o>=i)return!0}}if(e){const c=d.hass.states[e];if(c&&c.state!=="unavailable"&&c.state!=="unknown"){const o=parseFloat(c.state);if(!isNaN(o)&&o>=s)return!0}}if(n){const c=d.hass.states[n];if(c&&c.state!=="unavailable"&&c.state!=="unknown"){const o=parseFloat(c.state);if(!isNaN(o)&&o>=a)return!0}}return!1}function gl(l){return(window.ForkUWeatherAwareConfig||{})[l]!==!1}function Hb(){const t=(window.ForkUWeatherAwareConfig||{}).gaming_mode_entity;if(!t||typeof t!="string"||!t.trim())return!1;const e=Ge();if(!e?.hass?.states)return!1;const n=e.hass.states[t];return!!(n&&String(n.state).toLowerCase()==="on")}let yi=null,ic=0;const zb=3e3;function ac(){const l=Date.now();if(l-ic<zb&&yi)return yi;ic=l;try{const t=window.ForkUWeatherAwareConfig||{},e=Ge();if(!e?.hass)return{x:.75,y:.12};const n=t.moon_position_entity,i=t.moon_phase_entity,s=t.moon_azimuth_entity,a=t.moon_altitude_entity;let d={x:.75,y:.12};for(const c of[n,i].filter(Boolean)){const o=e.hass.states[c];if(!o?.attributes)continue;const Z=o.attributes,m=parseFloat(Z.azimuth??Z.moon_azimuth_deg),b=parseFloat(Z.elevation??Z.altitude??Z.moon_altitude_deg);if(!isNaN(m)&&!isNaN(b)&&b>0){d.x=Math.max(0,Math.min(1,(m-90)/180)),d.y=.08+.22*(1-Math.min(90,b)/90);break}}if(s||a){const c=s?e.hass.states[s]:null,o=a?e.hass.states[a]:null,Z=c?parseFloat(c.state):NaN,m=o?parseFloat(o.state):NaN;!isNaN(Z)&&!isNaN(m)&&m>0&&(d.x=Math.max(0,Math.min(1,(Z-90)/180)),d.y=.08+.22*(1-Math.min(90,m)/90))}return yi=d,d}catch{return yi||{x:.75,y:.12}}}const ls={N:0,NE:45,E:90,SE:135,S:180,SW:225,W:270,NW:315};let Rl=-1;function sc(){const l=window.ForkUWeatherAwareConfig||{},t=Ge();let e=0,n=0;if(l.development_mode&&(l.debug_lightning_counter!=null||l.debug_lightning_distance!=null))e=l.debug_lightning_counter!=null&&l.debug_lightning_counter!==""?parseInt(l.debug_lightning_counter,10)||0:Rl>=0?Rl:0,n=l.debug_lightning_distance!=null&&l.debug_lightning_distance!==""?parseFloat(l.debug_lightning_distance)||0:5,l.debug_lightning_counter!=null&&l.debug_lightning_counter!==""&&(Rl=e);else if(t?.hass?.states){const s=l.lightning_counter_entity,a=l.lightning_distance_entity;if(s){const d=t.hass.states[s];if(d?.state!=="unavailable"&&d?.state!=="unknown"){const c=parseInt(d.state,10);isNaN(c)||(e=c)}}if(a){const d=t.hass.states[a];if(d?.state!=="unavailable"&&d?.state!=="unknown"){const c=parseFloat(d.state);!isNaN(c)&&c>=0&&(n=c)}}Rl<0&&(Rl=e)}const i=e>Rl?Math.min(e-Rl,5):0;return i>0&&(Rl=e),{count:e,distanceKm:n,strikesToTrigger:i}}function ns(){const l=window.ForkUWeatherAwareConfig||{},t=Ge(),e=Mn();if(l.development_mode&&l.debug_cloud_coverage!=null&&String(l.debug_cloud_coverage).trim()!==""){const i=parseFloat(l.debug_cloud_coverage);if(!isNaN(i))return Math.max(0,Math.min(100,i))}if(!t?.hass)return null;if(l.cloud_coverage_entity){const i=t.hass.states[l.cloud_coverage_entity];if(i?.state&&i.state!=="unavailable"&&i.state!=="unknown"){const s=parseFloat(i.state);if(!isNaN(s))return Math.max(0,Math.min(100,s))}}const n=t.hass.states[e];if(n?.attributes?.cloud_coverage!=null){const i=parseFloat(n.attributes.cloud_coverage);if(!isNaN(i))return Math.max(0,Math.min(100,i))}return null}function dc(){const l=window.ForkUWeatherAwareConfig||{},t=Ge(),e=Mn();if(l.development_mode&&l.debug_precipitation&&l.debug_precipitation!=="Use sensors"){const a={light:.35,medium:.65,heavy:1.2}[l.debug_precipitation];if(a!==void 0)return a}if(!t?.hass)return 1;if(l.precipitation_entity){const a=t.hass.states[l.precipitation_entity];if(a?.state!=="unavailable"&&a?.state!=="unknown"){const d=parseFloat(a.state);if(!isNaN(d))return Math.max(.2,Math.min(1.5,.2+d/10))}}const n=t.hass.states[e];if(!n?.attributes)return 1;const i=n.attributes.precipitation??n.attributes.precipitation_1h??n.attributes.precipitation_probability;if(i==null)return 1;const s=parseFloat(i);return isNaN(s)?1:Math.max(.2,Math.min(1.5,.2+s/10))}function Kb(){const l=window.ForkUWeatherAwareConfig||{},t=Ge();if(!t?.hass?.states)return 0;const e=l.aurora_chance_entity;if(!e)return 0;const n=t.hass.states[e];if(!n?.state||n.state==="unavailable"||n.state==="unknown")return 0;const i=parseFloat(n.state);return isNaN(i)?0:Math.max(0,Math.min(100,i))/100}function Bb(){const l=window.ForkUWeatherAwareConfig||{},t=Ge();if(!t?.hass?.states)return null;const e=l.k_index_entity;if(!e)return null;const n=t.hass.states[e];if(!n?.state||n.state==="unavailable"||n.state==="unknown")return null;const i=parseFloat(n.state);return isNaN(i)?null:Math.max(0,Math.min(9,i))}function Eb(){const t=(window.ForkUWeatherAwareConfig||{}).aurora_visibility_alert_entity;if(!t)return!1;const e=Ge();if(!e?.hass?.states)return!1;const n=e.hass.states[t];return!!(n&&String(n.state).toLowerCase()==="on")}function Ci(){const l=window.ForkUWeatherAwareConfig||{};if(!gl("enable_aurora_effect"))return 0;if(l.development_mode&&l.debug_aurora_score!=null&&String(l.debug_aurora_score).trim()!==""){const Z=parseFloat(l.debug_aurora_score);if(!isNaN(Z))return Math.max(0,Math.min(1,Z))}const t=Kb()||(Eb()?.7:0),n=1-(ns()??50)/100,s=is()?.elevation??0,a=Math.max(0,Math.min(1,1-(s+6)/6));let d=t*n*a;const c=Bb();c!=null&&c>=0&&(d*=Math.min(1.5,1+.05*c));const o=l.aurora_visibility_min!=null&&!isNaN(parseFloat(l.aurora_visibility_min))?Math.max(0,Math.min(1,parseFloat(l.aurora_visibility_min))):.15;return d>=o?d:0}function cc(){const l=window.ForkUWeatherAwareConfig||{};if(l.theme_mode==="dark"||l.theme_mode==="light")return l.theme_mode;const t=document.documentElement;return t?.classList&&(t.classList.contains("dark")||t.getAttribute("theme")==="dark")?"dark":t?.classList?.contains("light")?"light":typeof window.matchMedia<"u"&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"}function is(){const l=window.ForkUWeatherAwareConfig||{},t=Ge(),e=l.sun_entity||"sun.sun";let n=180,i=45,s=3;if(t?.hass?.states){const a=t.hass.states[e];if(a?.attributes){const d=a.attributes;n=parseFloat(d.azimuth)||180,i=parseFloat(d.elevation)||45}if(l.uv_index_entity){const d=t.hass.states[l.uv_index_entity];if(d?.state!=="unavailable"&&d?.state!=="unknown"){const c=parseFloat(d.state);!isNaN(c)&&c>=0&&(s=c)}}else{const d=t.hass.states[Mn()];d?.attributes?.uv_index!=null&&(s=parseFloat(d.attributes.uv_index)||3)}}return{azimuth:n,elevation:i,uvIndex:s}}function oc(){const l=window.ForkUWeatherAwareConfig||{},t=Mn();if(l.development_mode&&(l.debug_wind_speed||l.debug_wind_direction)){let s=5;if(l.debug_wind_speed&&l.debug_wind_speed!=="Use sensors")s={none:0,light:10,medium:25,strong:45}[l.debug_wind_speed]??5;else{const d=Ge();if(d?.hass&&l.wind_speed_entity){const c=d.hass.states[l.wind_speed_entity];c?.state!=="unavailable"&&(s=parseFloat(c.state)||5)}}let a=270;if(l.debug_wind_direction&&l.debug_wind_direction!=="Use sensors"){const d=l.debug_wind_direction;a=(ls[d]??parseFloat(d))||270}else{const d=Ge();if(d?.hass&&l.wind_direction_entity){const c=d.hass.states[l.wind_direction_entity];c?.state!=="unavailable"&&(a=parseFloat(c.state)||270)}}return{speed:s,bearing:a}}const e=Ge();if(!e?.hass)return{speed:5,bearing:270};let n=5,i=270;if(l.wind_speed_entity){const s=e.hass.states[l.wind_speed_entity];if(s?.state!=="unavailable"&&s?.state!=="unknown"){const a=parseFloat(s.state);isNaN(a)||(n=a)}}if(n===5){const s=e.hass.states[t],a=s?.attributes?.wind_speed!=null?parseFloat(s.attributes.wind_speed):NaN;isNaN(a)||(n=a)}if(l.wind_direction_entity){const s=e.hass.states[l.wind_direction_entity];if(s?.state!=="unavailable"&&s?.state!=="unknown"){const a=parseFloat(s.state);isNaN(a)?typeof s.state=="string"&&ls[s.state]!=null&&(i=ls[s.state]):i=a}}if(i===270){const s=e.hass.states[t],a=s?.attributes?.wind_bearing!=null?parseFloat(s.attributes.wind_bearing):NaN;isNaN(a)||(i=a)}return{speed:n,bearing:i}}function Ab(){const l=(window.ForkUWeatherAwareConfig||{}).spatial_mode||"foreground";return{foreground:9998,background:-1,bubble:3,"gradient-mask":9997}[l]??9998}function mc(l){const t=window.ForkUWeatherAwareConfig||{},e={rain:t.enable_rain,rain_storm:t.enable_rain&&t.enable_lightning_effect,rain_drizzle:t.enable_rain,snow_gentle:t.enable_snow,snow_storm:t.enable_snow,snow_layered:t.enable_snow,fog_light:t.enable_fog,fog_dense:t.enable_fog,sun_beams:t.enable_sun_glow,clouds:t.enable_clouds,hail:t.enable_hail,lightning:t.enable_lightning_effect,stars:t.enable_stars,matrix:t.enable_matrix};return l&&l!=="none"&&e[l]===!1?"none":l}let Be=null,ue=null,as=null,ss=0,Zc=window.location.pathname;function Qb(){ue&&ue.style.setProperty("--weather-overlay-z",String(Ab()))}function hc(){const l=Date.now();if(l-ss<1e3)return;const t=tc(),e=ec();if(!t||!e){Be&&Be.stop(),ue&&(ue.style.display="none");return}if(ss=l,ue&&(ue.style.display="block"),window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches){Be&&Be.stop(),ue&&(ue.style.display="none");return}const n=window.ForkUWeatherAwareConfig||{},i=n.gaming_matrix_only&&Hb()&&gl("enable_matrix"),s=i?null:$d(),a=i?"matrix":mc(Od(s));(s!==as||!Be)&&(as=s);const d=gl("enable_smog_effect")&&nc(),c=a==="stars"&&gl("enable_moon_glow")?ac():null,o=a==="stars"?Ci():0,Z=a==="stars"&&o>0,b=["rain","rain_storm","rain_drizzle","snow_storm"].includes(a)&&gl("enable_window_droplets"),h=(window.ForkUWeatherAwareConfig||{}).spatial_mode||"foreground",{speed:p,bearing:V}=oc(),r=n.wind_sway_factor!=null&&!isNaN(parseFloat(n.wind_sway_factor))?Math.max(0,Math.min(2,parseFloat(n.wind_sway_factor))):.7,u=n.rain_max_tilt_deg!=null&&!isNaN(parseFloat(n.rain_max_tilt_deg))?parseFloat(n.rain_max_tilt_deg):30,C=n.rain_wind_min_kmh!=null&&!isNaN(parseFloat(n.rain_wind_min_kmh))?parseFloat(n.rain_wind_min_kmh):3,R=a==="lightning"||a==="rain_storm"?sc():null,G=a==="rain_storm"?R:null,N=a==="sun_beams"?is():null,I=n.speed_factor_lightning!=null&&!isNaN(parseFloat(n.speed_factor_lightning))?parseFloat(n.speed_factor_lightning):1,x=ns(),M=dc(),y=cc(),g=n.cloud_speed_multiplier!=null&&!isNaN(parseFloat(n.cloud_speed_multiplier))?Math.max(.1,Math.min(3,parseFloat(n.cloud_speed_multiplier))):1;Be&&Be.start(a,100,{smogActive:d,moonPosition:c,windowDroplets:b,spatialMode:h,windBearing:V,windSpeedKmh:p,windSwayFactor:r,rainMaxTiltDeg:u,rainWindMinKmh:C,lightningData:R,lightningOverlay:G,sunPosition:N,speed_factor_lightning:I,cloudCoverage:x,precipitationMultiplier:M,themeMode:y,cloudSpeedMultiplier:g,auroraOverlay:Z,auroraVisibilityScore:o,auroraVariant:(window.ForkUWeatherAwareConfig||{}).aurora_variant||"bands"})}function Pb(){Be&&Be.resize({viewportWidth:window.innerWidth,viewportHeight:window.innerHeight,isMobile:es(),devicePixelRatio:lc()})}function jb(){if(!ue){if(!wb()){kb("WebGL not supported - weather overlay disabled");return}ue=document.createElement("div"),ue.id="fork-u-weather-overlay",ue.style.cssText="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--weather-overlay-z,9998);",Qb(),document.body.appendChild(ue);try{if(Be=new Tb(ue,{viewportWidth:window.innerWidth,viewportHeight:window.innerHeight,isMobile:es(),devicePixelRatio:lc()}),!tc()||!ec())ue.style.display="none";else{const l=$d(),t=mc(Od(l));as=l;const e=gl("enable_smog_effect")&&nc(),n=t==="stars"&&gl("enable_moon_glow")?ac():null,i=t==="stars"?Ci():0,s=t==="stars"&&i>0,d=["rain","rain_storm","rain_drizzle","snow_storm"].includes(t)&&gl("enable_window_droplets"),c=(window.ForkUWeatherAwareConfig||{}).spatial_mode||"foreground",{speed:o,bearing:Z}=oc(),m=window.ForkUWeatherAwareConfig||{},b=m.wind_sway_factor!=null&&!isNaN(parseFloat(m.wind_sway_factor))?Math.max(0,Math.min(2,parseFloat(m.wind_sway_factor))):.7,h=m.rain_max_tilt_deg!=null&&!isNaN(parseFloat(m.rain_max_tilt_deg))?parseFloat(m.rain_max_tilt_deg):30,p=m.rain_wind_min_kmh!=null&&!isNaN(parseFloat(m.rain_wind_min_kmh))?parseFloat(m.rain_wind_min_kmh):3,V=t==="lightning"||t==="rain_storm"?sc():null,r=t==="sun_beams"?is():null;Be.start(t,100,{smogActive:e,moonPosition:n,windowDroplets:d,spatialMode:c,windBearing:Z,windSpeedKmh:o,windSwayFactor:b,rainMaxTiltDeg:h,rainWindMinKmh:p,lightningData:V,lightningOverlay:t==="rain_storm"?V:null,sunPosition:r,speed_factor_lightning:m.speed_factor_lightning!=null&&!isNaN(parseFloat(m.speed_factor_lightning))?parseFloat(m.speed_factor_lightning):1,cloudCoverage:ns(),precipitationMultiplier:dc(),themeMode:cc(),cloudSpeedMultiplier:m.cloud_speed_multiplier!=null&&!isNaN(parseFloat(m.cloud_speed_multiplier))?Math.max(.1,Math.min(3,parseFloat(m.cloud_speed_multiplier))):1,auroraOverlay:t==="stars"&&Ci()>0,auroraVisibilityScore:t==="stars"?Ci():0,auroraVariant:(window.ForkUWeatherAwareConfig||{}).aurora_variant||"bands"})}}catch(l){Un("Weather overlay init failed:",l),ue?.parentNode&&ue.parentNode.removeChild(ue);return}setInterval(hc,1e3),window.addEventListener("resize",Pb),setInterval(()=>{window.location.pathname!==Zc&&(Zc=window.location.pathname,ss=0,hc())},500)}}function uc(){let l=0;const t=setInterval(()=>{l++,Ge()?(clearInterval(t),jb()):l>=60&&(clearInterval(t),Un("Home Assistant not found after 30s"))},500)}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",uc):uc(),function(){const l=window.ForkUWeatherAwareDefaultConfig||{enabled:!0,weather_entity:"weather.openweathermap",development_mode:!1,test_effect:"Use Real Weather",sun_entity:"sun.sun",moon_phase_entity:null,uv_index_entity:null,moon_position_entity:null,moon_azimuth_entity:null,moon_altitude_entity:null,moon_distance_entity:null,gaming_mode_entity:null,pm25_entity:null,pm4_entity:null,pm10_entity:null,smog_threshold_pm25:35,smog_threshold_pm4:50,smog_threshold_pm10:50,cloud_coverage_entity:null,wind_speed_entity:null,wind_direction_entity:null,precipitation_entity:null,lightning_counter_entity:null,lightning_distance_entity:null,debug_precipitation:null,debug_wind_speed:null,debug_wind_direction:null,debug_lightning_distance:null,debug_lightning_counter:null,debug_cloud_coverage:null,cloud_speed_multiplier:1,wind_sway_factor:.7,spatial_mode:"foreground",enable_rain:!0,enable_snow:!0,enable_clouds:!0,enable_fog:!0,enable_smog_effect:!0,enable_sun_glow:!0,enable_moon_glow:!0,enable_stars:!0,enable_hail:!0,enable_lightning_effect:!0,enable_matrix:!0,enable_window_droplets:!0,stars_require_moon:!1,mobile_limit_dpr:!0,mobile_reduce_particles:!0,mobile_snowy2_light:!0,mobile_smog_simple:!1,mobile_30fps:!1,gaming_matrix_only:!1,snowy_variant:"snowy2",enable_aurora_effect:!0,aurora_variant:"bands",aurora_chance_entity:null,aurora_visibility_alert_entity:null,aurora_visibility_min:.15,k_index_entity:null,debug_aurora_score:null};class t extends HTMLElement{connectedCallback(){super.connectedCallback&&super.connectedCallback(),this._scheduleEditorCheck()}_scheduleEditorCheck(){this._editorCheckScheduled||(this._editorCheckScheduled=!0,requestAnimationFrame(()=>{this._editorCheckScheduled=!1,this._config&&this._render()}))}setConfig(a){const d=Object.assign({},l,a||{});window.ForkUWeatherAwareConfig=d,this._config=d,this._render()}set hass(a){if(this._hass=a,this._config&&!window.ForkUWeatherAwareConfig&&(window.ForkUWeatherAwareConfig=this._config),a?.themes?.darkMode!==void 0){const d=window.ForkUWeatherAwareConfig||{},c=d.theme_mode,o=a.themes.darkMode?"dark":"light";window.ForkUWeatherAwareConfig=Object.assign({},d,{theme_mode:c==="light"||c==="dark"?c:o})}}_isInEditorPreview(){let a=this;for(;a;){if(a.nodeType===1&&a.classList&&(a.classList.contains("element-preview")||a.tagName&&a.tagName.toLowerCase().includes("hui-dialog-edit-card")))return!0;const d=a.getRootNode?a.getRootNode():a;a=(d instanceof ShadowRoot?d.host:a.parentNode)||null}return!1}_render(){this.shadowRoot||this.attachShadow({mode:"open"});const a=this._config||window.ForkUWeatherAwareConfig||l,d=this._isInEditorPreview(),c=!a.development_mode&&!d;this.style.display=c?"none":"",this.shadowRoot.innerHTML=`
        <ha-card header="Fork U - Weather Aware" style="${c?"display:none":""}">
          <div class="card-content">
            <p>Fullscreen, smooth weather overlay running on this dashboard.</p>
            <p><strong>Weather entity:</strong> ${a.weather_entity||"not set"}</p>
            <p><strong>Development mode:</strong> ${a.development_mode?"on":"off"}</p>
          </div>
        </ha-card>
      `}getCardSize(){const a=this._config||window.ForkUWeatherAwareConfig||{},d=this._isInEditorPreview&&this._isInEditorPreview();return!a.development_mode&&!d?0:1}static getConfigElement(){return document.createElement("fork-u-weather-aware-editor")}static getStubConfig(){return{enabled:!0,weather_entity:"weather.openweathermap",development_mode:!1,test_effect:"Use Real Weather"}}}typeof window.customCards>"u"&&(window.customCards=[]),window.customCards.push({type:"fork-u-weather-aware-card",name:"Fork U - Weather Aware",description:"Fullscreen weather overlay with rain, snow, lightning, fog and more.",preview:!1});function e(s){return s==null?"":String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;")}function n(s,a,d){const c={value:"",label:"— None —"};if(!s||!s.states)return d?[c,{value:d,label:"Current: "+d}]:[c];const o=Object.keys(s.states).filter(m=>a.some(b=>m.startsWith(b+"."))).sort(),Z=[c];return o.forEach(m=>Z.push({value:m,label:m})),d&&d.trim()&&!o.includes(d)&&Z.splice(1,0,{value:d,label:"Current: "+d}),Z}class i extends HTMLElement{setConfig(a){this._config=Object.assign({},l,a||{}),this._config&&(window.ForkUWeatherAwareConfig=this._config),this.shadowRoot?this._updateFormValues(this._config):(this.attachShadow({mode:"open"}),this._render())}set hass(a){this._hass=a,a&&this.shadowRoot&&this._config&&!this._entitySelectsPopulated&&this._populateEntitySelects()}_populateEntitySelects(){const a=this.shadowRoot,d=this._hass,c=this._config||{};if(!a||!d)return;this._entitySelectsPopulated=!0,[{id:"weather_entity",domains:["weather"]},{id:"sun_entity",domains:["sun"]},{id:"moon_phase_entity",domains:["sensor"]},{id:"uv_index_entity",domains:["sensor"]},{id:"moon_position_entity",domains:["sensor"]},{id:"moon_azimuth_entity",domains:["sensor"]},{id:"moon_altitude_entity",domains:["sensor"]},{id:"moon_distance_entity",domains:["sensor"]},{id:"wind_speed_entity",domains:["sensor"]},{id:"wind_direction_entity",domains:["sensor"]},{id:"cloud_coverage_entity",domains:["sensor"]},{id:"precipitation_entity",domains:["sensor"]},{id:"pm25_entity",domains:["sensor"]},{id:"pm4_entity",domains:["sensor"]},{id:"pm10_entity",domains:["sensor"]},{id:"gaming_mode_entity",domains:["input_boolean","binary_sensor"]},{id:"lightning_counter_entity",domains:["sensor"]},{id:"lightning_distance_entity",domains:["sensor"]},{id:"aurora_chance_entity",domains:["sensor"]},{id:"aurora_visibility_alert_entity",domains:["binary_sensor"]},{id:"k_index_entity",domains:["sensor"]}].forEach(({id:Z,domains:m})=>{const b=a.getElementById(Z+"_list");if(!b)return;const h=c[Z]||"",p=n(d,m,h);b.innerHTML=p.filter(V=>V.value).map(V=>`<option value="${e(V.value)}">${e(V.label)}</option>`).join("")})}_updateFormValues(a){const d=this.shadowRoot;if(!d||!a)return;const c=(Z,m)=>{const b=d.getElementById(Z);b&&(b.type==="checkbox"?b.checked=!!m:b.value=m!=null?String(m):"")};c("enabled",a.enabled),c("weather_entity",a.weather_entity),c("sun_entity",a.sun_entity),c("moon_phase_entity",a.moon_phase_entity),c("uv_index_entity",a.uv_index_entity),c("moon_position_entity",a.moon_position_entity),c("moon_azimuth_entity",a.moon_azimuth_entity),c("moon_altitude_entity",a.moon_altitude_entity),c("moon_distance_entity",a.moon_distance_entity),c("gaming_mode_entity",a.gaming_mode_entity),c("pm25_entity",a.pm25_entity),c("pm4_entity",a.pm4_entity),c("pm10_entity",a.pm10_entity),c("smog_threshold_pm25",a.smog_threshold_pm25),c("smog_threshold_pm4",a.smog_threshold_pm4),c("smog_threshold_pm10",a.smog_threshold_pm10),c("cloud_coverage_entity",a.cloud_coverage_entity),c("wind_speed_entity",a.wind_speed_entity),c("wind_direction_entity",a.wind_direction_entity),c("precipitation_entity",a.precipitation_entity),c("lightning_counter_entity",a.lightning_counter_entity),c("lightning_distance_entity",a.lightning_distance_entity),c("aurora_variant",a.aurora_variant||"bands"),c("aurora_chance_entity",a.aurora_chance_entity),c("aurora_visibility_alert_entity",a.aurora_visibility_alert_entity),c("aurora_visibility_min",a.aurora_visibility_min),c("k_index_entity",a.k_index_entity),c("enable_aurora_effect",a.enable_aurora_effect),c("debug_aurora_score",a.debug_aurora_score),c("cloud_speed_multiplier",a.cloud_speed_multiplier),c("wind_sway_factor",a.wind_sway_factor),c("rain_max_tilt_deg",a.rain_max_tilt_deg),c("rain_wind_min_kmh",a.rain_wind_min_kmh),c("enable_rain",a.enable_rain),c("enable_snow",a.enable_snow),c("enable_clouds",a.enable_clouds),c("enable_fog",a.enable_fog),c("enable_smog_effect",a.enable_smog_effect),c("enable_sun_glow",a.enable_sun_glow),c("enable_moon_glow",a.enable_moon_glow),c("enable_stars",a.enable_stars),c("enable_hail",a.enable_hail),c("enable_lightning_effect",a.enable_lightning_effect),c("enable_matrix",a.enable_matrix),c("enable_window_droplets",a.enable_window_droplets),c("stars_require_moon",a.stars_require_moon),c("drizzle_precipitation_max",a.drizzle_precipitation_max),["rain","snow","clouds","fog","smog","hail","lightning","stars","matrix"].forEach(Z=>c("speed_factor_"+Z,a["speed_factor_"+Z])),c("development_mode",a.development_mode),c("debug_precipitation",a.debug_precipitation),c("debug_wind_speed",a.debug_wind_speed),c("debug_wind_direction",a.debug_wind_direction),c("debug_lightning_distance",a.debug_lightning_distance),c("debug_lightning_counter",a.debug_lightning_counter),c("debug_cloud_coverage",a.debug_cloud_coverage),c("mobile_limit_dpr",a.mobile_limit_dpr),c("mobile_reduce_particles",a.mobile_reduce_particles),c("mobile_snowy2_light",a.mobile_snowy2_light),c("mobile_smog_simple",a.mobile_smog_simple),c("mobile_30fps",a.mobile_30fps),c("gaming_matrix_only",a.gaming_matrix_only),c("snowy_variant",a.snowy_variant||"snowy2"),c("theme_mode",a.theme_mode||""),c("spatial_mode",a.spatial_mode||"foreground");const o=a.test_effect||"Use Real Weather";d.querySelectorAll('input[name="test_effect"]').forEach(Z=>{Z.checked=Z.value===o})}_render(){this.shadowRoot||this.attachShadow({mode:"open"});const a=this._config||l,d=this._hass,c=["Use Real Weather","rainy","pouring","cloudy","partlycloudy","fog","lightning","lightning-rainy","snowy","snowy-rainy","clear-night","sunny","hail"],o=n(d,["weather"],a.weather_entity),Z=n(d,["sun"],a.sun_entity),m=h=>n(d,["sensor"],h),b=n(d,["input_boolean","binary_sensor"],a.gaming_mode_entity);this.shadowRoot.innerHTML=`
        <style>
          :host { display: block; }
          .editor { padding: 16px; max-width: 560px; }
          ha-expansion-panel { margin-bottom: 8px; --expansion-panel-content-padding: 12px 16px; }
          ha-expansion-panel .content { padding: 12px 16px; }
          .section { margin-bottom: 16px; }
          .section-title { font-size: 0.9em; font-weight: 600; margin-bottom: 10px; color: var(--primary-text-color); }
          .form-row { margin-bottom: 16px; display: flex; flex-wrap: wrap; align-items: center; gap: 12px; }
          .form-row label { font-size: 14px; color: var(--secondary-text-color); min-width: 140px; }
          .entity-select, input[type="text"], input[type="number"], select {
            min-width: 220px; max-width: 100%;
            padding: 8px 12px;
            border-radius: var(--mdc-shape-small, 8px);
            border: 1px solid var(--divider-color, rgba(0,0,0,0.12));
            background: var(--ha-card-background, var(--card-background-color));
            color: var(--primary-text-color);
            font-size: 14px;
            font-family: var(--mdc-typography-font-family, Roboto, sans-serif);
          }
          .entity-select:focus, input:focus, select:focus { outline: none; border-color: var(--primary-color); }
          input[type="number"] { min-width: 72px; width: 72px; }
          .radio-group { display: flex; flex-wrap: wrap; gap: 12px; }
          .radio-group label { min-width: auto; cursor: pointer; }
          input[type="checkbox"] { cursor: pointer; width: 18px; height: 18px; accent-color: var(--primary-color); }
        </style>
        <div class="editor">
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:cog"></ha-icon> General</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">General</div>
            <div class="form-row">
              <label><input type="checkbox" id="enabled" ${a.enabled?"checked":""}> Enable overlay</label>
            </div>
            <div class="form-row">
              <label>Weather entity</label>
              <input id="weather_entity" type="text" class="entity-select" list="weather_entity_list" value="${a.weather_entity||""}" placeholder="np. weather.openweathermap">
              <datalist id="weather_entity_list">
                ${o.map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Sun entity</label>
              <input id="sun_entity" type="text" class="entity-select" list="sun_entity_list" value="${a.sun_entity||""}" placeholder="sun.sun">
              <datalist id="sun_entity_list">
                ${Z.map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:weather-night"></ha-icon> Moon &amp; UV</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Moon &amp; UV</div>
            <div class="form-row">
              <label>Moon phase</label>
              <input id="moon_phase_entity" type="text" class="entity-select" list="moon_phase_entity_list" value="${a.moon_phase_entity||""}" placeholder="sensor.moon_phase">
              <datalist id="moon_phase_entity_list">
                ${m(a.moon_phase_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>UV index</label>
              <input id="uv_index_entity" type="text" class="entity-select" list="uv_index_entity_list" value="${a.uv_index_entity||""}" placeholder="sensor.uv_index">
              <datalist id="uv_index_entity_list">
                ${m(a.uv_index_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Moon position (single)</label>
              <input id="moon_position_entity" type="text" class="entity-select" list="moon_position_entity_list" value="${a.moon_position_entity||""}" placeholder="sensor.moon_position">
              <datalist id="moon_position_entity_list">
                ${m(a.moon_position_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row"><label>Lunar Phase (3 sensors)</label></div>
            <div class="form-row">
              <label>Azimuth</label>
              <input id="moon_azimuth_entity" type="text" class="entity-select" list="moon_azimuth_entity_list" value="${a.moon_azimuth_entity||""}" placeholder="sensor.moon_azimuth">
              <datalist id="moon_azimuth_entity_list">
                ${m(a.moon_azimuth_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Altitude</label>
              <input id="moon_altitude_entity" type="text" class="entity-select" list="moon_altitude_entity_list" value="${a.moon_altitude_entity||""}" placeholder="sensor.moon_altitude">
              <datalist id="moon_altitude_entity_list">
                ${m(a.moon_altitude_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Distance</label>
              <input id="moon_distance_entity" type="text" class="entity-select" list="moon_distance_entity_list" value="${a.moon_distance_entity||""}" placeholder="sensor.moon_distance">
              <datalist id="moon_distance_entity_list">
                ${m(a.moon_distance_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:weather-windy"></ha-icon> Wind, clouds, precipitation</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Wind, clouds, precipitation</div>
            <div class="form-row">
              <label>Wind speed</label>
              <input id="wind_speed_entity" type="text" class="entity-select" list="wind_speed_entity_list" value="${a.wind_speed_entity||""}" placeholder="sensor.wind_speed">
              <datalist id="wind_speed_entity_list">
                ${m(a.wind_speed_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Wind direction</label>
              <input id="wind_direction_entity" type="text" class="entity-select" list="wind_direction_entity_list" value="${a.wind_direction_entity||""}" placeholder="sensor.wind_direction">
              <datalist id="wind_direction_entity_list">
                ${m(a.wind_direction_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Cloud coverage</label>
              <input id="cloud_coverage_entity" type="text" class="entity-select" list="cloud_coverage_entity_list" value="${a.cloud_coverage_entity||""}" placeholder="sensor.cloud_coverage">
              <datalist id="cloud_coverage_entity_list">
                ${m(a.cloud_coverage_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Precipitation</label>
              <input id="precipitation_entity" type="text" class="entity-select" list="precipitation_entity_list" value="${a.precipitation_entity||""}" placeholder="sensor.precipitation">
              <datalist id="precipitation_entity_list">
                ${m(a.precipitation_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Cloud speed multiplier</label>
              <input type="number" id="cloud_speed_multiplier" value="${a.cloud_speed_multiplier??1}" min="0.1" max="3" step="0.1" style="width:72px">
            </div>
            <div class="form-row">
              <label>Drizzle threshold (mm)</label>
              <input type="number" id="drizzle_precipitation_max" value="${a.drizzle_precipitation_max??2.5}" min="0" max="20" step="0.5" style="width:72px" title="Precipitation ≤ this = drizzle (light rain); above = normal rain">
            </div>
            <div class="form-row">
              <label>Wind sway factor</label>
              <input type="number" id="wind_sway_factor" value="${a.wind_sway_factor??.7}" min="0" max="2" step="0.1" style="width:72px" title="How strongly wind bends rain/snow (0 = off, 0.7 = default)">
            </div>
            <div class="form-row">
              <label>Rain max tilt (°)</label>
              <input type="number" id="rain_max_tilt_deg" value="${a.rain_max_tilt_deg??30}" min="0" max="60" step="5" style="width:72px" title="Max rain/snow tilt from wind (default 30)">
              <label>Rain wind min (km/h)</label>
              <input type="number" id="rain_wind_min_kmh" value="${a.rain_wind_min_kmh??3}" min="0" max="20" step="1" style="width:72px" title="Min wind speed to tilt rain (default 3)">
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:speedometer"></ha-icon> Effect speed factors (1 = default, 0.1–3)</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Effect speed factors (1 = default, 0.1–3)</div>
            <div class="form-row" style="flex-wrap:wrap;gap:8px 16px;">
              <label>Rain</label><input type="number" id="speed_factor_rain" value="${a.speed_factor_rain??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Snow</label><input type="number" id="speed_factor_snow" value="${a.speed_factor_snow??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Clouds</label><input type="number" id="speed_factor_clouds" value="${a.speed_factor_clouds??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Fog</label><input type="number" id="speed_factor_fog" value="${a.speed_factor_fog??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Smog</label><input type="number" id="speed_factor_smog" value="${a.speed_factor_smog??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Hail</label><input type="number" id="speed_factor_hail" value="${a.speed_factor_hail??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Lightning</label><input type="number" id="speed_factor_lightning" value="${a.speed_factor_lightning??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Stars</label><input type="number" id="speed_factor_stars" value="${a.speed_factor_stars??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Matrix</label><input type="number" id="speed_factor_matrix" value="${a.speed_factor_matrix??1}" min="0.1" max="3" step="0.1" style="width:52px">
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:tune"></ha-icon> Effects enabled</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Toggle individual effects (disable heavy ones if needed)</div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_rain" ${a.enable_rain!==!1?"checked":""}> Rain (rainy / pouring / lightning-rainy)</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_snow" ${a.enable_snow!==!1?"checked":""}> Snow (snowy / snowy2 / snowy-rainy)</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_clouds" ${a.enable_clouds!==!1?"checked":""}> Clouds</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_fog" ${a.enable_fog!==!1?"checked":""}> Fog</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_smog_effect" ${a.enable_smog_effect!==!1?"checked":""}> Smog alert fog</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_sun_glow" ${a.enable_sun_glow!==!1?"checked":""}> Sun glow / beams</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_moon_glow" ${a.enable_moon_glow!==!1?"checked":""}> Moon glow</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_stars" ${a.enable_stars!==!1?"checked":""}> Stars</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="stars_require_moon" ${a.stars_require_moon?"checked":""}> Stars require moon glow</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_hail" ${a.enable_hail!==!1?"checked":""}> Hail (meteors)</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_lightning_effect" ${a.enable_lightning_effect!==!1?"checked":""}> Lightning flashes</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_matrix" ${a.enable_matrix!==!1?"checked":""}> Matrix / gaming overlay</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_window_droplets" ${a.enable_window_droplets!==!1?"checked":""}> Window droplets (side rain on glass)</label>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:target"></ha-icon> Spatial awareness</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Spatial awareness (where effects are drawn)</div>
            <div class="form-row">
              <label>Theme</label>
              <select id="theme_mode" title="Override light/dark for snow/effects; null = auto from HA theme">
                <option value="" ${a.theme_mode?"":"selected"}>Auto (from HA theme)</option>
                <option value="light" ${a.theme_mode==="light"?"selected":""}>Light</option>
                <option value="dark" ${a.theme_mode==="dark"?"selected":""}>Dark</option>
              </select>
            </div>
            <div class="form-row">
              <label>Mode</label>
              <select id="spatial_mode" class="entity-select">
                <option value="background" ${a.spatial_mode==="background"?"selected":""}>Background (behind all cards, z-index -1)</option>
                <option value="bubble" ${a.spatial_mode==="bubble"?"selected":""}>Bubble aware (under Bubble card backdrops, z-index 3)</option>
                <option value="gradient-mask" ${a.spatial_mode==="gradient-mask"?"selected":""}>Gradient mask (effects around card edges)</option>
                <option value="foreground" ${!a.spatial_mode||a.spatial_mode==="foreground"?"selected":""}>Foreground (current behavior, above cards)</option>
              </select>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:snowflake"></ha-icon> Snow variant</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Snow variant</div>
            <div class="form-row">
              <label>Preferred snow style</label>
              <select id="snowy_variant" class="entity-select">
                <option value="snowy" ${a.snowy_variant==="snowy"?"selected":""}>Classic snowy (particles)</option>
                <option value="snowy2" ${!a.snowy_variant||a.snowy_variant==="snowy2"?"selected":""}>Snowy2 (layered, lighter on mobile)</option>
              </select>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:northern-lights"></ha-icon> Aurora (Northern Lights)</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Aurora effect on clear nights – header bands when visibility score &gt; threshold</div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_aurora_effect" ${a.enable_aurora_effect!==!1?"checked":""}> Enable aurora effect</label>
            </div>
            <div class="form-row">
              <label>Style</label>
              <select id="aurora_variant" title="Bands: footer-style header; Northern Gradients: soft flowing curtains">
                <option value="bands" ${a.aurora_variant==="bands"||!a.aurora_variant?"selected":""}>Bands (header stripes)</option>
                <option value="northern-gradients" ${a.aurora_variant==="northern-gradients"?"selected":""}>Bubble Northern Gradients (soft curtains)</option>
              </select>
            </div>
            <div class="form-row">
              <label>Aurora chance entity (%)</label>
              <input id="aurora_chance_entity" type="text" class="entity-select" list="aurora_chance_entity_list" value="${a.aurora_chance_entity||""}" placeholder="sensor.aurora_60_1">
              <datalist id="aurora_chance_entity_list">
                ${m(a.aurora_chance_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
              <span class="help">NOAA Aurora Forecast 0–100</span>
            </div>
            <div class="form-row">
              <label>Aurora alert (binary)</label>
              <input id="aurora_visibility_alert_entity" type="text" class="entity-select" list="aurora_visibility_alert_entity_list" value="${a.aurora_visibility_alert_entity||""}" placeholder="binary_sensor.aurora_visibility_alert">
              <datalist id="aurora_visibility_alert_entity_list">
                ${n(d,["binary_sensor"],a.aurora_visibility_alert_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
              <span class="help">Optional shortcut when ON</span>
            </div>
            <div class="form-row">
              <label>K-index (optional)</label>
              <input id="k_index_entity" type="text" class="entity-select" list="k_index_entity_list" value="${a.k_index_entity||""}" placeholder="sensor.planetary_k_index">
              <datalist id="k_index_entity_list">
                ${m(a.k_index_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
              <span class="help">Planetary Kp from NOAA Space Weather</span>
            </div>
            <div class="form-row">
              <label>Min visibility score (0–1)</label>
              <input type="number" id="aurora_visibility_min" value="${a.aurora_visibility_min??.15}" min="0" max="1" step="0.05" style="width:72px" title="Minimum score to show effect (default 0.15)">
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:blur"></ha-icon> Smog (PM µg/m³ – fog above threshold)</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Smog (PM µg/m³ – fog when above threshold). Default thresholds: WHO / EPA / EU</div>
            <div class="form-row">
              <label>PM2.5</label>
              <input id="pm25_entity" type="text" class="entity-select" list="pm25_entity_list" value="${a.pm25_entity||""}" placeholder="sensor.pm25">
              <datalist id="pm25_entity_list">
                ${m(a.pm25_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
              <label>Alert threshold (µg/m³)</label>
              <input type="number" id="smog_threshold_pm25" value="${a.smog_threshold_pm25??35}" min="1" max="500" style="width:60px" title="Default 35 (EPA: unhealthy for sensitive groups)">
            </div>
            <div class="form-row">
              <label>PM4</label>
              <input id="pm4_entity" type="text" class="entity-select" list="pm4_entity_list" value="${a.pm4_entity||""}" placeholder="sensor.pm4">
              <datalist id="pm4_entity_list">
                ${m(a.pm4_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
              <label>Alert threshold (µg/m³)</label>
              <input type="number" id="smog_threshold_pm4" value="${a.smog_threshold_pm4??50}" min="1" max="500" style="width:60px">
            </div>
            <div class="form-row">
              <label>PM10</label>
              <input id="pm10_entity" type="text" class="entity-select" list="pm10_entity_list" value="${a.pm10_entity||""}" placeholder="sensor.pm10">
              <datalist id="pm10_entity_list">
                ${m(a.pm10_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
              <label>Alert threshold (µg/m³)</label>
              <input type="number" id="smog_threshold_pm10" value="${a.smog_threshold_pm10??50}" min="1" max="500" style="width:60px" title="Default 50 (EU 24h limit / WHO guideline)">
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:flash"></ha-icon> Gaming &amp; Lightning</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Gaming &amp; Lightning</div>
            <div class="form-row">
              <label>Gaming mode</label>
              <input id="gaming_mode_entity" type="text" class="entity-select" list="gaming_mode_entity_list" value="${a.gaming_mode_entity||""}" placeholder="input_boolean.gaming_mode">
              <datalist id="gaming_mode_entity_list">
                ${b.map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="gaming_matrix_only" ${a.gaming_matrix_only?"checked":""}> When Gaming ON: Matrix only (no weather background)</label>
            </div>
            <div class="form-row">
              <label>Lightning counter</label>
              <input id="lightning_counter_entity" type="text" class="entity-select" list="lightning_counter_entity_list" value="${a.lightning_counter_entity||""}" placeholder="sensor.lightning_counter">
              <datalist id="lightning_counter_entity_list">
                ${m(a.lightning_counter_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Lightning distance</label>
              <input id="lightning_distance_entity" type="text" class="entity-select" list="lightning_distance_entity_list" value="${a.lightning_distance_entity||""}" placeholder="sensor.lightning_distance">
              <datalist id="lightning_distance_entity_list">
                ${m(a.lightning_distance_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:cellphone"></ha-icon> Mobile</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Mobile</div>
            <div class="form-row">
              <label><input type="checkbox" id="mobile_limit_dpr" ${a.mobile_limit_dpr?"checked":""}> Limit canvas resolution on mobile (better performance)</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="mobile_reduce_particles" ${a.mobile_reduce_particles?"checked":""}> Fewer particles (rain/snow/fog) on mobile</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="mobile_snowy2_light" ${a.mobile_snowy2_light?"checked":""}> Lighter <code>snowy2</code> snow on mobile</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="mobile_smog_simple" ${a.mobile_smog_simple?"checked":""}> Simpler smog rendering on mobile</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="mobile_30fps" ${a.mobile_30fps?"checked":""}> Limit animation to ~30 FPS on mobile</label>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:test-tube"></ha-icon> Development mode</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Development mode</div>
            <div class="form-row">
              <label><input type="checkbox" id="development_mode" ${a.development_mode?"checked":""}> Override real weather for testing</label>
            </div>
            ${a.development_mode?`
            <div class="form-row">
              <label>Test effect</label>
              <div class="radio-group">
                ${c.map(h=>`
                  <label><input type="radio" name="test_effect" value="${e(h)}" ${a.test_effect===h?"checked":""}> ${e(h)}</label>
                `).join("")}
              </div>
            </div>
            <div class="form-row" style="margin-top:10px;"><strong>Debug overrides</strong></div>
            <div class="form-row">
              <label>Precipitation</label>
              <select id="debug_precipitation">
                <option value="">Use sensors</option>
                <option value="light" ${a.debug_precipitation==="light"?"selected":""}>Light (~1 mm/h)</option>
                <option value="medium" ${a.debug_precipitation==="medium"?"selected":""}>Medium (~3 mm/h)</option>
                <option value="heavy" ${a.debug_precipitation==="heavy"?"selected":""}>Heavy (~8 mm/h)</option>
              </select>
            </div>
            <div class="form-row">
              <label>Wind speed</label>
              <select id="debug_wind_speed">
                <option value="">Use sensors</option>
                <option value="none" ${a.debug_wind_speed==="none"?"selected":""}>None</option>
                <option value="light" ${a.debug_wind_speed==="light"?"selected":""}>Light (~10 km/h)</option>
                <option value="medium" ${a.debug_wind_speed==="medium"?"selected":""}>Medium (~25 km/h)</option>
                <option value="strong" ${a.debug_wind_speed==="strong"?"selected":""}>Strong (~45 km/h)</option>
              </select>
            </div>
            <div class="form-row">
              <label>Wind direction</label>
              <select id="debug_wind_direction">
                <option value="">Use sensors</option>
                <option value="N" ${a.debug_wind_direction==="N"?"selected":""}>N</option>
                <option value="NE" ${a.debug_wind_direction==="NE"?"selected":""}>NE</option>
                <option value="E" ${a.debug_wind_direction==="E"?"selected":""}>E</option>
                <option value="SE" ${a.debug_wind_direction==="SE"?"selected":""}>SE</option>
                <option value="S" ${a.debug_wind_direction==="S"?"selected":""}>S</option>
                <option value="SW" ${a.debug_wind_direction==="SW"?"selected":""}>SW</option>
                <option value="W" ${a.debug_wind_direction==="W"?"selected":""}>W</option>
                <option value="NW" ${a.debug_wind_direction==="NW"?"selected":""}>NW</option>
              </select>
            </div>
            <div class="form-row">
              <label>Lightning distance (km)</label>
              <input type="number" id="debug_lightning_distance" value="${a.debug_lightning_distance??""}" placeholder="override" min="0" max="500" step="0.5" style="width:80px">
              <label>Lightning counter</label>
              <input type="number" id="debug_lightning_counter" value="${a.debug_lightning_counter??""}" placeholder="override" min="0" style="width:60px">
            </div>
            <div class="form-row">
              <label>Cloud coverage (%)</label>
              <input type="number" id="debug_cloud_coverage" value="${a.debug_cloud_coverage??""}" placeholder="0-100" min="0" max="100" style="width:80px">
            </div>
            <div class="form-row">
              <label>Aurora visibility score (0–1)</label>
              <input type="number" id="debug_aurora_score" value="${a.debug_aurora_score??""}" placeholder="force aurora" min="0" max="1" step="0.1" style="width:80px" title="Force aurora effect in dev mode">
            </div>
            `:""}
          </div>
            </div>
          </ha-expansion-panel>
        </div>
      `,this._attachListeners(),this._hass&&this._populateEntitySelects()}_attachListeners(){const a=this.shadowRoot;if(!a)return;const d=this._config||l,c=()=>{const Z=Object.assign({},d,{enabled:a.getElementById("enabled").checked,weather_entity:a.getElementById("weather_entity").value||l.weather_entity,sun_entity:a.getElementById("sun_entity").value||l.sun_entity,moon_phase_entity:a.getElementById("moon_phase_entity").value||null,uv_index_entity:a.getElementById("uv_index_entity").value||null,moon_position_entity:a.getElementById("moon_position_entity").value||null,moon_azimuth_entity:a.getElementById("moon_azimuth_entity").value||null,moon_altitude_entity:a.getElementById("moon_altitude_entity").value||null,moon_distance_entity:a.getElementById("moon_distance_entity").value||null,gaming_mode_entity:a.getElementById("gaming_mode_entity").value||null,pm25_entity:a.getElementById("pm25_entity").value||null,pm4_entity:a.getElementById("pm4_entity").value||null,pm10_entity:a.getElementById("pm10_entity").value||null,smog_threshold_pm25:parseInt(a.getElementById("smog_threshold_pm25")?.value||"35",10)||35,smog_threshold_pm4:parseInt(a.getElementById("smog_threshold_pm4")?.value||"50",10)||50,smog_threshold_pm10:parseInt(a.getElementById("smog_threshold_pm10")?.value||"50",10)||50,cloud_coverage_entity:a.getElementById("cloud_coverage_entity")?.value||null,wind_speed_entity:a.getElementById("wind_speed_entity")?.value||null,wind_direction_entity:a.getElementById("wind_direction_entity")?.value||null,precipitation_entity:a.getElementById("precipitation_entity")?.value||null,lightning_counter_entity:a.getElementById("lightning_counter_entity")?.value||null,lightning_distance_entity:a.getElementById("lightning_distance_entity")?.value||null,debug_precipitation:a.getElementById("debug_precipitation")?.value||null,debug_wind_speed:a.getElementById("debug_wind_speed")?.value||null,debug_wind_direction:a.getElementById("debug_wind_direction")?.value||null,debug_lightning_distance:a.getElementById("debug_lightning_distance")?.value||null,debug_lightning_counter:a.getElementById("debug_lightning_counter")?.value||null,debug_cloud_coverage:a.getElementById("debug_cloud_coverage")?.value||null,debug_aurora_score:a.getElementById("debug_aurora_score")?.value||null,aurora_variant:a.getElementById("aurora_variant")?.value||"bands",aurora_chance_entity:a.getElementById("aurora_chance_entity")?.value||null,aurora_visibility_alert_entity:a.getElementById("aurora_visibility_alert_entity")?.value||null,aurora_visibility_min:parseFloat(a.getElementById("aurora_visibility_min")?.value||"0.15")||.15,k_index_entity:a.getElementById("k_index_entity")?.value||null,enable_aurora_effect:!!a.getElementById("enable_aurora_effect")?.checked,cloud_speed_multiplier:parseFloat(a.getElementById("cloud_speed_multiplier")?.value||"1")||1,drizzle_precipitation_max:parseFloat(a.getElementById("drizzle_precipitation_max")?.value||"2.5")||2.5,wind_sway_factor:parseFloat(a.getElementById("wind_sway_factor")?.value||"0.7")||.7,rain_max_tilt_deg:parseFloat(a.getElementById("rain_max_tilt_deg")?.value||"30")||30,rain_wind_min_kmh:parseFloat(a.getElementById("rain_wind_min_kmh")?.value||"3")||3,speed_factor_rain:parseFloat(a.getElementById("speed_factor_rain")?.value||"1")||1,speed_factor_snow:parseFloat(a.getElementById("speed_factor_snow")?.value||"1")||1,speed_factor_clouds:parseFloat(a.getElementById("speed_factor_clouds")?.value||"1")||1,speed_factor_fog:parseFloat(a.getElementById("speed_factor_fog")?.value||"1")||1,speed_factor_smog:parseFloat(a.getElementById("speed_factor_smog")?.value||"1")||1,speed_factor_hail:parseFloat(a.getElementById("speed_factor_hail")?.value||"1")||1,speed_factor_lightning:parseFloat(a.getElementById("speed_factor_lightning")?.value||"1")||1,speed_factor_stars:parseFloat(a.getElementById("speed_factor_stars")?.value||"1")||1,speed_factor_matrix:parseFloat(a.getElementById("speed_factor_matrix")?.value||"1")||1,enable_rain:!!a.getElementById("enable_rain")?.checked,enable_snow:!!a.getElementById("enable_snow")?.checked,enable_clouds:!!a.getElementById("enable_clouds")?.checked,enable_fog:!!a.getElementById("enable_fog")?.checked,enable_smog_effect:!!a.getElementById("enable_smog_effect")?.checked,enable_sun_glow:!!a.getElementById("enable_sun_glow")?.checked,enable_moon_glow:!!a.getElementById("enable_moon_glow")?.checked,enable_stars:!!a.getElementById("enable_stars")?.checked,enable_hail:!!a.getElementById("enable_hail")?.checked,enable_lightning_effect:!!a.getElementById("enable_lightning_effect")?.checked,enable_matrix:!!a.getElementById("enable_matrix")?.checked,enable_window_droplets:!!a.getElementById("enable_window_droplets")?.checked,stars_require_moon:!!a.getElementById("stars_require_moon")?.checked,mobile_limit_dpr:!!a.getElementById("mobile_limit_dpr")?.checked,mobile_reduce_particles:!!a.getElementById("mobile_reduce_particles")?.checked,mobile_snowy2_light:!!a.getElementById("mobile_snowy2_light")?.checked,mobile_smog_simple:!!a.getElementById("mobile_smog_simple")?.checked,mobile_30fps:!!a.getElementById("mobile_30fps")?.checked,gaming_matrix_only:!!a.getElementById("gaming_matrix_only")?.checked,snowy_variant:a.getElementById("snowy_variant")?.value||"snowy2",theme_mode:a.getElementById("theme_mode")?.value||null,spatial_mode:a.getElementById("spatial_mode")?.value||"foreground",development_mode:a.getElementById("development_mode").checked,test_effect:(a.querySelector('input[name="test_effect"]:checked')||{}).value||"Use Real Weather"});this._config=Z,window.ForkUWeatherAwareConfig=Z,this.dispatchEvent(new CustomEvent("config-changed",{detail:{config:Z}}))};["weather_entity","sun_entity","theme_mode","moon_phase_entity","uv_index_entity","moon_position_entity","moon_azimuth_entity","moon_altitude_entity","moon_distance_entity","gaming_mode_entity","pm25_entity","pm4_entity","pm10_entity","smog_threshold_pm25","smog_threshold_pm4","smog_threshold_pm10","cloud_coverage_entity","wind_speed_entity","wind_direction_entity","precipitation_entity","lightning_counter_entity","lightning_distance_entity","aurora_variant","aurora_chance_entity","aurora_visibility_alert_entity","aurora_visibility_min","k_index_entity","debug_precipitation","debug_wind_speed","debug_wind_direction","debug_lightning_distance","debug_lightning_counter","debug_cloud_coverage","debug_aurora_score","cloud_speed_multiplier","drizzle_precipitation_max","wind_sway_factor","rain_max_tilt_deg","rain_wind_min_kmh","speed_factor_rain","speed_factor_snow","speed_factor_clouds","speed_factor_fog","speed_factor_smog","speed_factor_hail","speed_factor_lightning","speed_factor_stars","speed_factor_matrix","snowy_variant","spatial_mode"].forEach(Z=>{const m=a.getElementById(Z);m&&m.addEventListener("change",c)}),["enabled","development_mode","mobile_limit_dpr","mobile_reduce_particles","mobile_snowy2_light","mobile_smog_simple","mobile_30fps","gaming_matrix_only","enable_rain","enable_snow","enable_clouds","enable_fog","enable_smog_effect","enable_sun_glow","enable_moon_glow","enable_stars","enable_hail","enable_lightning_effect","enable_matrix","enable_window_droplets","stars_require_moon","enable_aurora_effect"].forEach(Z=>{const m=a.getElementById(Z);m&&m.addEventListener("change",c)}),a.querySelectorAll('input[name="test_effect"]').forEach(Z=>{Z.addEventListener("change",c)})}}customElements.get("fork-u-weather-aware-card")||customElements.define("fork-u-weather-aware-card",t),customElements.get("fork-u-weather-aware-editor")||customElements.define("fork-u-weather-aware-editor",i)}()})();
