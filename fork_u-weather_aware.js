(function(){"use strict";const ls={enabled:!0,weather_entity:"weather.openweathermap",development_mode:!1,test_effect:"Use Real Weather",sun_entity:"sun.sun",moon_phase_entity:null,uv_index_entity:null,moon_position_entity:null,moon_azimuth_entity:null,moon_altitude_entity:null,moon_distance_entity:null,gaming_mode_entity:null,pm25_entity:null,pm4_entity:null,pm10_entity:null,smog_threshold_pm25:35,smog_threshold_pm4:50,smog_threshold_pm10:50,cloud_coverage_entity:null,wind_speed_entity:null,wind_direction_entity:null,precipitation_entity:null,lightning_counter_entity:null,lightning_distance_entity:null,debug_precipitation:null,debug_wind_speed:null,debug_wind_direction:null,debug_lightning_distance:null,debug_lightning_counter:null,debug_cloud_coverage:null,cloud_speed_multiplier:1,rain_max_tilt_deg:30,rain_wind_min_kmh:3,theme_mode:null,drizzle_precipitation_max:2.5,speed_factor_rain:1,speed_factor_snow:1,speed_factor_clouds:1,speed_factor_fog:1,speed_factor_smog:1,speed_factor_hail:1,speed_factor_lightning:1,speed_factor_stars:1,speed_factor_matrix:1,wind_sway_factor:.7,spatial_mode:"foreground",enable_rain:!0,enable_snow:!0,enable_clouds:!0,enable_fog:!0,enable_smog_effect:!0,enable_sun_glow:!0,enable_moon_glow:!0,enable_stars:!0,enable_hail:!0,enable_lightning_effect:!0,enable_matrix:!0,enable_window_droplets:!0,stars_require_moon:!1,mobile_limit_dpr:!0,mobile_reduce_particles:!0,mobile_snowy2_light:!0,mobile_smog_simple:!1,mobile_30fps:!1,gaming_matrix_only:!1};window.ForkUWeatherAwareConfig=Object.assign({},ls,window.ForkUWeatherAwareConfig||{}),window.ForkUWeatherAwareDefaultConfig=ls;try{console.log("%cFork U – Weather Aware%c Three.js overlay · spatial, theme & mobile aware","background:#ffcc00;color:#000;font-weight:bold;padding:2px 6px;border-radius:3px 0 0 3px;","background:#1e1e1e;color:#fff;padding:2px 6px;border-radius:0 3px 3px 0;")}catch{}/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Ci="170",mc=0,ns=1,Zc=2,is=1,hc=2,_e=3,ol=0,Re=1,Oe=2,ml=0,Ee=1,Ae=2,as=3,ss=4,bc=5,Rl=100,uc=101,rc=102,pc=103,Gc=104,Wc=200,Vc=201,Xc=202,gc=203,Si=204,Ii=205,Rc=206,yc=207,Cc=208,Sc=209,Ic=210,xc=211,Yc=212,Nc=213,fc=214,xi=0,Yi=1,Ni=2,kl=3,fi=4,Fi=5,Li=6,Ui=7,ds=0,Fc=1,Lc=2,Zl=0,Uc=1,Mc=2,Tc=3,Jc=4,vc=5,kc=6,wc=7,cs=300,wl=301,Hl=302,Mi=303,Ti=304,Tn=306,Ji=1e3,yl=1001,vi=1002,Te=1003,Hc=1004,Jn=1005,be=1006,ki=1007,Cl=1008,Qe=1009,os=1010,ms=1011,pn=1012,wi=1013,Sl=1014,qe=1015,Gn=1016,Hi=1017,zi=1018,zl=1020,Zs=35902,hs=1021,bs=1022,Ne=1023,us=1024,rs=1025,Kl=1026,Bl=1027,ps=1028,Ki=1029,Gs=1030,Bi=1031,Ei=1033,vn=33776,kn=33777,wn=33778,Hn=33779,Ai=35840,Qi=35841,Pi=35842,ji=35843,Di=36196,_i=37492,Oi=37496,qi=37808,$i=37809,ta=37810,ea=37811,la=37812,na=37813,ia=37814,aa=37815,sa=37816,da=37817,ca=37818,oa=37819,ma=37820,Za=37821,zn=36492,ha=36494,ba=36495,Ws=36283,ua=36284,ra=36285,pa=36286,zc=3200,Kc=3201,Bc=0,Ec=1,hl="",fe="srgb",El="srgb-linear",Kn="linear",Qt="srgb",Al=7680,Vs=519,Ac=512,Qc=513,Pc=514,Xs=515,jc=516,Dc=517,_c=518,Oc=519,gs=35044,Rs="300 es",$e=2e3,Bn=2001;class Ql{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const i=this._listeners[t];if(i!==void 0){const s=i.indexOf(e);s!==-1&&i.splice(s,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const n=this._listeners[t.type];if(n!==void 0){t.target=this;const i=n.slice(0);for(let s=0,a=i.length;s<a;s++)i[s].call(this,t);t.target=null}}}const ue=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let ys=1234567;const Wn=Math.PI/180,Vn=180/Math.PI;function Pl(){const l=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(ue[l&255]+ue[l>>8&255]+ue[l>>16&255]+ue[l>>24&255]+"-"+ue[t&255]+ue[t>>8&255]+"-"+ue[t>>16&15|64]+ue[t>>24&255]+"-"+ue[e&63|128]+ue[e>>8&255]+"-"+ue[e>>16&255]+ue[e>>24&255]+ue[n&255]+ue[n>>8&255]+ue[n>>16&255]+ue[n>>24&255]).toLowerCase()}function We(l,t,e){return Math.max(t,Math.min(e,l))}function Ga(l,t){return(l%t+t)%t}function qc(l,t,e,n,i){return n+(l-t)*(i-n)/(e-t)}function $c(l,t,e){return l!==t?(e-l)/(t-l):0}function Xn(l,t,e){return(1-e)*l+e*t}function to(l,t,e,n){return Xn(l,t,1-Math.exp(-e*n))}function eo(l,t=1){return t-Math.abs(Ga(l,t*2)-t)}function lo(l,t,e){return l<=t?0:l>=e?1:(l=(l-t)/(e-t),l*l*(3-2*l))}function no(l,t,e){return l<=t?0:l>=e?1:(l=(l-t)/(e-t),l*l*l*(l*(l*6-15)+10))}function io(l,t){return l+Math.floor(Math.random()*(t-l+1))}function ao(l,t){return l+Math.random()*(t-l)}function so(l){return l*(.5-Math.random())}function co(l){l!==void 0&&(ys=l);let t=ys+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}function oo(l){return l*Wn}function mo(l){return l*Vn}function Zo(l){return(l&l-1)===0&&l!==0}function ho(l){return Math.pow(2,Math.ceil(Math.log(l)/Math.LN2))}function bo(l){return Math.pow(2,Math.floor(Math.log(l)/Math.LN2))}function uo(l,t,e,n,i){const s=Math.cos,a=Math.sin,d=s(e/2),c=a(e/2),o=s((t+n)/2),m=a((t+n)/2),Z=s((t-n)/2),b=a((t-n)/2),h=s((n-t)/2),p=a((n-t)/2);switch(i){case"XYX":l.set(d*m,c*Z,c*b,d*o);break;case"YZY":l.set(c*b,d*m,c*Z,d*o);break;case"ZXZ":l.set(c*Z,c*b,d*m,d*o);break;case"XZX":l.set(d*m,c*p,c*h,d*o);break;case"YXY":l.set(c*h,d*m,c*p,d*o);break;case"ZYZ":l.set(c*p,c*h,d*m,d*o);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function jl(l,t){switch(t.constructor){case Float32Array:return l;case Uint32Array:return l/4294967295;case Uint16Array:return l/65535;case Uint8Array:return l/255;case Int32Array:return Math.max(l/2147483647,-1);case Int16Array:return Math.max(l/32767,-1);case Int8Array:return Math.max(l/127,-1);default:throw new Error("Invalid component type.")}}function Ve(l,t){switch(t.constructor){case Float32Array:return l;case Uint32Array:return Math.round(l*4294967295);case Uint16Array:return Math.round(l*65535);case Uint8Array:return Math.round(l*255);case Int32Array:return Math.round(l*2147483647);case Int16Array:return Math.round(l*32767);case Int8Array:return Math.round(l*127);default:throw new Error("Invalid component type.")}}const jt={DEG2RAD:Wn,RAD2DEG:Vn,generateUUID:Pl,clamp:We,euclideanModulo:Ga,mapLinear:qc,inverseLerp:$c,lerp:Xn,damp:to,pingpong:eo,smoothstep:lo,smootherstep:no,randInt:io,randFloat:ao,randFloatSpread:so,seededRandom:co,degToRad:oo,radToDeg:mo,isPowerOfTwo:Zo,ceilPowerOfTwo:ho,floorPowerOfTwo:bo,setQuaternionFromProperEuler:uo,normalize:Ve,denormalize:jl};class Lt{constructor(t=0,e=0){Lt.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(We(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),s=this.x-t.x,a=this.y-t.y;return this.x=s*n-a*i+t.x,this.y=s*i+a*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class xt{constructor(t,e,n,i,s,a,d,c,o){xt.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],t!==void 0&&this.set(t,e,n,i,s,a,d,c,o)}set(t,e,n,i,s,a,d,c,o){const m=this.elements;return m[0]=t,m[1]=i,m[2]=d,m[3]=e,m[4]=s,m[5]=c,m[6]=n,m[7]=a,m[8]=o,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,s=this.elements,a=n[0],d=n[3],c=n[6],o=n[1],m=n[4],Z=n[7],b=n[2],h=n[5],p=n[8],W=i[0],r=i[3],u=i[6],S=i[1],C=i[4],X=i[7],M=i[2],I=i[5],x=i[8];return s[0]=a*W+d*S+c*M,s[3]=a*r+d*C+c*I,s[6]=a*u+d*X+c*x,s[1]=o*W+m*S+Z*M,s[4]=o*r+m*C+Z*I,s[7]=o*u+m*X+Z*x,s[2]=b*W+h*S+p*M,s[5]=b*r+h*C+p*I,s[8]=b*u+h*X+p*x,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],a=t[4],d=t[5],c=t[6],o=t[7],m=t[8];return e*a*m-e*d*o-n*s*m+n*d*c+i*s*o-i*a*c}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],a=t[4],d=t[5],c=t[6],o=t[7],m=t[8],Z=m*a-d*o,b=d*c-m*s,h=o*s-a*c,p=e*Z+n*b+i*h;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const W=1/p;return t[0]=Z*W,t[1]=(i*o-m*n)*W,t[2]=(d*n-i*a)*W,t[3]=b*W,t[4]=(m*e-i*c)*W,t[5]=(i*s-d*e)*W,t[6]=h*W,t[7]=(n*c-o*e)*W,t[8]=(a*e-n*s)*W,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,s,a,d){const c=Math.cos(s),o=Math.sin(s);return this.set(n*c,n*o,-n*(c*a+o*d)+a+t,-i*o,i*c,-i*(-o*a+c*d)+d+e,0,0,1),this}scale(t,e){return this.premultiply(Wa.makeScale(t,e)),this}rotate(t){return this.premultiply(Wa.makeRotation(-t)),this}translate(t,e){return this.premultiply(Wa.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,n,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<9;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}const Wa=new xt;function Cs(l){for(let t=l.length-1;t>=0;--t)if(l[t]>=65535)return!0;return!1}function En(l){return document.createElementNS("http://www.w3.org/1999/xhtml",l)}function ro(){const l=En("canvas");return l.style.display="block",l}const Ss={};function gn(l){l in Ss||(Ss[l]=!0,console.warn(l))}function po(l,t,e){return new Promise(function(n,i){function s(){switch(l.clientWaitSync(t,l.SYNC_FLUSH_COMMANDS_BIT,0)){case l.WAIT_FAILED:i();break;case l.TIMEOUT_EXPIRED:setTimeout(s,e);break;default:n()}}setTimeout(s,e)})}function Go(l){const t=l.elements;t[2]=.5*t[2]+.5*t[3],t[6]=.5*t[6]+.5*t[7],t[10]=.5*t[10]+.5*t[11],t[14]=.5*t[14]+.5*t[15]}function Wo(l){const t=l.elements;t[11]===-1?(t[10]=-t[10]-1,t[14]=-t[14]):(t[10]=-t[10],t[14]=-t[14]+1)}const kt={enabled:!0,workingColorSpace:El,spaces:{},convert:function(l,t,e){return this.enabled===!1||t===e||!t||!e||(this.spaces[t].transfer===Qt&&(l.r=tl(l.r),l.g=tl(l.g),l.b=tl(l.b)),this.spaces[t].primaries!==this.spaces[e].primaries&&(l.applyMatrix3(this.spaces[t].toXYZ),l.applyMatrix3(this.spaces[e].fromXYZ)),this.spaces[e].transfer===Qt&&(l.r=Dl(l.r),l.g=Dl(l.g),l.b=Dl(l.b))),l},fromWorkingColorSpace:function(l,t){return this.convert(l,this.workingColorSpace,t)},toWorkingColorSpace:function(l,t){return this.convert(l,t,this.workingColorSpace)},getPrimaries:function(l){return this.spaces[l].primaries},getTransfer:function(l){return l===hl?Kn:this.spaces[l].transfer},getLuminanceCoefficients:function(l,t=this.workingColorSpace){return l.fromArray(this.spaces[t].luminanceCoefficients)},define:function(l){Object.assign(this.spaces,l)},_getMatrix:function(l,t,e){return l.copy(this.spaces[t].toXYZ).multiply(this.spaces[e].fromXYZ)},_getDrawingBufferColorSpace:function(l){return this.spaces[l].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(l=this.workingColorSpace){return this.spaces[l].workingColorSpaceConfig.unpackColorSpace}};function tl(l){return l<.04045?l*.0773993808:Math.pow(l*.9478672986+.0521327014,2.4)}function Dl(l){return l<.0031308?l*12.92:1.055*Math.pow(l,.41666)-.055}const Is=[.64,.33,.3,.6,.15,.06],xs=[.2126,.7152,.0722],Ys=[.3127,.329],Ns=new xt().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),fs=new xt().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);kt.define({[El]:{primaries:Is,whitePoint:Ys,transfer:Kn,toXYZ:Ns,fromXYZ:fs,luminanceCoefficients:xs,workingColorSpaceConfig:{unpackColorSpace:fe},outputColorSpaceConfig:{drawingBufferColorSpace:fe}},[fe]:{primaries:Is,whitePoint:Ys,transfer:Qt,toXYZ:Ns,fromXYZ:fs,luminanceCoefficients:xs,outputColorSpaceConfig:{drawingBufferColorSpace:fe}}});let _l;class Vo{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{_l===void 0&&(_l=En("canvas")),_l.width=t.width,_l.height=t.height;const n=_l.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=_l}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=En("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");n.drawImage(t,0,0,t.width,t.height);const i=n.getImageData(0,0,t.width,t.height),s=i.data;for(let a=0;a<s.length;a++)s[a]=tl(s[a]/255)*255;return n.putImageData(i,0,0),e}else if(t.data){const e=t.data.slice(0);for(let n=0;n<e.length;n++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[n]=Math.floor(tl(e[n]/255)*255):e[n]=tl(e[n]);return{data:e,width:t.width,height:t.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let Xo=0;class Fs{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:Xo++}),this.uuid=Pl(),this.data=t,this.dataReady=!0,this.version=0}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(i!==null){let s;if(Array.isArray(i)){s=[];for(let a=0,d=i.length;a<d;a++)i[a].isDataTexture?s.push(Va(i[a].image)):s.push(Va(i[a]))}else s=Va(i);n.url=s}return e||(t.images[this.uuid]=n),n}}function Va(l){return typeof HTMLImageElement<"u"&&l instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&l instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&l instanceof ImageBitmap?Vo.getDataURL(l):l.data?{data:Array.from(l.data),width:l.width,height:l.height,type:l.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let go=0;class Xe extends Ql{constructor(t=Xe.DEFAULT_IMAGE,e=Xe.DEFAULT_MAPPING,n=yl,i=yl,s=be,a=Cl,d=Ne,c=Qe,o=Xe.DEFAULT_ANISOTROPY,m=hl){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:go++}),this.uuid=Pl(),this.name="",this.source=new Fs(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=n,this.wrapT=i,this.magFilter=s,this.minFilter=a,this.anisotropy=o,this.format=d,this.internalFormat=null,this.type=c,this.offset=new Lt(0,0),this.repeat=new Lt(1,1),this.center=new Lt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new xt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=m,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==cs)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case Ji:t.x=t.x-Math.floor(t.x);break;case yl:t.x=t.x<0?0:1;break;case vi:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case Ji:t.y=t.y-Math.floor(t.y);break;case yl:t.y=t.y<0?0:1;break;case vi:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){t===!0&&this.pmremVersion++}}Xe.DEFAULT_IMAGE=null,Xe.DEFAULT_MAPPING=cs,Xe.DEFAULT_ANISOTROPY=1;class ne{constructor(t=0,e=0,n=0,i=1){ne.prototype.isVector4=!0,this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,s=this.w,a=t.elements;return this.x=a[0]*e+a[4]*n+a[8]*i+a[12]*s,this.y=a[1]*e+a[5]*n+a[9]*i+a[13]*s,this.z=a[2]*e+a[6]*n+a[10]*i+a[14]*s,this.w=a[3]*e+a[7]*n+a[11]*i+a[15]*s,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,s;const c=t.elements,o=c[0],m=c[4],Z=c[8],b=c[1],h=c[5],p=c[9],W=c[2],r=c[6],u=c[10];if(Math.abs(m-b)<.01&&Math.abs(Z-W)<.01&&Math.abs(p-r)<.01){if(Math.abs(m+b)<.1&&Math.abs(Z+W)<.1&&Math.abs(p+r)<.1&&Math.abs(o+h+u-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const C=(o+1)/2,X=(h+1)/2,M=(u+1)/2,I=(m+b)/4,x=(Z+W)/4,U=(p+r)/4;return C>X&&C>M?C<.01?(n=0,i=.707106781,s=.707106781):(n=Math.sqrt(C),i=I/n,s=x/n):X>M?X<.01?(n=.707106781,i=0,s=.707106781):(i=Math.sqrt(X),n=I/i,s=U/i):M<.01?(n=.707106781,i=.707106781,s=0):(s=Math.sqrt(M),n=x/s,i=U/s),this.set(n,i,s,e),this}let S=Math.sqrt((r-p)*(r-p)+(Z-W)*(Z-W)+(b-m)*(b-m));return Math.abs(S)<.001&&(S=1),this.x=(r-p)/S,this.y=(Z-W)/S,this.z=(b-m)/S,this.w=Math.acos((o+h+u-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Ro extends Ql{constructor(t=1,e=1,n={}){super(),this.isRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new ne(0,0,t,e),this.scissorTest=!1,this.viewport=new ne(0,0,t,e);const i={width:t,height:e,depth:1};n=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:be,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},n);const s=new Xe(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace);s.flipY=!1,s.generateMipmaps=n.generateMipmaps,s.internalFormat=n.internalFormat,this.textures=[];const a=n.count;for(let d=0;d<a;d++)this.textures[d]=s.clone(),this.textures[d].isRenderTargetTexture=!0;this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,this.resolveDepthBuffer=n.resolveDepthBuffer,this.resolveStencilBuffer=n.resolveStencilBuffer,this.depthTexture=n.depthTexture,this.samples=n.samples}get texture(){return this.textures[0]}set texture(t){this.textures[0]=t}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let i=0,s=this.textures.length;i<s;i++)this.textures[i].image.width=t,this.textures[i].image.height=e,this.textures[i].image.depth=n;this.dispose()}this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.textures.length=0;for(let n=0,i=t.textures.length;n<i;n++)this.textures[n]=t.textures[n].clone(),this.textures[n].isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new Fs(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.resolveDepthBuffer=t.resolveDepthBuffer,this.resolveStencilBuffer=t.resolveStencilBuffer,t.depthTexture!==null&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class bl extends Ro{constructor(t=1,e=1,n={}){super(t,e,n),this.isWebGLRenderTarget=!0}}class Ls extends Xe{constructor(t=null,e=1,n=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:n,depth:i},this.magFilter=Te,this.minFilter=Te,this.wrapR=yl,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class yo extends Xe{constructor(t=null,e=1,n=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:e,height:n,depth:i},this.magFilter=Te,this.minFilter=Te,this.wrapR=yl,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Rn{constructor(t=0,e=0,n=0,i=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=n,this._w=i}static slerpFlat(t,e,n,i,s,a,d){let c=n[i+0],o=n[i+1],m=n[i+2],Z=n[i+3];const b=s[a+0],h=s[a+1],p=s[a+2],W=s[a+3];if(d===0){t[e+0]=c,t[e+1]=o,t[e+2]=m,t[e+3]=Z;return}if(d===1){t[e+0]=b,t[e+1]=h,t[e+2]=p,t[e+3]=W;return}if(Z!==W||c!==b||o!==h||m!==p){let r=1-d;const u=c*b+o*h+m*p+Z*W,S=u>=0?1:-1,C=1-u*u;if(C>Number.EPSILON){const M=Math.sqrt(C),I=Math.atan2(M,u*S);r=Math.sin(r*I)/M,d=Math.sin(d*I)/M}const X=d*S;if(c=c*r+b*X,o=o*r+h*X,m=m*r+p*X,Z=Z*r+W*X,r===1-d){const M=1/Math.sqrt(c*c+o*o+m*m+Z*Z);c*=M,o*=M,m*=M,Z*=M}}t[e]=c,t[e+1]=o,t[e+2]=m,t[e+3]=Z}static multiplyQuaternionsFlat(t,e,n,i,s,a){const d=n[i],c=n[i+1],o=n[i+2],m=n[i+3],Z=s[a],b=s[a+1],h=s[a+2],p=s[a+3];return t[e]=d*p+m*Z+c*h-o*b,t[e+1]=c*p+m*b+o*Z-d*h,t[e+2]=o*p+m*h+d*b-c*Z,t[e+3]=m*p-d*Z-c*b-o*h,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const n=t._x,i=t._y,s=t._z,a=t._order,d=Math.cos,c=Math.sin,o=d(n/2),m=d(i/2),Z=d(s/2),b=c(n/2),h=c(i/2),p=c(s/2);switch(a){case"XYZ":this._x=b*m*Z+o*h*p,this._y=o*h*Z-b*m*p,this._z=o*m*p+b*h*Z,this._w=o*m*Z-b*h*p;break;case"YXZ":this._x=b*m*Z+o*h*p,this._y=o*h*Z-b*m*p,this._z=o*m*p-b*h*Z,this._w=o*m*Z+b*h*p;break;case"ZXY":this._x=b*m*Z-o*h*p,this._y=o*h*Z+b*m*p,this._z=o*m*p+b*h*Z,this._w=o*m*Z-b*h*p;break;case"ZYX":this._x=b*m*Z-o*h*p,this._y=o*h*Z+b*m*p,this._z=o*m*p-b*h*Z,this._w=o*m*Z+b*h*p;break;case"YZX":this._x=b*m*Z+o*h*p,this._y=o*h*Z+b*m*p,this._z=o*m*p-b*h*Z,this._w=o*m*Z-b*h*p;break;case"XZY":this._x=b*m*Z-o*h*p,this._y=o*h*Z-b*m*p,this._z=o*m*p+b*h*Z,this._w=o*m*Z+b*h*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return e===!0&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],s=e[8],a=e[1],d=e[5],c=e[9],o=e[2],m=e[6],Z=e[10],b=n+d+Z;if(b>0){const h=.5/Math.sqrt(b+1);this._w=.25/h,this._x=(m-c)*h,this._y=(s-o)*h,this._z=(a-i)*h}else if(n>d&&n>Z){const h=2*Math.sqrt(1+n-d-Z);this._w=(m-c)/h,this._x=.25*h,this._y=(i+a)/h,this._z=(s+o)/h}else if(d>Z){const h=2*Math.sqrt(1+d-n-Z);this._w=(s-o)/h,this._x=(i+a)/h,this._y=.25*h,this._z=(c+m)/h}else{const h=2*Math.sqrt(1+Z-n-d);this._w=(a-i)/h,this._x=(s+o)/h,this._y=(c+m)/h,this._z=.25*h}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(We(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,s=t._z,a=t._w,d=e._x,c=e._y,o=e._z,m=e._w;return this._x=n*m+a*d+i*o-s*c,this._y=i*m+a*c+s*d-n*o,this._z=s*m+a*o+n*c-i*d,this._w=a*m-n*d-i*c-s*o,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,i=this._y,s=this._z,a=this._w;let d=a*t._w+n*t._x+i*t._y+s*t._z;if(d<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,d=-d):this.copy(t),d>=1)return this._w=a,this._x=n,this._y=i,this._z=s,this;const c=1-d*d;if(c<=Number.EPSILON){const h=1-e;return this._w=h*a+e*this._w,this._x=h*n+e*this._x,this._y=h*i+e*this._y,this._z=h*s+e*this._z,this.normalize(),this}const o=Math.sqrt(c),m=Math.atan2(o,d),Z=Math.sin((1-e)*m)/o,b=Math.sin(e*m)/o;return this._w=a*Z+this._w*b,this._x=n*Z+this._x*b,this._y=i*Z+this._y*b,this._z=s*Z+this._z*b,this._onChangeCallback(),this}slerpQuaternions(t,e,n){return this.copy(t).slerp(e,n)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),n=Math.random(),i=Math.sqrt(1-n),s=Math.sqrt(n);return this.set(i*Math.sin(t),i*Math.cos(t),s*Math.sin(e),s*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class k{constructor(t=0,e=0,n=0){k.prototype.isVector3=!0,this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(Us.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(Us.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,s=t.elements;return this.x=s[0]*e+s[3]*n+s[6]*i,this.y=s[1]*e+s[4]*n+s[7]*i,this.z=s[2]*e+s[5]*n+s[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,s=t.elements,a=1/(s[3]*e+s[7]*n+s[11]*i+s[15]);return this.x=(s[0]*e+s[4]*n+s[8]*i+s[12])*a,this.y=(s[1]*e+s[5]*n+s[9]*i+s[13])*a,this.z=(s[2]*e+s[6]*n+s[10]*i+s[14])*a,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,s=t.x,a=t.y,d=t.z,c=t.w,o=2*(a*i-d*n),m=2*(d*e-s*i),Z=2*(s*n-a*e);return this.x=e+c*o+a*Z-d*m,this.y=n+c*m+d*o-s*Z,this.z=i+c*Z+s*m-a*o,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*i,this.y=s[1]*e+s[5]*n+s[9]*i,this.z=s[2]*e+s[6]*n+s[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,s=t.z,a=e.x,d=e.y,c=e.z;return this.x=i*c-s*d,this.y=s*a-n*c,this.z=n*d-i*a,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return Xa.copy(this).projectOnVector(t),this.sub(Xa)}reflect(t){return this.sub(Xa.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(We(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=Math.random()*2-1,n=Math.sqrt(1-e*e);return this.x=n*Math.cos(t),this.y=e,this.z=n*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Xa=new k,Us=new Rn;class yn{constructor(t=new k(1/0,1/0,1/0),e=new k(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e+=3)this.expandByPoint(Je.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,n=t.count;e<n;e++)this.expandByPoint(Je.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=Je.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const n=t.geometry;if(n!==void 0){const s=n.getAttribute("position");if(e===!0&&s!==void 0&&t.isInstancedMesh!==!0)for(let a=0,d=s.count;a<d;a++)t.isMesh===!0?t.getVertexPosition(a,Je):Je.fromBufferAttribute(s,a),Je.applyMatrix4(t.matrixWorld),this.expandByPoint(Je);else t.boundingBox!==void 0?(t.boundingBox===null&&t.computeBoundingBox(),An.copy(t.boundingBox)):(n.boundingBox===null&&n.computeBoundingBox(),An.copy(n.boundingBox)),An.applyMatrix4(t.matrixWorld),this.union(An)}const i=t.children;for(let s=0,a=i.length;s<a;s++)this.expandByObject(i[s],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,Je),Je.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Cn),Qn.subVectors(this.max,Cn),Ol.subVectors(t.a,Cn),ql.subVectors(t.b,Cn),$l.subVectors(t.c,Cn),ul.subVectors(ql,Ol),rl.subVectors($l,ql),Il.subVectors(Ol,$l);let e=[0,-ul.z,ul.y,0,-rl.z,rl.y,0,-Il.z,Il.y,ul.z,0,-ul.x,rl.z,0,-rl.x,Il.z,0,-Il.x,-ul.y,ul.x,0,-rl.y,rl.x,0,-Il.y,Il.x,0];return!ga(e,Ol,ql,$l,Qn)||(e=[1,0,0,0,1,0,0,0,1],!ga(e,Ol,ql,$l,Qn))?!1:(Pn.crossVectors(ul,rl),e=[Pn.x,Pn.y,Pn.z],ga(e,Ol,ql,$l,Qn))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,Je).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=this.getSize(Je).length()*.5),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(el[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),el[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),el[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),el[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),el[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),el[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),el[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),el[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(el),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const el=[new k,new k,new k,new k,new k,new k,new k,new k],Je=new k,An=new yn,Ol=new k,ql=new k,$l=new k,ul=new k,rl=new k,Il=new k,Cn=new k,Qn=new k,Pn=new k,xl=new k;function ga(l,t,e,n,i){for(let s=0,a=l.length-3;s<=a;s+=3){xl.fromArray(l,s);const d=i.x*Math.abs(xl.x)+i.y*Math.abs(xl.y)+i.z*Math.abs(xl.z),c=t.dot(xl),o=e.dot(xl),m=n.dot(xl);if(Math.max(-Math.max(c,o,m),Math.min(c,o,m))>d)return!1}return!0}const Co=new yn,Sn=new k,Ra=new k;class jn{constructor(t=new k,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):Co.setFromPoints(t).getCenter(n);let i=0;for(let s=0,a=t.length;s<a;s++)i=Math.max(i,n.distanceToSquared(t[s]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;Sn.subVectors(t,this.center);const e=Sn.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),i=(n-this.radius)*.5;this.center.addScaledVector(Sn,i/n),this.radius+=i}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)===!0?this.radius=Math.max(this.radius,t.radius):(Ra.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(Sn.copy(t.center).add(Ra)),this.expandByPoint(Sn.copy(t.center).sub(Ra))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const ll=new k,ya=new k,Dn=new k,pl=new k,Ca=new k,_n=new k,Sa=new k;class Ms{constructor(t=new k,e=new k(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,ll)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=ll.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(ll.copy(this.origin).addScaledVector(this.direction,e),ll.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){ya.copy(t).add(e).multiplyScalar(.5),Dn.copy(e).sub(t).normalize(),pl.copy(this.origin).sub(ya);const s=t.distanceTo(e)*.5,a=-this.direction.dot(Dn),d=pl.dot(this.direction),c=-pl.dot(Dn),o=pl.lengthSq(),m=Math.abs(1-a*a);let Z,b,h,p;if(m>0)if(Z=a*c-d,b=a*d-c,p=s*m,Z>=0)if(b>=-p)if(b<=p){const W=1/m;Z*=W,b*=W,h=Z*(Z+a*b+2*d)+b*(a*Z+b+2*c)+o}else b=s,Z=Math.max(0,-(a*b+d)),h=-Z*Z+b*(b+2*c)+o;else b=-s,Z=Math.max(0,-(a*b+d)),h=-Z*Z+b*(b+2*c)+o;else b<=-p?(Z=Math.max(0,-(-a*s+d)),b=Z>0?-s:Math.min(Math.max(-s,-c),s),h=-Z*Z+b*(b+2*c)+o):b<=p?(Z=0,b=Math.min(Math.max(-s,-c),s),h=b*(b+2*c)+o):(Z=Math.max(0,-(a*s+d)),b=Z>0?s:Math.min(Math.max(-s,-c),s),h=-Z*Z+b*(b+2*c)+o);else b=a>0?-s:s,Z=Math.max(0,-(a*b+d)),h=-Z*Z+b*(b+2*c)+o;return n&&n.copy(this.origin).addScaledVector(this.direction,Z),i&&i.copy(ya).addScaledVector(Dn,b),h}intersectSphere(t,e){ll.subVectors(t.center,this.origin);const n=ll.dot(this.direction),i=ll.dot(ll)-n*n,s=t.radius*t.radius;if(i>s)return null;const a=Math.sqrt(s-i),d=n-a,c=n+a;return c<0?null:d<0?this.at(c,e):this.at(d,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,s,a,d,c;const o=1/this.direction.x,m=1/this.direction.y,Z=1/this.direction.z,b=this.origin;return o>=0?(n=(t.min.x-b.x)*o,i=(t.max.x-b.x)*o):(n=(t.max.x-b.x)*o,i=(t.min.x-b.x)*o),m>=0?(s=(t.min.y-b.y)*m,a=(t.max.y-b.y)*m):(s=(t.max.y-b.y)*m,a=(t.min.y-b.y)*m),n>a||s>i||((s>n||isNaN(n))&&(n=s),(a<i||isNaN(i))&&(i=a),Z>=0?(d=(t.min.z-b.z)*Z,c=(t.max.z-b.z)*Z):(d=(t.max.z-b.z)*Z,c=(t.min.z-b.z)*Z),n>c||d>i)||((d>n||n!==n)&&(n=d),(c<i||i!==i)&&(i=c),i<0)?null:this.at(n>=0?n:i,e)}intersectsBox(t){return this.intersectBox(t,ll)!==null}intersectTriangle(t,e,n,i,s){Ca.subVectors(e,t),_n.subVectors(n,t),Sa.crossVectors(Ca,_n);let a=this.direction.dot(Sa),d;if(a>0){if(i)return null;d=1}else if(a<0)d=-1,a=-a;else return null;pl.subVectors(this.origin,t);const c=d*this.direction.dot(_n.crossVectors(pl,_n));if(c<0)return null;const o=d*this.direction.dot(Ca.cross(pl));if(o<0||c+o>a)return null;const m=-d*pl.dot(Sa);return m<0?null:this.at(m/a,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class ie{constructor(t,e,n,i,s,a,d,c,o,m,Z,b,h,p,W,r){ie.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,e,n,i,s,a,d,c,o,m,Z,b,h,p,W,r)}set(t,e,n,i,s,a,d,c,o,m,Z,b,h,p,W,r){const u=this.elements;return u[0]=t,u[4]=e,u[8]=n,u[12]=i,u[1]=s,u[5]=a,u[9]=d,u[13]=c,u[2]=o,u[6]=m,u[10]=Z,u[14]=b,u[3]=h,u[7]=p,u[11]=W,u[15]=r,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new ie().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/tn.setFromMatrixColumn(t,0).length(),s=1/tn.setFromMatrixColumn(t,1).length(),a=1/tn.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*s,e[5]=n[5]*s,e[6]=n[6]*s,e[7]=0,e[8]=n[8]*a,e[9]=n[9]*a,e[10]=n[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,n=t.x,i=t.y,s=t.z,a=Math.cos(n),d=Math.sin(n),c=Math.cos(i),o=Math.sin(i),m=Math.cos(s),Z=Math.sin(s);if(t.order==="XYZ"){const b=a*m,h=a*Z,p=d*m,W=d*Z;e[0]=c*m,e[4]=-c*Z,e[8]=o,e[1]=h+p*o,e[5]=b-W*o,e[9]=-d*c,e[2]=W-b*o,e[6]=p+h*o,e[10]=a*c}else if(t.order==="YXZ"){const b=c*m,h=c*Z,p=o*m,W=o*Z;e[0]=b+W*d,e[4]=p*d-h,e[8]=a*o,e[1]=a*Z,e[5]=a*m,e[9]=-d,e[2]=h*d-p,e[6]=W+b*d,e[10]=a*c}else if(t.order==="ZXY"){const b=c*m,h=c*Z,p=o*m,W=o*Z;e[0]=b-W*d,e[4]=-a*Z,e[8]=p+h*d,e[1]=h+p*d,e[5]=a*m,e[9]=W-b*d,e[2]=-a*o,e[6]=d,e[10]=a*c}else if(t.order==="ZYX"){const b=a*m,h=a*Z,p=d*m,W=d*Z;e[0]=c*m,e[4]=p*o-h,e[8]=b*o+W,e[1]=c*Z,e[5]=W*o+b,e[9]=h*o-p,e[2]=-o,e[6]=d*c,e[10]=a*c}else if(t.order==="YZX"){const b=a*c,h=a*o,p=d*c,W=d*o;e[0]=c*m,e[4]=W-b*Z,e[8]=p*Z+h,e[1]=Z,e[5]=a*m,e[9]=-d*m,e[2]=-o*m,e[6]=h*Z+p,e[10]=b-W*Z}else if(t.order==="XZY"){const b=a*c,h=a*o,p=d*c,W=d*o;e[0]=c*m,e[4]=-Z,e[8]=o*m,e[1]=b*Z+W,e[5]=a*m,e[9]=h*Z-p,e[2]=p*Z-h,e[6]=d*m,e[10]=W*Z+b}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(So,t,Io)}lookAt(t,e,n){const i=this.elements;return Ie.subVectors(t,e),Ie.lengthSq()===0&&(Ie.z=1),Ie.normalize(),Gl.crossVectors(n,Ie),Gl.lengthSq()===0&&(Math.abs(n.z)===1?Ie.x+=1e-4:Ie.z+=1e-4,Ie.normalize(),Gl.crossVectors(n,Ie)),Gl.normalize(),On.crossVectors(Ie,Gl),i[0]=Gl.x,i[4]=On.x,i[8]=Ie.x,i[1]=Gl.y,i[5]=On.y,i[9]=Ie.y,i[2]=Gl.z,i[6]=On.z,i[10]=Ie.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,s=this.elements,a=n[0],d=n[4],c=n[8],o=n[12],m=n[1],Z=n[5],b=n[9],h=n[13],p=n[2],W=n[6],r=n[10],u=n[14],S=n[3],C=n[7],X=n[11],M=n[15],I=i[0],x=i[4],U=i[8],R=i[12],g=i[1],Y=i[5],Q=i[9],w=i[13],E=i[2],_=i[6],K=i[10],$=i[14],z=i[3],nt=i[7],ot=i[11],Vt=i[15];return s[0]=a*I+d*g+c*E+o*z,s[4]=a*x+d*Y+c*_+o*nt,s[8]=a*U+d*Q+c*K+o*ot,s[12]=a*R+d*w+c*$+o*Vt,s[1]=m*I+Z*g+b*E+h*z,s[5]=m*x+Z*Y+b*_+h*nt,s[9]=m*U+Z*Q+b*K+h*ot,s[13]=m*R+Z*w+b*$+h*Vt,s[2]=p*I+W*g+r*E+u*z,s[6]=p*x+W*Y+r*_+u*nt,s[10]=p*U+W*Q+r*K+u*ot,s[14]=p*R+W*w+r*$+u*Vt,s[3]=S*I+C*g+X*E+M*z,s[7]=S*x+C*Y+X*_+M*nt,s[11]=S*U+C*Q+X*K+M*ot,s[15]=S*R+C*w+X*$+M*Vt,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],s=t[12],a=t[1],d=t[5],c=t[9],o=t[13],m=t[2],Z=t[6],b=t[10],h=t[14],p=t[3],W=t[7],r=t[11],u=t[15];return p*(+s*c*Z-i*o*Z-s*d*b+n*o*b+i*d*h-n*c*h)+W*(+e*c*h-e*o*b+s*a*b-i*a*h+i*o*m-s*c*m)+r*(+e*o*Z-e*d*h-s*a*Z+n*a*h+s*d*m-n*o*m)+u*(-i*d*m-e*c*Z+e*d*b+i*a*Z-n*a*b+n*c*m)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],a=t[4],d=t[5],c=t[6],o=t[7],m=t[8],Z=t[9],b=t[10],h=t[11],p=t[12],W=t[13],r=t[14],u=t[15],S=Z*r*o-W*b*o+W*c*h-d*r*h-Z*c*u+d*b*u,C=p*b*o-m*r*o-p*c*h+a*r*h+m*c*u-a*b*u,X=m*W*o-p*Z*o+p*d*h-a*W*h-m*d*u+a*Z*u,M=p*Z*c-m*W*c-p*d*b+a*W*b+m*d*r-a*Z*r,I=e*S+n*C+i*X+s*M;if(I===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const x=1/I;return t[0]=S*x,t[1]=(W*b*s-Z*r*s-W*i*h+n*r*h+Z*i*u-n*b*u)*x,t[2]=(d*r*s-W*c*s+W*i*o-n*r*o-d*i*u+n*c*u)*x,t[3]=(Z*c*s-d*b*s-Z*i*o+n*b*o+d*i*h-n*c*h)*x,t[4]=C*x,t[5]=(m*r*s-p*b*s+p*i*h-e*r*h-m*i*u+e*b*u)*x,t[6]=(p*c*s-a*r*s-p*i*o+e*r*o+a*i*u-e*c*u)*x,t[7]=(a*b*s-m*c*s+m*i*o-e*b*o-a*i*h+e*c*h)*x,t[8]=X*x,t[9]=(p*Z*s-m*W*s-p*n*h+e*W*h+m*n*u-e*Z*u)*x,t[10]=(a*W*s-p*d*s+p*n*o-e*W*o-a*n*u+e*d*u)*x,t[11]=(m*d*s-a*Z*s-m*n*o+e*Z*o+a*n*h-e*d*h)*x,t[12]=M*x,t[13]=(m*W*i-p*Z*i+p*n*b-e*W*b-m*n*r+e*Z*r)*x,t[14]=(p*d*i-a*W*i-p*n*c+e*W*c+a*n*r-e*d*r)*x,t[15]=(a*Z*i-m*d*i+m*n*c-e*Z*c-a*n*b+e*d*b)*x,this}scale(t){const e=this.elements,n=t.x,i=t.y,s=t.z;return e[0]*=n,e[4]*=i,e[8]*=s,e[1]*=n,e[5]*=i,e[9]*=s,e[2]*=n,e[6]*=i,e[10]*=s,e[3]*=n,e[7]*=i,e[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),s=1-n,a=t.x,d=t.y,c=t.z,o=s*a,m=s*d;return this.set(o*a+n,o*d-i*c,o*c+i*d,0,o*d+i*c,m*d+n,m*c-i*a,0,o*c-i*d,m*c+i*a,s*c*c+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,i,s,a){return this.set(1,n,s,0,t,1,a,0,e,i,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,s=e._x,a=e._y,d=e._z,c=e._w,o=s+s,m=a+a,Z=d+d,b=s*o,h=s*m,p=s*Z,W=a*m,r=a*Z,u=d*Z,S=c*o,C=c*m,X=c*Z,M=n.x,I=n.y,x=n.z;return i[0]=(1-(W+u))*M,i[1]=(h+X)*M,i[2]=(p-C)*M,i[3]=0,i[4]=(h-X)*I,i[5]=(1-(b+u))*I,i[6]=(r+S)*I,i[7]=0,i[8]=(p+C)*x,i[9]=(r-S)*x,i[10]=(1-(b+W))*x,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let s=tn.set(i[0],i[1],i[2]).length();const a=tn.set(i[4],i[5],i[6]).length(),d=tn.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),t.x=i[12],t.y=i[13],t.z=i[14],ve.copy(this);const o=1/s,m=1/a,Z=1/d;return ve.elements[0]*=o,ve.elements[1]*=o,ve.elements[2]*=o,ve.elements[4]*=m,ve.elements[5]*=m,ve.elements[6]*=m,ve.elements[8]*=Z,ve.elements[9]*=Z,ve.elements[10]*=Z,e.setFromRotationMatrix(ve),n.x=s,n.y=a,n.z=d,this}makePerspective(t,e,n,i,s,a,d=$e){const c=this.elements,o=2*s/(e-t),m=2*s/(n-i),Z=(e+t)/(e-t),b=(n+i)/(n-i);let h,p;if(d===$e)h=-(a+s)/(a-s),p=-2*a*s/(a-s);else if(d===Bn)h=-a/(a-s),p=-a*s/(a-s);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+d);return c[0]=o,c[4]=0,c[8]=Z,c[12]=0,c[1]=0,c[5]=m,c[9]=b,c[13]=0,c[2]=0,c[6]=0,c[10]=h,c[14]=p,c[3]=0,c[7]=0,c[11]=-1,c[15]=0,this}makeOrthographic(t,e,n,i,s,a,d=$e){const c=this.elements,o=1/(e-t),m=1/(n-i),Z=1/(a-s),b=(e+t)*o,h=(n+i)*m;let p,W;if(d===$e)p=(a+s)*Z,W=-2*Z;else if(d===Bn)p=s*Z,W=-1*Z;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+d);return c[0]=2*o,c[4]=0,c[8]=0,c[12]=-b,c[1]=0,c[5]=2*m,c[9]=0,c[13]=-h,c[2]=0,c[6]=0,c[10]=W,c[14]=-p,c[3]=0,c[7]=0,c[11]=0,c[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<16;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}const tn=new k,ve=new ie,So=new k(0,0,0),Io=new k(1,1,1),Gl=new k,On=new k,Ie=new k,Ts=new ie,Js=new Rn;class nl{constructor(t=0,e=0,n=0,i=nl.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i=this._order){return this._x=t,this._y=e,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const i=t.elements,s=i[0],a=i[4],d=i[8],c=i[1],o=i[5],m=i[9],Z=i[2],b=i[6],h=i[10];switch(e){case"XYZ":this._y=Math.asin(We(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(-m,h),this._z=Math.atan2(-a,s)):(this._x=Math.atan2(b,o),this._z=0);break;case"YXZ":this._x=Math.asin(-We(m,-1,1)),Math.abs(m)<.9999999?(this._y=Math.atan2(d,h),this._z=Math.atan2(c,o)):(this._y=Math.atan2(-Z,s),this._z=0);break;case"ZXY":this._x=Math.asin(We(b,-1,1)),Math.abs(b)<.9999999?(this._y=Math.atan2(-Z,h),this._z=Math.atan2(-a,o)):(this._y=0,this._z=Math.atan2(c,s));break;case"ZYX":this._y=Math.asin(-We(Z,-1,1)),Math.abs(Z)<.9999999?(this._x=Math.atan2(b,h),this._z=Math.atan2(c,s)):(this._x=0,this._z=Math.atan2(-a,o));break;case"YZX":this._z=Math.asin(We(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-m,o),this._y=Math.atan2(-Z,s)):(this._x=0,this._y=Math.atan2(d,h));break;case"XZY":this._z=Math.asin(-We(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(b,o),this._y=Math.atan2(d,s)):(this._x=Math.atan2(-m,h),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return Ts.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Ts,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Js.setFromEuler(this),this.setFromQuaternion(Js,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}nl.DEFAULT_ORDER="XYZ";class vs{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let xo=0;const ks=new k,en=new Rn,il=new ie,qn=new k,In=new k,Yo=new k,No=new Rn,ws=new k(1,0,0),Hs=new k(0,1,0),zs=new k(0,0,1),Ks={type:"added"},fo={type:"removed"},ln={type:"childadded",child:null},Ia={type:"childremoved",child:null};class ye extends Ql{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:xo++}),this.uuid=Pl(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=ye.DEFAULT_UP.clone();const t=new k,e=new nl,n=new Rn,i=new k(1,1,1);function s(){n.setFromEuler(e,!1)}function a(){e.setFromQuaternion(n,void 0,!1)}e._onChange(s),n._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new ie},normalMatrix:{value:new xt}}),this.matrix=new ie,this.matrixWorld=new ie,this.matrixAutoUpdate=ye.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=ye.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new vs,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return en.setFromAxisAngle(t,e),this.quaternion.multiply(en),this}rotateOnWorldAxis(t,e){return en.setFromAxisAngle(t,e),this.quaternion.premultiply(en),this}rotateX(t){return this.rotateOnAxis(ws,t)}rotateY(t){return this.rotateOnAxis(Hs,t)}rotateZ(t){return this.rotateOnAxis(zs,t)}translateOnAxis(t,e){return ks.copy(t).applyQuaternion(this.quaternion),this.position.add(ks.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(ws,t)}translateY(t){return this.translateOnAxis(Hs,t)}translateZ(t){return this.translateOnAxis(zs,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(il.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?qn.copy(t):qn.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),In.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?il.lookAt(In,qn,this.up):il.lookAt(qn,In,this.up),this.quaternion.setFromRotationMatrix(il),i&&(il.extractRotation(i.matrixWorld),en.setFromRotationMatrix(il),this.quaternion.premultiply(en.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(Ks),ln.child=t,this.dispatchEvent(ln),ln.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(fo),Ia.child=t,this.dispatchEvent(Ia),Ia.child=null),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),il.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),il.multiply(t.parent.matrixWorld)),t.applyMatrix4(il),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(Ks),ln.child=t,this.dispatchEvent(ln),ln.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const a=this.children[n].getObjectByProperty(t,e);if(a!==void 0)return a}}getObjectsByProperty(t,e,n=[]){this[t]===e&&n.push(this);const i=this.children;for(let s=0,a=i.length;s<a;s++)i[s].getObjectsByProperty(t,e,n);return n}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(In,t,Yo),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(In,No,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(t===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),e===!0){const i=this.children;for(let s=0,a=i.length;s<a;s++)i[s].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.visibility=this._visibility,i.active=this._active,i.bounds=this._bounds.map(d=>({boxInitialized:d.boxInitialized,boxMin:d.box.min.toArray(),boxMax:d.box.max.toArray(),sphereInitialized:d.sphereInitialized,sphereRadius:d.sphere.radius,sphereCenter:d.sphere.center.toArray()})),i.maxInstanceCount=this._maxInstanceCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.geometryCount=this._geometryCount,i.matricesTexture=this._matricesTexture.toJSON(t),this._colorsTexture!==null&&(i.colorsTexture=this._colorsTexture.toJSON(t)),this.boundingSphere!==null&&(i.boundingSphere={center:i.boundingSphere.center.toArray(),radius:i.boundingSphere.radius}),this.boundingBox!==null&&(i.boundingBox={min:i.boundingBox.min.toArray(),max:i.boundingBox.max.toArray()}));function s(d,c){return d[c.uuid]===void 0&&(d[c.uuid]=c.toJSON(t)),c.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=s(t.geometries,this.geometry);const d=this.geometry.parameters;if(d!==void 0&&d.shapes!==void 0){const c=d.shapes;if(Array.isArray(c))for(let o=0,m=c.length;o<m;o++){const Z=c[o];s(t.shapes,Z)}else s(t.shapes,c)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const d=[];for(let c=0,o=this.material.length;c<o;c++)d.push(s(t.materials,this.material[c]));i.material=d}else i.material=s(t.materials,this.material);if(this.children.length>0){i.children=[];for(let d=0;d<this.children.length;d++)i.children.push(this.children[d].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let d=0;d<this.animations.length;d++){const c=this.animations[d];i.animations.push(s(t.animations,c))}}if(e){const d=a(t.geometries),c=a(t.materials),o=a(t.textures),m=a(t.images),Z=a(t.shapes),b=a(t.skeletons),h=a(t.animations),p=a(t.nodes);d.length>0&&(n.geometries=d),c.length>0&&(n.materials=c),o.length>0&&(n.textures=o),m.length>0&&(n.images=m),Z.length>0&&(n.shapes=Z),b.length>0&&(n.skeletons=b),h.length>0&&(n.animations=h),p.length>0&&(n.nodes=p)}return n.object=i,n;function a(d){const c=[];for(const o in d){const m=d[o];delete m.metadata,c.push(m)}return c}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let n=0;n<t.children.length;n++){const i=t.children[n];this.add(i.clone())}return this}}ye.DEFAULT_UP=new k(0,1,0),ye.DEFAULT_MATRIX_AUTO_UPDATE=!0,ye.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const ke=new k,al=new k,xa=new k,sl=new k,nn=new k,an=new k,Bs=new k,Ya=new k,Na=new k,fa=new k,Fa=new ne,La=new ne,Ua=new ne;class we{constructor(t=new k,e=new k,n=new k){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i.subVectors(n,e),ke.subVectors(t,e),i.cross(ke);const s=i.lengthSq();return s>0?i.multiplyScalar(1/Math.sqrt(s)):i.set(0,0,0)}static getBarycoord(t,e,n,i,s){ke.subVectors(i,e),al.subVectors(n,e),xa.subVectors(t,e);const a=ke.dot(ke),d=ke.dot(al),c=ke.dot(xa),o=al.dot(al),m=al.dot(xa),Z=a*o-d*d;if(Z===0)return s.set(0,0,0),null;const b=1/Z,h=(o*c-d*m)*b,p=(a*m-d*c)*b;return s.set(1-h-p,p,h)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,sl)===null?!1:sl.x>=0&&sl.y>=0&&sl.x+sl.y<=1}static getInterpolation(t,e,n,i,s,a,d,c){return this.getBarycoord(t,e,n,i,sl)===null?(c.x=0,c.y=0,"z"in c&&(c.z=0),"w"in c&&(c.w=0),null):(c.setScalar(0),c.addScaledVector(s,sl.x),c.addScaledVector(a,sl.y),c.addScaledVector(d,sl.z),c)}static getInterpolatedAttribute(t,e,n,i,s,a){return Fa.setScalar(0),La.setScalar(0),Ua.setScalar(0),Fa.fromBufferAttribute(t,e),La.fromBufferAttribute(t,n),Ua.fromBufferAttribute(t,i),a.setScalar(0),a.addScaledVector(Fa,s.x),a.addScaledVector(La,s.y),a.addScaledVector(Ua,s.z),a}static isFrontFacing(t,e,n,i){return ke.subVectors(n,e),al.subVectors(t,e),ke.cross(al).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}setFromAttributeAndIndices(t,e,n,i){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,i),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return ke.subVectors(this.c,this.b),al.subVectors(this.a,this.b),ke.cross(al).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return we.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return we.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,n,i,s){return we.getInterpolation(t,this.a,this.b,this.c,e,n,i,s)}containsPoint(t){return we.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return we.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,i=this.b,s=this.c;let a,d;nn.subVectors(i,n),an.subVectors(s,n),Ya.subVectors(t,n);const c=nn.dot(Ya),o=an.dot(Ya);if(c<=0&&o<=0)return e.copy(n);Na.subVectors(t,i);const m=nn.dot(Na),Z=an.dot(Na);if(m>=0&&Z<=m)return e.copy(i);const b=c*Z-m*o;if(b<=0&&c>=0&&m<=0)return a=c/(c-m),e.copy(n).addScaledVector(nn,a);fa.subVectors(t,s);const h=nn.dot(fa),p=an.dot(fa);if(p>=0&&h<=p)return e.copy(s);const W=h*o-c*p;if(W<=0&&o>=0&&p<=0)return d=o/(o-p),e.copy(n).addScaledVector(an,d);const r=m*p-h*Z;if(r<=0&&Z-m>=0&&h-p>=0)return Bs.subVectors(s,i),d=(Z-m)/(Z-m+(h-p)),e.copy(i).addScaledVector(Bs,d);const u=1/(r+W+b);return a=W*u,d=b*u,e.copy(n).addScaledVector(nn,a).addScaledVector(an,d)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const Es={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Wl={h:0,s:0,l:0},$n={h:0,s:0,l:0};function Ma(l,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?l+(t-l)*6*e:e<1/2?t:e<2/3?l+(t-l)*6*(2/3-e):l}class Kt{constructor(t,e,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,n)}set(t,e,n){if(e===void 0&&n===void 0){const i=t;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(t,e,n);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=fe){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,kt.toWorkingColorSpace(this,e),this}setRGB(t,e,n,i=kt.workingColorSpace){return this.r=t,this.g=e,this.b=n,kt.toWorkingColorSpace(this,i),this}setHSL(t,e,n,i=kt.workingColorSpace){if(t=Ga(t,1),e=We(e,0,1),n=We(n,0,1),e===0)this.r=this.g=this.b=n;else{const s=n<=.5?n*(1+e):n+e-n*e,a=2*n-s;this.r=Ma(a,s,t+1/3),this.g=Ma(a,s,t),this.b=Ma(a,s,t-1/3)}return kt.toWorkingColorSpace(this,i),this}setStyle(t,e=fe){function n(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(t)){let s;const a=i[1],d=i[2];switch(a){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))return n(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,e);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))return n(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,e);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))return n(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(t)){const s=i[1],a=s.length;if(a===3)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,e);if(a===6)return this.setHex(parseInt(s,16),e);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=fe){const n=Es[t.toLowerCase()];return n!==void 0?this.setHex(n,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=tl(t.r),this.g=tl(t.g),this.b=tl(t.b),this}copyLinearToSRGB(t){return this.r=Dl(t.r),this.g=Dl(t.g),this.b=Dl(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=fe){return kt.fromWorkingColorSpace(re.copy(this),t),Math.round(We(re.r*255,0,255))*65536+Math.round(We(re.g*255,0,255))*256+Math.round(We(re.b*255,0,255))}getHexString(t=fe){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=kt.workingColorSpace){kt.fromWorkingColorSpace(re.copy(this),e);const n=re.r,i=re.g,s=re.b,a=Math.max(n,i,s),d=Math.min(n,i,s);let c,o;const m=(d+a)/2;if(d===a)c=0,o=0;else{const Z=a-d;switch(o=m<=.5?Z/(a+d):Z/(2-a-d),a){case n:c=(i-s)/Z+(i<s?6:0);break;case i:c=(s-n)/Z+2;break;case s:c=(n-i)/Z+4;break}c/=6}return t.h=c,t.s=o,t.l=m,t}getRGB(t,e=kt.workingColorSpace){return kt.fromWorkingColorSpace(re.copy(this),e),t.r=re.r,t.g=re.g,t.b=re.b,t}getStyle(t=fe){kt.fromWorkingColorSpace(re.copy(this),t);const e=re.r,n=re.g,i=re.b;return t!==fe?`color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(e*255)},${Math.round(n*255)},${Math.round(i*255)})`}offsetHSL(t,e,n){return this.getHSL(Wl),this.setHSL(Wl.h+t,Wl.s+e,Wl.l+n)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Wl),t.getHSL($n);const n=Xn(Wl.h,$n.h,e),i=Xn(Wl.s,$n.s,e),s=Xn(Wl.l,$n.l,e);return this.setHSL(n,i,s),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,n=this.g,i=this.b,s=t.elements;return this.r=s[0]*e+s[3]*n+s[6]*i,this.g=s[1]*e+s[4]*n+s[7]*i,this.b=s[2]*e+s[5]*n+s[8]*i,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const re=new Kt;Kt.NAMES=Es;let Fo=0;class xn extends Ql{static get type(){return"Material"}get type(){return this.constructor.type}set type(t){}constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Fo++}),this.uuid=Pl(),this.name="",this.blending=Ee,this.side=ol,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=Si,this.blendDst=Ii,this.blendEquation=Rl,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Kt(0,0,0),this.blendAlpha=0,this.depthFunc=kl,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Vs,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Al,this.stencilZFail=Al,this.stencilZPass=Al,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const n=t[e];if(n===void 0){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const i=this[e];if(i===void 0){console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const n={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(n.dispersion=this.dispersion),this.iridescence!==void 0&&(n.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(n.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.anisotropy!==void 0&&(n.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(n.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(n.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapRotation!==void 0&&(n.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Ee&&(n.blending=this.blending),this.side!==ol&&(n.side=this.side),this.vertexColors===!0&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=!0),this.blendSrc!==Si&&(n.blendSrc=this.blendSrc),this.blendDst!==Ii&&(n.blendDst=this.blendDst),this.blendEquation!==Rl&&(n.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(n.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(n.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(n.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(n.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(n.blendAlpha=this.blendAlpha),this.depthFunc!==kl&&(n.depthFunc=this.depthFunc),this.depthTest===!1&&(n.depthTest=this.depthTest),this.depthWrite===!1&&(n.depthWrite=this.depthWrite),this.colorWrite===!1&&(n.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(n.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==Vs&&(n.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(n.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(n.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Al&&(n.stencilFail=this.stencilFail),this.stencilZFail!==Al&&(n.stencilZFail=this.stencilZFail),this.stencilZPass!==Al&&(n.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(n.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaHash===!0&&(n.alphaHash=!0),this.alphaToCoverage===!0&&(n.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=!0),this.forceSinglePass===!0&&(n.forceSinglePass=!0),this.wireframe===!0&&(n.wireframe=!0),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=!0),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData);function i(s){const a=[];for(const d in s){const c=s[d];delete c.metadata,a.push(c)}return a}if(e){const s=i(t.textures),a=i(t.images);s.length>0&&(n.textures=s),a.length>0&&(n.images=a)}return n}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(e!==null){const i=e.length;n=new Array(i);for(let s=0;s!==i;++s)n[s]=e[s].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class Yn extends xn{static get type(){return"MeshBasicMaterial"}constructor(t){super(),this.isMeshBasicMaterial=!0,this.color=new Kt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new nl,this.combine=ds,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const de=new k,ti=new Lt;class Ce{constructor(t,e,n=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=n,this.usage=gs,this.updateRanges=[],this.gpuType=qe,this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,s=this.itemSize;i<s;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,n=this.count;e<n;e++)ti.fromBufferAttribute(this,e),ti.applyMatrix3(t),this.setXY(e,ti.x,ti.y);else if(this.itemSize===3)for(let e=0,n=this.count;e<n;e++)de.fromBufferAttribute(this,e),de.applyMatrix3(t),this.setXYZ(e,de.x,de.y,de.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)de.fromBufferAttribute(this,e),de.applyMatrix4(t),this.setXYZ(e,de.x,de.y,de.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)de.fromBufferAttribute(this,e),de.applyNormalMatrix(t),this.setXYZ(e,de.x,de.y,de.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)de.fromBufferAttribute(this,e),de.transformDirection(t),this.setXYZ(e,de.x,de.y,de.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let n=this.array[t*this.itemSize+e];return this.normalized&&(n=jl(n,this.array)),n}setComponent(t,e,n){return this.normalized&&(n=Ve(n,this.array)),this.array[t*this.itemSize+e]=n,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=jl(e,this.array)),e}setX(t,e){return this.normalized&&(e=Ve(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=jl(e,this.array)),e}setY(t,e){return this.normalized&&(e=Ve(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=jl(e,this.array)),e}setZ(t,e){return this.normalized&&(e=Ve(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=jl(e,this.array)),e}setW(t,e){return this.normalized&&(e=Ve(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.normalized&&(e=Ve(e,this.array),n=Ve(n,this.array)),this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.normalized&&(e=Ve(e,this.array),n=Ve(n,this.array),i=Ve(i,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,s){return t*=this.itemSize,this.normalized&&(e=Ve(e,this.array),n=Ve(n,this.array),i=Ve(i,this.array),s=Ve(s,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=s,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==gs&&(t.usage=this.usage),t}}class As extends Ce{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class Qs extends Ce{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class Yl extends Ce{constructor(t,e,n){super(new Float32Array(t),e,n)}}let Lo=0;const Fe=new ie,Ta=new ye,sn=new k,xe=new yn,Nn=new yn,me=new k;class Le extends Ql{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Lo++}),this.uuid=Pl(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Cs(t)?Qs:As)(t,1):this.index=t,this}setIndirect(t){return this.indirect=t,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const s=new xt().getNormalMatrix(t);n.applyNormalMatrix(s),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(t),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return Fe.makeRotationFromQuaternion(t),this.applyMatrix4(Fe),this}rotateX(t){return Fe.makeRotationX(t),this.applyMatrix4(Fe),this}rotateY(t){return Fe.makeRotationY(t),this.applyMatrix4(Fe),this}rotateZ(t){return Fe.makeRotationZ(t),this.applyMatrix4(Fe),this}translate(t,e,n){return Fe.makeTranslation(t,e,n),this.applyMatrix4(Fe),this}scale(t,e,n){return Fe.makeScale(t,e,n),this.applyMatrix4(Fe),this}lookAt(t){return Ta.lookAt(t),Ta.updateMatrix(),this.applyMatrix4(Ta.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(sn).negate(),this.translate(sn.x,sn.y,sn.z),this}setFromPoints(t){const e=this.getAttribute("position");if(e===void 0){const n=[];for(let i=0,s=t.length;i<s;i++){const a=t[i];n.push(a.x,a.y,a.z||0)}this.setAttribute("position",new Yl(n,3))}else{for(let n=0,i=e.count;n<i;n++){const s=t[n];e.setXYZ(n,s.x,s.y,s.z||0)}t.length>e.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),e.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new yn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new k(-1/0,-1/0,-1/0),new k(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,i=e.length;n<i;n++){const s=e[n];xe.setFromBufferAttribute(s),this.morphTargetsRelative?(me.addVectors(this.boundingBox.min,xe.min),this.boundingBox.expandByPoint(me),me.addVectors(this.boundingBox.max,xe.max),this.boundingBox.expandByPoint(me)):(this.boundingBox.expandByPoint(xe.min),this.boundingBox.expandByPoint(xe.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new jn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new k,1/0);return}if(t){const n=this.boundingSphere.center;if(xe.setFromBufferAttribute(t),e)for(let s=0,a=e.length;s<a;s++){const d=e[s];Nn.setFromBufferAttribute(d),this.morphTargetsRelative?(me.addVectors(xe.min,Nn.min),xe.expandByPoint(me),me.addVectors(xe.max,Nn.max),xe.expandByPoint(me)):(xe.expandByPoint(Nn.min),xe.expandByPoint(Nn.max))}xe.getCenter(n);let i=0;for(let s=0,a=t.count;s<a;s++)me.fromBufferAttribute(t,s),i=Math.max(i,n.distanceToSquared(me));if(e)for(let s=0,a=e.length;s<a;s++){const d=e[s],c=this.morphTargetsRelative;for(let o=0,m=d.count;o<m;o++)me.fromBufferAttribute(d,o),c&&(sn.fromBufferAttribute(t,o),me.add(sn)),i=Math.max(i,n.distanceToSquared(me))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=e.position,i=e.normal,s=e.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Ce(new Float32Array(4*n.count),4));const a=this.getAttribute("tangent"),d=[],c=[];for(let U=0;U<n.count;U++)d[U]=new k,c[U]=new k;const o=new k,m=new k,Z=new k,b=new Lt,h=new Lt,p=new Lt,W=new k,r=new k;function u(U,R,g){o.fromBufferAttribute(n,U),m.fromBufferAttribute(n,R),Z.fromBufferAttribute(n,g),b.fromBufferAttribute(s,U),h.fromBufferAttribute(s,R),p.fromBufferAttribute(s,g),m.sub(o),Z.sub(o),h.sub(b),p.sub(b);const Y=1/(h.x*p.y-p.x*h.y);isFinite(Y)&&(W.copy(m).multiplyScalar(p.y).addScaledVector(Z,-h.y).multiplyScalar(Y),r.copy(Z).multiplyScalar(h.x).addScaledVector(m,-p.x).multiplyScalar(Y),d[U].add(W),d[R].add(W),d[g].add(W),c[U].add(r),c[R].add(r),c[g].add(r))}let S=this.groups;S.length===0&&(S=[{start:0,count:t.count}]);for(let U=0,R=S.length;U<R;++U){const g=S[U],Y=g.start,Q=g.count;for(let w=Y,E=Y+Q;w<E;w+=3)u(t.getX(w+0),t.getX(w+1),t.getX(w+2))}const C=new k,X=new k,M=new k,I=new k;function x(U){M.fromBufferAttribute(i,U),I.copy(M);const R=d[U];C.copy(R),C.sub(M.multiplyScalar(M.dot(R))).normalize(),X.crossVectors(I,R);const Y=X.dot(c[U])<0?-1:1;a.setXYZW(U,C.x,C.y,C.z,Y)}for(let U=0,R=S.length;U<R;++U){const g=S[U],Y=g.start,Q=g.count;for(let w=Y,E=Y+Q;w<E;w+=3)x(t.getX(w+0)),x(t.getX(w+1)),x(t.getX(w+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new Ce(new Float32Array(e.count*3),3),this.setAttribute("normal",n);else for(let b=0,h=n.count;b<h;b++)n.setXYZ(b,0,0,0);const i=new k,s=new k,a=new k,d=new k,c=new k,o=new k,m=new k,Z=new k;if(t)for(let b=0,h=t.count;b<h;b+=3){const p=t.getX(b+0),W=t.getX(b+1),r=t.getX(b+2);i.fromBufferAttribute(e,p),s.fromBufferAttribute(e,W),a.fromBufferAttribute(e,r),m.subVectors(a,s),Z.subVectors(i,s),m.cross(Z),d.fromBufferAttribute(n,p),c.fromBufferAttribute(n,W),o.fromBufferAttribute(n,r),d.add(m),c.add(m),o.add(m),n.setXYZ(p,d.x,d.y,d.z),n.setXYZ(W,c.x,c.y,c.z),n.setXYZ(r,o.x,o.y,o.z)}else for(let b=0,h=e.count;b<h;b+=3)i.fromBufferAttribute(e,b+0),s.fromBufferAttribute(e,b+1),a.fromBufferAttribute(e,b+2),m.subVectors(a,s),Z.subVectors(i,s),m.cross(Z),n.setXYZ(b+0,m.x,m.y,m.z),n.setXYZ(b+1,m.x,m.y,m.z),n.setXYZ(b+2,m.x,m.y,m.z);this.normalizeNormals(),n.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)me.fromBufferAttribute(t,e),me.normalize(),t.setXYZ(e,me.x,me.y,me.z)}toNonIndexed(){function t(d,c){const o=d.array,m=d.itemSize,Z=d.normalized,b=new o.constructor(c.length*m);let h=0,p=0;for(let W=0,r=c.length;W<r;W++){d.isInterleavedBufferAttribute?h=c[W]*d.data.stride+d.offset:h=c[W]*m;for(let u=0;u<m;u++)b[p++]=o[h++]}return new Ce(b,m,Z)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Le,n=this.index.array,i=this.attributes;for(const d in i){const c=i[d],o=t(c,n);e.setAttribute(d,o)}const s=this.morphAttributes;for(const d in s){const c=[],o=s[d];for(let m=0,Z=o.length;m<Z;m++){const b=o[m],h=t(b,n);c.push(h)}e.morphAttributes[d]=c}e.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let d=0,c=a.length;d<c;d++){const o=a[d];e.addGroup(o.start,o.count,o.materialIndex)}return e}toJSON(){const t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const c=this.parameters;for(const o in c)c[o]!==void 0&&(t[o]=c[o]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const c in n){const o=n[c];t.data.attributes[c]=o.toJSON(t.data)}const i={};let s=!1;for(const c in this.morphAttributes){const o=this.morphAttributes[c],m=[];for(let Z=0,b=o.length;Z<b;Z++){const h=o[Z];m.push(h.toJSON(t.data))}m.length>0&&(i[c]=m,s=!0)}s&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(t.data.groups=JSON.parse(JSON.stringify(a)));const d=this.boundingSphere;return d!==null&&(t.data.boundingSphere={center:d.center.toArray(),radius:d.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;n!==null&&this.setIndex(n.clone(e));const i=t.attributes;for(const o in i){const m=i[o];this.setAttribute(o,m.clone(e))}const s=t.morphAttributes;for(const o in s){const m=[],Z=s[o];for(let b=0,h=Z.length;b<h;b++)m.push(Z[b].clone(e));this.morphAttributes[o]=m}this.morphTargetsRelative=t.morphTargetsRelative;const a=t.groups;for(let o=0,m=a.length;o<m;o++){const Z=a[o];this.addGroup(Z.start,Z.count,Z.materialIndex)}const d=t.boundingBox;d!==null&&(this.boundingBox=d.clone());const c=t.boundingSphere;return c!==null&&(this.boundingSphere=c.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const Ps=new ie,Nl=new Ms,ei=new jn,js=new k,li=new k,ni=new k,ii=new k,Ja=new k,ai=new k,Ds=new k,si=new k;class ae extends ye{constructor(t=new Le,e=new Yn){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const d=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[d]=s}}}}getVertexPosition(t,e){const n=this.geometry,i=n.attributes.position,s=n.morphAttributes.position,a=n.morphTargetsRelative;e.fromBufferAttribute(i,t);const d=this.morphTargetInfluences;if(s&&d){ai.set(0,0,0);for(let c=0,o=s.length;c<o;c++){const m=d[c],Z=s[c];m!==0&&(Ja.fromBufferAttribute(Z,t),a?ai.addScaledVector(Ja,m):ai.addScaledVector(Ja.sub(e),m))}e.add(ai)}return e}raycast(t,e){const n=this.geometry,i=this.material,s=this.matrixWorld;i!==void 0&&(n.boundingSphere===null&&n.computeBoundingSphere(),ei.copy(n.boundingSphere),ei.applyMatrix4(s),Nl.copy(t.ray).recast(t.near),!(ei.containsPoint(Nl.origin)===!1&&(Nl.intersectSphere(ei,js)===null||Nl.origin.distanceToSquared(js)>(t.far-t.near)**2))&&(Ps.copy(s).invert(),Nl.copy(t.ray).applyMatrix4(Ps),!(n.boundingBox!==null&&Nl.intersectsBox(n.boundingBox)===!1)&&this._computeIntersections(t,e,Nl)))}_computeIntersections(t,e,n){let i;const s=this.geometry,a=this.material,d=s.index,c=s.attributes.position,o=s.attributes.uv,m=s.attributes.uv1,Z=s.attributes.normal,b=s.groups,h=s.drawRange;if(d!==null)if(Array.isArray(a))for(let p=0,W=b.length;p<W;p++){const r=b[p],u=a[r.materialIndex],S=Math.max(r.start,h.start),C=Math.min(d.count,Math.min(r.start+r.count,h.start+h.count));for(let X=S,M=C;X<M;X+=3){const I=d.getX(X),x=d.getX(X+1),U=d.getX(X+2);i=di(this,u,t,n,o,m,Z,I,x,U),i&&(i.faceIndex=Math.floor(X/3),i.face.materialIndex=r.materialIndex,e.push(i))}}else{const p=Math.max(0,h.start),W=Math.min(d.count,h.start+h.count);for(let r=p,u=W;r<u;r+=3){const S=d.getX(r),C=d.getX(r+1),X=d.getX(r+2);i=di(this,a,t,n,o,m,Z,S,C,X),i&&(i.faceIndex=Math.floor(r/3),e.push(i))}}else if(c!==void 0)if(Array.isArray(a))for(let p=0,W=b.length;p<W;p++){const r=b[p],u=a[r.materialIndex],S=Math.max(r.start,h.start),C=Math.min(c.count,Math.min(r.start+r.count,h.start+h.count));for(let X=S,M=C;X<M;X+=3){const I=X,x=X+1,U=X+2;i=di(this,u,t,n,o,m,Z,I,x,U),i&&(i.faceIndex=Math.floor(X/3),i.face.materialIndex=r.materialIndex,e.push(i))}}else{const p=Math.max(0,h.start),W=Math.min(c.count,h.start+h.count);for(let r=p,u=W;r<u;r+=3){const S=r,C=r+1,X=r+2;i=di(this,a,t,n,o,m,Z,S,C,X),i&&(i.faceIndex=Math.floor(r/3),e.push(i))}}}}function Uo(l,t,e,n,i,s,a,d){let c;if(t.side===Re?c=n.intersectTriangle(a,s,i,!0,d):c=n.intersectTriangle(i,s,a,t.side===ol,d),c===null)return null;si.copy(d),si.applyMatrix4(l.matrixWorld);const o=e.ray.origin.distanceTo(si);return o<e.near||o>e.far?null:{distance:o,point:si.clone(),object:l}}function di(l,t,e,n,i,s,a,d,c,o){l.getVertexPosition(d,li),l.getVertexPosition(c,ni),l.getVertexPosition(o,ii);const m=Uo(l,t,e,n,li,ni,ii,Ds);if(m){const Z=new k;we.getBarycoord(Ds,li,ni,ii,Z),i&&(m.uv=we.getInterpolatedAttribute(i,d,c,o,Z,new Lt)),s&&(m.uv1=we.getInterpolatedAttribute(s,d,c,o,Z,new Lt)),a&&(m.normal=we.getInterpolatedAttribute(a,d,c,o,Z,new k),m.normal.dot(n.direction)>0&&m.normal.multiplyScalar(-1));const b={a:d,b:c,c:o,normal:new k,materialIndex:0};we.getNormal(li,ni,ii,b.normal),m.face=b,m.barycoord=Z}return m}class fn extends Le{constructor(t=1,e=1,n=1,i=1,s=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:s,depthSegments:a};const d=this;i=Math.floor(i),s=Math.floor(s),a=Math.floor(a);const c=[],o=[],m=[],Z=[];let b=0,h=0;p("z","y","x",-1,-1,n,e,t,a,s,0),p("z","y","x",1,-1,n,e,-t,a,s,1),p("x","z","y",1,1,t,n,e,i,a,2),p("x","z","y",1,-1,t,n,-e,i,a,3),p("x","y","z",1,-1,t,e,n,i,s,4),p("x","y","z",-1,-1,t,e,-n,i,s,5),this.setIndex(c),this.setAttribute("position",new Yl(o,3)),this.setAttribute("normal",new Yl(m,3)),this.setAttribute("uv",new Yl(Z,2));function p(W,r,u,S,C,X,M,I,x,U,R){const g=X/x,Y=M/U,Q=X/2,w=M/2,E=I/2,_=x+1,K=U+1;let $=0,z=0;const nt=new k;for(let ot=0;ot<K;ot++){const Vt=ot*Y-w;for(let Ut=0;Ut<_;Ut++){const Pt=Ut*g-Q;nt[W]=Pt*S,nt[r]=Vt*C,nt[u]=E,o.push(nt.x,nt.y,nt.z),nt[W]=0,nt[r]=0,nt[u]=I>0?1:-1,m.push(nt.x,nt.y,nt.z),Z.push(Ut/x),Z.push(1-ot/U),$+=1}}for(let ot=0;ot<U;ot++)for(let Vt=0;Vt<x;Vt++){const Ut=b+Vt+_*ot,Pt=b+Vt+_*(ot+1),A=b+(Vt+1)+_*(ot+1),tt=b+(Vt+1)+_*ot;c.push(Ut,Pt,tt),c.push(Pt,A,tt),z+=6}d.addGroup(h,z,R),h+=z,b+=$}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new fn(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function dn(l){const t={};for(const e in l){t[e]={};for(const n in l[e]){const i=l[e][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),t[e][n]=null):t[e][n]=i.clone():Array.isArray(i)?t[e][n]=i.slice():t[e][n]=i}}return t}function ge(l){const t={};for(let e=0;e<l.length;e++){const n=dn(l[e]);for(const i in n)t[i]=n[i]}return t}function Mo(l){const t=[];for(let e=0;e<l.length;e++)t.push(l[e].clone());return t}function _s(l){const t=l.getRenderTarget();return t===null?l.outputColorSpace:t.isXRRenderTarget===!0?t.texture.colorSpace:kt.workingColorSpace}const To={clone:dn,merge:ge};var Jo=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,vo=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class he extends xn{static get type(){return"ShaderMaterial"}constructor(t){super(),this.isShaderMaterial=!0,this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=Jo,this.fragmentShader=vo,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=dn(t.uniforms),this.uniformsGroups=Mo(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const a=this.uniforms[i].value;a&&a.isTexture?e.uniforms[i]={type:"t",value:a.toJSON(t).uuid}:a&&a.isColor?e.uniforms[i]={type:"c",value:a.getHex()}:a&&a.isVector2?e.uniforms[i]={type:"v2",value:a.toArray()}:a&&a.isVector3?e.uniforms[i]={type:"v3",value:a.toArray()}:a&&a.isVector4?e.uniforms[i]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?e.uniforms[i]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?e.uniforms[i]={type:"m4",value:a.toArray()}:e.uniforms[i]={value:a}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}class Os extends ye{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new ie,this.projectionMatrix=new ie,this.projectionMatrixInverse=new ie,this.coordinateSystem=$e}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const Vl=new k,qs=new Lt,$s=new Lt;class He extends Os{constructor(t=50,e=1,n=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=Vn*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(Wn*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return Vn*2*Math.atan(Math.tan(Wn*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,e,n){Vl.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(Vl.x,Vl.y).multiplyScalar(-t/Vl.z),Vl.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),n.set(Vl.x,Vl.y).multiplyScalar(-t/Vl.z)}getViewSize(t,e){return this.getViewBounds(t,qs,$s),e.subVectors($s,qs)}setViewOffset(t,e,n,i,s,a){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(Wn*.5*this.fov)/this.zoom,n=2*e,i=this.aspect*n,s=-.5*i;const a=this.view;if(this.view!==null&&this.view.enabled){const c=a.fullWidth,o=a.fullHeight;s+=a.offsetX*i/c,e-=a.offsetY*n/o,i*=a.width/c,n*=a.height/o}const d=this.filmOffset;d!==0&&(s+=t*d/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+i,e,e-n,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const cn=-90,on=1;class ko extends ye{constructor(t,e,n){super(),this.type="CubeCamera",this.renderTarget=n,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new He(cn,on,t,e);i.layers=this.layers,this.add(i);const s=new He(cn,on,t,e);s.layers=this.layers,this.add(s);const a=new He(cn,on,t,e);a.layers=this.layers,this.add(a);const d=new He(cn,on,t,e);d.layers=this.layers,this.add(d);const c=new He(cn,on,t,e);c.layers=this.layers,this.add(c);const o=new He(cn,on,t,e);o.layers=this.layers,this.add(o)}updateCoordinateSystem(){const t=this.coordinateSystem,e=this.children.concat(),[n,i,s,a,d,c]=e;for(const o of e)this.remove(o);if(t===$e)n.up.set(0,1,0),n.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),a.up.set(0,0,1),a.lookAt(0,-1,0),d.up.set(0,1,0),d.lookAt(0,0,1),c.up.set(0,1,0),c.lookAt(0,0,-1);else if(t===Bn)n.up.set(0,-1,0),n.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),a.up.set(0,0,-1),a.lookAt(0,-1,0),d.up.set(0,-1,0),d.lookAt(0,0,1),c.up.set(0,-1,0),c.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+t);for(const o of e)this.add(o),o.updateMatrixWorld()}update(t,e){this.parent===null&&this.updateMatrixWorld();const{renderTarget:n,activeMipmapLevel:i}=this;this.coordinateSystem!==t.coordinateSystem&&(this.coordinateSystem=t.coordinateSystem,this.updateCoordinateSystem());const[s,a,d,c,o,m]=this.children,Z=t.getRenderTarget(),b=t.getActiveCubeFace(),h=t.getActiveMipmapLevel(),p=t.xr.enabled;t.xr.enabled=!1;const W=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0,i),t.render(e,s),t.setRenderTarget(n,1,i),t.render(e,a),t.setRenderTarget(n,2,i),t.render(e,d),t.setRenderTarget(n,3,i),t.render(e,c),t.setRenderTarget(n,4,i),t.render(e,o),n.texture.generateMipmaps=W,t.setRenderTarget(n,5,i),t.render(e,m),t.setRenderTarget(Z,b,h),t.xr.enabled=p,n.texture.needsPMREMUpdate=!0}}class td extends Xe{constructor(t,e,n,i,s,a,d,c,o,m){t=t!==void 0?t:[],e=e!==void 0?e:wl,super(t,e,n,i,s,a,d,c,o,m),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class wo extends bl{constructor(t=1,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const n={width:t,height:t,depth:1},i=[n,n,n,n,n,n];this.texture=new td(i,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:be}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new fn(5,5,5),s=new he({name:"CubemapFromEquirect",uniforms:dn(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:Re,blending:ml});s.uniforms.tEquirect.value=e;const a=new ae(i,s),d=e.minFilter;return e.minFilter===Cl&&(e.minFilter=be),new ko(1,10,this).update(t,a),e.minFilter=d,a.geometry.dispose(),a.material.dispose(),this}clear(t,e,n,i){const s=t.getRenderTarget();for(let a=0;a<6;a++)t.setRenderTarget(this,a),t.clear(e,n,i);t.setRenderTarget(s)}}const va=new k,Ho=new k,zo=new xt;class fl{constructor(t=new k(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=va.subVectors(n,e).cross(Ho.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const n=t.delta(va),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const s=-(t.start.dot(this.normal)+this.constant)/i;return s<0||s>1?null:e.copy(t.start).addScaledVector(n,s)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||zo.getNormalMatrix(t),i=this.coplanarPoint(va).applyMatrix4(t),s=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Fl=new jn,ci=new k;class ed{constructor(t=new fl,e=new fl,n=new fl,i=new fl,s=new fl,a=new fl){this.planes=[t,e,n,i,s,a]}set(t,e,n,i,s,a){const d=this.planes;return d[0].copy(t),d[1].copy(e),d[2].copy(n),d[3].copy(i),d[4].copy(s),d[5].copy(a),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t,e=$e){const n=this.planes,i=t.elements,s=i[0],a=i[1],d=i[2],c=i[3],o=i[4],m=i[5],Z=i[6],b=i[7],h=i[8],p=i[9],W=i[10],r=i[11],u=i[12],S=i[13],C=i[14],X=i[15];if(n[0].setComponents(c-s,b-o,r-h,X-u).normalize(),n[1].setComponents(c+s,b+o,r+h,X+u).normalize(),n[2].setComponents(c+a,b+m,r+p,X+S).normalize(),n[3].setComponents(c-a,b-m,r-p,X-S).normalize(),n[4].setComponents(c-d,b-Z,r-W,X-C).normalize(),e===$e)n[5].setComponents(c+d,b+Z,r+W,X+C).normalize();else if(e===Bn)n[5].setComponents(d,Z,W,C).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);return this}intersectsObject(t){if(t.boundingSphere!==void 0)t.boundingSphere===null&&t.computeBoundingSphere(),Fl.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;e.boundingSphere===null&&e.computeBoundingSphere(),Fl.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(Fl)}intersectsSprite(t){return Fl.center.set(0,0,0),Fl.radius=.7071067811865476,Fl.applyMatrix4(t.matrixWorld),this.intersectsSphere(Fl)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let s=0;s<6;s++)if(e[s].distanceToPoint(n)<i)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(ci.x=i.normal.x>0?t.max.x:t.min.x,ci.y=i.normal.y>0?t.max.y:t.min.y,ci.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(ci)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function ld(){let l=null,t=!1,e=null,n=null;function i(s,a){e(s,a),n=l.requestAnimationFrame(i)}return{start:function(){t!==!0&&e!==null&&(n=l.requestAnimationFrame(i),t=!0)},stop:function(){l.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(s){e=s},setContext:function(s){l=s}}}function Ko(l){const t=new WeakMap;function e(d,c){const o=d.array,m=d.usage,Z=o.byteLength,b=l.createBuffer();l.bindBuffer(c,b),l.bufferData(c,o,m),d.onUploadCallback();let h;if(o instanceof Float32Array)h=l.FLOAT;else if(o instanceof Uint16Array)d.isFloat16BufferAttribute?h=l.HALF_FLOAT:h=l.UNSIGNED_SHORT;else if(o instanceof Int16Array)h=l.SHORT;else if(o instanceof Uint32Array)h=l.UNSIGNED_INT;else if(o instanceof Int32Array)h=l.INT;else if(o instanceof Int8Array)h=l.BYTE;else if(o instanceof Uint8Array)h=l.UNSIGNED_BYTE;else if(o instanceof Uint8ClampedArray)h=l.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+o);return{buffer:b,type:h,bytesPerElement:o.BYTES_PER_ELEMENT,version:d.version,size:Z}}function n(d,c,o){const m=c.array,Z=c.updateRanges;if(l.bindBuffer(o,d),Z.length===0)l.bufferSubData(o,0,m);else{Z.sort((h,p)=>h.start-p.start);let b=0;for(let h=1;h<Z.length;h++){const p=Z[b],W=Z[h];W.start<=p.start+p.count+1?p.count=Math.max(p.count,W.start+W.count-p.start):(++b,Z[b]=W)}Z.length=b+1;for(let h=0,p=Z.length;h<p;h++){const W=Z[h];l.bufferSubData(o,W.start*m.BYTES_PER_ELEMENT,m,W.start,W.count)}c.clearUpdateRanges()}c.onUploadCallback()}function i(d){return d.isInterleavedBufferAttribute&&(d=d.data),t.get(d)}function s(d){d.isInterleavedBufferAttribute&&(d=d.data);const c=t.get(d);c&&(l.deleteBuffer(c.buffer),t.delete(d))}function a(d,c){if(d.isInterleavedBufferAttribute&&(d=d.data),d.isGLBufferAttribute){const m=t.get(d);(!m||m.version<d.version)&&t.set(d,{buffer:d.buffer,type:d.type,bytesPerElement:d.elementSize,version:d.version});return}const o=t.get(d);if(o===void 0)t.set(d,e(d,c));else if(o.version<d.version){if(o.size!==d.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");n(o.buffer,d,c),o.version=d.version}}return{get:i,remove:s,update:a}}class ee extends Le{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const s=t/2,a=e/2,d=Math.floor(n),c=Math.floor(i),o=d+1,m=c+1,Z=t/d,b=e/c,h=[],p=[],W=[],r=[];for(let u=0;u<m;u++){const S=u*b-a;for(let C=0;C<o;C++){const X=C*Z-s;p.push(X,-S,0),W.push(0,0,1),r.push(C/d),r.push(1-u/c)}}for(let u=0;u<c;u++)for(let S=0;S<d;S++){const C=S+o*u,X=S+o*(u+1),M=S+1+o*(u+1),I=S+1+o*u;h.push(C,X,I),h.push(X,M,I)}this.setIndex(h),this.setAttribute("position",new Yl(p,3)),this.setAttribute("normal",new Yl(W,3)),this.setAttribute("uv",new Yl(r,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new ee(t.width,t.height,t.widthSegments,t.heightSegments)}}var Bo=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,Eo=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,Ao=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,Qo=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Po=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,jo=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,Do=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,_o=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,Oo=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,qo=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,$o=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,tm=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,em=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,lm=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,nm=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,im=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,am=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,sm=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,dm=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,cm=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,om=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,mm=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,Zm=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,hm=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,bm=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,um=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,rm=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,pm=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,Gm=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Wm=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Vm="gl_FragColor = linearToOutputTexel( gl_FragColor );",Xm=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,gm=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Rm=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,ym=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Cm=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,Sm=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Im=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,xm=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Ym=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Nm=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,fm=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,Fm=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Lm=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,Um=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,Mm=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,Tm=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,Jm=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,vm=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,km=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,wm=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,Hm=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,zm=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,Km=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,Bm=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,Em=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,Am=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,Qm=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,Pm=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,jm=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,Dm=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,_m=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,Om=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,qm=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,$m=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,tZ=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,eZ=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,lZ=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,nZ=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,iZ=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,aZ=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,sZ=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,dZ=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,cZ=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,oZ=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,mZ=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,ZZ=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,hZ=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,bZ=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,uZ=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,rZ=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,pZ=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,GZ=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,WZ=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,VZ=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,XZ=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,gZ=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,RZ=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,yZ=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,CZ=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,SZ=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,IZ=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,xZ=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,YZ=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,NZ=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,fZ=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,FZ=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,LZ=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,UZ=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,MZ=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,TZ=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,JZ=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,vZ=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,kZ=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,wZ=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,HZ=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,zZ=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const ft={alphahash_fragment:Bo,alphahash_pars_fragment:Eo,alphamap_fragment:Ao,alphamap_pars_fragment:Qo,alphatest_fragment:Po,alphatest_pars_fragment:jo,aomap_fragment:Do,aomap_pars_fragment:_o,batching_pars_vertex:Oo,batching_vertex:qo,begin_vertex:$o,beginnormal_vertex:tm,bsdfs:em,iridescence_fragment:lm,bumpmap_pars_fragment:nm,clipping_planes_fragment:im,clipping_planes_pars_fragment:am,clipping_planes_pars_vertex:sm,clipping_planes_vertex:dm,color_fragment:cm,color_pars_fragment:om,color_pars_vertex:mm,color_vertex:Zm,common:hm,cube_uv_reflection_fragment:bm,defaultnormal_vertex:um,displacementmap_pars_vertex:rm,displacementmap_vertex:pm,emissivemap_fragment:Gm,emissivemap_pars_fragment:Wm,colorspace_fragment:Vm,colorspace_pars_fragment:Xm,envmap_fragment:gm,envmap_common_pars_fragment:Rm,envmap_pars_fragment:ym,envmap_pars_vertex:Cm,envmap_physical_pars_fragment:Tm,envmap_vertex:Sm,fog_vertex:Im,fog_pars_vertex:xm,fog_fragment:Ym,fog_pars_fragment:Nm,gradientmap_pars_fragment:fm,lightmap_pars_fragment:Fm,lights_lambert_fragment:Lm,lights_lambert_pars_fragment:Um,lights_pars_begin:Mm,lights_toon_fragment:Jm,lights_toon_pars_fragment:vm,lights_phong_fragment:km,lights_phong_pars_fragment:wm,lights_physical_fragment:Hm,lights_physical_pars_fragment:zm,lights_fragment_begin:Km,lights_fragment_maps:Bm,lights_fragment_end:Em,logdepthbuf_fragment:Am,logdepthbuf_pars_fragment:Qm,logdepthbuf_pars_vertex:Pm,logdepthbuf_vertex:jm,map_fragment:Dm,map_pars_fragment:_m,map_particle_fragment:Om,map_particle_pars_fragment:qm,metalnessmap_fragment:$m,metalnessmap_pars_fragment:tZ,morphinstance_vertex:eZ,morphcolor_vertex:lZ,morphnormal_vertex:nZ,morphtarget_pars_vertex:iZ,morphtarget_vertex:aZ,normal_fragment_begin:sZ,normal_fragment_maps:dZ,normal_pars_fragment:cZ,normal_pars_vertex:oZ,normal_vertex:mZ,normalmap_pars_fragment:ZZ,clearcoat_normal_fragment_begin:hZ,clearcoat_normal_fragment_maps:bZ,clearcoat_pars_fragment:uZ,iridescence_pars_fragment:rZ,opaque_fragment:pZ,packing:GZ,premultiplied_alpha_fragment:WZ,project_vertex:VZ,dithering_fragment:XZ,dithering_pars_fragment:gZ,roughnessmap_fragment:RZ,roughnessmap_pars_fragment:yZ,shadowmap_pars_fragment:CZ,shadowmap_pars_vertex:SZ,shadowmap_vertex:IZ,shadowmask_pars_fragment:xZ,skinbase_vertex:YZ,skinning_pars_vertex:NZ,skinning_vertex:fZ,skinnormal_vertex:FZ,specularmap_fragment:LZ,specularmap_pars_fragment:UZ,tonemapping_fragment:MZ,tonemapping_pars_fragment:TZ,transmission_fragment:JZ,transmission_pars_fragment:vZ,uv_pars_fragment:kZ,uv_pars_vertex:wZ,uv_vertex:HZ,worldpos_vertex:zZ,background_vert:`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,background_frag:`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,backgroundCube_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,backgroundCube_frag:`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,cube_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,cube_frag:`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,depth_vert:`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,depth_frag:`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,distanceRGBA_vert:`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,distanceRGBA_frag:`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,equirect_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,equirect_frag:`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,linedashed_vert:`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,linedashed_frag:`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,meshbasic_vert:`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,meshbasic_frag:`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshlambert_vert:`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshlambert_frag:`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshmatcap_vert:`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,meshmatcap_frag:`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshnormal_vert:`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,meshnormal_frag:`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,meshphong_vert:`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshphong_frag:`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphysical_vert:`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,meshphysical_frag:`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshtoon_vert:`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshtoon_frag:`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,points_vert:`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,points_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,shadow_vert:`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,shadow_frag:`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,sprite_vert:`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,sprite_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`},et={common:{diffuse:{value:new Kt(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new xt},alphaMap:{value:null},alphaMapTransform:{value:new xt},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new xt}},envmap:{envMap:{value:null},envMapRotation:{value:new xt},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new xt}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new xt}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new xt},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new xt},normalScale:{value:new Lt(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new xt},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new xt}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new xt}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new xt}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Kt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Kt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new xt},alphaTest:{value:0},uvTransform:{value:new xt}},sprite:{diffuse:{value:new Kt(16777215)},opacity:{value:1},center:{value:new Lt(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new xt},alphaMap:{value:null},alphaMapTransform:{value:new xt},alphaTest:{value:0}}},Pe={basic:{uniforms:ge([et.common,et.specularmap,et.envmap,et.aomap,et.lightmap,et.fog]),vertexShader:ft.meshbasic_vert,fragmentShader:ft.meshbasic_frag},lambert:{uniforms:ge([et.common,et.specularmap,et.envmap,et.aomap,et.lightmap,et.emissivemap,et.bumpmap,et.normalmap,et.displacementmap,et.fog,et.lights,{emissive:{value:new Kt(0)}}]),vertexShader:ft.meshlambert_vert,fragmentShader:ft.meshlambert_frag},phong:{uniforms:ge([et.common,et.specularmap,et.envmap,et.aomap,et.lightmap,et.emissivemap,et.bumpmap,et.normalmap,et.displacementmap,et.fog,et.lights,{emissive:{value:new Kt(0)},specular:{value:new Kt(1118481)},shininess:{value:30}}]),vertexShader:ft.meshphong_vert,fragmentShader:ft.meshphong_frag},standard:{uniforms:ge([et.common,et.envmap,et.aomap,et.lightmap,et.emissivemap,et.bumpmap,et.normalmap,et.displacementmap,et.roughnessmap,et.metalnessmap,et.fog,et.lights,{emissive:{value:new Kt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ft.meshphysical_vert,fragmentShader:ft.meshphysical_frag},toon:{uniforms:ge([et.common,et.aomap,et.lightmap,et.emissivemap,et.bumpmap,et.normalmap,et.displacementmap,et.gradientmap,et.fog,et.lights,{emissive:{value:new Kt(0)}}]),vertexShader:ft.meshtoon_vert,fragmentShader:ft.meshtoon_frag},matcap:{uniforms:ge([et.common,et.bumpmap,et.normalmap,et.displacementmap,et.fog,{matcap:{value:null}}]),vertexShader:ft.meshmatcap_vert,fragmentShader:ft.meshmatcap_frag},points:{uniforms:ge([et.points,et.fog]),vertexShader:ft.points_vert,fragmentShader:ft.points_frag},dashed:{uniforms:ge([et.common,et.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ft.linedashed_vert,fragmentShader:ft.linedashed_frag},depth:{uniforms:ge([et.common,et.displacementmap]),vertexShader:ft.depth_vert,fragmentShader:ft.depth_frag},normal:{uniforms:ge([et.common,et.bumpmap,et.normalmap,et.displacementmap,{opacity:{value:1}}]),vertexShader:ft.meshnormal_vert,fragmentShader:ft.meshnormal_frag},sprite:{uniforms:ge([et.sprite,et.fog]),vertexShader:ft.sprite_vert,fragmentShader:ft.sprite_frag},background:{uniforms:{uvTransform:{value:new xt},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:ft.background_vert,fragmentShader:ft.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new xt}},vertexShader:ft.backgroundCube_vert,fragmentShader:ft.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:ft.cube_vert,fragmentShader:ft.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ft.equirect_vert,fragmentShader:ft.equirect_frag},distanceRGBA:{uniforms:ge([et.common,et.displacementmap,{referencePosition:{value:new k},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ft.distanceRGBA_vert,fragmentShader:ft.distanceRGBA_frag},shadow:{uniforms:ge([et.lights,et.fog,{color:{value:new Kt(0)},opacity:{value:1}}]),vertexShader:ft.shadow_vert,fragmentShader:ft.shadow_frag}};Pe.physical={uniforms:ge([Pe.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new xt},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new xt},clearcoatNormalScale:{value:new Lt(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new xt},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new xt},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new xt},sheen:{value:0},sheenColor:{value:new Kt(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new xt},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new xt},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new xt},transmissionSamplerSize:{value:new Lt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new xt},attenuationDistance:{value:0},attenuationColor:{value:new Kt(0)},specularColor:{value:new Kt(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new xt},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new xt},anisotropyVector:{value:new Lt},anisotropyMap:{value:null},anisotropyMapTransform:{value:new xt}}]),vertexShader:ft.meshphysical_vert,fragmentShader:ft.meshphysical_frag};const oi={r:0,b:0,g:0},Ll=new nl,KZ=new ie;function BZ(l,t,e,n,i,s,a){const d=new Kt(0);let c=s===!0?0:1,o,m,Z=null,b=0,h=null;function p(S){let C=S.isScene===!0?S.background:null;return C&&C.isTexture&&(C=(S.backgroundBlurriness>0?e:t).get(C)),C}function W(S){let C=!1;const X=p(S);X===null?u(d,c):X&&X.isColor&&(u(X,1),C=!0);const M=l.xr.getEnvironmentBlendMode();M==="additive"?n.buffers.color.setClear(0,0,0,1,a):M==="alpha-blend"&&n.buffers.color.setClear(0,0,0,0,a),(l.autoClear||C)&&(n.buffers.depth.setTest(!0),n.buffers.depth.setMask(!0),n.buffers.color.setMask(!0),l.clear(l.autoClearColor,l.autoClearDepth,l.autoClearStencil))}function r(S,C){const X=p(C);X&&(X.isCubeTexture||X.mapping===Tn)?(m===void 0&&(m=new ae(new fn(1,1,1),new he({name:"BackgroundCubeMaterial",uniforms:dn(Pe.backgroundCube.uniforms),vertexShader:Pe.backgroundCube.vertexShader,fragmentShader:Pe.backgroundCube.fragmentShader,side:Re,depthTest:!1,depthWrite:!1,fog:!1})),m.geometry.deleteAttribute("normal"),m.geometry.deleteAttribute("uv"),m.onBeforeRender=function(M,I,x){this.matrixWorld.copyPosition(x.matrixWorld)},Object.defineProperty(m.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(m)),Ll.copy(C.backgroundRotation),Ll.x*=-1,Ll.y*=-1,Ll.z*=-1,X.isCubeTexture&&X.isRenderTargetTexture===!1&&(Ll.y*=-1,Ll.z*=-1),m.material.uniforms.envMap.value=X,m.material.uniforms.flipEnvMap.value=X.isCubeTexture&&X.isRenderTargetTexture===!1?-1:1,m.material.uniforms.backgroundBlurriness.value=C.backgroundBlurriness,m.material.uniforms.backgroundIntensity.value=C.backgroundIntensity,m.material.uniforms.backgroundRotation.value.setFromMatrix4(KZ.makeRotationFromEuler(Ll)),m.material.toneMapped=kt.getTransfer(X.colorSpace)!==Qt,(Z!==X||b!==X.version||h!==l.toneMapping)&&(m.material.needsUpdate=!0,Z=X,b=X.version,h=l.toneMapping),m.layers.enableAll(),S.unshift(m,m.geometry,m.material,0,0,null)):X&&X.isTexture&&(o===void 0&&(o=new ae(new ee(2,2),new he({name:"BackgroundMaterial",uniforms:dn(Pe.background.uniforms),vertexShader:Pe.background.vertexShader,fragmentShader:Pe.background.fragmentShader,side:ol,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(o)),o.material.uniforms.t2D.value=X,o.material.uniforms.backgroundIntensity.value=C.backgroundIntensity,o.material.toneMapped=kt.getTransfer(X.colorSpace)!==Qt,X.matrixAutoUpdate===!0&&X.updateMatrix(),o.material.uniforms.uvTransform.value.copy(X.matrix),(Z!==X||b!==X.version||h!==l.toneMapping)&&(o.material.needsUpdate=!0,Z=X,b=X.version,h=l.toneMapping),o.layers.enableAll(),S.unshift(o,o.geometry,o.material,0,0,null))}function u(S,C){S.getRGB(oi,_s(l)),n.buffers.color.setClear(oi.r,oi.g,oi.b,C,a)}return{getClearColor:function(){return d},setClearColor:function(S,C=1){d.set(S),c=C,u(d,c)},getClearAlpha:function(){return c},setClearAlpha:function(S){c=S,u(d,c)},render:W,addToRenderList:r}}function EZ(l,t){const e=l.getParameter(l.MAX_VERTEX_ATTRIBS),n={},i=b(null);let s=i,a=!1;function d(g,Y,Q,w,E){let _=!1;const K=Z(w,Q,Y);s!==K&&(s=K,o(s.object)),_=h(g,w,Q,E),_&&p(g,w,Q,E),E!==null&&t.update(E,l.ELEMENT_ARRAY_BUFFER),(_||a)&&(a=!1,X(g,Y,Q,w),E!==null&&l.bindBuffer(l.ELEMENT_ARRAY_BUFFER,t.get(E).buffer))}function c(){return l.createVertexArray()}function o(g){return l.bindVertexArray(g)}function m(g){return l.deleteVertexArray(g)}function Z(g,Y,Q){const w=Q.wireframe===!0;let E=n[g.id];E===void 0&&(E={},n[g.id]=E);let _=E[Y.id];_===void 0&&(_={},E[Y.id]=_);let K=_[w];return K===void 0&&(K=b(c()),_[w]=K),K}function b(g){const Y=[],Q=[],w=[];for(let E=0;E<e;E++)Y[E]=0,Q[E]=0,w[E]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:Y,enabledAttributes:Q,attributeDivisors:w,object:g,attributes:{},index:null}}function h(g,Y,Q,w){const E=s.attributes,_=Y.attributes;let K=0;const $=Q.getAttributes();for(const z in $)if($[z].location>=0){const ot=E[z];let Vt=_[z];if(Vt===void 0&&(z==="instanceMatrix"&&g.instanceMatrix&&(Vt=g.instanceMatrix),z==="instanceColor"&&g.instanceColor&&(Vt=g.instanceColor)),ot===void 0||ot.attribute!==Vt||Vt&&ot.data!==Vt.data)return!0;K++}return s.attributesNum!==K||s.index!==w}function p(g,Y,Q,w){const E={},_=Y.attributes;let K=0;const $=Q.getAttributes();for(const z in $)if($[z].location>=0){let ot=_[z];ot===void 0&&(z==="instanceMatrix"&&g.instanceMatrix&&(ot=g.instanceMatrix),z==="instanceColor"&&g.instanceColor&&(ot=g.instanceColor));const Vt={};Vt.attribute=ot,ot&&ot.data&&(Vt.data=ot.data),E[z]=Vt,K++}s.attributes=E,s.attributesNum=K,s.index=w}function W(){const g=s.newAttributes;for(let Y=0,Q=g.length;Y<Q;Y++)g[Y]=0}function r(g){u(g,0)}function u(g,Y){const Q=s.newAttributes,w=s.enabledAttributes,E=s.attributeDivisors;Q[g]=1,w[g]===0&&(l.enableVertexAttribArray(g),w[g]=1),E[g]!==Y&&(l.vertexAttribDivisor(g,Y),E[g]=Y)}function S(){const g=s.newAttributes,Y=s.enabledAttributes;for(let Q=0,w=Y.length;Q<w;Q++)Y[Q]!==g[Q]&&(l.disableVertexAttribArray(Q),Y[Q]=0)}function C(g,Y,Q,w,E,_,K){K===!0?l.vertexAttribIPointer(g,Y,Q,E,_):l.vertexAttribPointer(g,Y,Q,w,E,_)}function X(g,Y,Q,w){W();const E=w.attributes,_=Q.getAttributes(),K=Y.defaultAttributeValues;for(const $ in _){const z=_[$];if(z.location>=0){let nt=E[$];if(nt===void 0&&($==="instanceMatrix"&&g.instanceMatrix&&(nt=g.instanceMatrix),$==="instanceColor"&&g.instanceColor&&(nt=g.instanceColor)),nt!==void 0){const ot=nt.normalized,Vt=nt.itemSize,Ut=t.get(nt);if(Ut===void 0)continue;const Pt=Ut.buffer,A=Ut.type,tt=Ut.bytesPerElement,pt=A===l.INT||A===l.UNSIGNED_INT||nt.gpuType===wi;if(nt.isInterleavedBufferAttribute){const it=nt.data,yt=it.stride,It=nt.offset;if(it.isInstancedInterleavedBuffer){for(let Mt=0;Mt<z.locationSize;Mt++)u(z.location+Mt,it.meshPerAttribute);g.isInstancedMesh!==!0&&w._maxInstanceCount===void 0&&(w._maxInstanceCount=it.meshPerAttribute*it.count)}else for(let Mt=0;Mt<z.locationSize;Mt++)r(z.location+Mt);l.bindBuffer(l.ARRAY_BUFFER,Pt);for(let Mt=0;Mt<z.locationSize;Mt++)C(z.location+Mt,Vt/z.locationSize,A,ot,yt*tt,(It+Vt/z.locationSize*Mt)*tt,pt)}else{if(nt.isInstancedBufferAttribute){for(let it=0;it<z.locationSize;it++)u(z.location+it,nt.meshPerAttribute);g.isInstancedMesh!==!0&&w._maxInstanceCount===void 0&&(w._maxInstanceCount=nt.meshPerAttribute*nt.count)}else for(let it=0;it<z.locationSize;it++)r(z.location+it);l.bindBuffer(l.ARRAY_BUFFER,Pt);for(let it=0;it<z.locationSize;it++)C(z.location+it,Vt/z.locationSize,A,ot,Vt*tt,Vt/z.locationSize*it*tt,pt)}}else if(K!==void 0){const ot=K[$];if(ot!==void 0)switch(ot.length){case 2:l.vertexAttrib2fv(z.location,ot);break;case 3:l.vertexAttrib3fv(z.location,ot);break;case 4:l.vertexAttrib4fv(z.location,ot);break;default:l.vertexAttrib1fv(z.location,ot)}}}}S()}function M(){U();for(const g in n){const Y=n[g];for(const Q in Y){const w=Y[Q];for(const E in w)m(w[E].object),delete w[E];delete Y[Q]}delete n[g]}}function I(g){if(n[g.id]===void 0)return;const Y=n[g.id];for(const Q in Y){const w=Y[Q];for(const E in w)m(w[E].object),delete w[E];delete Y[Q]}delete n[g.id]}function x(g){for(const Y in n){const Q=n[Y];if(Q[g.id]===void 0)continue;const w=Q[g.id];for(const E in w)m(w[E].object),delete w[E];delete Q[g.id]}}function U(){R(),a=!0,s!==i&&(s=i,o(s.object))}function R(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:d,reset:U,resetDefaultState:R,dispose:M,releaseStatesOfGeometry:I,releaseStatesOfProgram:x,initAttributes:W,enableAttribute:r,disableUnusedAttributes:S}}function AZ(l,t,e){let n;function i(o){n=o}function s(o,m){l.drawArrays(n,o,m),e.update(m,n,1)}function a(o,m,Z){Z!==0&&(l.drawArraysInstanced(n,o,m,Z),e.update(m,n,Z))}function d(o,m,Z){if(Z===0)return;t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n,o,0,m,0,Z);let h=0;for(let p=0;p<Z;p++)h+=m[p];e.update(h,n,1)}function c(o,m,Z,b){if(Z===0)return;const h=t.get("WEBGL_multi_draw");if(h===null)for(let p=0;p<o.length;p++)a(o[p],m[p],b[p]);else{h.multiDrawArraysInstancedWEBGL(n,o,0,m,0,b,0,Z);let p=0;for(let W=0;W<Z;W++)p+=m[W]*b[W];e.update(p,n,1)}}this.setMode=i,this.render=s,this.renderInstances=a,this.renderMultiDraw=d,this.renderMultiDrawInstances=c}function QZ(l,t,e,n){let i;function s(){if(i!==void 0)return i;if(t.has("EXT_texture_filter_anisotropic")===!0){const x=t.get("EXT_texture_filter_anisotropic");i=l.getParameter(x.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function a(x){return!(x!==Ne&&n.convert(x)!==l.getParameter(l.IMPLEMENTATION_COLOR_READ_FORMAT))}function d(x){const U=x===Gn&&(t.has("EXT_color_buffer_half_float")||t.has("EXT_color_buffer_float"));return!(x!==Qe&&n.convert(x)!==l.getParameter(l.IMPLEMENTATION_COLOR_READ_TYPE)&&x!==qe&&!U)}function c(x){if(x==="highp"){if(l.getShaderPrecisionFormat(l.VERTEX_SHADER,l.HIGH_FLOAT).precision>0&&l.getShaderPrecisionFormat(l.FRAGMENT_SHADER,l.HIGH_FLOAT).precision>0)return"highp";x="mediump"}return x==="mediump"&&l.getShaderPrecisionFormat(l.VERTEX_SHADER,l.MEDIUM_FLOAT).precision>0&&l.getShaderPrecisionFormat(l.FRAGMENT_SHADER,l.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let o=e.precision!==void 0?e.precision:"highp";const m=c(o);m!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",m,"instead."),o=m);const Z=e.logarithmicDepthBuffer===!0,b=e.reverseDepthBuffer===!0&&t.has("EXT_clip_control"),h=l.getParameter(l.MAX_TEXTURE_IMAGE_UNITS),p=l.getParameter(l.MAX_VERTEX_TEXTURE_IMAGE_UNITS),W=l.getParameter(l.MAX_TEXTURE_SIZE),r=l.getParameter(l.MAX_CUBE_MAP_TEXTURE_SIZE),u=l.getParameter(l.MAX_VERTEX_ATTRIBS),S=l.getParameter(l.MAX_VERTEX_UNIFORM_VECTORS),C=l.getParameter(l.MAX_VARYING_VECTORS),X=l.getParameter(l.MAX_FRAGMENT_UNIFORM_VECTORS),M=p>0,I=l.getParameter(l.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:s,getMaxPrecision:c,textureFormatReadable:a,textureTypeReadable:d,precision:o,logarithmicDepthBuffer:Z,reverseDepthBuffer:b,maxTextures:h,maxVertexTextures:p,maxTextureSize:W,maxCubemapSize:r,maxAttributes:u,maxVertexUniforms:S,maxVaryings:C,maxFragmentUniforms:X,vertexTextures:M,maxSamples:I}}function PZ(l){const t=this;let e=null,n=0,i=!1,s=!1;const a=new fl,d=new xt,c={value:null,needsUpdate:!1};this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(Z,b){const h=Z.length!==0||b||n!==0||i;return i=b,n=Z.length,h},this.beginShadows=function(){s=!0,m(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(Z,b){e=m(Z,b,0)},this.setState=function(Z,b,h){const p=Z.clippingPlanes,W=Z.clipIntersection,r=Z.clipShadows,u=l.get(Z);if(!i||p===null||p.length===0||s&&!r)s?m(null):o();else{const S=s?0:n,C=S*4;let X=u.clippingState||null;c.value=X,X=m(p,b,C,h);for(let M=0;M!==C;++M)X[M]=e[M];u.clippingState=X,this.numIntersection=W?this.numPlanes:0,this.numPlanes+=S}};function o(){c.value!==e&&(c.value=e,c.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function m(Z,b,h,p){const W=Z!==null?Z.length:0;let r=null;if(W!==0){if(r=c.value,p!==!0||r===null){const u=h+W*4,S=b.matrixWorldInverse;d.getNormalMatrix(S),(r===null||r.length<u)&&(r=new Float32Array(u));for(let C=0,X=h;C!==W;++C,X+=4)a.copy(Z[C]).applyMatrix4(S,d),a.normal.toArray(r,X),r[X+3]=a.constant}c.value=r,c.needsUpdate=!0}return t.numPlanes=W,t.numIntersection=0,r}}function jZ(l){let t=new WeakMap;function e(a,d){return d===Mi?a.mapping=wl:d===Ti&&(a.mapping=Hl),a}function n(a){if(a&&a.isTexture){const d=a.mapping;if(d===Mi||d===Ti)if(t.has(a)){const c=t.get(a).texture;return e(c,a.mapping)}else{const c=a.image;if(c&&c.height>0){const o=new wo(c.height);return o.fromEquirectangularTexture(l,a),t.set(a,o),a.addEventListener("dispose",i),e(o.texture,a.mapping)}else return null}}return a}function i(a){const d=a.target;d.removeEventListener("dispose",i);const c=t.get(d);c!==void 0&&(t.delete(d),c.dispose())}function s(){t=new WeakMap}return{get:n,dispose:s}}class ka extends Os{constructor(t=-1,e=1,n=1,i=-1,s=.1,a=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=s,this.far=a,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,s,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let s=n-t,a=n+t,d=i+e,c=i-e;if(this.view!==null&&this.view.enabled){const o=(this.right-this.left)/this.view.fullWidth/this.zoom,m=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=o*this.view.offsetX,a=s+o*this.view.width,d-=m*this.view.offsetY,c=d-m*this.view.height}this.projectionMatrix.makeOrthographic(s,a,d,c,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}const mn=4,nd=[.125,.215,.35,.446,.526,.582],Ul=20,wa=new ka,id=new Kt;let Ha=null,za=0,Ka=0,Ba=!1;const Ml=(1+Math.sqrt(5))/2,Zn=1/Ml,ad=[new k(-Ml,Zn,0),new k(Ml,Zn,0),new k(-Zn,0,Ml),new k(Zn,0,Ml),new k(0,Ml,-Zn),new k(0,Ml,Zn),new k(-1,1,-1),new k(1,1,-1),new k(-1,1,1),new k(1,1,1)];class sd{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,i=100){Ha=this._renderer.getRenderTarget(),za=this._renderer.getActiveCubeFace(),Ka=this._renderer.getActiveMipmapLevel(),Ba=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(t,n,i,s),e>0&&this._blur(s,0,0,e),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=od(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=cd(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(Ha,za,Ka),this._renderer.xr.enabled=Ba,t.scissorTest=!1,mi(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===wl||t.mapping===Hl?this._setSize(t.image.length===0?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),Ha=this._renderer.getRenderTarget(),za=this._renderer.getActiveCubeFace(),Ka=this._renderer.getActiveMipmapLevel(),Ba=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const n=e||this._allocateTargets();return this._textureToCubeUV(t,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,n={magFilter:be,minFilter:be,generateMipmaps:!1,type:Gn,format:Ne,colorSpace:El,depthBuffer:!1},i=dd(t,e,n);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==t||this._pingPongRenderTarget.height!==e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=dd(t,e,n);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=DZ(s)),this._blurMaterial=_Z(s,t,e)}return i}_compileMaterial(t){const e=new ae(this._lodPlanes[0],t);this._renderer.compile(e,wa)}_sceneToCubeUV(t,e,n,i){const d=new He(90,1,e,n),c=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],m=this._renderer,Z=m.autoClear,b=m.toneMapping;m.getClearColor(id),m.toneMapping=Zl,m.autoClear=!1;const h=new Yn({name:"PMREM.Background",side:Re,depthWrite:!1,depthTest:!1}),p=new ae(new fn,h);let W=!1;const r=t.background;r?r.isColor&&(h.color.copy(r),t.background=null,W=!0):(h.color.copy(id),W=!0);for(let u=0;u<6;u++){const S=u%3;S===0?(d.up.set(0,c[u],0),d.lookAt(o[u],0,0)):S===1?(d.up.set(0,0,c[u]),d.lookAt(0,o[u],0)):(d.up.set(0,c[u],0),d.lookAt(0,0,o[u]));const C=this._cubeSize;mi(i,S*C,u>2?C:0,C,C),m.setRenderTarget(i),W&&m.render(p,d),m.render(t,d)}p.geometry.dispose(),p.material.dispose(),m.toneMapping=b,m.autoClear=Z,t.background=r}_textureToCubeUV(t,e){const n=this._renderer,i=t.mapping===wl||t.mapping===Hl;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=od()),this._cubemapMaterial.uniforms.flipEnvMap.value=t.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=cd());const s=i?this._cubemapMaterial:this._equirectMaterial,a=new ae(this._lodPlanes[0],s),d=s.uniforms;d.envMap.value=t;const c=this._cubeSize;mi(e,0,0,3*c,2*c),n.setRenderTarget(e),n.render(a,wa)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;const i=this._lodPlanes.length;for(let s=1;s<i;s++){const a=Math.sqrt(this._sigmas[s]*this._sigmas[s]-this._sigmas[s-1]*this._sigmas[s-1]),d=ad[(i-s-1)%ad.length];this._blur(t,s-1,s,a,d)}e.autoClear=n}_blur(t,e,n,i,s){const a=this._pingPongRenderTarget;this._halfBlur(t,a,e,n,i,"latitudinal",s),this._halfBlur(a,t,n,n,i,"longitudinal",s)}_halfBlur(t,e,n,i,s,a,d){const c=this._renderer,o=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const m=3,Z=new ae(this._lodPlanes[i],o),b=o.uniforms,h=this._sizeLods[n]-1,p=isFinite(s)?Math.PI/(2*h):2*Math.PI/(2*Ul-1),W=s/p,r=isFinite(s)?1+Math.floor(m*W):Ul;r>Ul&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${r} samples when the maximum is set to ${Ul}`);const u=[];let S=0;for(let x=0;x<Ul;++x){const U=x/W,R=Math.exp(-U*U/2);u.push(R),x===0?S+=R:x<r&&(S+=2*R)}for(let x=0;x<u.length;x++)u[x]=u[x]/S;b.envMap.value=t.texture,b.samples.value=r,b.weights.value=u,b.latitudinal.value=a==="latitudinal",d&&(b.poleAxis.value=d);const{_lodMax:C}=this;b.dTheta.value=p,b.mipInt.value=C-n;const X=this._sizeLods[i],M=3*X*(i>C-mn?i-C+mn:0),I=4*(this._cubeSize-X);mi(e,M,I,3*X,2*X),c.setRenderTarget(e),c.render(Z,wa)}}function DZ(l){const t=[],e=[],n=[];let i=l;const s=l-mn+1+nd.length;for(let a=0;a<s;a++){const d=Math.pow(2,i);e.push(d);let c=1/d;a>l-mn?c=nd[a-l+mn-1]:a===0&&(c=0),n.push(c);const o=1/(d-2),m=-o,Z=1+o,b=[m,m,Z,m,Z,Z,m,m,Z,Z,m,Z],h=6,p=6,W=3,r=2,u=1,S=new Float32Array(W*p*h),C=new Float32Array(r*p*h),X=new Float32Array(u*p*h);for(let I=0;I<h;I++){const x=I%3*2/3-1,U=I>2?0:-1,R=[x,U,0,x+2/3,U,0,x+2/3,U+1,0,x,U,0,x+2/3,U+1,0,x,U+1,0];S.set(R,W*p*I),C.set(b,r*p*I);const g=[I,I,I,I,I,I];X.set(g,u*p*I)}const M=new Le;M.setAttribute("position",new Ce(S,W)),M.setAttribute("uv",new Ce(C,r)),M.setAttribute("faceIndex",new Ce(X,u)),t.push(M),i>mn&&i--}return{lodPlanes:t,sizeLods:e,sigmas:n}}function dd(l,t,e){const n=new bl(l,t,e);return n.texture.mapping=Tn,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function mi(l,t,e,n,i){l.viewport.set(t,e,n,i),l.scissor.set(t,e,n,i)}function _Z(l,t,e){const n=new Float32Array(Ul),i=new k(0,1,0);return new he({name:"SphericalGaussianBlur",defines:{n:Ul,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/e,CUBEUV_MAX_MIP:`${l}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:Ea(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:ml,depthTest:!1,depthWrite:!1})}function cd(){return new he({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:Ea(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:ml,depthTest:!1,depthWrite:!1})}function od(){return new he({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:Ea(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:ml,depthTest:!1,depthWrite:!1})}function Ea(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function OZ(l){let t=new WeakMap,e=null;function n(d){if(d&&d.isTexture){const c=d.mapping,o=c===Mi||c===Ti,m=c===wl||c===Hl;if(o||m){let Z=t.get(d);const b=Z!==void 0?Z.texture.pmremVersion:0;if(d.isRenderTargetTexture&&d.pmremVersion!==b)return e===null&&(e=new sd(l)),Z=o?e.fromEquirectangular(d,Z):e.fromCubemap(d,Z),Z.texture.pmremVersion=d.pmremVersion,t.set(d,Z),Z.texture;if(Z!==void 0)return Z.texture;{const h=d.image;return o&&h&&h.height>0||m&&h&&i(h)?(e===null&&(e=new sd(l)),Z=o?e.fromEquirectangular(d):e.fromCubemap(d),Z.texture.pmremVersion=d.pmremVersion,t.set(d,Z),d.addEventListener("dispose",s),Z.texture):null}}}return d}function i(d){let c=0;const o=6;for(let m=0;m<o;m++)d[m]!==void 0&&c++;return c===o}function s(d){const c=d.target;c.removeEventListener("dispose",s);const o=t.get(c);o!==void 0&&(t.delete(c),o.dispose())}function a(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:n,dispose:a}}function qZ(l){const t={};function e(n){if(t[n]!==void 0)return t[n];let i;switch(n){case"WEBGL_depth_texture":i=l.getExtension("WEBGL_depth_texture")||l.getExtension("MOZ_WEBGL_depth_texture")||l.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=l.getExtension("EXT_texture_filter_anisotropic")||l.getExtension("MOZ_EXT_texture_filter_anisotropic")||l.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=l.getExtension("WEBGL_compressed_texture_s3tc")||l.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||l.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=l.getExtension("WEBGL_compressed_texture_pvrtc")||l.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=l.getExtension(n)}return t[n]=i,i}return{has:function(n){return e(n)!==null},init:function(){e("EXT_color_buffer_float"),e("WEBGL_clip_cull_distance"),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("WEBGL_multisampled_render_to_texture"),e("WEBGL_render_shared_exponent")},get:function(n){const i=e(n);return i===null&&gn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function $Z(l,t,e,n){const i={},s=new WeakMap;function a(Z){const b=Z.target;b.index!==null&&t.remove(b.index);for(const p in b.attributes)t.remove(b.attributes[p]);for(const p in b.morphAttributes){const W=b.morphAttributes[p];for(let r=0,u=W.length;r<u;r++)t.remove(W[r])}b.removeEventListener("dispose",a),delete i[b.id];const h=s.get(b);h&&(t.remove(h),s.delete(b)),n.releaseStatesOfGeometry(b),b.isInstancedBufferGeometry===!0&&delete b._maxInstanceCount,e.memory.geometries--}function d(Z,b){return i[b.id]===!0||(b.addEventListener("dispose",a),i[b.id]=!0,e.memory.geometries++),b}function c(Z){const b=Z.attributes;for(const p in b)t.update(b[p],l.ARRAY_BUFFER);const h=Z.morphAttributes;for(const p in h){const W=h[p];for(let r=0,u=W.length;r<u;r++)t.update(W[r],l.ARRAY_BUFFER)}}function o(Z){const b=[],h=Z.index,p=Z.attributes.position;let W=0;if(h!==null){const S=h.array;W=h.version;for(let C=0,X=S.length;C<X;C+=3){const M=S[C+0],I=S[C+1],x=S[C+2];b.push(M,I,I,x,x,M)}}else if(p!==void 0){const S=p.array;W=p.version;for(let C=0,X=S.length/3-1;C<X;C+=3){const M=C+0,I=C+1,x=C+2;b.push(M,I,I,x,x,M)}}else return;const r=new(Cs(b)?Qs:As)(b,1);r.version=W;const u=s.get(Z);u&&t.remove(u),s.set(Z,r)}function m(Z){const b=s.get(Z);if(b){const h=Z.index;h!==null&&b.version<h.version&&o(Z)}else o(Z);return s.get(Z)}return{get:d,update:c,getWireframeAttribute:m}}function th(l,t,e){let n;function i(b){n=b}let s,a;function d(b){s=b.type,a=b.bytesPerElement}function c(b,h){l.drawElements(n,h,s,b*a),e.update(h,n,1)}function o(b,h,p){p!==0&&(l.drawElementsInstanced(n,h,s,b*a,p),e.update(h,n,p))}function m(b,h,p){if(p===0)return;t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n,h,0,s,b,0,p);let r=0;for(let u=0;u<p;u++)r+=h[u];e.update(r,n,1)}function Z(b,h,p,W){if(p===0)return;const r=t.get("WEBGL_multi_draw");if(r===null)for(let u=0;u<b.length;u++)o(b[u]/a,h[u],W[u]);else{r.multiDrawElementsInstancedWEBGL(n,h,0,s,b,0,W,0,p);let u=0;for(let S=0;S<p;S++)u+=h[S]*W[S];e.update(u,n,1)}}this.setMode=i,this.setIndex=d,this.render=c,this.renderInstances=o,this.renderMultiDraw=m,this.renderMultiDrawInstances=Z}function eh(l){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,a,d){switch(e.calls++,a){case l.TRIANGLES:e.triangles+=d*(s/3);break;case l.LINES:e.lines+=d*(s/2);break;case l.LINE_STRIP:e.lines+=d*(s-1);break;case l.LINE_LOOP:e.lines+=d*s;break;case l.POINTS:e.points+=d*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function i(){e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:i,update:n}}function lh(l,t,e){const n=new WeakMap,i=new ne;function s(a,d,c){const o=a.morphTargetInfluences,m=d.morphAttributes.position||d.morphAttributes.normal||d.morphAttributes.color,Z=m!==void 0?m.length:0;let b=n.get(d);if(b===void 0||b.count!==Z){let R=function(){x.dispose(),n.delete(d),d.removeEventListener("dispose",R)};b!==void 0&&b.texture.dispose();const h=d.morphAttributes.position!==void 0,p=d.morphAttributes.normal!==void 0,W=d.morphAttributes.color!==void 0,r=d.morphAttributes.position||[],u=d.morphAttributes.normal||[],S=d.morphAttributes.color||[];let C=0;h===!0&&(C=1),p===!0&&(C=2),W===!0&&(C=3);let X=d.attributes.position.count*C,M=1;X>t.maxTextureSize&&(M=Math.ceil(X/t.maxTextureSize),X=t.maxTextureSize);const I=new Float32Array(X*M*4*Z),x=new Ls(I,X,M,Z);x.type=qe,x.needsUpdate=!0;const U=C*4;for(let g=0;g<Z;g++){const Y=r[g],Q=u[g],w=S[g],E=X*M*4*g;for(let _=0;_<Y.count;_++){const K=_*U;h===!0&&(i.fromBufferAttribute(Y,_),I[E+K+0]=i.x,I[E+K+1]=i.y,I[E+K+2]=i.z,I[E+K+3]=0),p===!0&&(i.fromBufferAttribute(Q,_),I[E+K+4]=i.x,I[E+K+5]=i.y,I[E+K+6]=i.z,I[E+K+7]=0),W===!0&&(i.fromBufferAttribute(w,_),I[E+K+8]=i.x,I[E+K+9]=i.y,I[E+K+10]=i.z,I[E+K+11]=w.itemSize===4?i.w:1)}}b={count:Z,texture:x,size:new Lt(X,M)},n.set(d,b),d.addEventListener("dispose",R)}if(a.isInstancedMesh===!0&&a.morphTexture!==null)c.getUniforms().setValue(l,"morphTexture",a.morphTexture,e);else{let h=0;for(let W=0;W<o.length;W++)h+=o[W];const p=d.morphTargetsRelative?1:1-h;c.getUniforms().setValue(l,"morphTargetBaseInfluence",p),c.getUniforms().setValue(l,"morphTargetInfluences",o)}c.getUniforms().setValue(l,"morphTargetsTexture",b.texture,e),c.getUniforms().setValue(l,"morphTargetsTextureSize",b.size)}return{update:s}}function nh(l,t,e,n){let i=new WeakMap;function s(c){const o=n.render.frame,m=c.geometry,Z=t.get(c,m);if(i.get(Z)!==o&&(t.update(Z),i.set(Z,o)),c.isInstancedMesh&&(c.hasEventListener("dispose",d)===!1&&c.addEventListener("dispose",d),i.get(c)!==o&&(e.update(c.instanceMatrix,l.ARRAY_BUFFER),c.instanceColor!==null&&e.update(c.instanceColor,l.ARRAY_BUFFER),i.set(c,o))),c.isSkinnedMesh){const b=c.skeleton;i.get(b)!==o&&(b.update(),i.set(b,o))}return Z}function a(){i=new WeakMap}function d(c){const o=c.target;o.removeEventListener("dispose",d),e.remove(o.instanceMatrix),o.instanceColor!==null&&e.remove(o.instanceColor)}return{update:s,dispose:a}}class md extends Xe{constructor(t,e,n,i,s,a,d,c,o,m=Kl){if(m!==Kl&&m!==Bl)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&m===Kl&&(n=Sl),n===void 0&&m===Bl&&(n=zl),super(null,i,s,a,d,c,m,n,o),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=d!==void 0?d:Te,this.minFilter=c!==void 0?c:Te,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return this.compareFunction!==null&&(e.compareFunction=this.compareFunction),e}}const Zd=new Xe,hd=new md(1,1),bd=new Ls,ud=new yo,rd=new td,pd=[],Gd=[],Wd=new Float32Array(16),Vd=new Float32Array(9),Xd=new Float32Array(4);function hn(l,t,e){const n=l[0];if(n<=0||n>0)return l;const i=t*e;let s=pd[i];if(s===void 0&&(s=new Float32Array(i),pd[i]=s),t!==0){n.toArray(s,0);for(let a=1,d=0;a!==t;++a)d+=e,l[a].toArray(s,d)}return s}function ce(l,t){if(l.length!==t.length)return!1;for(let e=0,n=l.length;e<n;e++)if(l[e]!==t[e])return!1;return!0}function oe(l,t){for(let e=0,n=t.length;e<n;e++)l[e]=t[e]}function Zi(l,t){let e=Gd[t];e===void 0&&(e=new Int32Array(t),Gd[t]=e);for(let n=0;n!==t;++n)e[n]=l.allocateTextureUnit();return e}function ih(l,t){const e=this.cache;e[0]!==t&&(l.uniform1f(this.addr,t),e[0]=t)}function ah(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(l.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(ce(e,t))return;l.uniform2fv(this.addr,t),oe(e,t)}}function sh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(l.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(l.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(ce(e,t))return;l.uniform3fv(this.addr,t),oe(e,t)}}function dh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(l.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(ce(e,t))return;l.uniform4fv(this.addr,t),oe(e,t)}}function ch(l,t){const e=this.cache,n=t.elements;if(n===void 0){if(ce(e,t))return;l.uniformMatrix2fv(this.addr,!1,t),oe(e,t)}else{if(ce(e,n))return;Xd.set(n),l.uniformMatrix2fv(this.addr,!1,Xd),oe(e,n)}}function oh(l,t){const e=this.cache,n=t.elements;if(n===void 0){if(ce(e,t))return;l.uniformMatrix3fv(this.addr,!1,t),oe(e,t)}else{if(ce(e,n))return;Vd.set(n),l.uniformMatrix3fv(this.addr,!1,Vd),oe(e,n)}}function mh(l,t){const e=this.cache,n=t.elements;if(n===void 0){if(ce(e,t))return;l.uniformMatrix4fv(this.addr,!1,t),oe(e,t)}else{if(ce(e,n))return;Wd.set(n),l.uniformMatrix4fv(this.addr,!1,Wd),oe(e,n)}}function Zh(l,t){const e=this.cache;e[0]!==t&&(l.uniform1i(this.addr,t),e[0]=t)}function hh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(l.uniform2i(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(ce(e,t))return;l.uniform2iv(this.addr,t),oe(e,t)}}function bh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(l.uniform3i(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else{if(ce(e,t))return;l.uniform3iv(this.addr,t),oe(e,t)}}function uh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(l.uniform4i(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(ce(e,t))return;l.uniform4iv(this.addr,t),oe(e,t)}}function rh(l,t){const e=this.cache;e[0]!==t&&(l.uniform1ui(this.addr,t),e[0]=t)}function ph(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(l.uniform2ui(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(ce(e,t))return;l.uniform2uiv(this.addr,t),oe(e,t)}}function Gh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(l.uniform3ui(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else{if(ce(e,t))return;l.uniform3uiv(this.addr,t),oe(e,t)}}function Wh(l,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(l.uniform4ui(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(ce(e,t))return;l.uniform4uiv(this.addr,t),oe(e,t)}}function Vh(l,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(l.uniform1i(this.addr,i),n[0]=i);let s;this.type===l.SAMPLER_2D_SHADOW?(hd.compareFunction=Xs,s=hd):s=Zd,e.setTexture2D(t||s,i)}function Xh(l,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(l.uniform1i(this.addr,i),n[0]=i),e.setTexture3D(t||ud,i)}function gh(l,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(l.uniform1i(this.addr,i),n[0]=i),e.setTextureCube(t||rd,i)}function Rh(l,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(l.uniform1i(this.addr,i),n[0]=i),e.setTexture2DArray(t||bd,i)}function yh(l){switch(l){case 5126:return ih;case 35664:return ah;case 35665:return sh;case 35666:return dh;case 35674:return ch;case 35675:return oh;case 35676:return mh;case 5124:case 35670:return Zh;case 35667:case 35671:return hh;case 35668:case 35672:return bh;case 35669:case 35673:return uh;case 5125:return rh;case 36294:return ph;case 36295:return Gh;case 36296:return Wh;case 35678:case 36198:case 36298:case 36306:case 35682:return Vh;case 35679:case 36299:case 36307:return Xh;case 35680:case 36300:case 36308:case 36293:return gh;case 36289:case 36303:case 36311:case 36292:return Rh}}function Ch(l,t){l.uniform1fv(this.addr,t)}function Sh(l,t){const e=hn(t,this.size,2);l.uniform2fv(this.addr,e)}function Ih(l,t){const e=hn(t,this.size,3);l.uniform3fv(this.addr,e)}function xh(l,t){const e=hn(t,this.size,4);l.uniform4fv(this.addr,e)}function Yh(l,t){const e=hn(t,this.size,4);l.uniformMatrix2fv(this.addr,!1,e)}function Nh(l,t){const e=hn(t,this.size,9);l.uniformMatrix3fv(this.addr,!1,e)}function fh(l,t){const e=hn(t,this.size,16);l.uniformMatrix4fv(this.addr,!1,e)}function Fh(l,t){l.uniform1iv(this.addr,t)}function Lh(l,t){l.uniform2iv(this.addr,t)}function Uh(l,t){l.uniform3iv(this.addr,t)}function Mh(l,t){l.uniform4iv(this.addr,t)}function Th(l,t){l.uniform1uiv(this.addr,t)}function Jh(l,t){l.uniform2uiv(this.addr,t)}function vh(l,t){l.uniform3uiv(this.addr,t)}function kh(l,t){l.uniform4uiv(this.addr,t)}function wh(l,t,e){const n=this.cache,i=t.length,s=Zi(e,i);ce(n,s)||(l.uniform1iv(this.addr,s),oe(n,s));for(let a=0;a!==i;++a)e.setTexture2D(t[a]||Zd,s[a])}function Hh(l,t,e){const n=this.cache,i=t.length,s=Zi(e,i);ce(n,s)||(l.uniform1iv(this.addr,s),oe(n,s));for(let a=0;a!==i;++a)e.setTexture3D(t[a]||ud,s[a])}function zh(l,t,e){const n=this.cache,i=t.length,s=Zi(e,i);ce(n,s)||(l.uniform1iv(this.addr,s),oe(n,s));for(let a=0;a!==i;++a)e.setTextureCube(t[a]||rd,s[a])}function Kh(l,t,e){const n=this.cache,i=t.length,s=Zi(e,i);ce(n,s)||(l.uniform1iv(this.addr,s),oe(n,s));for(let a=0;a!==i;++a)e.setTexture2DArray(t[a]||bd,s[a])}function Bh(l){switch(l){case 5126:return Ch;case 35664:return Sh;case 35665:return Ih;case 35666:return xh;case 35674:return Yh;case 35675:return Nh;case 35676:return fh;case 5124:case 35670:return Fh;case 35667:case 35671:return Lh;case 35668:case 35672:return Uh;case 35669:case 35673:return Mh;case 5125:return Th;case 36294:return Jh;case 36295:return vh;case 36296:return kh;case 35678:case 36198:case 36298:case 36306:case 35682:return wh;case 35679:case 36299:case 36307:return Hh;case 35680:case 36300:case 36308:case 36293:return zh;case 36289:case 36303:case 36311:case 36292:return Kh}}class Eh{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.type=e.type,this.setValue=yh(e.type)}}class Ah{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.type=e.type,this.size=e.size,this.setValue=Bh(e.type)}}class Qh{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,n){const i=this.seq;for(let s=0,a=i.length;s!==a;++s){const d=i[s];d.setValue(t,e[d.id],n)}}}const Aa=/(\w+)(\])?(\[|\.)?/g;function gd(l,t){l.seq.push(t),l.map[t.id]=t}function Ph(l,t,e){const n=l.name,i=n.length;for(Aa.lastIndex=0;;){const s=Aa.exec(n),a=Aa.lastIndex;let d=s[1];const c=s[2]==="]",o=s[3];if(c&&(d=d|0),o===void 0||o==="["&&a+2===i){gd(e,o===void 0?new Eh(d,l,t):new Ah(d,l,t));break}else{let Z=e.map[d];Z===void 0&&(Z=new Qh(d),gd(e,Z)),e=Z}}}class hi{constructor(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){const s=t.getActiveUniform(e,i),a=t.getUniformLocation(e,s.name);Ph(s,a,this)}}setValue(t,e,n,i){const s=this.map[e];s!==void 0&&s.setValue(t,n,i)}setOptional(t,e,n){const i=e[n];i!==void 0&&this.setValue(t,n,i)}static upload(t,e,n,i){for(let s=0,a=e.length;s!==a;++s){const d=e[s],c=n[d.id];c.needsUpdate!==!1&&d.setValue(t,c.value,i)}}static seqWithValue(t,e){const n=[];for(let i=0,s=t.length;i!==s;++i){const a=t[i];a.id in e&&n.push(a)}return n}}function Rd(l,t,e){const n=l.createShader(t);return l.shaderSource(n,e),l.compileShader(n),n}const jh=37297;let Dh=0;function _h(l,t){const e=l.split(`
`),n=[],i=Math.max(t-6,0),s=Math.min(t+6,e.length);for(let a=i;a<s;a++){const d=a+1;n.push(`${d===t?">":" "} ${d}: ${e[a]}`)}return n.join(`
`)}const yd=new xt;function Oh(l){kt._getMatrix(yd,kt.workingColorSpace,l);const t=`mat3( ${yd.elements.map(e=>e.toFixed(4))} )`;switch(kt.getTransfer(l)){case Kn:return[t,"LinearTransferOETF"];case Qt:return[t,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",l),[t,"LinearTransferOETF"]}}function Cd(l,t,e){const n=l.getShaderParameter(t,l.COMPILE_STATUS),i=l.getShaderInfoLog(t).trim();if(n&&i==="")return"";const s=/ERROR: 0:(\d+)/.exec(i);if(s){const a=parseInt(s[1]);return e.toUpperCase()+`

`+i+`

`+_h(l.getShaderSource(t),a)}else return i}function qh(l,t){const e=Oh(t);return[`vec4 ${l}( vec4 value ) {`,`	return ${e[1]}( vec4( value.rgb * ${e[0]}, value.a ) );`,"}"].join(`
`)}function $h(l,t){let e;switch(t){case Uc:e="Linear";break;case Mc:e="Reinhard";break;case Tc:e="Cineon";break;case Jc:e="ACESFilmic";break;case kc:e="AgX";break;case wc:e="Neutral";break;case vc:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+l+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}const bi=new k;function tb(){kt.getLuminanceCoefficients(bi);const l=bi.x.toFixed(4),t=bi.y.toFixed(4),e=bi.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${l}, ${t}, ${e} );`,"	return dot( weights, rgb );","}"].join(`
`)}function eb(l){return[l.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",l.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(Fn).join(`
`)}function lb(l){const t=[];for(const e in l){const n=l[e];n!==!1&&t.push("#define "+e+" "+n)}return t.join(`
`)}function nb(l,t){const e={},n=l.getProgramParameter(t,l.ACTIVE_ATTRIBUTES);for(let i=0;i<n;i++){const s=l.getActiveAttrib(t,i),a=s.name;let d=1;s.type===l.FLOAT_MAT2&&(d=2),s.type===l.FLOAT_MAT3&&(d=3),s.type===l.FLOAT_MAT4&&(d=4),e[a]={type:s.type,location:l.getAttribLocation(t,a),locationSize:d}}return e}function Fn(l){return l!==""}function Sd(l,t){const e=t.numSpotLightShadows+t.numSpotLightMaps-t.numSpotLightShadowsWithMaps;return l.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,e).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function Id(l,t){return l.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const ib=/^[ \t]*#include +<([\w\d./]+)>/gm;function Qa(l){return l.replace(ib,sb)}const ab=new Map;function sb(l,t){let e=ft[t];if(e===void 0){const n=ab.get(t);if(n!==void 0)e=ft[n],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',t,n);else throw new Error("Can not resolve #include <"+t+">")}return Qa(e)}const db=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function xd(l){return l.replace(db,cb)}function cb(l,t,e,n){let i="";for(let s=parseInt(t);s<parseInt(e);s++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function Yd(l){let t=`precision ${l.precision} float;
	precision ${l.precision} int;
	precision ${l.precision} sampler2D;
	precision ${l.precision} samplerCube;
	precision ${l.precision} sampler3D;
	precision ${l.precision} sampler2DArray;
	precision ${l.precision} sampler2DShadow;
	precision ${l.precision} samplerCubeShadow;
	precision ${l.precision} sampler2DArrayShadow;
	precision ${l.precision} isampler2D;
	precision ${l.precision} isampler3D;
	precision ${l.precision} isamplerCube;
	precision ${l.precision} isampler2DArray;
	precision ${l.precision} usampler2D;
	precision ${l.precision} usampler3D;
	precision ${l.precision} usamplerCube;
	precision ${l.precision} usampler2DArray;
	`;return l.precision==="highp"?t+=`
#define HIGH_PRECISION`:l.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:l.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function ob(l){let t="SHADOWMAP_TYPE_BASIC";return l.shadowMapType===is?t="SHADOWMAP_TYPE_PCF":l.shadowMapType===hc?t="SHADOWMAP_TYPE_PCF_SOFT":l.shadowMapType===_e&&(t="SHADOWMAP_TYPE_VSM"),t}function mb(l){let t="ENVMAP_TYPE_CUBE";if(l.envMap)switch(l.envMapMode){case wl:case Hl:t="ENVMAP_TYPE_CUBE";break;case Tn:t="ENVMAP_TYPE_CUBE_UV";break}return t}function Zb(l){let t="ENVMAP_MODE_REFLECTION";if(l.envMap)switch(l.envMapMode){case Hl:t="ENVMAP_MODE_REFRACTION";break}return t}function hb(l){let t="ENVMAP_BLENDING_NONE";if(l.envMap)switch(l.combine){case ds:t="ENVMAP_BLENDING_MULTIPLY";break;case Fc:t="ENVMAP_BLENDING_MIX";break;case Lc:t="ENVMAP_BLENDING_ADD";break}return t}function bb(l){const t=l.envMapCubeUVHeight;if(t===null)return null;const e=Math.log2(t)-2,n=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,e),7*16)),texelHeight:n,maxMip:e}}function ub(l,t,e,n){const i=l.getContext(),s=e.defines;let a=e.vertexShader,d=e.fragmentShader;const c=ob(e),o=mb(e),m=Zb(e),Z=hb(e),b=bb(e),h=eb(e),p=lb(s),W=i.createProgram();let r,u,S=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(r=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,p].filter(Fn).join(`
`),r.length>0&&(r+=`
`),u=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,p].filter(Fn).join(`
`),u.length>0&&(u+=`
`)):(r=[Yd(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,p,e.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",e.batching?"#define USE_BATCHING":"",e.batchingColor?"#define USE_BATCHING_COLOR":"",e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.instancingMorph?"#define USE_INSTANCING_MORPH":"",e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+m:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.displacementMap?"#define USE_DISPLACEMENTMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaHash?"#define USE_ALPHAHASH":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.mapUv?"#define MAP_UV "+e.mapUv:"",e.alphaMapUv?"#define ALPHAMAP_UV "+e.alphaMapUv:"",e.lightMapUv?"#define LIGHTMAP_UV "+e.lightMapUv:"",e.aoMapUv?"#define AOMAP_UV "+e.aoMapUv:"",e.emissiveMapUv?"#define EMISSIVEMAP_UV "+e.emissiveMapUv:"",e.bumpMapUv?"#define BUMPMAP_UV "+e.bumpMapUv:"",e.normalMapUv?"#define NORMALMAP_UV "+e.normalMapUv:"",e.displacementMapUv?"#define DISPLACEMENTMAP_UV "+e.displacementMapUv:"",e.metalnessMapUv?"#define METALNESSMAP_UV "+e.metalnessMapUv:"",e.roughnessMapUv?"#define ROUGHNESSMAP_UV "+e.roughnessMapUv:"",e.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+e.anisotropyMapUv:"",e.clearcoatMapUv?"#define CLEARCOATMAP_UV "+e.clearcoatMapUv:"",e.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+e.clearcoatNormalMapUv:"",e.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+e.clearcoatRoughnessMapUv:"",e.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+e.iridescenceMapUv:"",e.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+e.iridescenceThicknessMapUv:"",e.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+e.sheenColorMapUv:"",e.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+e.sheenRoughnessMapUv:"",e.specularMapUv?"#define SPECULARMAP_UV "+e.specularMapUv:"",e.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+e.specularColorMapUv:"",e.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+e.specularIntensityMapUv:"",e.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+e.transmissionMapUv:"",e.thicknessMapUv?"#define THICKNESSMAP_UV "+e.thicknessMapUv:"",e.vertexTangents&&e.flatShading===!1?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphColors?"#define USE_MORPHCOLORS":"",e.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+e.morphTextureStride:"",e.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+c:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Fn).join(`
`),u=[Yd(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,p,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+o:"",e.envMap?"#define "+m:"",e.envMap?"#define "+Z:"",b?"#define CUBEUV_TEXEL_WIDTH "+b.texelWidth:"",b?"#define CUBEUV_TEXEL_HEIGHT "+b.texelHeight:"",b?"#define CUBEUV_MAX_MIP "+b.maxMip+".0":"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.dispersion?"#define USE_DISPERSION":"",e.iridescence?"#define USE_IRIDESCENCE":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.alphaHash?"#define USE_ALPHAHASH":"",e.sheen?"#define USE_SHEEN":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents&&e.flatShading===!1?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor||e.batchingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+c:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",e.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",e.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==Zl?"#define TONE_MAPPING":"",e.toneMapping!==Zl?ft.tonemapping_pars_fragment:"",e.toneMapping!==Zl?$h("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.opaque?"#define OPAQUE":"",ft.colorspace_pars_fragment,qh("linearToOutputTexel",e.outputColorSpace),tb(),e.useDepthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Fn).join(`
`)),a=Qa(a),a=Sd(a,e),a=Id(a,e),d=Qa(d),d=Sd(d,e),d=Id(d,e),a=xd(a),d=xd(d),e.isRawShaderMaterial!==!0&&(S=`#version 300 es
`,r=[h,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+r,u=["#define varying in",e.glslVersion===Rs?"":"layout(location = 0) out highp vec4 pc_fragColor;",e.glslVersion===Rs?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+u);const C=S+r+a,X=S+u+d,M=Rd(i,i.VERTEX_SHADER,C),I=Rd(i,i.FRAGMENT_SHADER,X);i.attachShader(W,M),i.attachShader(W,I),e.index0AttributeName!==void 0?i.bindAttribLocation(W,0,e.index0AttributeName):e.morphTargets===!0&&i.bindAttribLocation(W,0,"position"),i.linkProgram(W);function x(Y){if(l.debug.checkShaderErrors){const Q=i.getProgramInfoLog(W).trim(),w=i.getShaderInfoLog(M).trim(),E=i.getShaderInfoLog(I).trim();let _=!0,K=!0;if(i.getProgramParameter(W,i.LINK_STATUS)===!1)if(_=!1,typeof l.debug.onShaderError=="function")l.debug.onShaderError(i,W,M,I);else{const $=Cd(i,M,"vertex"),z=Cd(i,I,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(W,i.VALIDATE_STATUS)+`

Material Name: `+Y.name+`
Material Type: `+Y.type+`

Program Info Log: `+Q+`
`+$+`
`+z)}else Q!==""?console.warn("THREE.WebGLProgram: Program Info Log:",Q):(w===""||E==="")&&(K=!1);K&&(Y.diagnostics={runnable:_,programLog:Q,vertexShader:{log:w,prefix:r},fragmentShader:{log:E,prefix:u}})}i.deleteShader(M),i.deleteShader(I),U=new hi(i,W),R=nb(i,W)}let U;this.getUniforms=function(){return U===void 0&&x(this),U};let R;this.getAttributes=function(){return R===void 0&&x(this),R};let g=e.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return g===!1&&(g=i.getProgramParameter(W,jh)),g},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(W),this.program=void 0},this.type=e.shaderType,this.name=e.shaderName,this.id=Dh++,this.cacheKey=t,this.usedTimes=1,this.program=W,this.vertexShader=M,this.fragmentShader=I,this}let rb=0;class pb{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,n=t.fragmentShader,i=this._getShaderStage(e),s=this._getShaderStage(n),a=this._getShaderCacheForMaterial(t);return a.has(i)===!1&&(a.add(i),i.usedTimes++),a.has(s)===!1&&(a.add(s),s.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const n of e)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;let n=e.get(t);return n===void 0&&(n=new Set,e.set(t,n)),n}_getShaderStage(t){const e=this.shaderCache;let n=e.get(t);return n===void 0&&(n=new Gb(t),e.set(t,n)),n}}class Gb{constructor(t){this.id=rb++,this.code=t,this.usedTimes=0}}function Wb(l,t,e,n,i,s,a){const d=new vs,c=new pb,o=new Set,m=[],Z=i.logarithmicDepthBuffer,b=i.vertexTextures;let h=i.precision;const p={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function W(R){return o.add(R),R===0?"uv":`uv${R}`}function r(R,g,Y,Q,w){const E=Q.fog,_=w.geometry,K=R.isMeshStandardMaterial?Q.environment:null,$=(R.isMeshStandardMaterial?e:t).get(R.envMap||K),z=$&&$.mapping===Tn?$.image.height:null,nt=p[R.type];R.precision!==null&&(h=i.getMaxPrecision(R.precision),h!==R.precision&&console.warn("THREE.WebGLProgram.getParameters:",R.precision,"not supported, using",h,"instead."));const ot=_.morphAttributes.position||_.morphAttributes.normal||_.morphAttributes.color,Vt=ot!==void 0?ot.length:0;let Ut=0;_.morphAttributes.position!==void 0&&(Ut=1),_.morphAttributes.normal!==void 0&&(Ut=2),_.morphAttributes.color!==void 0&&(Ut=3);let Pt,A,tt,pt;if(nt){const At=Pe[nt];Pt=At.vertexShader,A=At.fragmentShader}else Pt=R.vertexShader,A=R.fragmentShader,c.update(R),tt=c.getVertexShaderID(R),pt=c.getFragmentShaderID(R);const it=l.getRenderTarget(),yt=l.state.buffers.depth.getReversed(),It=w.isInstancedMesh===!0,Mt=w.isBatchedMesh===!0,te=!!R.map,wt=!!R.matcap,se=!!$,L=!!R.aoMap,Ue=!!R.lightMap,Tt=!!R.bumpMap,Jt=!!R.normalMap,gt=!!R.displacementMap,Ot=!!R.emissiveMap,Xt=!!R.metalnessMap,y=!!R.roughnessMap,G=R.anisotropy>0,T=R.clearcoat>0,P=R.dispersion>0,D=R.iridescence>0,B=R.sheen>0,Gt=R.transmission>0,at=G&&!!R.anisotropyMap,mt=T&&!!R.clearcoatMap,Ht=T&&!!R.clearcoatNormalMap,O=T&&!!R.clearcoatRoughnessMap,Zt=D&&!!R.iridescenceMap,Rt=D&&!!R.iridescenceThicknessMap,Ct=B&&!!R.sheenColorMap,ht=B&&!!R.sheenRoughnessMap,vt=!!R.specularMap,Ft=!!R.specularColorMap,Dt=!!R.specularIntensityMap,N=Gt&&!!R.transmissionMap,lt=Gt&&!!R.thicknessMap,H=!!R.gradientMap,j=!!R.alphaMap,ct=R.alphaTest>0,st=!!R.alphaHash,Yt=!!R.extensions;let le=Zl;R.toneMapped&&(it===null||it.isXRRenderTarget===!0)&&(le=l.toneMapping);const Ge={shaderID:nt,shaderType:R.type,shaderName:R.name,vertexShader:Pt,fragmentShader:A,defines:R.defines,customVertexShaderID:tt,customFragmentShaderID:pt,isRawShaderMaterial:R.isRawShaderMaterial===!0,glslVersion:R.glslVersion,precision:h,batching:Mt,batchingColor:Mt&&w._colorsTexture!==null,instancing:It,instancingColor:It&&w.instanceColor!==null,instancingMorph:It&&w.morphTexture!==null,supportsVertexTextures:b,outputColorSpace:it===null?l.outputColorSpace:it.isXRRenderTarget===!0?it.texture.colorSpace:El,alphaToCoverage:!!R.alphaToCoverage,map:te,matcap:wt,envMap:se,envMapMode:se&&$.mapping,envMapCubeUVHeight:z,aoMap:L,lightMap:Ue,bumpMap:Tt,normalMap:Jt,displacementMap:b&&gt,emissiveMap:Ot,normalMapObjectSpace:Jt&&R.normalMapType===Ec,normalMapTangentSpace:Jt&&R.normalMapType===Bc,metalnessMap:Xt,roughnessMap:y,anisotropy:G,anisotropyMap:at,clearcoat:T,clearcoatMap:mt,clearcoatNormalMap:Ht,clearcoatRoughnessMap:O,dispersion:P,iridescence:D,iridescenceMap:Zt,iridescenceThicknessMap:Rt,sheen:B,sheenColorMap:Ct,sheenRoughnessMap:ht,specularMap:vt,specularColorMap:Ft,specularIntensityMap:Dt,transmission:Gt,transmissionMap:N,thicknessMap:lt,gradientMap:H,opaque:R.transparent===!1&&R.blending===Ee&&R.alphaToCoverage===!1,alphaMap:j,alphaTest:ct,alphaHash:st,combine:R.combine,mapUv:te&&W(R.map.channel),aoMapUv:L&&W(R.aoMap.channel),lightMapUv:Ue&&W(R.lightMap.channel),bumpMapUv:Tt&&W(R.bumpMap.channel),normalMapUv:Jt&&W(R.normalMap.channel),displacementMapUv:gt&&W(R.displacementMap.channel),emissiveMapUv:Ot&&W(R.emissiveMap.channel),metalnessMapUv:Xt&&W(R.metalnessMap.channel),roughnessMapUv:y&&W(R.roughnessMap.channel),anisotropyMapUv:at&&W(R.anisotropyMap.channel),clearcoatMapUv:mt&&W(R.clearcoatMap.channel),clearcoatNormalMapUv:Ht&&W(R.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:O&&W(R.clearcoatRoughnessMap.channel),iridescenceMapUv:Zt&&W(R.iridescenceMap.channel),iridescenceThicknessMapUv:Rt&&W(R.iridescenceThicknessMap.channel),sheenColorMapUv:Ct&&W(R.sheenColorMap.channel),sheenRoughnessMapUv:ht&&W(R.sheenRoughnessMap.channel),specularMapUv:vt&&W(R.specularMap.channel),specularColorMapUv:Ft&&W(R.specularColorMap.channel),specularIntensityMapUv:Dt&&W(R.specularIntensityMap.channel),transmissionMapUv:N&&W(R.transmissionMap.channel),thicknessMapUv:lt&&W(R.thicknessMap.channel),alphaMapUv:j&&W(R.alphaMap.channel),vertexTangents:!!_.attributes.tangent&&(Jt||G),vertexColors:R.vertexColors,vertexAlphas:R.vertexColors===!0&&!!_.attributes.color&&_.attributes.color.itemSize===4,pointsUvs:w.isPoints===!0&&!!_.attributes.uv&&(te||j),fog:!!E,useFog:R.fog===!0,fogExp2:!!E&&E.isFogExp2,flatShading:R.flatShading===!0,sizeAttenuation:R.sizeAttenuation===!0,logarithmicDepthBuffer:Z,reverseDepthBuffer:yt,skinning:w.isSkinnedMesh===!0,morphTargets:_.morphAttributes.position!==void 0,morphNormals:_.morphAttributes.normal!==void 0,morphColors:_.morphAttributes.color!==void 0,morphTargetsCount:Vt,morphTextureStride:Ut,numDirLights:g.directional.length,numPointLights:g.point.length,numSpotLights:g.spot.length,numSpotLightMaps:g.spotLightMap.length,numRectAreaLights:g.rectArea.length,numHemiLights:g.hemi.length,numDirLightShadows:g.directionalShadowMap.length,numPointLightShadows:g.pointShadowMap.length,numSpotLightShadows:g.spotShadowMap.length,numSpotLightShadowsWithMaps:g.numSpotLightShadowsWithMaps,numLightProbes:g.numLightProbes,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:R.dithering,shadowMapEnabled:l.shadowMap.enabled&&Y.length>0,shadowMapType:l.shadowMap.type,toneMapping:le,decodeVideoTexture:te&&R.map.isVideoTexture===!0&&kt.getTransfer(R.map.colorSpace)===Qt,decodeVideoTextureEmissive:Ot&&R.emissiveMap.isVideoTexture===!0&&kt.getTransfer(R.emissiveMap.colorSpace)===Qt,premultipliedAlpha:R.premultipliedAlpha,doubleSided:R.side===Oe,flipSided:R.side===Re,useDepthPacking:R.depthPacking>=0,depthPacking:R.depthPacking||0,index0AttributeName:R.index0AttributeName,extensionClipCullDistance:Yt&&R.extensions.clipCullDistance===!0&&n.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(Yt&&R.extensions.multiDraw===!0||Mt)&&n.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:n.has("KHR_parallel_shader_compile"),customProgramCacheKey:R.customProgramCacheKey()};return Ge.vertexUv1s=o.has(1),Ge.vertexUv2s=o.has(2),Ge.vertexUv3s=o.has(3),o.clear(),Ge}function u(R){const g=[];if(R.shaderID?g.push(R.shaderID):(g.push(R.customVertexShaderID),g.push(R.customFragmentShaderID)),R.defines!==void 0)for(const Y in R.defines)g.push(Y),g.push(R.defines[Y]);return R.isRawShaderMaterial===!1&&(S(g,R),C(g,R),g.push(l.outputColorSpace)),g.push(R.customProgramCacheKey),g.join()}function S(R,g){R.push(g.precision),R.push(g.outputColorSpace),R.push(g.envMapMode),R.push(g.envMapCubeUVHeight),R.push(g.mapUv),R.push(g.alphaMapUv),R.push(g.lightMapUv),R.push(g.aoMapUv),R.push(g.bumpMapUv),R.push(g.normalMapUv),R.push(g.displacementMapUv),R.push(g.emissiveMapUv),R.push(g.metalnessMapUv),R.push(g.roughnessMapUv),R.push(g.anisotropyMapUv),R.push(g.clearcoatMapUv),R.push(g.clearcoatNormalMapUv),R.push(g.clearcoatRoughnessMapUv),R.push(g.iridescenceMapUv),R.push(g.iridescenceThicknessMapUv),R.push(g.sheenColorMapUv),R.push(g.sheenRoughnessMapUv),R.push(g.specularMapUv),R.push(g.specularColorMapUv),R.push(g.specularIntensityMapUv),R.push(g.transmissionMapUv),R.push(g.thicknessMapUv),R.push(g.combine),R.push(g.fogExp2),R.push(g.sizeAttenuation),R.push(g.morphTargetsCount),R.push(g.morphAttributeCount),R.push(g.numDirLights),R.push(g.numPointLights),R.push(g.numSpotLights),R.push(g.numSpotLightMaps),R.push(g.numHemiLights),R.push(g.numRectAreaLights),R.push(g.numDirLightShadows),R.push(g.numPointLightShadows),R.push(g.numSpotLightShadows),R.push(g.numSpotLightShadowsWithMaps),R.push(g.numLightProbes),R.push(g.shadowMapType),R.push(g.toneMapping),R.push(g.numClippingPlanes),R.push(g.numClipIntersection),R.push(g.depthPacking)}function C(R,g){d.disableAll(),g.supportsVertexTextures&&d.enable(0),g.instancing&&d.enable(1),g.instancingColor&&d.enable(2),g.instancingMorph&&d.enable(3),g.matcap&&d.enable(4),g.envMap&&d.enable(5),g.normalMapObjectSpace&&d.enable(6),g.normalMapTangentSpace&&d.enable(7),g.clearcoat&&d.enable(8),g.iridescence&&d.enable(9),g.alphaTest&&d.enable(10),g.vertexColors&&d.enable(11),g.vertexAlphas&&d.enable(12),g.vertexUv1s&&d.enable(13),g.vertexUv2s&&d.enable(14),g.vertexUv3s&&d.enable(15),g.vertexTangents&&d.enable(16),g.anisotropy&&d.enable(17),g.alphaHash&&d.enable(18),g.batching&&d.enable(19),g.dispersion&&d.enable(20),g.batchingColor&&d.enable(21),R.push(d.mask),d.disableAll(),g.fog&&d.enable(0),g.useFog&&d.enable(1),g.flatShading&&d.enable(2),g.logarithmicDepthBuffer&&d.enable(3),g.reverseDepthBuffer&&d.enable(4),g.skinning&&d.enable(5),g.morphTargets&&d.enable(6),g.morphNormals&&d.enable(7),g.morphColors&&d.enable(8),g.premultipliedAlpha&&d.enable(9),g.shadowMapEnabled&&d.enable(10),g.doubleSided&&d.enable(11),g.flipSided&&d.enable(12),g.useDepthPacking&&d.enable(13),g.dithering&&d.enable(14),g.transmission&&d.enable(15),g.sheen&&d.enable(16),g.opaque&&d.enable(17),g.pointsUvs&&d.enable(18),g.decodeVideoTexture&&d.enable(19),g.decodeVideoTextureEmissive&&d.enable(20),g.alphaToCoverage&&d.enable(21),R.push(d.mask)}function X(R){const g=p[R.type];let Y;if(g){const Q=Pe[g];Y=To.clone(Q.uniforms)}else Y=R.uniforms;return Y}function M(R,g){let Y;for(let Q=0,w=m.length;Q<w;Q++){const E=m[Q];if(E.cacheKey===g){Y=E,++Y.usedTimes;break}}return Y===void 0&&(Y=new ub(l,g,R,s),m.push(Y)),Y}function I(R){if(--R.usedTimes===0){const g=m.indexOf(R);m[g]=m[m.length-1],m.pop(),R.destroy()}}function x(R){c.remove(R)}function U(){c.dispose()}return{getParameters:r,getProgramCacheKey:u,getUniforms:X,acquireProgram:M,releaseProgram:I,releaseShaderCache:x,programs:m,dispose:U}}function Vb(){let l=new WeakMap;function t(a){return l.has(a)}function e(a){let d=l.get(a);return d===void 0&&(d={},l.set(a,d)),d}function n(a){l.delete(a)}function i(a,d,c){l.get(a)[d]=c}function s(){l=new WeakMap}return{has:t,get:e,remove:n,update:i,dispose:s}}function Xb(l,t){return l.groupOrder!==t.groupOrder?l.groupOrder-t.groupOrder:l.renderOrder!==t.renderOrder?l.renderOrder-t.renderOrder:l.material.id!==t.material.id?l.material.id-t.material.id:l.z!==t.z?l.z-t.z:l.id-t.id}function Nd(l,t){return l.groupOrder!==t.groupOrder?l.groupOrder-t.groupOrder:l.renderOrder!==t.renderOrder?l.renderOrder-t.renderOrder:l.z!==t.z?t.z-l.z:l.id-t.id}function fd(){const l=[];let t=0;const e=[],n=[],i=[];function s(){t=0,e.length=0,n.length=0,i.length=0}function a(Z,b,h,p,W,r){let u=l[t];return u===void 0?(u={id:Z.id,object:Z,geometry:b,material:h,groupOrder:p,renderOrder:Z.renderOrder,z:W,group:r},l[t]=u):(u.id=Z.id,u.object=Z,u.geometry=b,u.material=h,u.groupOrder=p,u.renderOrder=Z.renderOrder,u.z=W,u.group=r),t++,u}function d(Z,b,h,p,W,r){const u=a(Z,b,h,p,W,r);h.transmission>0?n.push(u):h.transparent===!0?i.push(u):e.push(u)}function c(Z,b,h,p,W,r){const u=a(Z,b,h,p,W,r);h.transmission>0?n.unshift(u):h.transparent===!0?i.unshift(u):e.unshift(u)}function o(Z,b){e.length>1&&e.sort(Z||Xb),n.length>1&&n.sort(b||Nd),i.length>1&&i.sort(b||Nd)}function m(){for(let Z=t,b=l.length;Z<b;Z++){const h=l[Z];if(h.id===null)break;h.id=null,h.object=null,h.geometry=null,h.material=null,h.group=null}}return{opaque:e,transmissive:n,transparent:i,init:s,push:d,unshift:c,finish:m,sort:o}}function gb(){let l=new WeakMap;function t(n,i){const s=l.get(n);let a;return s===void 0?(a=new fd,l.set(n,[a])):i>=s.length?(a=new fd,s.push(a)):a=s[i],a}function e(){l=new WeakMap}return{get:t,dispose:e}}function Rb(){const l={};return{get:function(t){if(l[t.id]!==void 0)return l[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new k,color:new Kt};break;case"SpotLight":e={position:new k,direction:new k,color:new Kt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new k,color:new Kt,distance:0,decay:0};break;case"HemisphereLight":e={direction:new k,skyColor:new Kt,groundColor:new Kt};break;case"RectAreaLight":e={color:new Kt,position:new k,halfWidth:new k,halfHeight:new k};break}return l[t.id]=e,e}}}function yb(){const l={};return{get:function(t){if(l[t.id]!==void 0)return l[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Lt};break;case"SpotLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Lt};break;case"PointLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Lt,shadowCameraNear:1,shadowCameraFar:1e3};break}return l[t.id]=e,e}}}let Cb=0;function Sb(l,t){return(t.castShadow?2:0)-(l.castShadow?2:0)+(t.map?1:0)-(l.map?1:0)}function Ib(l){const t=new Rb,e=yb(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let o=0;o<9;o++)n.probe.push(new k);const i=new k,s=new ie,a=new ie;function d(o){let m=0,Z=0,b=0;for(let R=0;R<9;R++)n.probe[R].set(0,0,0);let h=0,p=0,W=0,r=0,u=0,S=0,C=0,X=0,M=0,I=0,x=0;o.sort(Sb);for(let R=0,g=o.length;R<g;R++){const Y=o[R],Q=Y.color,w=Y.intensity,E=Y.distance,_=Y.shadow&&Y.shadow.map?Y.shadow.map.texture:null;if(Y.isAmbientLight)m+=Q.r*w,Z+=Q.g*w,b+=Q.b*w;else if(Y.isLightProbe){for(let K=0;K<9;K++)n.probe[K].addScaledVector(Y.sh.coefficients[K],w);x++}else if(Y.isDirectionalLight){const K=t.get(Y);if(K.color.copy(Y.color).multiplyScalar(Y.intensity),Y.castShadow){const $=Y.shadow,z=e.get(Y);z.shadowIntensity=$.intensity,z.shadowBias=$.bias,z.shadowNormalBias=$.normalBias,z.shadowRadius=$.radius,z.shadowMapSize=$.mapSize,n.directionalShadow[h]=z,n.directionalShadowMap[h]=_,n.directionalShadowMatrix[h]=Y.shadow.matrix,S++}n.directional[h]=K,h++}else if(Y.isSpotLight){const K=t.get(Y);K.position.setFromMatrixPosition(Y.matrixWorld),K.color.copy(Q).multiplyScalar(w),K.distance=E,K.coneCos=Math.cos(Y.angle),K.penumbraCos=Math.cos(Y.angle*(1-Y.penumbra)),K.decay=Y.decay,n.spot[W]=K;const $=Y.shadow;if(Y.map&&(n.spotLightMap[M]=Y.map,M++,$.updateMatrices(Y),Y.castShadow&&I++),n.spotLightMatrix[W]=$.matrix,Y.castShadow){const z=e.get(Y);z.shadowIntensity=$.intensity,z.shadowBias=$.bias,z.shadowNormalBias=$.normalBias,z.shadowRadius=$.radius,z.shadowMapSize=$.mapSize,n.spotShadow[W]=z,n.spotShadowMap[W]=_,X++}W++}else if(Y.isRectAreaLight){const K=t.get(Y);K.color.copy(Q).multiplyScalar(w),K.halfWidth.set(Y.width*.5,0,0),K.halfHeight.set(0,Y.height*.5,0),n.rectArea[r]=K,r++}else if(Y.isPointLight){const K=t.get(Y);if(K.color.copy(Y.color).multiplyScalar(Y.intensity),K.distance=Y.distance,K.decay=Y.decay,Y.castShadow){const $=Y.shadow,z=e.get(Y);z.shadowIntensity=$.intensity,z.shadowBias=$.bias,z.shadowNormalBias=$.normalBias,z.shadowRadius=$.radius,z.shadowMapSize=$.mapSize,z.shadowCameraNear=$.camera.near,z.shadowCameraFar=$.camera.far,n.pointShadow[p]=z,n.pointShadowMap[p]=_,n.pointShadowMatrix[p]=Y.shadow.matrix,C++}n.point[p]=K,p++}else if(Y.isHemisphereLight){const K=t.get(Y);K.skyColor.copy(Y.color).multiplyScalar(w),K.groundColor.copy(Y.groundColor).multiplyScalar(w),n.hemi[u]=K,u++}}r>0&&(l.has("OES_texture_float_linear")===!0?(n.rectAreaLTC1=et.LTC_FLOAT_1,n.rectAreaLTC2=et.LTC_FLOAT_2):(n.rectAreaLTC1=et.LTC_HALF_1,n.rectAreaLTC2=et.LTC_HALF_2)),n.ambient[0]=m,n.ambient[1]=Z,n.ambient[2]=b;const U=n.hash;(U.directionalLength!==h||U.pointLength!==p||U.spotLength!==W||U.rectAreaLength!==r||U.hemiLength!==u||U.numDirectionalShadows!==S||U.numPointShadows!==C||U.numSpotShadows!==X||U.numSpotMaps!==M||U.numLightProbes!==x)&&(n.directional.length=h,n.spot.length=W,n.rectArea.length=r,n.point.length=p,n.hemi.length=u,n.directionalShadow.length=S,n.directionalShadowMap.length=S,n.pointShadow.length=C,n.pointShadowMap.length=C,n.spotShadow.length=X,n.spotShadowMap.length=X,n.directionalShadowMatrix.length=S,n.pointShadowMatrix.length=C,n.spotLightMatrix.length=X+M-I,n.spotLightMap.length=M,n.numSpotLightShadowsWithMaps=I,n.numLightProbes=x,U.directionalLength=h,U.pointLength=p,U.spotLength=W,U.rectAreaLength=r,U.hemiLength=u,U.numDirectionalShadows=S,U.numPointShadows=C,U.numSpotShadows=X,U.numSpotMaps=M,U.numLightProbes=x,n.version=Cb++)}function c(o,m){let Z=0,b=0,h=0,p=0,W=0;const r=m.matrixWorldInverse;for(let u=0,S=o.length;u<S;u++){const C=o[u];if(C.isDirectionalLight){const X=n.directional[Z];X.direction.setFromMatrixPosition(C.matrixWorld),i.setFromMatrixPosition(C.target.matrixWorld),X.direction.sub(i),X.direction.transformDirection(r),Z++}else if(C.isSpotLight){const X=n.spot[h];X.position.setFromMatrixPosition(C.matrixWorld),X.position.applyMatrix4(r),X.direction.setFromMatrixPosition(C.matrixWorld),i.setFromMatrixPosition(C.target.matrixWorld),X.direction.sub(i),X.direction.transformDirection(r),h++}else if(C.isRectAreaLight){const X=n.rectArea[p];X.position.setFromMatrixPosition(C.matrixWorld),X.position.applyMatrix4(r),a.identity(),s.copy(C.matrixWorld),s.premultiply(r),a.extractRotation(s),X.halfWidth.set(C.width*.5,0,0),X.halfHeight.set(0,C.height*.5,0),X.halfWidth.applyMatrix4(a),X.halfHeight.applyMatrix4(a),p++}else if(C.isPointLight){const X=n.point[b];X.position.setFromMatrixPosition(C.matrixWorld),X.position.applyMatrix4(r),b++}else if(C.isHemisphereLight){const X=n.hemi[W];X.direction.setFromMatrixPosition(C.matrixWorld),X.direction.transformDirection(r),W++}}}return{setup:d,setupView:c,state:n}}function Fd(l){const t=new Ib(l),e=[],n=[];function i(m){o.camera=m,e.length=0,n.length=0}function s(m){e.push(m)}function a(m){n.push(m)}function d(){t.setup(e)}function c(m){t.setupView(e,m)}const o={lightsArray:e,shadowsArray:n,camera:null,lights:t,transmissionRenderTarget:{}};return{init:i,state:o,setupLights:d,setupLightsView:c,pushLight:s,pushShadow:a}}function xb(l){let t=new WeakMap;function e(i,s=0){const a=t.get(i);let d;return a===void 0?(d=new Fd(l),t.set(i,[d])):s>=a.length?(d=new Fd(l),a.push(d)):d=a[s],d}function n(){t=new WeakMap}return{get:e,dispose:n}}class Yb extends xn{static get type(){return"MeshDepthMaterial"}constructor(t){super(),this.isMeshDepthMaterial=!0,this.depthPacking=zc,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class Nb extends xn{static get type(){return"MeshDistanceMaterial"}constructor(t){super(),this.isMeshDistanceMaterial=!0,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}const fb=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,Fb=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function Lb(l,t,e){let n=new ed;const i=new Lt,s=new Lt,a=new ne,d=new Yb({depthPacking:Kc}),c=new Nb,o={},m=e.maxTextureSize,Z={[ol]:Re,[Re]:ol,[Oe]:Oe},b=new he({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Lt},radius:{value:4}},vertexShader:fb,fragmentShader:Fb}),h=b.clone();h.defines.HORIZONTAL_PASS=1;const p=new Le;p.setAttribute("position",new Ce(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const W=new ae(p,b),r=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=is;let u=this.type;this.render=function(I,x,U){if(r.enabled===!1||r.autoUpdate===!1&&r.needsUpdate===!1||I.length===0)return;const R=l.getRenderTarget(),g=l.getActiveCubeFace(),Y=l.getActiveMipmapLevel(),Q=l.state;Q.setBlending(ml),Q.buffers.color.setClear(1,1,1,1),Q.buffers.depth.setTest(!0),Q.setScissorTest(!1);const w=u!==_e&&this.type===_e,E=u===_e&&this.type!==_e;for(let _=0,K=I.length;_<K;_++){const $=I[_],z=$.shadow;if(z===void 0){console.warn("THREE.WebGLShadowMap:",$,"has no shadow.");continue}if(z.autoUpdate===!1&&z.needsUpdate===!1)continue;i.copy(z.mapSize);const nt=z.getFrameExtents();if(i.multiply(nt),s.copy(z.mapSize),(i.x>m||i.y>m)&&(i.x>m&&(s.x=Math.floor(m/nt.x),i.x=s.x*nt.x,z.mapSize.x=s.x),i.y>m&&(s.y=Math.floor(m/nt.y),i.y=s.y*nt.y,z.mapSize.y=s.y)),z.map===null||w===!0||E===!0){const Vt=this.type!==_e?{minFilter:Te,magFilter:Te}:{};z.map!==null&&z.map.dispose(),z.map=new bl(i.x,i.y,Vt),z.map.texture.name=$.name+".shadowMap",z.camera.updateProjectionMatrix()}l.setRenderTarget(z.map),l.clear();const ot=z.getViewportCount();for(let Vt=0;Vt<ot;Vt++){const Ut=z.getViewport(Vt);a.set(s.x*Ut.x,s.y*Ut.y,s.x*Ut.z,s.y*Ut.w),Q.viewport(a),z.updateMatrices($,Vt),n=z.getFrustum(),X(x,U,z.camera,$,this.type)}z.isPointLightShadow!==!0&&this.type===_e&&S(z,U),z.needsUpdate=!1}u=this.type,r.needsUpdate=!1,l.setRenderTarget(R,g,Y)};function S(I,x){const U=t.update(W);b.defines.VSM_SAMPLES!==I.blurSamples&&(b.defines.VSM_SAMPLES=I.blurSamples,h.defines.VSM_SAMPLES=I.blurSamples,b.needsUpdate=!0,h.needsUpdate=!0),I.mapPass===null&&(I.mapPass=new bl(i.x,i.y)),b.uniforms.shadow_pass.value=I.map.texture,b.uniforms.resolution.value=I.mapSize,b.uniforms.radius.value=I.radius,l.setRenderTarget(I.mapPass),l.clear(),l.renderBufferDirect(x,null,U,b,W,null),h.uniforms.shadow_pass.value=I.mapPass.texture,h.uniforms.resolution.value=I.mapSize,h.uniforms.radius.value=I.radius,l.setRenderTarget(I.map),l.clear(),l.renderBufferDirect(x,null,U,h,W,null)}function C(I,x,U,R){let g=null;const Y=U.isPointLight===!0?I.customDistanceMaterial:I.customDepthMaterial;if(Y!==void 0)g=Y;else if(g=U.isPointLight===!0?c:d,l.localClippingEnabled&&x.clipShadows===!0&&Array.isArray(x.clippingPlanes)&&x.clippingPlanes.length!==0||x.displacementMap&&x.displacementScale!==0||x.alphaMap&&x.alphaTest>0||x.map&&x.alphaTest>0){const Q=g.uuid,w=x.uuid;let E=o[Q];E===void 0&&(E={},o[Q]=E);let _=E[w];_===void 0&&(_=g.clone(),E[w]=_,x.addEventListener("dispose",M)),g=_}if(g.visible=x.visible,g.wireframe=x.wireframe,R===_e?g.side=x.shadowSide!==null?x.shadowSide:x.side:g.side=x.shadowSide!==null?x.shadowSide:Z[x.side],g.alphaMap=x.alphaMap,g.alphaTest=x.alphaTest,g.map=x.map,g.clipShadows=x.clipShadows,g.clippingPlanes=x.clippingPlanes,g.clipIntersection=x.clipIntersection,g.displacementMap=x.displacementMap,g.displacementScale=x.displacementScale,g.displacementBias=x.displacementBias,g.wireframeLinewidth=x.wireframeLinewidth,g.linewidth=x.linewidth,U.isPointLight===!0&&g.isMeshDistanceMaterial===!0){const Q=l.properties.get(g);Q.light=U}return g}function X(I,x,U,R,g){if(I.visible===!1)return;if(I.layers.test(x.layers)&&(I.isMesh||I.isLine||I.isPoints)&&(I.castShadow||I.receiveShadow&&g===_e)&&(!I.frustumCulled||n.intersectsObject(I))){I.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse,I.matrixWorld);const w=t.update(I),E=I.material;if(Array.isArray(E)){const _=w.groups;for(let K=0,$=_.length;K<$;K++){const z=_[K],nt=E[z.materialIndex];if(nt&&nt.visible){const ot=C(I,nt,R,g);I.onBeforeShadow(l,I,x,U,w,ot,z),l.renderBufferDirect(U,null,w,ot,I,z),I.onAfterShadow(l,I,x,U,w,ot,z)}}}else if(E.visible){const _=C(I,E,R,g);I.onBeforeShadow(l,I,x,U,w,_,null),l.renderBufferDirect(U,null,w,_,I,null),I.onAfterShadow(l,I,x,U,w,_,null)}}const Q=I.children;for(let w=0,E=Q.length;w<E;w++)X(Q[w],x,U,R,g)}function M(I){I.target.removeEventListener("dispose",M);for(const U in o){const R=o[U],g=I.target.uuid;g in R&&(R[g].dispose(),delete R[g])}}}const Ub={[xi]:Yi,[Ni]:Li,[fi]:Ui,[kl]:Fi,[Yi]:xi,[Li]:Ni,[Ui]:fi,[Fi]:kl};function Mb(l,t){function e(){let N=!1;const lt=new ne;let H=null;const j=new ne(0,0,0,0);return{setMask:function(ct){H!==ct&&!N&&(l.colorMask(ct,ct,ct,ct),H=ct)},setLocked:function(ct){N=ct},setClear:function(ct,st,Yt,le,Ge){Ge===!0&&(ct*=le,st*=le,Yt*=le),lt.set(ct,st,Yt,le),j.equals(lt)===!1&&(l.clearColor(ct,st,Yt,le),j.copy(lt))},reset:function(){N=!1,H=null,j.set(-1,0,0,0)}}}function n(){let N=!1,lt=!1,H=null,j=null,ct=null;return{setReversed:function(st){if(lt!==st){const Yt=t.get("EXT_clip_control");lt?Yt.clipControlEXT(Yt.LOWER_LEFT_EXT,Yt.ZERO_TO_ONE_EXT):Yt.clipControlEXT(Yt.LOWER_LEFT_EXT,Yt.NEGATIVE_ONE_TO_ONE_EXT);const le=ct;ct=null,this.setClear(le)}lt=st},getReversed:function(){return lt},setTest:function(st){st?it(l.DEPTH_TEST):yt(l.DEPTH_TEST)},setMask:function(st){H!==st&&!N&&(l.depthMask(st),H=st)},setFunc:function(st){if(lt&&(st=Ub[st]),j!==st){switch(st){case xi:l.depthFunc(l.NEVER);break;case Yi:l.depthFunc(l.ALWAYS);break;case Ni:l.depthFunc(l.LESS);break;case kl:l.depthFunc(l.LEQUAL);break;case fi:l.depthFunc(l.EQUAL);break;case Fi:l.depthFunc(l.GEQUAL);break;case Li:l.depthFunc(l.GREATER);break;case Ui:l.depthFunc(l.NOTEQUAL);break;default:l.depthFunc(l.LEQUAL)}j=st}},setLocked:function(st){N=st},setClear:function(st){ct!==st&&(lt&&(st=1-st),l.clearDepth(st),ct=st)},reset:function(){N=!1,H=null,j=null,ct=null,lt=!1}}}function i(){let N=!1,lt=null,H=null,j=null,ct=null,st=null,Yt=null,le=null,Ge=null;return{setTest:function(At){N||(At?it(l.STENCIL_TEST):yt(l.STENCIL_TEST))},setMask:function(At){lt!==At&&!N&&(l.stencilMask(At),lt=At)},setFunc:function(At,Ke,dl){(H!==At||j!==Ke||ct!==dl)&&(l.stencilFunc(At,Ke,dl),H=At,j=Ke,ct=dl)},setOp:function(At,Ke,dl){(st!==At||Yt!==Ke||le!==dl)&&(l.stencilOp(At,Ke,dl),st=At,Yt=Ke,le=dl)},setLocked:function(At){N=At},setClear:function(At){Ge!==At&&(l.clearStencil(At),Ge=At)},reset:function(){N=!1,lt=null,H=null,j=null,ct=null,st=null,Yt=null,le=null,Ge=null}}}const s=new e,a=new n,d=new i,c=new WeakMap,o=new WeakMap;let m={},Z={},b=new WeakMap,h=[],p=null,W=!1,r=null,u=null,S=null,C=null,X=null,M=null,I=null,x=new Kt(0,0,0),U=0,R=!1,g=null,Y=null,Q=null,w=null,E=null;const _=l.getParameter(l.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let K=!1,$=0;const z=l.getParameter(l.VERSION);z.indexOf("WebGL")!==-1?($=parseFloat(/^WebGL (\d)/.exec(z)[1]),K=$>=1):z.indexOf("OpenGL ES")!==-1&&($=parseFloat(/^OpenGL ES (\d)/.exec(z)[1]),K=$>=2);let nt=null,ot={};const Vt=l.getParameter(l.SCISSOR_BOX),Ut=l.getParameter(l.VIEWPORT),Pt=new ne().fromArray(Vt),A=new ne().fromArray(Ut);function tt(N,lt,H,j){const ct=new Uint8Array(4),st=l.createTexture();l.bindTexture(N,st),l.texParameteri(N,l.TEXTURE_MIN_FILTER,l.NEAREST),l.texParameteri(N,l.TEXTURE_MAG_FILTER,l.NEAREST);for(let Yt=0;Yt<H;Yt++)N===l.TEXTURE_3D||N===l.TEXTURE_2D_ARRAY?l.texImage3D(lt,0,l.RGBA,1,1,j,0,l.RGBA,l.UNSIGNED_BYTE,ct):l.texImage2D(lt+Yt,0,l.RGBA,1,1,0,l.RGBA,l.UNSIGNED_BYTE,ct);return st}const pt={};pt[l.TEXTURE_2D]=tt(l.TEXTURE_2D,l.TEXTURE_2D,1),pt[l.TEXTURE_CUBE_MAP]=tt(l.TEXTURE_CUBE_MAP,l.TEXTURE_CUBE_MAP_POSITIVE_X,6),pt[l.TEXTURE_2D_ARRAY]=tt(l.TEXTURE_2D_ARRAY,l.TEXTURE_2D_ARRAY,1,1),pt[l.TEXTURE_3D]=tt(l.TEXTURE_3D,l.TEXTURE_3D,1,1),s.setClear(0,0,0,1),a.setClear(1),d.setClear(0),it(l.DEPTH_TEST),a.setFunc(kl),Tt(!1),Jt(ns),it(l.CULL_FACE),L(ml);function it(N){m[N]!==!0&&(l.enable(N),m[N]=!0)}function yt(N){m[N]!==!1&&(l.disable(N),m[N]=!1)}function It(N,lt){return Z[N]!==lt?(l.bindFramebuffer(N,lt),Z[N]=lt,N===l.DRAW_FRAMEBUFFER&&(Z[l.FRAMEBUFFER]=lt),N===l.FRAMEBUFFER&&(Z[l.DRAW_FRAMEBUFFER]=lt),!0):!1}function Mt(N,lt){let H=h,j=!1;if(N){H=b.get(lt),H===void 0&&(H=[],b.set(lt,H));const ct=N.textures;if(H.length!==ct.length||H[0]!==l.COLOR_ATTACHMENT0){for(let st=0,Yt=ct.length;st<Yt;st++)H[st]=l.COLOR_ATTACHMENT0+st;H.length=ct.length,j=!0}}else H[0]!==l.BACK&&(H[0]=l.BACK,j=!0);j&&l.drawBuffers(H)}function te(N){return p!==N?(l.useProgram(N),p=N,!0):!1}const wt={[Rl]:l.FUNC_ADD,[uc]:l.FUNC_SUBTRACT,[rc]:l.FUNC_REVERSE_SUBTRACT};wt[pc]=l.MIN,wt[Gc]=l.MAX;const se={[Wc]:l.ZERO,[Vc]:l.ONE,[Xc]:l.SRC_COLOR,[Si]:l.SRC_ALPHA,[Ic]:l.SRC_ALPHA_SATURATE,[Cc]:l.DST_COLOR,[Rc]:l.DST_ALPHA,[gc]:l.ONE_MINUS_SRC_COLOR,[Ii]:l.ONE_MINUS_SRC_ALPHA,[Sc]:l.ONE_MINUS_DST_COLOR,[yc]:l.ONE_MINUS_DST_ALPHA,[xc]:l.CONSTANT_COLOR,[Yc]:l.ONE_MINUS_CONSTANT_COLOR,[Nc]:l.CONSTANT_ALPHA,[fc]:l.ONE_MINUS_CONSTANT_ALPHA};function L(N,lt,H,j,ct,st,Yt,le,Ge,At){if(N===ml){W===!0&&(yt(l.BLEND),W=!1);return}if(W===!1&&(it(l.BLEND),W=!0),N!==bc){if(N!==r||At!==R){if((u!==Rl||X!==Rl)&&(l.blendEquation(l.FUNC_ADD),u=Rl,X=Rl),At)switch(N){case Ee:l.blendFuncSeparate(l.ONE,l.ONE_MINUS_SRC_ALPHA,l.ONE,l.ONE_MINUS_SRC_ALPHA);break;case Ae:l.blendFunc(l.ONE,l.ONE);break;case as:l.blendFuncSeparate(l.ZERO,l.ONE_MINUS_SRC_COLOR,l.ZERO,l.ONE);break;case ss:l.blendFuncSeparate(l.ZERO,l.SRC_COLOR,l.ZERO,l.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",N);break}else switch(N){case Ee:l.blendFuncSeparate(l.SRC_ALPHA,l.ONE_MINUS_SRC_ALPHA,l.ONE,l.ONE_MINUS_SRC_ALPHA);break;case Ae:l.blendFunc(l.SRC_ALPHA,l.ONE);break;case as:l.blendFuncSeparate(l.ZERO,l.ONE_MINUS_SRC_COLOR,l.ZERO,l.ONE);break;case ss:l.blendFunc(l.ZERO,l.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",N);break}S=null,C=null,M=null,I=null,x.set(0,0,0),U=0,r=N,R=At}return}ct=ct||lt,st=st||H,Yt=Yt||j,(lt!==u||ct!==X)&&(l.blendEquationSeparate(wt[lt],wt[ct]),u=lt,X=ct),(H!==S||j!==C||st!==M||Yt!==I)&&(l.blendFuncSeparate(se[H],se[j],se[st],se[Yt]),S=H,C=j,M=st,I=Yt),(le.equals(x)===!1||Ge!==U)&&(l.blendColor(le.r,le.g,le.b,Ge),x.copy(le),U=Ge),r=N,R=!1}function Ue(N,lt){N.side===Oe?yt(l.CULL_FACE):it(l.CULL_FACE);let H=N.side===Re;lt&&(H=!H),Tt(H),N.blending===Ee&&N.transparent===!1?L(ml):L(N.blending,N.blendEquation,N.blendSrc,N.blendDst,N.blendEquationAlpha,N.blendSrcAlpha,N.blendDstAlpha,N.blendColor,N.blendAlpha,N.premultipliedAlpha),a.setFunc(N.depthFunc),a.setTest(N.depthTest),a.setMask(N.depthWrite),s.setMask(N.colorWrite);const j=N.stencilWrite;d.setTest(j),j&&(d.setMask(N.stencilWriteMask),d.setFunc(N.stencilFunc,N.stencilRef,N.stencilFuncMask),d.setOp(N.stencilFail,N.stencilZFail,N.stencilZPass)),Ot(N.polygonOffset,N.polygonOffsetFactor,N.polygonOffsetUnits),N.alphaToCoverage===!0?it(l.SAMPLE_ALPHA_TO_COVERAGE):yt(l.SAMPLE_ALPHA_TO_COVERAGE)}function Tt(N){g!==N&&(N?l.frontFace(l.CW):l.frontFace(l.CCW),g=N)}function Jt(N){N!==mc?(it(l.CULL_FACE),N!==Y&&(N===ns?l.cullFace(l.BACK):N===Zc?l.cullFace(l.FRONT):l.cullFace(l.FRONT_AND_BACK))):yt(l.CULL_FACE),Y=N}function gt(N){N!==Q&&(K&&l.lineWidth(N),Q=N)}function Ot(N,lt,H){N?(it(l.POLYGON_OFFSET_FILL),(w!==lt||E!==H)&&(l.polygonOffset(lt,H),w=lt,E=H)):yt(l.POLYGON_OFFSET_FILL)}function Xt(N){N?it(l.SCISSOR_TEST):yt(l.SCISSOR_TEST)}function y(N){N===void 0&&(N=l.TEXTURE0+_-1),nt!==N&&(l.activeTexture(N),nt=N)}function G(N,lt,H){H===void 0&&(nt===null?H=l.TEXTURE0+_-1:H=nt);let j=ot[H];j===void 0&&(j={type:void 0,texture:void 0},ot[H]=j),(j.type!==N||j.texture!==lt)&&(nt!==H&&(l.activeTexture(H),nt=H),l.bindTexture(N,lt||pt[N]),j.type=N,j.texture=lt)}function T(){const N=ot[nt];N!==void 0&&N.type!==void 0&&(l.bindTexture(N.type,null),N.type=void 0,N.texture=void 0)}function P(){try{l.compressedTexImage2D.apply(l,arguments)}catch(N){console.error("THREE.WebGLState:",N)}}function D(){try{l.compressedTexImage3D.apply(l,arguments)}catch(N){console.error("THREE.WebGLState:",N)}}function B(){try{l.texSubImage2D.apply(l,arguments)}catch(N){console.error("THREE.WebGLState:",N)}}function Gt(){try{l.texSubImage3D.apply(l,arguments)}catch(N){console.error("THREE.WebGLState:",N)}}function at(){try{l.compressedTexSubImage2D.apply(l,arguments)}catch(N){console.error("THREE.WebGLState:",N)}}function mt(){try{l.compressedTexSubImage3D.apply(l,arguments)}catch(N){console.error("THREE.WebGLState:",N)}}function Ht(){try{l.texStorage2D.apply(l,arguments)}catch(N){console.error("THREE.WebGLState:",N)}}function O(){try{l.texStorage3D.apply(l,arguments)}catch(N){console.error("THREE.WebGLState:",N)}}function Zt(){try{l.texImage2D.apply(l,arguments)}catch(N){console.error("THREE.WebGLState:",N)}}function Rt(){try{l.texImage3D.apply(l,arguments)}catch(N){console.error("THREE.WebGLState:",N)}}function Ct(N){Pt.equals(N)===!1&&(l.scissor(N.x,N.y,N.z,N.w),Pt.copy(N))}function ht(N){A.equals(N)===!1&&(l.viewport(N.x,N.y,N.z,N.w),A.copy(N))}function vt(N,lt){let H=o.get(lt);H===void 0&&(H=new WeakMap,o.set(lt,H));let j=H.get(N);j===void 0&&(j=l.getUniformBlockIndex(lt,N.name),H.set(N,j))}function Ft(N,lt){const j=o.get(lt).get(N);c.get(lt)!==j&&(l.uniformBlockBinding(lt,j,N.__bindingPointIndex),c.set(lt,j))}function Dt(){l.disable(l.BLEND),l.disable(l.CULL_FACE),l.disable(l.DEPTH_TEST),l.disable(l.POLYGON_OFFSET_FILL),l.disable(l.SCISSOR_TEST),l.disable(l.STENCIL_TEST),l.disable(l.SAMPLE_ALPHA_TO_COVERAGE),l.blendEquation(l.FUNC_ADD),l.blendFunc(l.ONE,l.ZERO),l.blendFuncSeparate(l.ONE,l.ZERO,l.ONE,l.ZERO),l.blendColor(0,0,0,0),l.colorMask(!0,!0,!0,!0),l.clearColor(0,0,0,0),l.depthMask(!0),l.depthFunc(l.LESS),a.setReversed(!1),l.clearDepth(1),l.stencilMask(4294967295),l.stencilFunc(l.ALWAYS,0,4294967295),l.stencilOp(l.KEEP,l.KEEP,l.KEEP),l.clearStencil(0),l.cullFace(l.BACK),l.frontFace(l.CCW),l.polygonOffset(0,0),l.activeTexture(l.TEXTURE0),l.bindFramebuffer(l.FRAMEBUFFER,null),l.bindFramebuffer(l.DRAW_FRAMEBUFFER,null),l.bindFramebuffer(l.READ_FRAMEBUFFER,null),l.useProgram(null),l.lineWidth(1),l.scissor(0,0,l.canvas.width,l.canvas.height),l.viewport(0,0,l.canvas.width,l.canvas.height),m={},nt=null,ot={},Z={},b=new WeakMap,h=[],p=null,W=!1,r=null,u=null,S=null,C=null,X=null,M=null,I=null,x=new Kt(0,0,0),U=0,R=!1,g=null,Y=null,Q=null,w=null,E=null,Pt.set(0,0,l.canvas.width,l.canvas.height),A.set(0,0,l.canvas.width,l.canvas.height),s.reset(),a.reset(),d.reset()}return{buffers:{color:s,depth:a,stencil:d},enable:it,disable:yt,bindFramebuffer:It,drawBuffers:Mt,useProgram:te,setBlending:L,setMaterial:Ue,setFlipSided:Tt,setCullFace:Jt,setLineWidth:gt,setPolygonOffset:Ot,setScissorTest:Xt,activeTexture:y,bindTexture:G,unbindTexture:T,compressedTexImage2D:P,compressedTexImage3D:D,texImage2D:Zt,texImage3D:Rt,updateUBOMapping:vt,uniformBlockBinding:Ft,texStorage2D:Ht,texStorage3D:O,texSubImage2D:B,texSubImage3D:Gt,compressedTexSubImage2D:at,compressedTexSubImage3D:mt,scissor:Ct,viewport:ht,reset:Dt}}function Ld(l,t,e,n){const i=Tb(n);switch(e){case hs:return l*t;case us:return l*t;case rs:return l*t*2;case ps:return l*t/i.components*i.byteLength;case Ki:return l*t/i.components*i.byteLength;case Gs:return l*t*2/i.components*i.byteLength;case Bi:return l*t*2/i.components*i.byteLength;case bs:return l*t*3/i.components*i.byteLength;case Ne:return l*t*4/i.components*i.byteLength;case Ei:return l*t*4/i.components*i.byteLength;case vn:case kn:return Math.floor((l+3)/4)*Math.floor((t+3)/4)*8;case wn:case Hn:return Math.floor((l+3)/4)*Math.floor((t+3)/4)*16;case Qi:case ji:return Math.max(l,16)*Math.max(t,8)/4;case Ai:case Pi:return Math.max(l,8)*Math.max(t,8)/2;case Di:case _i:return Math.floor((l+3)/4)*Math.floor((t+3)/4)*8;case Oi:return Math.floor((l+3)/4)*Math.floor((t+3)/4)*16;case qi:return Math.floor((l+3)/4)*Math.floor((t+3)/4)*16;case $i:return Math.floor((l+4)/5)*Math.floor((t+3)/4)*16;case ta:return Math.floor((l+4)/5)*Math.floor((t+4)/5)*16;case ea:return Math.floor((l+5)/6)*Math.floor((t+4)/5)*16;case la:return Math.floor((l+5)/6)*Math.floor((t+5)/6)*16;case na:return Math.floor((l+7)/8)*Math.floor((t+4)/5)*16;case ia:return Math.floor((l+7)/8)*Math.floor((t+5)/6)*16;case aa:return Math.floor((l+7)/8)*Math.floor((t+7)/8)*16;case sa:return Math.floor((l+9)/10)*Math.floor((t+4)/5)*16;case da:return Math.floor((l+9)/10)*Math.floor((t+5)/6)*16;case ca:return Math.floor((l+9)/10)*Math.floor((t+7)/8)*16;case oa:return Math.floor((l+9)/10)*Math.floor((t+9)/10)*16;case ma:return Math.floor((l+11)/12)*Math.floor((t+9)/10)*16;case Za:return Math.floor((l+11)/12)*Math.floor((t+11)/12)*16;case zn:case ha:case ba:return Math.ceil(l/4)*Math.ceil(t/4)*16;case Ws:case ua:return Math.ceil(l/4)*Math.ceil(t/4)*8;case ra:case pa:return Math.ceil(l/4)*Math.ceil(t/4)*16}throw new Error(`Unable to determine texture byte length for ${e} format.`)}function Tb(l){switch(l){case Qe:case os:return{byteLength:1,components:1};case pn:case ms:case Gn:return{byteLength:2,components:1};case Hi:case zi:return{byteLength:2,components:4};case Sl:case wi:case qe:return{byteLength:4,components:1};case Zs:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${l}.`)}function Jb(l,t,e,n,i,s,a){const d=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,c=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),o=new Lt,m=new WeakMap;let Z;const b=new WeakMap;let h=!1;try{h=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function p(y,G){return h?new OffscreenCanvas(y,G):En("canvas")}function W(y,G,T){let P=1;const D=Xt(y);if((D.width>T||D.height>T)&&(P=T/Math.max(D.width,D.height)),P<1)if(typeof HTMLImageElement<"u"&&y instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&y instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&y instanceof ImageBitmap||typeof VideoFrame<"u"&&y instanceof VideoFrame){const B=Math.floor(P*D.width),Gt=Math.floor(P*D.height);Z===void 0&&(Z=p(B,Gt));const at=G?p(B,Gt):Z;return at.width=B,at.height=Gt,at.getContext("2d").drawImage(y,0,0,B,Gt),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+D.width+"x"+D.height+") to ("+B+"x"+Gt+")."),at}else return"data"in y&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+D.width+"x"+D.height+")."),y;return y}function r(y){return y.generateMipmaps}function u(y){l.generateMipmap(y)}function S(y){return y.isWebGLCubeRenderTarget?l.TEXTURE_CUBE_MAP:y.isWebGL3DRenderTarget?l.TEXTURE_3D:y.isWebGLArrayRenderTarget||y.isCompressedArrayTexture?l.TEXTURE_2D_ARRAY:l.TEXTURE_2D}function C(y,G,T,P,D=!1){if(y!==null){if(l[y]!==void 0)return l[y];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+y+"'")}let B=G;if(G===l.RED&&(T===l.FLOAT&&(B=l.R32F),T===l.HALF_FLOAT&&(B=l.R16F),T===l.UNSIGNED_BYTE&&(B=l.R8)),G===l.RED_INTEGER&&(T===l.UNSIGNED_BYTE&&(B=l.R8UI),T===l.UNSIGNED_SHORT&&(B=l.R16UI),T===l.UNSIGNED_INT&&(B=l.R32UI),T===l.BYTE&&(B=l.R8I),T===l.SHORT&&(B=l.R16I),T===l.INT&&(B=l.R32I)),G===l.RG&&(T===l.FLOAT&&(B=l.RG32F),T===l.HALF_FLOAT&&(B=l.RG16F),T===l.UNSIGNED_BYTE&&(B=l.RG8)),G===l.RG_INTEGER&&(T===l.UNSIGNED_BYTE&&(B=l.RG8UI),T===l.UNSIGNED_SHORT&&(B=l.RG16UI),T===l.UNSIGNED_INT&&(B=l.RG32UI),T===l.BYTE&&(B=l.RG8I),T===l.SHORT&&(B=l.RG16I),T===l.INT&&(B=l.RG32I)),G===l.RGB_INTEGER&&(T===l.UNSIGNED_BYTE&&(B=l.RGB8UI),T===l.UNSIGNED_SHORT&&(B=l.RGB16UI),T===l.UNSIGNED_INT&&(B=l.RGB32UI),T===l.BYTE&&(B=l.RGB8I),T===l.SHORT&&(B=l.RGB16I),T===l.INT&&(B=l.RGB32I)),G===l.RGBA_INTEGER&&(T===l.UNSIGNED_BYTE&&(B=l.RGBA8UI),T===l.UNSIGNED_SHORT&&(B=l.RGBA16UI),T===l.UNSIGNED_INT&&(B=l.RGBA32UI),T===l.BYTE&&(B=l.RGBA8I),T===l.SHORT&&(B=l.RGBA16I),T===l.INT&&(B=l.RGBA32I)),G===l.RGB&&T===l.UNSIGNED_INT_5_9_9_9_REV&&(B=l.RGB9_E5),G===l.RGBA){const Gt=D?Kn:kt.getTransfer(P);T===l.FLOAT&&(B=l.RGBA32F),T===l.HALF_FLOAT&&(B=l.RGBA16F),T===l.UNSIGNED_BYTE&&(B=Gt===Qt?l.SRGB8_ALPHA8:l.RGBA8),T===l.UNSIGNED_SHORT_4_4_4_4&&(B=l.RGBA4),T===l.UNSIGNED_SHORT_5_5_5_1&&(B=l.RGB5_A1)}return(B===l.R16F||B===l.R32F||B===l.RG16F||B===l.RG32F||B===l.RGBA16F||B===l.RGBA32F)&&t.get("EXT_color_buffer_float"),B}function X(y,G){let T;return y?G===null||G===Sl||G===zl?T=l.DEPTH24_STENCIL8:G===qe?T=l.DEPTH32F_STENCIL8:G===pn&&(T=l.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):G===null||G===Sl||G===zl?T=l.DEPTH_COMPONENT24:G===qe?T=l.DEPTH_COMPONENT32F:G===pn&&(T=l.DEPTH_COMPONENT16),T}function M(y,G){return r(y)===!0||y.isFramebufferTexture&&y.minFilter!==Te&&y.minFilter!==be?Math.log2(Math.max(G.width,G.height))+1:y.mipmaps!==void 0&&y.mipmaps.length>0?y.mipmaps.length:y.isCompressedTexture&&Array.isArray(y.image)?G.mipmaps.length:1}function I(y){const G=y.target;G.removeEventListener("dispose",I),U(G),G.isVideoTexture&&m.delete(G)}function x(y){const G=y.target;G.removeEventListener("dispose",x),g(G)}function U(y){const G=n.get(y);if(G.__webglInit===void 0)return;const T=y.source,P=b.get(T);if(P){const D=P[G.__cacheKey];D.usedTimes--,D.usedTimes===0&&R(y),Object.keys(P).length===0&&b.delete(T)}n.remove(y)}function R(y){const G=n.get(y);l.deleteTexture(G.__webglTexture);const T=y.source,P=b.get(T);delete P[G.__cacheKey],a.memory.textures--}function g(y){const G=n.get(y);if(y.depthTexture&&(y.depthTexture.dispose(),n.remove(y.depthTexture)),y.isWebGLCubeRenderTarget)for(let P=0;P<6;P++){if(Array.isArray(G.__webglFramebuffer[P]))for(let D=0;D<G.__webglFramebuffer[P].length;D++)l.deleteFramebuffer(G.__webglFramebuffer[P][D]);else l.deleteFramebuffer(G.__webglFramebuffer[P]);G.__webglDepthbuffer&&l.deleteRenderbuffer(G.__webglDepthbuffer[P])}else{if(Array.isArray(G.__webglFramebuffer))for(let P=0;P<G.__webglFramebuffer.length;P++)l.deleteFramebuffer(G.__webglFramebuffer[P]);else l.deleteFramebuffer(G.__webglFramebuffer);if(G.__webglDepthbuffer&&l.deleteRenderbuffer(G.__webglDepthbuffer),G.__webglMultisampledFramebuffer&&l.deleteFramebuffer(G.__webglMultisampledFramebuffer),G.__webglColorRenderbuffer)for(let P=0;P<G.__webglColorRenderbuffer.length;P++)G.__webglColorRenderbuffer[P]&&l.deleteRenderbuffer(G.__webglColorRenderbuffer[P]);G.__webglDepthRenderbuffer&&l.deleteRenderbuffer(G.__webglDepthRenderbuffer)}const T=y.textures;for(let P=0,D=T.length;P<D;P++){const B=n.get(T[P]);B.__webglTexture&&(l.deleteTexture(B.__webglTexture),a.memory.textures--),n.remove(T[P])}n.remove(y)}let Y=0;function Q(){Y=0}function w(){const y=Y;return y>=i.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+y+" texture units while this GPU supports only "+i.maxTextures),Y+=1,y}function E(y){const G=[];return G.push(y.wrapS),G.push(y.wrapT),G.push(y.wrapR||0),G.push(y.magFilter),G.push(y.minFilter),G.push(y.anisotropy),G.push(y.internalFormat),G.push(y.format),G.push(y.type),G.push(y.generateMipmaps),G.push(y.premultiplyAlpha),G.push(y.flipY),G.push(y.unpackAlignment),G.push(y.colorSpace),G.join()}function _(y,G){const T=n.get(y);if(y.isVideoTexture&&gt(y),y.isRenderTargetTexture===!1&&y.version>0&&T.__version!==y.version){const P=y.image;if(P===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(P.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{A(T,y,G);return}}e.bindTexture(l.TEXTURE_2D,T.__webglTexture,l.TEXTURE0+G)}function K(y,G){const T=n.get(y);if(y.version>0&&T.__version!==y.version){A(T,y,G);return}e.bindTexture(l.TEXTURE_2D_ARRAY,T.__webglTexture,l.TEXTURE0+G)}function $(y,G){const T=n.get(y);if(y.version>0&&T.__version!==y.version){A(T,y,G);return}e.bindTexture(l.TEXTURE_3D,T.__webglTexture,l.TEXTURE0+G)}function z(y,G){const T=n.get(y);if(y.version>0&&T.__version!==y.version){tt(T,y,G);return}e.bindTexture(l.TEXTURE_CUBE_MAP,T.__webglTexture,l.TEXTURE0+G)}const nt={[Ji]:l.REPEAT,[yl]:l.CLAMP_TO_EDGE,[vi]:l.MIRRORED_REPEAT},ot={[Te]:l.NEAREST,[Hc]:l.NEAREST_MIPMAP_NEAREST,[Jn]:l.NEAREST_MIPMAP_LINEAR,[be]:l.LINEAR,[ki]:l.LINEAR_MIPMAP_NEAREST,[Cl]:l.LINEAR_MIPMAP_LINEAR},Vt={[Ac]:l.NEVER,[Oc]:l.ALWAYS,[Qc]:l.LESS,[Xs]:l.LEQUAL,[Pc]:l.EQUAL,[_c]:l.GEQUAL,[jc]:l.GREATER,[Dc]:l.NOTEQUAL};function Ut(y,G){if(G.type===qe&&t.has("OES_texture_float_linear")===!1&&(G.magFilter===be||G.magFilter===ki||G.magFilter===Jn||G.magFilter===Cl||G.minFilter===be||G.minFilter===ki||G.minFilter===Jn||G.minFilter===Cl)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),l.texParameteri(y,l.TEXTURE_WRAP_S,nt[G.wrapS]),l.texParameteri(y,l.TEXTURE_WRAP_T,nt[G.wrapT]),(y===l.TEXTURE_3D||y===l.TEXTURE_2D_ARRAY)&&l.texParameteri(y,l.TEXTURE_WRAP_R,nt[G.wrapR]),l.texParameteri(y,l.TEXTURE_MAG_FILTER,ot[G.magFilter]),l.texParameteri(y,l.TEXTURE_MIN_FILTER,ot[G.minFilter]),G.compareFunction&&(l.texParameteri(y,l.TEXTURE_COMPARE_MODE,l.COMPARE_REF_TO_TEXTURE),l.texParameteri(y,l.TEXTURE_COMPARE_FUNC,Vt[G.compareFunction])),t.has("EXT_texture_filter_anisotropic")===!0){if(G.magFilter===Te||G.minFilter!==Jn&&G.minFilter!==Cl||G.type===qe&&t.has("OES_texture_float_linear")===!1)return;if(G.anisotropy>1||n.get(G).__currentAnisotropy){const T=t.get("EXT_texture_filter_anisotropic");l.texParameterf(y,T.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(G.anisotropy,i.getMaxAnisotropy())),n.get(G).__currentAnisotropy=G.anisotropy}}}function Pt(y,G){let T=!1;y.__webglInit===void 0&&(y.__webglInit=!0,G.addEventListener("dispose",I));const P=G.source;let D=b.get(P);D===void 0&&(D={},b.set(P,D));const B=E(G);if(B!==y.__cacheKey){D[B]===void 0&&(D[B]={texture:l.createTexture(),usedTimes:0},a.memory.textures++,T=!0),D[B].usedTimes++;const Gt=D[y.__cacheKey];Gt!==void 0&&(D[y.__cacheKey].usedTimes--,Gt.usedTimes===0&&R(G)),y.__cacheKey=B,y.__webglTexture=D[B].texture}return T}function A(y,G,T){let P=l.TEXTURE_2D;(G.isDataArrayTexture||G.isCompressedArrayTexture)&&(P=l.TEXTURE_2D_ARRAY),G.isData3DTexture&&(P=l.TEXTURE_3D);const D=Pt(y,G),B=G.source;e.bindTexture(P,y.__webglTexture,l.TEXTURE0+T);const Gt=n.get(B);if(B.version!==Gt.__version||D===!0){e.activeTexture(l.TEXTURE0+T);const at=kt.getPrimaries(kt.workingColorSpace),mt=G.colorSpace===hl?null:kt.getPrimaries(G.colorSpace),Ht=G.colorSpace===hl||at===mt?l.NONE:l.BROWSER_DEFAULT_WEBGL;l.pixelStorei(l.UNPACK_FLIP_Y_WEBGL,G.flipY),l.pixelStorei(l.UNPACK_PREMULTIPLY_ALPHA_WEBGL,G.premultiplyAlpha),l.pixelStorei(l.UNPACK_ALIGNMENT,G.unpackAlignment),l.pixelStorei(l.UNPACK_COLORSPACE_CONVERSION_WEBGL,Ht);let O=W(G.image,!1,i.maxTextureSize);O=Ot(G,O);const Zt=s.convert(G.format,G.colorSpace),Rt=s.convert(G.type);let Ct=C(G.internalFormat,Zt,Rt,G.colorSpace,G.isVideoTexture);Ut(P,G);let ht;const vt=G.mipmaps,Ft=G.isVideoTexture!==!0,Dt=Gt.__version===void 0||D===!0,N=B.dataReady,lt=M(G,O);if(G.isDepthTexture)Ct=X(G.format===Bl,G.type),Dt&&(Ft?e.texStorage2D(l.TEXTURE_2D,1,Ct,O.width,O.height):e.texImage2D(l.TEXTURE_2D,0,Ct,O.width,O.height,0,Zt,Rt,null));else if(G.isDataTexture)if(vt.length>0){Ft&&Dt&&e.texStorage2D(l.TEXTURE_2D,lt,Ct,vt[0].width,vt[0].height);for(let H=0,j=vt.length;H<j;H++)ht=vt[H],Ft?N&&e.texSubImage2D(l.TEXTURE_2D,H,0,0,ht.width,ht.height,Zt,Rt,ht.data):e.texImage2D(l.TEXTURE_2D,H,Ct,ht.width,ht.height,0,Zt,Rt,ht.data);G.generateMipmaps=!1}else Ft?(Dt&&e.texStorage2D(l.TEXTURE_2D,lt,Ct,O.width,O.height),N&&e.texSubImage2D(l.TEXTURE_2D,0,0,0,O.width,O.height,Zt,Rt,O.data)):e.texImage2D(l.TEXTURE_2D,0,Ct,O.width,O.height,0,Zt,Rt,O.data);else if(G.isCompressedTexture)if(G.isCompressedArrayTexture){Ft&&Dt&&e.texStorage3D(l.TEXTURE_2D_ARRAY,lt,Ct,vt[0].width,vt[0].height,O.depth);for(let H=0,j=vt.length;H<j;H++)if(ht=vt[H],G.format!==Ne)if(Zt!==null)if(Ft){if(N)if(G.layerUpdates.size>0){const ct=Ld(ht.width,ht.height,G.format,G.type);for(const st of G.layerUpdates){const Yt=ht.data.subarray(st*ct/ht.data.BYTES_PER_ELEMENT,(st+1)*ct/ht.data.BYTES_PER_ELEMENT);e.compressedTexSubImage3D(l.TEXTURE_2D_ARRAY,H,0,0,st,ht.width,ht.height,1,Zt,Yt)}G.clearLayerUpdates()}else e.compressedTexSubImage3D(l.TEXTURE_2D_ARRAY,H,0,0,0,ht.width,ht.height,O.depth,Zt,ht.data)}else e.compressedTexImage3D(l.TEXTURE_2D_ARRAY,H,Ct,ht.width,ht.height,O.depth,0,ht.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else Ft?N&&e.texSubImage3D(l.TEXTURE_2D_ARRAY,H,0,0,0,ht.width,ht.height,O.depth,Zt,Rt,ht.data):e.texImage3D(l.TEXTURE_2D_ARRAY,H,Ct,ht.width,ht.height,O.depth,0,Zt,Rt,ht.data)}else{Ft&&Dt&&e.texStorage2D(l.TEXTURE_2D,lt,Ct,vt[0].width,vt[0].height);for(let H=0,j=vt.length;H<j;H++)ht=vt[H],G.format!==Ne?Zt!==null?Ft?N&&e.compressedTexSubImage2D(l.TEXTURE_2D,H,0,0,ht.width,ht.height,Zt,ht.data):e.compressedTexImage2D(l.TEXTURE_2D,H,Ct,ht.width,ht.height,0,ht.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Ft?N&&e.texSubImage2D(l.TEXTURE_2D,H,0,0,ht.width,ht.height,Zt,Rt,ht.data):e.texImage2D(l.TEXTURE_2D,H,Ct,ht.width,ht.height,0,Zt,Rt,ht.data)}else if(G.isDataArrayTexture)if(Ft){if(Dt&&e.texStorage3D(l.TEXTURE_2D_ARRAY,lt,Ct,O.width,O.height,O.depth),N)if(G.layerUpdates.size>0){const H=Ld(O.width,O.height,G.format,G.type);for(const j of G.layerUpdates){const ct=O.data.subarray(j*H/O.data.BYTES_PER_ELEMENT,(j+1)*H/O.data.BYTES_PER_ELEMENT);e.texSubImage3D(l.TEXTURE_2D_ARRAY,0,0,0,j,O.width,O.height,1,Zt,Rt,ct)}G.clearLayerUpdates()}else e.texSubImage3D(l.TEXTURE_2D_ARRAY,0,0,0,0,O.width,O.height,O.depth,Zt,Rt,O.data)}else e.texImage3D(l.TEXTURE_2D_ARRAY,0,Ct,O.width,O.height,O.depth,0,Zt,Rt,O.data);else if(G.isData3DTexture)Ft?(Dt&&e.texStorage3D(l.TEXTURE_3D,lt,Ct,O.width,O.height,O.depth),N&&e.texSubImage3D(l.TEXTURE_3D,0,0,0,0,O.width,O.height,O.depth,Zt,Rt,O.data)):e.texImage3D(l.TEXTURE_3D,0,Ct,O.width,O.height,O.depth,0,Zt,Rt,O.data);else if(G.isFramebufferTexture){if(Dt)if(Ft)e.texStorage2D(l.TEXTURE_2D,lt,Ct,O.width,O.height);else{let H=O.width,j=O.height;for(let ct=0;ct<lt;ct++)e.texImage2D(l.TEXTURE_2D,ct,Ct,H,j,0,Zt,Rt,null),H>>=1,j>>=1}}else if(vt.length>0){if(Ft&&Dt){const H=Xt(vt[0]);e.texStorage2D(l.TEXTURE_2D,lt,Ct,H.width,H.height)}for(let H=0,j=vt.length;H<j;H++)ht=vt[H],Ft?N&&e.texSubImage2D(l.TEXTURE_2D,H,0,0,Zt,Rt,ht):e.texImage2D(l.TEXTURE_2D,H,Ct,Zt,Rt,ht);G.generateMipmaps=!1}else if(Ft){if(Dt){const H=Xt(O);e.texStorage2D(l.TEXTURE_2D,lt,Ct,H.width,H.height)}N&&e.texSubImage2D(l.TEXTURE_2D,0,0,0,Zt,Rt,O)}else e.texImage2D(l.TEXTURE_2D,0,Ct,Zt,Rt,O);r(G)&&u(P),Gt.__version=B.version,G.onUpdate&&G.onUpdate(G)}y.__version=G.version}function tt(y,G,T){if(G.image.length!==6)return;const P=Pt(y,G),D=G.source;e.bindTexture(l.TEXTURE_CUBE_MAP,y.__webglTexture,l.TEXTURE0+T);const B=n.get(D);if(D.version!==B.__version||P===!0){e.activeTexture(l.TEXTURE0+T);const Gt=kt.getPrimaries(kt.workingColorSpace),at=G.colorSpace===hl?null:kt.getPrimaries(G.colorSpace),mt=G.colorSpace===hl||Gt===at?l.NONE:l.BROWSER_DEFAULT_WEBGL;l.pixelStorei(l.UNPACK_FLIP_Y_WEBGL,G.flipY),l.pixelStorei(l.UNPACK_PREMULTIPLY_ALPHA_WEBGL,G.premultiplyAlpha),l.pixelStorei(l.UNPACK_ALIGNMENT,G.unpackAlignment),l.pixelStorei(l.UNPACK_COLORSPACE_CONVERSION_WEBGL,mt);const Ht=G.isCompressedTexture||G.image[0].isCompressedTexture,O=G.image[0]&&G.image[0].isDataTexture,Zt=[];for(let j=0;j<6;j++)!Ht&&!O?Zt[j]=W(G.image[j],!0,i.maxCubemapSize):Zt[j]=O?G.image[j].image:G.image[j],Zt[j]=Ot(G,Zt[j]);const Rt=Zt[0],Ct=s.convert(G.format,G.colorSpace),ht=s.convert(G.type),vt=C(G.internalFormat,Ct,ht,G.colorSpace),Ft=G.isVideoTexture!==!0,Dt=B.__version===void 0||P===!0,N=D.dataReady;let lt=M(G,Rt);Ut(l.TEXTURE_CUBE_MAP,G);let H;if(Ht){Ft&&Dt&&e.texStorage2D(l.TEXTURE_CUBE_MAP,lt,vt,Rt.width,Rt.height);for(let j=0;j<6;j++){H=Zt[j].mipmaps;for(let ct=0;ct<H.length;ct++){const st=H[ct];G.format!==Ne?Ct!==null?Ft?N&&e.compressedTexSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct,0,0,st.width,st.height,Ct,st.data):e.compressedTexImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct,vt,st.width,st.height,0,st.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Ft?N&&e.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct,0,0,st.width,st.height,Ct,ht,st.data):e.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct,vt,st.width,st.height,0,Ct,ht,st.data)}}}else{if(H=G.mipmaps,Ft&&Dt){H.length>0&&lt++;const j=Xt(Zt[0]);e.texStorage2D(l.TEXTURE_CUBE_MAP,lt,vt,j.width,j.height)}for(let j=0;j<6;j++)if(O){Ft?N&&e.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,0,0,0,Zt[j].width,Zt[j].height,Ct,ht,Zt[j].data):e.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,0,vt,Zt[j].width,Zt[j].height,0,Ct,ht,Zt[j].data);for(let ct=0;ct<H.length;ct++){const Yt=H[ct].image[j].image;Ft?N&&e.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct+1,0,0,Yt.width,Yt.height,Ct,ht,Yt.data):e.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct+1,vt,Yt.width,Yt.height,0,Ct,ht,Yt.data)}}else{Ft?N&&e.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,0,0,0,Ct,ht,Zt[j]):e.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,0,vt,Ct,ht,Zt[j]);for(let ct=0;ct<H.length;ct++){const st=H[ct];Ft?N&&e.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct+1,0,0,Ct,ht,st.image[j]):e.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+j,ct+1,vt,Ct,ht,st.image[j])}}}r(G)&&u(l.TEXTURE_CUBE_MAP),B.__version=D.version,G.onUpdate&&G.onUpdate(G)}y.__version=G.version}function pt(y,G,T,P,D,B){const Gt=s.convert(T.format,T.colorSpace),at=s.convert(T.type),mt=C(T.internalFormat,Gt,at,T.colorSpace),Ht=n.get(G),O=n.get(T);if(O.__renderTarget=G,!Ht.__hasExternalTextures){const Zt=Math.max(1,G.width>>B),Rt=Math.max(1,G.height>>B);D===l.TEXTURE_3D||D===l.TEXTURE_2D_ARRAY?e.texImage3D(D,B,mt,Zt,Rt,G.depth,0,Gt,at,null):e.texImage2D(D,B,mt,Zt,Rt,0,Gt,at,null)}e.bindFramebuffer(l.FRAMEBUFFER,y),Jt(G)?d.framebufferTexture2DMultisampleEXT(l.FRAMEBUFFER,P,D,O.__webglTexture,0,Tt(G)):(D===l.TEXTURE_2D||D>=l.TEXTURE_CUBE_MAP_POSITIVE_X&&D<=l.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&l.framebufferTexture2D(l.FRAMEBUFFER,P,D,O.__webglTexture,B),e.bindFramebuffer(l.FRAMEBUFFER,null)}function it(y,G,T){if(l.bindRenderbuffer(l.RENDERBUFFER,y),G.depthBuffer){const P=G.depthTexture,D=P&&P.isDepthTexture?P.type:null,B=X(G.stencilBuffer,D),Gt=G.stencilBuffer?l.DEPTH_STENCIL_ATTACHMENT:l.DEPTH_ATTACHMENT,at=Tt(G);Jt(G)?d.renderbufferStorageMultisampleEXT(l.RENDERBUFFER,at,B,G.width,G.height):T?l.renderbufferStorageMultisample(l.RENDERBUFFER,at,B,G.width,G.height):l.renderbufferStorage(l.RENDERBUFFER,B,G.width,G.height),l.framebufferRenderbuffer(l.FRAMEBUFFER,Gt,l.RENDERBUFFER,y)}else{const P=G.textures;for(let D=0;D<P.length;D++){const B=P[D],Gt=s.convert(B.format,B.colorSpace),at=s.convert(B.type),mt=C(B.internalFormat,Gt,at,B.colorSpace),Ht=Tt(G);T&&Jt(G)===!1?l.renderbufferStorageMultisample(l.RENDERBUFFER,Ht,mt,G.width,G.height):Jt(G)?d.renderbufferStorageMultisampleEXT(l.RENDERBUFFER,Ht,mt,G.width,G.height):l.renderbufferStorage(l.RENDERBUFFER,mt,G.width,G.height)}}l.bindRenderbuffer(l.RENDERBUFFER,null)}function yt(y,G){if(G&&G.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(l.FRAMEBUFFER,y),!(G.depthTexture&&G.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const P=n.get(G.depthTexture);P.__renderTarget=G,(!P.__webglTexture||G.depthTexture.image.width!==G.width||G.depthTexture.image.height!==G.height)&&(G.depthTexture.image.width=G.width,G.depthTexture.image.height=G.height,G.depthTexture.needsUpdate=!0),_(G.depthTexture,0);const D=P.__webglTexture,B=Tt(G);if(G.depthTexture.format===Kl)Jt(G)?d.framebufferTexture2DMultisampleEXT(l.FRAMEBUFFER,l.DEPTH_ATTACHMENT,l.TEXTURE_2D,D,0,B):l.framebufferTexture2D(l.FRAMEBUFFER,l.DEPTH_ATTACHMENT,l.TEXTURE_2D,D,0);else if(G.depthTexture.format===Bl)Jt(G)?d.framebufferTexture2DMultisampleEXT(l.FRAMEBUFFER,l.DEPTH_STENCIL_ATTACHMENT,l.TEXTURE_2D,D,0,B):l.framebufferTexture2D(l.FRAMEBUFFER,l.DEPTH_STENCIL_ATTACHMENT,l.TEXTURE_2D,D,0);else throw new Error("Unknown depthTexture format")}function It(y){const G=n.get(y),T=y.isWebGLCubeRenderTarget===!0;if(G.__boundDepthTexture!==y.depthTexture){const P=y.depthTexture;if(G.__depthDisposeCallback&&G.__depthDisposeCallback(),P){const D=()=>{delete G.__boundDepthTexture,delete G.__depthDisposeCallback,P.removeEventListener("dispose",D)};P.addEventListener("dispose",D),G.__depthDisposeCallback=D}G.__boundDepthTexture=P}if(y.depthTexture&&!G.__autoAllocateDepthBuffer){if(T)throw new Error("target.depthTexture not supported in Cube render targets");yt(G.__webglFramebuffer,y)}else if(T){G.__webglDepthbuffer=[];for(let P=0;P<6;P++)if(e.bindFramebuffer(l.FRAMEBUFFER,G.__webglFramebuffer[P]),G.__webglDepthbuffer[P]===void 0)G.__webglDepthbuffer[P]=l.createRenderbuffer(),it(G.__webglDepthbuffer[P],y,!1);else{const D=y.stencilBuffer?l.DEPTH_STENCIL_ATTACHMENT:l.DEPTH_ATTACHMENT,B=G.__webglDepthbuffer[P];l.bindRenderbuffer(l.RENDERBUFFER,B),l.framebufferRenderbuffer(l.FRAMEBUFFER,D,l.RENDERBUFFER,B)}}else if(e.bindFramebuffer(l.FRAMEBUFFER,G.__webglFramebuffer),G.__webglDepthbuffer===void 0)G.__webglDepthbuffer=l.createRenderbuffer(),it(G.__webglDepthbuffer,y,!1);else{const P=y.stencilBuffer?l.DEPTH_STENCIL_ATTACHMENT:l.DEPTH_ATTACHMENT,D=G.__webglDepthbuffer;l.bindRenderbuffer(l.RENDERBUFFER,D),l.framebufferRenderbuffer(l.FRAMEBUFFER,P,l.RENDERBUFFER,D)}e.bindFramebuffer(l.FRAMEBUFFER,null)}function Mt(y,G,T){const P=n.get(y);G!==void 0&&pt(P.__webglFramebuffer,y,y.texture,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,0),T!==void 0&&It(y)}function te(y){const G=y.texture,T=n.get(y),P=n.get(G);y.addEventListener("dispose",x);const D=y.textures,B=y.isWebGLCubeRenderTarget===!0,Gt=D.length>1;if(Gt||(P.__webglTexture===void 0&&(P.__webglTexture=l.createTexture()),P.__version=G.version,a.memory.textures++),B){T.__webglFramebuffer=[];for(let at=0;at<6;at++)if(G.mipmaps&&G.mipmaps.length>0){T.__webglFramebuffer[at]=[];for(let mt=0;mt<G.mipmaps.length;mt++)T.__webglFramebuffer[at][mt]=l.createFramebuffer()}else T.__webglFramebuffer[at]=l.createFramebuffer()}else{if(G.mipmaps&&G.mipmaps.length>0){T.__webglFramebuffer=[];for(let at=0;at<G.mipmaps.length;at++)T.__webglFramebuffer[at]=l.createFramebuffer()}else T.__webglFramebuffer=l.createFramebuffer();if(Gt)for(let at=0,mt=D.length;at<mt;at++){const Ht=n.get(D[at]);Ht.__webglTexture===void 0&&(Ht.__webglTexture=l.createTexture(),a.memory.textures++)}if(y.samples>0&&Jt(y)===!1){T.__webglMultisampledFramebuffer=l.createFramebuffer(),T.__webglColorRenderbuffer=[],e.bindFramebuffer(l.FRAMEBUFFER,T.__webglMultisampledFramebuffer);for(let at=0;at<D.length;at++){const mt=D[at];T.__webglColorRenderbuffer[at]=l.createRenderbuffer(),l.bindRenderbuffer(l.RENDERBUFFER,T.__webglColorRenderbuffer[at]);const Ht=s.convert(mt.format,mt.colorSpace),O=s.convert(mt.type),Zt=C(mt.internalFormat,Ht,O,mt.colorSpace,y.isXRRenderTarget===!0),Rt=Tt(y);l.renderbufferStorageMultisample(l.RENDERBUFFER,Rt,Zt,y.width,y.height),l.framebufferRenderbuffer(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0+at,l.RENDERBUFFER,T.__webglColorRenderbuffer[at])}l.bindRenderbuffer(l.RENDERBUFFER,null),y.depthBuffer&&(T.__webglDepthRenderbuffer=l.createRenderbuffer(),it(T.__webglDepthRenderbuffer,y,!0)),e.bindFramebuffer(l.FRAMEBUFFER,null)}}if(B){e.bindTexture(l.TEXTURE_CUBE_MAP,P.__webglTexture),Ut(l.TEXTURE_CUBE_MAP,G);for(let at=0;at<6;at++)if(G.mipmaps&&G.mipmaps.length>0)for(let mt=0;mt<G.mipmaps.length;mt++)pt(T.__webglFramebuffer[at][mt],y,G,l.COLOR_ATTACHMENT0,l.TEXTURE_CUBE_MAP_POSITIVE_X+at,mt);else pt(T.__webglFramebuffer[at],y,G,l.COLOR_ATTACHMENT0,l.TEXTURE_CUBE_MAP_POSITIVE_X+at,0);r(G)&&u(l.TEXTURE_CUBE_MAP),e.unbindTexture()}else if(Gt){for(let at=0,mt=D.length;at<mt;at++){const Ht=D[at],O=n.get(Ht);e.bindTexture(l.TEXTURE_2D,O.__webglTexture),Ut(l.TEXTURE_2D,Ht),pt(T.__webglFramebuffer,y,Ht,l.COLOR_ATTACHMENT0+at,l.TEXTURE_2D,0),r(Ht)&&u(l.TEXTURE_2D)}e.unbindTexture()}else{let at=l.TEXTURE_2D;if((y.isWebGL3DRenderTarget||y.isWebGLArrayRenderTarget)&&(at=y.isWebGL3DRenderTarget?l.TEXTURE_3D:l.TEXTURE_2D_ARRAY),e.bindTexture(at,P.__webglTexture),Ut(at,G),G.mipmaps&&G.mipmaps.length>0)for(let mt=0;mt<G.mipmaps.length;mt++)pt(T.__webglFramebuffer[mt],y,G,l.COLOR_ATTACHMENT0,at,mt);else pt(T.__webglFramebuffer,y,G,l.COLOR_ATTACHMENT0,at,0);r(G)&&u(at),e.unbindTexture()}y.depthBuffer&&It(y)}function wt(y){const G=y.textures;for(let T=0,P=G.length;T<P;T++){const D=G[T];if(r(D)){const B=S(y),Gt=n.get(D).__webglTexture;e.bindTexture(B,Gt),u(B),e.unbindTexture()}}}const se=[],L=[];function Ue(y){if(y.samples>0){if(Jt(y)===!1){const G=y.textures,T=y.width,P=y.height;let D=l.COLOR_BUFFER_BIT;const B=y.stencilBuffer?l.DEPTH_STENCIL_ATTACHMENT:l.DEPTH_ATTACHMENT,Gt=n.get(y),at=G.length>1;if(at)for(let mt=0;mt<G.length;mt++)e.bindFramebuffer(l.FRAMEBUFFER,Gt.__webglMultisampledFramebuffer),l.framebufferRenderbuffer(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0+mt,l.RENDERBUFFER,null),e.bindFramebuffer(l.FRAMEBUFFER,Gt.__webglFramebuffer),l.framebufferTexture2D(l.DRAW_FRAMEBUFFER,l.COLOR_ATTACHMENT0+mt,l.TEXTURE_2D,null,0);e.bindFramebuffer(l.READ_FRAMEBUFFER,Gt.__webglMultisampledFramebuffer),e.bindFramebuffer(l.DRAW_FRAMEBUFFER,Gt.__webglFramebuffer);for(let mt=0;mt<G.length;mt++){if(y.resolveDepthBuffer&&(y.depthBuffer&&(D|=l.DEPTH_BUFFER_BIT),y.stencilBuffer&&y.resolveStencilBuffer&&(D|=l.STENCIL_BUFFER_BIT)),at){l.framebufferRenderbuffer(l.READ_FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.RENDERBUFFER,Gt.__webglColorRenderbuffer[mt]);const Ht=n.get(G[mt]).__webglTexture;l.framebufferTexture2D(l.DRAW_FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,Ht,0)}l.blitFramebuffer(0,0,T,P,0,0,T,P,D,l.NEAREST),c===!0&&(se.length=0,L.length=0,se.push(l.COLOR_ATTACHMENT0+mt),y.depthBuffer&&y.resolveDepthBuffer===!1&&(se.push(B),L.push(B),l.invalidateFramebuffer(l.DRAW_FRAMEBUFFER,L)),l.invalidateFramebuffer(l.READ_FRAMEBUFFER,se))}if(e.bindFramebuffer(l.READ_FRAMEBUFFER,null),e.bindFramebuffer(l.DRAW_FRAMEBUFFER,null),at)for(let mt=0;mt<G.length;mt++){e.bindFramebuffer(l.FRAMEBUFFER,Gt.__webglMultisampledFramebuffer),l.framebufferRenderbuffer(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0+mt,l.RENDERBUFFER,Gt.__webglColorRenderbuffer[mt]);const Ht=n.get(G[mt]).__webglTexture;e.bindFramebuffer(l.FRAMEBUFFER,Gt.__webglFramebuffer),l.framebufferTexture2D(l.DRAW_FRAMEBUFFER,l.COLOR_ATTACHMENT0+mt,l.TEXTURE_2D,Ht,0)}e.bindFramebuffer(l.DRAW_FRAMEBUFFER,Gt.__webglMultisampledFramebuffer)}else if(y.depthBuffer&&y.resolveDepthBuffer===!1&&c){const G=y.stencilBuffer?l.DEPTH_STENCIL_ATTACHMENT:l.DEPTH_ATTACHMENT;l.invalidateFramebuffer(l.DRAW_FRAMEBUFFER,[G])}}}function Tt(y){return Math.min(i.maxSamples,y.samples)}function Jt(y){const G=n.get(y);return y.samples>0&&t.has("WEBGL_multisampled_render_to_texture")===!0&&G.__useRenderToTexture!==!1}function gt(y){const G=a.render.frame;m.get(y)!==G&&(m.set(y,G),y.update())}function Ot(y,G){const T=y.colorSpace,P=y.format,D=y.type;return y.isCompressedTexture===!0||y.isVideoTexture===!0||T!==El&&T!==hl&&(kt.getTransfer(T)===Qt?(P!==Ne||D!==Qe)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",T)),G}function Xt(y){return typeof HTMLImageElement<"u"&&y instanceof HTMLImageElement?(o.width=y.naturalWidth||y.width,o.height=y.naturalHeight||y.height):typeof VideoFrame<"u"&&y instanceof VideoFrame?(o.width=y.displayWidth,o.height=y.displayHeight):(o.width=y.width,o.height=y.height),o}this.allocateTextureUnit=w,this.resetTextureUnits=Q,this.setTexture2D=_,this.setTexture2DArray=K,this.setTexture3D=$,this.setTextureCube=z,this.rebindTextures=Mt,this.setupRenderTarget=te,this.updateRenderTargetMipmap=wt,this.updateMultisampleRenderTarget=Ue,this.setupDepthRenderbuffer=It,this.setupFrameBufferTexture=pt,this.useMultisampledRTT=Jt}function vb(l,t){function e(n,i=hl){let s;const a=kt.getTransfer(i);if(n===Qe)return l.UNSIGNED_BYTE;if(n===Hi)return l.UNSIGNED_SHORT_4_4_4_4;if(n===zi)return l.UNSIGNED_SHORT_5_5_5_1;if(n===Zs)return l.UNSIGNED_INT_5_9_9_9_REV;if(n===os)return l.BYTE;if(n===ms)return l.SHORT;if(n===pn)return l.UNSIGNED_SHORT;if(n===wi)return l.INT;if(n===Sl)return l.UNSIGNED_INT;if(n===qe)return l.FLOAT;if(n===Gn)return l.HALF_FLOAT;if(n===hs)return l.ALPHA;if(n===bs)return l.RGB;if(n===Ne)return l.RGBA;if(n===us)return l.LUMINANCE;if(n===rs)return l.LUMINANCE_ALPHA;if(n===Kl)return l.DEPTH_COMPONENT;if(n===Bl)return l.DEPTH_STENCIL;if(n===ps)return l.RED;if(n===Ki)return l.RED_INTEGER;if(n===Gs)return l.RG;if(n===Bi)return l.RG_INTEGER;if(n===Ei)return l.RGBA_INTEGER;if(n===vn||n===kn||n===wn||n===Hn)if(a===Qt)if(s=t.get("WEBGL_compressed_texture_s3tc_srgb"),s!==null){if(n===vn)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===kn)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===wn)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===Hn)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(s=t.get("WEBGL_compressed_texture_s3tc"),s!==null){if(n===vn)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===kn)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===wn)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===Hn)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(n===Ai||n===Qi||n===Pi||n===ji)if(s=t.get("WEBGL_compressed_texture_pvrtc"),s!==null){if(n===Ai)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===Qi)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===Pi)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===ji)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(n===Di||n===_i||n===Oi)if(s=t.get("WEBGL_compressed_texture_etc"),s!==null){if(n===Di||n===_i)return a===Qt?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(n===Oi)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(n===qi||n===$i||n===ta||n===ea||n===la||n===na||n===ia||n===aa||n===sa||n===da||n===ca||n===oa||n===ma||n===Za)if(s=t.get("WEBGL_compressed_texture_astc"),s!==null){if(n===qi)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===$i)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===ta)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===ea)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===la)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===na)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===ia)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===aa)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===sa)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===da)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===ca)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===oa)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===ma)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===Za)return a===Qt?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(n===zn||n===ha||n===ba)if(s=t.get("EXT_texture_compression_bptc"),s!==null){if(n===zn)return a===Qt?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(n===ha)return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(n===ba)return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(n===Ws||n===ua||n===ra||n===pa)if(s=t.get("EXT_texture_compression_rgtc"),s!==null){if(n===zn)return s.COMPRESSED_RED_RGTC1_EXT;if(n===ua)return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(n===ra)return s.COMPRESSED_RED_GREEN_RGTC2_EXT;if(n===pa)return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return n===zl?l.UNSIGNED_INT_24_8:l[n]!==void 0?l[n]:null}return{convert:e}}class kb extends He{constructor(t=[]){super(),this.isArrayCamera=!0,this.cameras=t}}class pe extends ye{constructor(){super(),this.isGroup=!0,this.type="Group"}}const wb={type:"move"};class Pa{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new pe,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new pe,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new k,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new k),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new pe,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new k,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new k),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}connect(t){if(t&&t.hand){const e=this._hand;if(e)for(const n of t.hand.values())this._getHandJoint(e,n)}return this.dispatchEvent({type:"connected",data:t}),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,n){let i=null,s=null,a=null;const d=this._targetRay,c=this._grip,o=this._hand;if(t&&e.session.visibilityState!=="visible-blurred"){if(o&&t.hand){a=!0;for(const W of t.hand.values()){const r=e.getJointPose(W,n),u=this._getHandJoint(o,W);r!==null&&(u.matrix.fromArray(r.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale),u.matrixWorldNeedsUpdate=!0,u.jointRadius=r.radius),u.visible=r!==null}const m=o.joints["index-finger-tip"],Z=o.joints["thumb-tip"],b=m.position.distanceTo(Z.position),h=.02,p=.005;o.inputState.pinching&&b>h+p?(o.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!o.inputState.pinching&&b<=h-p&&(o.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else c!==null&&t.gripSpace&&(s=e.getPose(t.gripSpace,n),s!==null&&(c.matrix.fromArray(s.transform.matrix),c.matrix.decompose(c.position,c.rotation,c.scale),c.matrixWorldNeedsUpdate=!0,s.linearVelocity?(c.hasLinearVelocity=!0,c.linearVelocity.copy(s.linearVelocity)):c.hasLinearVelocity=!1,s.angularVelocity?(c.hasAngularVelocity=!0,c.angularVelocity.copy(s.angularVelocity)):c.hasAngularVelocity=!1));d!==null&&(i=e.getPose(t.targetRaySpace,n),i===null&&s!==null&&(i=s),i!==null&&(d.matrix.fromArray(i.transform.matrix),d.matrix.decompose(d.position,d.rotation,d.scale),d.matrixWorldNeedsUpdate=!0,i.linearVelocity?(d.hasLinearVelocity=!0,d.linearVelocity.copy(i.linearVelocity)):d.hasLinearVelocity=!1,i.angularVelocity?(d.hasAngularVelocity=!0,d.angularVelocity.copy(i.angularVelocity)):d.hasAngularVelocity=!1,this.dispatchEvent(wb)))}return d!==null&&(d.visible=i!==null),c!==null&&(c.visible=s!==null),o!==null&&(o.visible=a!==null),this}_getHandJoint(t,e){if(t.joints[e.jointName]===void 0){const n=new pe;n.matrixAutoUpdate=!1,n.visible=!1,t.joints[e.jointName]=n,t.add(n)}return t.joints[e.jointName]}}const Hb=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,zb=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class Kb{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(t,e,n){if(this.texture===null){const i=new Xe,s=t.properties.get(i);s.__webglTexture=e.texture,(e.depthNear!=n.depthNear||e.depthFar!=n.depthFar)&&(this.depthNear=e.depthNear,this.depthFar=e.depthFar),this.texture=i}}getMesh(t){if(this.texture!==null&&this.mesh===null){const e=t.cameras[0].viewport,n=new he({vertexShader:Hb,fragmentShader:zb,uniforms:{depthColor:{value:this.texture},depthWidth:{value:e.z},depthHeight:{value:e.w}}});this.mesh=new ae(new ee(20,20),n)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class Bb extends Ql{constructor(t,e){super();const n=this;let i=null,s=1,a=null,d="local-floor",c=1,o=null,m=null,Z=null,b=null,h=null,p=null;const W=new Kb,r=e.getContextAttributes();let u=null,S=null;const C=[],X=[],M=new Lt;let I=null;const x=new He;x.viewport=new ne;const U=new He;U.viewport=new ne;const R=[x,U],g=new kb;let Y=null,Q=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(A){let tt=C[A];return tt===void 0&&(tt=new Pa,C[A]=tt),tt.getTargetRaySpace()},this.getControllerGrip=function(A){let tt=C[A];return tt===void 0&&(tt=new Pa,C[A]=tt),tt.getGripSpace()},this.getHand=function(A){let tt=C[A];return tt===void 0&&(tt=new Pa,C[A]=tt),tt.getHandSpace()};function w(A){const tt=X.indexOf(A.inputSource);if(tt===-1)return;const pt=C[tt];pt!==void 0&&(pt.update(A.inputSource,A.frame,o||a),pt.dispatchEvent({type:A.type,data:A.inputSource}))}function E(){i.removeEventListener("select",w),i.removeEventListener("selectstart",w),i.removeEventListener("selectend",w),i.removeEventListener("squeeze",w),i.removeEventListener("squeezestart",w),i.removeEventListener("squeezeend",w),i.removeEventListener("end",E),i.removeEventListener("inputsourceschange",_);for(let A=0;A<C.length;A++){const tt=X[A];tt!==null&&(X[A]=null,C[A].disconnect(tt))}Y=null,Q=null,W.reset(),t.setRenderTarget(u),h=null,b=null,Z=null,i=null,S=null,Pt.stop(),n.isPresenting=!1,t.setPixelRatio(I),t.setSize(M.width,M.height,!1),n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(A){s=A,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(A){d=A,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o||a},this.setReferenceSpace=function(A){o=A},this.getBaseLayer=function(){return b!==null?b:h},this.getBinding=function(){return Z},this.getFrame=function(){return p},this.getSession=function(){return i},this.setSession=async function(A){if(i=A,i!==null){if(u=t.getRenderTarget(),i.addEventListener("select",w),i.addEventListener("selectstart",w),i.addEventListener("selectend",w),i.addEventListener("squeeze",w),i.addEventListener("squeezestart",w),i.addEventListener("squeezeend",w),i.addEventListener("end",E),i.addEventListener("inputsourceschange",_),r.xrCompatible!==!0&&await e.makeXRCompatible(),I=t.getPixelRatio(),t.getSize(M),i.renderState.layers===void 0){const tt={antialias:r.antialias,alpha:!0,depth:r.depth,stencil:r.stencil,framebufferScaleFactor:s};h=new XRWebGLLayer(i,e,tt),i.updateRenderState({baseLayer:h}),t.setPixelRatio(1),t.setSize(h.framebufferWidth,h.framebufferHeight,!1),S=new bl(h.framebufferWidth,h.framebufferHeight,{format:Ne,type:Qe,colorSpace:t.outputColorSpace,stencilBuffer:r.stencil})}else{let tt=null,pt=null,it=null;r.depth&&(it=r.stencil?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT24,tt=r.stencil?Bl:Kl,pt=r.stencil?zl:Sl);const yt={colorFormat:e.RGBA8,depthFormat:it,scaleFactor:s};Z=new XRWebGLBinding(i,e),b=Z.createProjectionLayer(yt),i.updateRenderState({layers:[b]}),t.setPixelRatio(1),t.setSize(b.textureWidth,b.textureHeight,!1),S=new bl(b.textureWidth,b.textureHeight,{format:Ne,type:Qe,depthTexture:new md(b.textureWidth,b.textureHeight,pt,void 0,void 0,void 0,void 0,void 0,void 0,tt),stencilBuffer:r.stencil,colorSpace:t.outputColorSpace,samples:r.antialias?4:0,resolveDepthBuffer:b.ignoreDepthValues===!1})}S.isXRRenderTarget=!0,this.setFoveation(c),o=null,a=await i.requestReferenceSpace(d),Pt.setContext(i),Pt.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode},this.getDepthTexture=function(){return W.getDepthTexture()};function _(A){for(let tt=0;tt<A.removed.length;tt++){const pt=A.removed[tt],it=X.indexOf(pt);it>=0&&(X[it]=null,C[it].disconnect(pt))}for(let tt=0;tt<A.added.length;tt++){const pt=A.added[tt];let it=X.indexOf(pt);if(it===-1){for(let It=0;It<C.length;It++)if(It>=X.length){X.push(pt),it=It;break}else if(X[It]===null){X[It]=pt,it=It;break}if(it===-1)break}const yt=C[it];yt&&yt.connect(pt)}}const K=new k,$=new k;function z(A,tt,pt){K.setFromMatrixPosition(tt.matrixWorld),$.setFromMatrixPosition(pt.matrixWorld);const it=K.distanceTo($),yt=tt.projectionMatrix.elements,It=pt.projectionMatrix.elements,Mt=yt[14]/(yt[10]-1),te=yt[14]/(yt[10]+1),wt=(yt[9]+1)/yt[5],se=(yt[9]-1)/yt[5],L=(yt[8]-1)/yt[0],Ue=(It[8]+1)/It[0],Tt=Mt*L,Jt=Mt*Ue,gt=it/(-L+Ue),Ot=gt*-L;if(tt.matrixWorld.decompose(A.position,A.quaternion,A.scale),A.translateX(Ot),A.translateZ(gt),A.matrixWorld.compose(A.position,A.quaternion,A.scale),A.matrixWorldInverse.copy(A.matrixWorld).invert(),yt[10]===-1)A.projectionMatrix.copy(tt.projectionMatrix),A.projectionMatrixInverse.copy(tt.projectionMatrixInverse);else{const Xt=Mt+gt,y=te+gt,G=Tt-Ot,T=Jt+(it-Ot),P=wt*te/y*Xt,D=se*te/y*Xt;A.projectionMatrix.makePerspective(G,T,P,D,Xt,y),A.projectionMatrixInverse.copy(A.projectionMatrix).invert()}}function nt(A,tt){tt===null?A.matrixWorld.copy(A.matrix):A.matrixWorld.multiplyMatrices(tt.matrixWorld,A.matrix),A.matrixWorldInverse.copy(A.matrixWorld).invert()}this.updateCamera=function(A){if(i===null)return;let tt=A.near,pt=A.far;W.texture!==null&&(W.depthNear>0&&(tt=W.depthNear),W.depthFar>0&&(pt=W.depthFar)),g.near=U.near=x.near=tt,g.far=U.far=x.far=pt,(Y!==g.near||Q!==g.far)&&(i.updateRenderState({depthNear:g.near,depthFar:g.far}),Y=g.near,Q=g.far),x.layers.mask=A.layers.mask|2,U.layers.mask=A.layers.mask|4,g.layers.mask=x.layers.mask|U.layers.mask;const it=A.parent,yt=g.cameras;nt(g,it);for(let It=0;It<yt.length;It++)nt(yt[It],it);yt.length===2?z(g,x,U):g.projectionMatrix.copy(x.projectionMatrix),ot(A,g,it)};function ot(A,tt,pt){pt===null?A.matrix.copy(tt.matrixWorld):(A.matrix.copy(pt.matrixWorld),A.matrix.invert(),A.matrix.multiply(tt.matrixWorld)),A.matrix.decompose(A.position,A.quaternion,A.scale),A.updateMatrixWorld(!0),A.projectionMatrix.copy(tt.projectionMatrix),A.projectionMatrixInverse.copy(tt.projectionMatrixInverse),A.isPerspectiveCamera&&(A.fov=Vn*2*Math.atan(1/A.projectionMatrix.elements[5]),A.zoom=1)}this.getCamera=function(){return g},this.getFoveation=function(){if(!(b===null&&h===null))return c},this.setFoveation=function(A){c=A,b!==null&&(b.fixedFoveation=A),h!==null&&h.fixedFoveation!==void 0&&(h.fixedFoveation=A)},this.hasDepthSensing=function(){return W.texture!==null},this.getDepthSensingMesh=function(){return W.getMesh(g)};let Vt=null;function Ut(A,tt){if(m=tt.getViewerPose(o||a),p=tt,m!==null){const pt=m.views;h!==null&&(t.setRenderTargetFramebuffer(S,h.framebuffer),t.setRenderTarget(S));let it=!1;pt.length!==g.cameras.length&&(g.cameras.length=0,it=!0);for(let It=0;It<pt.length;It++){const Mt=pt[It];let te=null;if(h!==null)te=h.getViewport(Mt);else{const se=Z.getViewSubImage(b,Mt);te=se.viewport,It===0&&(t.setRenderTargetTextures(S,se.colorTexture,b.ignoreDepthValues?void 0:se.depthStencilTexture),t.setRenderTarget(S))}let wt=R[It];wt===void 0&&(wt=new He,wt.layers.enable(It),wt.viewport=new ne,R[It]=wt),wt.matrix.fromArray(Mt.transform.matrix),wt.matrix.decompose(wt.position,wt.quaternion,wt.scale),wt.projectionMatrix.fromArray(Mt.projectionMatrix),wt.projectionMatrixInverse.copy(wt.projectionMatrix).invert(),wt.viewport.set(te.x,te.y,te.width,te.height),It===0&&(g.matrix.copy(wt.matrix),g.matrix.decompose(g.position,g.quaternion,g.scale)),it===!0&&g.cameras.push(wt)}const yt=i.enabledFeatures;if(yt&&yt.includes("depth-sensing")){const It=Z.getDepthInformation(pt[0]);It&&It.isValid&&It.texture&&W.init(t,It,i.renderState)}}for(let pt=0;pt<C.length;pt++){const it=X[pt],yt=C[pt];it!==null&&yt!==void 0&&yt.update(it,tt,o||a)}Vt&&Vt(A,tt),tt.detectedPlanes&&n.dispatchEvent({type:"planesdetected",data:tt}),p=null}const Pt=new ld;Pt.setAnimationLoop(Ut),this.setAnimationLoop=function(A){Vt=A},this.dispose=function(){}}}const Tl=new nl,Eb=new ie;function Ab(l,t){function e(r,u){r.matrixAutoUpdate===!0&&r.updateMatrix(),u.value.copy(r.matrix)}function n(r,u){u.color.getRGB(r.fogColor.value,_s(l)),u.isFog?(r.fogNear.value=u.near,r.fogFar.value=u.far):u.isFogExp2&&(r.fogDensity.value=u.density)}function i(r,u,S,C,X){u.isMeshBasicMaterial||u.isMeshLambertMaterial?s(r,u):u.isMeshToonMaterial?(s(r,u),Z(r,u)):u.isMeshPhongMaterial?(s(r,u),m(r,u)):u.isMeshStandardMaterial?(s(r,u),b(r,u),u.isMeshPhysicalMaterial&&h(r,u,X)):u.isMeshMatcapMaterial?(s(r,u),p(r,u)):u.isMeshDepthMaterial?s(r,u):u.isMeshDistanceMaterial?(s(r,u),W(r,u)):u.isMeshNormalMaterial?s(r,u):u.isLineBasicMaterial?(a(r,u),u.isLineDashedMaterial&&d(r,u)):u.isPointsMaterial?c(r,u,S,C):u.isSpriteMaterial?o(r,u):u.isShadowMaterial?(r.color.value.copy(u.color),r.opacity.value=u.opacity):u.isShaderMaterial&&(u.uniformsNeedUpdate=!1)}function s(r,u){r.opacity.value=u.opacity,u.color&&r.diffuse.value.copy(u.color),u.emissive&&r.emissive.value.copy(u.emissive).multiplyScalar(u.emissiveIntensity),u.map&&(r.map.value=u.map,e(u.map,r.mapTransform)),u.alphaMap&&(r.alphaMap.value=u.alphaMap,e(u.alphaMap,r.alphaMapTransform)),u.bumpMap&&(r.bumpMap.value=u.bumpMap,e(u.bumpMap,r.bumpMapTransform),r.bumpScale.value=u.bumpScale,u.side===Re&&(r.bumpScale.value*=-1)),u.normalMap&&(r.normalMap.value=u.normalMap,e(u.normalMap,r.normalMapTransform),r.normalScale.value.copy(u.normalScale),u.side===Re&&r.normalScale.value.negate()),u.displacementMap&&(r.displacementMap.value=u.displacementMap,e(u.displacementMap,r.displacementMapTransform),r.displacementScale.value=u.displacementScale,r.displacementBias.value=u.displacementBias),u.emissiveMap&&(r.emissiveMap.value=u.emissiveMap,e(u.emissiveMap,r.emissiveMapTransform)),u.specularMap&&(r.specularMap.value=u.specularMap,e(u.specularMap,r.specularMapTransform)),u.alphaTest>0&&(r.alphaTest.value=u.alphaTest);const S=t.get(u),C=S.envMap,X=S.envMapRotation;C&&(r.envMap.value=C,Tl.copy(X),Tl.x*=-1,Tl.y*=-1,Tl.z*=-1,C.isCubeTexture&&C.isRenderTargetTexture===!1&&(Tl.y*=-1,Tl.z*=-1),r.envMapRotation.value.setFromMatrix4(Eb.makeRotationFromEuler(Tl)),r.flipEnvMap.value=C.isCubeTexture&&C.isRenderTargetTexture===!1?-1:1,r.reflectivity.value=u.reflectivity,r.ior.value=u.ior,r.refractionRatio.value=u.refractionRatio),u.lightMap&&(r.lightMap.value=u.lightMap,r.lightMapIntensity.value=u.lightMapIntensity,e(u.lightMap,r.lightMapTransform)),u.aoMap&&(r.aoMap.value=u.aoMap,r.aoMapIntensity.value=u.aoMapIntensity,e(u.aoMap,r.aoMapTransform))}function a(r,u){r.diffuse.value.copy(u.color),r.opacity.value=u.opacity,u.map&&(r.map.value=u.map,e(u.map,r.mapTransform))}function d(r,u){r.dashSize.value=u.dashSize,r.totalSize.value=u.dashSize+u.gapSize,r.scale.value=u.scale}function c(r,u,S,C){r.diffuse.value.copy(u.color),r.opacity.value=u.opacity,r.size.value=u.size*S,r.scale.value=C*.5,u.map&&(r.map.value=u.map,e(u.map,r.uvTransform)),u.alphaMap&&(r.alphaMap.value=u.alphaMap,e(u.alphaMap,r.alphaMapTransform)),u.alphaTest>0&&(r.alphaTest.value=u.alphaTest)}function o(r,u){r.diffuse.value.copy(u.color),r.opacity.value=u.opacity,r.rotation.value=u.rotation,u.map&&(r.map.value=u.map,e(u.map,r.mapTransform)),u.alphaMap&&(r.alphaMap.value=u.alphaMap,e(u.alphaMap,r.alphaMapTransform)),u.alphaTest>0&&(r.alphaTest.value=u.alphaTest)}function m(r,u){r.specular.value.copy(u.specular),r.shininess.value=Math.max(u.shininess,1e-4)}function Z(r,u){u.gradientMap&&(r.gradientMap.value=u.gradientMap)}function b(r,u){r.metalness.value=u.metalness,u.metalnessMap&&(r.metalnessMap.value=u.metalnessMap,e(u.metalnessMap,r.metalnessMapTransform)),r.roughness.value=u.roughness,u.roughnessMap&&(r.roughnessMap.value=u.roughnessMap,e(u.roughnessMap,r.roughnessMapTransform)),u.envMap&&(r.envMapIntensity.value=u.envMapIntensity)}function h(r,u,S){r.ior.value=u.ior,u.sheen>0&&(r.sheenColor.value.copy(u.sheenColor).multiplyScalar(u.sheen),r.sheenRoughness.value=u.sheenRoughness,u.sheenColorMap&&(r.sheenColorMap.value=u.sheenColorMap,e(u.sheenColorMap,r.sheenColorMapTransform)),u.sheenRoughnessMap&&(r.sheenRoughnessMap.value=u.sheenRoughnessMap,e(u.sheenRoughnessMap,r.sheenRoughnessMapTransform))),u.clearcoat>0&&(r.clearcoat.value=u.clearcoat,r.clearcoatRoughness.value=u.clearcoatRoughness,u.clearcoatMap&&(r.clearcoatMap.value=u.clearcoatMap,e(u.clearcoatMap,r.clearcoatMapTransform)),u.clearcoatRoughnessMap&&(r.clearcoatRoughnessMap.value=u.clearcoatRoughnessMap,e(u.clearcoatRoughnessMap,r.clearcoatRoughnessMapTransform)),u.clearcoatNormalMap&&(r.clearcoatNormalMap.value=u.clearcoatNormalMap,e(u.clearcoatNormalMap,r.clearcoatNormalMapTransform),r.clearcoatNormalScale.value.copy(u.clearcoatNormalScale),u.side===Re&&r.clearcoatNormalScale.value.negate())),u.dispersion>0&&(r.dispersion.value=u.dispersion),u.iridescence>0&&(r.iridescence.value=u.iridescence,r.iridescenceIOR.value=u.iridescenceIOR,r.iridescenceThicknessMinimum.value=u.iridescenceThicknessRange[0],r.iridescenceThicknessMaximum.value=u.iridescenceThicknessRange[1],u.iridescenceMap&&(r.iridescenceMap.value=u.iridescenceMap,e(u.iridescenceMap,r.iridescenceMapTransform)),u.iridescenceThicknessMap&&(r.iridescenceThicknessMap.value=u.iridescenceThicknessMap,e(u.iridescenceThicknessMap,r.iridescenceThicknessMapTransform))),u.transmission>0&&(r.transmission.value=u.transmission,r.transmissionSamplerMap.value=S.texture,r.transmissionSamplerSize.value.set(S.width,S.height),u.transmissionMap&&(r.transmissionMap.value=u.transmissionMap,e(u.transmissionMap,r.transmissionMapTransform)),r.thickness.value=u.thickness,u.thicknessMap&&(r.thicknessMap.value=u.thicknessMap,e(u.thicknessMap,r.thicknessMapTransform)),r.attenuationDistance.value=u.attenuationDistance,r.attenuationColor.value.copy(u.attenuationColor)),u.anisotropy>0&&(r.anisotropyVector.value.set(u.anisotropy*Math.cos(u.anisotropyRotation),u.anisotropy*Math.sin(u.anisotropyRotation)),u.anisotropyMap&&(r.anisotropyMap.value=u.anisotropyMap,e(u.anisotropyMap,r.anisotropyMapTransform))),r.specularIntensity.value=u.specularIntensity,r.specularColor.value.copy(u.specularColor),u.specularColorMap&&(r.specularColorMap.value=u.specularColorMap,e(u.specularColorMap,r.specularColorMapTransform)),u.specularIntensityMap&&(r.specularIntensityMap.value=u.specularIntensityMap,e(u.specularIntensityMap,r.specularIntensityMapTransform))}function p(r,u){u.matcap&&(r.matcap.value=u.matcap)}function W(r,u){const S=t.get(u).light;r.referencePosition.value.setFromMatrixPosition(S.matrixWorld),r.nearDistance.value=S.shadow.camera.near,r.farDistance.value=S.shadow.camera.far}return{refreshFogUniforms:n,refreshMaterialUniforms:i}}function Qb(l,t,e,n){let i={},s={},a=[];const d=l.getParameter(l.MAX_UNIFORM_BUFFER_BINDINGS);function c(S,C){const X=C.program;n.uniformBlockBinding(S,X)}function o(S,C){let X=i[S.id];X===void 0&&(p(S),X=m(S),i[S.id]=X,S.addEventListener("dispose",r));const M=C.program;n.updateUBOMapping(S,M);const I=t.render.frame;s[S.id]!==I&&(b(S),s[S.id]=I)}function m(S){const C=Z();S.__bindingPointIndex=C;const X=l.createBuffer(),M=S.__size,I=S.usage;return l.bindBuffer(l.UNIFORM_BUFFER,X),l.bufferData(l.UNIFORM_BUFFER,M,I),l.bindBuffer(l.UNIFORM_BUFFER,null),l.bindBufferBase(l.UNIFORM_BUFFER,C,X),X}function Z(){for(let S=0;S<d;S++)if(a.indexOf(S)===-1)return a.push(S),S;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function b(S){const C=i[S.id],X=S.uniforms,M=S.__cache;l.bindBuffer(l.UNIFORM_BUFFER,C);for(let I=0,x=X.length;I<x;I++){const U=Array.isArray(X[I])?X[I]:[X[I]];for(let R=0,g=U.length;R<g;R++){const Y=U[R];if(h(Y,I,R,M)===!0){const Q=Y.__offset,w=Array.isArray(Y.value)?Y.value:[Y.value];let E=0;for(let _=0;_<w.length;_++){const K=w[_],$=W(K);typeof K=="number"||typeof K=="boolean"?(Y.__data[0]=K,l.bufferSubData(l.UNIFORM_BUFFER,Q+E,Y.__data)):K.isMatrix3?(Y.__data[0]=K.elements[0],Y.__data[1]=K.elements[1],Y.__data[2]=K.elements[2],Y.__data[3]=0,Y.__data[4]=K.elements[3],Y.__data[5]=K.elements[4],Y.__data[6]=K.elements[5],Y.__data[7]=0,Y.__data[8]=K.elements[6],Y.__data[9]=K.elements[7],Y.__data[10]=K.elements[8],Y.__data[11]=0):(K.toArray(Y.__data,E),E+=$.storage/Float32Array.BYTES_PER_ELEMENT)}l.bufferSubData(l.UNIFORM_BUFFER,Q,Y.__data)}}}l.bindBuffer(l.UNIFORM_BUFFER,null)}function h(S,C,X,M){const I=S.value,x=C+"_"+X;if(M[x]===void 0)return typeof I=="number"||typeof I=="boolean"?M[x]=I:M[x]=I.clone(),!0;{const U=M[x];if(typeof I=="number"||typeof I=="boolean"){if(U!==I)return M[x]=I,!0}else if(U.equals(I)===!1)return U.copy(I),!0}return!1}function p(S){const C=S.uniforms;let X=0;const M=16;for(let x=0,U=C.length;x<U;x++){const R=Array.isArray(C[x])?C[x]:[C[x]];for(let g=0,Y=R.length;g<Y;g++){const Q=R[g],w=Array.isArray(Q.value)?Q.value:[Q.value];for(let E=0,_=w.length;E<_;E++){const K=w[E],$=W(K),z=X%M,nt=z%$.boundary,ot=z+nt;X+=nt,ot!==0&&M-ot<$.storage&&(X+=M-ot),Q.__data=new Float32Array($.storage/Float32Array.BYTES_PER_ELEMENT),Q.__offset=X,X+=$.storage}}}const I=X%M;return I>0&&(X+=M-I),S.__size=X,S.__cache={},this}function W(S){const C={boundary:0,storage:0};return typeof S=="number"||typeof S=="boolean"?(C.boundary=4,C.storage=4):S.isVector2?(C.boundary=8,C.storage=8):S.isVector3||S.isColor?(C.boundary=16,C.storage=12):S.isVector4?(C.boundary=16,C.storage=16):S.isMatrix3?(C.boundary=48,C.storage=48):S.isMatrix4?(C.boundary=64,C.storage=64):S.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",S),C}function r(S){const C=S.target;C.removeEventListener("dispose",r);const X=a.indexOf(C.__bindingPointIndex);a.splice(X,1),l.deleteBuffer(i[C.id]),delete i[C.id],delete s[C.id]}function u(){for(const S in i)l.deleteBuffer(i[S]);a=[],i={},s={}}return{bind:c,update:o,dispose:u}}class Pb{constructor(t={}){const{canvas:e=ro(),context:n=null,depth:i=!0,stencil:s=!1,alpha:a=!1,antialias:d=!1,premultipliedAlpha:c=!0,preserveDrawingBuffer:o=!1,powerPreference:m="default",failIfMajorPerformanceCaveat:Z=!1,reverseDepthBuffer:b=!1}=t;this.isWebGLRenderer=!0;let h;if(n!==null){if(typeof WebGLRenderingContext<"u"&&n instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");h=n.getContextAttributes().alpha}else h=a;const p=new Uint32Array(4),W=new Int32Array(4);let r=null,u=null;const S=[],C=[];this.domElement=e,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=fe,this.toneMapping=Zl,this.toneMappingExposure=1;const X=this;let M=!1,I=0,x=0,U=null,R=-1,g=null;const Y=new ne,Q=new ne;let w=null;const E=new Kt(0);let _=0,K=e.width,$=e.height,z=1,nt=null,ot=null;const Vt=new ne(0,0,K,$),Ut=new ne(0,0,K,$);let Pt=!1;const A=new ed;let tt=!1,pt=!1;const it=new ie,yt=new ie,It=new k,Mt=new ne,te={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let wt=!1;function se(){return U===null?z:1}let L=n;function Ue(V,f){return e.getContext(V,f)}try{const V={alpha:!0,depth:i,stencil:s,antialias:d,premultipliedAlpha:c,preserveDrawingBuffer:o,powerPreference:m,failIfMajorPerformanceCaveat:Z};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${Ci}`),e.addEventListener("webglcontextlost",j,!1),e.addEventListener("webglcontextrestored",ct,!1),e.addEventListener("webglcontextcreationerror",st,!1),L===null){const f="webgl2";if(L=Ue(f,V),L===null)throw Ue(f)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(V){throw console.error("THREE.WebGLRenderer: "+V.message),V}let Tt,Jt,gt,Ot,Xt,y,G,T,P,D,B,Gt,at,mt,Ht,O,Zt,Rt,Ct,ht,vt,Ft,Dt,N;function lt(){Tt=new qZ(L),Tt.init(),Ft=new vb(L,Tt),Jt=new QZ(L,Tt,t,Ft),gt=new Mb(L,Tt),Jt.reverseDepthBuffer&&b&&gt.buffers.depth.setReversed(!0),Ot=new eh(L),Xt=new Vb,y=new Jb(L,Tt,gt,Xt,Jt,Ft,Ot),G=new jZ(X),T=new OZ(X),P=new Ko(L),Dt=new EZ(L,P),D=new $Z(L,P,Ot,Dt),B=new nh(L,D,P,Ot),Ct=new lh(L,Jt,y),O=new PZ(Xt),Gt=new Wb(X,G,T,Tt,Jt,Dt,O),at=new Ab(X,Xt),mt=new gb,Ht=new xb(Tt),Rt=new BZ(X,G,T,gt,B,h,c),Zt=new Lb(X,B,Jt),N=new Qb(L,Ot,Jt,gt),ht=new AZ(L,Tt,Ot),vt=new th(L,Tt,Ot),Ot.programs=Gt.programs,X.capabilities=Jt,X.extensions=Tt,X.properties=Xt,X.renderLists=mt,X.shadowMap=Zt,X.state=gt,X.info=Ot}lt();const H=new Bb(X,L);this.xr=H,this.getContext=function(){return L},this.getContextAttributes=function(){return L.getContextAttributes()},this.forceContextLoss=function(){const V=Tt.get("WEBGL_lose_context");V&&V.loseContext()},this.forceContextRestore=function(){const V=Tt.get("WEBGL_lose_context");V&&V.restoreContext()},this.getPixelRatio=function(){return z},this.setPixelRatio=function(V){V!==void 0&&(z=V,this.setSize(K,$,!1))},this.getSize=function(V){return V.set(K,$)},this.setSize=function(V,f,J=!0){if(H.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}K=V,$=f,e.width=Math.floor(V*z),e.height=Math.floor(f*z),J===!0&&(e.style.width=V+"px",e.style.height=f+"px"),this.setViewport(0,0,V,f)},this.getDrawingBufferSize=function(V){return V.set(K*z,$*z).floor()},this.setDrawingBufferSize=function(V,f,J){K=V,$=f,z=J,e.width=Math.floor(V*J),e.height=Math.floor(f*J),this.setViewport(0,0,V,f)},this.getCurrentViewport=function(V){return V.copy(Y)},this.getViewport=function(V){return V.copy(Vt)},this.setViewport=function(V,f,J,v){V.isVector4?Vt.set(V.x,V.y,V.z,V.w):Vt.set(V,f,J,v),gt.viewport(Y.copy(Vt).multiplyScalar(z).round())},this.getScissor=function(V){return V.copy(Ut)},this.setScissor=function(V,f,J,v){V.isVector4?Ut.set(V.x,V.y,V.z,V.w):Ut.set(V,f,J,v),gt.scissor(Q.copy(Ut).multiplyScalar(z).round())},this.getScissorTest=function(){return Pt},this.setScissorTest=function(V){gt.setScissorTest(Pt=V)},this.setOpaqueSort=function(V){nt=V},this.setTransparentSort=function(V){ot=V},this.getClearColor=function(V){return V.copy(Rt.getClearColor())},this.setClearColor=function(){Rt.setClearColor.apply(Rt,arguments)},this.getClearAlpha=function(){return Rt.getClearAlpha()},this.setClearAlpha=function(){Rt.setClearAlpha.apply(Rt,arguments)},this.clear=function(V=!0,f=!0,J=!0){let v=0;if(V){let F=!1;if(U!==null){const q=U.texture.format;F=q===Ei||q===Bi||q===Ki}if(F){const q=U.texture.type,dt=q===Qe||q===Sl||q===pn||q===zl||q===Hi||q===zi,bt=Rt.getClearColor(),ut=Rt.getClearAlpha(),St=bt.r,Nt=bt.g,rt=bt.b;dt?(p[0]=St,p[1]=Nt,p[2]=rt,p[3]=ut,L.clearBufferuiv(L.COLOR,0,p)):(W[0]=St,W[1]=Nt,W[2]=rt,W[3]=ut,L.clearBufferiv(L.COLOR,0,W))}else v|=L.COLOR_BUFFER_BIT}f&&(v|=L.DEPTH_BUFFER_BIT),J&&(v|=L.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),L.clear(v)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",j,!1),e.removeEventListener("webglcontextrestored",ct,!1),e.removeEventListener("webglcontextcreationerror",st,!1),mt.dispose(),Ht.dispose(),Xt.dispose(),G.dispose(),T.dispose(),B.dispose(),Dt.dispose(),N.dispose(),Gt.dispose(),H.dispose(),H.removeEventListener("sessionstart",lc),H.removeEventListener("sessionend",nc),vl.stop()};function j(V){V.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),M=!0}function ct(){console.log("THREE.WebGLRenderer: Context Restored."),M=!1;const V=Ot.autoReset,f=Zt.enabled,J=Zt.autoUpdate,v=Zt.needsUpdate,F=Zt.type;lt(),Ot.autoReset=V,Zt.enabled=f,Zt.autoUpdate=J,Zt.needsUpdate=v,Zt.type=F}function st(V){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",V.statusMessage)}function Yt(V){const f=V.target;f.removeEventListener("dispose",Yt),le(f)}function le(V){Ge(V),Xt.remove(V)}function Ge(V){const f=Xt.get(V).programs;f!==void 0&&(f.forEach(function(J){Gt.releaseProgram(J)}),V.isShaderMaterial&&Gt.releaseShaderCache(V))}this.renderBufferDirect=function(V,f,J,v,F,q){f===null&&(f=te);const dt=F.isMesh&&F.matrixWorld.determinant()<0,bt=Mu(V,f,J,v,F);gt.setMaterial(v,dt);let ut=J.index,St=1;if(v.wireframe===!0){if(ut=D.getWireframeAttribute(J),ut===void 0)return;St=2}const Nt=J.drawRange,rt=J.attributes.position;let zt=Nt.start*St,_t=(Nt.start+Nt.count)*St;q!==null&&(zt=Math.max(zt,q.start*St),_t=Math.min(_t,(q.start+q.count)*St)),ut!==null?(zt=Math.max(zt,0),_t=Math.min(_t,ut.count)):rt!=null&&(zt=Math.max(zt,0),_t=Math.min(_t,rt.count));const qt=_t-zt;if(qt<0||qt===1/0)return;Dt.setup(F,v,bt,J,ut);let Se,Bt=ht;if(ut!==null&&(Se=P.get(ut),Bt=vt,Bt.setIndex(Se)),F.isMesh)v.wireframe===!0?(gt.setLineWidth(v.wireframeLinewidth*se()),Bt.setMode(L.LINES)):Bt.setMode(L.TRIANGLES);else if(F.isLine){let Wt=v.linewidth;Wt===void 0&&(Wt=1),gt.setLineWidth(Wt*se()),F.isLineSegments?Bt.setMode(L.LINES):F.isLineLoop?Bt.setMode(L.LINE_LOOP):Bt.setMode(L.LINE_STRIP)}else F.isPoints?Bt.setMode(L.POINTS):F.isSprite&&Bt.setMode(L.TRIANGLES);if(F.isBatchedMesh)if(F._multiDrawInstances!==null)Bt.renderMultiDrawInstances(F._multiDrawStarts,F._multiDrawCounts,F._multiDrawCount,F._multiDrawInstances);else if(Tt.get("WEBGL_multi_draw"))Bt.renderMultiDraw(F._multiDrawStarts,F._multiDrawCounts,F._multiDrawCount);else{const Wt=F._multiDrawStarts,cl=F._multiDrawCounts,Et=F._multiDrawCount,Be=ut?P.get(ut).bytesPerElement:1,rn=Xt.get(v).currentProgram.getUniforms();for(let Ye=0;Ye<Et;Ye++)rn.setValue(L,"_gl_DrawID",Ye),Bt.render(Wt[Ye]/Be,cl[Ye])}else if(F.isInstancedMesh)Bt.renderInstances(zt,qt,F.count);else if(J.isInstancedBufferGeometry){const Wt=J._maxInstanceCount!==void 0?J._maxInstanceCount:1/0,cl=Math.min(J.instanceCount,Wt);Bt.renderInstances(zt,qt,cl)}else Bt.render(zt,qt)};function At(V,f,J){V.transparent===!0&&V.side===Oe&&V.forceSinglePass===!1?(V.side=Re,V.needsUpdate=!0,yi(V,f,J),V.side=ol,V.needsUpdate=!0,yi(V,f,J),V.side=Oe):yi(V,f,J)}this.compile=function(V,f,J=null){J===null&&(J=V),u=Ht.get(J),u.init(f),C.push(u),J.traverseVisible(function(F){F.isLight&&F.layers.test(f.layers)&&(u.pushLight(F),F.castShadow&&u.pushShadow(F))}),V!==J&&V.traverseVisible(function(F){F.isLight&&F.layers.test(f.layers)&&(u.pushLight(F),F.castShadow&&u.pushShadow(F))}),u.setupLights();const v=new Set;return V.traverse(function(F){if(!(F.isMesh||F.isPoints||F.isLine||F.isSprite))return;const q=F.material;if(q)if(Array.isArray(q))for(let dt=0;dt<q.length;dt++){const bt=q[dt];At(bt,J,F),v.add(bt)}else At(q,J,F),v.add(q)}),C.pop(),u=null,v},this.compileAsync=function(V,f,J=null){const v=this.compile(V,f,J);return new Promise(F=>{function q(){if(v.forEach(function(dt){Xt.get(dt).currentProgram.isReady()&&v.delete(dt)}),v.size===0){F(V);return}setTimeout(q,10)}Tt.get("KHR_parallel_shader_compile")!==null?q():setTimeout(q,10)})};let Ke=null;function dl(V){Ke&&Ke(V)}function lc(){vl.stop()}function nc(){vl.start()}const vl=new ld;vl.setAnimationLoop(dl),typeof self<"u"&&vl.setContext(self),this.setAnimationLoop=function(V){Ke=V,H.setAnimationLoop(V),V===null?vl.stop():vl.start()},H.addEventListener("sessionstart",lc),H.addEventListener("sessionend",nc),this.render=function(V,f){if(f!==void 0&&f.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(M===!0)return;if(V.matrixWorldAutoUpdate===!0&&V.updateMatrixWorld(),f.parent===null&&f.matrixWorldAutoUpdate===!0&&f.updateMatrixWorld(),H.enabled===!0&&H.isPresenting===!0&&(H.cameraAutoUpdate===!0&&H.updateCamera(f),f=H.getCamera()),V.isScene===!0&&V.onBeforeRender(X,V,f,U),u=Ht.get(V,C.length),u.init(f),C.push(u),yt.multiplyMatrices(f.projectionMatrix,f.matrixWorldInverse),A.setFromProjectionMatrix(yt),pt=this.localClippingEnabled,tt=O.init(this.clippingPlanes,pt),r=mt.get(V,S.length),r.init(),S.push(r),H.enabled===!0&&H.isPresenting===!0){const q=X.xr.getDepthSensingMesh();q!==null&&es(q,f,-1/0,X.sortObjects)}es(V,f,0,X.sortObjects),r.finish(),X.sortObjects===!0&&r.sort(nt,ot),wt=H.enabled===!1||H.isPresenting===!1||H.hasDepthSensing()===!1,wt&&Rt.addToRenderList(r,V),this.info.render.frame++,tt===!0&&O.beginShadows();const J=u.state.shadowsArray;Zt.render(J,V,f),tt===!0&&O.endShadows(),this.info.autoReset===!0&&this.info.reset();const v=r.opaque,F=r.transmissive;if(u.setupLights(),f.isArrayCamera){const q=f.cameras;if(F.length>0)for(let dt=0,bt=q.length;dt<bt;dt++){const ut=q[dt];ac(v,F,V,ut)}wt&&Rt.render(V);for(let dt=0,bt=q.length;dt<bt;dt++){const ut=q[dt];ic(r,V,ut,ut.viewport)}}else F.length>0&&ac(v,F,V,f),wt&&Rt.render(V),ic(r,V,f);U!==null&&(y.updateMultisampleRenderTarget(U),y.updateRenderTargetMipmap(U)),V.isScene===!0&&V.onAfterRender(X,V,f),Dt.resetDefaultState(),R=-1,g=null,C.pop(),C.length>0?(u=C[C.length-1],tt===!0&&O.setGlobalState(X.clippingPlanes,u.state.camera)):u=null,S.pop(),S.length>0?r=S[S.length-1]:r=null};function es(V,f,J,v){if(V.visible===!1)return;if(V.layers.test(f.layers)){if(V.isGroup)J=V.renderOrder;else if(V.isLOD)V.autoUpdate===!0&&V.update(f);else if(V.isLight)u.pushLight(V),V.castShadow&&u.pushShadow(V);else if(V.isSprite){if(!V.frustumCulled||A.intersectsSprite(V)){v&&Mt.setFromMatrixPosition(V.matrixWorld).applyMatrix4(yt);const dt=B.update(V),bt=V.material;bt.visible&&r.push(V,dt,bt,J,Mt.z,null)}}else if((V.isMesh||V.isLine||V.isPoints)&&(!V.frustumCulled||A.intersectsObject(V))){const dt=B.update(V),bt=V.material;if(v&&(V.boundingSphere!==void 0?(V.boundingSphere===null&&V.computeBoundingSphere(),Mt.copy(V.boundingSphere.center)):(dt.boundingSphere===null&&dt.computeBoundingSphere(),Mt.copy(dt.boundingSphere.center)),Mt.applyMatrix4(V.matrixWorld).applyMatrix4(yt)),Array.isArray(bt)){const ut=dt.groups;for(let St=0,Nt=ut.length;St<Nt;St++){const rt=ut[St],zt=bt[rt.materialIndex];zt&&zt.visible&&r.push(V,dt,zt,J,Mt.z,rt)}}else bt.visible&&r.push(V,dt,bt,J,Mt.z,null)}}const q=V.children;for(let dt=0,bt=q.length;dt<bt;dt++)es(q[dt],f,J,v)}function ic(V,f,J,v){const F=V.opaque,q=V.transmissive,dt=V.transparent;u.setupLightsView(J),tt===!0&&O.setGlobalState(X.clippingPlanes,J),v&&gt.viewport(Y.copy(v)),F.length>0&&Ri(F,f,J),q.length>0&&Ri(q,f,J),dt.length>0&&Ri(dt,f,J),gt.buffers.depth.setTest(!0),gt.buffers.depth.setMask(!0),gt.buffers.color.setMask(!0),gt.setPolygonOffset(!1)}function ac(V,f,J,v){if((J.isScene===!0?J.overrideMaterial:null)!==null)return;u.state.transmissionRenderTarget[v.id]===void 0&&(u.state.transmissionRenderTarget[v.id]=new bl(1,1,{generateMipmaps:!0,type:Tt.has("EXT_color_buffer_half_float")||Tt.has("EXT_color_buffer_float")?Gn:Qe,minFilter:Cl,samples:4,stencilBuffer:s,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:kt.workingColorSpace}));const q=u.state.transmissionRenderTarget[v.id],dt=v.viewport||Y;q.setSize(dt.z,dt.w);const bt=X.getRenderTarget();X.setRenderTarget(q),X.getClearColor(E),_=X.getClearAlpha(),_<1&&X.setClearColor(16777215,.5),X.clear(),wt&&Rt.render(J);const ut=X.toneMapping;X.toneMapping=Zl;const St=v.viewport;if(v.viewport!==void 0&&(v.viewport=void 0),u.setupLightsView(v),tt===!0&&O.setGlobalState(X.clippingPlanes,v),Ri(V,J,v),y.updateMultisampleRenderTarget(q),y.updateRenderTargetMipmap(q),Tt.has("WEBGL_multisampled_render_to_texture")===!1){let Nt=!1;for(let rt=0,zt=f.length;rt<zt;rt++){const _t=f[rt],qt=_t.object,Se=_t.geometry,Bt=_t.material,Wt=_t.group;if(Bt.side===Oe&&qt.layers.test(v.layers)){const cl=Bt.side;Bt.side=Re,Bt.needsUpdate=!0,sc(qt,J,v,Se,Bt,Wt),Bt.side=cl,Bt.needsUpdate=!0,Nt=!0}}Nt===!0&&(y.updateMultisampleRenderTarget(q),y.updateRenderTargetMipmap(q))}X.setRenderTarget(bt),X.setClearColor(E,_),St!==void 0&&(v.viewport=St),X.toneMapping=ut}function Ri(V,f,J){const v=f.isScene===!0?f.overrideMaterial:null;for(let F=0,q=V.length;F<q;F++){const dt=V[F],bt=dt.object,ut=dt.geometry,St=v===null?dt.material:v,Nt=dt.group;bt.layers.test(J.layers)&&sc(bt,f,J,ut,St,Nt)}}function sc(V,f,J,v,F,q){V.onBeforeRender(X,f,J,v,F,q),V.modelViewMatrix.multiplyMatrices(J.matrixWorldInverse,V.matrixWorld),V.normalMatrix.getNormalMatrix(V.modelViewMatrix),F.onBeforeRender(X,f,J,v,V,q),F.transparent===!0&&F.side===Oe&&F.forceSinglePass===!1?(F.side=Re,F.needsUpdate=!0,X.renderBufferDirect(J,f,v,F,V,q),F.side=ol,F.needsUpdate=!0,X.renderBufferDirect(J,f,v,F,V,q),F.side=Oe):X.renderBufferDirect(J,f,v,F,V,q),V.onAfterRender(X,f,J,v,F,q)}function yi(V,f,J){f.isScene!==!0&&(f=te);const v=Xt.get(V),F=u.state.lights,q=u.state.shadowsArray,dt=F.state.version,bt=Gt.getParameters(V,F.state,q,f,J),ut=Gt.getProgramCacheKey(bt);let St=v.programs;v.environment=V.isMeshStandardMaterial?f.environment:null,v.fog=f.fog,v.envMap=(V.isMeshStandardMaterial?T:G).get(V.envMap||v.environment),v.envMapRotation=v.environment!==null&&V.envMap===null?f.environmentRotation:V.envMapRotation,St===void 0&&(V.addEventListener("dispose",Yt),St=new Map,v.programs=St);let Nt=St.get(ut);if(Nt!==void 0){if(v.currentProgram===Nt&&v.lightsStateVersion===dt)return cc(V,bt),Nt}else bt.uniforms=Gt.getUniforms(V),V.onBeforeCompile(bt,X),Nt=Gt.acquireProgram(bt,ut),St.set(ut,Nt),v.uniforms=bt.uniforms;const rt=v.uniforms;return(!V.isShaderMaterial&&!V.isRawShaderMaterial||V.clipping===!0)&&(rt.clippingPlanes=O.uniform),cc(V,bt),v.needsLights=Ju(V),v.lightsStateVersion=dt,v.needsLights&&(rt.ambientLightColor.value=F.state.ambient,rt.lightProbe.value=F.state.probe,rt.directionalLights.value=F.state.directional,rt.directionalLightShadows.value=F.state.directionalShadow,rt.spotLights.value=F.state.spot,rt.spotLightShadows.value=F.state.spotShadow,rt.rectAreaLights.value=F.state.rectArea,rt.ltc_1.value=F.state.rectAreaLTC1,rt.ltc_2.value=F.state.rectAreaLTC2,rt.pointLights.value=F.state.point,rt.pointLightShadows.value=F.state.pointShadow,rt.hemisphereLights.value=F.state.hemi,rt.directionalShadowMap.value=F.state.directionalShadowMap,rt.directionalShadowMatrix.value=F.state.directionalShadowMatrix,rt.spotShadowMap.value=F.state.spotShadowMap,rt.spotLightMatrix.value=F.state.spotLightMatrix,rt.spotLightMap.value=F.state.spotLightMap,rt.pointShadowMap.value=F.state.pointShadowMap,rt.pointShadowMatrix.value=F.state.pointShadowMatrix),v.currentProgram=Nt,v.uniformsList=null,Nt}function dc(V){if(V.uniformsList===null){const f=V.currentProgram.getUniforms();V.uniformsList=hi.seqWithValue(f.seq,V.uniforms)}return V.uniformsList}function cc(V,f){const J=Xt.get(V);J.outputColorSpace=f.outputColorSpace,J.batching=f.batching,J.batchingColor=f.batchingColor,J.instancing=f.instancing,J.instancingColor=f.instancingColor,J.instancingMorph=f.instancingMorph,J.skinning=f.skinning,J.morphTargets=f.morphTargets,J.morphNormals=f.morphNormals,J.morphColors=f.morphColors,J.morphTargetsCount=f.morphTargetsCount,J.numClippingPlanes=f.numClippingPlanes,J.numIntersection=f.numClipIntersection,J.vertexAlphas=f.vertexAlphas,J.vertexTangents=f.vertexTangents,J.toneMapping=f.toneMapping}function Mu(V,f,J,v,F){f.isScene!==!0&&(f=te),y.resetTextureUnits();const q=f.fog,dt=v.isMeshStandardMaterial?f.environment:null,bt=U===null?X.outputColorSpace:U.isXRRenderTarget===!0?U.texture.colorSpace:El,ut=(v.isMeshStandardMaterial?T:G).get(v.envMap||dt),St=v.vertexColors===!0&&!!J.attributes.color&&J.attributes.color.itemSize===4,Nt=!!J.attributes.tangent&&(!!v.normalMap||v.anisotropy>0),rt=!!J.morphAttributes.position,zt=!!J.morphAttributes.normal,_t=!!J.morphAttributes.color;let qt=Zl;v.toneMapped&&(U===null||U.isXRRenderTarget===!0)&&(qt=X.toneMapping);const Se=J.morphAttributes.position||J.morphAttributes.normal||J.morphAttributes.color,Bt=Se!==void 0?Se.length:0,Wt=Xt.get(v),cl=u.state.lights;if(tt===!0&&(pt===!0||V!==g)){const Me=V===g&&v.id===R;O.setState(v,V,Me)}let Et=!1;v.version===Wt.__version?(Wt.needsLights&&Wt.lightsStateVersion!==cl.state.version||Wt.outputColorSpace!==bt||F.isBatchedMesh&&Wt.batching===!1||!F.isBatchedMesh&&Wt.batching===!0||F.isBatchedMesh&&Wt.batchingColor===!0&&F.colorTexture===null||F.isBatchedMesh&&Wt.batchingColor===!1&&F.colorTexture!==null||F.isInstancedMesh&&Wt.instancing===!1||!F.isInstancedMesh&&Wt.instancing===!0||F.isSkinnedMesh&&Wt.skinning===!1||!F.isSkinnedMesh&&Wt.skinning===!0||F.isInstancedMesh&&Wt.instancingColor===!0&&F.instanceColor===null||F.isInstancedMesh&&Wt.instancingColor===!1&&F.instanceColor!==null||F.isInstancedMesh&&Wt.instancingMorph===!0&&F.morphTexture===null||F.isInstancedMesh&&Wt.instancingMorph===!1&&F.morphTexture!==null||Wt.envMap!==ut||v.fog===!0&&Wt.fog!==q||Wt.numClippingPlanes!==void 0&&(Wt.numClippingPlanes!==O.numPlanes||Wt.numIntersection!==O.numIntersection)||Wt.vertexAlphas!==St||Wt.vertexTangents!==Nt||Wt.morphTargets!==rt||Wt.morphNormals!==zt||Wt.morphColors!==_t||Wt.toneMapping!==qt||Wt.morphTargetsCount!==Bt)&&(Et=!0):(Et=!0,Wt.__version=v.version);let Be=Wt.currentProgram;Et===!0&&(Be=yi(v,f,F));let rn=!1,Ye=!1,Un=!1;const $t=Be.getUniforms(),De=Wt.uniforms;if(gt.useProgram(Be.program)&&(rn=!0,Ye=!0,Un=!0),v.id!==R&&(R=v.id,Ye=!0),rn||g!==V){gt.buffers.depth.getReversed()?(it.copy(V.projectionMatrix),Go(it),Wo(it),$t.setValue(L,"projectionMatrix",it)):$t.setValue(L,"projectionMatrix",V.projectionMatrix),$t.setValue(L,"viewMatrix",V.matrixWorldInverse);const Xl=$t.map.cameraPosition;Xl!==void 0&&Xl.setValue(L,It.setFromMatrixPosition(V.matrixWorld)),Jt.logarithmicDepthBuffer&&$t.setValue(L,"logDepthBufFC",2/(Math.log(V.far+1)/Math.LN2)),(v.isMeshPhongMaterial||v.isMeshToonMaterial||v.isMeshLambertMaterial||v.isMeshBasicMaterial||v.isMeshStandardMaterial||v.isShaderMaterial)&&$t.setValue(L,"isOrthographic",V.isOrthographicCamera===!0),g!==V&&(g=V,Ye=!0,Un=!0)}if(F.isSkinnedMesh){$t.setOptional(L,F,"bindMatrix"),$t.setOptional(L,F,"bindMatrixInverse");const Me=F.skeleton;Me&&(Me.boneTexture===null&&Me.computeBoneTexture(),$t.setValue(L,"boneTexture",Me.boneTexture,y))}F.isBatchedMesh&&($t.setOptional(L,F,"batchingTexture"),$t.setValue(L,"batchingTexture",F._matricesTexture,y),$t.setOptional(L,F,"batchingIdTexture"),$t.setValue(L,"batchingIdTexture",F._indirectTexture,y),$t.setOptional(L,F,"batchingColorTexture"),F._colorsTexture!==null&&$t.setValue(L,"batchingColorTexture",F._colorsTexture,y));const Mn=J.morphAttributes;if((Mn.position!==void 0||Mn.normal!==void 0||Mn.color!==void 0)&&Ct.update(F,J,Be),(Ye||Wt.receiveShadow!==F.receiveShadow)&&(Wt.receiveShadow=F.receiveShadow,$t.setValue(L,"receiveShadow",F.receiveShadow)),v.isMeshGouraudMaterial&&v.envMap!==null&&(De.envMap.value=ut,De.flipEnvMap.value=ut.isCubeTexture&&ut.isRenderTargetTexture===!1?-1:1),v.isMeshStandardMaterial&&v.envMap===null&&f.environment!==null&&(De.envMapIntensity.value=f.environmentIntensity),Ye&&($t.setValue(L,"toneMappingExposure",X.toneMappingExposure),Wt.needsLights&&Tu(De,Un),q&&v.fog===!0&&at.refreshFogUniforms(De,q),at.refreshMaterialUniforms(De,v,z,$,u.state.transmissionRenderTarget[V.id]),hi.upload(L,dc(Wt),De,y)),v.isShaderMaterial&&v.uniformsNeedUpdate===!0&&(hi.upload(L,dc(Wt),De,y),v.uniformsNeedUpdate=!1),v.isSpriteMaterial&&$t.setValue(L,"center",F.center),$t.setValue(L,"modelViewMatrix",F.modelViewMatrix),$t.setValue(L,"normalMatrix",F.normalMatrix),$t.setValue(L,"modelMatrix",F.matrixWorld),v.isShaderMaterial||v.isRawShaderMaterial){const Me=v.uniformsGroups;for(let Xl=0,gl=Me.length;Xl<gl;Xl++){const oc=Me[Xl];N.update(oc,Be),N.bind(oc,Be)}}return Be}function Tu(V,f){V.ambientLightColor.needsUpdate=f,V.lightProbe.needsUpdate=f,V.directionalLights.needsUpdate=f,V.directionalLightShadows.needsUpdate=f,V.pointLights.needsUpdate=f,V.pointLightShadows.needsUpdate=f,V.spotLights.needsUpdate=f,V.spotLightShadows.needsUpdate=f,V.rectAreaLights.needsUpdate=f,V.hemisphereLights.needsUpdate=f}function Ju(V){return V.isMeshLambertMaterial||V.isMeshToonMaterial||V.isMeshPhongMaterial||V.isMeshStandardMaterial||V.isShadowMaterial||V.isShaderMaterial&&V.lights===!0}this.getActiveCubeFace=function(){return I},this.getActiveMipmapLevel=function(){return x},this.getRenderTarget=function(){return U},this.setRenderTargetTextures=function(V,f,J){Xt.get(V.texture).__webglTexture=f,Xt.get(V.depthTexture).__webglTexture=J;const v=Xt.get(V);v.__hasExternalTextures=!0,v.__autoAllocateDepthBuffer=J===void 0,v.__autoAllocateDepthBuffer||Tt.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),v.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(V,f){const J=Xt.get(V);J.__webglFramebuffer=f,J.__useDefaultFramebuffer=f===void 0},this.setRenderTarget=function(V,f=0,J=0){U=V,I=f,x=J;let v=!0,F=null,q=!1,dt=!1;if(V){const ut=Xt.get(V);if(ut.__useDefaultFramebuffer!==void 0)gt.bindFramebuffer(L.FRAMEBUFFER,null),v=!1;else if(ut.__webglFramebuffer===void 0)y.setupRenderTarget(V);else if(ut.__hasExternalTextures)y.rebindTextures(V,Xt.get(V.texture).__webglTexture,Xt.get(V.depthTexture).__webglTexture);else if(V.depthBuffer){const rt=V.depthTexture;if(ut.__boundDepthTexture!==rt){if(rt!==null&&Xt.has(rt)&&(V.width!==rt.image.width||V.height!==rt.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");y.setupDepthRenderbuffer(V)}}const St=V.texture;(St.isData3DTexture||St.isDataArrayTexture||St.isCompressedArrayTexture)&&(dt=!0);const Nt=Xt.get(V).__webglFramebuffer;V.isWebGLCubeRenderTarget?(Array.isArray(Nt[f])?F=Nt[f][J]:F=Nt[f],q=!0):V.samples>0&&y.useMultisampledRTT(V)===!1?F=Xt.get(V).__webglMultisampledFramebuffer:Array.isArray(Nt)?F=Nt[J]:F=Nt,Y.copy(V.viewport),Q.copy(V.scissor),w=V.scissorTest}else Y.copy(Vt).multiplyScalar(z).floor(),Q.copy(Ut).multiplyScalar(z).floor(),w=Pt;if(gt.bindFramebuffer(L.FRAMEBUFFER,F)&&v&&gt.drawBuffers(V,F),gt.viewport(Y),gt.scissor(Q),gt.setScissorTest(w),q){const ut=Xt.get(V.texture);L.framebufferTexture2D(L.FRAMEBUFFER,L.COLOR_ATTACHMENT0,L.TEXTURE_CUBE_MAP_POSITIVE_X+f,ut.__webglTexture,J)}else if(dt){const ut=Xt.get(V.texture),St=f||0;L.framebufferTextureLayer(L.FRAMEBUFFER,L.COLOR_ATTACHMENT0,ut.__webglTexture,J||0,St)}R=-1},this.readRenderTargetPixels=function(V,f,J,v,F,q,dt){if(!(V&&V.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let bt=Xt.get(V).__webglFramebuffer;if(V.isWebGLCubeRenderTarget&&dt!==void 0&&(bt=bt[dt]),bt){gt.bindFramebuffer(L.FRAMEBUFFER,bt);try{const ut=V.texture,St=ut.format,Nt=ut.type;if(!Jt.textureFormatReadable(St)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!Jt.textureTypeReadable(Nt)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}f>=0&&f<=V.width-v&&J>=0&&J<=V.height-F&&L.readPixels(f,J,v,F,Ft.convert(St),Ft.convert(Nt),q)}finally{const ut=U!==null?Xt.get(U).__webglFramebuffer:null;gt.bindFramebuffer(L.FRAMEBUFFER,ut)}}},this.readRenderTargetPixelsAsync=async function(V,f,J,v,F,q,dt){if(!(V&&V.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let bt=Xt.get(V).__webglFramebuffer;if(V.isWebGLCubeRenderTarget&&dt!==void 0&&(bt=bt[dt]),bt){const ut=V.texture,St=ut.format,Nt=ut.type;if(!Jt.textureFormatReadable(St))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!Jt.textureTypeReadable(Nt))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");if(f>=0&&f<=V.width-v&&J>=0&&J<=V.height-F){gt.bindFramebuffer(L.FRAMEBUFFER,bt);const rt=L.createBuffer();L.bindBuffer(L.PIXEL_PACK_BUFFER,rt),L.bufferData(L.PIXEL_PACK_BUFFER,q.byteLength,L.STREAM_READ),L.readPixels(f,J,v,F,Ft.convert(St),Ft.convert(Nt),0);const zt=U!==null?Xt.get(U).__webglFramebuffer:null;gt.bindFramebuffer(L.FRAMEBUFFER,zt);const _t=L.fenceSync(L.SYNC_GPU_COMMANDS_COMPLETE,0);return L.flush(),await po(L,_t,4),L.bindBuffer(L.PIXEL_PACK_BUFFER,rt),L.getBufferSubData(L.PIXEL_PACK_BUFFER,0,q),L.deleteBuffer(rt),L.deleteSync(_t),q}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")}},this.copyFramebufferToTexture=function(V,f=null,J=0){V.isTexture!==!0&&(gn("WebGLRenderer: copyFramebufferToTexture function signature has changed."),f=arguments[0]||null,V=arguments[1]);const v=Math.pow(2,-J),F=Math.floor(V.image.width*v),q=Math.floor(V.image.height*v),dt=f!==null?f.x:0,bt=f!==null?f.y:0;y.setTexture2D(V,0),L.copyTexSubImage2D(L.TEXTURE_2D,J,0,0,dt,bt,F,q),gt.unbindTexture()},this.copyTextureToTexture=function(V,f,J=null,v=null,F=0){V.isTexture!==!0&&(gn("WebGLRenderer: copyTextureToTexture function signature has changed."),v=arguments[0]||null,V=arguments[1],f=arguments[2],F=arguments[3]||0,J=null);let q,dt,bt,ut,St,Nt,rt,zt,_t;const qt=V.isCompressedTexture?V.mipmaps[F]:V.image;J!==null?(q=J.max.x-J.min.x,dt=J.max.y-J.min.y,bt=J.isBox3?J.max.z-J.min.z:1,ut=J.min.x,St=J.min.y,Nt=J.isBox3?J.min.z:0):(q=qt.width,dt=qt.height,bt=qt.depth||1,ut=0,St=0,Nt=0),v!==null?(rt=v.x,zt=v.y,_t=v.z):(rt=0,zt=0,_t=0);const Se=Ft.convert(f.format),Bt=Ft.convert(f.type);let Wt;f.isData3DTexture?(y.setTexture3D(f,0),Wt=L.TEXTURE_3D):f.isDataArrayTexture||f.isCompressedArrayTexture?(y.setTexture2DArray(f,0),Wt=L.TEXTURE_2D_ARRAY):(y.setTexture2D(f,0),Wt=L.TEXTURE_2D),L.pixelStorei(L.UNPACK_FLIP_Y_WEBGL,f.flipY),L.pixelStorei(L.UNPACK_PREMULTIPLY_ALPHA_WEBGL,f.premultiplyAlpha),L.pixelStorei(L.UNPACK_ALIGNMENT,f.unpackAlignment);const cl=L.getParameter(L.UNPACK_ROW_LENGTH),Et=L.getParameter(L.UNPACK_IMAGE_HEIGHT),Be=L.getParameter(L.UNPACK_SKIP_PIXELS),rn=L.getParameter(L.UNPACK_SKIP_ROWS),Ye=L.getParameter(L.UNPACK_SKIP_IMAGES);L.pixelStorei(L.UNPACK_ROW_LENGTH,qt.width),L.pixelStorei(L.UNPACK_IMAGE_HEIGHT,qt.height),L.pixelStorei(L.UNPACK_SKIP_PIXELS,ut),L.pixelStorei(L.UNPACK_SKIP_ROWS,St),L.pixelStorei(L.UNPACK_SKIP_IMAGES,Nt);const Un=V.isDataArrayTexture||V.isData3DTexture,$t=f.isDataArrayTexture||f.isData3DTexture;if(V.isRenderTargetTexture||V.isDepthTexture){const De=Xt.get(V),Mn=Xt.get(f),Me=Xt.get(De.__renderTarget),Xl=Xt.get(Mn.__renderTarget);gt.bindFramebuffer(L.READ_FRAMEBUFFER,Me.__webglFramebuffer),gt.bindFramebuffer(L.DRAW_FRAMEBUFFER,Xl.__webglFramebuffer);for(let gl=0;gl<bt;gl++)Un&&L.framebufferTextureLayer(L.READ_FRAMEBUFFER,L.COLOR_ATTACHMENT0,Xt.get(V).__webglTexture,F,Nt+gl),V.isDepthTexture?($t&&L.framebufferTextureLayer(L.DRAW_FRAMEBUFFER,L.COLOR_ATTACHMENT0,Xt.get(f).__webglTexture,F,_t+gl),L.blitFramebuffer(ut,St,q,dt,rt,zt,q,dt,L.DEPTH_BUFFER_BIT,L.NEAREST)):$t?L.copyTexSubImage3D(Wt,F,rt,zt,_t+gl,ut,St,q,dt):L.copyTexSubImage2D(Wt,F,rt,zt,_t+gl,ut,St,q,dt);gt.bindFramebuffer(L.READ_FRAMEBUFFER,null),gt.bindFramebuffer(L.DRAW_FRAMEBUFFER,null)}else $t?V.isDataTexture||V.isData3DTexture?L.texSubImage3D(Wt,F,rt,zt,_t,q,dt,bt,Se,Bt,qt.data):f.isCompressedArrayTexture?L.compressedTexSubImage3D(Wt,F,rt,zt,_t,q,dt,bt,Se,qt.data):L.texSubImage3D(Wt,F,rt,zt,_t,q,dt,bt,Se,Bt,qt):V.isDataTexture?L.texSubImage2D(L.TEXTURE_2D,F,rt,zt,q,dt,Se,Bt,qt.data):V.isCompressedTexture?L.compressedTexSubImage2D(L.TEXTURE_2D,F,rt,zt,qt.width,qt.height,Se,qt.data):L.texSubImage2D(L.TEXTURE_2D,F,rt,zt,q,dt,Se,Bt,qt);L.pixelStorei(L.UNPACK_ROW_LENGTH,cl),L.pixelStorei(L.UNPACK_IMAGE_HEIGHT,Et),L.pixelStorei(L.UNPACK_SKIP_PIXELS,Be),L.pixelStorei(L.UNPACK_SKIP_ROWS,rn),L.pixelStorei(L.UNPACK_SKIP_IMAGES,Ye),F===0&&f.generateMipmaps&&L.generateMipmap(Wt),gt.unbindTexture()},this.copyTextureToTexture3D=function(V,f,J=null,v=null,F=0){return V.isTexture!==!0&&(gn("WebGLRenderer: copyTextureToTexture3D function signature has changed."),J=arguments[0]||null,v=arguments[1]||null,V=arguments[2],f=arguments[3],F=arguments[4]||0),gn('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),this.copyTextureToTexture(V,f,J,v,F)},this.initRenderTarget=function(V){Xt.get(V).__webglFramebuffer===void 0&&y.setupRenderTarget(V)},this.initTexture=function(V){V.isCubeTexture?y.setTextureCube(V,0):V.isData3DTexture?y.setTexture3D(V,0):V.isDataArrayTexture||V.isCompressedArrayTexture?y.setTexture2DArray(V,0):y.setTexture2D(V,0),gt.unbindTexture()},this.resetState=function(){I=0,x=0,U=null,gt.reset(),Dt.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return $e}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(t){this._outputColorSpace=t;const e=this.getContext();e.drawingBufferColorspace=kt._getDrawingBufferColorSpace(t),e.unpackColorSpace=kt._getUnpackColorSpace()}}class Ud extends ye{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new nl,this.environmentIntensity=1,this.environmentRotation=new nl,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,this.backgroundRotation.copy(t.backgroundRotation),this.environmentIntensity=t.environmentIntensity,this.environmentRotation.copy(t.environmentRotation),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(e.object.backgroundIntensity=this.backgroundIntensity),e.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(e.object.environmentIntensity=this.environmentIntensity),e.object.environmentRotation=this.environmentRotation.toArray(),e}}class je extends Ce{constructor(t,e,n,i=1){super(t,e,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}class ui extends xn{static get type(){return"PointsMaterial"}constructor(t){super(),this.isPointsMaterial=!0,this.color=new Kt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const Md=new ie,ja=new Ms,ri=new jn,pi=new k;class Da extends ye{constructor(t=new Le,e=new ui){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,s=t.params.Points.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),ri.copy(n.boundingSphere),ri.applyMatrix4(i),ri.radius+=s,t.ray.intersectsSphere(ri)===!1)return;Md.copy(i).invert(),ja.copy(t.ray).applyMatrix4(Md);const d=s/((this.scale.x+this.scale.y+this.scale.z)/3),c=d*d,o=n.index,Z=n.attributes.position;if(o!==null){const b=Math.max(0,a.start),h=Math.min(o.count,a.start+a.count);for(let p=b,W=h;p<W;p++){const r=o.getX(p);pi.fromBufferAttribute(Z,r),Td(pi,r,c,i,t,e,this)}}else{const b=Math.max(0,a.start),h=Math.min(Z.count,a.start+a.count);for(let p=b,W=h;p<W;p++)pi.fromBufferAttribute(Z,p),Td(pi,p,c,i,t,e,this)}}updateMorphTargets(){const e=this.geometry.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const d=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[d]=s}}}}}function Td(l,t,e,n,i,s,a){const d=ja.distanceSqToPoint(l);if(d<e){const c=new k;ja.closestPointToPoint(l,c),c.applyMatrix4(n);const o=i.ray.origin.distanceTo(c);if(o<i.near||o>i.far)return;s.push({distance:o,distanceToRay:Math.sqrt(d),point:c,index:t,face:null,faceIndex:null,barycoord:null,object:a})}}class jb extends Xe{constructor(t,e,n,i,s,a,d,c,o){super(t,e,n,i,s,a,d,c,o),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Jd extends Le{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}toJSON(){const t=super.toJSON();return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Ci}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Ci);const _a=100,Gi=new Map;let Db=0;const vd=typeof globalThis.requestAnimationFrame=="function"?l=>globalThis.requestAnimationFrame(l):l=>{const t=++Db,e=setTimeout(()=>{Gi.delete(t),l(performance.now())},16);return Gi.set(t,e),t},_b=typeof globalThis.cancelAnimationFrame=="function"?l=>globalThis.cancelAnimationFrame(l):l=>{const t=Gi.get(l);t&&(clearTimeout(t),Gi.delete(l))};function Wi(l,t=l){if(typeof document<"u"&&document.createElement){const e=document.createElement("canvas");e.width=l,e.height=t;const n=e.getContext("2d");if(!n)throw new Error("Unable to get 2D context");return{canvas:e,ctx:n}}if(typeof OffscreenCanvas<"u"){const e=new OffscreenCanvas(l,t),n=e.getContext("2d");if(!n)throw new Error("Unable to get 2D context");return{canvas:e,ctx:n}}throw new Error("Canvas not supported")}function Vi(l){return new jb(l)}function kd(){const{canvas:t,ctx:e}=Wi(32,32),n=e.createRadialGradient(32/2,32/2,0,32/2,32/2,32/2);n.addColorStop(0,"rgba(255, 255, 255, 1)"),n.addColorStop(.4,"rgba(255, 255, 255, 0.5)"),n.addColorStop(1,"rgba(255, 255, 255, 0)"),e.fillStyle=n,e.fillRect(0,0,32,32);const i=Vi(t);return i.needsUpdate=!0,i}function Ob(){const{canvas:t,ctx:e}=Wi(16,16),n=e.createRadialGradient(16/2,16/2,0,16/2,16/2,16/2);n.addColorStop(0,"rgba(255, 255, 255, 1)"),n.addColorStop(.3,"rgba(255, 255, 255, 0.6)"),n.addColorStop(1,"rgba(255, 255, 255, 0)"),e.fillStyle=n,e.fillRect(0,0,16,16);const i=Vi(t);return i.needsUpdate=!0,i}const Oa=`
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;class qb{constructor(t){this.canvas=t.canvas,this.viewportWidth=t.viewportWidth,this.viewportHeight=t.viewportHeight,this.devicePixelRatio=t.devicePixelRatio??1,this.isMobile=t.isMobile??!1,this.viewWidth=this.computeViewWidth(_a),this.viewHeight=_a,this.camera=this.createCamera(),this.renderer=this.createRenderer(),this.scene=new Ud,this.animationFrame=null,this.lastTimestamp=0,this.currentEffect="none",this.activeEffect=null,this.opacity=100,this.effectExtras={},this.lastAppliedExtras={},this.snowSurfaces=[],this.smogOverlay=null,this.windowDropletsOverlay=null,this.renderTarget=null,this.maskScene=null,this.maskCamera=null,this.maskQuad=null,this.renderLoop=e=>this.renderFrame(e)}computeViewWidth(t){return t*(this.viewportWidth/Math.max(1,this.viewportHeight))}createCamera(){const t=this.viewWidth/2,e=this.viewHeight/2,n=new ka(-t,t,e,-e,-1e3,1e3);return n.position.z=10,n}createRenderer(){const t=new Pb({canvas:this.canvas,alpha:!0,antialias:!this.isMobile,powerPreference:"high-performance",stencil:!1,depth:!1,preserveDrawingBuffer:!1});return t.setPixelRatio(Math.min(this.devicePixelRatio||1,this.isMobile?1:1.5)),t.setSize(this.viewportWidth,this.viewportHeight,!1),t}start(t,e,n={}){this.opacity=Math.max(0,Math.min(100,e)),this.effectExtras=n;const i=this.effectExtras.moonPosition,s=this.lastAppliedExtras.moonPosition,a=i?.x!==s?.x||i?.y!==s?.y,d=this.lastAppliedExtras.snowAccumulation!==this.effectExtras.snowAccumulation||this.lastAppliedExtras.matrixRainColor!==this.effectExtras.matrixRainColor||this.lastAppliedExtras.smogActive!==this.effectExtras.smogActive||this.lastAppliedExtras.windowDroplets!==this.effectExtras.windowDroplets||a;if(this.currentEffect===t&&this.activeEffect&&!d){this.activeEffect.setOpacity(this.opacity),this.updateSmogOverlay(),this.updateWindowDropletsOverlay(),this.startLoop();return}this.setEffect(t)}stop(){this.disposeSmogOverlay(),this.disposeWindowDropletsOverlay(),this.disposeActiveEffect(),this.currentEffect="none",this.stopLoop(),this.lastAppliedExtras={}}updateSmogOverlay(){const t=!!this.effectExtras.smogActive;t&&!this.smogOverlay?(this.smogOverlay=hu(this),this.scene.add(this.smogOverlay.group)):!t&&this.smogOverlay?this.disposeSmogOverlay():this.smogOverlay&&this.smogOverlay.setOpacity(this.opacity)}disposeSmogOverlay(){this.smogOverlay&&(this.scene.remove(this.smogOverlay.group),this.smogOverlay.dispose(),this.smogOverlay=null)}updateWindowDropletsOverlay(){const t=!!this.effectExtras.windowDroplets;t&&!this.windowDropletsOverlay?(this.windowDropletsOverlay=Zu(this),this.scene.add(this.windowDropletsOverlay.group)):!t&&this.windowDropletsOverlay?this.disposeWindowDropletsOverlay():this.windowDropletsOverlay&&this.windowDropletsOverlay.setOpacity(this.opacity)}disposeWindowDropletsOverlay(){this.windowDropletsOverlay&&(this.scene.remove(this.windowDropletsOverlay.group),this.windowDropletsOverlay.dispose(),this.windowDropletsOverlay=null)}setOpacity(t){this.opacity=Math.max(0,Math.min(100,t)),this.activeEffect?.setOpacity(this.opacity)}setSnowSurfaces(t){this.snowSurfaces=t||[],this.activeEffect?.setSnowSurfaces?.(this.snowSurfaces)}getLastAppliedExtras(){return{...this.lastAppliedExtras}}resize(t){if(this.viewportWidth=t.viewportWidth,this.viewportHeight=t.viewportHeight,this.renderTarget&&this.renderTarget.setSize(this.viewportWidth,this.viewportHeight),this.devicePixelRatio=t.devicePixelRatio??1,this.isMobile=t.isMobile??!1,this.viewWidth=this.computeViewWidth(_a),this.camera=this.createCamera(),this.renderer.setPixelRatio(Math.min(this.devicePixelRatio||1,this.isMobile?1:1.5)),this.renderer.setSize(this.viewportWidth,this.viewportHeight,!1),this.activeEffect?.onResize)this.activeEffect.onResize(this.viewWidth,this.viewHeight,this.isMobile,this.viewportWidth,this.viewportHeight),this.activeEffect.setSnowSurfaces?.(this.snowSurfaces);else if(this.currentEffect!=="none"){const e=this.currentEffect;this.currentEffect="none",this.setEffect(e)}}destroy(){this.stop(),this.renderTarget&&(this.renderTarget.dispose(),this.renderTarget=null),this.maskQuad?.material&&this.maskQuad.material.dispose(),this.maskScene?.clear(),this.renderer.dispose(),this.scene.clear()}startLoop(){this.animationFrame==null&&(this.lastTimestamp=0,this.animationFrame=vd(this.renderLoop))}stopLoop(){this.animationFrame!=null&&(_b(this.animationFrame),this.animationFrame=null)}renderFrame(t){this.lastTimestamp===0&&(this.lastTimestamp=t);const e=Math.min((t-this.lastTimestamp)/1e3,.05);this.lastTimestamp=t,this.activeEffect?.update(e,t/1e3),this.smogOverlay?.update(e),this.windowDropletsOverlay?.update(e);const n=this.effectExtras.spatialMode==="gradient-mask";n&&(this.ensureGradientMaskPass(),this.renderer.setRenderTarget(this.renderTarget)),this.renderer.render(this.scene,this.camera),n&&(this.renderer.setRenderTarget(null),this.maskQuad.material.uniforms.tDiffuse.value=this.renderTarget.texture,this.renderer.render(this.maskScene,this.maskCamera)),this.animationFrame=vd(this.renderLoop)}ensureGradientMaskPass(){if(this.renderTarget)return;this.renderTarget=new bl(this.viewportWidth,this.viewportHeight,{minFilter:be,magFilter:be,format:Ne,type:Qe,stencilBuffer:!1}),this.maskCamera=new ka(-1,1,1,-1,0,1),this.maskScene=new Ud;const t=new ee(2,2),e=new he({uniforms:{tDiffuse:{value:null},uInner:{value:.32},uOuter:{value:.85}},vertexShader:"varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }",fragmentShader:`
        uniform sampler2D tDiffuse;
        uniform float uInner;
        uniform float uOuter;
        varying vec2 vUv;
        void main() {
          vec4 tex = texture2D(tDiffuse, vUv);
          vec2 c = vUv - 0.5;
          float d = length(c) * 2.0;
          float mask = smoothstep(uInner, uOuter, d);
          gl_FragColor = vec4(tex.rgb, tex.a * mask);
        }
      `,transparent:!0,depthWrite:!1});this.maskQuad=new ae(t,e),this.maskScene.add(this.maskQuad)}setEffect(t){if(this.disposeActiveEffect(),this.currentEffect=t,t==="none"){this.stopLoop();return}const e=this.createEffectInstance(t);if(!e){this.stopLoop(),this.currentEffect="none";return}this.activeEffect=e,this.activeEffect.setOpacity(this.opacity),this.snowSurfaces.length&&this.activeEffect.setSnowSurfaces&&this.activeEffect.setSnowSurfaces(this.snowSurfaces),this.scene.add(e.group),this.lastAppliedExtras={...this.effectExtras},this.updateSmogOverlay(),this.updateWindowDropletsOverlay(),this.startLoop()}disposeActiveEffect(){this.activeEffect&&(this.scene.remove(this.activeEffect.group),this.activeEffect.dispose(),this.activeEffect=null)}createEffectInstance(t){const e={viewWidth:this.viewWidth,viewHeight:this.viewHeight,viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,isMobile:this.isMobile,effect:t,opacity:this.opacity,snowAccumulation:!!this.effectExtras.snowAccumulation,snowSurfaces:this.snowSurfaces,matrixRainColor:this.effectExtras.matrixRainColor,moonPosition:this.effectExtras.moonPosition};return t==="lightning"?Wu(e):t==="sun_beams"?pu(e):t==="stars"?ou(e):t==="matrix"?du(e):t==="clouds"?Gu(e):t==="hail"?Vu(e):t.startsWith("rain")?tu(e):t==="snow_layered"?nu(e):t.startsWith("snow")?lu(e):t.startsWith("fog")?ru(e):null}}function $b(l,t){const e=t?.6:1;return l==="rain_storm"?{count:Math.floor(600*e),length:{min:1.1,max:1.5},speed:{min:1.4,max:1.9},timeScale:1.2,lightning:!0,lightningOnly:!1}:l==="rain_drizzle"?{count:Math.floor(250*e),length:{min:.6,max:.9},speed:{min:.3,max:.6},timeScale:.6,lightning:!1,lightningOnly:!1}:{count:Math.floor(480*e),length:{min:.9,max:1.2},speed:{min:1,max:1.3},timeScale:1,lightning:!1,lightningOnly:!1}}function tu(l){const t=new pe,e=$b(l.effect,l.isMobile),n=e.count,i=new ee(.06,1),s=new Jd;s.index=i.index,s.attributes.position=i.attributes.position,s.attributes.uv=i.attributes.uv,s.instanceCount=n;const a=new Float32Array(n*3),d=new Float32Array(n),c=new Float32Array(n),o=new Float32Array(n),m=new Float32Array(n);for(let p=0;p<n;p++){const W=p*3;a[W]=jt.randFloatSpread(l.viewWidth+10),a[W+1]=jt.randFloatSpread(l.viewHeight),a[W+2]=Math.random()*.5,d[p]=jt.randFloat(e.speed.min,e.speed.max),c[p]=jt.randFloat(e.length.min,e.length.max),o[p]=jt.randFloat(.5,1.5),m[p]=Math.random()}s.setAttribute("instanceOffset",new je(a,3)),s.setAttribute("instanceSpeed",new je(d,1)),s.setAttribute("instanceLength",new je(c,1)),s.setAttribute("instanceSway",new je(o,1)),s.setAttribute("instancePhase",new je(m,1));const Z={uTime:{value:0},uOpacity:{value:l.opacity/100},uViewSize:{value:new Lt(l.viewWidth,l.viewHeight)}},b=new he({uniforms:Z,vertexShader:`
      attribute vec3 instanceOffset;
      attribute float instanceSpeed;
      attribute float instanceLength;
      attribute float instanceSway;
      attribute float instancePhase;
      uniform float uTime;
      uniform vec2 uViewSize;
      varying float vAlpha;
      void main() {
        float progress = fract(uTime * instanceSpeed + instancePhase);
        float travel = (uViewSize.y * 0.5) - progress * (uViewSize.y + 20.0);
        vec3 transformed = position;
        transformed.y *= instanceLength;
        transformed.x += instanceOffset.x + sin(progress * 6.28318 + instancePhase) * instanceSway;
        transformed.y += travel + instanceOffset.y;
        transformed.z += -5.0 + instanceOffset.z;
        vAlpha = 1.0 - progress;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
      }
    `,fragmentShader:`
      uniform float uOpacity;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(0.65, 0.75, 0.9, clamp(vAlpha * 0.85 * uOpacity, 0.0, 1.0));
      }
    `,transparent:!0,depthWrite:!1,blending:Ae}),h=new ae(s,b);return h.frustumCulled=!1,t.add(h),{group:t,update(p){Z.uTime.value+=p*e.timeScale,Z.uViewSize.value.set(l.viewWidth,l.viewHeight)},setOpacity(p){Z.uOpacity.value=Math.max(0,Math.min(1,p/100))},onResize(p,W){l.viewWidth=p,l.viewHeight=W,Z.uViewSize.value.set(p,W)},dispose(){s.dispose(),b.dispose()}}}function eu(l,t){const e=t?.6:1;return Math.floor(l==="snow_storm"?1e3*e:600*e)}function lu(l){const t=new pe,e=eu(l.effect,l.isMobile),n=new Float32Array(e*3),i=new Float32Array(e*3);for(let m=0;m<e;m++){const Z=m*3;n[Z]=jt.randFloatSpread(l.viewWidth+30),n[Z+1]=jt.randFloatSpread(l.viewHeight+30),n[Z+2]=Math.random()*4-2,i[Z]=jt.randFloat(-.2,.2),i[Z+1]=l.effect==="snow_storm"?jt.randFloat(-1.4,-.9):jt.randFloat(-.8,-.4),i[Z+2]=jt.randFloat(-.05,.05)}const s=new Le;s.setAttribute("position",new Ce(n,3));const a=kd(),d=l.effect==="snow_storm"?.9:.75,c=new ui({map:a,transparent:!0,opacity:d*(l.opacity/100),sizeAttenuation:!1,size:l.effect==="snow_storm"?3.4:2.6,color:16777215,depthWrite:!1,depthTest:!1,blending:Ae}),o=new Da(s,c);return o.frustumCulled=!1,t.add(o),{group:t,update(m){const Z=s.attributes.position.array;for(let b=0;b<Z.length;b+=3){Z[b]+=i[b]*m*25,Z[b+1]+=i[b+1]*m*25,Z[b+2]+=i[b+2]*m*10;const h=l.viewWidth/2+15,p=l.viewHeight/2+15;Z[b+1]<-p&&(Z[b+1]=p,Z[b]=jt.randFloatSpread(l.viewWidth+30)),Z[b]<-h&&(Z[b]=h),Z[b]>h&&(Z[b]=-h)}s.attributes.position.needsUpdate=!0},setOpacity(m){c.opacity=d*Math.max(0,Math.min(1,m/100))},onResize(m,Z){l.viewWidth=m,l.viewHeight=Z},dispose(){s.dispose(),c.dispose(),a.dispose()}}}const wd=[{sizeMin:24,sizeMax:40,speedFactor:.12,swayAmpMin:10,swayAmpMax:30,opacity:1,colorMin:255,colorMax:255},{sizeMin:20,sizeMax:28,speedFactor:.09,swayAmpMin:10,swayAmpMax:25,opacity:.85,colorMin:255,colorMax:255},{sizeMin:16,sizeMax:24,speedFactor:.07,swayAmpMin:10,swayAmpMax:20,opacity:.75,colorMin:255,colorMax:255},{sizeMin:12,sizeMax:18,speedFactor:.05,swayAmpMin:10,swayAmpMax:20,opacity:.65,colorMin:220,colorMax:229},{sizeMin:10,sizeMax:14,speedFactor:.03,swayAmpMin:10,swayAmpMax:20,opacity:.55,colorMin:210,colorMax:219},{sizeMin:8,sizeMax:12,speedFactor:.01,swayAmpMin:10,swayAmpMax:20,opacity:.4,colorMin:200,colorMax:209}];function nu(l){const t=new pe;let e=l.isMobile?180:300;const n=Math.floor(e/wd.length),i=kd(),s=wd.map(a=>{const d=new Float32Array(n*3),c=new Float32Array(n),o=new Float32Array(n),m=new Float32Array(n),Z=new Float32Array(n);for(let r=0;r<n;r++){const u=r*3,S=a.sizeMin+Math.random()*(a.sizeMax-a.sizeMin);d[u]=jt.randFloatSpread(l.viewWidth+20),d[u+1]=jt.randFloatSpread(l.viewHeight+20),d[u+2]=Math.random()*2-1,c[r]=S*a.speedFactor*.15+Math.random()*.02,o[r]=a.swayAmpMin+Math.random()*(a.swayAmpMax-a.swayAmpMin),m[r]=Math.random()*Math.PI*2,Z[r]=.01+Math.random()*.02}const b=new Le;b.setAttribute("position",new Ce(d,3));const h=(a.sizeMin+a.sizeMax)/2,p=new ui({map:i,transparent:!0,opacity:a.opacity*(l.opacity/100),sizeAttenuation:!1,size:h*.15,color:16777215,depthWrite:!1,depthTest:!1,blending:Ae}),W=new Da(b,p);return W.frustumCulled=!1,t.add(W),{geo:b,mat:p,fallSpeeds:c,swayAmps:o,swayOffsets:m,swaySpeeds:Z,baseOpacity:a.opacity}});return{group:t,update(a){s.forEach(d=>{const c=d.geo.attributes.position.array,o=a*60;for(let m=0;m<c.length/3;m++){const Z=m*3;d.swayOffsets[m]+=d.swaySpeeds[m];const b=Math.sin(d.swayOffsets[m])*d.swayAmps[m]*.08;c[Z]+=b*o,c[Z+1]-=d.fallSpeeds[m]*o;const h=l.viewWidth/2+15,p=l.viewHeight/2+15;c[Z+1]<-p&&(c[Z+1]=p,c[Z]=jt.randFloatSpread(l.viewWidth+20)),c[Z]<-h&&(c[Z]=h),c[Z]>h&&(c[Z]=-h)}d.geo.attributes.position.needsUpdate=!0})},setOpacity(a){const d=Math.max(0,Math.min(1,a/100));s.forEach(c=>{c.mat.opacity=c.baseOpacity*d})},onResize(a,d){l.viewWidth=a,l.viewHeight=d},dispose(){s.forEach(a=>{a.geo.dispose(),a.mat.dispose()}),i.dispose()}}}const Hd=["園","迎","簡","益","大","诶","比","西","迪","伊","弗","吉","尺","杰","开","艾","勒","马","娜"],iu="#00ff41",au="#00cc33",su=85;function du(l){const t=new pe,e=Math.max(256,Math.floor(l.viewportWidth/2)),n=Math.max(256,Math.floor(l.viewportHeight/2)),{canvas:i,ctx:s}=Wi(e,n),a=Vi(i);a.minFilter=be,a.magFilter=be;const d=new ee(l.viewWidth,l.viewHeight),c=new Yn({map:a,transparent:!0,opacity:.9*(l.opacity/100),depthWrite:!1}),o=new ae(d,c);t.add(o);const m=[];let Z=0;return{group:t,update(b){const h=i.width,p=i.height,W=h/l.viewportWidth;Z+=b*1e3;const r=p/3,u=m.some(X=>X.y>r);if((m.length===0||u)&&Z>=.8&&m.length<6){Z=0;const X=h*.28,M=h*.72;let I=15,x;do{x=Math.random()<.5?30+Math.random()*(X-60):M+30+Math.random()*(h-M-60);const R=su*(h/l.viewportWidth);if(!m.some(Y=>Math.abs(Y.x-x)<R))break}while(--I>0);if(I>0){const U=4+Math.floor(Math.random()*8);m.push({x,y:-80,chars:Array.from({length:U},()=>Hd[Math.floor(Math.random()*Hd.length)]),speed:(.15+Math.random()*.12)*W})}}s.fillStyle="rgba(0,0,0,0.08)",s.fillRect(0,0,h,p),s.font=`${Math.max(12,16*W)}px monospace`,s.textAlign="center",s.textBaseline="top";const C=h/2;for(let X=m.length-1;X>=0;X--){const M=m[X];if(M.y+=M.speed,M.y>p+150){m.splice(X,1);continue}const I=Math.abs(M.x-C),x=I<h*.2?.5+I/(h*.2)*.4:.9,U=16*W;for(let R=0;R<M.chars.length;R++){const g=1-R/M.chars.length*.5;s.globalAlpha=g*x,s.fillStyle=R===0?iu:au,s.fillText(M.chars[R],M.x,M.y+R*U)}s.globalAlpha=1}a.needsUpdate=!0},setOpacity(b){c.opacity=.9*Math.max(0,Math.min(1,b/100))},onResize(b,h){l.viewWidth=b,l.viewHeight=h,o.geometry.dispose(),o.geometry=new ee(b,h)},dispose(){d.dispose(),c.dispose(),a.dispose()}}}function cu(l){return Math.floor(l?400*.6:400)}function ou(l){const t=new pe,e=cu(l.isMobile),n=new Float32Array(e*3),i=l.moonPosition;for(let Z=0;Z<e;Z++){const b=Z*3;n[b]=jt.randFloatSpread(l.viewWidth+20),n[b+1]=jt.randFloatSpread(l.viewHeight+20),n[b+2]=Math.random()*2-1}const s=new Le;s.setAttribute("position",new Ce(n,3));const a=Ob(),d=new ui({map:a,transparent:!0,opacity:.85*(l.opacity/100),sizeAttenuation:!1,size:2,color:15267071,depthWrite:!1,depthTest:!1,blending:Ae}),c=new Da(s,d);c.frustumCulled=!1,t.add(c);let o=null;if(i&&typeof i.x=="number"&&typeof i.y=="number"){const Z=(i.x-.5)*l.viewWidth,b=(.5-i.y)*l.viewHeight,h=Math.max(l.viewWidth,l.viewHeight)*.45,p=new ee(h,h),W=new he({uniforms:{uOpacity:{value:.22*(l.opacity/100)}},vertexShader:"varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }",fragmentShader:`
        varying vec2 vUv;
        uniform float uOpacity;
        void main() {
          vec2 c = vUv - 0.5;
          float d = length(c) * 2.0;
          float alpha = exp(-d * d * 2.8) * uOpacity;
          gl_FragColor = vec4(0.96, 0.97, 1.0, alpha);
        }
      `,transparent:!0,depthWrite:!1,blending:Ae});o=new ae(p,W),o.position.set(Z,b,-1),o.renderOrder=1,t.add(o)}let m=0;return{group:t,update(Z){m+=Z*1.2,d.opacity=.85*(l.opacity/100)*(.8+.2*Math.sin(m))},setOpacity(Z){d.opacity=.85*Math.max(0,Math.min(1,Z/100))},onResize(Z,b){l.viewWidth=Z,l.viewHeight=b},dispose(){s.dispose(),d.dispose(),a.dispose(),o&&(o.geometry.dispose(),o.material.dispose())}}}const mu=55;function Zu(l){const t=l.viewWidth,e=l.viewHeight,{canvas:n,ctx:i}=Wi(Math.max(256,Math.floor(l.viewportWidth/2)),Math.max(256,Math.floor(l.viewportHeight/2))),s=Vi(n);s.minFilter=be,s.magFilter=be;const a=new ee(t,e),d=new Yn({map:s,transparent:!0,opacity:.95*(l.opacity/100),depthWrite:!1}),c=new ae(a,d);c.renderOrder=5;const o=new pe;o.add(c);const m=[];let Z=0,b=0;function h(W,r,u){for(const S of m){const C=W-S.x,X=r-S.y,M=mu+(u+S.size)*.5;if(C*C+X*X<M*M)return!0}return!1}function p(){return 2200+Math.random()*2800}return{group:o,update(W){const r=n.width,u=n.height,S=Math.min(W*1e3,50);if(Z+=S,b<=0&&(b=p()),Z>=b){Z=0,b=p();const C=.18,X=r*C,M=r*(1-C),I=Math.random()<.5?"left":"right",x=4+Math.random()*6;let U,R,g=12;do U=I==="left"?Math.random()*X:M+Math.random()*(r-M),R=Math.random()*u*.55;while(--g>0&&h(U,R,x));g>0&&m.push({x:U,y:R,size:x,phase:"appear",opacity:0,life:0,appearDur:300,restDur:2e3+Math.random()*2500,slideVel:8+Math.random()*6,slideAccel:.8+Math.random()*.6})}i.clearRect(0,0,r,u);for(let C=m.length-1;C>=0;C--){const X=m[C];if(X.life+=S,X.phase==="appear")X.opacity=Math.min(1,X.life/X.appearDur*1.8),X.life>=X.appearDur&&(X.phase="rest",X.life=0,X.opacity=1);else if(X.phase==="rest")X.life>=X.restDur&&(X.phase="slide",X.life=0);else{const M=S/1e3;X.slideVel=(X.slideVel||8)+X.slideAccel*M*60,X.y+=X.slideVel*M;const I=X.y/u;if(X.opacity=I<.85?1:Math.max(0,(1-I)/.15),X.y>u+X.size*2){m.splice(C,1);continue}}if(X.y<=u+X.size*2){i.save(),i.globalAlpha=X.opacity;const M=i.createRadialGradient(X.x-X.size*.3,X.y-X.size*.3,0,X.x,X.y,X.size*1.5);M.addColorStop(0,"rgba(230, 240, 255, 0.75)"),M.addColorStop(.35,"rgba(200, 218, 242, 0.55)"),M.addColorStop(.7,"rgba(170, 190, 215, 0.25)"),M.addColorStop(1,"rgba(150, 170, 195, 0)"),i.fillStyle=M,i.beginPath(),i.ellipse(X.x,X.y,X.size*.5,X.size*1.1,0,0,Math.PI*2),i.fill(),i.restore()}}s.needsUpdate=!0},setOpacity(W){d.opacity=.95*Math.max(0,Math.min(1,W/100))},dispose(){a.dispose(),d.dispose(),s.dispose()}}}function hu(l){const t=l.viewWidth,e=l.viewHeight,n=new ee(t,e),i={uTime:{value:0},uOpacity:{value:.18*(l.opacity/100)},uScale:{value:1.4},uResolution:{value:new Lt(t,e)}},s=new he({uniforms:i,vertexShader:Oa,fragmentShader:`
      varying vec2 vUv;
      uniform float uTime;
      uniform float uOpacity;
      uniform float uScale;
      uniform vec2 uResolution;
      float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
      float noise(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(mix(hash(i), hash(i + vec2(1,0)), u.x), mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), u.x), u.y);
      }
      float fbm(vec2 p) {
        float v = 0.0, amp = 0.5;
        for (int i = 0; i < 4; i++) {
          v += amp * noise(p);
          p *= 2.0;
          amp *= 0.5;
        }
        return v;
      }
      void main() {
        vec2 aspect = vec2(uResolution.x / max(uResolution.y, 0.0001), 1.0);
        vec2 uv = (vUv - 0.5) * aspect + 0.5;
        uv *= uScale;
        uv += vec2(0.02, -0.04) * uTime;
        float d = fbm(uv);
        d = smoothstep(0.2, 0.65, d);
        float vMask = smoothstep(0.0, 0.55, vUv.y);
        vec3 color = vec3(0.55, 0.52, 0.48);
        gl_FragColor = vec4(color, d * vMask * uOpacity);
      }
    `,transparent:!0,depthWrite:!1,blending:Ee}),a=new ae(n,s);a.renderOrder=10;const d=new pe;return d.add(a),{group:d,update(c){i.uTime.value+=c*.15},setOpacity(c){i.uOpacity.value=.18*Math.max(0,Math.min(1,c/100))},dispose(){n.dispose(),s.dispose()}}}function bu(l,t){const e=l==="fog_dense",n=e?.225:.11,i=t?.85:1,s=e?[{scale:1*i,speed:.28,intensity:1,flow:new Lt(.08,.02),low:.25,high:.78,contrast:1.1,color:[.86,.89,.95]},{scale:1.6*i,speed:.36,intensity:.85,flow:new Lt(-.05,.025),low:.2,high:.7,contrast:1.22,color:[.9,.92,.97]}]:[{scale:1.2*i,speed:.22,intensity:.75,flow:new Lt(.05,.015),low:.3,high:.82,contrast:1.15,color:[.88,.91,.96]},{scale:1.9*i,speed:.3,intensity:.55,flow:new Lt(-.03,.012),low:.25,high:.75,contrast:1.22,color:[.8,.84,.92]}];return{baseOpacity:n,layers:s}}const uu=`
  varying vec2 vUv;
  uniform float uTime;
  uniform float uOpacity;
  uniform float uScale;
  uniform vec2 uFlow;
  uniform vec2 uResolution;
  uniform float uLow;
  uniform float uHigh;
  uniform float uContrast;
  uniform vec3 uColor;
  float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123); }
  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(
      mix(hash(i), hash(i + vec2(1,0)), u.x),
      mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), u.x), u.y);
  }
  float fbm(vec2 p) {
    float v = 0.0, amp = 0.5;
    for (int i = 0; i < 5; i++) {
      v += amp * noise(p);
      p *= 2.0;
      amp *= 0.5;
    }
    return v;
  }
  void main() {
    vec2 aspect = vec2(uResolution.x / max(uResolution.y, 0.0001), 1.0);
    vec2 uv = (vUv - 0.5) * aspect + 0.5;
    uv *= uScale;
    uv += uFlow * uTime;
    float primary = fbm(uv);
    float detail = fbm(uv * 1.8 - uFlow.yx * (uTime * 0.35));
    float density = mix(primary, detail, 0.35);
    density = smoothstep(uLow, uHigh, density);
    density = pow(density, uContrast);
    gl_FragColor = vec4(uColor, density * uOpacity);
  }
`;function ru(l){const t=new pe,e=bu(l.effect,l.isMobile),n=e.layers.map(i=>{const s=new ee(l.viewWidth,l.viewHeight),a={uTime:{value:0},uOpacity:{value:e.baseOpacity*i.intensity*(l.opacity/100)},uScale:{value:i.scale},uFlow:{value:i.flow.clone()},uResolution:{value:new Lt(l.viewWidth,l.viewHeight)},uLow:{value:i.low},uHigh:{value:i.high},uContrast:{value:i.contrast},uColor:{value:new Kt(i.color[0],i.color[1],i.color[2])}},d=new he({uniforms:a,vertexShader:Oa,fragmentShader:uu,transparent:!0,depthWrite:!1,blending:Ee}),c=new ae(s,d);return c.renderOrder=-3,t.add(c),{mesh:c,uniforms:a,config:i}});return{group:t,update(i){n.forEach(s=>{s.uniforms.uTime.value+=i*s.config.speed})},setOpacity(i){const s=Math.max(0,Math.min(1,i/100)),a=l.isMobile?.75:1;n.forEach(d=>{d.uniforms.uOpacity.value=e.baseOpacity*d.config.intensity*s*a})},onResize(i,s){l.viewWidth=i,l.viewHeight=s,n.forEach(a=>{a.uniforms.uResolution.value.set(i,s),a.mesh.geometry.dispose(),a.mesh.geometry=new ee(i,s)})},dispose(){n.forEach(i=>{i.mesh.geometry.dispose(),i.mesh.material.dispose()})}}}function pu(l){const t=new pe;let e=new ee(l.viewWidth,l.viewHeight);const n={uTime:{value:0},uOpacity:{value:l.opacity/100},uViewSize:{value:new Lt(l.viewWidth,l.viewHeight)}},i=new he({uniforms:n,vertexShader:"varying vec3 vPosition; void main() { vPosition = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }",fragmentShader:`
      varying vec3 vPosition;
      uniform vec2 uViewSize;
      uniform float uTime;
      uniform float uOpacity;
      void main() {
        vec2 uv = vec2((vPosition.x / uViewSize.x) + 0.5, (vPosition.y / uViewSize.y) + 0.5);
        vec2 origin = vec2(1.1, 1.05);
        vec2 dir = origin - uv;
        float dist = length(dir);
        float angle = atan(dir.y, dir.x);
        float beams = sin(angle * 18.0 + uTime * 0.8) * 0.5 + 0.5;
        float intensity = smoothstep(0.6, 0.0, dist) * beams;
        float alpha = intensity * 0.65 * uOpacity;
        vec3 color = mix(vec3(1.0, 0.95, 0.8), vec3(1.0, 0.85, 0.4), dist);
        gl_FragColor = vec4(color, alpha);
      }
    `,transparent:!0,depthWrite:!1,blending:Ae}),s=new ae(e,i);return s.position.set(0,0,-2),t.add(s),{group:t,update(a){n.uTime.value+=a},setOpacity(a){n.uOpacity.value=Math.max(0,Math.min(1,a/100))},onResize(a,d){l.viewWidth=a,l.viewHeight=d,n.uViewSize.value.set(a,d),e.dispose(),e=new ee(a,d),s.geometry=e},dispose(){e.dispose(),i.dispose()}}}function Gu(l){const t=new pe,e=.6;let n=new ee(l.viewWidth,l.viewHeight*e);const i={uTime:{value:0},uOpacity:{value:l.opacity/100},uViewSize:{value:new Lt(l.viewWidth,l.viewHeight)},uScale:{value:l.isMobile?1.5:1}},s=`
    varying vec2 vUv;
    uniform float uTime;
    uniform float uOpacity;
    uniform float uScale;
    float hash(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
    float noise(vec2 p) {
      vec2 i = floor(p);
      vec2 f = fract(p);
      vec2 u = f * f * (3.0 - 2.0 * f);
      return mix(mix(hash(i), hash(i+vec2(1,0)), u.x), mix(hash(i+vec2(0,1)), hash(i+vec2(1,1)), u.x), u.y);
    }
    float fbm(vec2 p) {
      float v = 0.0, amp = 0.5, freq = 1.0;
      for (int i = 0; i < 6; i++) {
        v += amp * noise(p * freq);
        amp *= 0.5;
        freq *= 2.0;
      }
      return v;
    }
    void main() {
      vec2 uv = vUv * uScale;
      float time = uTime * 0.05;
      vec2 q = vec2(fbm(uv + vec2(time * 0.5, time * 0.2)), fbm(uv + vec2(1.0)));
      vec2 r = vec2(fbm(uv + q + vec2(1.7, 9.2) + 0.15 * time), fbm(uv + q + vec2(8.3, 2.8) + 0.126 * time));
      float f = fbm(uv + r);
      float cloud = smoothstep(0.2, 0.7, f);
      cloud *= smoothstep(0.0, 0.3, vUv.y);
      cloud *= smoothstep(1.0, 0.8, vUv.y);
      float shadow = smoothstep(0.3, 0.6, fbm(uv * 2.0 + r + vec2(0.5)));
      vec3 color = mix(vec3(0.81, 0.82, 0.89), vec3(1.0), shadow * 0.8 + 0.2);
      gl_FragColor = vec4(color, cloud * uOpacity * 0.24);
    }
  `,a=new he({uniforms:i,vertexShader:"varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }",fragmentShader:s,transparent:!0,depthWrite:!1,blending:Ee}),d=new ae(n,a);return d.position.set(0,l.viewHeight*.25,-6),d.renderOrder=-2,t.add(d),{group:t,update(c){i.uTime.value+=c},setOpacity(c){i.uOpacity.value=Math.max(0,Math.min(1,c/100))},onResize(c,o,m){n.dispose(),n=new ee(c,o*e),d.geometry=n,i.uViewSize.value.set(c,o),i.uScale.value=m?1.5:1,d.position.set(0,o*.25,-6)},dispose(){n.dispose(),a.dispose()}}}function Wu(l){const t=new pe,e=`
    varying vec2 vUv;
    uniform float uFlash;
    uniform vec2 uOrigin;
    uniform float uTime;
    float hash(float n) { return fract(sin(n) * 43758.5453); }
    float jaggedLine(vec2 uv, float anchor, float seed) {
      float segments = 8.0;
      float progress = clamp(1.0 - uv.y, 0.0, 0.999) * segments;
      float idx = floor(progress);
      float frac = fract(progress);
      float offsetA = hash(seed + idx) * 0.24 - 0.12;
      float offsetB = hash(seed + idx + 1.0) * 0.24 - 0.12;
      float offset = mix(offsetA, offsetB, smoothstep(0.0, 1.0, frac));
      float width = mix(0.006, 0.02, hash(seed + idx * 1.7));
      float target = anchor + offset;
      float dist = abs(uv.x - target);
      float intensity = smoothstep(width, 0.0, dist);
      float fade = smoothstep(0.0, 0.9, 1.0 - uv.y);
      return intensity * fade;
    }
    void main() {
      float seed = floor(uTime * 11.0);
      float core = jaggedLine(vUv, uOrigin.x, seed);
      float halo = jaggedLine(vUv, uOrigin.x + 0.008, seed + 2.0) * 0.4;
      float alpha = clamp((core + halo) * uFlash, 0.0, 1.0);
      gl_FragColor = vec4(1.0, 0.98, 0.9, alpha);
    }
  `,n={uFlash:{value:0},uOrigin:{value:new Lt(.85,1.05)},uTime:{value:0}};let i=new ee(l.viewWidth,l.viewHeight);const s=new he({uniforms:n,vertexShader:Oa,fragmentShader:e,transparent:!0,depthWrite:!1,depthTest:!1,blending:Ae}),a=new ae(i,s);a.position.set(0,0,-6),a.renderOrder=25,t.add(a);let d=new ee(l.viewWidth,l.viewHeight);const c=new Yn({color:16777215,transparent:!0,opacity:0,depthWrite:!1,depthTest:!1,blending:Ae}),o=new ae(d,c);o.position.set(0,0,-8),o.renderOrder=30,t.add(o);let m=jt.randFloat(1,3),Z=0,b=.25;const h=Math.max(0,Math.min(1,l.opacity/100)),p=()=>{b=jt.randFloat(.18,.32),Z=b,n.uFlash.value=1,n.uOrigin.value.set(jt.randFloat(.6,.95),jt.randFloat(.85,1.05)),c.opacity=Math.max(c.opacity,.55*h+.15)};return{group:t,update(W){if(m-=W,m<=0&&(m=jt.randFloat(1.5,4),p()),n.uTime.value+=W,Z>0){Z-=W;const r=Math.max(0,Z/Math.max(b,.001));n.uFlash.value=Math.pow(r,1.4)*h}else n.uFlash.value>0&&(n.uFlash.value=Math.max(0,n.uFlash.value-W*8));c.opacity=Math.max(0,c.opacity-W*6)},setOpacity(W){const r=Math.max(0,Math.min(1,W/100));n.uFlash.value*=r/h},onResize(W,r){l.viewWidth=W,l.viewHeight=r,i.dispose(),i=new ee(W,r),a.geometry=i,d.dispose(),d=new ee(W,r),o.geometry=d},dispose(){i.dispose(),s.dispose(),d.dispose(),c.dispose()}}}function Vu(l){const t=new pe,e=l.isMobile?10:15,n=new ee(.25,.25),i=new Jd;i.index=n.index,i.attributes.position=n.attributes.position,i.attributes.uv=n.attributes.uv,i.instanceCount=e;const s=new Float32Array(e*3),a=new Float32Array(e),d=new Float32Array(e),c=new Float32Array(e),o=new Float32Array(e);for(let h=0;h<e;h++){const p=h*3;s[p]=jt.randFloatSpread(l.viewWidth+10),s[p+1]=jt.randFloatSpread(l.viewHeight),s[p+2]=Math.random()*2,a[h]=jt.randFloat(2.8,4),d[h]=jt.randFloat(1.8,2.8),c[h]=Math.random()*Math.PI*2,o[h]=Math.random()}i.setAttribute("instanceOffset",new je(s,3)),i.setAttribute("instanceSpeed",new je(a,1)),i.setAttribute("instanceSize",new je(d,1)),i.setAttribute("instanceRotation",new je(c,1)),i.setAttribute("instancePhase",new je(o,1));const m={uTime:{value:0},uOpacity:{value:l.opacity/100},uViewSize:{value:new Lt(l.viewWidth,l.viewHeight)}},Z=new he({uniforms:m,vertexShader:`
      attribute vec3 instanceOffset;
      attribute float instanceSpeed;
      attribute float instanceSize;
      attribute float instanceRotation;
      attribute float instancePhase;
      uniform float uTime;
      uniform vec2 uViewSize;
      varying float vAlpha;
      void main() {
        float progress = fract(uTime * instanceSpeed + instancePhase);
        float travel = (uViewSize.y * 0.5) - progress * (uViewSize.y + 20.0);
        float angle = instanceRotation + uTime * instanceSpeed * 3.0;
        vec2 rotated = vec2(position.x * cos(angle) - position.y * sin(angle), position.x * sin(angle) + position.y * cos(angle));
        vec3 transformed = vec3(rotated * instanceSize, position.z);
        transformed.x += instanceOffset.x;
        transformed.y += travel + instanceOffset.y;
        transformed.z += -5.0 + instanceOffset.z;
        vAlpha = 1.0;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
      }
    `,fragmentShader:`
      uniform float uOpacity;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(0.95, 0.98, 1.0, vAlpha * uOpacity);
      }
    `,transparent:!0,depthWrite:!1,blending:Ee}),b=new ae(i,Z);return b.frustumCulled=!1,t.add(b),{group:t,update(h){m.uTime.value+=h,m.uViewSize.value.set(l.viewWidth,l.viewHeight)},setOpacity(h){m.uOpacity.value=Math.max(0,Math.min(1,h/100))},onResize(h,p){l.viewWidth=h,l.viewHeight=p,m.uViewSize.value.set(h,p)},dispose(){i.dispose(),Z.dispose()}}}const zd="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiOy8qKgogKiBAbGljZW5zZQogKiBDb3B5cmlnaHQgMjAxMC0yMDI0IFRocmVlLmpzIEF1dGhvcnMKICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVAogKi9jb25zdCBOaT0iMTcwIixqdD0iIix3dD0ic3JnYiIseG49InNyZ2ItbGluZWFyIixpaT0ibGluZWFyIixxZT0ic3JnYiIseHI9IjMwMCBlcyI7Y2xhc3MgTW57YWRkRXZlbnRMaXN0ZW5lcihlLHQpe3RoaXMuX2xpc3RlbmVycz09PXZvaWQgMCYmKHRoaXMuX2xpc3RlbmVycz17fSk7Y29uc3Qgbj10aGlzLl9saXN0ZW5lcnM7bltlXT09PXZvaWQgMCYmKG5bZV09W10pLG5bZV0uaW5kZXhPZih0KT09PS0xJiZuW2VdLnB1c2godCl9aGFzRXZlbnRMaXN0ZW5lcihlLHQpe2lmKHRoaXMuX2xpc3RlbmVycz09PXZvaWQgMClyZXR1cm4hMTtjb25zdCBuPXRoaXMuX2xpc3RlbmVycztyZXR1cm4gbltlXSE9PXZvaWQgMCYmbltlXS5pbmRleE9mKHQpIT09LTF9cmVtb3ZlRXZlbnRMaXN0ZW5lcihlLHQpe2lmKHRoaXMuX2xpc3RlbmVycz09PXZvaWQgMClyZXR1cm47Y29uc3Qgcj10aGlzLl9saXN0ZW5lcnNbZV07aWYociE9PXZvaWQgMCl7Y29uc3Qgcz1yLmluZGV4T2YodCk7cyE9PS0xJiZyLnNwbGljZShzLDEpfX1kaXNwYXRjaEV2ZW50KGUpe2lmKHRoaXMuX2xpc3RlbmVycz09PXZvaWQgMClyZXR1cm47Y29uc3Qgbj10aGlzLl9saXN0ZW5lcnNbZS50eXBlXTtpZihuIT09dm9pZCAwKXtlLnRhcmdldD10aGlzO2NvbnN0IHI9bi5zbGljZSgwKTtmb3IobGV0IHM9MCxhPXIubGVuZ3RoO3M8YTtzKyspcltzXS5jYWxsKHRoaXMsZSk7ZS50YXJnZXQ9bnVsbH19fWNvbnN0IGR0PVsiMDAiLCIwMSIsIjAyIiwiMDMiLCIwNCIsIjA1IiwiMDYiLCIwNyIsIjA4IiwiMDkiLCIwYSIsIjBiIiwiMGMiLCIwZCIsIjBlIiwiMGYiLCIxMCIsIjExIiwiMTIiLCIxMyIsIjE0IiwiMTUiLCIxNiIsIjE3IiwiMTgiLCIxOSIsIjFhIiwiMWIiLCIxYyIsIjFkIiwiMWUiLCIxZiIsIjIwIiwiMjEiLCIyMiIsIjIzIiwiMjQiLCIyNSIsIjI2IiwiMjciLCIyOCIsIjI5IiwiMmEiLCIyYiIsIjJjIiwiMmQiLCIyZSIsIjJmIiwiMzAiLCIzMSIsIjMyIiwiMzMiLCIzNCIsIjM1IiwiMzYiLCIzNyIsIjM4IiwiMzkiLCIzYSIsIjNiIiwiM2MiLCIzZCIsIjNlIiwiM2YiLCI0MCIsIjQxIiwiNDIiLCI0MyIsIjQ0IiwiNDUiLCI0NiIsIjQ3IiwiNDgiLCI0OSIsIjRhIiwiNGIiLCI0YyIsIjRkIiwiNGUiLCI0ZiIsIjUwIiwiNTEiLCI1MiIsIjUzIiwiNTQiLCI1NSIsIjU2IiwiNTciLCI1OCIsIjU5IiwiNWEiLCI1YiIsIjVjIiwiNWQiLCI1ZSIsIjVmIiwiNjAiLCI2MSIsIjYyIiwiNjMiLCI2NCIsIjY1IiwiNjYiLCI2NyIsIjY4IiwiNjkiLCI2YSIsIjZiIiwiNmMiLCI2ZCIsIjZlIiwiNmYiLCI3MCIsIjcxIiwiNzIiLCI3MyIsIjc0IiwiNzUiLCI3NiIsIjc3IiwiNzgiLCI3OSIsIjdhIiwiN2IiLCI3YyIsIjdkIiwiN2UiLCI3ZiIsIjgwIiwiODEiLCI4MiIsIjgzIiwiODQiLCI4NSIsIjg2IiwiODciLCI4OCIsIjg5IiwiOGEiLCI4YiIsIjhjIiwiOGQiLCI4ZSIsIjhmIiwiOTAiLCI5MSIsIjkyIiwiOTMiLCI5NCIsIjk1IiwiOTYiLCI5NyIsIjk4IiwiOTkiLCI5YSIsIjliIiwiOWMiLCI5ZCIsIjllIiwiOWYiLCJhMCIsImExIiwiYTIiLCJhMyIsImE0IiwiYTUiLCJhNiIsImE3IiwiYTgiLCJhOSIsImFhIiwiYWIiLCJhYyIsImFkIiwiYWUiLCJhZiIsImIwIiwiYjEiLCJiMiIsImIzIiwiYjQiLCJiNSIsImI2IiwiYjciLCJiOCIsImI5IiwiYmEiLCJiYiIsImJjIiwiYmQiLCJiZSIsImJmIiwiYzAiLCJjMSIsImMyIiwiYzMiLCJjNCIsImM1IiwiYzYiLCJjNyIsImM4IiwiYzkiLCJjYSIsImNiIiwiY2MiLCJjZCIsImNlIiwiY2YiLCJkMCIsImQxIiwiZDIiLCJkMyIsImQ0IiwiZDUiLCJkNiIsImQ3IiwiZDgiLCJkOSIsImRhIiwiZGIiLCJkYyIsImRkIiwiZGUiLCJkZiIsImUwIiwiZTEiLCJlMiIsImUzIiwiZTQiLCJlNSIsImU2IiwiZTciLCJlOCIsImU5IiwiZWEiLCJlYiIsImVjIiwiZWQiLCJlZSIsImVmIiwiZjAiLCJmMSIsImYyIiwiZjMiLCJmNCIsImY1IiwiZjYiLCJmNyIsImY4IiwiZjkiLCJmYSIsImZiIiwiZmMiLCJmZCIsImZlIiwiZmYiXTtsZXQgTXI9MTIzNDU2Nztjb25zdCBIbj1NYXRoLlBJLzE4MCxWbj0xODAvTWF0aC5QSTtmdW5jdGlvbiBTbigpe2NvbnN0IGk9TWF0aC5yYW5kb20oKSo0Mjk0OTY3Mjk1fDAsZT1NYXRoLnJhbmRvbSgpKjQyOTQ5NjcyOTV8MCx0PU1hdGgucmFuZG9tKCkqNDI5NDk2NzI5NXwwLG49TWF0aC5yYW5kb20oKSo0Mjk0OTY3Mjk1fDA7cmV0dXJuKGR0W2kmMjU1XStkdFtpPj44JjI1NV0rZHRbaT4+MTYmMjU1XStkdFtpPj4yNCYyNTVdKyItIitkdFtlJjI1NV0rZHRbZT4+OCYyNTVdKyItIitkdFtlPj4xNiYxNXw2NF0rZHRbZT4+MjQmMjU1XSsiLSIrZHRbdCY2M3wxMjhdK2R0W3Q+PjgmMjU1XSsiLSIrZHRbdD4+MTYmMjU1XStkdFt0Pj4yNCYyNTVdK2R0W24mMjU1XStkdFtuPj44JjI1NV0rZHRbbj4+MTYmMjU1XStkdFtuPj4yNCYyNTVdKS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIF90KGksZSx0KXtyZXR1cm4gTWF0aC5tYXgoZSxNYXRoLm1pbih0LGkpKX1mdW5jdGlvbiBPaShpLGUpe3JldHVybihpJWUrZSklZX1mdW5jdGlvbiBxcyhpLGUsdCxuLHIpe3JldHVybiBuKyhpLWUpKihyLW4pLyh0LWUpfWZ1bmN0aW9uIFlzKGksZSx0KXtyZXR1cm4gaSE9PWU/KHQtaSkvKGUtaSk6MH1mdW5jdGlvbiBrbihpLGUsdCl7cmV0dXJuKDEtdCkqaSt0KmV9ZnVuY3Rpb24gJHMoaSxlLHQsbil7cmV0dXJuIGtuKGksZSwxLU1hdGguZXhwKC10Km4pKX1mdW5jdGlvbiBacyhpLGU9MSl7cmV0dXJuIGUtTWF0aC5hYnMoT2koaSxlKjIpLWUpfWZ1bmN0aW9uIEtzKGksZSx0KXtyZXR1cm4gaTw9ZT8wOmk+PXQ/MTooaT0oaS1lKS8odC1lKSxpKmkqKDMtMippKSl9ZnVuY3Rpb24ganMoaSxlLHQpe3JldHVybiBpPD1lPzA6aT49dD8xOihpPShpLWUpLyh0LWUpLGkqaSppKihpKihpKjYtMTUpKzEwKSl9ZnVuY3Rpb24gSnMoaSxlKXtyZXR1cm4gaStNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKGUtaSsxKSl9ZnVuY3Rpb24gUXMoaSxlKXtyZXR1cm4gaStNYXRoLnJhbmRvbSgpKihlLWkpfWZ1bmN0aW9uIGVhKGkpe3JldHVybiBpKiguNS1NYXRoLnJhbmRvbSgpKX1mdW5jdGlvbiB0YShpKXtpIT09dm9pZCAwJiYoTXI9aSk7bGV0IGU9TXIrPTE4MzE1NjU4MTM7cmV0dXJuIGU9TWF0aC5pbXVsKGVeZT4+PjE1LGV8MSksZV49ZStNYXRoLmltdWwoZV5lPj4+NyxlfDYxKSwoKGVeZT4+PjE0KT4+PjApLzQyOTQ5NjcyOTZ9ZnVuY3Rpb24gbmEoaSl7cmV0dXJuIGkqSG59ZnVuY3Rpb24gaWEoaSl7cmV0dXJuIGkqVm59ZnVuY3Rpb24gcmEoaSl7cmV0dXJuKGkmaS0xKT09PTAmJmkhPT0wfWZ1bmN0aW9uIHNhKGkpe3JldHVybiBNYXRoLnBvdygyLE1hdGguY2VpbChNYXRoLmxvZyhpKS9NYXRoLkxOMikpfWZ1bmN0aW9uIGFhKGkpe3JldHVybiBNYXRoLnBvdygyLE1hdGguZmxvb3IoTWF0aC5sb2coaSkvTWF0aC5MTjIpKX1mdW5jdGlvbiBvYShpLGUsdCxuLHIpe2NvbnN0IHM9TWF0aC5jb3MsYT1NYXRoLnNpbixvPXModC8yKSxsPWEodC8yKSxjPXMoKGUrbikvMiksdT1hKChlK24pLzIpLGg9cygoZS1uKS8yKSxmPWEoKGUtbikvMikscD1zKChuLWUpLzIpLF89YSgobi1lKS8yKTtzd2l0Y2gocil7Y2FzZSJYWVgiOmkuc2V0KG8qdSxsKmgsbCpmLG8qYyk7YnJlYWs7Y2FzZSJZWlkiOmkuc2V0KGwqZixvKnUsbCpoLG8qYyk7YnJlYWs7Y2FzZSJaWFoiOmkuc2V0KGwqaCxsKmYsbyp1LG8qYyk7YnJlYWs7Y2FzZSJYWlgiOmkuc2V0KG8qdSxsKl8sbCpwLG8qYyk7YnJlYWs7Y2FzZSJZWFkiOmkuc2V0KGwqcCxvKnUsbCpfLG8qYyk7YnJlYWs7Y2FzZSJaWVoiOmkuc2V0KGwqXyxsKnAsbyp1LG8qYyk7YnJlYWs7ZGVmYXVsdDpjb25zb2xlLndhcm4oIlRIUkVFLk1hdGhVdGlsczogLnNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAiK3IpfX1mdW5jdGlvbiBFbihpLGUpe3N3aXRjaChlLmNvbnN0cnVjdG9yKXtjYXNlIEZsb2F0MzJBcnJheTpyZXR1cm4gaTtjYXNlIFVpbnQzMkFycmF5OnJldHVybiBpLzQyOTQ5NjcyOTU7Y2FzZSBVaW50MTZBcnJheTpyZXR1cm4gaS82NTUzNTtjYXNlIFVpbnQ4QXJyYXk6cmV0dXJuIGkvMjU1O2Nhc2UgSW50MzJBcnJheTpyZXR1cm4gTWF0aC5tYXgoaS8yMTQ3NDgzNjQ3LC0xKTtjYXNlIEludDE2QXJyYXk6cmV0dXJuIE1hdGgubWF4KGkvMzI3NjcsLTEpO2Nhc2UgSW50OEFycmF5OnJldHVybiBNYXRoLm1heChpLzEyNywtMSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgY29tcG9uZW50IHR5cGUuIil9fWZ1bmN0aW9uIGd0KGksZSl7c3dpdGNoKGUuY29uc3RydWN0b3Ipe2Nhc2UgRmxvYXQzMkFycmF5OnJldHVybiBpO2Nhc2UgVWludDMyQXJyYXk6cmV0dXJuIE1hdGgucm91bmQoaSo0Mjk0OTY3Mjk1KTtjYXNlIFVpbnQxNkFycmF5OnJldHVybiBNYXRoLnJvdW5kKGkqNjU1MzUpO2Nhc2UgVWludDhBcnJheTpyZXR1cm4gTWF0aC5yb3VuZChpKjI1NSk7Y2FzZSBJbnQzMkFycmF5OnJldHVybiBNYXRoLnJvdW5kKGkqMjE0NzQ4MzY0Nyk7Y2FzZSBJbnQxNkFycmF5OnJldHVybiBNYXRoLnJvdW5kKGkqMzI3NjcpO2Nhc2UgSW50OEFycmF5OnJldHVybiBNYXRoLnJvdW5kKGkqMTI3KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiSW52YWxpZCBjb21wb25lbnQgdHlwZS4iKX19Y29uc3QgJGU9e0RFRzJSQUQ6SG4sUkFEMkRFRzpWbixnZW5lcmF0ZVVVSUQ6U24sY2xhbXA6X3QsZXVjbGlkZWFuTW9kdWxvOk9pLG1hcExpbmVhcjpxcyxpbnZlcnNlTGVycDpZcyxsZXJwOmtuLGRhbXA6JHMscGluZ3Bvbmc6WnMsc21vb3Roc3RlcDpLcyxzbW9vdGhlcnN0ZXA6anMscmFuZEludDpKcyxyYW5kRmxvYXQ6UXMscmFuZEZsb2F0U3ByZWFkOmVhLHNlZWRlZFJhbmRvbTp0YSxkZWdUb1JhZDpuYSxyYWRUb0RlZzppYSxpc1Bvd2VyT2ZUd286cmEsY2VpbFBvd2VyT2ZUd286c2EsZmxvb3JQb3dlck9mVHdvOmFhLHNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXI6b2Esbm9ybWFsaXplOmd0LGRlbm9ybWFsaXplOkVufTtjbGFzcyBMZXtjb25zdHJ1Y3RvcihlPTAsdD0wKXtMZS5wcm90b3R5cGUuaXNWZWN0b3IyPSEwLHRoaXMueD1lLHRoaXMueT10fWdldCB3aWR0aCgpe3JldHVybiB0aGlzLnh9c2V0IHdpZHRoKGUpe3RoaXMueD1lfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy55fXNldCBoZWlnaHQoZSl7dGhpcy55PWV9c2V0KGUsdCl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXN9c2V0U2NhbGFyKGUpe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9ZSx0aGlzfXNldFgoZSl7cmV0dXJuIHRoaXMueD1lLHRoaXN9c2V0WShlKXtyZXR1cm4gdGhpcy55PWUsdGhpc31zZXRDb21wb25lbnQoZSx0KXtzd2l0Y2goZSl7Y2FzZSAwOnRoaXMueD10O2JyZWFrO2Nhc2UgMTp0aGlzLnk9dDticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAiK2UpfXJldHVybiB0aGlzfWdldENvbXBvbmVudChlKXtzd2l0Y2goZSl7Y2FzZSAwOnJldHVybiB0aGlzLng7Y2FzZSAxOnJldHVybiB0aGlzLnk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoImluZGV4IGlzIG91dCBvZiByYW5nZTogIitlKX19Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54LHRoaXMueSl9Y29weShlKXtyZXR1cm4gdGhpcy54PWUueCx0aGlzLnk9ZS55LHRoaXN9YWRkKGUpe3JldHVybiB0aGlzLngrPWUueCx0aGlzLnkrPWUueSx0aGlzfWFkZFNjYWxhcihlKXtyZXR1cm4gdGhpcy54Kz1lLHRoaXMueSs9ZSx0aGlzfWFkZFZlY3RvcnMoZSx0KXtyZXR1cm4gdGhpcy54PWUueCt0LngsdGhpcy55PWUueSt0LnksdGhpc31hZGRTY2FsZWRWZWN0b3IoZSx0KXtyZXR1cm4gdGhpcy54Kz1lLngqdCx0aGlzLnkrPWUueSp0LHRoaXN9c3ViKGUpe3JldHVybiB0aGlzLngtPWUueCx0aGlzLnktPWUueSx0aGlzfXN1YlNjYWxhcihlKXtyZXR1cm4gdGhpcy54LT1lLHRoaXMueS09ZSx0aGlzfXN1YlZlY3RvcnMoZSx0KXtyZXR1cm4gdGhpcy54PWUueC10LngsdGhpcy55PWUueS10LnksdGhpc31tdWx0aXBseShlKXtyZXR1cm4gdGhpcy54Kj1lLngsdGhpcy55Kj1lLnksdGhpc31tdWx0aXBseVNjYWxhcihlKXtyZXR1cm4gdGhpcy54Kj1lLHRoaXMueSo9ZSx0aGlzfWRpdmlkZShlKXtyZXR1cm4gdGhpcy54Lz1lLngsdGhpcy55Lz1lLnksdGhpc31kaXZpZGVTY2FsYXIoZSl7cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMS9lKX1hcHBseU1hdHJpeDMoZSl7Y29uc3QgdD10aGlzLngsbj10aGlzLnkscj1lLmVsZW1lbnRzO3JldHVybiB0aGlzLng9clswXSp0K3JbM10qbityWzZdLHRoaXMueT1yWzFdKnQrcls0XSpuK3JbN10sdGhpc31taW4oZSl7cmV0dXJuIHRoaXMueD1NYXRoLm1pbih0aGlzLngsZS54KSx0aGlzLnk9TWF0aC5taW4odGhpcy55LGUueSksdGhpc31tYXgoZSl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0aGlzLngsZS54KSx0aGlzLnk9TWF0aC5tYXgodGhpcy55LGUueSksdGhpc31jbGFtcChlLHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgoZS54LE1hdGgubWluKHQueCx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgoZS55LE1hdGgubWluKHQueSx0aGlzLnkpKSx0aGlzfWNsYW1wU2NhbGFyKGUsdCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heChlLE1hdGgubWluKHQsdGhpcy54KSksdGhpcy55PU1hdGgubWF4KGUsTWF0aC5taW4odCx0aGlzLnkpKSx0aGlzfWNsYW1wTGVuZ3RoKGUsdCl7Y29uc3Qgbj10aGlzLmxlbmd0aCgpO3JldHVybiB0aGlzLmRpdmlkZVNjYWxhcihufHwxKS5tdWx0aXBseVNjYWxhcihNYXRoLm1heChlLE1hdGgubWluKHQsbikpKX1mbG9vcigpe3JldHVybiB0aGlzLng9TWF0aC5mbG9vcih0aGlzLngpLHRoaXMueT1NYXRoLmZsb29yKHRoaXMueSksdGhpc31jZWlsKCl7cmV0dXJuIHRoaXMueD1NYXRoLmNlaWwodGhpcy54KSx0aGlzLnk9TWF0aC5jZWlsKHRoaXMueSksdGhpc31yb3VuZCgpe3JldHVybiB0aGlzLng9TWF0aC5yb3VuZCh0aGlzLngpLHRoaXMueT1NYXRoLnJvdW5kKHRoaXMueSksdGhpc31yb3VuZFRvWmVybygpe3JldHVybiB0aGlzLng9TWF0aC50cnVuYyh0aGlzLngpLHRoaXMueT1NYXRoLnRydW5jKHRoaXMueSksdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy54PS10aGlzLngsdGhpcy55PS10aGlzLnksdGhpc31kb3QoZSl7cmV0dXJuIHRoaXMueCplLngrdGhpcy55KmUueX1jcm9zcyhlKXtyZXR1cm4gdGhpcy54KmUueS10aGlzLnkqZS54fWxlbmd0aFNxKCl7cmV0dXJuIHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueX1sZW5ndGgoKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSl9bWFuaGF0dGFuTGVuZ3RoKCl7cmV0dXJuIE1hdGguYWJzKHRoaXMueCkrTWF0aC5hYnModGhpcy55KX1ub3JtYWxpemUoKXtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKXx8MSl9YW5nbGUoKXtyZXR1cm4gTWF0aC5hdGFuMigtdGhpcy55LC10aGlzLngpK01hdGguUEl9YW5nbGVUbyhlKXtjb25zdCB0PU1hdGguc3FydCh0aGlzLmxlbmd0aFNxKCkqZS5sZW5ndGhTcSgpKTtpZih0PT09MClyZXR1cm4gTWF0aC5QSS8yO2NvbnN0IG49dGhpcy5kb3QoZSkvdDtyZXR1cm4gTWF0aC5hY29zKF90KG4sLTEsMSkpfWRpc3RhbmNlVG8oZSl7cmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKGUpKX1kaXN0YW5jZVRvU3F1YXJlZChlKXtjb25zdCB0PXRoaXMueC1lLngsbj10aGlzLnktZS55O3JldHVybiB0KnQrbipufW1hbmhhdHRhbkRpc3RhbmNlVG8oZSl7cmV0dXJuIE1hdGguYWJzKHRoaXMueC1lLngpK01hdGguYWJzKHRoaXMueS1lLnkpfXNldExlbmd0aChlKXtyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihlKX1sZXJwKGUsdCl7cmV0dXJuIHRoaXMueCs9KGUueC10aGlzLngpKnQsdGhpcy55Kz0oZS55LXRoaXMueSkqdCx0aGlzfWxlcnBWZWN0b3JzKGUsdCxuKXtyZXR1cm4gdGhpcy54PWUueCsodC54LWUueCkqbix0aGlzLnk9ZS55Kyh0LnktZS55KSpuLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLng9PT10aGlzLngmJmUueT09PXRoaXMueX1mcm9tQXJyYXkoZSx0PTApe3JldHVybiB0aGlzLng9ZVt0XSx0aGlzLnk9ZVt0KzFdLHRoaXN9dG9BcnJheShlPVtdLHQ9MCl7cmV0dXJuIGVbdF09dGhpcy54LGVbdCsxXT10aGlzLnksZX1mcm9tQnVmZmVyQXR0cmlidXRlKGUsdCl7cmV0dXJuIHRoaXMueD1lLmdldFgodCksdGhpcy55PWUuZ2V0WSh0KSx0aGlzfXJvdGF0ZUFyb3VuZChlLHQpe2NvbnN0IG49TWF0aC5jb3ModCkscj1NYXRoLnNpbih0KSxzPXRoaXMueC1lLngsYT10aGlzLnktZS55O3JldHVybiB0aGlzLng9cypuLWEqcitlLngsdGhpcy55PXMqcithKm4rZS55LHRoaXN9cmFuZG9tKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJhbmRvbSgpLHRoaXMueT1NYXRoLnJhbmRvbSgpLHRoaXN9KltTeW1ib2wuaXRlcmF0b3JdKCl7eWllbGQgdGhpcy54LHlpZWxkIHRoaXMueX19Y2xhc3Mgd2V7Y29uc3RydWN0b3IoZSx0LG4scixzLGEsbyxsLGMpe3dlLnByb3RvdHlwZS5pc01hdHJpeDM9ITAsdGhpcy5lbGVtZW50cz1bMSwwLDAsMCwxLDAsMCwwLDFdLGUhPT12b2lkIDAmJnRoaXMuc2V0KGUsdCxuLHIscyxhLG8sbCxjKX1zZXQoZSx0LG4scixzLGEsbyxsLGMpe2NvbnN0IHU9dGhpcy5lbGVtZW50cztyZXR1cm4gdVswXT1lLHVbMV09cix1WzJdPW8sdVszXT10LHVbNF09cyx1WzVdPWwsdVs2XT1uLHVbN109YSx1WzhdPWMsdGhpc31pZGVudGl0eSgpe3JldHVybiB0aGlzLnNldCgxLDAsMCwwLDEsMCwwLDAsMSksdGhpc31jb3B5KGUpe2NvbnN0IHQ9dGhpcy5lbGVtZW50cyxuPWUuZWxlbWVudHM7cmV0dXJuIHRbMF09blswXSx0WzFdPW5bMV0sdFsyXT1uWzJdLHRbM109blszXSx0WzRdPW5bNF0sdFs1XT1uWzVdLHRbNl09bls2XSx0WzddPW5bN10sdFs4XT1uWzhdLHRoaXN9ZXh0cmFjdEJhc2lzKGUsdCxuKXtyZXR1cm4gZS5zZXRGcm9tTWF0cml4M0NvbHVtbih0aGlzLDApLHQuc2V0RnJvbU1hdHJpeDNDb2x1bW4odGhpcywxKSxuLnNldEZyb21NYXRyaXgzQ29sdW1uKHRoaXMsMiksdGhpc31zZXRGcm9tTWF0cml4NChlKXtjb25zdCB0PWUuZWxlbWVudHM7cmV0dXJuIHRoaXMuc2V0KHRbMF0sdFs0XSx0WzhdLHRbMV0sdFs1XSx0WzldLHRbMl0sdFs2XSx0WzEwXSksdGhpc31tdWx0aXBseShlKXtyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHRoaXMsZSl9cHJlbXVsdGlwbHkoZSl7cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyhlLHRoaXMpfW11bHRpcGx5TWF0cmljZXMoZSx0KXtjb25zdCBuPWUuZWxlbWVudHMscj10LmVsZW1lbnRzLHM9dGhpcy5lbGVtZW50cyxhPW5bMF0sbz1uWzNdLGw9bls2XSxjPW5bMV0sdT1uWzRdLGg9bls3XSxmPW5bMl0scD1uWzVdLF89bls4XSx4PXJbMF0sbT1yWzNdLGQ9cls2XSxBPXJbMV0sVD1yWzRdLE09cls3XSxGPXJbMl0sYj1yWzVdLHc9cls4XTtyZXR1cm4gc1swXT1hKngrbypBK2wqRixzWzNdPWEqbStvKlQrbCpiLHNbNl09YSpkK28qTStsKncsc1sxXT1jKngrdSpBK2gqRixzWzRdPWMqbSt1KlQraCpiLHNbN109YypkK3UqTStoKncsc1syXT1mKngrcCpBK18qRixzWzVdPWYqbStwKlQrXypiLHNbOF09ZipkK3AqTStfKncsdGhpc31tdWx0aXBseVNjYWxhcihlKXtjb25zdCB0PXRoaXMuZWxlbWVudHM7cmV0dXJuIHRbMF0qPWUsdFszXSo9ZSx0WzZdKj1lLHRbMV0qPWUsdFs0XSo9ZSx0WzddKj1lLHRbMl0qPWUsdFs1XSo9ZSx0WzhdKj1lLHRoaXN9ZGV0ZXJtaW5hbnQoKXtjb25zdCBlPXRoaXMuZWxlbWVudHMsdD1lWzBdLG49ZVsxXSxyPWVbMl0scz1lWzNdLGE9ZVs0XSxvPWVbNV0sbD1lWzZdLGM9ZVs3XSx1PWVbOF07cmV0dXJuIHQqYSp1LXQqbypjLW4qcyp1K24qbypsK3IqcypjLXIqYSpsfWludmVydCgpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyx0PWVbMF0sbj1lWzFdLHI9ZVsyXSxzPWVbM10sYT1lWzRdLG89ZVs1XSxsPWVbNl0sYz1lWzddLHU9ZVs4XSxoPXUqYS1vKmMsZj1vKmwtdSpzLHA9YypzLWEqbCxfPXQqaCtuKmYrcipwO2lmKF89PT0wKXJldHVybiB0aGlzLnNldCgwLDAsMCwwLDAsMCwwLDAsMCk7Y29uc3QgeD0xL187cmV0dXJuIGVbMF09aCp4LGVbMV09KHIqYy11Km4pKngsZVsyXT0obypuLXIqYSkqeCxlWzNdPWYqeCxlWzRdPSh1KnQtcipsKSp4LGVbNV09KHIqcy1vKnQpKngsZVs2XT1wKngsZVs3XT0obipsLWMqdCkqeCxlWzhdPShhKnQtbipzKSp4LHRoaXN9dHJhbnNwb3NlKCl7bGV0IGU7Y29uc3QgdD10aGlzLmVsZW1lbnRzO3JldHVybiBlPXRbMV0sdFsxXT10WzNdLHRbM109ZSxlPXRbMl0sdFsyXT10WzZdLHRbNl09ZSxlPXRbNV0sdFs1XT10WzddLHRbN109ZSx0aGlzfWdldE5vcm1hbE1hdHJpeChlKXtyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4NChlKS5pbnZlcnQoKS50cmFuc3Bvc2UoKX10cmFuc3Bvc2VJbnRvQXJyYXkoZSl7Y29uc3QgdD10aGlzLmVsZW1lbnRzO3JldHVybiBlWzBdPXRbMF0sZVsxXT10WzNdLGVbMl09dFs2XSxlWzNdPXRbMV0sZVs0XT10WzRdLGVbNV09dFs3XSxlWzZdPXRbMl0sZVs3XT10WzVdLGVbOF09dFs4XSx0aGlzfXNldFV2VHJhbnNmb3JtKGUsdCxuLHIscyxhLG8pe2NvbnN0IGw9TWF0aC5jb3MocyksYz1NYXRoLnNpbihzKTtyZXR1cm4gdGhpcy5zZXQobipsLG4qYywtbioobCphK2MqbykrYStlLC1yKmMscipsLC1yKigtYyphK2wqbykrbyt0LDAsMCwxKSx0aGlzfXNjYWxlKGUsdCl7cmV0dXJuIHRoaXMucHJlbXVsdGlwbHkoQmkubWFrZVNjYWxlKGUsdCkpLHRoaXN9cm90YXRlKGUpe3JldHVybiB0aGlzLnByZW11bHRpcGx5KEJpLm1ha2VSb3RhdGlvbigtZSkpLHRoaXN9dHJhbnNsYXRlKGUsdCl7cmV0dXJuIHRoaXMucHJlbXVsdGlwbHkoQmkubWFrZVRyYW5zbGF0aW9uKGUsdCkpLHRoaXN9bWFrZVRyYW5zbGF0aW9uKGUsdCl7cmV0dXJuIGUuaXNWZWN0b3IyP3RoaXMuc2V0KDEsMCxlLngsMCwxLGUueSwwLDAsMSk6dGhpcy5zZXQoMSwwLGUsMCwxLHQsMCwwLDEpLHRoaXN9bWFrZVJvdGF0aW9uKGUpe2NvbnN0IHQ9TWF0aC5jb3MoZSksbj1NYXRoLnNpbihlKTtyZXR1cm4gdGhpcy5zZXQodCwtbiwwLG4sdCwwLDAsMCwxKSx0aGlzfW1ha2VTY2FsZShlLHQpe3JldHVybiB0aGlzLnNldChlLDAsMCwwLHQsMCwwLDAsMSksdGhpc31lcXVhbHMoZSl7Y29uc3QgdD10aGlzLmVsZW1lbnRzLG49ZS5lbGVtZW50cztmb3IobGV0IHI9MDtyPDk7cisrKWlmKHRbcl0hPT1uW3JdKXJldHVybiExO3JldHVybiEwfWZyb21BcnJheShlLHQ9MCl7Zm9yKGxldCBuPTA7bjw5O24rKyl0aGlzLmVsZW1lbnRzW25dPWVbbit0XTtyZXR1cm4gdGhpc310b0FycmF5KGU9W10sdD0wKXtjb25zdCBuPXRoaXMuZWxlbWVudHM7cmV0dXJuIGVbdF09blswXSxlW3QrMV09blsxXSxlW3QrMl09blsyXSxlW3QrM109blszXSxlW3QrNF09bls0XSxlW3QrNV09bls1XSxlW3QrNl09bls2XSxlW3QrN109bls3XSxlW3QrOF09bls4XSxlfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KHRoaXMuZWxlbWVudHMpfX1jb25zdCBCaT1uZXcgd2U7ZnVuY3Rpb24gU3IoaSl7Zm9yKGxldCBlPWkubGVuZ3RoLTE7ZT49MDstLWUpaWYoaVtlXT49NjU1MzUpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gcmkoaSl7cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIsaSl9ZnVuY3Rpb24gbGEoKXtjb25zdCBpPXJpKCJjYW52YXMiKTtyZXR1cm4gaS5zdHlsZS5kaXNwbGF5PSJibG9jayIsaX1jb25zdCBFcj17fTtmdW5jdGlvbiBXbihpKXtpIGluIEVyfHwoRXJbaV09ITAsY29uc29sZS53YXJuKGkpKX1mdW5jdGlvbiBjYShpLGUsdCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4scil7ZnVuY3Rpb24gcygpe3N3aXRjaChpLmNsaWVudFdhaXRTeW5jKGUsaS5TWU5DX0ZMVVNIX0NPTU1BTkRTX0JJVCwwKSl7Y2FzZSBpLldBSVRfRkFJTEVEOnIoKTticmVhaztjYXNlIGkuVElNRU9VVF9FWFBJUkVEOnNldFRpbWVvdXQocyx0KTticmVhaztkZWZhdWx0Om4oKX19c2V0VGltZW91dChzLHQpfSl9ZnVuY3Rpb24gdWEoaSl7Y29uc3QgZT1pLmVsZW1lbnRzO2VbMl09LjUqZVsyXSsuNSplWzNdLGVbNl09LjUqZVs2XSsuNSplWzddLGVbMTBdPS41KmVbMTBdKy41KmVbMTFdLGVbMTRdPS41KmVbMTRdKy41KmVbMTVdfWZ1bmN0aW9uIGhhKGkpe2NvbnN0IGU9aS5lbGVtZW50cztlWzExXT09PS0xPyhlWzEwXT0tZVsxMF0tMSxlWzE0XT0tZVsxNF0pOihlWzEwXT0tZVsxMF0sZVsxNF09LWVbMTRdKzEpfWNvbnN0IEJlPXtlbmFibGVkOiEwLHdvcmtpbmdDb2xvclNwYWNlOnhuLHNwYWNlczp7fSxjb252ZXJ0OmZ1bmN0aW9uKGksZSx0KXtyZXR1cm4gdGhpcy5lbmFibGVkPT09ITF8fGU9PT10fHwhZXx8IXR8fCh0aGlzLnNwYWNlc1tlXS50cmFuc2Zlcj09PXFlJiYoaS5yPVZ0KGkuciksaS5nPVZ0KGkuZyksaS5iPVZ0KGkuYikpLHRoaXMuc3BhY2VzW2VdLnByaW1hcmllcyE9PXRoaXMuc3BhY2VzW3RdLnByaW1hcmllcyYmKGkuYXBwbHlNYXRyaXgzKHRoaXMuc3BhY2VzW2VdLnRvWFlaKSxpLmFwcGx5TWF0cml4Myh0aGlzLnNwYWNlc1t0XS5mcm9tWFlaKSksdGhpcy5zcGFjZXNbdF0udHJhbnNmZXI9PT1xZSYmKGkucj15bihpLnIpLGkuZz15bihpLmcpLGkuYj15bihpLmIpKSksaX0sZnJvbVdvcmtpbmdDb2xvclNwYWNlOmZ1bmN0aW9uKGksZSl7cmV0dXJuIHRoaXMuY29udmVydChpLHRoaXMud29ya2luZ0NvbG9yU3BhY2UsZSl9LHRvV29ya2luZ0NvbG9yU3BhY2U6ZnVuY3Rpb24oaSxlKXtyZXR1cm4gdGhpcy5jb252ZXJ0KGksZSx0aGlzLndvcmtpbmdDb2xvclNwYWNlKX0sZ2V0UHJpbWFyaWVzOmZ1bmN0aW9uKGkpe3JldHVybiB0aGlzLnNwYWNlc1tpXS5wcmltYXJpZXN9LGdldFRyYW5zZmVyOmZ1bmN0aW9uKGkpe3JldHVybiBpPT09anQ/aWk6dGhpcy5zcGFjZXNbaV0udHJhbnNmZXJ9LGdldEx1bWluYW5jZUNvZWZmaWNpZW50czpmdW5jdGlvbihpLGU9dGhpcy53b3JraW5nQ29sb3JTcGFjZSl7cmV0dXJuIGkuZnJvbUFycmF5KHRoaXMuc3BhY2VzW2VdLmx1bWluYW5jZUNvZWZmaWNpZW50cyl9LGRlZmluZTpmdW5jdGlvbihpKXtPYmplY3QuYXNzaWduKHRoaXMuc3BhY2VzLGkpfSxfZ2V0TWF0cml4OmZ1bmN0aW9uKGksZSx0KXtyZXR1cm4gaS5jb3B5KHRoaXMuc3BhY2VzW2VdLnRvWFlaKS5tdWx0aXBseSh0aGlzLnNwYWNlc1t0XS5mcm9tWFlaKX0sX2dldERyYXdpbmdCdWZmZXJDb2xvclNwYWNlOmZ1bmN0aW9uKGkpe3JldHVybiB0aGlzLnNwYWNlc1tpXS5vdXRwdXRDb2xvclNwYWNlQ29uZmlnLmRyYXdpbmdCdWZmZXJDb2xvclNwYWNlfSxfZ2V0VW5wYWNrQ29sb3JTcGFjZTpmdW5jdGlvbihpPXRoaXMud29ya2luZ0NvbG9yU3BhY2Upe3JldHVybiB0aGlzLnNwYWNlc1tpXS53b3JraW5nQ29sb3JTcGFjZUNvbmZpZy51bnBhY2tDb2xvclNwYWNlfX07ZnVuY3Rpb24gVnQoaSl7cmV0dXJuIGk8LjA0MDQ1P2kqLjA3NzM5OTM4MDg6TWF0aC5wb3coaSouOTQ3ODY3Mjk4NisuMDUyMTMyNzAxNCwyLjQpfWZ1bmN0aW9uIHluKGkpe3JldHVybiBpPC4wMDMxMzA4P2kqMTIuOTI6MS4wNTUqTWF0aC5wb3coaSwuNDE2NjYpLS4wNTV9Y29uc3QgeXI9Wy42NCwuMzMsLjMsLjYsLjE1LC4wNl0sVHI9Wy4yMTI2LC43MTUyLC4wNzIyXSxBcj1bLjMxMjcsLjMyOV0sYnI9bmV3IHdlKCkuc2V0KC40MTIzOTA4LC4zNTc1ODQzLC4xODA0ODA4LC4yMTI2MzksLjcxNTE2ODcsLjA3MjE5MjMsLjAxOTMzMDgsLjExOTE5NDgsLjk1MDUzMjIpLHdyPW5ldyB3ZSgpLnNldCgzLjI0MDk2OTksLTEuNTM3MzgzMiwtLjQ5ODYxMDgsLS45NjkyNDM2LDEuODc1OTY3NSwuMDQxNTU1MSwuMDU1NjMwMSwtLjIwMzk3NywxLjA1Njk3MTUpO0JlLmRlZmluZSh7W3huXTp7cHJpbWFyaWVzOnlyLHdoaXRlUG9pbnQ6QXIsdHJhbnNmZXI6aWksdG9YWVo6YnIsZnJvbVhZWjp3cixsdW1pbmFuY2VDb2VmZmljaWVudHM6VHIsd29ya2luZ0NvbG9yU3BhY2VDb25maWc6e3VucGFja0NvbG9yU3BhY2U6d3R9LG91dHB1dENvbG9yU3BhY2VDb25maWc6e2RyYXdpbmdCdWZmZXJDb2xvclNwYWNlOnd0fX0sW3d0XTp7cHJpbWFyaWVzOnlyLHdoaXRlUG9pbnQ6QXIsdHJhbnNmZXI6cWUsdG9YWVo6YnIsZnJvbVhZWjp3cixsdW1pbmFuY2VDb2VmZmljaWVudHM6VHIsb3V0cHV0Q29sb3JTcGFjZUNvbmZpZzp7ZHJhd2luZ0J1ZmZlckNvbG9yU3BhY2U6d3R9fX0pO2xldCBUbjtjbGFzcyBkYXtzdGF0aWMgZ2V0RGF0YVVSTChlKXtpZigvXmRhdGE6L2kudGVzdChlLnNyYyl8fHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudD4idSIpcmV0dXJuIGUuc3JjO2xldCB0O2lmKGUgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCl0PWU7ZWxzZXtUbj09PXZvaWQgMCYmKFRuPXJpKCJjYW52YXMiKSksVG4ud2lkdGg9ZS53aWR0aCxUbi5oZWlnaHQ9ZS5oZWlnaHQ7Y29uc3Qgbj1Ubi5nZXRDb250ZXh0KCIyZCIpO2UgaW5zdGFuY2VvZiBJbWFnZURhdGE/bi5wdXRJbWFnZURhdGEoZSwwLDApOm4uZHJhd0ltYWdlKGUsMCwwLGUud2lkdGgsZS5oZWlnaHQpLHQ9VG59cmV0dXJuIHQud2lkdGg+MjA0OHx8dC5oZWlnaHQ+MjA0OD8oY29uc29sZS53YXJuKCJUSFJFRS5JbWFnZVV0aWxzLmdldERhdGFVUkw6IEltYWdlIGNvbnZlcnRlZCB0byBqcGcgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMiLGUpLHQudG9EYXRhVVJMKCJpbWFnZS9qcGVnIiwuNikpOnQudG9EYXRhVVJMKCJpbWFnZS9wbmciKX1zdGF0aWMgc1JHQlRvTGluZWFyKGUpe2lmKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50PCJ1IiYmZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnR8fHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudDwidSImJmUgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudHx8dHlwZW9mIEltYWdlQml0bWFwPCJ1IiYmZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKXtjb25zdCB0PXJpKCJjYW52YXMiKTt0LndpZHRoPWUud2lkdGgsdC5oZWlnaHQ9ZS5oZWlnaHQ7Y29uc3Qgbj10LmdldENvbnRleHQoIjJkIik7bi5kcmF3SW1hZ2UoZSwwLDAsZS53aWR0aCxlLmhlaWdodCk7Y29uc3Qgcj1uLmdldEltYWdlRGF0YSgwLDAsZS53aWR0aCxlLmhlaWdodCkscz1yLmRhdGE7Zm9yKGxldCBhPTA7YTxzLmxlbmd0aDthKyspc1thXT1WdChzW2FdLzI1NSkqMjU1O3JldHVybiBuLnB1dEltYWdlRGF0YShyLDAsMCksdH1lbHNlIGlmKGUuZGF0YSl7Y29uc3QgdD1lLmRhdGEuc2xpY2UoMCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheT90W25dPU1hdGguZmxvb3IoVnQodFtuXS8yNTUpKjI1NSk6dFtuXT1WdCh0W25dKTtyZXR1cm57ZGF0YTp0LHdpZHRoOmUud2lkdGgsaGVpZ2h0OmUuaGVpZ2h0fX1lbHNlIHJldHVybiBjb25zb2xlLndhcm4oIlRIUkVFLkltYWdlVXRpbHMuc1JHQlRvTGluZWFyKCk6IFVuc3VwcG9ydGVkIGltYWdlIHR5cGUuIE5vIGNvbG9yIHNwYWNlIGNvbnZlcnNpb24gYXBwbGllZC4iKSxlfX1sZXQgZmE9MDtjbGFzcyBScntjb25zdHJ1Y3RvcihlPW51bGwpe3RoaXMuaXNTb3VyY2U9ITAsT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImlkIix7dmFsdWU6ZmErK30pLHRoaXMudXVpZD1TbigpLHRoaXMuZGF0YT1lLHRoaXMuZGF0YVJlYWR5PSEwLHRoaXMudmVyc2lvbj0wfXNldCBuZWVkc1VwZGF0ZShlKXtlPT09ITAmJnRoaXMudmVyc2lvbisrfXRvSlNPTihlKXtjb25zdCB0PWU9PT12b2lkIDB8fHR5cGVvZiBlPT0ic3RyaW5nIjtpZighdCYmZS5pbWFnZXNbdGhpcy51dWlkXSE9PXZvaWQgMClyZXR1cm4gZS5pbWFnZXNbdGhpcy51dWlkXTtjb25zdCBuPXt1dWlkOnRoaXMudXVpZCx1cmw6IiJ9LHI9dGhpcy5kYXRhO2lmKHIhPT1udWxsKXtsZXQgcztpZihBcnJheS5pc0FycmF5KHIpKXtzPVtdO2ZvcihsZXQgYT0wLG89ci5sZW5ndGg7YTxvO2ErKylyW2FdLmlzRGF0YVRleHR1cmU/cy5wdXNoKHppKHJbYV0uaW1hZ2UpKTpzLnB1c2goemkoclthXSkpfWVsc2Ugcz16aShyKTtuLnVybD1zfXJldHVybiB0fHwoZS5pbWFnZXNbdGhpcy51dWlkXT1uKSxufX1mdW5jdGlvbiB6aShpKXtyZXR1cm4gdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQ8InUiJiZpIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudHx8dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50PCJ1IiYmaSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50fHx0eXBlb2YgSW1hZ2VCaXRtYXA8InUiJiZpIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXA/ZGEuZ2V0RGF0YVVSTChpKTppLmRhdGE/e2RhdGE6QXJyYXkuZnJvbShpLmRhdGEpLHdpZHRoOmkud2lkdGgsaGVpZ2h0OmkuaGVpZ2h0LHR5cGU6aS5kYXRhLmNvbnN0cnVjdG9yLm5hbWV9Oihjb25zb2xlLndhcm4oIlRIUkVFLlRleHR1cmU6IFVuYWJsZSB0byBzZXJpYWxpemUgVGV4dHVyZS4iKSx7fSl9bGV0IHBhPTA7Y2xhc3MgdnQgZXh0ZW5kcyBNbntjb25zdHJ1Y3RvcihlPXZ0LkRFRkFVTFRfSU1BR0UsdD12dC5ERUZBVUxUX01BUFBJTkcsbj0xMDAxLHI9MTAwMSxzPTEwMDYsYT0xMDA4LG89MTAyMyxsPTEwMDksYz12dC5ERUZBVUxUX0FOSVNPVFJPUFksdT1qdCl7c3VwZXIoKSx0aGlzLmlzVGV4dHVyZT0hMCxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiaWQiLHt2YWx1ZTpwYSsrfSksdGhpcy51dWlkPVNuKCksdGhpcy5uYW1lPSIiLHRoaXMuc291cmNlPW5ldyBScihlKSx0aGlzLm1pcG1hcHM9W10sdGhpcy5tYXBwaW5nPXQsdGhpcy5jaGFubmVsPTAsdGhpcy53cmFwUz1uLHRoaXMud3JhcFQ9cix0aGlzLm1hZ0ZpbHRlcj1zLHRoaXMubWluRmlsdGVyPWEsdGhpcy5hbmlzb3Ryb3B5PWMsdGhpcy5mb3JtYXQ9byx0aGlzLmludGVybmFsRm9ybWF0PW51bGwsdGhpcy50eXBlPWwsdGhpcy5vZmZzZXQ9bmV3IExlKDAsMCksdGhpcy5yZXBlYXQ9bmV3IExlKDEsMSksdGhpcy5jZW50ZXI9bmV3IExlKDAsMCksdGhpcy5yb3RhdGlvbj0wLHRoaXMubWF0cml4QXV0b1VwZGF0ZT0hMCx0aGlzLm1hdHJpeD1uZXcgd2UsdGhpcy5nZW5lcmF0ZU1pcG1hcHM9ITAsdGhpcy5wcmVtdWx0aXBseUFscGhhPSExLHRoaXMuZmxpcFk9ITAsdGhpcy51bnBhY2tBbGlnbm1lbnQ9NCx0aGlzLmNvbG9yU3BhY2U9dSx0aGlzLnVzZXJEYXRhPXt9LHRoaXMudmVyc2lvbj0wLHRoaXMub25VcGRhdGU9bnVsbCx0aGlzLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hMSx0aGlzLnBtcmVtVmVyc2lvbj0wfWdldCBpbWFnZSgpe3JldHVybiB0aGlzLnNvdXJjZS5kYXRhfXNldCBpbWFnZShlPW51bGwpe3RoaXMuc291cmNlLmRhdGE9ZX11cGRhdGVNYXRyaXgoKXt0aGlzLm1hdHJpeC5zZXRVdlRyYW5zZm9ybSh0aGlzLm9mZnNldC54LHRoaXMub2Zmc2V0LnksdGhpcy5yZXBlYXQueCx0aGlzLnJlcGVhdC55LHRoaXMucm90YXRpb24sdGhpcy5jZW50ZXIueCx0aGlzLmNlbnRlci55KX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9Y29weShlKXtyZXR1cm4gdGhpcy5uYW1lPWUubmFtZSx0aGlzLnNvdXJjZT1lLnNvdXJjZSx0aGlzLm1pcG1hcHM9ZS5taXBtYXBzLnNsaWNlKDApLHRoaXMubWFwcGluZz1lLm1hcHBpbmcsdGhpcy5jaGFubmVsPWUuY2hhbm5lbCx0aGlzLndyYXBTPWUud3JhcFMsdGhpcy53cmFwVD1lLndyYXBULHRoaXMubWFnRmlsdGVyPWUubWFnRmlsdGVyLHRoaXMubWluRmlsdGVyPWUubWluRmlsdGVyLHRoaXMuYW5pc290cm9weT1lLmFuaXNvdHJvcHksdGhpcy5mb3JtYXQ9ZS5mb3JtYXQsdGhpcy5pbnRlcm5hbEZvcm1hdD1lLmludGVybmFsRm9ybWF0LHRoaXMudHlwZT1lLnR5cGUsdGhpcy5vZmZzZXQuY29weShlLm9mZnNldCksdGhpcy5yZXBlYXQuY29weShlLnJlcGVhdCksdGhpcy5jZW50ZXIuY29weShlLmNlbnRlciksdGhpcy5yb3RhdGlvbj1lLnJvdGF0aW9uLHRoaXMubWF0cml4QXV0b1VwZGF0ZT1lLm1hdHJpeEF1dG9VcGRhdGUsdGhpcy5tYXRyaXguY29weShlLm1hdHJpeCksdGhpcy5nZW5lcmF0ZU1pcG1hcHM9ZS5nZW5lcmF0ZU1pcG1hcHMsdGhpcy5wcmVtdWx0aXBseUFscGhhPWUucHJlbXVsdGlwbHlBbHBoYSx0aGlzLmZsaXBZPWUuZmxpcFksdGhpcy51bnBhY2tBbGlnbm1lbnQ9ZS51bnBhY2tBbGlnbm1lbnQsdGhpcy5jb2xvclNwYWNlPWUuY29sb3JTcGFjZSx0aGlzLnVzZXJEYXRhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZS51c2VyRGF0YSkpLHRoaXMubmVlZHNVcGRhdGU9ITAsdGhpc310b0pTT04oZSl7Y29uc3QgdD1lPT09dm9pZCAwfHx0eXBlb2YgZT09InN0cmluZyI7aWYoIXQmJmUudGV4dHVyZXNbdGhpcy51dWlkXSE9PXZvaWQgMClyZXR1cm4gZS50ZXh0dXJlc1t0aGlzLnV1aWRdO2NvbnN0IG49e21ldGFkYXRhOnt2ZXJzaW9uOjQuNix0eXBlOiJUZXh0dXJlIixnZW5lcmF0b3I6IlRleHR1cmUudG9KU09OIn0sdXVpZDp0aGlzLnV1aWQsbmFtZTp0aGlzLm5hbWUsaW1hZ2U6dGhpcy5zb3VyY2UudG9KU09OKGUpLnV1aWQsbWFwcGluZzp0aGlzLm1hcHBpbmcsY2hhbm5lbDp0aGlzLmNoYW5uZWwscmVwZWF0Olt0aGlzLnJlcGVhdC54LHRoaXMucmVwZWF0LnldLG9mZnNldDpbdGhpcy5vZmZzZXQueCx0aGlzLm9mZnNldC55XSxjZW50ZXI6W3RoaXMuY2VudGVyLngsdGhpcy5jZW50ZXIueV0scm90YXRpb246dGhpcy5yb3RhdGlvbix3cmFwOlt0aGlzLndyYXBTLHRoaXMud3JhcFRdLGZvcm1hdDp0aGlzLmZvcm1hdCxpbnRlcm5hbEZvcm1hdDp0aGlzLmludGVybmFsRm9ybWF0LHR5cGU6dGhpcy50eXBlLGNvbG9yU3BhY2U6dGhpcy5jb2xvclNwYWNlLG1pbkZpbHRlcjp0aGlzLm1pbkZpbHRlcixtYWdGaWx0ZXI6dGhpcy5tYWdGaWx0ZXIsYW5pc290cm9weTp0aGlzLmFuaXNvdHJvcHksZmxpcFk6dGhpcy5mbGlwWSxnZW5lcmF0ZU1pcG1hcHM6dGhpcy5nZW5lcmF0ZU1pcG1hcHMscHJlbXVsdGlwbHlBbHBoYTp0aGlzLnByZW11bHRpcGx5QWxwaGEsdW5wYWNrQWxpZ25tZW50OnRoaXMudW5wYWNrQWxpZ25tZW50fTtyZXR1cm4gT2JqZWN0LmtleXModGhpcy51c2VyRGF0YSkubGVuZ3RoPjAmJihuLnVzZXJEYXRhPXRoaXMudXNlckRhdGEpLHR8fChlLnRleHR1cmVzW3RoaXMudXVpZF09biksbn1kaXNwb3NlKCl7dGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJkaXNwb3NlIn0pfXRyYW5zZm9ybVV2KGUpe2lmKHRoaXMubWFwcGluZyE9PTMwMClyZXR1cm4gZTtpZihlLmFwcGx5TWF0cml4Myh0aGlzLm1hdHJpeCksZS54PDB8fGUueD4xKXN3aXRjaCh0aGlzLndyYXBTKXtjYXNlIDFlMzplLng9ZS54LU1hdGguZmxvb3IoZS54KTticmVhaztjYXNlIDEwMDE6ZS54PWUueDwwPzA6MTticmVhaztjYXNlIDEwMDI6TWF0aC5hYnMoTWF0aC5mbG9vcihlLngpJTIpPT09MT9lLng9TWF0aC5jZWlsKGUueCktZS54OmUueD1lLngtTWF0aC5mbG9vcihlLngpO2JyZWFrfWlmKGUueTwwfHxlLnk+MSlzd2l0Y2godGhpcy53cmFwVCl7Y2FzZSAxZTM6ZS55PWUueS1NYXRoLmZsb29yKGUueSk7YnJlYWs7Y2FzZSAxMDAxOmUueT1lLnk8MD8wOjE7YnJlYWs7Y2FzZSAxMDAyOk1hdGguYWJzKE1hdGguZmxvb3IoZS55KSUyKT09PTE/ZS55PU1hdGguY2VpbChlLnkpLWUueTplLnk9ZS55LU1hdGguZmxvb3IoZS55KTticmVha31yZXR1cm4gdGhpcy5mbGlwWSYmKGUueT0xLWUueSksZX1zZXQgbmVlZHNVcGRhdGUoZSl7ZT09PSEwJiYodGhpcy52ZXJzaW9uKyssdGhpcy5zb3VyY2UubmVlZHNVcGRhdGU9ITApfXNldCBuZWVkc1BNUkVNVXBkYXRlKGUpe2U9PT0hMCYmdGhpcy5wbXJlbVZlcnNpb24rK319dnQuREVGQVVMVF9JTUFHRT1udWxsLHZ0LkRFRkFVTFRfTUFQUElORz0zMDAsdnQuREVGQVVMVF9BTklTT1RST1BZPTE7Y2xhc3MgaXR7Y29uc3RydWN0b3IoZT0wLHQ9MCxuPTAscj0xKXtpdC5wcm90b3R5cGUuaXNWZWN0b3I0PSEwLHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1uLHRoaXMudz1yfWdldCB3aWR0aCgpe3JldHVybiB0aGlzLnp9c2V0IHdpZHRoKGUpe3RoaXMuej1lfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy53fXNldCBoZWlnaHQoZSl7dGhpcy53PWV9c2V0KGUsdCxuLHIpe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzLno9bix0aGlzLnc9cix0aGlzfXNldFNjYWxhcihlKXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PWUsdGhpcy56PWUsdGhpcy53PWUsdGhpc31zZXRYKGUpe3JldHVybiB0aGlzLng9ZSx0aGlzfXNldFkoZSl7cmV0dXJuIHRoaXMueT1lLHRoaXN9c2V0WihlKXtyZXR1cm4gdGhpcy56PWUsdGhpc31zZXRXKGUpe3JldHVybiB0aGlzLnc9ZSx0aGlzfXNldENvbXBvbmVudChlLHQpe3N3aXRjaChlKXtjYXNlIDA6dGhpcy54PXQ7YnJlYWs7Y2FzZSAxOnRoaXMueT10O2JyZWFrO2Nhc2UgMjp0aGlzLno9dDticmVhaztjYXNlIDM6dGhpcy53PXQ7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoImluZGV4IGlzIG91dCBvZiByYW5nZTogIitlKX1yZXR1cm4gdGhpc31nZXRDb21wb25lbnQoZSl7c3dpdGNoKGUpe2Nhc2UgMDpyZXR1cm4gdGhpcy54O2Nhc2UgMTpyZXR1cm4gdGhpcy55O2Nhc2UgMjpyZXR1cm4gdGhpcy56O2Nhc2UgMzpyZXR1cm4gdGhpcy53O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIrZSl9fWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCx0aGlzLnksdGhpcy56LHRoaXMudyl9Y29weShlKXtyZXR1cm4gdGhpcy54PWUueCx0aGlzLnk9ZS55LHRoaXMuej1lLnosdGhpcy53PWUudyE9PXZvaWQgMD9lLnc6MSx0aGlzfWFkZChlKXtyZXR1cm4gdGhpcy54Kz1lLngsdGhpcy55Kz1lLnksdGhpcy56Kz1lLnosdGhpcy53Kz1lLncsdGhpc31hZGRTY2FsYXIoZSl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPWUsdGhpcy56Kz1lLHRoaXMudys9ZSx0aGlzfWFkZFZlY3RvcnMoZSx0KXtyZXR1cm4gdGhpcy54PWUueCt0LngsdGhpcy55PWUueSt0LnksdGhpcy56PWUueit0LnosdGhpcy53PWUudyt0LncsdGhpc31hZGRTY2FsZWRWZWN0b3IoZSx0KXtyZXR1cm4gdGhpcy54Kz1lLngqdCx0aGlzLnkrPWUueSp0LHRoaXMueis9ZS56KnQsdGhpcy53Kz1lLncqdCx0aGlzfXN1YihlKXtyZXR1cm4gdGhpcy54LT1lLngsdGhpcy55LT1lLnksdGhpcy56LT1lLnosdGhpcy53LT1lLncsdGhpc31zdWJTY2FsYXIoZSl7cmV0dXJuIHRoaXMueC09ZSx0aGlzLnktPWUsdGhpcy56LT1lLHRoaXMudy09ZSx0aGlzfXN1YlZlY3RvcnMoZSx0KXtyZXR1cm4gdGhpcy54PWUueC10LngsdGhpcy55PWUueS10LnksdGhpcy56PWUuei10LnosdGhpcy53PWUudy10LncsdGhpc31tdWx0aXBseShlKXtyZXR1cm4gdGhpcy54Kj1lLngsdGhpcy55Kj1lLnksdGhpcy56Kj1lLnosdGhpcy53Kj1lLncsdGhpc31tdWx0aXBseVNjYWxhcihlKXtyZXR1cm4gdGhpcy54Kj1lLHRoaXMueSo9ZSx0aGlzLnoqPWUsdGhpcy53Kj1lLHRoaXN9YXBwbHlNYXRyaXg0KGUpe2NvbnN0IHQ9dGhpcy54LG49dGhpcy55LHI9dGhpcy56LHM9dGhpcy53LGE9ZS5lbGVtZW50cztyZXR1cm4gdGhpcy54PWFbMF0qdCthWzRdKm4rYVs4XSpyK2FbMTJdKnMsdGhpcy55PWFbMV0qdCthWzVdKm4rYVs5XSpyK2FbMTNdKnMsdGhpcy56PWFbMl0qdCthWzZdKm4rYVsxMF0qcithWzE0XSpzLHRoaXMudz1hWzNdKnQrYVs3XSpuK2FbMTFdKnIrYVsxNV0qcyx0aGlzfWRpdmlkZShlKXtyZXR1cm4gdGhpcy54Lz1lLngsdGhpcy55Lz1lLnksdGhpcy56Lz1lLnosdGhpcy53Lz1lLncsdGhpc31kaXZpZGVTY2FsYXIoZSl7cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMS9lKX1zZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbihlKXt0aGlzLnc9MipNYXRoLmFjb3MoZS53KTtjb25zdCB0PU1hdGguc3FydCgxLWUudyplLncpO3JldHVybiB0PDFlLTQ/KHRoaXMueD0xLHRoaXMueT0wLHRoaXMuej0wKToodGhpcy54PWUueC90LHRoaXMueT1lLnkvdCx0aGlzLno9ZS56L3QpLHRoaXN9c2V0QXhpc0FuZ2xlRnJvbVJvdGF0aW9uTWF0cml4KGUpe2xldCB0LG4scixzO2NvbnN0IGw9ZS5lbGVtZW50cyxjPWxbMF0sdT1sWzRdLGg9bFs4XSxmPWxbMV0scD1sWzVdLF89bFs5XSx4PWxbMl0sbT1sWzZdLGQ9bFsxMF07aWYoTWF0aC5hYnModS1mKTwuMDEmJk1hdGguYWJzKGgteCk8LjAxJiZNYXRoLmFicyhfLW0pPC4wMSl7aWYoTWF0aC5hYnModStmKTwuMSYmTWF0aC5hYnMoaCt4KTwuMSYmTWF0aC5hYnMoXyttKTwuMSYmTWF0aC5hYnMoYytwK2QtMyk8LjEpcmV0dXJuIHRoaXMuc2V0KDEsMCwwLDApLHRoaXM7dD1NYXRoLlBJO2NvbnN0IFQ9KGMrMSkvMixNPShwKzEpLzIsRj0oZCsxKS8yLGI9KHUrZikvNCx3PShoK3gpLzQsVT0oXyttKS80O3JldHVybiBUPk0mJlQ+Rj9UPC4wMT8obj0wLHI9LjcwNzEwNjc4MSxzPS43MDcxMDY3ODEpOihuPU1hdGguc3FydChUKSxyPWIvbixzPXcvbik6TT5GP008LjAxPyhuPS43MDcxMDY3ODEscj0wLHM9LjcwNzEwNjc4MSk6KHI9TWF0aC5zcXJ0KE0pLG49Yi9yLHM9VS9yKTpGPC4wMT8obj0uNzA3MTA2NzgxLHI9LjcwNzEwNjc4MSxzPTApOihzPU1hdGguc3FydChGKSxuPXcvcyxyPVUvcyksdGhpcy5zZXQobixyLHMsdCksdGhpc31sZXQgQT1NYXRoLnNxcnQoKG0tXykqKG0tXykrKGgteCkqKGgteCkrKGYtdSkqKGYtdSkpO3JldHVybiBNYXRoLmFicyhBKTwuMDAxJiYoQT0xKSx0aGlzLng9KG0tXykvQSx0aGlzLnk9KGgteCkvQSx0aGlzLno9KGYtdSkvQSx0aGlzLnc9TWF0aC5hY29zKChjK3ArZC0xKS8yKSx0aGlzfXNldEZyb21NYXRyaXhQb3NpdGlvbihlKXtjb25zdCB0PWUuZWxlbWVudHM7cmV0dXJuIHRoaXMueD10WzEyXSx0aGlzLnk9dFsxM10sdGhpcy56PXRbMTRdLHRoaXMudz10WzE1XSx0aGlzfW1pbihlKXtyZXR1cm4gdGhpcy54PU1hdGgubWluKHRoaXMueCxlLngpLHRoaXMueT1NYXRoLm1pbih0aGlzLnksZS55KSx0aGlzLno9TWF0aC5taW4odGhpcy56LGUueiksdGhpcy53PU1hdGgubWluKHRoaXMudyxlLncpLHRoaXN9bWF4KGUpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodGhpcy54LGUueCksdGhpcy55PU1hdGgubWF4KHRoaXMueSxlLnkpLHRoaXMuej1NYXRoLm1heCh0aGlzLnosZS56KSx0aGlzLnc9TWF0aC5tYXgodGhpcy53LGUudyksdGhpc31jbGFtcChlLHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgoZS54LE1hdGgubWluKHQueCx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgoZS55LE1hdGgubWluKHQueSx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgoZS56LE1hdGgubWluKHQueix0aGlzLnopKSx0aGlzLnc9TWF0aC5tYXgoZS53LE1hdGgubWluKHQudyx0aGlzLncpKSx0aGlzfWNsYW1wU2NhbGFyKGUsdCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heChlLE1hdGgubWluKHQsdGhpcy54KSksdGhpcy55PU1hdGgubWF4KGUsTWF0aC5taW4odCx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgoZSxNYXRoLm1pbih0LHRoaXMueikpLHRoaXMudz1NYXRoLm1heChlLE1hdGgubWluKHQsdGhpcy53KSksdGhpc31jbGFtcExlbmd0aChlLHQpe2NvbnN0IG49dGhpcy5sZW5ndGgoKTtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIobnx8MSkubXVsdGlwbHlTY2FsYXIoTWF0aC5tYXgoZSxNYXRoLm1pbih0LG4pKSl9Zmxvb3IoKXtyZXR1cm4gdGhpcy54PU1hdGguZmxvb3IodGhpcy54KSx0aGlzLnk9TWF0aC5mbG9vcih0aGlzLnkpLHRoaXMuej1NYXRoLmZsb29yKHRoaXMueiksdGhpcy53PU1hdGguZmxvb3IodGhpcy53KSx0aGlzfWNlaWwoKXtyZXR1cm4gdGhpcy54PU1hdGguY2VpbCh0aGlzLngpLHRoaXMueT1NYXRoLmNlaWwodGhpcy55KSx0aGlzLno9TWF0aC5jZWlsKHRoaXMueiksdGhpcy53PU1hdGguY2VpbCh0aGlzLncpLHRoaXN9cm91bmQoKXtyZXR1cm4gdGhpcy54PU1hdGgucm91bmQodGhpcy54KSx0aGlzLnk9TWF0aC5yb3VuZCh0aGlzLnkpLHRoaXMuej1NYXRoLnJvdW5kKHRoaXMueiksdGhpcy53PU1hdGgucm91bmQodGhpcy53KSx0aGlzfXJvdW5kVG9aZXJvKCl7cmV0dXJuIHRoaXMueD1NYXRoLnRydW5jKHRoaXMueCksdGhpcy55PU1hdGgudHJ1bmModGhpcy55KSx0aGlzLno9TWF0aC50cnVuYyh0aGlzLnopLHRoaXMudz1NYXRoLnRydW5jKHRoaXMudyksdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy54PS10aGlzLngsdGhpcy55PS10aGlzLnksdGhpcy56PS10aGlzLnosdGhpcy53PS10aGlzLncsdGhpc31kb3QoZSl7cmV0dXJuIHRoaXMueCplLngrdGhpcy55KmUueSt0aGlzLnoqZS56K3RoaXMudyplLnd9bGVuZ3RoU3EoKXtyZXR1cm4gdGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMud31sZW5ndGgoKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56K3RoaXMudyp0aGlzLncpfW1hbmhhdHRhbkxlbmd0aCgpe3JldHVybiBNYXRoLmFicyh0aGlzLngpK01hdGguYWJzKHRoaXMueSkrTWF0aC5hYnModGhpcy56KStNYXRoLmFicyh0aGlzLncpfW5vcm1hbGl6ZSgpe3JldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpfHwxKX1zZXRMZW5ndGgoZSl7cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoZSl9bGVycChlLHQpe3JldHVybiB0aGlzLngrPShlLngtdGhpcy54KSp0LHRoaXMueSs9KGUueS10aGlzLnkpKnQsdGhpcy56Kz0oZS56LXRoaXMueikqdCx0aGlzLncrPShlLnctdGhpcy53KSp0LHRoaXN9bGVycFZlY3RvcnMoZSx0LG4pe3JldHVybiB0aGlzLng9ZS54Kyh0LngtZS54KSpuLHRoaXMueT1lLnkrKHQueS1lLnkpKm4sdGhpcy56PWUueisodC56LWUueikqbix0aGlzLnc9ZS53Kyh0LnctZS53KSpuLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLng9PT10aGlzLngmJmUueT09PXRoaXMueSYmZS56PT09dGhpcy56JiZlLnc9PT10aGlzLnd9ZnJvbUFycmF5KGUsdD0wKXtyZXR1cm4gdGhpcy54PWVbdF0sdGhpcy55PWVbdCsxXSx0aGlzLno9ZVt0KzJdLHRoaXMudz1lW3QrM10sdGhpc310b0FycmF5KGU9W10sdD0wKXtyZXR1cm4gZVt0XT10aGlzLngsZVt0KzFdPXRoaXMueSxlW3QrMl09dGhpcy56LGVbdCszXT10aGlzLncsZX1mcm9tQnVmZmVyQXR0cmlidXRlKGUsdCl7cmV0dXJuIHRoaXMueD1lLmdldFgodCksdGhpcy55PWUuZ2V0WSh0KSx0aGlzLno9ZS5nZXRaKHQpLHRoaXMudz1lLmdldFcodCksdGhpc31yYW5kb20oKXtyZXR1cm4gdGhpcy54PU1hdGgucmFuZG9tKCksdGhpcy55PU1hdGgucmFuZG9tKCksdGhpcy56PU1hdGgucmFuZG9tKCksdGhpcy53PU1hdGgucmFuZG9tKCksdGhpc30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLngseWllbGQgdGhpcy55LHlpZWxkIHRoaXMueix5aWVsZCB0aGlzLnd9fWNsYXNzIG1hIGV4dGVuZHMgTW57Y29uc3RydWN0b3IoZT0xLHQ9MSxuPXt9KXtzdXBlcigpLHRoaXMuaXNSZW5kZXJUYXJnZXQ9ITAsdGhpcy53aWR0aD1lLHRoaXMuaGVpZ2h0PXQsdGhpcy5kZXB0aD0xLHRoaXMuc2Npc3Nvcj1uZXcgaXQoMCwwLGUsdCksdGhpcy5zY2lzc29yVGVzdD0hMSx0aGlzLnZpZXdwb3J0PW5ldyBpdCgwLDAsZSx0KTtjb25zdCByPXt3aWR0aDplLGhlaWdodDp0LGRlcHRoOjF9O249T2JqZWN0LmFzc2lnbih7Z2VuZXJhdGVNaXBtYXBzOiExLGludGVybmFsRm9ybWF0Om51bGwsbWluRmlsdGVyOjEwMDYsZGVwdGhCdWZmZXI6ITAsc3RlbmNpbEJ1ZmZlcjohMSxyZXNvbHZlRGVwdGhCdWZmZXI6ITAscmVzb2x2ZVN0ZW5jaWxCdWZmZXI6ITAsZGVwdGhUZXh0dXJlOm51bGwsc2FtcGxlczowLGNvdW50OjF9LG4pO2NvbnN0IHM9bmV3IHZ0KHIsbi5tYXBwaW5nLG4ud3JhcFMsbi53cmFwVCxuLm1hZ0ZpbHRlcixuLm1pbkZpbHRlcixuLmZvcm1hdCxuLnR5cGUsbi5hbmlzb3Ryb3B5LG4uY29sb3JTcGFjZSk7cy5mbGlwWT0hMSxzLmdlbmVyYXRlTWlwbWFwcz1uLmdlbmVyYXRlTWlwbWFwcyxzLmludGVybmFsRm9ybWF0PW4uaW50ZXJuYWxGb3JtYXQsdGhpcy50ZXh0dXJlcz1bXTtjb25zdCBhPW4uY291bnQ7Zm9yKGxldCBvPTA7bzxhO28rKyl0aGlzLnRleHR1cmVzW29dPXMuY2xvbmUoKSx0aGlzLnRleHR1cmVzW29dLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hMDt0aGlzLmRlcHRoQnVmZmVyPW4uZGVwdGhCdWZmZXIsdGhpcy5zdGVuY2lsQnVmZmVyPW4uc3RlbmNpbEJ1ZmZlcix0aGlzLnJlc29sdmVEZXB0aEJ1ZmZlcj1uLnJlc29sdmVEZXB0aEJ1ZmZlcix0aGlzLnJlc29sdmVTdGVuY2lsQnVmZmVyPW4ucmVzb2x2ZVN0ZW5jaWxCdWZmZXIsdGhpcy5kZXB0aFRleHR1cmU9bi5kZXB0aFRleHR1cmUsdGhpcy5zYW1wbGVzPW4uc2FtcGxlc31nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzLnRleHR1cmVzWzBdfXNldCB0ZXh0dXJlKGUpe3RoaXMudGV4dHVyZXNbMF09ZX1zZXRTaXplKGUsdCxuPTEpe2lmKHRoaXMud2lkdGghPT1lfHx0aGlzLmhlaWdodCE9PXR8fHRoaXMuZGVwdGghPT1uKXt0aGlzLndpZHRoPWUsdGhpcy5oZWlnaHQ9dCx0aGlzLmRlcHRoPW47Zm9yKGxldCByPTAscz10aGlzLnRleHR1cmVzLmxlbmd0aDtyPHM7cisrKXRoaXMudGV4dHVyZXNbcl0uaW1hZ2Uud2lkdGg9ZSx0aGlzLnRleHR1cmVzW3JdLmltYWdlLmhlaWdodD10LHRoaXMudGV4dHVyZXNbcl0uaW1hZ2UuZGVwdGg9bjt0aGlzLmRpc3Bvc2UoKX10aGlzLnZpZXdwb3J0LnNldCgwLDAsZSx0KSx0aGlzLnNjaXNzb3Iuc2V0KDAsMCxlLHQpfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX1jb3B5KGUpe3RoaXMud2lkdGg9ZS53aWR0aCx0aGlzLmhlaWdodD1lLmhlaWdodCx0aGlzLmRlcHRoPWUuZGVwdGgsdGhpcy5zY2lzc29yLmNvcHkoZS5zY2lzc29yKSx0aGlzLnNjaXNzb3JUZXN0PWUuc2Npc3NvclRlc3QsdGhpcy52aWV3cG9ydC5jb3B5KGUudmlld3BvcnQpLHRoaXMudGV4dHVyZXMubGVuZ3RoPTA7Zm9yKGxldCBuPTAscj1lLnRleHR1cmVzLmxlbmd0aDtuPHI7bisrKXRoaXMudGV4dHVyZXNbbl09ZS50ZXh0dXJlc1tuXS5jbG9uZSgpLHRoaXMudGV4dHVyZXNbbl0uaXNSZW5kZXJUYXJnZXRUZXh0dXJlPSEwO2NvbnN0IHQ9T2JqZWN0LmFzc2lnbih7fSxlLnRleHR1cmUuaW1hZ2UpO3JldHVybiB0aGlzLnRleHR1cmUuc291cmNlPW5ldyBScih0KSx0aGlzLmRlcHRoQnVmZmVyPWUuZGVwdGhCdWZmZXIsdGhpcy5zdGVuY2lsQnVmZmVyPWUuc3RlbmNpbEJ1ZmZlcix0aGlzLnJlc29sdmVEZXB0aEJ1ZmZlcj1lLnJlc29sdmVEZXB0aEJ1ZmZlcix0aGlzLnJlc29sdmVTdGVuY2lsQnVmZmVyPWUucmVzb2x2ZVN0ZW5jaWxCdWZmZXIsZS5kZXB0aFRleHR1cmUhPT1udWxsJiYodGhpcy5kZXB0aFRleHR1cmU9ZS5kZXB0aFRleHR1cmUuY2xvbmUoKSksdGhpcy5zYW1wbGVzPWUuc2FtcGxlcyx0aGlzfWRpc3Bvc2UoKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImRpc3Bvc2UifSl9fWNsYXNzIEp0IGV4dGVuZHMgbWF7Y29uc3RydWN0b3IoZT0xLHQ9MSxuPXt9KXtzdXBlcihlLHQsbiksdGhpcy5pc1dlYkdMUmVuZGVyVGFyZ2V0PSEwfX1jbGFzcyBDciBleHRlbmRzIHZ0e2NvbnN0cnVjdG9yKGU9bnVsbCx0PTEsbj0xLHI9MSl7c3VwZXIobnVsbCksdGhpcy5pc0RhdGFBcnJheVRleHR1cmU9ITAsdGhpcy5pbWFnZT17ZGF0YTplLHdpZHRoOnQsaGVpZ2h0Om4sZGVwdGg6cn0sdGhpcy5tYWdGaWx0ZXI9MTAwMyx0aGlzLm1pbkZpbHRlcj0xMDAzLHRoaXMud3JhcFI9MTAwMSx0aGlzLmdlbmVyYXRlTWlwbWFwcz0hMSx0aGlzLmZsaXBZPSExLHRoaXMudW5wYWNrQWxpZ25tZW50PTEsdGhpcy5sYXllclVwZGF0ZXM9bmV3IFNldH1hZGRMYXllclVwZGF0ZShlKXt0aGlzLmxheWVyVXBkYXRlcy5hZGQoZSl9Y2xlYXJMYXllclVwZGF0ZXMoKXt0aGlzLmxheWVyVXBkYXRlcy5jbGVhcigpfX1jbGFzcyBfYSBleHRlbmRzIHZ0e2NvbnN0cnVjdG9yKGU9bnVsbCx0PTEsbj0xLHI9MSl7c3VwZXIobnVsbCksdGhpcy5pc0RhdGEzRFRleHR1cmU9ITAsdGhpcy5pbWFnZT17ZGF0YTplLHdpZHRoOnQsaGVpZ2h0Om4sZGVwdGg6cn0sdGhpcy5tYWdGaWx0ZXI9MTAwMyx0aGlzLm1pbkZpbHRlcj0xMDAzLHRoaXMud3JhcFI9MTAwMSx0aGlzLmdlbmVyYXRlTWlwbWFwcz0hMSx0aGlzLmZsaXBZPSExLHRoaXMudW5wYWNrQWxpZ25tZW50PTF9fWNsYXNzIFhue2NvbnN0cnVjdG9yKGU9MCx0PTAsbj0wLHI9MSl7dGhpcy5pc1F1YXRlcm5pb249ITAsdGhpcy5feD1lLHRoaXMuX3k9dCx0aGlzLl96PW4sdGhpcy5fdz1yfXN0YXRpYyBzbGVycEZsYXQoZSx0LG4scixzLGEsbyl7bGV0IGw9bltyKzBdLGM9bltyKzFdLHU9bltyKzJdLGg9bltyKzNdO2NvbnN0IGY9c1thKzBdLHA9c1thKzFdLF89c1thKzJdLHg9c1thKzNdO2lmKG89PT0wKXtlW3QrMF09bCxlW3QrMV09YyxlW3QrMl09dSxlW3QrM109aDtyZXR1cm59aWYobz09PTEpe2VbdCswXT1mLGVbdCsxXT1wLGVbdCsyXT1fLGVbdCszXT14O3JldHVybn1pZihoIT09eHx8bCE9PWZ8fGMhPT1wfHx1IT09Xyl7bGV0IG09MS1vO2NvbnN0IGQ9bCpmK2MqcCt1Kl8raCp4LEE9ZD49MD8xOi0xLFQ9MS1kKmQ7aWYoVD5OdW1iZXIuRVBTSUxPTil7Y29uc3QgRj1NYXRoLnNxcnQoVCksYj1NYXRoLmF0YW4yKEYsZCpBKTttPU1hdGguc2luKG0qYikvRixvPU1hdGguc2luKG8qYikvRn1jb25zdCBNPW8qQTtpZihsPWwqbStmKk0sYz1jKm0rcCpNLHU9dSptK18qTSxoPWgqbSt4Kk0sbT09PTEtbyl7Y29uc3QgRj0xL01hdGguc3FydChsKmwrYypjK3UqdStoKmgpO2wqPUYsYyo9Rix1Kj1GLGgqPUZ9fWVbdF09bCxlW3QrMV09YyxlW3QrMl09dSxlW3QrM109aH1zdGF0aWMgbXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQoZSx0LG4scixzLGEpe2NvbnN0IG89bltyXSxsPW5bcisxXSxjPW5bcisyXSx1PW5bciszXSxoPXNbYV0sZj1zW2ErMV0scD1zW2ErMl0sXz1zW2ErM107cmV0dXJuIGVbdF09bypfK3UqaCtsKnAtYypmLGVbdCsxXT1sKl8rdSpmK2MqaC1vKnAsZVt0KzJdPWMqXyt1KnArbypmLWwqaCxlW3QrM109dSpfLW8qaC1sKmYtYypwLGV9Z2V0IHgoKXtyZXR1cm4gdGhpcy5feH1zZXQgeChlKXt0aGlzLl94PWUsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfWdldCB5KCl7cmV0dXJuIHRoaXMuX3l9c2V0IHkoZSl7dGhpcy5feT1lLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKX1nZXQgeigpe3JldHVybiB0aGlzLl96fXNldCB6KGUpe3RoaXMuX3o9ZSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9Z2V0IHcoKXtyZXR1cm4gdGhpcy5fd31zZXQgdyhlKXt0aGlzLl93PWUsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfXNldChlLHQsbixyKXtyZXR1cm4gdGhpcy5feD1lLHRoaXMuX3k9dCx0aGlzLl96PW4sdGhpcy5fdz1yLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuX3gsdGhpcy5feSx0aGlzLl96LHRoaXMuX3cpfWNvcHkoZSl7cmV0dXJuIHRoaXMuX3g9ZS54LHRoaXMuX3k9ZS55LHRoaXMuX3o9ZS56LHRoaXMuX3c9ZS53LHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfXNldEZyb21FdWxlcihlLHQ9ITApe2NvbnN0IG49ZS5feCxyPWUuX3kscz1lLl96LGE9ZS5fb3JkZXIsbz1NYXRoLmNvcyxsPU1hdGguc2luLGM9byhuLzIpLHU9byhyLzIpLGg9byhzLzIpLGY9bChuLzIpLHA9bChyLzIpLF89bChzLzIpO3N3aXRjaChhKXtjYXNlIlhZWiI6dGhpcy5feD1mKnUqaCtjKnAqXyx0aGlzLl95PWMqcCpoLWYqdSpfLHRoaXMuX3o9Yyp1Kl8rZipwKmgsdGhpcy5fdz1jKnUqaC1mKnAqXzticmVhaztjYXNlIllYWiI6dGhpcy5feD1mKnUqaCtjKnAqXyx0aGlzLl95PWMqcCpoLWYqdSpfLHRoaXMuX3o9Yyp1Kl8tZipwKmgsdGhpcy5fdz1jKnUqaCtmKnAqXzticmVhaztjYXNlIlpYWSI6dGhpcy5feD1mKnUqaC1jKnAqXyx0aGlzLl95PWMqcCpoK2YqdSpfLHRoaXMuX3o9Yyp1Kl8rZipwKmgsdGhpcy5fdz1jKnUqaC1mKnAqXzticmVhaztjYXNlIlpZWCI6dGhpcy5feD1mKnUqaC1jKnAqXyx0aGlzLl95PWMqcCpoK2YqdSpfLHRoaXMuX3o9Yyp1Kl8tZipwKmgsdGhpcy5fdz1jKnUqaCtmKnAqXzticmVhaztjYXNlIllaWCI6dGhpcy5feD1mKnUqaCtjKnAqXyx0aGlzLl95PWMqcCpoK2YqdSpfLHRoaXMuX3o9Yyp1Kl8tZipwKmgsdGhpcy5fdz1jKnUqaC1mKnAqXzticmVhaztjYXNlIlhaWSI6dGhpcy5feD1mKnUqaC1jKnAqXyx0aGlzLl95PWMqcCpoLWYqdSpfLHRoaXMuX3o9Yyp1Kl8rZipwKmgsdGhpcy5fdz1jKnUqaCtmKnAqXzticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybigiVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICIrYSl9cmV0dXJuIHQ9PT0hMCYmdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbUF4aXNBbmdsZShlLHQpe2NvbnN0IG49dC8yLHI9TWF0aC5zaW4obik7cmV0dXJuIHRoaXMuX3g9ZS54KnIsdGhpcy5feT1lLnkqcix0aGlzLl96PWUueipyLHRoaXMuX3c9TWF0aC5jb3MobiksdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVJvdGF0aW9uTWF0cml4KGUpe2NvbnN0IHQ9ZS5lbGVtZW50cyxuPXRbMF0scj10WzRdLHM9dFs4XSxhPXRbMV0sbz10WzVdLGw9dFs5XSxjPXRbMl0sdT10WzZdLGg9dFsxMF0sZj1uK28raDtpZihmPjApe2NvbnN0IHA9LjUvTWF0aC5zcXJ0KGYrMSk7dGhpcy5fdz0uMjUvcCx0aGlzLl94PSh1LWwpKnAsdGhpcy5feT0ocy1jKSpwLHRoaXMuX3o9KGEtcikqcH1lbHNlIGlmKG4+byYmbj5oKXtjb25zdCBwPTIqTWF0aC5zcXJ0KDErbi1vLWgpO3RoaXMuX3c9KHUtbCkvcCx0aGlzLl94PS4yNSpwLHRoaXMuX3k9KHIrYSkvcCx0aGlzLl96PShzK2MpL3B9ZWxzZSBpZihvPmgpe2NvbnN0IHA9MipNYXRoLnNxcnQoMStvLW4taCk7dGhpcy5fdz0ocy1jKS9wLHRoaXMuX3g9KHIrYSkvcCx0aGlzLl95PS4yNSpwLHRoaXMuX3o9KGwrdSkvcH1lbHNle2NvbnN0IHA9MipNYXRoLnNxcnQoMStoLW4tbyk7dGhpcy5fdz0oYS1yKS9wLHRoaXMuX3g9KHMrYykvcCx0aGlzLl95PShsK3UpL3AsdGhpcy5fej0uMjUqcH1yZXR1cm4gdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVVuaXRWZWN0b3JzKGUsdCl7bGV0IG49ZS5kb3QodCkrMTtyZXR1cm4gbjxOdW1iZXIuRVBTSUxPTj8obj0wLE1hdGguYWJzKGUueCk+TWF0aC5hYnMoZS56KT8odGhpcy5feD0tZS55LHRoaXMuX3k9ZS54LHRoaXMuX3o9MCx0aGlzLl93PW4pOih0aGlzLl94PTAsdGhpcy5feT0tZS56LHRoaXMuX3o9ZS55LHRoaXMuX3c9bikpOih0aGlzLl94PWUueSp0LnotZS56KnQueSx0aGlzLl95PWUueip0LngtZS54KnQueix0aGlzLl96PWUueCp0LnktZS55KnQueCx0aGlzLl93PW4pLHRoaXMubm9ybWFsaXplKCl9YW5nbGVUbyhlKXtyZXR1cm4gMipNYXRoLmFjb3MoTWF0aC5hYnMoX3QodGhpcy5kb3QoZSksLTEsMSkpKX1yb3RhdGVUb3dhcmRzKGUsdCl7Y29uc3Qgbj10aGlzLmFuZ2xlVG8oZSk7aWYobj09PTApcmV0dXJuIHRoaXM7Y29uc3Qgcj1NYXRoLm1pbigxLHQvbik7cmV0dXJuIHRoaXMuc2xlcnAoZSxyKSx0aGlzfWlkZW50aXR5KCl7cmV0dXJuIHRoaXMuc2V0KDAsMCwwLDEpfWludmVydCgpe3JldHVybiB0aGlzLmNvbmp1Z2F0ZSgpfWNvbmp1Z2F0ZSgpe3JldHVybiB0aGlzLl94Kj0tMSx0aGlzLl95Kj0tMSx0aGlzLl96Kj0tMSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31kb3QoZSl7cmV0dXJuIHRoaXMuX3gqZS5feCt0aGlzLl95KmUuX3krdGhpcy5feiplLl96K3RoaXMuX3cqZS5fd31sZW5ndGhTcSgpe3JldHVybiB0aGlzLl94KnRoaXMuX3grdGhpcy5feSp0aGlzLl95K3RoaXMuX3oqdGhpcy5feit0aGlzLl93KnRoaXMuX3d9bGVuZ3RoKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLl94KnRoaXMuX3grdGhpcy5feSp0aGlzLl95K3RoaXMuX3oqdGhpcy5feit0aGlzLl93KnRoaXMuX3cpfW5vcm1hbGl6ZSgpe2xldCBlPXRoaXMubGVuZ3RoKCk7cmV0dXJuIGU9PT0wPyh0aGlzLl94PTAsdGhpcy5feT0wLHRoaXMuX3o9MCx0aGlzLl93PTEpOihlPTEvZSx0aGlzLl94PXRoaXMuX3gqZSx0aGlzLl95PXRoaXMuX3kqZSx0aGlzLl96PXRoaXMuX3oqZSx0aGlzLl93PXRoaXMuX3cqZSksdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9bXVsdGlwbHkoZSl7cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyh0aGlzLGUpfXByZW11bHRpcGx5KGUpe3JldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoZSx0aGlzKX1tdWx0aXBseVF1YXRlcm5pb25zKGUsdCl7Y29uc3Qgbj1lLl94LHI9ZS5feSxzPWUuX3osYT1lLl93LG89dC5feCxsPXQuX3ksYz10Ll96LHU9dC5fdztyZXR1cm4gdGhpcy5feD1uKnUrYSpvK3IqYy1zKmwsdGhpcy5feT1yKnUrYSpsK3Mqby1uKmMsdGhpcy5fej1zKnUrYSpjK24qbC1yKm8sdGhpcy5fdz1hKnUtbipvLXIqbC1zKmMsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2xlcnAoZSx0KXtpZih0PT09MClyZXR1cm4gdGhpcztpZih0PT09MSlyZXR1cm4gdGhpcy5jb3B5KGUpO2NvbnN0IG49dGhpcy5feCxyPXRoaXMuX3kscz10aGlzLl96LGE9dGhpcy5fdztsZXQgbz1hKmUuX3crbiplLl94K3IqZS5feStzKmUuX3o7aWYobzwwPyh0aGlzLl93PS1lLl93LHRoaXMuX3g9LWUuX3gsdGhpcy5feT0tZS5feSx0aGlzLl96PS1lLl96LG89LW8pOnRoaXMuY29weShlKSxvPj0xKXJldHVybiB0aGlzLl93PWEsdGhpcy5feD1uLHRoaXMuX3k9cix0aGlzLl96PXMsdGhpcztjb25zdCBsPTEtbypvO2lmKGw8PU51bWJlci5FUFNJTE9OKXtjb25zdCBwPTEtdDtyZXR1cm4gdGhpcy5fdz1wKmErdCp0aGlzLl93LHRoaXMuX3g9cCpuK3QqdGhpcy5feCx0aGlzLl95PXAqcit0KnRoaXMuX3ksdGhpcy5fej1wKnMrdCp0aGlzLl96LHRoaXMubm9ybWFsaXplKCksdGhpc31jb25zdCBjPU1hdGguc3FydChsKSx1PU1hdGguYXRhbjIoYyxvKSxoPU1hdGguc2luKCgxLXQpKnUpL2MsZj1NYXRoLnNpbih0KnUpL2M7cmV0dXJuIHRoaXMuX3c9YSpoK3RoaXMuX3cqZix0aGlzLl94PW4qaCt0aGlzLl94KmYsdGhpcy5feT1yKmgrdGhpcy5feSpmLHRoaXMuX3o9cypoK3RoaXMuX3oqZix0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31zbGVycFF1YXRlcm5pb25zKGUsdCxuKXtyZXR1cm4gdGhpcy5jb3B5KGUpLnNsZXJwKHQsbil9cmFuZG9tKCl7Y29uc3QgZT0yKk1hdGguUEkqTWF0aC5yYW5kb20oKSx0PTIqTWF0aC5QSSpNYXRoLnJhbmRvbSgpLG49TWF0aC5yYW5kb20oKSxyPU1hdGguc3FydCgxLW4pLHM9TWF0aC5zcXJ0KG4pO3JldHVybiB0aGlzLnNldChyKk1hdGguc2luKGUpLHIqTWF0aC5jb3MoZSkscypNYXRoLnNpbih0KSxzKk1hdGguY29zKHQpKX1lcXVhbHMoZSl7cmV0dXJuIGUuX3g9PT10aGlzLl94JiZlLl95PT09dGhpcy5feSYmZS5fej09PXRoaXMuX3omJmUuX3c9PT10aGlzLl93fWZyb21BcnJheShlLHQ9MCl7cmV0dXJuIHRoaXMuX3g9ZVt0XSx0aGlzLl95PWVbdCsxXSx0aGlzLl96PWVbdCsyXSx0aGlzLl93PWVbdCszXSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc310b0FycmF5KGU9W10sdD0wKXtyZXR1cm4gZVt0XT10aGlzLl94LGVbdCsxXT10aGlzLl95LGVbdCsyXT10aGlzLl96LGVbdCszXT10aGlzLl93LGV9ZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHQpe3JldHVybiB0aGlzLl94PWUuZ2V0WCh0KSx0aGlzLl95PWUuZ2V0WSh0KSx0aGlzLl96PWUuZ2V0Wih0KSx0aGlzLl93PWUuZ2V0Vyh0KSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc310b0pTT04oKXtyZXR1cm4gdGhpcy50b0FycmF5KCl9X29uQ2hhbmdlKGUpe3JldHVybiB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrPWUsdGhpc31fb25DaGFuZ2VDYWxsYmFjaygpe30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLl94LHlpZWxkIHRoaXMuX3kseWllbGQgdGhpcy5feix5aWVsZCB0aGlzLl93fX1jbGFzcyBCe2NvbnN0cnVjdG9yKGU9MCx0PTAsbj0wKXtCLnByb3RvdHlwZS5pc1ZlY3RvcjM9ITAsdGhpcy54PWUsdGhpcy55PXQsdGhpcy56PW59c2V0KGUsdCxuKXtyZXR1cm4gbj09PXZvaWQgMCYmKG49dGhpcy56KSx0aGlzLng9ZSx0aGlzLnk9dCx0aGlzLno9bix0aGlzfXNldFNjYWxhcihlKXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PWUsdGhpcy56PWUsdGhpc31zZXRYKGUpe3JldHVybiB0aGlzLng9ZSx0aGlzfXNldFkoZSl7cmV0dXJuIHRoaXMueT1lLHRoaXN9c2V0WihlKXtyZXR1cm4gdGhpcy56PWUsdGhpc31zZXRDb21wb25lbnQoZSx0KXtzd2l0Y2goZSl7Y2FzZSAwOnRoaXMueD10O2JyZWFrO2Nhc2UgMTp0aGlzLnk9dDticmVhaztjYXNlIDI6dGhpcy56PXQ7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoImluZGV4IGlzIG91dCBvZiByYW5nZTogIitlKX1yZXR1cm4gdGhpc31nZXRDb21wb25lbnQoZSl7c3dpdGNoKGUpe2Nhc2UgMDpyZXR1cm4gdGhpcy54O2Nhc2UgMTpyZXR1cm4gdGhpcy55O2Nhc2UgMjpyZXR1cm4gdGhpcy56O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIrZSl9fWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCx0aGlzLnksdGhpcy56KX1jb3B5KGUpe3JldHVybiB0aGlzLng9ZS54LHRoaXMueT1lLnksdGhpcy56PWUueix0aGlzfWFkZChlKXtyZXR1cm4gdGhpcy54Kz1lLngsdGhpcy55Kz1lLnksdGhpcy56Kz1lLnosdGhpc31hZGRTY2FsYXIoZSl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPWUsdGhpcy56Kz1lLHRoaXN9YWRkVmVjdG9ycyhlLHQpe3JldHVybiB0aGlzLng9ZS54K3QueCx0aGlzLnk9ZS55K3QueSx0aGlzLno9ZS56K3Queix0aGlzfWFkZFNjYWxlZFZlY3RvcihlLHQpe3JldHVybiB0aGlzLngrPWUueCp0LHRoaXMueSs9ZS55KnQsdGhpcy56Kz1lLnoqdCx0aGlzfXN1YihlKXtyZXR1cm4gdGhpcy54LT1lLngsdGhpcy55LT1lLnksdGhpcy56LT1lLnosdGhpc31zdWJTY2FsYXIoZSl7cmV0dXJuIHRoaXMueC09ZSx0aGlzLnktPWUsdGhpcy56LT1lLHRoaXN9c3ViVmVjdG9ycyhlLHQpe3JldHVybiB0aGlzLng9ZS54LXQueCx0aGlzLnk9ZS55LXQueSx0aGlzLno9ZS56LXQueix0aGlzfW11bHRpcGx5KGUpe3JldHVybiB0aGlzLngqPWUueCx0aGlzLnkqPWUueSx0aGlzLnoqPWUueix0aGlzfW11bHRpcGx5U2NhbGFyKGUpe3JldHVybiB0aGlzLngqPWUsdGhpcy55Kj1lLHRoaXMueio9ZSx0aGlzfW11bHRpcGx5VmVjdG9ycyhlLHQpe3JldHVybiB0aGlzLng9ZS54KnQueCx0aGlzLnk9ZS55KnQueSx0aGlzLno9ZS56KnQueix0aGlzfWFwcGx5RXVsZXIoZSl7cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKFByLnNldEZyb21FdWxlcihlKSl9YXBwbHlBeGlzQW5nbGUoZSx0KXtyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oUHIuc2V0RnJvbUF4aXNBbmdsZShlLHQpKX1hcHBseU1hdHJpeDMoZSl7Y29uc3QgdD10aGlzLngsbj10aGlzLnkscj10aGlzLnoscz1lLmVsZW1lbnRzO3JldHVybiB0aGlzLng9c1swXSp0K3NbM10qbitzWzZdKnIsdGhpcy55PXNbMV0qdCtzWzRdKm4rc1s3XSpyLHRoaXMuej1zWzJdKnQrc1s1XSpuK3NbOF0qcix0aGlzfWFwcGx5Tm9ybWFsTWF0cml4KGUpe3JldHVybiB0aGlzLmFwcGx5TWF0cml4MyhlKS5ub3JtYWxpemUoKX1hcHBseU1hdHJpeDQoZSl7Y29uc3QgdD10aGlzLngsbj10aGlzLnkscj10aGlzLnoscz1lLmVsZW1lbnRzLGE9MS8oc1szXSp0K3NbN10qbitzWzExXSpyK3NbMTVdKTtyZXR1cm4gdGhpcy54PShzWzBdKnQrc1s0XSpuK3NbOF0qcitzWzEyXSkqYSx0aGlzLnk9KHNbMV0qdCtzWzVdKm4rc1s5XSpyK3NbMTNdKSphLHRoaXMuej0oc1syXSp0K3NbNl0qbitzWzEwXSpyK3NbMTRdKSphLHRoaXN9YXBwbHlRdWF0ZXJuaW9uKGUpe2NvbnN0IHQ9dGhpcy54LG49dGhpcy55LHI9dGhpcy56LHM9ZS54LGE9ZS55LG89ZS56LGw9ZS53LGM9MiooYSpyLW8qbiksdT0yKihvKnQtcypyKSxoPTIqKHMqbi1hKnQpO3JldHVybiB0aGlzLng9dCtsKmMrYSpoLW8qdSx0aGlzLnk9bitsKnUrbypjLXMqaCx0aGlzLno9citsKmgrcyp1LWEqYyx0aGlzfXByb2plY3QoZSl7cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KGUubWF0cml4V29ybGRJbnZlcnNlKS5hcHBseU1hdHJpeDQoZS5wcm9qZWN0aW9uTWF0cml4KX11bnByb2plY3QoZSl7cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KGUucHJvamVjdGlvbk1hdHJpeEludmVyc2UpLmFwcGx5TWF0cml4NChlLm1hdHJpeFdvcmxkKX10cmFuc2Zvcm1EaXJlY3Rpb24oZSl7Y29uc3QgdD10aGlzLngsbj10aGlzLnkscj10aGlzLnoscz1lLmVsZW1lbnRzO3JldHVybiB0aGlzLng9c1swXSp0K3NbNF0qbitzWzhdKnIsdGhpcy55PXNbMV0qdCtzWzVdKm4rc1s5XSpyLHRoaXMuej1zWzJdKnQrc1s2XSpuK3NbMTBdKnIsdGhpcy5ub3JtYWxpemUoKX1kaXZpZGUoZSl7cmV0dXJuIHRoaXMueC89ZS54LHRoaXMueS89ZS55LHRoaXMuei89ZS56LHRoaXN9ZGl2aWRlU2NhbGFyKGUpe3JldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEvZSl9bWluKGUpe3JldHVybiB0aGlzLng9TWF0aC5taW4odGhpcy54LGUueCksdGhpcy55PU1hdGgubWluKHRoaXMueSxlLnkpLHRoaXMuej1NYXRoLm1pbih0aGlzLnosZS56KSx0aGlzfW1heChlKXtyZXR1cm4gdGhpcy54PU1hdGgubWF4KHRoaXMueCxlLngpLHRoaXMueT1NYXRoLm1heCh0aGlzLnksZS55KSx0aGlzLno9TWF0aC5tYXgodGhpcy56LGUueiksdGhpc31jbGFtcChlLHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgoZS54LE1hdGgubWluKHQueCx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgoZS55LE1hdGgubWluKHQueSx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgoZS56LE1hdGgubWluKHQueix0aGlzLnopKSx0aGlzfWNsYW1wU2NhbGFyKGUsdCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heChlLE1hdGgubWluKHQsdGhpcy54KSksdGhpcy55PU1hdGgubWF4KGUsTWF0aC5taW4odCx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgoZSxNYXRoLm1pbih0LHRoaXMueikpLHRoaXN9Y2xhbXBMZW5ndGgoZSx0KXtjb25zdCBuPXRoaXMubGVuZ3RoKCk7cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKG58fDEpLm11bHRpcGx5U2NhbGFyKE1hdGgubWF4KGUsTWF0aC5taW4odCxuKSkpfWZsb29yKCl7cmV0dXJuIHRoaXMueD1NYXRoLmZsb29yKHRoaXMueCksdGhpcy55PU1hdGguZmxvb3IodGhpcy55KSx0aGlzLno9TWF0aC5mbG9vcih0aGlzLnopLHRoaXN9Y2VpbCgpe3JldHVybiB0aGlzLng9TWF0aC5jZWlsKHRoaXMueCksdGhpcy55PU1hdGguY2VpbCh0aGlzLnkpLHRoaXMuej1NYXRoLmNlaWwodGhpcy56KSx0aGlzfXJvdW5kKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJvdW5kKHRoaXMueCksdGhpcy55PU1hdGgucm91bmQodGhpcy55KSx0aGlzLno9TWF0aC5yb3VuZCh0aGlzLnopLHRoaXN9cm91bmRUb1plcm8oKXtyZXR1cm4gdGhpcy54PU1hdGgudHJ1bmModGhpcy54KSx0aGlzLnk9TWF0aC50cnVuYyh0aGlzLnkpLHRoaXMuej1NYXRoLnRydW5jKHRoaXMueiksdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy54PS10aGlzLngsdGhpcy55PS10aGlzLnksdGhpcy56PS10aGlzLnosdGhpc31kb3QoZSl7cmV0dXJuIHRoaXMueCplLngrdGhpcy55KmUueSt0aGlzLnoqZS56fWxlbmd0aFNxKCl7cmV0dXJuIHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56fWxlbmd0aCgpe3JldHVybiBNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnopfW1hbmhhdHRhbkxlbmd0aCgpe3JldHVybiBNYXRoLmFicyh0aGlzLngpK01hdGguYWJzKHRoaXMueSkrTWF0aC5hYnModGhpcy56KX1ub3JtYWxpemUoKXtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKXx8MSl9c2V0TGVuZ3RoKGUpe3JldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGUpfWxlcnAoZSx0KXtyZXR1cm4gdGhpcy54Kz0oZS54LXRoaXMueCkqdCx0aGlzLnkrPShlLnktdGhpcy55KSp0LHRoaXMueis9KGUuei10aGlzLnopKnQsdGhpc31sZXJwVmVjdG9ycyhlLHQsbil7cmV0dXJuIHRoaXMueD1lLngrKHQueC1lLngpKm4sdGhpcy55PWUueSsodC55LWUueSkqbix0aGlzLno9ZS56Kyh0LnotZS56KSpuLHRoaXN9Y3Jvc3MoZSl7cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKHRoaXMsZSl9Y3Jvc3NWZWN0b3JzKGUsdCl7Y29uc3Qgbj1lLngscj1lLnkscz1lLnosYT10Lngsbz10LnksbD10Lno7cmV0dXJuIHRoaXMueD1yKmwtcypvLHRoaXMueT1zKmEtbipsLHRoaXMuej1uKm8tciphLHRoaXN9cHJvamVjdE9uVmVjdG9yKGUpe2NvbnN0IHQ9ZS5sZW5ndGhTcSgpO2lmKHQ9PT0wKXJldHVybiB0aGlzLnNldCgwLDAsMCk7Y29uc3Qgbj1lLmRvdCh0aGlzKS90O3JldHVybiB0aGlzLmNvcHkoZSkubXVsdGlwbHlTY2FsYXIobil9cHJvamVjdE9uUGxhbmUoZSl7cmV0dXJuIEdpLmNvcHkodGhpcykucHJvamVjdE9uVmVjdG9yKGUpLHRoaXMuc3ViKEdpKX1yZWZsZWN0KGUpe3JldHVybiB0aGlzLnN1YihHaS5jb3B5KGUpLm11bHRpcGx5U2NhbGFyKDIqdGhpcy5kb3QoZSkpKX1hbmdsZVRvKGUpe2NvbnN0IHQ9TWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3EoKSplLmxlbmd0aFNxKCkpO2lmKHQ9PT0wKXJldHVybiBNYXRoLlBJLzI7Y29uc3Qgbj10aGlzLmRvdChlKS90O3JldHVybiBNYXRoLmFjb3MoX3QobiwtMSwxKSl9ZGlzdGFuY2VUbyhlKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoZSkpfWRpc3RhbmNlVG9TcXVhcmVkKGUpe2NvbnN0IHQ9dGhpcy54LWUueCxuPXRoaXMueS1lLnkscj10aGlzLnotZS56O3JldHVybiB0KnQrbipuK3Iqcn1tYW5oYXR0YW5EaXN0YW5jZVRvKGUpe3JldHVybiBNYXRoLmFicyh0aGlzLngtZS54KStNYXRoLmFicyh0aGlzLnktZS55KStNYXRoLmFicyh0aGlzLnotZS56KX1zZXRGcm9tU3BoZXJpY2FsKGUpe3JldHVybiB0aGlzLnNldEZyb21TcGhlcmljYWxDb29yZHMoZS5yYWRpdXMsZS5waGksZS50aGV0YSl9c2V0RnJvbVNwaGVyaWNhbENvb3JkcyhlLHQsbil7Y29uc3Qgcj1NYXRoLnNpbih0KSplO3JldHVybiB0aGlzLng9cipNYXRoLnNpbihuKSx0aGlzLnk9TWF0aC5jb3ModCkqZSx0aGlzLno9cipNYXRoLmNvcyhuKSx0aGlzfXNldEZyb21DeWxpbmRyaWNhbChlKXtyZXR1cm4gdGhpcy5zZXRGcm9tQ3lsaW5kcmljYWxDb29yZHMoZS5yYWRpdXMsZS50aGV0YSxlLnkpfXNldEZyb21DeWxpbmRyaWNhbENvb3JkcyhlLHQsbil7cmV0dXJuIHRoaXMueD1lKk1hdGguc2luKHQpLHRoaXMueT1uLHRoaXMuej1lKk1hdGguY29zKHQpLHRoaXN9c2V0RnJvbU1hdHJpeFBvc2l0aW9uKGUpe2NvbnN0IHQ9ZS5lbGVtZW50cztyZXR1cm4gdGhpcy54PXRbMTJdLHRoaXMueT10WzEzXSx0aGlzLno9dFsxNF0sdGhpc31zZXRGcm9tTWF0cml4U2NhbGUoZSl7Y29uc3QgdD10aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oZSwwKS5sZW5ndGgoKSxuPXRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbihlLDEpLmxlbmd0aCgpLHI9dGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKGUsMikubGVuZ3RoKCk7cmV0dXJuIHRoaXMueD10LHRoaXMueT1uLHRoaXMuej1yLHRoaXN9c2V0RnJvbU1hdHJpeENvbHVtbihlLHQpe3JldHVybiB0aGlzLmZyb21BcnJheShlLmVsZW1lbnRzLHQqNCl9c2V0RnJvbU1hdHJpeDNDb2x1bW4oZSx0KXtyZXR1cm4gdGhpcy5mcm9tQXJyYXkoZS5lbGVtZW50cyx0KjMpfXNldEZyb21FdWxlcihlKXtyZXR1cm4gdGhpcy54PWUuX3gsdGhpcy55PWUuX3ksdGhpcy56PWUuX3osdGhpc31zZXRGcm9tQ29sb3IoZSl7cmV0dXJuIHRoaXMueD1lLnIsdGhpcy55PWUuZyx0aGlzLno9ZS5iLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLng9PT10aGlzLngmJmUueT09PXRoaXMueSYmZS56PT09dGhpcy56fWZyb21BcnJheShlLHQ9MCl7cmV0dXJuIHRoaXMueD1lW3RdLHRoaXMueT1lW3QrMV0sdGhpcy56PWVbdCsyXSx0aGlzfXRvQXJyYXkoZT1bXSx0PTApe3JldHVybiBlW3RdPXRoaXMueCxlW3QrMV09dGhpcy55LGVbdCsyXT10aGlzLnosZX1mcm9tQnVmZmVyQXR0cmlidXRlKGUsdCl7cmV0dXJuIHRoaXMueD1lLmdldFgodCksdGhpcy55PWUuZ2V0WSh0KSx0aGlzLno9ZS5nZXRaKHQpLHRoaXN9cmFuZG9tKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJhbmRvbSgpLHRoaXMueT1NYXRoLnJhbmRvbSgpLHRoaXMuej1NYXRoLnJhbmRvbSgpLHRoaXN9cmFuZG9tRGlyZWN0aW9uKCl7Y29uc3QgZT1NYXRoLnJhbmRvbSgpKk1hdGguUEkqMix0PU1hdGgucmFuZG9tKCkqMi0xLG49TWF0aC5zcXJ0KDEtdCp0KTtyZXR1cm4gdGhpcy54PW4qTWF0aC5jb3MoZSksdGhpcy55PXQsdGhpcy56PW4qTWF0aC5zaW4oZSksdGhpc30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLngseWllbGQgdGhpcy55LHlpZWxkIHRoaXMuen19Y29uc3QgR2k9bmV3IEIsUHI9bmV3IFhuO2NsYXNzIHFue2NvbnN0cnVjdG9yKGU9bmV3IEIoMS8wLDEvMCwxLzApLHQ9bmV3IEIoLTEvMCwtMS8wLC0xLzApKXt0aGlzLmlzQm94Mz0hMCx0aGlzLm1pbj1lLHRoaXMubWF4PXR9c2V0KGUsdCl7cmV0dXJuIHRoaXMubWluLmNvcHkoZSksdGhpcy5tYXguY29weSh0KSx0aGlzfXNldEZyb21BcnJheShlKXt0aGlzLm1ha2VFbXB0eSgpO2ZvcihsZXQgdD0wLG49ZS5sZW5ndGg7dDxuO3QrPTMpdGhpcy5leHBhbmRCeVBvaW50KEx0LmZyb21BcnJheShlLHQpKTtyZXR1cm4gdGhpc31zZXRGcm9tQnVmZmVyQXR0cmlidXRlKGUpe3RoaXMubWFrZUVtcHR5KCk7Zm9yKGxldCB0PTAsbj1lLmNvdW50O3Q8bjt0KyspdGhpcy5leHBhbmRCeVBvaW50KEx0LmZyb21CdWZmZXJBdHRyaWJ1dGUoZSx0KSk7cmV0dXJuIHRoaXN9c2V0RnJvbVBvaW50cyhlKXt0aGlzLm1ha2VFbXB0eSgpO2ZvcihsZXQgdD0wLG49ZS5sZW5ndGg7dDxuO3QrKyl0aGlzLmV4cGFuZEJ5UG9pbnQoZVt0XSk7cmV0dXJuIHRoaXN9c2V0RnJvbUNlbnRlckFuZFNpemUoZSx0KXtjb25zdCBuPUx0LmNvcHkodCkubXVsdGlwbHlTY2FsYXIoLjUpO3JldHVybiB0aGlzLm1pbi5jb3B5KGUpLnN1YihuKSx0aGlzLm1heC5jb3B5KGUpLmFkZChuKSx0aGlzfXNldEZyb21PYmplY3QoZSx0PSExKXtyZXR1cm4gdGhpcy5tYWtlRW1wdHkoKSx0aGlzLmV4cGFuZEJ5T2JqZWN0KGUsdCl9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfWNvcHkoZSl7cmV0dXJuIHRoaXMubWluLmNvcHkoZS5taW4pLHRoaXMubWF4LmNvcHkoZS5tYXgpLHRoaXN9bWFrZUVtcHR5KCl7cmV0dXJuIHRoaXMubWluLng9dGhpcy5taW4ueT10aGlzLm1pbi56PTEvMCx0aGlzLm1heC54PXRoaXMubWF4Lnk9dGhpcy5tYXguej0tMS8wLHRoaXN9aXNFbXB0eSgpe3JldHVybiB0aGlzLm1heC54PHRoaXMubWluLnh8fHRoaXMubWF4Lnk8dGhpcy5taW4ueXx8dGhpcy5tYXguejx0aGlzLm1pbi56fWdldENlbnRlcihlKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/ZS5zZXQoMCwwLDApOmUuYWRkVmVjdG9ycyh0aGlzLm1pbix0aGlzLm1heCkubXVsdGlwbHlTY2FsYXIoLjUpfWdldFNpemUoZSl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP2Uuc2V0KDAsMCwwKTplLnN1YlZlY3RvcnModGhpcy5tYXgsdGhpcy5taW4pfWV4cGFuZEJ5UG9pbnQoZSl7cmV0dXJuIHRoaXMubWluLm1pbihlKSx0aGlzLm1heC5tYXgoZSksdGhpc31leHBhbmRCeVZlY3RvcihlKXtyZXR1cm4gdGhpcy5taW4uc3ViKGUpLHRoaXMubWF4LmFkZChlKSx0aGlzfWV4cGFuZEJ5U2NhbGFyKGUpe3JldHVybiB0aGlzLm1pbi5hZGRTY2FsYXIoLWUpLHRoaXMubWF4LmFkZFNjYWxhcihlKSx0aGlzfWV4cGFuZEJ5T2JqZWN0KGUsdD0hMSl7ZS51cGRhdGVXb3JsZE1hdHJpeCghMSwhMSk7Y29uc3Qgbj1lLmdlb21ldHJ5O2lmKG4hPT12b2lkIDApe2NvbnN0IHM9bi5nZXRBdHRyaWJ1dGUoInBvc2l0aW9uIik7aWYodD09PSEwJiZzIT09dm9pZCAwJiZlLmlzSW5zdGFuY2VkTWVzaCE9PSEwKWZvcihsZXQgYT0wLG89cy5jb3VudDthPG87YSsrKWUuaXNNZXNoPT09ITA/ZS5nZXRWZXJ0ZXhQb3NpdGlvbihhLEx0KTpMdC5mcm9tQnVmZmVyQXR0cmlidXRlKHMsYSksTHQuYXBwbHlNYXRyaXg0KGUubWF0cml4V29ybGQpLHRoaXMuZXhwYW5kQnlQb2ludChMdCk7ZWxzZSBlLmJvdW5kaW5nQm94IT09dm9pZCAwPyhlLmJvdW5kaW5nQm94PT09bnVsbCYmZS5jb21wdXRlQm91bmRpbmdCb3goKSxzaS5jb3B5KGUuYm91bmRpbmdCb3gpKToobi5ib3VuZGluZ0JveD09PW51bGwmJm4uY29tcHV0ZUJvdW5kaW5nQm94KCksc2kuY29weShuLmJvdW5kaW5nQm94KSksc2kuYXBwbHlNYXRyaXg0KGUubWF0cml4V29ybGQpLHRoaXMudW5pb24oc2kpfWNvbnN0IHI9ZS5jaGlsZHJlbjtmb3IobGV0IHM9MCxhPXIubGVuZ3RoO3M8YTtzKyspdGhpcy5leHBhbmRCeU9iamVjdChyW3NdLHQpO3JldHVybiB0aGlzfWNvbnRhaW5zUG9pbnQoZSl7cmV0dXJuIGUueD49dGhpcy5taW4ueCYmZS54PD10aGlzLm1heC54JiZlLnk+PXRoaXMubWluLnkmJmUueTw9dGhpcy5tYXgueSYmZS56Pj10aGlzLm1pbi56JiZlLno8PXRoaXMubWF4Lnp9Y29udGFpbnNCb3goZSl7cmV0dXJuIHRoaXMubWluLng8PWUubWluLngmJmUubWF4Lng8PXRoaXMubWF4LngmJnRoaXMubWluLnk8PWUubWluLnkmJmUubWF4Lnk8PXRoaXMubWF4LnkmJnRoaXMubWluLno8PWUubWluLnomJmUubWF4Lno8PXRoaXMubWF4Lnp9Z2V0UGFyYW1ldGVyKGUsdCl7cmV0dXJuIHQuc2V0KChlLngtdGhpcy5taW4ueCkvKHRoaXMubWF4LngtdGhpcy5taW4ueCksKGUueS10aGlzLm1pbi55KS8odGhpcy5tYXgueS10aGlzLm1pbi55KSwoZS56LXRoaXMubWluLnopLyh0aGlzLm1heC56LXRoaXMubWluLnopKX1pbnRlcnNlY3RzQm94KGUpe3JldHVybiBlLm1heC54Pj10aGlzLm1pbi54JiZlLm1pbi54PD10aGlzLm1heC54JiZlLm1heC55Pj10aGlzLm1pbi55JiZlLm1pbi55PD10aGlzLm1heC55JiZlLm1heC56Pj10aGlzLm1pbi56JiZlLm1pbi56PD10aGlzLm1heC56fWludGVyc2VjdHNTcGhlcmUoZSl7cmV0dXJuIHRoaXMuY2xhbXBQb2ludChlLmNlbnRlcixMdCksTHQuZGlzdGFuY2VUb1NxdWFyZWQoZS5jZW50ZXIpPD1lLnJhZGl1cyplLnJhZGl1c31pbnRlcnNlY3RzUGxhbmUoZSl7bGV0IHQsbjtyZXR1cm4gZS5ub3JtYWwueD4wPyh0PWUubm9ybWFsLngqdGhpcy5taW4ueCxuPWUubm9ybWFsLngqdGhpcy5tYXgueCk6KHQ9ZS5ub3JtYWwueCp0aGlzLm1heC54LG49ZS5ub3JtYWwueCp0aGlzLm1pbi54KSxlLm5vcm1hbC55PjA/KHQrPWUubm9ybWFsLnkqdGhpcy5taW4ueSxuKz1lLm5vcm1hbC55KnRoaXMubWF4LnkpOih0Kz1lLm5vcm1hbC55KnRoaXMubWF4Lnksbis9ZS5ub3JtYWwueSp0aGlzLm1pbi55KSxlLm5vcm1hbC56PjA/KHQrPWUubm9ybWFsLnoqdGhpcy5taW4ueixuKz1lLm5vcm1hbC56KnRoaXMubWF4LnopOih0Kz1lLm5vcm1hbC56KnRoaXMubWF4Lnosbis9ZS5ub3JtYWwueip0aGlzLm1pbi56KSx0PD0tZS5jb25zdGFudCYmbj49LWUuY29uc3RhbnR9aW50ZXJzZWN0c1RyaWFuZ2xlKGUpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiExO3RoaXMuZ2V0Q2VudGVyKFluKSxhaS5zdWJWZWN0b3JzKHRoaXMubWF4LFluKSxBbi5zdWJWZWN0b3JzKGUuYSxZbiksYm4uc3ViVmVjdG9ycyhlLmIsWW4pLHduLnN1YlZlY3RvcnMoZS5jLFluKSxRdC5zdWJWZWN0b3JzKGJuLEFuKSxlbi5zdWJWZWN0b3JzKHduLGJuKSxsbi5zdWJWZWN0b3JzKEFuLHduKTtsZXQgdD1bMCwtUXQueixRdC55LDAsLWVuLnosZW4ueSwwLC1sbi56LGxuLnksUXQueiwwLC1RdC54LGVuLnosMCwtZW4ueCxsbi56LDAsLWxuLngsLVF0LnksUXQueCwwLC1lbi55LGVuLngsMCwtbG4ueSxsbi54LDBdO3JldHVybiFIaSh0LEFuLGJuLHduLGFpKXx8KHQ9WzEsMCwwLDAsMSwwLDAsMCwxXSwhSGkodCxBbixibix3bixhaSkpPyExOihvaS5jcm9zc1ZlY3RvcnMoUXQsZW4pLHQ9W29pLngsb2kueSxvaS56XSxIaSh0LEFuLGJuLHduLGFpKSl9Y2xhbXBQb2ludChlLHQpe3JldHVybiB0LmNvcHkoZSkuY2xhbXAodGhpcy5taW4sdGhpcy5tYXgpfWRpc3RhbmNlVG9Qb2ludChlKXtyZXR1cm4gdGhpcy5jbGFtcFBvaW50KGUsTHQpLmRpc3RhbmNlVG8oZSl9Z2V0Qm91bmRpbmdTcGhlcmUoZSl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP2UubWFrZUVtcHR5KCk6KHRoaXMuZ2V0Q2VudGVyKGUuY2VudGVyKSxlLnJhZGl1cz10aGlzLmdldFNpemUoTHQpLmxlbmd0aCgpKi41KSxlfWludGVyc2VjdChlKXtyZXR1cm4gdGhpcy5taW4ubWF4KGUubWluKSx0aGlzLm1heC5taW4oZS5tYXgpLHRoaXMuaXNFbXB0eSgpJiZ0aGlzLm1ha2VFbXB0eSgpLHRoaXN9dW5pb24oZSl7cmV0dXJuIHRoaXMubWluLm1pbihlLm1pbiksdGhpcy5tYXgubWF4KGUubWF4KSx0aGlzfWFwcGx5TWF0cml4NChlKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/dGhpczooa3RbMF0uc2V0KHRoaXMubWluLngsdGhpcy5taW4ueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoZSksa3RbMV0uc2V0KHRoaXMubWluLngsdGhpcy5taW4ueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoZSksa3RbMl0uc2V0KHRoaXMubWluLngsdGhpcy5tYXgueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoZSksa3RbM10uc2V0KHRoaXMubWluLngsdGhpcy5tYXgueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoZSksa3RbNF0uc2V0KHRoaXMubWF4LngsdGhpcy5taW4ueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoZSksa3RbNV0uc2V0KHRoaXMubWF4LngsdGhpcy5taW4ueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoZSksa3RbNl0uc2V0KHRoaXMubWF4LngsdGhpcy5tYXgueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoZSksa3RbN10uc2V0KHRoaXMubWF4LngsdGhpcy5tYXgueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoZSksdGhpcy5zZXRGcm9tUG9pbnRzKGt0KSx0aGlzKX10cmFuc2xhdGUoZSl7cmV0dXJuIHRoaXMubWluLmFkZChlKSx0aGlzLm1heC5hZGQoZSksdGhpc31lcXVhbHMoZSl7cmV0dXJuIGUubWluLmVxdWFscyh0aGlzLm1pbikmJmUubWF4LmVxdWFscyh0aGlzLm1heCl9fWNvbnN0IGt0PVtuZXcgQixuZXcgQixuZXcgQixuZXcgQixuZXcgQixuZXcgQixuZXcgQixuZXcgQl0sTHQ9bmV3IEIsc2k9bmV3IHFuLEFuPW5ldyBCLGJuPW5ldyBCLHduPW5ldyBCLFF0PW5ldyBCLGVuPW5ldyBCLGxuPW5ldyBCLFluPW5ldyBCLGFpPW5ldyBCLG9pPW5ldyBCLGNuPW5ldyBCO2Z1bmN0aW9uIEhpKGksZSx0LG4scil7Zm9yKGxldCBzPTAsYT1pLmxlbmd0aC0zO3M8PWE7cys9Myl7Y24uZnJvbUFycmF5KGkscyk7Y29uc3Qgbz1yLngqTWF0aC5hYnMoY24ueCkrci55Kk1hdGguYWJzKGNuLnkpK3IueipNYXRoLmFicyhjbi56KSxsPWUuZG90KGNuKSxjPXQuZG90KGNuKSx1PW4uZG90KGNuKTtpZihNYXRoLm1heCgtTWF0aC5tYXgobCxjLHUpLE1hdGgubWluKGwsYyx1KSk+bylyZXR1cm4hMX1yZXR1cm4hMH1jb25zdCBnYT1uZXcgcW4sJG49bmV3IEIsVmk9bmV3IEI7Y2xhc3MgbGl7Y29uc3RydWN0b3IoZT1uZXcgQix0PS0xKXt0aGlzLmlzU3BoZXJlPSEwLHRoaXMuY2VudGVyPWUsdGhpcy5yYWRpdXM9dH1zZXQoZSx0KXtyZXR1cm4gdGhpcy5jZW50ZXIuY29weShlKSx0aGlzLnJhZGl1cz10LHRoaXN9c2V0RnJvbVBvaW50cyhlLHQpe2NvbnN0IG49dGhpcy5jZW50ZXI7dCE9PXZvaWQgMD9uLmNvcHkodCk6Z2Euc2V0RnJvbVBvaW50cyhlKS5nZXRDZW50ZXIobik7bGV0IHI9MDtmb3IobGV0IHM9MCxhPWUubGVuZ3RoO3M8YTtzKyspcj1NYXRoLm1heChyLG4uZGlzdGFuY2VUb1NxdWFyZWQoZVtzXSkpO3JldHVybiB0aGlzLnJhZGl1cz1NYXRoLnNxcnQociksdGhpc31jb3B5KGUpe3JldHVybiB0aGlzLmNlbnRlci5jb3B5KGUuY2VudGVyKSx0aGlzLnJhZGl1cz1lLnJhZGl1cyx0aGlzfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5yYWRpdXM8MH1tYWtlRW1wdHkoKXtyZXR1cm4gdGhpcy5jZW50ZXIuc2V0KDAsMCwwKSx0aGlzLnJhZGl1cz0tMSx0aGlzfWNvbnRhaW5zUG9pbnQoZSl7cmV0dXJuIGUuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5jZW50ZXIpPD10aGlzLnJhZGl1cyp0aGlzLnJhZGl1c31kaXN0YW5jZVRvUG9pbnQoZSl7cmV0dXJuIGUuZGlzdGFuY2VUbyh0aGlzLmNlbnRlciktdGhpcy5yYWRpdXN9aW50ZXJzZWN0c1NwaGVyZShlKXtjb25zdCB0PXRoaXMucmFkaXVzK2UucmFkaXVzO3JldHVybiBlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCh0aGlzLmNlbnRlcik8PXQqdH1pbnRlcnNlY3RzQm94KGUpe3JldHVybiBlLmludGVyc2VjdHNTcGhlcmUodGhpcyl9aW50ZXJzZWN0c1BsYW5lKGUpe3JldHVybiBNYXRoLmFicyhlLmRpc3RhbmNlVG9Qb2ludCh0aGlzLmNlbnRlcikpPD10aGlzLnJhZGl1c31jbGFtcFBvaW50KGUsdCl7Y29uc3Qgbj10aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZChlKTtyZXR1cm4gdC5jb3B5KGUpLG4+dGhpcy5yYWRpdXMqdGhpcy5yYWRpdXMmJih0LnN1Yih0aGlzLmNlbnRlcikubm9ybWFsaXplKCksdC5tdWx0aXBseVNjYWxhcih0aGlzLnJhZGl1cykuYWRkKHRoaXMuY2VudGVyKSksdH1nZXRCb3VuZGluZ0JveChlKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/KGUubWFrZUVtcHR5KCksZSk6KGUuc2V0KHRoaXMuY2VudGVyLHRoaXMuY2VudGVyKSxlLmV4cGFuZEJ5U2NhbGFyKHRoaXMucmFkaXVzKSxlKX1hcHBseU1hdHJpeDQoZSl7cmV0dXJuIHRoaXMuY2VudGVyLmFwcGx5TWF0cml4NChlKSx0aGlzLnJhZGl1cz10aGlzLnJhZGl1cyplLmdldE1heFNjYWxlT25BeGlzKCksdGhpc310cmFuc2xhdGUoZSl7cmV0dXJuIHRoaXMuY2VudGVyLmFkZChlKSx0aGlzfWV4cGFuZEJ5UG9pbnQoZSl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuY2VudGVyLmNvcHkoZSksdGhpcy5yYWRpdXM9MCx0aGlzOyRuLnN1YlZlY3RvcnMoZSx0aGlzLmNlbnRlcik7Y29uc3QgdD0kbi5sZW5ndGhTcSgpO2lmKHQ+dGhpcy5yYWRpdXMqdGhpcy5yYWRpdXMpe2NvbnN0IG49TWF0aC5zcXJ0KHQpLHI9KG4tdGhpcy5yYWRpdXMpKi41O3RoaXMuY2VudGVyLmFkZFNjYWxlZFZlY3RvcigkbixyL24pLHRoaXMucmFkaXVzKz1yfXJldHVybiB0aGlzfXVuaW9uKGUpe3JldHVybiBlLmlzRW1wdHkoKT90aGlzOnRoaXMuaXNFbXB0eSgpPyh0aGlzLmNvcHkoZSksdGhpcyk6KHRoaXMuY2VudGVyLmVxdWFscyhlLmNlbnRlcik9PT0hMD90aGlzLnJhZGl1cz1NYXRoLm1heCh0aGlzLnJhZGl1cyxlLnJhZGl1cyk6KFZpLnN1YlZlY3RvcnMoZS5jZW50ZXIsdGhpcy5jZW50ZXIpLnNldExlbmd0aChlLnJhZGl1cyksdGhpcy5leHBhbmRCeVBvaW50KCRuLmNvcHkoZS5jZW50ZXIpLmFkZChWaSkpLHRoaXMuZXhwYW5kQnlQb2ludCgkbi5jb3B5KGUuY2VudGVyKS5zdWIoVmkpKSksdGhpcyl9ZXF1YWxzKGUpe3JldHVybiBlLmNlbnRlci5lcXVhbHModGhpcy5jZW50ZXIpJiZlLnJhZGl1cz09PXRoaXMucmFkaXVzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX19Y29uc3QgV3Q9bmV3IEIsa2k9bmV3IEIsY2k9bmV3IEIsdG49bmV3IEIsV2k9bmV3IEIsdWk9bmV3IEIsWGk9bmV3IEI7Y2xhc3MgRHJ7Y29uc3RydWN0b3IoZT1uZXcgQix0PW5ldyBCKDAsMCwtMSkpe3RoaXMub3JpZ2luPWUsdGhpcy5kaXJlY3Rpb249dH1zZXQoZSx0KXtyZXR1cm4gdGhpcy5vcmlnaW4uY29weShlKSx0aGlzLmRpcmVjdGlvbi5jb3B5KHQpLHRoaXN9Y29weShlKXtyZXR1cm4gdGhpcy5vcmlnaW4uY29weShlLm9yaWdpbiksdGhpcy5kaXJlY3Rpb24uY29weShlLmRpcmVjdGlvbiksdGhpc31hdChlLHQpe3JldHVybiB0LmNvcHkodGhpcy5vcmlnaW4pLmFkZFNjYWxlZFZlY3Rvcih0aGlzLmRpcmVjdGlvbixlKX1sb29rQXQoZSl7cmV0dXJuIHRoaXMuZGlyZWN0aW9uLmNvcHkoZSkuc3ViKHRoaXMub3JpZ2luKS5ub3JtYWxpemUoKSx0aGlzfXJlY2FzdChlKXtyZXR1cm4gdGhpcy5vcmlnaW4uY29weSh0aGlzLmF0KGUsV3QpKSx0aGlzfWNsb3Nlc3RQb2ludFRvUG9pbnQoZSx0KXt0LnN1YlZlY3RvcnMoZSx0aGlzLm9yaWdpbik7Y29uc3Qgbj10LmRvdCh0aGlzLmRpcmVjdGlvbik7cmV0dXJuIG48MD90LmNvcHkodGhpcy5vcmlnaW4pOnQuY29weSh0aGlzLm9yaWdpbikuYWRkU2NhbGVkVmVjdG9yKHRoaXMuZGlyZWN0aW9uLG4pfWRpc3RhbmNlVG9Qb2ludChlKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQoZSkpfWRpc3RhbmNlU3FUb1BvaW50KGUpe2NvbnN0IHQ9V3Quc3ViVmVjdG9ycyhlLHRoaXMub3JpZ2luKS5kb3QodGhpcy5kaXJlY3Rpb24pO3JldHVybiB0PDA/dGhpcy5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQoZSk6KFd0LmNvcHkodGhpcy5vcmlnaW4pLmFkZFNjYWxlZFZlY3Rvcih0aGlzLmRpcmVjdGlvbix0KSxXdC5kaXN0YW5jZVRvU3F1YXJlZChlKSl9ZGlzdGFuY2VTcVRvU2VnbWVudChlLHQsbixyKXtraS5jb3B5KGUpLmFkZCh0KS5tdWx0aXBseVNjYWxhciguNSksY2kuY29weSh0KS5zdWIoZSkubm9ybWFsaXplKCksdG4uY29weSh0aGlzLm9yaWdpbikuc3ViKGtpKTtjb25zdCBzPWUuZGlzdGFuY2VUbyh0KSouNSxhPS10aGlzLmRpcmVjdGlvbi5kb3QoY2kpLG89dG4uZG90KHRoaXMuZGlyZWN0aW9uKSxsPS10bi5kb3QoY2kpLGM9dG4ubGVuZ3RoU3EoKSx1PU1hdGguYWJzKDEtYSphKTtsZXQgaCxmLHAsXztpZih1PjApaWYoaD1hKmwtbyxmPWEqby1sLF89cyp1LGg+PTApaWYoZj49LV8paWYoZjw9Xyl7Y29uc3QgeD0xL3U7aCo9eCxmKj14LHA9aCooaCthKmYrMipvKStmKihhKmgrZisyKmwpK2N9ZWxzZSBmPXMsaD1NYXRoLm1heCgwLC0oYSpmK28pKSxwPS1oKmgrZiooZisyKmwpK2M7ZWxzZSBmPS1zLGg9TWF0aC5tYXgoMCwtKGEqZitvKSkscD0taCpoK2YqKGYrMipsKStjO2Vsc2UgZjw9LV8/KGg9TWF0aC5tYXgoMCwtKC1hKnMrbykpLGY9aD4wPy1zOk1hdGgubWluKE1hdGgubWF4KC1zLC1sKSxzKSxwPS1oKmgrZiooZisyKmwpK2MpOmY8PV8/KGg9MCxmPU1hdGgubWluKE1hdGgubWF4KC1zLC1sKSxzKSxwPWYqKGYrMipsKStjKTooaD1NYXRoLm1heCgwLC0oYSpzK28pKSxmPWg+MD9zOk1hdGgubWluKE1hdGgubWF4KC1zLC1sKSxzKSxwPS1oKmgrZiooZisyKmwpK2MpO2Vsc2UgZj1hPjA/LXM6cyxoPU1hdGgubWF4KDAsLShhKmYrbykpLHA9LWgqaCtmKihmKzIqbCkrYztyZXR1cm4gbiYmbi5jb3B5KHRoaXMub3JpZ2luKS5hZGRTY2FsZWRWZWN0b3IodGhpcy5kaXJlY3Rpb24saCksciYmci5jb3B5KGtpKS5hZGRTY2FsZWRWZWN0b3IoY2ksZikscH1pbnRlcnNlY3RTcGhlcmUoZSx0KXtXdC5zdWJWZWN0b3JzKGUuY2VudGVyLHRoaXMub3JpZ2luKTtjb25zdCBuPVd0LmRvdCh0aGlzLmRpcmVjdGlvbikscj1XdC5kb3QoV3QpLW4qbixzPWUucmFkaXVzKmUucmFkaXVzO2lmKHI+cylyZXR1cm4gbnVsbDtjb25zdCBhPU1hdGguc3FydChzLXIpLG89bi1hLGw9bithO3JldHVybiBsPDA/bnVsbDpvPDA/dGhpcy5hdChsLHQpOnRoaXMuYXQobyx0KX1pbnRlcnNlY3RzU3BoZXJlKGUpe3JldHVybiB0aGlzLmRpc3RhbmNlU3FUb1BvaW50KGUuY2VudGVyKTw9ZS5yYWRpdXMqZS5yYWRpdXN9ZGlzdGFuY2VUb1BsYW5lKGUpe2NvbnN0IHQ9ZS5ub3JtYWwuZG90KHRoaXMuZGlyZWN0aW9uKTtpZih0PT09MClyZXR1cm4gZS5kaXN0YW5jZVRvUG9pbnQodGhpcy5vcmlnaW4pPT09MD8wOm51bGw7Y29uc3Qgbj0tKHRoaXMub3JpZ2luLmRvdChlLm5vcm1hbCkrZS5jb25zdGFudCkvdDtyZXR1cm4gbj49MD9uOm51bGx9aW50ZXJzZWN0UGxhbmUoZSx0KXtjb25zdCBuPXRoaXMuZGlzdGFuY2VUb1BsYW5lKGUpO3JldHVybiBuPT09bnVsbD9udWxsOnRoaXMuYXQobix0KX1pbnRlcnNlY3RzUGxhbmUoZSl7Y29uc3QgdD1lLmRpc3RhbmNlVG9Qb2ludCh0aGlzLm9yaWdpbik7cmV0dXJuIHQ9PT0wfHxlLm5vcm1hbC5kb3QodGhpcy5kaXJlY3Rpb24pKnQ8MH1pbnRlcnNlY3RCb3goZSx0KXtsZXQgbixyLHMsYSxvLGw7Y29uc3QgYz0xL3RoaXMuZGlyZWN0aW9uLngsdT0xL3RoaXMuZGlyZWN0aW9uLnksaD0xL3RoaXMuZGlyZWN0aW9uLnosZj10aGlzLm9yaWdpbjtyZXR1cm4gYz49MD8obj0oZS5taW4ueC1mLngpKmMscj0oZS5tYXgueC1mLngpKmMpOihuPShlLm1heC54LWYueCkqYyxyPShlLm1pbi54LWYueCkqYyksdT49MD8ocz0oZS5taW4ueS1mLnkpKnUsYT0oZS5tYXgueS1mLnkpKnUpOihzPShlLm1heC55LWYueSkqdSxhPShlLm1pbi55LWYueSkqdSksbj5hfHxzPnJ8fCgocz5ufHxpc05hTihuKSkmJihuPXMpLChhPHJ8fGlzTmFOKHIpKSYmKHI9YSksaD49MD8obz0oZS5taW4uei1mLnopKmgsbD0oZS5tYXguei1mLnopKmgpOihvPShlLm1heC56LWYueikqaCxsPShlLm1pbi56LWYueikqaCksbj5sfHxvPnIpfHwoKG8+bnx8biE9PW4pJiYobj1vKSwobDxyfHxyIT09cikmJihyPWwpLHI8MCk/bnVsbDp0aGlzLmF0KG4+PTA/bjpyLHQpfWludGVyc2VjdHNCb3goZSl7cmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KGUsV3QpIT09bnVsbH1pbnRlcnNlY3RUcmlhbmdsZShlLHQsbixyLHMpe1dpLnN1YlZlY3RvcnModCxlKSx1aS5zdWJWZWN0b3JzKG4sZSksWGkuY3Jvc3NWZWN0b3JzKFdpLHVpKTtsZXQgYT10aGlzLmRpcmVjdGlvbi5kb3QoWGkpLG87aWYoYT4wKXtpZihyKXJldHVybiBudWxsO289MX1lbHNlIGlmKGE8MClvPS0xLGE9LWE7ZWxzZSByZXR1cm4gbnVsbDt0bi5zdWJWZWN0b3JzKHRoaXMub3JpZ2luLGUpO2NvbnN0IGw9byp0aGlzLmRpcmVjdGlvbi5kb3QodWkuY3Jvc3NWZWN0b3JzKHRuLHVpKSk7aWYobDwwKXJldHVybiBudWxsO2NvbnN0IGM9byp0aGlzLmRpcmVjdGlvbi5kb3QoV2kuY3Jvc3ModG4pKTtpZihjPDB8fGwrYz5hKXJldHVybiBudWxsO2NvbnN0IHU9LW8qdG4uZG90KFhpKTtyZXR1cm4gdTwwP251bGw6dGhpcy5hdCh1L2Escyl9YXBwbHlNYXRyaXg0KGUpe3JldHVybiB0aGlzLm9yaWdpbi5hcHBseU1hdHJpeDQoZSksdGhpcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKGUpLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLm9yaWdpbi5lcXVhbHModGhpcy5vcmlnaW4pJiZlLmRpcmVjdGlvbi5lcXVhbHModGhpcy5kaXJlY3Rpb24pfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX19Y2xhc3MgcnR7Y29uc3RydWN0b3IoZSx0LG4scixzLGEsbyxsLGMsdSxoLGYscCxfLHgsbSl7cnQucHJvdG90eXBlLmlzTWF0cml4ND0hMCx0aGlzLmVsZW1lbnRzPVsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxXSxlIT09dm9pZCAwJiZ0aGlzLnNldChlLHQsbixyLHMsYSxvLGwsYyx1LGgsZixwLF8seCxtKX1zZXQoZSx0LG4scixzLGEsbyxsLGMsdSxoLGYscCxfLHgsbSl7Y29uc3QgZD10aGlzLmVsZW1lbnRzO3JldHVybiBkWzBdPWUsZFs0XT10LGRbOF09bixkWzEyXT1yLGRbMV09cyxkWzVdPWEsZFs5XT1vLGRbMTNdPWwsZFsyXT1jLGRbNl09dSxkWzEwXT1oLGRbMTRdPWYsZFszXT1wLGRbN109XyxkWzExXT14LGRbMTVdPW0sdGhpc31pZGVudGl0eSgpe3JldHVybiB0aGlzLnNldCgxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyBydCgpLmZyb21BcnJheSh0aGlzLmVsZW1lbnRzKX1jb3B5KGUpe2NvbnN0IHQ9dGhpcy5lbGVtZW50cyxuPWUuZWxlbWVudHM7cmV0dXJuIHRbMF09blswXSx0WzFdPW5bMV0sdFsyXT1uWzJdLHRbM109blszXSx0WzRdPW5bNF0sdFs1XT1uWzVdLHRbNl09bls2XSx0WzddPW5bN10sdFs4XT1uWzhdLHRbOV09bls5XSx0WzEwXT1uWzEwXSx0WzExXT1uWzExXSx0WzEyXT1uWzEyXSx0WzEzXT1uWzEzXSx0WzE0XT1uWzE0XSx0WzE1XT1uWzE1XSx0aGlzfWNvcHlQb3NpdGlvbihlKXtjb25zdCB0PXRoaXMuZWxlbWVudHMsbj1lLmVsZW1lbnRzO3JldHVybiB0WzEyXT1uWzEyXSx0WzEzXT1uWzEzXSx0WzE0XT1uWzE0XSx0aGlzfXNldEZyb21NYXRyaXgzKGUpe2NvbnN0IHQ9ZS5lbGVtZW50cztyZXR1cm4gdGhpcy5zZXQodFswXSx0WzNdLHRbNl0sMCx0WzFdLHRbNF0sdFs3XSwwLHRbMl0sdFs1XSx0WzhdLDAsMCwwLDAsMSksdGhpc31leHRyYWN0QmFzaXMoZSx0LG4pe3JldHVybiBlLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywwKSx0LnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywxKSxuLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywyKSx0aGlzfW1ha2VCYXNpcyhlLHQsbil7cmV0dXJuIHRoaXMuc2V0KGUueCx0Lngsbi54LDAsZS55LHQueSxuLnksMCxlLnosdC56LG4ueiwwLDAsMCwwLDEpLHRoaXN9ZXh0cmFjdFJvdGF0aW9uKGUpe2NvbnN0IHQ9dGhpcy5lbGVtZW50cyxuPWUuZWxlbWVudHMscj0xL1JuLnNldEZyb21NYXRyaXhDb2x1bW4oZSwwKS5sZW5ndGgoKSxzPTEvUm4uc2V0RnJvbU1hdHJpeENvbHVtbihlLDEpLmxlbmd0aCgpLGE9MS9Sbi5zZXRGcm9tTWF0cml4Q29sdW1uKGUsMikubGVuZ3RoKCk7cmV0dXJuIHRbMF09blswXSpyLHRbMV09blsxXSpyLHRbMl09blsyXSpyLHRbM109MCx0WzRdPW5bNF0qcyx0WzVdPW5bNV0qcyx0WzZdPW5bNl0qcyx0WzddPTAsdFs4XT1uWzhdKmEsdFs5XT1uWzldKmEsdFsxMF09blsxMF0qYSx0WzExXT0wLHRbMTJdPTAsdFsxM109MCx0WzE0XT0wLHRbMTVdPTEsdGhpc31tYWtlUm90YXRpb25Gcm9tRXVsZXIoZSl7Y29uc3QgdD10aGlzLmVsZW1lbnRzLG49ZS54LHI9ZS55LHM9ZS56LGE9TWF0aC5jb3Mobiksbz1NYXRoLnNpbihuKSxsPU1hdGguY29zKHIpLGM9TWF0aC5zaW4ociksdT1NYXRoLmNvcyhzKSxoPU1hdGguc2luKHMpO2lmKGUub3JkZXI9PT0iWFlaIil7Y29uc3QgZj1hKnUscD1hKmgsXz1vKnUseD1vKmg7dFswXT1sKnUsdFs0XT0tbCpoLHRbOF09Yyx0WzFdPXArXypjLHRbNV09Zi14KmMsdFs5XT0tbypsLHRbMl09eC1mKmMsdFs2XT1fK3AqYyx0WzEwXT1hKmx9ZWxzZSBpZihlLm9yZGVyPT09IllYWiIpe2NvbnN0IGY9bCp1LHA9bCpoLF89Yyp1LHg9YypoO3RbMF09Zit4Km8sdFs0XT1fKm8tcCx0WzhdPWEqYyx0WzFdPWEqaCx0WzVdPWEqdSx0WzldPS1vLHRbMl09cCpvLV8sdFs2XT14K2Yqbyx0WzEwXT1hKmx9ZWxzZSBpZihlLm9yZGVyPT09IlpYWSIpe2NvbnN0IGY9bCp1LHA9bCpoLF89Yyp1LHg9YypoO3RbMF09Zi14Km8sdFs0XT0tYSpoLHRbOF09XytwKm8sdFsxXT1wK18qbyx0WzVdPWEqdSx0WzldPXgtZipvLHRbMl09LWEqYyx0WzZdPW8sdFsxMF09YSpsfWVsc2UgaWYoZS5vcmRlcj09PSJaWVgiKXtjb25zdCBmPWEqdSxwPWEqaCxfPW8qdSx4PW8qaDt0WzBdPWwqdSx0WzRdPV8qYy1wLHRbOF09ZipjK3gsdFsxXT1sKmgsdFs1XT14KmMrZix0WzldPXAqYy1fLHRbMl09LWMsdFs2XT1vKmwsdFsxMF09YSpsfWVsc2UgaWYoZS5vcmRlcj09PSJZWlgiKXtjb25zdCBmPWEqbCxwPWEqYyxfPW8qbCx4PW8qYzt0WzBdPWwqdSx0WzRdPXgtZipoLHRbOF09XypoK3AsdFsxXT1oLHRbNV09YSp1LHRbOV09LW8qdSx0WzJdPS1jKnUsdFs2XT1wKmgrXyx0WzEwXT1mLXgqaH1lbHNlIGlmKGUub3JkZXI9PT0iWFpZIil7Y29uc3QgZj1hKmwscD1hKmMsXz1vKmwseD1vKmM7dFswXT1sKnUsdFs0XT0taCx0WzhdPWMqdSx0WzFdPWYqaCt4LHRbNV09YSp1LHRbOV09cCpoLV8sdFsyXT1fKmgtcCx0WzZdPW8qdSx0WzEwXT14KmgrZn1yZXR1cm4gdFszXT0wLHRbN109MCx0WzExXT0wLHRbMTJdPTAsdFsxM109MCx0WzE0XT0wLHRbMTVdPTEsdGhpc31tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihlKXtyZXR1cm4gdGhpcy5jb21wb3NlKHZhLGUseGEpfWxvb2tBdChlLHQsbil7Y29uc3Qgcj10aGlzLmVsZW1lbnRzO3JldHVybiB5dC5zdWJWZWN0b3JzKGUsdCkseXQubGVuZ3RoU3EoKT09PTAmJih5dC56PTEpLHl0Lm5vcm1hbGl6ZSgpLG5uLmNyb3NzVmVjdG9ycyhuLHl0KSxubi5sZW5ndGhTcSgpPT09MCYmKE1hdGguYWJzKG4ueik9PT0xP3l0LngrPTFlLTQ6eXQueis9MWUtNCx5dC5ub3JtYWxpemUoKSxubi5jcm9zc1ZlY3RvcnMobix5dCkpLG5uLm5vcm1hbGl6ZSgpLGhpLmNyb3NzVmVjdG9ycyh5dCxubiksclswXT1ubi54LHJbNF09aGkueCxyWzhdPXl0LngsclsxXT1ubi55LHJbNV09aGkueSxyWzldPXl0LnksclsyXT1ubi56LHJbNl09aGkueixyWzEwXT15dC56LHRoaXN9bXVsdGlwbHkoZSl7cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyh0aGlzLGUpfXByZW11bHRpcGx5KGUpe3JldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoZSx0aGlzKX1tdWx0aXBseU1hdHJpY2VzKGUsdCl7Y29uc3Qgbj1lLmVsZW1lbnRzLHI9dC5lbGVtZW50cyxzPXRoaXMuZWxlbWVudHMsYT1uWzBdLG89bls0XSxsPW5bOF0sYz1uWzEyXSx1PW5bMV0saD1uWzVdLGY9bls5XSxwPW5bMTNdLF89blsyXSx4PW5bNl0sbT1uWzEwXSxkPW5bMTRdLEE9blszXSxUPW5bN10sTT1uWzExXSxGPW5bMTVdLGI9clswXSx3PXJbNF0sVT1yWzhdLEU9clsxMl0sUz1yWzFdLFI9cls1XSxxPXJbOV0sej1yWzEzXSxXPXJbMl0sSz1yWzZdLFY9clsxMF0sUT1yWzE0XSxIPXJbM10saWU9cls3XSxjZT1yWzExXSx4ZT1yWzE1XTtyZXR1cm4gc1swXT1hKmIrbypTK2wqVytjKkgsc1s0XT1hKncrbypSK2wqSytjKmllLHNbOF09YSpVK28qcStsKlYrYypjZSxzWzEyXT1hKkUrbyp6K2wqUStjKnhlLHNbMV09dSpiK2gqUytmKlcrcCpILHNbNV09dSp3K2gqUitmKksrcCppZSxzWzldPXUqVStoKnErZipWK3AqY2Usc1sxM109dSpFK2gqeitmKlErcCp4ZSxzWzJdPV8qYit4KlMrbSpXK2QqSCxzWzZdPV8qdyt4KlIrbSpLK2QqaWUsc1sxMF09XypVK3gqcSttKlYrZCpjZSxzWzE0XT1fKkUreCp6K20qUStkKnhlLHNbM109QSpiK1QqUytNKlcrRipILHNbN109QSp3K1QqUitNKksrRippZSxzWzExXT1BKlUrVCpxK00qVitGKmNlLHNbMTVdPUEqRStUKnorTSpRK0YqeGUsdGhpc31tdWx0aXBseVNjYWxhcihlKXtjb25zdCB0PXRoaXMuZWxlbWVudHM7cmV0dXJuIHRbMF0qPWUsdFs0XSo9ZSx0WzhdKj1lLHRbMTJdKj1lLHRbMV0qPWUsdFs1XSo9ZSx0WzldKj1lLHRbMTNdKj1lLHRbMl0qPWUsdFs2XSo9ZSx0WzEwXSo9ZSx0WzE0XSo9ZSx0WzNdKj1lLHRbN10qPWUsdFsxMV0qPWUsdFsxNV0qPWUsdGhpc31kZXRlcm1pbmFudCgpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyx0PWVbMF0sbj1lWzRdLHI9ZVs4XSxzPWVbMTJdLGE9ZVsxXSxvPWVbNV0sbD1lWzldLGM9ZVsxM10sdT1lWzJdLGg9ZVs2XSxmPWVbMTBdLHA9ZVsxNF0sXz1lWzNdLHg9ZVs3XSxtPWVbMTFdLGQ9ZVsxNV07cmV0dXJuIF8qKCtzKmwqaC1yKmMqaC1zKm8qZituKmMqZityKm8qcC1uKmwqcCkreCooK3QqbCpwLXQqYypmK3MqYSpmLXIqYSpwK3IqYyp1LXMqbCp1KSttKigrdCpjKmgtdCpvKnAtcyphKmgrbiphKnArcypvKnUtbipjKnUpK2QqKC1yKm8qdS10KmwqaCt0Km8qZityKmEqaC1uKmEqZituKmwqdSl9dHJhbnNwb3NlKCl7Y29uc3QgZT10aGlzLmVsZW1lbnRzO2xldCB0O3JldHVybiB0PWVbMV0sZVsxXT1lWzRdLGVbNF09dCx0PWVbMl0sZVsyXT1lWzhdLGVbOF09dCx0PWVbNl0sZVs2XT1lWzldLGVbOV09dCx0PWVbM10sZVszXT1lWzEyXSxlWzEyXT10LHQ9ZVs3XSxlWzddPWVbMTNdLGVbMTNdPXQsdD1lWzExXSxlWzExXT1lWzE0XSxlWzE0XT10LHRoaXN9c2V0UG9zaXRpb24oZSx0LG4pe2NvbnN0IHI9dGhpcy5lbGVtZW50cztyZXR1cm4gZS5pc1ZlY3RvcjM/KHJbMTJdPWUueCxyWzEzXT1lLnksclsxNF09ZS56KTooclsxMl09ZSxyWzEzXT10LHJbMTRdPW4pLHRoaXN9aW52ZXJ0KCl7Y29uc3QgZT10aGlzLmVsZW1lbnRzLHQ9ZVswXSxuPWVbMV0scj1lWzJdLHM9ZVszXSxhPWVbNF0sbz1lWzVdLGw9ZVs2XSxjPWVbN10sdT1lWzhdLGg9ZVs5XSxmPWVbMTBdLHA9ZVsxMV0sXz1lWzEyXSx4PWVbMTNdLG09ZVsxNF0sZD1lWzE1XSxBPWgqbSpjLXgqZipjK3gqbCpwLW8qbSpwLWgqbCpkK28qZipkLFQ9XypmKmMtdSptKmMtXypsKnArYSptKnArdSpsKmQtYSpmKmQsTT11KngqYy1fKmgqYytfKm8qcC1hKngqcC11Km8qZCthKmgqZCxGPV8qaCpsLXUqeCpsLV8qbypmK2EqeCpmK3UqbyptLWEqaCptLGI9dCpBK24qVCtyKk0rcypGO2lmKGI9PT0wKXJldHVybiB0aGlzLnNldCgwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwKTtjb25zdCB3PTEvYjtyZXR1cm4gZVswXT1BKncsZVsxXT0oeCpmKnMtaCptKnMteCpyKnArbiptKnAraCpyKmQtbipmKmQpKncsZVsyXT0obyptKnMteCpsKnMreCpyKmMtbiptKmMtbypyKmQrbipsKmQpKncsZVszXT0oaCpsKnMtbypmKnMtaCpyKmMrbipmKmMrbypyKnAtbipsKnApKncsZVs0XT1UKncsZVs1XT0odSptKnMtXypmKnMrXypyKnAtdCptKnAtdSpyKmQrdCpmKmQpKncsZVs2XT0oXypsKnMtYSptKnMtXypyKmMrdCptKmMrYSpyKmQtdCpsKmQpKncsZVs3XT0oYSpmKnMtdSpsKnMrdSpyKmMtdCpmKmMtYSpyKnArdCpsKnApKncsZVs4XT1NKncsZVs5XT0oXypoKnMtdSp4KnMtXypuKnArdCp4KnArdSpuKmQtdCpoKmQpKncsZVsxMF09KGEqeCpzLV8qbypzK18qbipjLXQqeCpjLWEqbipkK3QqbypkKSp3LGVbMTFdPSh1Km8qcy1hKmgqcy11Km4qYyt0KmgqYythKm4qcC10Km8qcCkqdyxlWzEyXT1GKncsZVsxM109KHUqeCpyLV8qaCpyK18qbipmLXQqeCpmLXUqbiptK3QqaCptKSp3LGVbMTRdPShfKm8qci1hKngqci1fKm4qbCt0KngqbCthKm4qbS10Km8qbSkqdyxlWzE1XT0oYSpoKnItdSpvKnIrdSpuKmwtdCpoKmwtYSpuKmYrdCpvKmYpKncsdGhpc31zY2FsZShlKXtjb25zdCB0PXRoaXMuZWxlbWVudHMsbj1lLngscj1lLnkscz1lLno7cmV0dXJuIHRbMF0qPW4sdFs0XSo9cix0WzhdKj1zLHRbMV0qPW4sdFs1XSo9cix0WzldKj1zLHRbMl0qPW4sdFs2XSo9cix0WzEwXSo9cyx0WzNdKj1uLHRbN10qPXIsdFsxMV0qPXMsdGhpc31nZXRNYXhTY2FsZU9uQXhpcygpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyx0PWVbMF0qZVswXStlWzFdKmVbMV0rZVsyXSplWzJdLG49ZVs0XSplWzRdK2VbNV0qZVs1XStlWzZdKmVbNl0scj1lWzhdKmVbOF0rZVs5XSplWzldK2VbMTBdKmVbMTBdO3JldHVybiBNYXRoLnNxcnQoTWF0aC5tYXgodCxuLHIpKX1tYWtlVHJhbnNsYXRpb24oZSx0LG4pe3JldHVybiBlLmlzVmVjdG9yMz90aGlzLnNldCgxLDAsMCxlLngsMCwxLDAsZS55LDAsMCwxLGUueiwwLDAsMCwxKTp0aGlzLnNldCgxLDAsMCxlLDAsMSwwLHQsMCwwLDEsbiwwLDAsMCwxKSx0aGlzfW1ha2VSb3RhdGlvblgoZSl7Y29uc3QgdD1NYXRoLmNvcyhlKSxuPU1hdGguc2luKGUpO3JldHVybiB0aGlzLnNldCgxLDAsMCwwLDAsdCwtbiwwLDAsbix0LDAsMCwwLDAsMSksdGhpc31tYWtlUm90YXRpb25ZKGUpe2NvbnN0IHQ9TWF0aC5jb3MoZSksbj1NYXRoLnNpbihlKTtyZXR1cm4gdGhpcy5zZXQodCwwLG4sMCwwLDEsMCwwLC1uLDAsdCwwLDAsMCwwLDEpLHRoaXN9bWFrZVJvdGF0aW9uWihlKXtjb25zdCB0PU1hdGguY29zKGUpLG49TWF0aC5zaW4oZSk7cmV0dXJuIHRoaXMuc2V0KHQsLW4sMCwwLG4sdCwwLDAsMCwwLDEsMCwwLDAsMCwxKSx0aGlzfW1ha2VSb3RhdGlvbkF4aXMoZSx0KXtjb25zdCBuPU1hdGguY29zKHQpLHI9TWF0aC5zaW4odCkscz0xLW4sYT1lLngsbz1lLnksbD1lLnosYz1zKmEsdT1zKm87cmV0dXJuIHRoaXMuc2V0KGMqYStuLGMqby1yKmwsYypsK3IqbywwLGMqbytyKmwsdSpvK24sdSpsLXIqYSwwLGMqbC1yKm8sdSpsK3IqYSxzKmwqbCtuLDAsMCwwLDAsMSksdGhpc31tYWtlU2NhbGUoZSx0LG4pe3JldHVybiB0aGlzLnNldChlLDAsMCwwLDAsdCwwLDAsMCwwLG4sMCwwLDAsMCwxKSx0aGlzfW1ha2VTaGVhcihlLHQsbixyLHMsYSl7cmV0dXJuIHRoaXMuc2V0KDEsbixzLDAsZSwxLGEsMCx0LHIsMSwwLDAsMCwwLDEpLHRoaXN9Y29tcG9zZShlLHQsbil7Y29uc3Qgcj10aGlzLmVsZW1lbnRzLHM9dC5feCxhPXQuX3ksbz10Ll96LGw9dC5fdyxjPXMrcyx1PWErYSxoPW8rbyxmPXMqYyxwPXMqdSxfPXMqaCx4PWEqdSxtPWEqaCxkPW8qaCxBPWwqYyxUPWwqdSxNPWwqaCxGPW4ueCxiPW4ueSx3PW4uejtyZXR1cm4gclswXT0oMS0oeCtkKSkqRixyWzFdPShwK00pKkYsclsyXT0oXy1UKSpGLHJbM109MCxyWzRdPShwLU0pKmIscls1XT0oMS0oZitkKSkqYixyWzZdPShtK0EpKmIscls3XT0wLHJbOF09KF8rVCkqdyxyWzldPShtLUEpKncsclsxMF09KDEtKGYreCkpKncsclsxMV09MCxyWzEyXT1lLngsclsxM109ZS55LHJbMTRdPWUueixyWzE1XT0xLHRoaXN9ZGVjb21wb3NlKGUsdCxuKXtjb25zdCByPXRoaXMuZWxlbWVudHM7bGV0IHM9Um4uc2V0KHJbMF0sclsxXSxyWzJdKS5sZW5ndGgoKTtjb25zdCBhPVJuLnNldChyWzRdLHJbNV0scls2XSkubGVuZ3RoKCksbz1Sbi5zZXQocls4XSxyWzldLHJbMTBdKS5sZW5ndGgoKTt0aGlzLmRldGVybWluYW50KCk8MCYmKHM9LXMpLGUueD1yWzEyXSxlLnk9clsxM10sZS56PXJbMTRdLFV0LmNvcHkodGhpcyk7Y29uc3QgYz0xL3MsdT0xL2EsaD0xL287cmV0dXJuIFV0LmVsZW1lbnRzWzBdKj1jLFV0LmVsZW1lbnRzWzFdKj1jLFV0LmVsZW1lbnRzWzJdKj1jLFV0LmVsZW1lbnRzWzRdKj11LFV0LmVsZW1lbnRzWzVdKj11LFV0LmVsZW1lbnRzWzZdKj11LFV0LmVsZW1lbnRzWzhdKj1oLFV0LmVsZW1lbnRzWzldKj1oLFV0LmVsZW1lbnRzWzEwXSo9aCx0LnNldEZyb21Sb3RhdGlvbk1hdHJpeChVdCksbi54PXMsbi55PWEsbi56PW8sdGhpc31tYWtlUGVyc3BlY3RpdmUoZSx0LG4scixzLGEsbz0yZTMpe2NvbnN0IGw9dGhpcy5lbGVtZW50cyxjPTIqcy8odC1lKSx1PTIqcy8obi1yKSxoPSh0K2UpLyh0LWUpLGY9KG4rcikvKG4tcik7bGV0IHAsXztpZihvPT09MmUzKXA9LShhK3MpLyhhLXMpLF89LTIqYSpzLyhhLXMpO2Vsc2UgaWYobz09PTIwMDEpcD0tYS8oYS1zKSxfPS1hKnMvKGEtcyk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLk1hdHJpeDQubWFrZVBlcnNwZWN0aXZlKCk6IEludmFsaWQgY29vcmRpbmF0ZSBzeXN0ZW06ICIrbyk7cmV0dXJuIGxbMF09YyxsWzRdPTAsbFs4XT1oLGxbMTJdPTAsbFsxXT0wLGxbNV09dSxsWzldPWYsbFsxM109MCxsWzJdPTAsbFs2XT0wLGxbMTBdPXAsbFsxNF09XyxsWzNdPTAsbFs3XT0wLGxbMTFdPS0xLGxbMTVdPTAsdGhpc31tYWtlT3J0aG9ncmFwaGljKGUsdCxuLHIscyxhLG89MmUzKXtjb25zdCBsPXRoaXMuZWxlbWVudHMsYz0xLyh0LWUpLHU9MS8obi1yKSxoPTEvKGEtcyksZj0odCtlKSpjLHA9KG4rcikqdTtsZXQgXyx4O2lmKG89PT0yZTMpXz0oYStzKSpoLHg9LTIqaDtlbHNlIGlmKG89PT0yMDAxKV89cypoLHg9LTEqaDtlbHNlIHRocm93IG5ldyBFcnJvcigiVEhSRUUuTWF0cml4NC5tYWtlT3J0aG9ncmFwaGljKCk6IEludmFsaWQgY29vcmRpbmF0ZSBzeXN0ZW06ICIrbyk7cmV0dXJuIGxbMF09MipjLGxbNF09MCxsWzhdPTAsbFsxMl09LWYsbFsxXT0wLGxbNV09Mip1LGxbOV09MCxsWzEzXT0tcCxsWzJdPTAsbFs2XT0wLGxbMTBdPXgsbFsxNF09LV8sbFszXT0wLGxbN109MCxsWzExXT0wLGxbMTVdPTEsdGhpc31lcXVhbHMoZSl7Y29uc3QgdD10aGlzLmVsZW1lbnRzLG49ZS5lbGVtZW50cztmb3IobGV0IHI9MDtyPDE2O3IrKylpZih0W3JdIT09bltyXSlyZXR1cm4hMTtyZXR1cm4hMH1mcm9tQXJyYXkoZSx0PTApe2ZvcihsZXQgbj0wO248MTY7bisrKXRoaXMuZWxlbWVudHNbbl09ZVtuK3RdO3JldHVybiB0aGlzfXRvQXJyYXkoZT1bXSx0PTApe2NvbnN0IG49dGhpcy5lbGVtZW50cztyZXR1cm4gZVt0XT1uWzBdLGVbdCsxXT1uWzFdLGVbdCsyXT1uWzJdLGVbdCszXT1uWzNdLGVbdCs0XT1uWzRdLGVbdCs1XT1uWzVdLGVbdCs2XT1uWzZdLGVbdCs3XT1uWzddLGVbdCs4XT1uWzhdLGVbdCs5XT1uWzldLGVbdCsxMF09blsxMF0sZVt0KzExXT1uWzExXSxlW3QrMTJdPW5bMTJdLGVbdCsxM109blsxM10sZVt0KzE0XT1uWzE0XSxlW3QrMTVdPW5bMTVdLGV9fWNvbnN0IFJuPW5ldyBCLFV0PW5ldyBydCx2YT1uZXcgQigwLDAsMCkseGE9bmV3IEIoMSwxLDEpLG5uPW5ldyBCLGhpPW5ldyBCLHl0PW5ldyBCLExyPW5ldyBydCxVcj1uZXcgWG47Y2xhc3MgWHR7Y29uc3RydWN0b3IoZT0wLHQ9MCxuPTAscj1YdC5ERUZBVUxUX09SREVSKXt0aGlzLmlzRXVsZXI9ITAsdGhpcy5feD1lLHRoaXMuX3k9dCx0aGlzLl96PW4sdGhpcy5fb3JkZXI9cn1nZXQgeCgpe3JldHVybiB0aGlzLl94fXNldCB4KGUpe3RoaXMuX3g9ZSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9Z2V0IHkoKXtyZXR1cm4gdGhpcy5feX1zZXQgeShlKXt0aGlzLl95PWUsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfWdldCB6KCl7cmV0dXJuIHRoaXMuX3p9c2V0IHooZSl7dGhpcy5fej1lLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKX1nZXQgb3JkZXIoKXtyZXR1cm4gdGhpcy5fb3JkZXJ9c2V0IG9yZGVyKGUpe3RoaXMuX29yZGVyPWUsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfXNldChlLHQsbixyPXRoaXMuX29yZGVyKXtyZXR1cm4gdGhpcy5feD1lLHRoaXMuX3k9dCx0aGlzLl96PW4sdGhpcy5fb3JkZXI9cix0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLl94LHRoaXMuX3ksdGhpcy5feix0aGlzLl9vcmRlcil9Y29weShlKXtyZXR1cm4gdGhpcy5feD1lLl94LHRoaXMuX3k9ZS5feSx0aGlzLl96PWUuX3osdGhpcy5fb3JkZXI9ZS5fb3JkZXIsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVJvdGF0aW9uTWF0cml4KGUsdD10aGlzLl9vcmRlcixuPSEwKXtjb25zdCByPWUuZWxlbWVudHMscz1yWzBdLGE9cls0XSxvPXJbOF0sbD1yWzFdLGM9cls1XSx1PXJbOV0saD1yWzJdLGY9cls2XSxwPXJbMTBdO3N3aXRjaCh0KXtjYXNlIlhZWiI6dGhpcy5feT1NYXRoLmFzaW4oX3QobywtMSwxKSksTWF0aC5hYnMobyk8Ljk5OTk5OTk/KHRoaXMuX3g9TWF0aC5hdGFuMigtdSxwKSx0aGlzLl96PU1hdGguYXRhbjIoLWEscykpOih0aGlzLl94PU1hdGguYXRhbjIoZixjKSx0aGlzLl96PTApO2JyZWFrO2Nhc2UiWVhaIjp0aGlzLl94PU1hdGguYXNpbigtX3QodSwtMSwxKSksTWF0aC5hYnModSk8Ljk5OTk5OTk/KHRoaXMuX3k9TWF0aC5hdGFuMihvLHApLHRoaXMuX3o9TWF0aC5hdGFuMihsLGMpKToodGhpcy5feT1NYXRoLmF0YW4yKC1oLHMpLHRoaXMuX3o9MCk7YnJlYWs7Y2FzZSJaWFkiOnRoaXMuX3g9TWF0aC5hc2luKF90KGYsLTEsMSkpLE1hdGguYWJzKGYpPC45OTk5OTk5Pyh0aGlzLl95PU1hdGguYXRhbjIoLWgscCksdGhpcy5fej1NYXRoLmF0YW4yKC1hLGMpKToodGhpcy5feT0wLHRoaXMuX3o9TWF0aC5hdGFuMihsLHMpKTticmVhaztjYXNlIlpZWCI6dGhpcy5feT1NYXRoLmFzaW4oLV90KGgsLTEsMSkpLE1hdGguYWJzKGgpPC45OTk5OTk5Pyh0aGlzLl94PU1hdGguYXRhbjIoZixwKSx0aGlzLl96PU1hdGguYXRhbjIobCxzKSk6KHRoaXMuX3g9MCx0aGlzLl96PU1hdGguYXRhbjIoLWEsYykpO2JyZWFrO2Nhc2UiWVpYIjp0aGlzLl96PU1hdGguYXNpbihfdChsLC0xLDEpKSxNYXRoLmFicyhsKTwuOTk5OTk5OT8odGhpcy5feD1NYXRoLmF0YW4yKC11LGMpLHRoaXMuX3k9TWF0aC5hdGFuMigtaCxzKSk6KHRoaXMuX3g9MCx0aGlzLl95PU1hdGguYXRhbjIobyxwKSk7YnJlYWs7Y2FzZSJYWlkiOnRoaXMuX3o9TWF0aC5hc2luKC1fdChhLC0xLDEpKSxNYXRoLmFicyhhKTwuOTk5OTk5OT8odGhpcy5feD1NYXRoLmF0YW4yKGYsYyksdGhpcy5feT1NYXRoLmF0YW4yKG8scykpOih0aGlzLl94PU1hdGguYXRhbjIoLXUscCksdGhpcy5feT0wKTticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybigiVEhSRUUuRXVsZXI6IC5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAiK3QpfXJldHVybiB0aGlzLl9vcmRlcj10LG49PT0hMCYmdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVF1YXRlcm5pb24oZSx0LG4pe3JldHVybiBMci5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihlKSx0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeChMcix0LG4pfXNldEZyb21WZWN0b3IzKGUsdD10aGlzLl9vcmRlcil7cmV0dXJuIHRoaXMuc2V0KGUueCxlLnksZS56LHQpfXJlb3JkZXIoZSl7cmV0dXJuIFVyLnNldEZyb21FdWxlcih0aGlzKSx0aGlzLnNldEZyb21RdWF0ZXJuaW9uKFVyLGUpfWVxdWFscyhlKXtyZXR1cm4gZS5feD09PXRoaXMuX3gmJmUuX3k9PT10aGlzLl95JiZlLl96PT09dGhpcy5feiYmZS5fb3JkZXI9PT10aGlzLl9vcmRlcn1mcm9tQXJyYXkoZSl7cmV0dXJuIHRoaXMuX3g9ZVswXSx0aGlzLl95PWVbMV0sdGhpcy5fej1lWzJdLGVbM10hPT12b2lkIDAmJih0aGlzLl9vcmRlcj1lWzNdKSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc310b0FycmF5KGU9W10sdD0wKXtyZXR1cm4gZVt0XT10aGlzLl94LGVbdCsxXT10aGlzLl95LGVbdCsyXT10aGlzLl96LGVbdCszXT10aGlzLl9vcmRlcixlfV9vbkNoYW5nZShlKXtyZXR1cm4gdGhpcy5fb25DaGFuZ2VDYWxsYmFjaz1lLHRoaXN9X29uQ2hhbmdlQ2FsbGJhY2soKXt9KltTeW1ib2wuaXRlcmF0b3JdKCl7eWllbGQgdGhpcy5feCx5aWVsZCB0aGlzLl95LHlpZWxkIHRoaXMuX3oseWllbGQgdGhpcy5fb3JkZXJ9fVh0LkRFRkFVTFRfT1JERVI9IlhZWiI7Y2xhc3MgRnJ7Y29uc3RydWN0b3IoKXt0aGlzLm1hc2s9MX1zZXQoZSl7dGhpcy5tYXNrPSgxPDxlfDApPj4+MH1lbmFibGUoZSl7dGhpcy5tYXNrfD0xPDxlfDB9ZW5hYmxlQWxsKCl7dGhpcy5tYXNrPS0xfXRvZ2dsZShlKXt0aGlzLm1hc2tePTE8PGV8MH1kaXNhYmxlKGUpe3RoaXMubWFzayY9figxPDxlfDApfWRpc2FibGVBbGwoKXt0aGlzLm1hc2s9MH10ZXN0KGUpe3JldHVybih0aGlzLm1hc2smZS5tYXNrKSE9PTB9aXNFbmFibGVkKGUpe3JldHVybih0aGlzLm1hc2smKDE8PGV8MCkpIT09MH19bGV0IE1hPTA7Y29uc3QgSXI9bmV3IEIsQ249bmV3IFhuLHF0PW5ldyBydCxkaT1uZXcgQixabj1uZXcgQixTYT1uZXcgQixFYT1uZXcgWG4sTnI9bmV3IEIoMSwwLDApLE9yPW5ldyBCKDAsMSwwKSxCcj1uZXcgQigwLDAsMSksenI9e3R5cGU6ImFkZGVkIn0seWE9e3R5cGU6InJlbW92ZWQifSxQbj17dHlwZToiY2hpbGRhZGRlZCIsY2hpbGQ6bnVsbH0scWk9e3R5cGU6ImNoaWxkcmVtb3ZlZCIsY2hpbGQ6bnVsbH07Y2xhc3MgTXQgZXh0ZW5kcyBNbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5pc09iamVjdDNEPSEwLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJpZCIse3ZhbHVlOk1hKyt9KSx0aGlzLnV1aWQ9U24oKSx0aGlzLm5hbWU9IiIsdGhpcy50eXBlPSJPYmplY3QzRCIsdGhpcy5wYXJlbnQ9bnVsbCx0aGlzLmNoaWxkcmVuPVtdLHRoaXMudXA9TXQuREVGQVVMVF9VUC5jbG9uZSgpO2NvbnN0IGU9bmV3IEIsdD1uZXcgWHQsbj1uZXcgWG4scj1uZXcgQigxLDEsMSk7ZnVuY3Rpb24gcygpe24uc2V0RnJvbUV1bGVyKHQsITEpfWZ1bmN0aW9uIGEoKXt0LnNldEZyb21RdWF0ZXJuaW9uKG4sdm9pZCAwLCExKX10Ll9vbkNoYW5nZShzKSxuLl9vbkNoYW5nZShhKSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLHtwb3NpdGlvbjp7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6ZX0scm90YXRpb246e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOnR9LHF1YXRlcm5pb246e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOm59LHNjYWxlOntjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTpyfSxtb2RlbFZpZXdNYXRyaXg6e3ZhbHVlOm5ldyBydH0sbm9ybWFsTWF0cml4Ont2YWx1ZTpuZXcgd2V9fSksdGhpcy5tYXRyaXg9bmV3IHJ0LHRoaXMubWF0cml4V29ybGQ9bmV3IHJ0LHRoaXMubWF0cml4QXV0b1VwZGF0ZT1NdC5ERUZBVUxUX01BVFJJWF9BVVRPX1VQREFURSx0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZT1NdC5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURSx0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITEsdGhpcy5sYXllcnM9bmV3IEZyLHRoaXMudmlzaWJsZT0hMCx0aGlzLmNhc3RTaGFkb3c9ITEsdGhpcy5yZWNlaXZlU2hhZG93PSExLHRoaXMuZnJ1c3R1bUN1bGxlZD0hMCx0aGlzLnJlbmRlck9yZGVyPTAsdGhpcy5hbmltYXRpb25zPVtdLHRoaXMudXNlckRhdGE9e319b25CZWZvcmVTaGFkb3coKXt9b25BZnRlclNoYWRvdygpe31vbkJlZm9yZVJlbmRlcigpe31vbkFmdGVyUmVuZGVyKCl7fWFwcGx5TWF0cml4NChlKXt0aGlzLm1hdHJpeEF1dG9VcGRhdGUmJnRoaXMudXBkYXRlTWF0cml4KCksdGhpcy5tYXRyaXgucHJlbXVsdGlwbHkoZSksdGhpcy5tYXRyaXguZGVjb21wb3NlKHRoaXMucG9zaXRpb24sdGhpcy5xdWF0ZXJuaW9uLHRoaXMuc2NhbGUpfWFwcGx5UXVhdGVybmlvbihlKXtyZXR1cm4gdGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KGUpLHRoaXN9c2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlKGUsdCl7dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoZSx0KX1zZXRSb3RhdGlvbkZyb21FdWxlcihlKXt0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKGUsITApfXNldFJvdGF0aW9uRnJvbU1hdHJpeChlKXt0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KGUpfXNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oZSl7dGhpcy5xdWF0ZXJuaW9uLmNvcHkoZSl9cm90YXRlT25BeGlzKGUsdCl7cmV0dXJuIENuLnNldEZyb21BeGlzQW5nbGUoZSx0KSx0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkoQ24pLHRoaXN9cm90YXRlT25Xb3JsZEF4aXMoZSx0KXtyZXR1cm4gQ24uc2V0RnJvbUF4aXNBbmdsZShlLHQpLHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseShDbiksdGhpc31yb3RhdGVYKGUpe3JldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhOcixlKX1yb3RhdGVZKGUpe3JldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhPcixlKX1yb3RhdGVaKGUpe3JldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhCcixlKX10cmFuc2xhdGVPbkF4aXMoZSx0KXtyZXR1cm4gSXIuY29weShlKS5hcHBseVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKSx0aGlzLnBvc2l0aW9uLmFkZChJci5tdWx0aXBseVNjYWxhcih0KSksdGhpc310cmFuc2xhdGVYKGUpe3JldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhOcixlKX10cmFuc2xhdGVZKGUpe3JldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhPcixlKX10cmFuc2xhdGVaKGUpe3JldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhCcixlKX1sb2NhbFRvV29ybGQoZSl7cmV0dXJuIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLGUuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpfXdvcmxkVG9Mb2NhbChlKXtyZXR1cm4gdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksZS5hcHBseU1hdHJpeDQocXQuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKSl9bG9va0F0KGUsdCxuKXtlLmlzVmVjdG9yMz9kaS5jb3B5KGUpOmRpLnNldChlLHQsbik7Y29uc3Qgcj10aGlzLnBhcmVudDt0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxabi5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5tYXRyaXhXb3JsZCksdGhpcy5pc0NhbWVyYXx8dGhpcy5pc0xpZ2h0P3F0Lmxvb2tBdChabixkaSx0aGlzLnVwKTpxdC5sb29rQXQoZGksWm4sdGhpcy51cCksdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChxdCksciYmKHF0LmV4dHJhY3RSb3RhdGlvbihyLm1hdHJpeFdvcmxkKSxDbi5zZXRGcm9tUm90YXRpb25NYXRyaXgocXQpLHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseShDbi5pbnZlcnQoKSkpfWFkZChlKXtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2ZvcihsZXQgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspdGhpcy5hZGQoYXJndW1lbnRzW3RdKTtyZXR1cm4gdGhpc31yZXR1cm4gZT09PXRoaXM/KGNvbnNvbGUuZXJyb3IoIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhbid0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLiIsZSksdGhpcyk6KGUmJmUuaXNPYmplY3QzRD8oZS5yZW1vdmVGcm9tUGFyZW50KCksZS5wYXJlbnQ9dGhpcyx0aGlzLmNoaWxkcmVuLnB1c2goZSksZS5kaXNwYXRjaEV2ZW50KHpyKSxQbi5jaGlsZD1lLHRoaXMuZGlzcGF0Y2hFdmVudChQbiksUG4uY2hpbGQ9bnVsbCk6Y29uc29sZS5lcnJvcigiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3Qgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk9iamVjdDNELiIsZSksdGhpcyl9cmVtb3ZlKGUpe2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKGxldCBuPTA7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl0aGlzLnJlbW92ZShhcmd1bWVudHNbbl0pO3JldHVybiB0aGlzfWNvbnN0IHQ9dGhpcy5jaGlsZHJlbi5pbmRleE9mKGUpO3JldHVybiB0IT09LTEmJihlLnBhcmVudD1udWxsLHRoaXMuY2hpbGRyZW4uc3BsaWNlKHQsMSksZS5kaXNwYXRjaEV2ZW50KHlhKSxxaS5jaGlsZD1lLHRoaXMuZGlzcGF0Y2hFdmVudChxaSkscWkuY2hpbGQ9bnVsbCksdGhpc31yZW1vdmVGcm9tUGFyZW50KCl7Y29uc3QgZT10aGlzLnBhcmVudDtyZXR1cm4gZSE9PW51bGwmJmUucmVtb3ZlKHRoaXMpLHRoaXN9Y2xlYXIoKXtyZXR1cm4gdGhpcy5yZW1vdmUoLi4udGhpcy5jaGlsZHJlbil9YXR0YWNoKGUpe3JldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxxdC5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpLGUucGFyZW50IT09bnVsbCYmKGUucGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxxdC5tdWx0aXBseShlLnBhcmVudC5tYXRyaXhXb3JsZCkpLGUuYXBwbHlNYXRyaXg0KHF0KSxlLnJlbW92ZUZyb21QYXJlbnQoKSxlLnBhcmVudD10aGlzLHRoaXMuY2hpbGRyZW4ucHVzaChlKSxlLnVwZGF0ZVdvcmxkTWF0cml4KCExLCEwKSxlLmRpc3BhdGNoRXZlbnQoenIpLFBuLmNoaWxkPWUsdGhpcy5kaXNwYXRjaEV2ZW50KFBuKSxQbi5jaGlsZD1udWxsLHRoaXN9Z2V0T2JqZWN0QnlJZChlKXtyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCJpZCIsZSl9Z2V0T2JqZWN0QnlOYW1lKGUpe3JldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoIm5hbWUiLGUpfWdldE9iamVjdEJ5UHJvcGVydHkoZSx0KXtpZih0aGlzW2VdPT09dClyZXR1cm4gdGhpcztmb3IobGV0IG49MCxyPXRoaXMuY2hpbGRyZW4ubGVuZ3RoO248cjtuKyspe2NvbnN0IGE9dGhpcy5jaGlsZHJlbltuXS5nZXRPYmplY3RCeVByb3BlcnR5KGUsdCk7aWYoYSE9PXZvaWQgMClyZXR1cm4gYX19Z2V0T2JqZWN0c0J5UHJvcGVydHkoZSx0LG49W10pe3RoaXNbZV09PT10JiZuLnB1c2godGhpcyk7Y29uc3Qgcj10aGlzLmNoaWxkcmVuO2ZvcihsZXQgcz0wLGE9ci5sZW5ndGg7czxhO3MrKylyW3NdLmdldE9iamVjdHNCeVByb3BlcnR5KGUsdCxuKTtyZXR1cm4gbn1nZXRXb3JsZFBvc2l0aW9uKGUpe3JldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxlLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1hdHJpeFdvcmxkKX1nZXRXb3JsZFF1YXRlcm5pb24oZSl7cmV0dXJuIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKFpuLGUsU2EpLGV9Z2V0V29ybGRTY2FsZShlKXtyZXR1cm4gdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoWm4sRWEsZSksZX1nZXRXb3JsZERpcmVjdGlvbihlKXt0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKTtjb25zdCB0PXRoaXMubWF0cml4V29ybGQuZWxlbWVudHM7cmV0dXJuIGUuc2V0KHRbOF0sdFs5XSx0WzEwXSkubm9ybWFsaXplKCl9cmF5Y2FzdCgpe310cmF2ZXJzZShlKXtlKHRoaXMpO2NvbnN0IHQ9dGhpcy5jaGlsZHJlbjtmb3IobGV0IG49MCxyPXQubGVuZ3RoO248cjtuKyspdFtuXS50cmF2ZXJzZShlKX10cmF2ZXJzZVZpc2libGUoZSl7aWYodGhpcy52aXNpYmxlPT09ITEpcmV0dXJuO2UodGhpcyk7Y29uc3QgdD10aGlzLmNoaWxkcmVuO2ZvcihsZXQgbj0wLHI9dC5sZW5ndGg7bjxyO24rKyl0W25dLnRyYXZlcnNlVmlzaWJsZShlKX10cmF2ZXJzZUFuY2VzdG9ycyhlKXtjb25zdCB0PXRoaXMucGFyZW50O3QhPT1udWxsJiYoZSh0KSx0LnRyYXZlcnNlQW5jZXN0b3JzKGUpKX11cGRhdGVNYXRyaXgoKXt0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sdGhpcy5xdWF0ZXJuaW9uLHRoaXMuc2NhbGUpLHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMH11cGRhdGVNYXRyaXhXb3JsZChlKXt0aGlzLm1hdHJpeEF1dG9VcGRhdGUmJnRoaXMudXBkYXRlTWF0cml4KCksKHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZXx8ZSkmJih0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZT09PSEwJiYodGhpcy5wYXJlbnQ9PT1udWxsP3RoaXMubWF0cml4V29ybGQuY29weSh0aGlzLm1hdHJpeCk6dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLHRoaXMubWF0cml4KSksdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSExLGU9ITApO2NvbnN0IHQ9dGhpcy5jaGlsZHJlbjtmb3IobGV0IG49MCxyPXQubGVuZ3RoO248cjtuKyspdFtuXS51cGRhdGVNYXRyaXhXb3JsZChlKX11cGRhdGVXb3JsZE1hdHJpeChlLHQpe2NvbnN0IG49dGhpcy5wYXJlbnQ7aWYoZT09PSEwJiZuIT09bnVsbCYmbi51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksdGhpcy5tYXRyaXhBdXRvVXBkYXRlJiZ0aGlzLnVwZGF0ZU1hdHJpeCgpLHRoaXMubWF0cml4V29ybGRBdXRvVXBkYXRlPT09ITAmJih0aGlzLnBhcmVudD09PW51bGw/dGhpcy5tYXRyaXhXb3JsZC5jb3B5KHRoaXMubWF0cml4KTp0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXModGhpcy5wYXJlbnQubWF0cml4V29ybGQsdGhpcy5tYXRyaXgpKSx0PT09ITApe2NvbnN0IHI9dGhpcy5jaGlsZHJlbjtmb3IobGV0IHM9MCxhPXIubGVuZ3RoO3M8YTtzKyspcltzXS51cGRhdGVXb3JsZE1hdHJpeCghMSwhMCl9fXRvSlNPTihlKXtjb25zdCB0PWU9PT12b2lkIDB8fHR5cGVvZiBlPT0ic3RyaW5nIixuPXt9O3QmJihlPXtnZW9tZXRyaWVzOnt9LG1hdGVyaWFsczp7fSx0ZXh0dXJlczp7fSxpbWFnZXM6e30sc2hhcGVzOnt9LHNrZWxldG9uczp7fSxhbmltYXRpb25zOnt9LG5vZGVzOnt9fSxuLm1ldGFkYXRhPXt2ZXJzaW9uOjQuNix0eXBlOiJPYmplY3QiLGdlbmVyYXRvcjoiT2JqZWN0M0QudG9KU09OIn0pO2NvbnN0IHI9e307ci51dWlkPXRoaXMudXVpZCxyLnR5cGU9dGhpcy50eXBlLHRoaXMubmFtZSE9PSIiJiYoci5uYW1lPXRoaXMubmFtZSksdGhpcy5jYXN0U2hhZG93PT09ITAmJihyLmNhc3RTaGFkb3c9ITApLHRoaXMucmVjZWl2ZVNoYWRvdz09PSEwJiYoci5yZWNlaXZlU2hhZG93PSEwKSx0aGlzLnZpc2libGU9PT0hMSYmKHIudmlzaWJsZT0hMSksdGhpcy5mcnVzdHVtQ3VsbGVkPT09ITEmJihyLmZydXN0dW1DdWxsZWQ9ITEpLHRoaXMucmVuZGVyT3JkZXIhPT0wJiYoci5yZW5kZXJPcmRlcj10aGlzLnJlbmRlck9yZGVyKSxPYmplY3Qua2V5cyh0aGlzLnVzZXJEYXRhKS5sZW5ndGg+MCYmKHIudXNlckRhdGE9dGhpcy51c2VyRGF0YSksci5sYXllcnM9dGhpcy5sYXllcnMubWFzayxyLm1hdHJpeD10aGlzLm1hdHJpeC50b0FycmF5KCksci51cD10aGlzLnVwLnRvQXJyYXkoKSx0aGlzLm1hdHJpeEF1dG9VcGRhdGU9PT0hMSYmKHIubWF0cml4QXV0b1VwZGF0ZT0hMSksdGhpcy5pc0luc3RhbmNlZE1lc2gmJihyLnR5cGU9Ikluc3RhbmNlZE1lc2giLHIuY291bnQ9dGhpcy5jb3VudCxyLmluc3RhbmNlTWF0cml4PXRoaXMuaW5zdGFuY2VNYXRyaXgudG9KU09OKCksdGhpcy5pbnN0YW5jZUNvbG9yIT09bnVsbCYmKHIuaW5zdGFuY2VDb2xvcj10aGlzLmluc3RhbmNlQ29sb3IudG9KU09OKCkpKSx0aGlzLmlzQmF0Y2hlZE1lc2gmJihyLnR5cGU9IkJhdGNoZWRNZXNoIixyLnBlck9iamVjdEZydXN0dW1DdWxsZWQ9dGhpcy5wZXJPYmplY3RGcnVzdHVtQ3VsbGVkLHIuc29ydE9iamVjdHM9dGhpcy5zb3J0T2JqZWN0cyxyLmRyYXdSYW5nZXM9dGhpcy5fZHJhd1JhbmdlcyxyLnJlc2VydmVkUmFuZ2VzPXRoaXMuX3Jlc2VydmVkUmFuZ2VzLHIudmlzaWJpbGl0eT10aGlzLl92aXNpYmlsaXR5LHIuYWN0aXZlPXRoaXMuX2FjdGl2ZSxyLmJvdW5kcz10aGlzLl9ib3VuZHMubWFwKG89Pih7Ym94SW5pdGlhbGl6ZWQ6by5ib3hJbml0aWFsaXplZCxib3hNaW46by5ib3gubWluLnRvQXJyYXkoKSxib3hNYXg6by5ib3gubWF4LnRvQXJyYXkoKSxzcGhlcmVJbml0aWFsaXplZDpvLnNwaGVyZUluaXRpYWxpemVkLHNwaGVyZVJhZGl1czpvLnNwaGVyZS5yYWRpdXMsc3BoZXJlQ2VudGVyOm8uc3BoZXJlLmNlbnRlci50b0FycmF5KCl9KSksci5tYXhJbnN0YW5jZUNvdW50PXRoaXMuX21heEluc3RhbmNlQ291bnQsci5tYXhWZXJ0ZXhDb3VudD10aGlzLl9tYXhWZXJ0ZXhDb3VudCxyLm1heEluZGV4Q291bnQ9dGhpcy5fbWF4SW5kZXhDb3VudCxyLmdlb21ldHJ5SW5pdGlhbGl6ZWQ9dGhpcy5fZ2VvbWV0cnlJbml0aWFsaXplZCxyLmdlb21ldHJ5Q291bnQ9dGhpcy5fZ2VvbWV0cnlDb3VudCxyLm1hdHJpY2VzVGV4dHVyZT10aGlzLl9tYXRyaWNlc1RleHR1cmUudG9KU09OKGUpLHRoaXMuX2NvbG9yc1RleHR1cmUhPT1udWxsJiYoci5jb2xvcnNUZXh0dXJlPXRoaXMuX2NvbG9yc1RleHR1cmUudG9KU09OKGUpKSx0aGlzLmJvdW5kaW5nU3BoZXJlIT09bnVsbCYmKHIuYm91bmRpbmdTcGhlcmU9e2NlbnRlcjpyLmJvdW5kaW5nU3BoZXJlLmNlbnRlci50b0FycmF5KCkscmFkaXVzOnIuYm91bmRpbmdTcGhlcmUucmFkaXVzfSksdGhpcy5ib3VuZGluZ0JveCE9PW51bGwmJihyLmJvdW5kaW5nQm94PXttaW46ci5ib3VuZGluZ0JveC5taW4udG9BcnJheSgpLG1heDpyLmJvdW5kaW5nQm94Lm1heC50b0FycmF5KCl9KSk7ZnVuY3Rpb24gcyhvLGwpe3JldHVybiBvW2wudXVpZF09PT12b2lkIDAmJihvW2wudXVpZF09bC50b0pTT04oZSkpLGwudXVpZH1pZih0aGlzLmlzU2NlbmUpdGhpcy5iYWNrZ3JvdW5kJiYodGhpcy5iYWNrZ3JvdW5kLmlzQ29sb3I/ci5iYWNrZ3JvdW5kPXRoaXMuYmFja2dyb3VuZC50b0pTT04oKTp0aGlzLmJhY2tncm91bmQuaXNUZXh0dXJlJiYoci5iYWNrZ3JvdW5kPXRoaXMuYmFja2dyb3VuZC50b0pTT04oZSkudXVpZCkpLHRoaXMuZW52aXJvbm1lbnQmJnRoaXMuZW52aXJvbm1lbnQuaXNUZXh0dXJlJiZ0aGlzLmVudmlyb25tZW50LmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSE9PSEwJiYoci5lbnZpcm9ubWVudD10aGlzLmVudmlyb25tZW50LnRvSlNPTihlKS51dWlkKTtlbHNlIGlmKHRoaXMuaXNNZXNofHx0aGlzLmlzTGluZXx8dGhpcy5pc1BvaW50cyl7ci5nZW9tZXRyeT1zKGUuZ2VvbWV0cmllcyx0aGlzLmdlb21ldHJ5KTtjb25zdCBvPXRoaXMuZ2VvbWV0cnkucGFyYW1ldGVycztpZihvIT09dm9pZCAwJiZvLnNoYXBlcyE9PXZvaWQgMCl7Y29uc3QgbD1vLnNoYXBlcztpZihBcnJheS5pc0FycmF5KGwpKWZvcihsZXQgYz0wLHU9bC5sZW5ndGg7Yzx1O2MrKyl7Y29uc3QgaD1sW2NdO3MoZS5zaGFwZXMsaCl9ZWxzZSBzKGUuc2hhcGVzLGwpfX1pZih0aGlzLmlzU2tpbm5lZE1lc2gmJihyLmJpbmRNb2RlPXRoaXMuYmluZE1vZGUsci5iaW5kTWF0cml4PXRoaXMuYmluZE1hdHJpeC50b0FycmF5KCksdGhpcy5za2VsZXRvbiE9PXZvaWQgMCYmKHMoZS5za2VsZXRvbnMsdGhpcy5za2VsZXRvbiksci5za2VsZXRvbj10aGlzLnNrZWxldG9uLnV1aWQpKSx0aGlzLm1hdGVyaWFsIT09dm9pZCAwKWlmKEFycmF5LmlzQXJyYXkodGhpcy5tYXRlcmlhbCkpe2NvbnN0IG89W107Zm9yKGxldCBsPTAsYz10aGlzLm1hdGVyaWFsLmxlbmd0aDtsPGM7bCsrKW8ucHVzaChzKGUubWF0ZXJpYWxzLHRoaXMubWF0ZXJpYWxbbF0pKTtyLm1hdGVyaWFsPW99ZWxzZSByLm1hdGVyaWFsPXMoZS5tYXRlcmlhbHMsdGhpcy5tYXRlcmlhbCk7aWYodGhpcy5jaGlsZHJlbi5sZW5ndGg+MCl7ci5jaGlsZHJlbj1bXTtmb3IobGV0IG89MDtvPHRoaXMuY2hpbGRyZW4ubGVuZ3RoO28rKylyLmNoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltvXS50b0pTT04oZSkub2JqZWN0KX1pZih0aGlzLmFuaW1hdGlvbnMubGVuZ3RoPjApe3IuYW5pbWF0aW9ucz1bXTtmb3IobGV0IG89MDtvPHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7bysrKXtjb25zdCBsPXRoaXMuYW5pbWF0aW9uc1tvXTtyLmFuaW1hdGlvbnMucHVzaChzKGUuYW5pbWF0aW9ucyxsKSl9fWlmKHQpe2NvbnN0IG89YShlLmdlb21ldHJpZXMpLGw9YShlLm1hdGVyaWFscyksYz1hKGUudGV4dHVyZXMpLHU9YShlLmltYWdlcyksaD1hKGUuc2hhcGVzKSxmPWEoZS5za2VsZXRvbnMpLHA9YShlLmFuaW1hdGlvbnMpLF89YShlLm5vZGVzKTtvLmxlbmd0aD4wJiYobi5nZW9tZXRyaWVzPW8pLGwubGVuZ3RoPjAmJihuLm1hdGVyaWFscz1sKSxjLmxlbmd0aD4wJiYobi50ZXh0dXJlcz1jKSx1Lmxlbmd0aD4wJiYobi5pbWFnZXM9dSksaC5sZW5ndGg+MCYmKG4uc2hhcGVzPWgpLGYubGVuZ3RoPjAmJihuLnNrZWxldG9ucz1mKSxwLmxlbmd0aD4wJiYobi5hbmltYXRpb25zPXApLF8ubGVuZ3RoPjAmJihuLm5vZGVzPV8pfXJldHVybiBuLm9iamVjdD1yLG47ZnVuY3Rpb24gYShvKXtjb25zdCBsPVtdO2Zvcihjb25zdCBjIGluIG8pe2NvbnN0IHU9b1tjXTtkZWxldGUgdS5tZXRhZGF0YSxsLnB1c2godSl9cmV0dXJuIGx9fWNsb25lKGUpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyxlKX1jb3B5KGUsdD0hMCl7aWYodGhpcy5uYW1lPWUubmFtZSx0aGlzLnVwLmNvcHkoZS51cCksdGhpcy5wb3NpdGlvbi5jb3B5KGUucG9zaXRpb24pLHRoaXMucm90YXRpb24ub3JkZXI9ZS5yb3RhdGlvbi5vcmRlcix0aGlzLnF1YXRlcm5pb24uY29weShlLnF1YXRlcm5pb24pLHRoaXMuc2NhbGUuY29weShlLnNjYWxlKSx0aGlzLm1hdHJpeC5jb3B5KGUubWF0cml4KSx0aGlzLm1hdHJpeFdvcmxkLmNvcHkoZS5tYXRyaXhXb3JsZCksdGhpcy5tYXRyaXhBdXRvVXBkYXRlPWUubWF0cml4QXV0b1VwZGF0ZSx0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZT1lLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSx0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlLHRoaXMubGF5ZXJzLm1hc2s9ZS5sYXllcnMubWFzayx0aGlzLnZpc2libGU9ZS52aXNpYmxlLHRoaXMuY2FzdFNoYWRvdz1lLmNhc3RTaGFkb3csdGhpcy5yZWNlaXZlU2hhZG93PWUucmVjZWl2ZVNoYWRvdyx0aGlzLmZydXN0dW1DdWxsZWQ9ZS5mcnVzdHVtQ3VsbGVkLHRoaXMucmVuZGVyT3JkZXI9ZS5yZW5kZXJPcmRlcix0aGlzLmFuaW1hdGlvbnM9ZS5hbmltYXRpb25zLnNsaWNlKCksdGhpcy51c2VyRGF0YT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGUudXNlckRhdGEpKSx0PT09ITApZm9yKGxldCBuPTA7bjxlLmNoaWxkcmVuLmxlbmd0aDtuKyspe2NvbnN0IHI9ZS5jaGlsZHJlbltuXTt0aGlzLmFkZChyLmNsb25lKCkpfXJldHVybiB0aGlzfX1NdC5ERUZBVUxUX1VQPW5ldyBCKDAsMSwwKSxNdC5ERUZBVUxUX01BVFJJWF9BVVRPX1VQREFURT0hMCxNdC5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURT0hMDtjb25zdCBGdD1uZXcgQixZdD1uZXcgQixZaT1uZXcgQiwkdD1uZXcgQixEbj1uZXcgQixMbj1uZXcgQixHcj1uZXcgQiwkaT1uZXcgQixaaT1uZXcgQixLaT1uZXcgQixqaT1uZXcgaXQsSmk9bmV3IGl0LFFpPW5ldyBpdDtjbGFzcyBJdHtjb25zdHJ1Y3RvcihlPW5ldyBCLHQ9bmV3IEIsbj1uZXcgQil7dGhpcy5hPWUsdGhpcy5iPXQsdGhpcy5jPW59c3RhdGljIGdldE5vcm1hbChlLHQsbixyKXtyLnN1YlZlY3RvcnMobix0KSxGdC5zdWJWZWN0b3JzKGUsdCksci5jcm9zcyhGdCk7Y29uc3Qgcz1yLmxlbmd0aFNxKCk7cmV0dXJuIHM+MD9yLm11bHRpcGx5U2NhbGFyKDEvTWF0aC5zcXJ0KHMpKTpyLnNldCgwLDAsMCl9c3RhdGljIGdldEJhcnljb29yZChlLHQsbixyLHMpe0Z0LnN1YlZlY3RvcnMocix0KSxZdC5zdWJWZWN0b3JzKG4sdCksWWkuc3ViVmVjdG9ycyhlLHQpO2NvbnN0IGE9RnQuZG90KEZ0KSxvPUZ0LmRvdChZdCksbD1GdC5kb3QoWWkpLGM9WXQuZG90KFl0KSx1PVl0LmRvdChZaSksaD1hKmMtbypvO2lmKGg9PT0wKXJldHVybiBzLnNldCgwLDAsMCksbnVsbDtjb25zdCBmPTEvaCxwPShjKmwtbyp1KSpmLF89KGEqdS1vKmwpKmY7cmV0dXJuIHMuc2V0KDEtcC1fLF8scCl9c3RhdGljIGNvbnRhaW5zUG9pbnQoZSx0LG4scil7cmV0dXJuIHRoaXMuZ2V0QmFyeWNvb3JkKGUsdCxuLHIsJHQpPT09bnVsbD8hMTokdC54Pj0wJiYkdC55Pj0wJiYkdC54KyR0Lnk8PTF9c3RhdGljIGdldEludGVycG9sYXRpb24oZSx0LG4scixzLGEsbyxsKXtyZXR1cm4gdGhpcy5nZXRCYXJ5Y29vcmQoZSx0LG4sciwkdCk9PT1udWxsPyhsLng9MCxsLnk9MCwieiJpbiBsJiYobC56PTApLCJ3ImluIGwmJihsLnc9MCksbnVsbCk6KGwuc2V0U2NhbGFyKDApLGwuYWRkU2NhbGVkVmVjdG9yKHMsJHQueCksbC5hZGRTY2FsZWRWZWN0b3IoYSwkdC55KSxsLmFkZFNjYWxlZFZlY3RvcihvLCR0LnopLGwpfXN0YXRpYyBnZXRJbnRlcnBvbGF0ZWRBdHRyaWJ1dGUoZSx0LG4scixzLGEpe3JldHVybiBqaS5zZXRTY2FsYXIoMCksSmkuc2V0U2NhbGFyKDApLFFpLnNldFNjYWxhcigwKSxqaS5mcm9tQnVmZmVyQXR0cmlidXRlKGUsdCksSmkuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLG4pLFFpLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSxyKSxhLnNldFNjYWxhcigwKSxhLmFkZFNjYWxlZFZlY3RvcihqaSxzLngpLGEuYWRkU2NhbGVkVmVjdG9yKEppLHMueSksYS5hZGRTY2FsZWRWZWN0b3IoUWkscy56KSxhfXN0YXRpYyBpc0Zyb250RmFjaW5nKGUsdCxuLHIpe3JldHVybiBGdC5zdWJWZWN0b3JzKG4sdCksWXQuc3ViVmVjdG9ycyhlLHQpLEZ0LmNyb3NzKFl0KS5kb3Qocik8MH1zZXQoZSx0LG4pe3JldHVybiB0aGlzLmEuY29weShlKSx0aGlzLmIuY29weSh0KSx0aGlzLmMuY29weShuKSx0aGlzfXNldEZyb21Qb2ludHNBbmRJbmRpY2VzKGUsdCxuLHIpe3JldHVybiB0aGlzLmEuY29weShlW3RdKSx0aGlzLmIuY29weShlW25dKSx0aGlzLmMuY29weShlW3JdKSx0aGlzfXNldEZyb21BdHRyaWJ1dGVBbmRJbmRpY2VzKGUsdCxuLHIpe3JldHVybiB0aGlzLmEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHQpLHRoaXMuYi5mcm9tQnVmZmVyQXR0cmlidXRlKGUsbiksdGhpcy5jLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSxyKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX1jb3B5KGUpe3JldHVybiB0aGlzLmEuY29weShlLmEpLHRoaXMuYi5jb3B5KGUuYiksdGhpcy5jLmNvcHkoZS5jKSx0aGlzfWdldEFyZWEoKXtyZXR1cm4gRnQuc3ViVmVjdG9ycyh0aGlzLmMsdGhpcy5iKSxZdC5zdWJWZWN0b3JzKHRoaXMuYSx0aGlzLmIpLEZ0LmNyb3NzKFl0KS5sZW5ndGgoKSouNX1nZXRNaWRwb2ludChlKXtyZXR1cm4gZS5hZGRWZWN0b3JzKHRoaXMuYSx0aGlzLmIpLmFkZCh0aGlzLmMpLm11bHRpcGx5U2NhbGFyKDEvMyl9Z2V0Tm9ybWFsKGUpe3JldHVybiBJdC5nZXROb3JtYWwodGhpcy5hLHRoaXMuYix0aGlzLmMsZSl9Z2V0UGxhbmUoZSl7cmV0dXJuIGUuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKHRoaXMuYSx0aGlzLmIsdGhpcy5jKX1nZXRCYXJ5Y29vcmQoZSx0KXtyZXR1cm4gSXQuZ2V0QmFyeWNvb3JkKGUsdGhpcy5hLHRoaXMuYix0aGlzLmMsdCl9Z2V0SW50ZXJwb2xhdGlvbihlLHQsbixyLHMpe3JldHVybiBJdC5nZXRJbnRlcnBvbGF0aW9uKGUsdGhpcy5hLHRoaXMuYix0aGlzLmMsdCxuLHIscyl9Y29udGFpbnNQb2ludChlKXtyZXR1cm4gSXQuY29udGFpbnNQb2ludChlLHRoaXMuYSx0aGlzLmIsdGhpcy5jKX1pc0Zyb250RmFjaW5nKGUpe3JldHVybiBJdC5pc0Zyb250RmFjaW5nKHRoaXMuYSx0aGlzLmIsdGhpcy5jLGUpfWludGVyc2VjdHNCb3goZSl7cmV0dXJuIGUuaW50ZXJzZWN0c1RyaWFuZ2xlKHRoaXMpfWNsb3Nlc3RQb2ludFRvUG9pbnQoZSx0KXtjb25zdCBuPXRoaXMuYSxyPXRoaXMuYixzPXRoaXMuYztsZXQgYSxvO0RuLnN1YlZlY3RvcnMocixuKSxMbi5zdWJWZWN0b3JzKHMsbiksJGkuc3ViVmVjdG9ycyhlLG4pO2NvbnN0IGw9RG4uZG90KCRpKSxjPUxuLmRvdCgkaSk7aWYobDw9MCYmYzw9MClyZXR1cm4gdC5jb3B5KG4pO1ppLnN1YlZlY3RvcnMoZSxyKTtjb25zdCB1PURuLmRvdChaaSksaD1Mbi5kb3QoWmkpO2lmKHU+PTAmJmg8PXUpcmV0dXJuIHQuY29weShyKTtjb25zdCBmPWwqaC11KmM7aWYoZjw9MCYmbD49MCYmdTw9MClyZXR1cm4gYT1sLyhsLXUpLHQuY29weShuKS5hZGRTY2FsZWRWZWN0b3IoRG4sYSk7S2kuc3ViVmVjdG9ycyhlLHMpO2NvbnN0IHA9RG4uZG90KEtpKSxfPUxuLmRvdChLaSk7aWYoXz49MCYmcDw9XylyZXR1cm4gdC5jb3B5KHMpO2NvbnN0IHg9cCpjLWwqXztpZih4PD0wJiZjPj0wJiZfPD0wKXJldHVybiBvPWMvKGMtXyksdC5jb3B5KG4pLmFkZFNjYWxlZFZlY3RvcihMbixvKTtjb25zdCBtPXUqXy1wKmg7aWYobTw9MCYmaC11Pj0wJiZwLV8+PTApcmV0dXJuIEdyLnN1YlZlY3RvcnMocyxyKSxvPShoLXUpLyhoLXUrKHAtXykpLHQuY29weShyKS5hZGRTY2FsZWRWZWN0b3IoR3Isbyk7Y29uc3QgZD0xLyhtK3grZik7cmV0dXJuIGE9eCpkLG89ZipkLHQuY29weShuKS5hZGRTY2FsZWRWZWN0b3IoRG4sYSkuYWRkU2NhbGVkVmVjdG9yKExuLG8pfWVxdWFscyhlKXtyZXR1cm4gZS5hLmVxdWFscyh0aGlzLmEpJiZlLmIuZXF1YWxzKHRoaXMuYikmJmUuYy5lcXVhbHModGhpcy5jKX19Y29uc3QgSHI9e2FsaWNlYmx1ZToxNTc5MjM4MyxhbnRpcXVld2hpdGU6MTY0NDQzNzUsYXF1YTo2NTUzNSxhcXVhbWFyaW5lOjgzODg1NjQsYXp1cmU6MTU3OTQxNzUsYmVpZ2U6MTYxMTkyNjAsYmlzcXVlOjE2NzcwMjQ0LGJsYWNrOjAsYmxhbmNoZWRhbG1vbmQ6MTY3NzIwNDUsYmx1ZToyNTUsYmx1ZXZpb2xldDo5MDU1MjAyLGJyb3duOjEwODI0MjM0LGJ1cmx5d29vZDoxNDU5NjIzMSxjYWRldGJsdWU6NjI2NjUyOCxjaGFydHJldXNlOjgzODgzNTIsY2hvY29sYXRlOjEzNzg5NDcwLGNvcmFsOjE2NzQ0MjcyLGNvcm5mbG93ZXJibHVlOjY1OTE5ODEsY29ybnNpbGs6MTY3NzUzODgsY3JpbXNvbjoxNDQyMzEwMCxjeWFuOjY1NTM1LGRhcmtibHVlOjEzOSxkYXJrY3lhbjozNTcyMyxkYXJrZ29sZGVucm9kOjEyMDkyOTM5LGRhcmtncmF5OjExMTE5MDE3LGRhcmtncmVlbjoyNTYwMCxkYXJrZ3JleToxMTExOTAxNyxkYXJra2hha2k6MTI0MzMyNTksZGFya21hZ2VudGE6OTEwOTY0MyxkYXJrb2xpdmVncmVlbjo1NTk3OTk5LGRhcmtvcmFuZ2U6MTY3NDc1MjAsZGFya29yY2hpZDoxMDA0MDAxMixkYXJrcmVkOjkxMDk1MDQsZGFya3NhbG1vbjoxNTMwODQxMCxkYXJrc2VhZ3JlZW46OTQxOTkxOSxkYXJrc2xhdGVibHVlOjQ3MzQzNDcsZGFya3NsYXRlZ3JheTozMTAwNDk1LGRhcmtzbGF0ZWdyZXk6MzEwMDQ5NSxkYXJrdHVycXVvaXNlOjUyOTQ1LGRhcmt2aW9sZXQ6OTY5OTUzOSxkZWVwcGluazoxNjcxNjk0NyxkZWVwc2t5Ymx1ZTo0OTE1MSxkaW1ncmF5OjY5MDgyNjUsZGltZ3JleTo2OTA4MjY1LGRvZGdlcmJsdWU6MjAwMzE5OSxmaXJlYnJpY2s6MTE2NzQxNDYsZmxvcmFsd2hpdGU6MTY3NzU5MjAsZm9yZXN0Z3JlZW46MjI2Mzg0MixmdWNoc2lhOjE2NzExOTM1LGdhaW5zYm9ybzoxNDQ3NDQ2MCxnaG9zdHdoaXRlOjE2MzE2NjcxLGdvbGQ6MTY3NjY3MjAsZ29sZGVucm9kOjE0MzI5MTIwLGdyYXk6ODQyMTUwNCxncmVlbjozMjc2OCxncmVlbnllbGxvdzoxMTQwMzA1NSxncmV5Ojg0MjE1MDQsaG9uZXlkZXc6MTU3OTQxNjAsaG90cGluazoxNjczODc0MCxpbmRpYW5yZWQ6MTM0NTg1MjQsaW5kaWdvOjQ5MTUzMzAsaXZvcnk6MTY3NzcyMDAsa2hha2k6MTU3ODc2NjAsbGF2ZW5kZXI6MTUxMzI0MTAsbGF2ZW5kZXJibHVzaDoxNjc3MzM2NSxsYXduZ3JlZW46ODE5MDk3NixsZW1vbmNoaWZmb246MTY3NzU4ODUsbGlnaHRibHVlOjExMzkzMjU0LGxpZ2h0Y29yYWw6MTU3NjE1MzYsbGlnaHRjeWFuOjE0NzQ1NTk5LGxpZ2h0Z29sZGVucm9keWVsbG93OjE2NDQ4MjEwLGxpZ2h0Z3JheToxMzg4MjMyMyxsaWdodGdyZWVuOjk0OTgyNTYsbGlnaHRncmV5OjEzODgyMzIzLGxpZ2h0cGluazoxNjc1ODQ2NSxsaWdodHNhbG1vbjoxNjc1Mjc2MixsaWdodHNlYWdyZWVuOjIxNDI4OTAsbGlnaHRza3libHVlOjg5MDAzNDYsbGlnaHRzbGF0ZWdyYXk6NzgzMzc1MyxsaWdodHNsYXRlZ3JleTo3ODMzNzUzLGxpZ2h0c3RlZWxibHVlOjExNTg0NzM0LGxpZ2h0eWVsbG93OjE2Nzc3MTg0LGxpbWU6NjUyODAsbGltZWdyZWVuOjMzMjkzMzAsbGluZW46MTY0NDU2NzAsbWFnZW50YToxNjcxMTkzNSxtYXJvb246ODM4ODYwOCxtZWRpdW1hcXVhbWFyaW5lOjY3MzczMjIsbWVkaXVtYmx1ZToyMDUsbWVkaXVtb3JjaGlkOjEyMjExNjY3LG1lZGl1bXB1cnBsZTo5NjYyNjgzLG1lZGl1bXNlYWdyZWVuOjM5NzgwOTcsbWVkaXVtc2xhdGVibHVlOjgwODc3OTAsbWVkaXVtc3ByaW5nZ3JlZW46NjQxNTQsbWVkaXVtdHVycXVvaXNlOjQ3NzIzMDAsbWVkaXVtdmlvbGV0cmVkOjEzMDQ3MTczLG1pZG5pZ2h0Ymx1ZToxNjQ0OTEyLG1pbnRjcmVhbToxNjEyMTg1MCxtaXN0eXJvc2U6MTY3NzAyNzMsbW9jY2FzaW46MTY3NzAyMjksbmF2YWpvd2hpdGU6MTY3Njg2ODUsbmF2eToxMjgsb2xkbGFjZToxNjY0MzU1OCxvbGl2ZTo4NDIxMzc2LG9saXZlZHJhYjo3MDQ4NzM5LG9yYW5nZToxNjc1MzkyMCxvcmFuZ2VyZWQ6MTY3MjkzNDQsb3JjaGlkOjE0MzE1NzM0LHBhbGVnb2xkZW5yb2Q6MTU2NTcxMzAscGFsZWdyZWVuOjEwMDI1ODgwLHBhbGV0dXJxdW9pc2U6MTE1Mjk5NjYscGFsZXZpb2xldHJlZDoxNDM4MTIwMyxwYXBheWF3aGlwOjE2NzczMDc3LHBlYWNocHVmZjoxNjc2NzY3MyxwZXJ1OjEzNDY4OTkxLHBpbms6MTY3NjEwMzUscGx1bToxNDUyNDYzNyxwb3dkZXJibHVlOjExNTkxOTEwLHB1cnBsZTo4Mzg4NzM2LHJlYmVjY2FwdXJwbGU6NjY5Nzg4MSxyZWQ6MTY3MTE2ODAscm9zeWJyb3duOjEyMzU3NTE5LHJveWFsYmx1ZTo0Mjg2OTQ1LHNhZGRsZWJyb3duOjkxMjcxODcsc2FsbW9uOjE2NDE2ODgyLHNhbmR5YnJvd246MTYwMzI4NjQsc2VhZ3JlZW46MzA1MDMyNyxzZWFzaGVsbDoxNjc3NDYzOCxzaWVubmE6MTA1MDY3OTcsc2lsdmVyOjEyNjMyMjU2LHNreWJsdWU6ODkwMDMzMSxzbGF0ZWJsdWU6Njk3MDA2MSxzbGF0ZWdyYXk6NzM3Mjk0NCxzbGF0ZWdyZXk6NzM3Mjk0NCxzbm93OjE2Nzc1OTMwLHNwcmluZ2dyZWVuOjY1NDA3LHN0ZWVsYmx1ZTo0NjIwOTgwLHRhbjoxMzgwODc4MCx0ZWFsOjMyODk2LHRoaXN0bGU6MTQyMDQ4ODgsdG9tYXRvOjE2NzM3MDk1LHR1cnF1b2lzZTo0MjUxODU2LHZpb2xldDoxNTYzMTA4Nix3aGVhdDoxNjExMzMzMSx3aGl0ZToxNjc3NzIxNSx3aGl0ZXNtb2tlOjE2MTE5Mjg1LHllbGxvdzoxNjc3Njk2MCx5ZWxsb3dncmVlbjoxMDE0NTA3NH0scm49e2g6MCxzOjAsbDowfSxmaT17aDowLHM6MCxsOjB9O2Z1bmN0aW9uIGVyKGksZSx0KXtyZXR1cm4gdDwwJiYodCs9MSksdD4xJiYodC09MSksdDwxLzY/aSsoZS1pKSo2KnQ6dDwxLzI/ZTp0PDIvMz9pKyhlLWkpKjYqKDIvMy10KTppfWNsYXNzIFZle2NvbnN0cnVjdG9yKGUsdCxuKXtyZXR1cm4gdGhpcy5pc0NvbG9yPSEwLHRoaXMucj0xLHRoaXMuZz0xLHRoaXMuYj0xLHRoaXMuc2V0KGUsdCxuKX1zZXQoZSx0LG4pe2lmKHQ9PT12b2lkIDAmJm49PT12b2lkIDApe2NvbnN0IHI9ZTtyJiZyLmlzQ29sb3I/dGhpcy5jb3B5KHIpOnR5cGVvZiByPT0ibnVtYmVyIj90aGlzLnNldEhleChyKTp0eXBlb2Ygcj09InN0cmluZyImJnRoaXMuc2V0U3R5bGUocil9ZWxzZSB0aGlzLnNldFJHQihlLHQsbik7cmV0dXJuIHRoaXN9c2V0U2NhbGFyKGUpe3JldHVybiB0aGlzLnI9ZSx0aGlzLmc9ZSx0aGlzLmI9ZSx0aGlzfXNldEhleChlLHQ9d3Qpe3JldHVybiBlPU1hdGguZmxvb3IoZSksdGhpcy5yPShlPj4xNiYyNTUpLzI1NSx0aGlzLmc9KGU+PjgmMjU1KS8yNTUsdGhpcy5iPShlJjI1NSkvMjU1LEJlLnRvV29ya2luZ0NvbG9yU3BhY2UodGhpcyx0KSx0aGlzfXNldFJHQihlLHQsbixyPUJlLndvcmtpbmdDb2xvclNwYWNlKXtyZXR1cm4gdGhpcy5yPWUsdGhpcy5nPXQsdGhpcy5iPW4sQmUudG9Xb3JraW5nQ29sb3JTcGFjZSh0aGlzLHIpLHRoaXN9c2V0SFNMKGUsdCxuLHI9QmUud29ya2luZ0NvbG9yU3BhY2Upe2lmKGU9T2koZSwxKSx0PV90KHQsMCwxKSxuPV90KG4sMCwxKSx0PT09MCl0aGlzLnI9dGhpcy5nPXRoaXMuYj1uO2Vsc2V7Y29uc3Qgcz1uPD0uNT9uKigxK3QpOm4rdC1uKnQsYT0yKm4tczt0aGlzLnI9ZXIoYSxzLGUrMS8zKSx0aGlzLmc9ZXIoYSxzLGUpLHRoaXMuYj1lcihhLHMsZS0xLzMpfXJldHVybiBCZS50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsciksdGhpc31zZXRTdHlsZShlLHQ9d3Qpe2Z1bmN0aW9uIG4ocyl7cyE9PXZvaWQgMCYmcGFyc2VGbG9hdChzKTwxJiZjb25zb2xlLndhcm4oIlRIUkVFLkNvbG9yOiBBbHBoYSBjb21wb25lbnQgb2YgIitlKyIgd2lsbCBiZSBpZ25vcmVkLiIpfWxldCByO2lmKHI9L14oXHcrKVwoKFteXCldKilcKS8uZXhlYyhlKSl7bGV0IHM7Y29uc3QgYT1yWzFdLG89clsyXTtzd2l0Y2goYSl7Y2FzZSJyZ2IiOmNhc2UicmdiYSI6aWYocz0vXlxzKihcZCspXHMqLFxzKihcZCspXHMqLFxzKihcZCspXHMqKD86LFxzKihcZCpcLj9cZCspXHMqKT8kLy5leGVjKG8pKXJldHVybiBuKHNbNF0pLHRoaXMuc2V0UkdCKE1hdGgubWluKDI1NSxwYXJzZUludChzWzFdLDEwKSkvMjU1LE1hdGgubWluKDI1NSxwYXJzZUludChzWzJdLDEwKSkvMjU1LE1hdGgubWluKDI1NSxwYXJzZUludChzWzNdLDEwKSkvMjU1LHQpO2lmKHM9L15ccyooXGQrKVwlXHMqLFxzKihcZCspXCVccyosXHMqKFxkKylcJVxzKig/OixccyooXGQqXC4/XGQrKVxzKik/JC8uZXhlYyhvKSlyZXR1cm4gbihzWzRdKSx0aGlzLnNldFJHQihNYXRoLm1pbigxMDAscGFyc2VJbnQoc1sxXSwxMCkpLzEwMCxNYXRoLm1pbigxMDAscGFyc2VJbnQoc1syXSwxMCkpLzEwMCxNYXRoLm1pbigxMDAscGFyc2VJbnQoc1szXSwxMCkpLzEwMCx0KTticmVhaztjYXNlImhzbCI6Y2FzZSJoc2xhIjppZihzPS9eXHMqKFxkKlwuP1xkKylccyosXHMqKFxkKlwuP1xkKylcJVxzKixccyooXGQqXC4/XGQrKVwlXHMqKD86LFxzKihcZCpcLj9cZCspXHMqKT8kLy5leGVjKG8pKXJldHVybiBuKHNbNF0pLHRoaXMuc2V0SFNMKHBhcnNlRmxvYXQoc1sxXSkvMzYwLHBhcnNlRmxvYXQoc1syXSkvMTAwLHBhcnNlRmxvYXQoc1szXSkvMTAwLHQpO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS53YXJuKCJUSFJFRS5Db2xvcjogVW5rbm93biBjb2xvciBtb2RlbCAiK2UpfX1lbHNlIGlmKHI9L15cIyhbQS1GYS1mXGRdKykkLy5leGVjKGUpKXtjb25zdCBzPXJbMV0sYT1zLmxlbmd0aDtpZihhPT09MylyZXR1cm4gdGhpcy5zZXRSR0IocGFyc2VJbnQocy5jaGFyQXQoMCksMTYpLzE1LHBhcnNlSW50KHMuY2hhckF0KDEpLDE2KS8xNSxwYXJzZUludChzLmNoYXJBdCgyKSwxNikvMTUsdCk7aWYoYT09PTYpcmV0dXJuIHRoaXMuc2V0SGV4KHBhcnNlSW50KHMsMTYpLHQpO2NvbnNvbGUud2FybigiVEhSRUUuQ29sb3I6IEludmFsaWQgaGV4IGNvbG9yICIrZSl9ZWxzZSBpZihlJiZlLmxlbmd0aD4wKXJldHVybiB0aGlzLnNldENvbG9yTmFtZShlLHQpO3JldHVybiB0aGlzfXNldENvbG9yTmFtZShlLHQ9d3Qpe2NvbnN0IG49SHJbZS50b0xvd2VyQ2FzZSgpXTtyZXR1cm4gbiE9PXZvaWQgMD90aGlzLnNldEhleChuLHQpOmNvbnNvbGUud2FybigiVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgIitlKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucix0aGlzLmcsdGhpcy5iKX1jb3B5KGUpe3JldHVybiB0aGlzLnI9ZS5yLHRoaXMuZz1lLmcsdGhpcy5iPWUuYix0aGlzfWNvcHlTUkdCVG9MaW5lYXIoZSl7cmV0dXJuIHRoaXMucj1WdChlLnIpLHRoaXMuZz1WdChlLmcpLHRoaXMuYj1WdChlLmIpLHRoaXN9Y29weUxpbmVhclRvU1JHQihlKXtyZXR1cm4gdGhpcy5yPXluKGUuciksdGhpcy5nPXluKGUuZyksdGhpcy5iPXluKGUuYiksdGhpc31jb252ZXJ0U1JHQlRvTGluZWFyKCl7cmV0dXJuIHRoaXMuY29weVNSR0JUb0xpbmVhcih0aGlzKSx0aGlzfWNvbnZlcnRMaW5lYXJUb1NSR0IoKXtyZXR1cm4gdGhpcy5jb3B5TGluZWFyVG9TUkdCKHRoaXMpLHRoaXN9Z2V0SGV4KGU9d3Qpe3JldHVybiBCZS5mcm9tV29ya2luZ0NvbG9yU3BhY2UoZnQuY29weSh0aGlzKSxlKSxNYXRoLnJvdW5kKF90KGZ0LnIqMjU1LDAsMjU1KSkqNjU1MzYrTWF0aC5yb3VuZChfdChmdC5nKjI1NSwwLDI1NSkpKjI1NitNYXRoLnJvdW5kKF90KGZ0LmIqMjU1LDAsMjU1KSl9Z2V0SGV4U3RyaW5nKGU9d3Qpe3JldHVybigiMDAwMDAwIit0aGlzLmdldEhleChlKS50b1N0cmluZygxNikpLnNsaWNlKC02KX1nZXRIU0woZSx0PUJlLndvcmtpbmdDb2xvclNwYWNlKXtCZS5mcm9tV29ya2luZ0NvbG9yU3BhY2UoZnQuY29weSh0aGlzKSx0KTtjb25zdCBuPWZ0LnIscj1mdC5nLHM9ZnQuYixhPU1hdGgubWF4KG4scixzKSxvPU1hdGgubWluKG4scixzKTtsZXQgbCxjO2NvbnN0IHU9KG8rYSkvMjtpZihvPT09YSlsPTAsYz0wO2Vsc2V7Y29uc3QgaD1hLW87c3dpdGNoKGM9dTw9LjU/aC8oYStvKTpoLygyLWEtbyksYSl7Y2FzZSBuOmw9KHItcykvaCsocjxzPzY6MCk7YnJlYWs7Y2FzZSByOmw9KHMtbikvaCsyO2JyZWFrO2Nhc2UgczpsPShuLXIpL2grNDticmVha31sLz02fXJldHVybiBlLmg9bCxlLnM9YyxlLmw9dSxlfWdldFJHQihlLHQ9QmUud29ya2luZ0NvbG9yU3BhY2Upe3JldHVybiBCZS5mcm9tV29ya2luZ0NvbG9yU3BhY2UoZnQuY29weSh0aGlzKSx0KSxlLnI9ZnQucixlLmc9ZnQuZyxlLmI9ZnQuYixlfWdldFN0eWxlKGU9d3Qpe0JlLmZyb21Xb3JraW5nQ29sb3JTcGFjZShmdC5jb3B5KHRoaXMpLGUpO2NvbnN0IHQ9ZnQucixuPWZ0Lmcscj1mdC5iO3JldHVybiBlIT09d3Q/YGNvbG9yKCR7ZX0gJHt0LnRvRml4ZWQoMyl9ICR7bi50b0ZpeGVkKDMpfSAke3IudG9GaXhlZCgzKX0pYDpgcmdiKCR7TWF0aC5yb3VuZCh0KjI1NSl9LCR7TWF0aC5yb3VuZChuKjI1NSl9LCR7TWF0aC5yb3VuZChyKjI1NSl9KWB9b2Zmc2V0SFNMKGUsdCxuKXtyZXR1cm4gdGhpcy5nZXRIU0wocm4pLHRoaXMuc2V0SFNMKHJuLmgrZSxybi5zK3Qscm4ubCtuKX1hZGQoZSl7cmV0dXJuIHRoaXMucis9ZS5yLHRoaXMuZys9ZS5nLHRoaXMuYis9ZS5iLHRoaXN9YWRkQ29sb3JzKGUsdCl7cmV0dXJuIHRoaXMucj1lLnIrdC5yLHRoaXMuZz1lLmcrdC5nLHRoaXMuYj1lLmIrdC5iLHRoaXN9YWRkU2NhbGFyKGUpe3JldHVybiB0aGlzLnIrPWUsdGhpcy5nKz1lLHRoaXMuYis9ZSx0aGlzfXN1YihlKXtyZXR1cm4gdGhpcy5yPU1hdGgubWF4KDAsdGhpcy5yLWUuciksdGhpcy5nPU1hdGgubWF4KDAsdGhpcy5nLWUuZyksdGhpcy5iPU1hdGgubWF4KDAsdGhpcy5iLWUuYiksdGhpc31tdWx0aXBseShlKXtyZXR1cm4gdGhpcy5yKj1lLnIsdGhpcy5nKj1lLmcsdGhpcy5iKj1lLmIsdGhpc31tdWx0aXBseVNjYWxhcihlKXtyZXR1cm4gdGhpcy5yKj1lLHRoaXMuZyo9ZSx0aGlzLmIqPWUsdGhpc31sZXJwKGUsdCl7cmV0dXJuIHRoaXMucis9KGUuci10aGlzLnIpKnQsdGhpcy5nKz0oZS5nLXRoaXMuZykqdCx0aGlzLmIrPShlLmItdGhpcy5iKSp0LHRoaXN9bGVycENvbG9ycyhlLHQsbil7cmV0dXJuIHRoaXMucj1lLnIrKHQuci1lLnIpKm4sdGhpcy5nPWUuZysodC5nLWUuZykqbix0aGlzLmI9ZS5iKyh0LmItZS5iKSpuLHRoaXN9bGVycEhTTChlLHQpe3RoaXMuZ2V0SFNMKHJuKSxlLmdldEhTTChmaSk7Y29uc3Qgbj1rbihybi5oLGZpLmgsdCkscj1rbihybi5zLGZpLnMsdCkscz1rbihybi5sLGZpLmwsdCk7cmV0dXJuIHRoaXMuc2V0SFNMKG4scixzKSx0aGlzfXNldEZyb21WZWN0b3IzKGUpe3JldHVybiB0aGlzLnI9ZS54LHRoaXMuZz1lLnksdGhpcy5iPWUueix0aGlzfWFwcGx5TWF0cml4MyhlKXtjb25zdCB0PXRoaXMucixuPXRoaXMuZyxyPXRoaXMuYixzPWUuZWxlbWVudHM7cmV0dXJuIHRoaXMucj1zWzBdKnQrc1szXSpuK3NbNl0qcix0aGlzLmc9c1sxXSp0K3NbNF0qbitzWzddKnIsdGhpcy5iPXNbMl0qdCtzWzVdKm4rc1s4XSpyLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLnI9PT10aGlzLnImJmUuZz09PXRoaXMuZyYmZS5iPT09dGhpcy5ifWZyb21BcnJheShlLHQ9MCl7cmV0dXJuIHRoaXMucj1lW3RdLHRoaXMuZz1lW3QrMV0sdGhpcy5iPWVbdCsyXSx0aGlzfXRvQXJyYXkoZT1bXSx0PTApe3JldHVybiBlW3RdPXRoaXMucixlW3QrMV09dGhpcy5nLGVbdCsyXT10aGlzLmIsZX1mcm9tQnVmZmVyQXR0cmlidXRlKGUsdCl7cmV0dXJuIHRoaXMucj1lLmdldFgodCksdGhpcy5nPWUuZ2V0WSh0KSx0aGlzLmI9ZS5nZXRaKHQpLHRoaXN9dG9KU09OKCl7cmV0dXJuIHRoaXMuZ2V0SGV4KCl9KltTeW1ib2wuaXRlcmF0b3JdKCl7eWllbGQgdGhpcy5yLHlpZWxkIHRoaXMuZyx5aWVsZCB0aGlzLmJ9fWNvbnN0IGZ0PW5ldyBWZTtWZS5OQU1FUz1IcjtsZXQgVGE9MDtjbGFzcyBLbiBleHRlbmRzIE1ue3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJNYXRlcmlhbCJ9Z2V0IHR5cGUoKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50eXBlfXNldCB0eXBlKGUpe31jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5pc01hdGVyaWFsPSEwLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJpZCIse3ZhbHVlOlRhKyt9KSx0aGlzLnV1aWQ9U24oKSx0aGlzLm5hbWU9IiIsdGhpcy5ibGVuZGluZz0xLHRoaXMuc2lkZT0wLHRoaXMudmVydGV4Q29sb3JzPSExLHRoaXMub3BhY2l0eT0xLHRoaXMudHJhbnNwYXJlbnQ9ITEsdGhpcy5hbHBoYUhhc2g9ITEsdGhpcy5ibGVuZFNyYz0yMDQsdGhpcy5ibGVuZERzdD0yMDUsdGhpcy5ibGVuZEVxdWF0aW9uPTEwMCx0aGlzLmJsZW5kU3JjQWxwaGE9bnVsbCx0aGlzLmJsZW5kRHN0QWxwaGE9bnVsbCx0aGlzLmJsZW5kRXF1YXRpb25BbHBoYT1udWxsLHRoaXMuYmxlbmRDb2xvcj1uZXcgVmUoMCwwLDApLHRoaXMuYmxlbmRBbHBoYT0wLHRoaXMuZGVwdGhGdW5jPTMsdGhpcy5kZXB0aFRlc3Q9ITAsdGhpcy5kZXB0aFdyaXRlPSEwLHRoaXMuc3RlbmNpbFdyaXRlTWFzaz0yNTUsdGhpcy5zdGVuY2lsRnVuYz01MTksdGhpcy5zdGVuY2lsUmVmPTAsdGhpcy5zdGVuY2lsRnVuY01hc2s9MjU1LHRoaXMuc3RlbmNpbEZhaWw9NzY4MCx0aGlzLnN0ZW5jaWxaRmFpbD03NjgwLHRoaXMuc3RlbmNpbFpQYXNzPTc2ODAsdGhpcy5zdGVuY2lsV3JpdGU9ITEsdGhpcy5jbGlwcGluZ1BsYW5lcz1udWxsLHRoaXMuY2xpcEludGVyc2VjdGlvbj0hMSx0aGlzLmNsaXBTaGFkb3dzPSExLHRoaXMuc2hhZG93U2lkZT1udWxsLHRoaXMuY29sb3JXcml0ZT0hMCx0aGlzLnByZWNpc2lvbj1udWxsLHRoaXMucG9seWdvbk9mZnNldD0hMSx0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3I9MCx0aGlzLnBvbHlnb25PZmZzZXRVbml0cz0wLHRoaXMuZGl0aGVyaW5nPSExLHRoaXMuYWxwaGFUb0NvdmVyYWdlPSExLHRoaXMucHJlbXVsdGlwbGllZEFscGhhPSExLHRoaXMuZm9yY2VTaW5nbGVQYXNzPSExLHRoaXMudmlzaWJsZT0hMCx0aGlzLnRvbmVNYXBwZWQ9ITAsdGhpcy51c2VyRGF0YT17fSx0aGlzLnZlcnNpb249MCx0aGlzLl9hbHBoYVRlc3Q9MH1nZXQgYWxwaGFUZXN0KCl7cmV0dXJuIHRoaXMuX2FscGhhVGVzdH1zZXQgYWxwaGFUZXN0KGUpe3RoaXMuX2FscGhhVGVzdD4wIT1lPjAmJnRoaXMudmVyc2lvbisrLHRoaXMuX2FscGhhVGVzdD1lfW9uQmVmb3JlUmVuZGVyKCl7fW9uQmVmb3JlQ29tcGlsZSgpe31jdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKXtyZXR1cm4gdGhpcy5vbkJlZm9yZUNvbXBpbGUudG9TdHJpbmcoKX1zZXRWYWx1ZXMoZSl7aWYoZSE9PXZvaWQgMClmb3IoY29uc3QgdCBpbiBlKXtjb25zdCBuPWVbdF07aWYobj09PXZvaWQgMCl7Y29uc29sZS53YXJuKGBUSFJFRS5NYXRlcmlhbDogcGFyYW1ldGVyICcke3R9JyBoYXMgdmFsdWUgb2YgdW5kZWZpbmVkLmApO2NvbnRpbnVlfWNvbnN0IHI9dGhpc1t0XTtpZihyPT09dm9pZCAwKXtjb25zb2xlLndhcm4oYFRIUkVFLk1hdGVyaWFsOiAnJHt0fScgaXMgbm90IGEgcHJvcGVydHkgb2YgVEhSRUUuJHt0aGlzLnR5cGV9LmApO2NvbnRpbnVlfXImJnIuaXNDb2xvcj9yLnNldChuKTpyJiZyLmlzVmVjdG9yMyYmbiYmbi5pc1ZlY3RvcjM/ci5jb3B5KG4pOnRoaXNbdF09bn19dG9KU09OKGUpe2NvbnN0IHQ9ZT09PXZvaWQgMHx8dHlwZW9mIGU9PSJzdHJpbmciO3QmJihlPXt0ZXh0dXJlczp7fSxpbWFnZXM6e319KTtjb25zdCBuPXttZXRhZGF0YTp7dmVyc2lvbjo0LjYsdHlwZToiTWF0ZXJpYWwiLGdlbmVyYXRvcjoiTWF0ZXJpYWwudG9KU09OIn19O24udXVpZD10aGlzLnV1aWQsbi50eXBlPXRoaXMudHlwZSx0aGlzLm5hbWUhPT0iIiYmKG4ubmFtZT10aGlzLm5hbWUpLHRoaXMuY29sb3ImJnRoaXMuY29sb3IuaXNDb2xvciYmKG4uY29sb3I9dGhpcy5jb2xvci5nZXRIZXgoKSksdGhpcy5yb3VnaG5lc3MhPT12b2lkIDAmJihuLnJvdWdobmVzcz10aGlzLnJvdWdobmVzcyksdGhpcy5tZXRhbG5lc3MhPT12b2lkIDAmJihuLm1ldGFsbmVzcz10aGlzLm1ldGFsbmVzcyksdGhpcy5zaGVlbiE9PXZvaWQgMCYmKG4uc2hlZW49dGhpcy5zaGVlbiksdGhpcy5zaGVlbkNvbG9yJiZ0aGlzLnNoZWVuQ29sb3IuaXNDb2xvciYmKG4uc2hlZW5Db2xvcj10aGlzLnNoZWVuQ29sb3IuZ2V0SGV4KCkpLHRoaXMuc2hlZW5Sb3VnaG5lc3MhPT12b2lkIDAmJihuLnNoZWVuUm91Z2huZXNzPXRoaXMuc2hlZW5Sb3VnaG5lc3MpLHRoaXMuZW1pc3NpdmUmJnRoaXMuZW1pc3NpdmUuaXNDb2xvciYmKG4uZW1pc3NpdmU9dGhpcy5lbWlzc2l2ZS5nZXRIZXgoKSksdGhpcy5lbWlzc2l2ZUludGVuc2l0eSE9PXZvaWQgMCYmdGhpcy5lbWlzc2l2ZUludGVuc2l0eSE9PTEmJihuLmVtaXNzaXZlSW50ZW5zaXR5PXRoaXMuZW1pc3NpdmVJbnRlbnNpdHkpLHRoaXMuc3BlY3VsYXImJnRoaXMuc3BlY3VsYXIuaXNDb2xvciYmKG4uc3BlY3VsYXI9dGhpcy5zcGVjdWxhci5nZXRIZXgoKSksdGhpcy5zcGVjdWxhckludGVuc2l0eSE9PXZvaWQgMCYmKG4uc3BlY3VsYXJJbnRlbnNpdHk9dGhpcy5zcGVjdWxhckludGVuc2l0eSksdGhpcy5zcGVjdWxhckNvbG9yJiZ0aGlzLnNwZWN1bGFyQ29sb3IuaXNDb2xvciYmKG4uc3BlY3VsYXJDb2xvcj10aGlzLnNwZWN1bGFyQ29sb3IuZ2V0SGV4KCkpLHRoaXMuc2hpbmluZXNzIT09dm9pZCAwJiYobi5zaGluaW5lc3M9dGhpcy5zaGluaW5lc3MpLHRoaXMuY2xlYXJjb2F0IT09dm9pZCAwJiYobi5jbGVhcmNvYXQ9dGhpcy5jbGVhcmNvYXQpLHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzIT09dm9pZCAwJiYobi5jbGVhcmNvYXRSb3VnaG5lc3M9dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MpLHRoaXMuY2xlYXJjb2F0TWFwJiZ0aGlzLmNsZWFyY29hdE1hcC5pc1RleHR1cmUmJihuLmNsZWFyY29hdE1hcD10aGlzLmNsZWFyY29hdE1hcC50b0pTT04oZSkudXVpZCksdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAmJnRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwLmlzVGV4dHVyZSYmKG4uY2xlYXJjb2F0Um91Z2huZXNzTWFwPXRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLmNsZWFyY29hdE5vcm1hbE1hcCYmdGhpcy5jbGVhcmNvYXROb3JtYWxNYXAuaXNUZXh0dXJlJiYobi5jbGVhcmNvYXROb3JtYWxNYXA9dGhpcy5jbGVhcmNvYXROb3JtYWxNYXAudG9KU09OKGUpLnV1aWQsbi5jbGVhcmNvYXROb3JtYWxTY2FsZT10aGlzLmNsZWFyY29hdE5vcm1hbFNjYWxlLnRvQXJyYXkoKSksdGhpcy5kaXNwZXJzaW9uIT09dm9pZCAwJiYobi5kaXNwZXJzaW9uPXRoaXMuZGlzcGVyc2lvbiksdGhpcy5pcmlkZXNjZW5jZSE9PXZvaWQgMCYmKG4uaXJpZGVzY2VuY2U9dGhpcy5pcmlkZXNjZW5jZSksdGhpcy5pcmlkZXNjZW5jZUlPUiE9PXZvaWQgMCYmKG4uaXJpZGVzY2VuY2VJT1I9dGhpcy5pcmlkZXNjZW5jZUlPUiksdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlIT09dm9pZCAwJiYobi5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlPXRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSksdGhpcy5pcmlkZXNjZW5jZU1hcCYmdGhpcy5pcmlkZXNjZW5jZU1hcC5pc1RleHR1cmUmJihuLmlyaWRlc2NlbmNlTWFwPXRoaXMuaXJpZGVzY2VuY2VNYXAudG9KU09OKGUpLnV1aWQpLHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAmJnRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAuaXNUZXh0dXJlJiYobi5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcD10aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLmFuaXNvdHJvcHkhPT12b2lkIDAmJihuLmFuaXNvdHJvcHk9dGhpcy5hbmlzb3Ryb3B5KSx0aGlzLmFuaXNvdHJvcHlSb3RhdGlvbiE9PXZvaWQgMCYmKG4uYW5pc290cm9weVJvdGF0aW9uPXRoaXMuYW5pc290cm9weVJvdGF0aW9uKSx0aGlzLmFuaXNvdHJvcHlNYXAmJnRoaXMuYW5pc290cm9weU1hcC5pc1RleHR1cmUmJihuLmFuaXNvdHJvcHlNYXA9dGhpcy5hbmlzb3Ryb3B5TWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLm1hcCYmdGhpcy5tYXAuaXNUZXh0dXJlJiYobi5tYXA9dGhpcy5tYXAudG9KU09OKGUpLnV1aWQpLHRoaXMubWF0Y2FwJiZ0aGlzLm1hdGNhcC5pc1RleHR1cmUmJihuLm1hdGNhcD10aGlzLm1hdGNhcC50b0pTT04oZSkudXVpZCksdGhpcy5hbHBoYU1hcCYmdGhpcy5hbHBoYU1hcC5pc1RleHR1cmUmJihuLmFscGhhTWFwPXRoaXMuYWxwaGFNYXAudG9KU09OKGUpLnV1aWQpLHRoaXMubGlnaHRNYXAmJnRoaXMubGlnaHRNYXAuaXNUZXh0dXJlJiYobi5saWdodE1hcD10aGlzLmxpZ2h0TWFwLnRvSlNPTihlKS51dWlkLG4ubGlnaHRNYXBJbnRlbnNpdHk9dGhpcy5saWdodE1hcEludGVuc2l0eSksdGhpcy5hb01hcCYmdGhpcy5hb01hcC5pc1RleHR1cmUmJihuLmFvTWFwPXRoaXMuYW9NYXAudG9KU09OKGUpLnV1aWQsbi5hb01hcEludGVuc2l0eT10aGlzLmFvTWFwSW50ZW5zaXR5KSx0aGlzLmJ1bXBNYXAmJnRoaXMuYnVtcE1hcC5pc1RleHR1cmUmJihuLmJ1bXBNYXA9dGhpcy5idW1wTWFwLnRvSlNPTihlKS51dWlkLG4uYnVtcFNjYWxlPXRoaXMuYnVtcFNjYWxlKSx0aGlzLm5vcm1hbE1hcCYmdGhpcy5ub3JtYWxNYXAuaXNUZXh0dXJlJiYobi5ub3JtYWxNYXA9dGhpcy5ub3JtYWxNYXAudG9KU09OKGUpLnV1aWQsbi5ub3JtYWxNYXBUeXBlPXRoaXMubm9ybWFsTWFwVHlwZSxuLm5vcm1hbFNjYWxlPXRoaXMubm9ybWFsU2NhbGUudG9BcnJheSgpKSx0aGlzLmRpc3BsYWNlbWVudE1hcCYmdGhpcy5kaXNwbGFjZW1lbnRNYXAuaXNUZXh0dXJlJiYobi5kaXNwbGFjZW1lbnRNYXA9dGhpcy5kaXNwbGFjZW1lbnRNYXAudG9KU09OKGUpLnV1aWQsbi5kaXNwbGFjZW1lbnRTY2FsZT10aGlzLmRpc3BsYWNlbWVudFNjYWxlLG4uZGlzcGxhY2VtZW50Qmlhcz10aGlzLmRpc3BsYWNlbWVudEJpYXMpLHRoaXMucm91Z2huZXNzTWFwJiZ0aGlzLnJvdWdobmVzc01hcC5pc1RleHR1cmUmJihuLnJvdWdobmVzc01hcD10aGlzLnJvdWdobmVzc01hcC50b0pTT04oZSkudXVpZCksdGhpcy5tZXRhbG5lc3NNYXAmJnRoaXMubWV0YWxuZXNzTWFwLmlzVGV4dHVyZSYmKG4ubWV0YWxuZXNzTWFwPXRoaXMubWV0YWxuZXNzTWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLmVtaXNzaXZlTWFwJiZ0aGlzLmVtaXNzaXZlTWFwLmlzVGV4dHVyZSYmKG4uZW1pc3NpdmVNYXA9dGhpcy5lbWlzc2l2ZU1hcC50b0pTT04oZSkudXVpZCksdGhpcy5zcGVjdWxhck1hcCYmdGhpcy5zcGVjdWxhck1hcC5pc1RleHR1cmUmJihuLnNwZWN1bGFyTWFwPXRoaXMuc3BlY3VsYXJNYXAudG9KU09OKGUpLnV1aWQpLHRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAmJnRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAuaXNUZXh0dXJlJiYobi5zcGVjdWxhckludGVuc2l0eU1hcD10aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLnNwZWN1bGFyQ29sb3JNYXAmJnRoaXMuc3BlY3VsYXJDb2xvck1hcC5pc1RleHR1cmUmJihuLnNwZWN1bGFyQ29sb3JNYXA9dGhpcy5zcGVjdWxhckNvbG9yTWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLmVudk1hcCYmdGhpcy5lbnZNYXAuaXNUZXh0dXJlJiYobi5lbnZNYXA9dGhpcy5lbnZNYXAudG9KU09OKGUpLnV1aWQsdGhpcy5jb21iaW5lIT09dm9pZCAwJiYobi5jb21iaW5lPXRoaXMuY29tYmluZSkpLHRoaXMuZW52TWFwUm90YXRpb24hPT12b2lkIDAmJihuLmVudk1hcFJvdGF0aW9uPXRoaXMuZW52TWFwUm90YXRpb24udG9BcnJheSgpKSx0aGlzLmVudk1hcEludGVuc2l0eSE9PXZvaWQgMCYmKG4uZW52TWFwSW50ZW5zaXR5PXRoaXMuZW52TWFwSW50ZW5zaXR5KSx0aGlzLnJlZmxlY3Rpdml0eSE9PXZvaWQgMCYmKG4ucmVmbGVjdGl2aXR5PXRoaXMucmVmbGVjdGl2aXR5KSx0aGlzLnJlZnJhY3Rpb25SYXRpbyE9PXZvaWQgMCYmKG4ucmVmcmFjdGlvblJhdGlvPXRoaXMucmVmcmFjdGlvblJhdGlvKSx0aGlzLmdyYWRpZW50TWFwJiZ0aGlzLmdyYWRpZW50TWFwLmlzVGV4dHVyZSYmKG4uZ3JhZGllbnRNYXA9dGhpcy5ncmFkaWVudE1hcC50b0pTT04oZSkudXVpZCksdGhpcy50cmFuc21pc3Npb24hPT12b2lkIDAmJihuLnRyYW5zbWlzc2lvbj10aGlzLnRyYW5zbWlzc2lvbiksdGhpcy50cmFuc21pc3Npb25NYXAmJnRoaXMudHJhbnNtaXNzaW9uTWFwLmlzVGV4dHVyZSYmKG4udHJhbnNtaXNzaW9uTWFwPXRoaXMudHJhbnNtaXNzaW9uTWFwLnRvSlNPTihlKS51dWlkKSx0aGlzLnRoaWNrbmVzcyE9PXZvaWQgMCYmKG4udGhpY2tuZXNzPXRoaXMudGhpY2tuZXNzKSx0aGlzLnRoaWNrbmVzc01hcCYmdGhpcy50aGlja25lc3NNYXAuaXNUZXh0dXJlJiYobi50aGlja25lc3NNYXA9dGhpcy50aGlja25lc3NNYXAudG9KU09OKGUpLnV1aWQpLHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZSE9PXZvaWQgMCYmdGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlIT09MS8wJiYobi5hdHRlbnVhdGlvbkRpc3RhbmNlPXRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZSksdGhpcy5hdHRlbnVhdGlvbkNvbG9yIT09dm9pZCAwJiYobi5hdHRlbnVhdGlvbkNvbG9yPXRoaXMuYXR0ZW51YXRpb25Db2xvci5nZXRIZXgoKSksdGhpcy5zaXplIT09dm9pZCAwJiYobi5zaXplPXRoaXMuc2l6ZSksdGhpcy5zaGFkb3dTaWRlIT09bnVsbCYmKG4uc2hhZG93U2lkZT10aGlzLnNoYWRvd1NpZGUpLHRoaXMuc2l6ZUF0dGVudWF0aW9uIT09dm9pZCAwJiYobi5zaXplQXR0ZW51YXRpb249dGhpcy5zaXplQXR0ZW51YXRpb24pLHRoaXMuYmxlbmRpbmchPT0xJiYobi5ibGVuZGluZz10aGlzLmJsZW5kaW5nKSx0aGlzLnNpZGUhPT0wJiYobi5zaWRlPXRoaXMuc2lkZSksdGhpcy52ZXJ0ZXhDb2xvcnM9PT0hMCYmKG4udmVydGV4Q29sb3JzPSEwKSx0aGlzLm9wYWNpdHk8MSYmKG4ub3BhY2l0eT10aGlzLm9wYWNpdHkpLHRoaXMudHJhbnNwYXJlbnQ9PT0hMCYmKG4udHJhbnNwYXJlbnQ9ITApLHRoaXMuYmxlbmRTcmMhPT0yMDQmJihuLmJsZW5kU3JjPXRoaXMuYmxlbmRTcmMpLHRoaXMuYmxlbmREc3QhPT0yMDUmJihuLmJsZW5kRHN0PXRoaXMuYmxlbmREc3QpLHRoaXMuYmxlbmRFcXVhdGlvbiE9PTEwMCYmKG4uYmxlbmRFcXVhdGlvbj10aGlzLmJsZW5kRXF1YXRpb24pLHRoaXMuYmxlbmRTcmNBbHBoYSE9PW51bGwmJihuLmJsZW5kU3JjQWxwaGE9dGhpcy5ibGVuZFNyY0FscGhhKSx0aGlzLmJsZW5kRHN0QWxwaGEhPT1udWxsJiYobi5ibGVuZERzdEFscGhhPXRoaXMuYmxlbmREc3RBbHBoYSksdGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEhPT1udWxsJiYobi5ibGVuZEVxdWF0aW9uQWxwaGE9dGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEpLHRoaXMuYmxlbmRDb2xvciYmdGhpcy5ibGVuZENvbG9yLmlzQ29sb3ImJihuLmJsZW5kQ29sb3I9dGhpcy5ibGVuZENvbG9yLmdldEhleCgpKSx0aGlzLmJsZW5kQWxwaGEhPT0wJiYobi5ibGVuZEFscGhhPXRoaXMuYmxlbmRBbHBoYSksdGhpcy5kZXB0aEZ1bmMhPT0zJiYobi5kZXB0aEZ1bmM9dGhpcy5kZXB0aEZ1bmMpLHRoaXMuZGVwdGhUZXN0PT09ITEmJihuLmRlcHRoVGVzdD10aGlzLmRlcHRoVGVzdCksdGhpcy5kZXB0aFdyaXRlPT09ITEmJihuLmRlcHRoV3JpdGU9dGhpcy5kZXB0aFdyaXRlKSx0aGlzLmNvbG9yV3JpdGU9PT0hMSYmKG4uY29sb3JXcml0ZT10aGlzLmNvbG9yV3JpdGUpLHRoaXMuc3RlbmNpbFdyaXRlTWFzayE9PTI1NSYmKG4uc3RlbmNpbFdyaXRlTWFzaz10aGlzLnN0ZW5jaWxXcml0ZU1hc2spLHRoaXMuc3RlbmNpbEZ1bmMhPT01MTkmJihuLnN0ZW5jaWxGdW5jPXRoaXMuc3RlbmNpbEZ1bmMpLHRoaXMuc3RlbmNpbFJlZiE9PTAmJihuLnN0ZW5jaWxSZWY9dGhpcy5zdGVuY2lsUmVmKSx0aGlzLnN0ZW5jaWxGdW5jTWFzayE9PTI1NSYmKG4uc3RlbmNpbEZ1bmNNYXNrPXRoaXMuc3RlbmNpbEZ1bmNNYXNrKSx0aGlzLnN0ZW5jaWxGYWlsIT09NzY4MCYmKG4uc3RlbmNpbEZhaWw9dGhpcy5zdGVuY2lsRmFpbCksdGhpcy5zdGVuY2lsWkZhaWwhPT03NjgwJiYobi5zdGVuY2lsWkZhaWw9dGhpcy5zdGVuY2lsWkZhaWwpLHRoaXMuc3RlbmNpbFpQYXNzIT09NzY4MCYmKG4uc3RlbmNpbFpQYXNzPXRoaXMuc3RlbmNpbFpQYXNzKSx0aGlzLnN0ZW5jaWxXcml0ZT09PSEwJiYobi5zdGVuY2lsV3JpdGU9dGhpcy5zdGVuY2lsV3JpdGUpLHRoaXMucm90YXRpb24hPT12b2lkIDAmJnRoaXMucm90YXRpb24hPT0wJiYobi5yb3RhdGlvbj10aGlzLnJvdGF0aW9uKSx0aGlzLnBvbHlnb25PZmZzZXQ9PT0hMCYmKG4ucG9seWdvbk9mZnNldD0hMCksdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yIT09MCYmKG4ucG9seWdvbk9mZnNldEZhY3Rvcj10aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IpLHRoaXMucG9seWdvbk9mZnNldFVuaXRzIT09MCYmKG4ucG9seWdvbk9mZnNldFVuaXRzPXRoaXMucG9seWdvbk9mZnNldFVuaXRzKSx0aGlzLmxpbmV3aWR0aCE9PXZvaWQgMCYmdGhpcy5saW5ld2lkdGghPT0xJiYobi5saW5ld2lkdGg9dGhpcy5saW5ld2lkdGgpLHRoaXMuZGFzaFNpemUhPT12b2lkIDAmJihuLmRhc2hTaXplPXRoaXMuZGFzaFNpemUpLHRoaXMuZ2FwU2l6ZSE9PXZvaWQgMCYmKG4uZ2FwU2l6ZT10aGlzLmdhcFNpemUpLHRoaXMuc2NhbGUhPT12b2lkIDAmJihuLnNjYWxlPXRoaXMuc2NhbGUpLHRoaXMuZGl0aGVyaW5nPT09ITAmJihuLmRpdGhlcmluZz0hMCksdGhpcy5hbHBoYVRlc3Q+MCYmKG4uYWxwaGFUZXN0PXRoaXMuYWxwaGFUZXN0KSx0aGlzLmFscGhhSGFzaD09PSEwJiYobi5hbHBoYUhhc2g9ITApLHRoaXMuYWxwaGFUb0NvdmVyYWdlPT09ITAmJihuLmFscGhhVG9Db3ZlcmFnZT0hMCksdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGE9PT0hMCYmKG4ucHJlbXVsdGlwbGllZEFscGhhPSEwKSx0aGlzLmZvcmNlU2luZ2xlUGFzcz09PSEwJiYobi5mb3JjZVNpbmdsZVBhc3M9ITApLHRoaXMud2lyZWZyYW1lPT09ITAmJihuLndpcmVmcmFtZT0hMCksdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg+MSYmKG4ud2lyZWZyYW1lTGluZXdpZHRoPXRoaXMud2lyZWZyYW1lTGluZXdpZHRoKSx0aGlzLndpcmVmcmFtZUxpbmVjYXAhPT0icm91bmQiJiYobi53aXJlZnJhbWVMaW5lY2FwPXRoaXMud2lyZWZyYW1lTGluZWNhcCksdGhpcy53aXJlZnJhbWVMaW5lam9pbiE9PSJyb3VuZCImJihuLndpcmVmcmFtZUxpbmVqb2luPXRoaXMud2lyZWZyYW1lTGluZWpvaW4pLHRoaXMuZmxhdFNoYWRpbmc9PT0hMCYmKG4uZmxhdFNoYWRpbmc9ITApLHRoaXMudmlzaWJsZT09PSExJiYobi52aXNpYmxlPSExKSx0aGlzLnRvbmVNYXBwZWQ9PT0hMSYmKG4udG9uZU1hcHBlZD0hMSksdGhpcy5mb2c9PT0hMSYmKG4uZm9nPSExKSxPYmplY3Qua2V5cyh0aGlzLnVzZXJEYXRhKS5sZW5ndGg+MCYmKG4udXNlckRhdGE9dGhpcy51c2VyRGF0YSk7ZnVuY3Rpb24gcihzKXtjb25zdCBhPVtdO2Zvcihjb25zdCBvIGluIHMpe2NvbnN0IGw9c1tvXTtkZWxldGUgbC5tZXRhZGF0YSxhLnB1c2gobCl9cmV0dXJuIGF9aWYodCl7Y29uc3Qgcz1yKGUudGV4dHVyZXMpLGE9cihlLmltYWdlcyk7cy5sZW5ndGg+MCYmKG4udGV4dHVyZXM9cyksYS5sZW5ndGg+MCYmKG4uaW1hZ2VzPWEpfXJldHVybiBufWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX1jb3B5KGUpe3RoaXMubmFtZT1lLm5hbWUsdGhpcy5ibGVuZGluZz1lLmJsZW5kaW5nLHRoaXMuc2lkZT1lLnNpZGUsdGhpcy52ZXJ0ZXhDb2xvcnM9ZS52ZXJ0ZXhDb2xvcnMsdGhpcy5vcGFjaXR5PWUub3BhY2l0eSx0aGlzLnRyYW5zcGFyZW50PWUudHJhbnNwYXJlbnQsdGhpcy5ibGVuZFNyYz1lLmJsZW5kU3JjLHRoaXMuYmxlbmREc3Q9ZS5ibGVuZERzdCx0aGlzLmJsZW5kRXF1YXRpb249ZS5ibGVuZEVxdWF0aW9uLHRoaXMuYmxlbmRTcmNBbHBoYT1lLmJsZW5kU3JjQWxwaGEsdGhpcy5ibGVuZERzdEFscGhhPWUuYmxlbmREc3RBbHBoYSx0aGlzLmJsZW5kRXF1YXRpb25BbHBoYT1lLmJsZW5kRXF1YXRpb25BbHBoYSx0aGlzLmJsZW5kQ29sb3IuY29weShlLmJsZW5kQ29sb3IpLHRoaXMuYmxlbmRBbHBoYT1lLmJsZW5kQWxwaGEsdGhpcy5kZXB0aEZ1bmM9ZS5kZXB0aEZ1bmMsdGhpcy5kZXB0aFRlc3Q9ZS5kZXB0aFRlc3QsdGhpcy5kZXB0aFdyaXRlPWUuZGVwdGhXcml0ZSx0aGlzLnN0ZW5jaWxXcml0ZU1hc2s9ZS5zdGVuY2lsV3JpdGVNYXNrLHRoaXMuc3RlbmNpbEZ1bmM9ZS5zdGVuY2lsRnVuYyx0aGlzLnN0ZW5jaWxSZWY9ZS5zdGVuY2lsUmVmLHRoaXMuc3RlbmNpbEZ1bmNNYXNrPWUuc3RlbmNpbEZ1bmNNYXNrLHRoaXMuc3RlbmNpbEZhaWw9ZS5zdGVuY2lsRmFpbCx0aGlzLnN0ZW5jaWxaRmFpbD1lLnN0ZW5jaWxaRmFpbCx0aGlzLnN0ZW5jaWxaUGFzcz1lLnN0ZW5jaWxaUGFzcyx0aGlzLnN0ZW5jaWxXcml0ZT1lLnN0ZW5jaWxXcml0ZTtjb25zdCB0PWUuY2xpcHBpbmdQbGFuZXM7bGV0IG49bnVsbDtpZih0IT09bnVsbCl7Y29uc3Qgcj10Lmxlbmd0aDtuPW5ldyBBcnJheShyKTtmb3IobGV0IHM9MDtzIT09cjsrK3MpbltzXT10W3NdLmNsb25lKCl9cmV0dXJuIHRoaXMuY2xpcHBpbmdQbGFuZXM9bix0aGlzLmNsaXBJbnRlcnNlY3Rpb249ZS5jbGlwSW50ZXJzZWN0aW9uLHRoaXMuY2xpcFNoYWRvd3M9ZS5jbGlwU2hhZG93cyx0aGlzLnNoYWRvd1NpZGU9ZS5zaGFkb3dTaWRlLHRoaXMuY29sb3JXcml0ZT1lLmNvbG9yV3JpdGUsdGhpcy5wcmVjaXNpb249ZS5wcmVjaXNpb24sdGhpcy5wb2x5Z29uT2Zmc2V0PWUucG9seWdvbk9mZnNldCx0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3I9ZS5wb2x5Z29uT2Zmc2V0RmFjdG9yLHRoaXMucG9seWdvbk9mZnNldFVuaXRzPWUucG9seWdvbk9mZnNldFVuaXRzLHRoaXMuZGl0aGVyaW5nPWUuZGl0aGVyaW5nLHRoaXMuYWxwaGFUZXN0PWUuYWxwaGFUZXN0LHRoaXMuYWxwaGFIYXNoPWUuYWxwaGFIYXNoLHRoaXMuYWxwaGFUb0NvdmVyYWdlPWUuYWxwaGFUb0NvdmVyYWdlLHRoaXMucHJlbXVsdGlwbGllZEFscGhhPWUucHJlbXVsdGlwbGllZEFscGhhLHRoaXMuZm9yY2VTaW5nbGVQYXNzPWUuZm9yY2VTaW5nbGVQYXNzLHRoaXMudmlzaWJsZT1lLnZpc2libGUsdGhpcy50b25lTWFwcGVkPWUudG9uZU1hcHBlZCx0aGlzLnVzZXJEYXRhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZS51c2VyRGF0YSkpLHRoaXN9ZGlzcG9zZSgpe3RoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToiZGlzcG9zZSJ9KX1zZXQgbmVlZHNVcGRhdGUoZSl7ZT09PSEwJiZ0aGlzLnZlcnNpb24rK31vbkJ1aWxkKCl7Y29uc29sZS53YXJuKCJNYXRlcmlhbDogb25CdWlsZCgpIGhhcyBiZWVuIHJlbW92ZWQuIil9fWNsYXNzIGpuIGV4dGVuZHMgS257c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIk1lc2hCYXNpY01hdGVyaWFsIn1jb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuaXNNZXNoQmFzaWNNYXRlcmlhbD0hMCx0aGlzLmNvbG9yPW5ldyBWZSgxNjc3NzIxNSksdGhpcy5tYXA9bnVsbCx0aGlzLmxpZ2h0TWFwPW51bGwsdGhpcy5saWdodE1hcEludGVuc2l0eT0xLHRoaXMuYW9NYXA9bnVsbCx0aGlzLmFvTWFwSW50ZW5zaXR5PTEsdGhpcy5zcGVjdWxhck1hcD1udWxsLHRoaXMuYWxwaGFNYXA9bnVsbCx0aGlzLmVudk1hcD1udWxsLHRoaXMuZW52TWFwUm90YXRpb249bmV3IFh0LHRoaXMuY29tYmluZT0wLHRoaXMucmVmbGVjdGl2aXR5PTEsdGhpcy5yZWZyYWN0aW9uUmF0aW89Ljk4LHRoaXMud2lyZWZyYW1lPSExLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPTEsdGhpcy53aXJlZnJhbWVMaW5lY2FwPSJyb3VuZCIsdGhpcy53aXJlZnJhbWVMaW5lam9pbj0icm91bmQiLHRoaXMuZm9nPSEwLHRoaXMuc2V0VmFsdWVzKGUpfWNvcHkoZSl7cmV0dXJuIHN1cGVyLmNvcHkoZSksdGhpcy5jb2xvci5jb3B5KGUuY29sb3IpLHRoaXMubWFwPWUubWFwLHRoaXMubGlnaHRNYXA9ZS5saWdodE1hcCx0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5PWUubGlnaHRNYXBJbnRlbnNpdHksdGhpcy5hb01hcD1lLmFvTWFwLHRoaXMuYW9NYXBJbnRlbnNpdHk9ZS5hb01hcEludGVuc2l0eSx0aGlzLnNwZWN1bGFyTWFwPWUuc3BlY3VsYXJNYXAsdGhpcy5hbHBoYU1hcD1lLmFscGhhTWFwLHRoaXMuZW52TWFwPWUuZW52TWFwLHRoaXMuZW52TWFwUm90YXRpb24uY29weShlLmVudk1hcFJvdGF0aW9uKSx0aGlzLmNvbWJpbmU9ZS5jb21iaW5lLHRoaXMucmVmbGVjdGl2aXR5PWUucmVmbGVjdGl2aXR5LHRoaXMucmVmcmFjdGlvblJhdGlvPWUucmVmcmFjdGlvblJhdGlvLHRoaXMud2lyZWZyYW1lPWUud2lyZWZyYW1lLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPWUud2lyZWZyYW1lTGluZXdpZHRoLHRoaXMud2lyZWZyYW1lTGluZWNhcD1lLndpcmVmcmFtZUxpbmVjYXAsdGhpcy53aXJlZnJhbWVMaW5lam9pbj1lLndpcmVmcmFtZUxpbmVqb2luLHRoaXMuZm9nPWUuZm9nLHRoaXN9fWNvbnN0IG90PW5ldyBCLHBpPW5ldyBMZTtjbGFzcyBTdHtjb25zdHJ1Y3RvcihlLHQsbj0hMSl7aWYoQXJyYXkuaXNBcnJheShlKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LiIpO3RoaXMuaXNCdWZmZXJBdHRyaWJ1dGU9ITAsdGhpcy5uYW1lPSIiLHRoaXMuYXJyYXk9ZSx0aGlzLml0ZW1TaXplPXQsdGhpcy5jb3VudD1lIT09dm9pZCAwP2UubGVuZ3RoL3Q6MCx0aGlzLm5vcm1hbGl6ZWQ9bix0aGlzLnVzYWdlPTM1MDQ0LHRoaXMudXBkYXRlUmFuZ2VzPVtdLHRoaXMuZ3B1VHlwZT0xMDE1LHRoaXMudmVyc2lvbj0wfW9uVXBsb2FkQ2FsbGJhY2soKXt9c2V0IG5lZWRzVXBkYXRlKGUpe2U9PT0hMCYmdGhpcy52ZXJzaW9uKyt9c2V0VXNhZ2UoZSl7cmV0dXJuIHRoaXMudXNhZ2U9ZSx0aGlzfWFkZFVwZGF0ZVJhbmdlKGUsdCl7dGhpcy51cGRhdGVSYW5nZXMucHVzaCh7c3RhcnQ6ZSxjb3VudDp0fSl9Y2xlYXJVcGRhdGVSYW5nZXMoKXt0aGlzLnVwZGF0ZVJhbmdlcy5sZW5ndGg9MH1jb3B5KGUpe3JldHVybiB0aGlzLm5hbWU9ZS5uYW1lLHRoaXMuYXJyYXk9bmV3IGUuYXJyYXkuY29uc3RydWN0b3IoZS5hcnJheSksdGhpcy5pdGVtU2l6ZT1lLml0ZW1TaXplLHRoaXMuY291bnQ9ZS5jb3VudCx0aGlzLm5vcm1hbGl6ZWQ9ZS5ub3JtYWxpemVkLHRoaXMudXNhZ2U9ZS51c2FnZSx0aGlzLmdwdVR5cGU9ZS5ncHVUeXBlLHRoaXN9Y29weUF0KGUsdCxuKXtlKj10aGlzLml0ZW1TaXplLG4qPXQuaXRlbVNpemU7Zm9yKGxldCByPTAscz10aGlzLml0ZW1TaXplO3I8cztyKyspdGhpcy5hcnJheVtlK3JdPXQuYXJyYXlbbityXTtyZXR1cm4gdGhpc31jb3B5QXJyYXkoZSl7cmV0dXJuIHRoaXMuYXJyYXkuc2V0KGUpLHRoaXN9YXBwbHlNYXRyaXgzKGUpe2lmKHRoaXMuaXRlbVNpemU9PT0yKWZvcihsZXQgdD0wLG49dGhpcy5jb3VudDt0PG47dCsrKXBpLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcyx0KSxwaS5hcHBseU1hdHJpeDMoZSksdGhpcy5zZXRYWSh0LHBpLngscGkueSk7ZWxzZSBpZih0aGlzLml0ZW1TaXplPT09Mylmb3IobGV0IHQ9MCxuPXRoaXMuY291bnQ7dDxuO3QrKylvdC5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsdCksb3QuYXBwbHlNYXRyaXgzKGUpLHRoaXMuc2V0WFlaKHQsb3QueCxvdC55LG90LnopO3JldHVybiB0aGlzfWFwcGx5TWF0cml4NChlKXtmb3IobGV0IHQ9MCxuPXRoaXMuY291bnQ7dDxuO3QrKylvdC5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsdCksb3QuYXBwbHlNYXRyaXg0KGUpLHRoaXMuc2V0WFlaKHQsb3QueCxvdC55LG90LnopO3JldHVybiB0aGlzfWFwcGx5Tm9ybWFsTWF0cml4KGUpe2ZvcihsZXQgdD0wLG49dGhpcy5jb3VudDt0PG47dCsrKW90LmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcyx0KSxvdC5hcHBseU5vcm1hbE1hdHJpeChlKSx0aGlzLnNldFhZWih0LG90Lngsb3QueSxvdC56KTtyZXR1cm4gdGhpc310cmFuc2Zvcm1EaXJlY3Rpb24oZSl7Zm9yKGxldCB0PTAsbj10aGlzLmNvdW50O3Q8bjt0Kyspb3QuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLHQpLG90LnRyYW5zZm9ybURpcmVjdGlvbihlKSx0aGlzLnNldFhZWih0LG90Lngsb3QueSxvdC56KTtyZXR1cm4gdGhpc31zZXQoZSx0PTApe3JldHVybiB0aGlzLmFycmF5LnNldChlLHQpLHRoaXN9Z2V0Q29tcG9uZW50KGUsdCl7bGV0IG49dGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrdF07cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKG49RW4obix0aGlzLmFycmF5KSksbn1zZXRDb21wb25lbnQoZSx0LG4pe3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihuPWd0KG4sdGhpcy5hcnJheSkpLHRoaXMuYXJyYXlbZSp0aGlzLml0ZW1TaXplK3RdPW4sdGhpc31nZXRYKGUpe2xldCB0PXRoaXMuYXJyYXlbZSp0aGlzLml0ZW1TaXplXTtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYodD1Fbih0LHRoaXMuYXJyYXkpKSx0fXNldFgoZSx0KXtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYodD1ndCh0LHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W2UqdGhpcy5pdGVtU2l6ZV09dCx0aGlzfWdldFkoZSl7bGV0IHQ9dGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrMV07cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9RW4odCx0aGlzLmFycmF5KSksdH1zZXRZKGUsdCl7cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9Z3QodCx0aGlzLmFycmF5KSksdGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrMV09dCx0aGlzfWdldFooZSl7bGV0IHQ9dGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrMl07cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9RW4odCx0aGlzLmFycmF5KSksdH1zZXRaKGUsdCl7cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9Z3QodCx0aGlzLmFycmF5KSksdGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrMl09dCx0aGlzfWdldFcoZSl7bGV0IHQ9dGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrM107cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9RW4odCx0aGlzLmFycmF5KSksdH1zZXRXKGUsdCl7cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHQ9Z3QodCx0aGlzLmFycmF5KSksdGhpcy5hcnJheVtlKnRoaXMuaXRlbVNpemUrM109dCx0aGlzfXNldFhZKGUsdCxuKXtyZXR1cm4gZSo9dGhpcy5pdGVtU2l6ZSx0aGlzLm5vcm1hbGl6ZWQmJih0PWd0KHQsdGhpcy5hcnJheSksbj1ndChuLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W2UrMF09dCx0aGlzLmFycmF5W2UrMV09bix0aGlzfXNldFhZWihlLHQsbixyKXtyZXR1cm4gZSo9dGhpcy5pdGVtU2l6ZSx0aGlzLm5vcm1hbGl6ZWQmJih0PWd0KHQsdGhpcy5hcnJheSksbj1ndChuLHRoaXMuYXJyYXkpLHI9Z3Qocix0aGlzLmFycmF5KSksdGhpcy5hcnJheVtlKzBdPXQsdGhpcy5hcnJheVtlKzFdPW4sdGhpcy5hcnJheVtlKzJdPXIsdGhpc31zZXRYWVpXKGUsdCxuLHIscyl7cmV0dXJuIGUqPXRoaXMuaXRlbVNpemUsdGhpcy5ub3JtYWxpemVkJiYodD1ndCh0LHRoaXMuYXJyYXkpLG49Z3Qobix0aGlzLmFycmF5KSxyPWd0KHIsdGhpcy5hcnJheSkscz1ndChzLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W2UrMF09dCx0aGlzLmFycmF5W2UrMV09bix0aGlzLmFycmF5W2UrMl09cix0aGlzLmFycmF5W2UrM109cyx0aGlzfW9uVXBsb2FkKGUpe3JldHVybiB0aGlzLm9uVXBsb2FkQ2FsbGJhY2s9ZSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYXJyYXksdGhpcy5pdGVtU2l6ZSkuY29weSh0aGlzKX10b0pTT04oKXtjb25zdCBlPXtpdGVtU2l6ZTp0aGlzLml0ZW1TaXplLHR5cGU6dGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLGFycmF5OkFycmF5LmZyb20odGhpcy5hcnJheSksbm9ybWFsaXplZDp0aGlzLm5vcm1hbGl6ZWR9O3JldHVybiB0aGlzLm5hbWUhPT0iIiYmKGUubmFtZT10aGlzLm5hbWUpLHRoaXMudXNhZ2UhPT0zNTA0NCYmKGUudXNhZ2U9dGhpcy51c2FnZSksZX19Y2xhc3MgVnIgZXh0ZW5kcyBTdHtjb25zdHJ1Y3RvcihlLHQsbil7c3VwZXIobmV3IFVpbnQxNkFycmF5KGUpLHQsbil9fWNsYXNzIGtyIGV4dGVuZHMgU3R7Y29uc3RydWN0b3IoZSx0LG4pe3N1cGVyKG5ldyBVaW50MzJBcnJheShlKSx0LG4pfX1jbGFzcyB1biBleHRlbmRzIFN0e2NvbnN0cnVjdG9yKGUsdCxuKXtzdXBlcihuZXcgRmxvYXQzMkFycmF5KGUpLHQsbil9fWxldCBBYT0wO2NvbnN0IFJ0PW5ldyBydCx0cj1uZXcgTXQsVW49bmV3IEIsVHQ9bmV3IHFuLEpuPW5ldyBxbix1dD1uZXcgQjtjbGFzcyBDdCBleHRlbmRzIE1ue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmlzQnVmZmVyR2VvbWV0cnk9ITAsT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImlkIix7dmFsdWU6QWErK30pLHRoaXMudXVpZD1TbigpLHRoaXMubmFtZT0iIix0aGlzLnR5cGU9IkJ1ZmZlckdlb21ldHJ5Iix0aGlzLmluZGV4PW51bGwsdGhpcy5pbmRpcmVjdD1udWxsLHRoaXMuYXR0cmlidXRlcz17fSx0aGlzLm1vcnBoQXR0cmlidXRlcz17fSx0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPSExLHRoaXMuZ3JvdXBzPVtdLHRoaXMuYm91bmRpbmdCb3g9bnVsbCx0aGlzLmJvdW5kaW5nU3BoZXJlPW51bGwsdGhpcy5kcmF3UmFuZ2U9e3N0YXJ0OjAsY291bnQ6MS8wfSx0aGlzLnVzZXJEYXRhPXt9fWdldEluZGV4KCl7cmV0dXJuIHRoaXMuaW5kZXh9c2V0SW5kZXgoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/dGhpcy5pbmRleD1uZXcoU3IoZSk/a3I6VnIpKGUsMSk6dGhpcy5pbmRleD1lLHRoaXN9c2V0SW5kaXJlY3QoZSl7cmV0dXJuIHRoaXMuaW5kaXJlY3Q9ZSx0aGlzfWdldEluZGlyZWN0KCl7cmV0dXJuIHRoaXMuaW5kaXJlY3R9Z2V0QXR0cmlidXRlKGUpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbZV19c2V0QXR0cmlidXRlKGUsdCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlc1tlXT10LHRoaXN9ZGVsZXRlQXR0cmlidXRlKGUpe3JldHVybiBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW2VdLHRoaXN9aGFzQXR0cmlidXRlKGUpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbZV0hPT12b2lkIDB9YWRkR3JvdXAoZSx0LG49MCl7dGhpcy5ncm91cHMucHVzaCh7c3RhcnQ6ZSxjb3VudDp0LG1hdGVyaWFsSW5kZXg6bn0pfWNsZWFyR3JvdXBzKCl7dGhpcy5ncm91cHM9W119c2V0RHJhd1JhbmdlKGUsdCl7dGhpcy5kcmF3UmFuZ2Uuc3RhcnQ9ZSx0aGlzLmRyYXdSYW5nZS5jb3VudD10fWFwcGx5TWF0cml4NChlKXtjb25zdCB0PXRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjt0IT09dm9pZCAwJiYodC5hcHBseU1hdHJpeDQoZSksdC5uZWVkc1VwZGF0ZT0hMCk7Y29uc3Qgbj10aGlzLmF0dHJpYnV0ZXMubm9ybWFsO2lmKG4hPT12b2lkIDApe2NvbnN0IHM9bmV3IHdlKCkuZ2V0Tm9ybWFsTWF0cml4KGUpO24uYXBwbHlOb3JtYWxNYXRyaXgocyksbi5uZWVkc1VwZGF0ZT0hMH1jb25zdCByPXRoaXMuYXR0cmlidXRlcy50YW5nZW50O3JldHVybiByIT09dm9pZCAwJiYoci50cmFuc2Zvcm1EaXJlY3Rpb24oZSksci5uZWVkc1VwZGF0ZT0hMCksdGhpcy5ib3VuZGluZ0JveCE9PW51bGwmJnRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCksdGhpcy5ib3VuZGluZ1NwaGVyZSE9PW51bGwmJnRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksdGhpc31hcHBseVF1YXRlcm5pb24oZSl7cmV0dXJuIFJ0Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKGUpLHRoaXMuYXBwbHlNYXRyaXg0KFJ0KSx0aGlzfXJvdGF0ZVgoZSl7cmV0dXJuIFJ0Lm1ha2VSb3RhdGlvblgoZSksdGhpcy5hcHBseU1hdHJpeDQoUnQpLHRoaXN9cm90YXRlWShlKXtyZXR1cm4gUnQubWFrZVJvdGF0aW9uWShlKSx0aGlzLmFwcGx5TWF0cml4NChSdCksdGhpc31yb3RhdGVaKGUpe3JldHVybiBSdC5tYWtlUm90YXRpb25aKGUpLHRoaXMuYXBwbHlNYXRyaXg0KFJ0KSx0aGlzfXRyYW5zbGF0ZShlLHQsbil7cmV0dXJuIFJ0Lm1ha2VUcmFuc2xhdGlvbihlLHQsbiksdGhpcy5hcHBseU1hdHJpeDQoUnQpLHRoaXN9c2NhbGUoZSx0LG4pe3JldHVybiBSdC5tYWtlU2NhbGUoZSx0LG4pLHRoaXMuYXBwbHlNYXRyaXg0KFJ0KSx0aGlzfWxvb2tBdChlKXtyZXR1cm4gdHIubG9va0F0KGUpLHRyLnVwZGF0ZU1hdHJpeCgpLHRoaXMuYXBwbHlNYXRyaXg0KHRyLm1hdHJpeCksdGhpc31jZW50ZXIoKXtyZXR1cm4gdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKSx0aGlzLmJvdW5kaW5nQm94LmdldENlbnRlcihVbikubmVnYXRlKCksdGhpcy50cmFuc2xhdGUoVW4ueCxVbi55LFVuLnopLHRoaXN9c2V0RnJvbVBvaW50cyhlKXtjb25zdCB0PXRoaXMuZ2V0QXR0cmlidXRlKCJwb3NpdGlvbiIpO2lmKHQ9PT12b2lkIDApe2NvbnN0IG49W107Zm9yKGxldCByPTAscz1lLmxlbmd0aDtyPHM7cisrKXtjb25zdCBhPWVbcl07bi5wdXNoKGEueCxhLnksYS56fHwwKX10aGlzLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyB1bihuLDMpKX1lbHNle2ZvcihsZXQgbj0wLHI9dC5jb3VudDtuPHI7bisrKXtjb25zdCBzPWVbbl07dC5zZXRYWVoobixzLngscy55LHMuenx8MCl9ZS5sZW5ndGg+dC5jb3VudCYmY29uc29sZS53YXJuKCJUSFJFRS5CdWZmZXJHZW9tZXRyeTogQnVmZmVyIHNpemUgdG9vIHNtYWxsIGZvciBwb2ludHMgZGF0YS4gVXNlIC5kaXNwb3NlKCkgYW5kIGNyZWF0ZSBhIG5ldyBnZW9tZXRyeS4iKSx0Lm5lZWRzVXBkYXRlPSEwfXJldHVybiB0aGlzfWNvbXB1dGVCb3VuZGluZ0JveCgpe3RoaXMuYm91bmRpbmdCb3g9PT1udWxsJiYodGhpcy5ib3VuZGluZ0JveD1uZXcgcW4pO2NvbnN0IGU9dGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLHQ9dGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247aWYoZSYmZS5pc0dMQnVmZmVyQXR0cmlidXRlKXtjb25zb2xlLmVycm9yKCJUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTogR0xCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgYSBtYW51YWwgYm91bmRpbmcgYm94LiIsdGhpcyksdGhpcy5ib3VuZGluZ0JveC5zZXQobmV3IEIoLTEvMCwtMS8wLC0xLzApLG5ldyBCKDEvMCwxLzAsMS8wKSk7cmV0dXJufWlmKGUhPT12b2lkIDApe2lmKHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShlKSx0KWZvcihsZXQgbj0wLHI9dC5sZW5ndGg7bjxyO24rKyl7Y29uc3Qgcz10W25dO1R0LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUocyksdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZT8odXQuYWRkVmVjdG9ycyh0aGlzLmJvdW5kaW5nQm94Lm1pbixUdC5taW4pLHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCh1dCksdXQuYWRkVmVjdG9ycyh0aGlzLmJvdW5kaW5nQm94Lm1heCxUdC5tYXgpLHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCh1dCkpOih0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoVHQubWluKSx0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoVHQubWF4KSl9fWVsc2UgdGhpcy5ib3VuZGluZ0JveC5tYWtlRW1wdHkoKTsoaXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueCl8fGlzTmFOKHRoaXMuYm91bmRpbmdCb3gubWluLnkpfHxpc05hTih0aGlzLmJvdW5kaW5nQm94Lm1pbi56KSkmJmNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpOiBDb21wdXRlZCBtaW4vbWF4IGhhdmUgTmFOIHZhbHVlcy4gVGhlICJwb3NpdGlvbiIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJyx0aGlzKX1jb21wdXRlQm91bmRpbmdTcGhlcmUoKXt0aGlzLmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmKHRoaXMuYm91bmRpbmdTcGhlcmU9bmV3IGxpKTtjb25zdCBlPXRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbix0PXRoaXMubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO2lmKGUmJmUuaXNHTEJ1ZmZlckF0dHJpYnV0ZSl7Y29uc29sZS5lcnJvcigiVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IEdMQnVmZmVyQXR0cmlidXRlIHJlcXVpcmVzIGEgbWFudWFsIGJvdW5kaW5nIHNwaGVyZS4iLHRoaXMpLHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0KG5ldyBCLDEvMCk7cmV0dXJufWlmKGUpe2NvbnN0IG49dGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7aWYoVHQuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShlKSx0KWZvcihsZXQgcz0wLGE9dC5sZW5ndGg7czxhO3MrKyl7Y29uc3Qgbz10W3NdO0puLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUobyksdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZT8odXQuYWRkVmVjdG9ycyhUdC5taW4sSm4ubWluKSxUdC5leHBhbmRCeVBvaW50KHV0KSx1dC5hZGRWZWN0b3JzKFR0Lm1heCxKbi5tYXgpLFR0LmV4cGFuZEJ5UG9pbnQodXQpKTooVHQuZXhwYW5kQnlQb2ludChKbi5taW4pLFR0LmV4cGFuZEJ5UG9pbnQoSm4ubWF4KSl9VHQuZ2V0Q2VudGVyKG4pO2xldCByPTA7Zm9yKGxldCBzPTAsYT1lLmNvdW50O3M8YTtzKyspdXQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHMpLHI9TWF0aC5tYXgocixuLmRpc3RhbmNlVG9TcXVhcmVkKHV0KSk7aWYodClmb3IobGV0IHM9MCxhPXQubGVuZ3RoO3M8YTtzKyspe2NvbnN0IG89dFtzXSxsPXRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7Zm9yKGxldCBjPTAsdT1vLmNvdW50O2M8dTtjKyspdXQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShvLGMpLGwmJihVbi5mcm9tQnVmZmVyQXR0cmlidXRlKGUsYyksdXQuYWRkKFVuKSkscj1NYXRoLm1heChyLG4uZGlzdGFuY2VUb1NxdWFyZWQodXQpKX10aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cz1NYXRoLnNxcnQociksaXNOYU4odGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMpJiZjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogQ29tcHV0ZWQgcmFkaXVzIGlzIE5hTi4gVGhlICJwb3NpdGlvbiIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJyx0aGlzKX19Y29tcHV0ZVRhbmdlbnRzKCl7Y29uc3QgZT10aGlzLmluZGV4LHQ9dGhpcy5hdHRyaWJ1dGVzO2lmKGU9PT1udWxsfHx0LnBvc2l0aW9uPT09dm9pZCAwfHx0Lm5vcm1hbD09PXZvaWQgMHx8dC51dj09PXZvaWQgMCl7Y29uc29sZS5lcnJvcigiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBmYWlsZWQuIE1pc3NpbmcgcmVxdWlyZWQgYXR0cmlidXRlcyAoaW5kZXgsIHBvc2l0aW9uLCBub3JtYWwgb3IgdXYpIik7cmV0dXJufWNvbnN0IG49dC5wb3NpdGlvbixyPXQubm9ybWFsLHM9dC51djt0aGlzLmhhc0F0dHJpYnV0ZSgidGFuZ2VudCIpPT09ITEmJnRoaXMuc2V0QXR0cmlidXRlKCJ0YW5nZW50IixuZXcgU3QobmV3IEZsb2F0MzJBcnJheSg0Km4uY291bnQpLDQpKTtjb25zdCBhPXRoaXMuZ2V0QXR0cmlidXRlKCJ0YW5nZW50Iiksbz1bXSxsPVtdO2ZvcihsZXQgVT0wO1U8bi5jb3VudDtVKyspb1tVXT1uZXcgQixsW1VdPW5ldyBCO2NvbnN0IGM9bmV3IEIsdT1uZXcgQixoPW5ldyBCLGY9bmV3IExlLHA9bmV3IExlLF89bmV3IExlLHg9bmV3IEIsbT1uZXcgQjtmdW5jdGlvbiBkKFUsRSxTKXtjLmZyb21CdWZmZXJBdHRyaWJ1dGUobixVKSx1LmZyb21CdWZmZXJBdHRyaWJ1dGUobixFKSxoLmZyb21CdWZmZXJBdHRyaWJ1dGUobixTKSxmLmZyb21CdWZmZXJBdHRyaWJ1dGUocyxVKSxwLmZyb21CdWZmZXJBdHRyaWJ1dGUocyxFKSxfLmZyb21CdWZmZXJBdHRyaWJ1dGUocyxTKSx1LnN1YihjKSxoLnN1YihjKSxwLnN1YihmKSxfLnN1YihmKTtjb25zdCBSPTEvKHAueCpfLnktXy54KnAueSk7aXNGaW5pdGUoUikmJih4LmNvcHkodSkubXVsdGlwbHlTY2FsYXIoXy55KS5hZGRTY2FsZWRWZWN0b3IoaCwtcC55KS5tdWx0aXBseVNjYWxhcihSKSxtLmNvcHkoaCkubXVsdGlwbHlTY2FsYXIocC54KS5hZGRTY2FsZWRWZWN0b3IodSwtXy54KS5tdWx0aXBseVNjYWxhcihSKSxvW1VdLmFkZCh4KSxvW0VdLmFkZCh4KSxvW1NdLmFkZCh4KSxsW1VdLmFkZChtKSxsW0VdLmFkZChtKSxsW1NdLmFkZChtKSl9bGV0IEE9dGhpcy5ncm91cHM7QS5sZW5ndGg9PT0wJiYoQT1be3N0YXJ0OjAsY291bnQ6ZS5jb3VudH1dKTtmb3IobGV0IFU9MCxFPUEubGVuZ3RoO1U8RTsrK1Upe2NvbnN0IFM9QVtVXSxSPVMuc3RhcnQscT1TLmNvdW50O2ZvcihsZXQgej1SLFc9UitxO3o8Vzt6Kz0zKWQoZS5nZXRYKHorMCksZS5nZXRYKHorMSksZS5nZXRYKHorMikpfWNvbnN0IFQ9bmV3IEIsTT1uZXcgQixGPW5ldyBCLGI9bmV3IEI7ZnVuY3Rpb24gdyhVKXtGLmZyb21CdWZmZXJBdHRyaWJ1dGUocixVKSxiLmNvcHkoRik7Y29uc3QgRT1vW1VdO1QuY29weShFKSxULnN1YihGLm11bHRpcGx5U2NhbGFyKEYuZG90KEUpKSkubm9ybWFsaXplKCksTS5jcm9zc1ZlY3RvcnMoYixFKTtjb25zdCBSPU0uZG90KGxbVV0pPDA/LTE6MTthLnNldFhZWlcoVSxULngsVC55LFQueixSKX1mb3IobGV0IFU9MCxFPUEubGVuZ3RoO1U8RTsrK1Upe2NvbnN0IFM9QVtVXSxSPVMuc3RhcnQscT1TLmNvdW50O2ZvcihsZXQgej1SLFc9UitxO3o8Vzt6Kz0zKXcoZS5nZXRYKHorMCkpLHcoZS5nZXRYKHorMSkpLHcoZS5nZXRYKHorMikpfX1jb21wdXRlVmVydGV4Tm9ybWFscygpe2NvbnN0IGU9dGhpcy5pbmRleCx0PXRoaXMuZ2V0QXR0cmlidXRlKCJwb3NpdGlvbiIpO2lmKHQhPT12b2lkIDApe2xldCBuPXRoaXMuZ2V0QXR0cmlidXRlKCJub3JtYWwiKTtpZihuPT09dm9pZCAwKW49bmV3IFN0KG5ldyBGbG9hdDMyQXJyYXkodC5jb3VudCozKSwzKSx0aGlzLnNldEF0dHJpYnV0ZSgibm9ybWFsIixuKTtlbHNlIGZvcihsZXQgZj0wLHA9bi5jb3VudDtmPHA7ZisrKW4uc2V0WFlaKGYsMCwwLDApO2NvbnN0IHI9bmV3IEIscz1uZXcgQixhPW5ldyBCLG89bmV3IEIsbD1uZXcgQixjPW5ldyBCLHU9bmV3IEIsaD1uZXcgQjtpZihlKWZvcihsZXQgZj0wLHA9ZS5jb3VudDtmPHA7Zis9Myl7Y29uc3QgXz1lLmdldFgoZiswKSx4PWUuZ2V0WChmKzEpLG09ZS5nZXRYKGYrMik7ci5mcm9tQnVmZmVyQXR0cmlidXRlKHQsXykscy5mcm9tQnVmZmVyQXR0cmlidXRlKHQseCksYS5mcm9tQnVmZmVyQXR0cmlidXRlKHQsbSksdS5zdWJWZWN0b3JzKGEscyksaC5zdWJWZWN0b3JzKHIscyksdS5jcm9zcyhoKSxvLmZyb21CdWZmZXJBdHRyaWJ1dGUobixfKSxsLmZyb21CdWZmZXJBdHRyaWJ1dGUobix4KSxjLmZyb21CdWZmZXJBdHRyaWJ1dGUobixtKSxvLmFkZCh1KSxsLmFkZCh1KSxjLmFkZCh1KSxuLnNldFhZWihfLG8ueCxvLnksby56KSxuLnNldFhZWih4LGwueCxsLnksbC56KSxuLnNldFhZWihtLGMueCxjLnksYy56KX1lbHNlIGZvcihsZXQgZj0wLHA9dC5jb3VudDtmPHA7Zis9MylyLmZyb21CdWZmZXJBdHRyaWJ1dGUodCxmKzApLHMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LGYrMSksYS5mcm9tQnVmZmVyQXR0cmlidXRlKHQsZisyKSx1LnN1YlZlY3RvcnMoYSxzKSxoLnN1YlZlY3RvcnMocixzKSx1LmNyb3NzKGgpLG4uc2V0WFlaKGYrMCx1LngsdS55LHUueiksbi5zZXRYWVooZisxLHUueCx1LnksdS56KSxuLnNldFhZWihmKzIsdS54LHUueSx1LnopO3RoaXMubm9ybWFsaXplTm9ybWFscygpLG4ubmVlZHNVcGRhdGU9ITB9fW5vcm1hbGl6ZU5vcm1hbHMoKXtjb25zdCBlPXRoaXMuYXR0cmlidXRlcy5ub3JtYWw7Zm9yKGxldCB0PTAsbj1lLmNvdW50O3Q8bjt0KyspdXQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHQpLHV0Lm5vcm1hbGl6ZSgpLGUuc2V0WFlaKHQsdXQueCx1dC55LHV0LnopfXRvTm9uSW5kZXhlZCgpe2Z1bmN0aW9uIGUobyxsKXtjb25zdCBjPW8uYXJyYXksdT1vLml0ZW1TaXplLGg9by5ub3JtYWxpemVkLGY9bmV3IGMuY29uc3RydWN0b3IobC5sZW5ndGgqdSk7bGV0IHA9MCxfPTA7Zm9yKGxldCB4PTAsbT1sLmxlbmd0aDt4PG07eCsrKXtvLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU/cD1sW3hdKm8uZGF0YS5zdHJpZGUrby5vZmZzZXQ6cD1sW3hdKnU7Zm9yKGxldCBkPTA7ZDx1O2QrKylmW18rK109Y1twKytdfXJldHVybiBuZXcgU3QoZix1LGgpfWlmKHRoaXMuaW5kZXg9PT1udWxsKXJldHVybiBjb25zb2xlLndhcm4oIlRIUkVFLkJ1ZmZlckdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpOiBCdWZmZXJHZW9tZXRyeSBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLiIpLHRoaXM7Y29uc3QgdD1uZXcgQ3Qsbj10aGlzLmluZGV4LmFycmF5LHI9dGhpcy5hdHRyaWJ1dGVzO2Zvcihjb25zdCBvIGluIHIpe2NvbnN0IGw9cltvXSxjPWUobCxuKTt0LnNldEF0dHJpYnV0ZShvLGMpfWNvbnN0IHM9dGhpcy5tb3JwaEF0dHJpYnV0ZXM7Zm9yKGNvbnN0IG8gaW4gcyl7Y29uc3QgbD1bXSxjPXNbb107Zm9yKGxldCB1PTAsaD1jLmxlbmd0aDt1PGg7dSsrKXtjb25zdCBmPWNbdV0scD1lKGYsbik7bC5wdXNoKHApfXQubW9ycGhBdHRyaWJ1dGVzW29dPWx9dC5tb3JwaFRhcmdldHNSZWxhdGl2ZT10aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO2NvbnN0IGE9dGhpcy5ncm91cHM7Zm9yKGxldCBvPTAsbD1hLmxlbmd0aDtvPGw7bysrKXtjb25zdCBjPWFbb107dC5hZGRHcm91cChjLnN0YXJ0LGMuY291bnQsYy5tYXRlcmlhbEluZGV4KX1yZXR1cm4gdH10b0pTT04oKXtjb25zdCBlPXttZXRhZGF0YTp7dmVyc2lvbjo0LjYsdHlwZToiQnVmZmVyR2VvbWV0cnkiLGdlbmVyYXRvcjoiQnVmZmVyR2VvbWV0cnkudG9KU09OIn19O2lmKGUudXVpZD10aGlzLnV1aWQsZS50eXBlPXRoaXMudHlwZSx0aGlzLm5hbWUhPT0iIiYmKGUubmFtZT10aGlzLm5hbWUpLE9iamVjdC5rZXlzKHRoaXMudXNlckRhdGEpLmxlbmd0aD4wJiYoZS51c2VyRGF0YT10aGlzLnVzZXJEYXRhKSx0aGlzLnBhcmFtZXRlcnMhPT12b2lkIDApe2NvbnN0IGw9dGhpcy5wYXJhbWV0ZXJzO2Zvcihjb25zdCBjIGluIGwpbFtjXSE9PXZvaWQgMCYmKGVbY109bFtjXSk7cmV0dXJuIGV9ZS5kYXRhPXthdHRyaWJ1dGVzOnt9fTtjb25zdCB0PXRoaXMuaW5kZXg7dCE9PW51bGwmJihlLmRhdGEuaW5kZXg9e3R5cGU6dC5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLGFycmF5OkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQuYXJyYXkpfSk7Y29uc3Qgbj10aGlzLmF0dHJpYnV0ZXM7Zm9yKGNvbnN0IGwgaW4gbil7Y29uc3QgYz1uW2xdO2UuZGF0YS5hdHRyaWJ1dGVzW2xdPWMudG9KU09OKGUuZGF0YSl9Y29uc3Qgcj17fTtsZXQgcz0hMTtmb3IoY29uc3QgbCBpbiB0aGlzLm1vcnBoQXR0cmlidXRlcyl7Y29uc3QgYz10aGlzLm1vcnBoQXR0cmlidXRlc1tsXSx1PVtdO2ZvcihsZXQgaD0wLGY9Yy5sZW5ndGg7aDxmO2grKyl7Y29uc3QgcD1jW2hdO3UucHVzaChwLnRvSlNPTihlLmRhdGEpKX11Lmxlbmd0aD4wJiYocltsXT11LHM9ITApfXMmJihlLmRhdGEubW9ycGhBdHRyaWJ1dGVzPXIsZS5kYXRhLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPXRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUpO2NvbnN0IGE9dGhpcy5ncm91cHM7YS5sZW5ndGg+MCYmKGUuZGF0YS5ncm91cHM9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhKSkpO2NvbnN0IG89dGhpcy5ib3VuZGluZ1NwaGVyZTtyZXR1cm4gbyE9PW51bGwmJihlLmRhdGEuYm91bmRpbmdTcGhlcmU9e2NlbnRlcjpvLmNlbnRlci50b0FycmF5KCkscmFkaXVzOm8ucmFkaXVzfSksZX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9Y29weShlKXt0aGlzLmluZGV4PW51bGwsdGhpcy5hdHRyaWJ1dGVzPXt9LHRoaXMubW9ycGhBdHRyaWJ1dGVzPXt9LHRoaXMuZ3JvdXBzPVtdLHRoaXMuYm91bmRpbmdCb3g9bnVsbCx0aGlzLmJvdW5kaW5nU3BoZXJlPW51bGw7Y29uc3QgdD17fTt0aGlzLm5hbWU9ZS5uYW1lO2NvbnN0IG49ZS5pbmRleDtuIT09bnVsbCYmdGhpcy5zZXRJbmRleChuLmNsb25lKHQpKTtjb25zdCByPWUuYXR0cmlidXRlcztmb3IoY29uc3QgYyBpbiByKXtjb25zdCB1PXJbY107dGhpcy5zZXRBdHRyaWJ1dGUoYyx1LmNsb25lKHQpKX1jb25zdCBzPWUubW9ycGhBdHRyaWJ1dGVzO2Zvcihjb25zdCBjIGluIHMpe2NvbnN0IHU9W10saD1zW2NdO2ZvcihsZXQgZj0wLHA9aC5sZW5ndGg7ZjxwO2YrKyl1LnB1c2goaFtmXS5jbG9uZSh0KSk7dGhpcy5tb3JwaEF0dHJpYnV0ZXNbY109dX10aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPWUubW9ycGhUYXJnZXRzUmVsYXRpdmU7Y29uc3QgYT1lLmdyb3Vwcztmb3IobGV0IGM9MCx1PWEubGVuZ3RoO2M8dTtjKyspe2NvbnN0IGg9YVtjXTt0aGlzLmFkZEdyb3VwKGguc3RhcnQsaC5jb3VudCxoLm1hdGVyaWFsSW5kZXgpfWNvbnN0IG89ZS5ib3VuZGluZ0JveDtvIT09bnVsbCYmKHRoaXMuYm91bmRpbmdCb3g9by5jbG9uZSgpKTtjb25zdCBsPWUuYm91bmRpbmdTcGhlcmU7cmV0dXJuIGwhPT1udWxsJiYodGhpcy5ib3VuZGluZ1NwaGVyZT1sLmNsb25lKCkpLHRoaXMuZHJhd1JhbmdlLnN0YXJ0PWUuZHJhd1JhbmdlLnN0YXJ0LHRoaXMuZHJhd1JhbmdlLmNvdW50PWUuZHJhd1JhbmdlLmNvdW50LHRoaXMudXNlckRhdGE9ZS51c2VyRGF0YSx0aGlzfWRpc3Bvc2UoKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImRpc3Bvc2UifSl9fWNvbnN0IFdyPW5ldyBydCxobj1uZXcgRHIsbWk9bmV3IGxpLFhyPW5ldyBCLF9pPW5ldyBCLGdpPW5ldyBCLHZpPW5ldyBCLG5yPW5ldyBCLHhpPW5ldyBCLHFyPW5ldyBCLE1pPW5ldyBCO2NsYXNzIHN0IGV4dGVuZHMgTXR7Y29uc3RydWN0b3IoZT1uZXcgQ3QsdD1uZXcgam4pe3N1cGVyKCksdGhpcy5pc01lc2g9ITAsdGhpcy50eXBlPSJNZXNoIix0aGlzLmdlb21ldHJ5PWUsdGhpcy5tYXRlcmlhbD10LHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCl9Y29weShlLHQpe3JldHVybiBzdXBlci5jb3B5KGUsdCksZS5tb3JwaFRhcmdldEluZmx1ZW5jZXMhPT12b2lkIDAmJih0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcz1lLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5zbGljZSgpKSxlLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSE9PXZvaWQgMCYmKHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5PU9iamVjdC5hc3NpZ24oe30sZS5tb3JwaFRhcmdldERpY3Rpb25hcnkpKSx0aGlzLm1hdGVyaWFsPUFycmF5LmlzQXJyYXkoZS5tYXRlcmlhbCk/ZS5tYXRlcmlhbC5zbGljZSgpOmUubWF0ZXJpYWwsdGhpcy5nZW9tZXRyeT1lLmdlb21ldHJ5LHRoaXN9dXBkYXRlTW9ycGhUYXJnZXRzKCl7Y29uc3QgdD10aGlzLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyxuPU9iamVjdC5rZXlzKHQpO2lmKG4ubGVuZ3RoPjApe2NvbnN0IHI9dFtuWzBdXTtpZihyIT09dm9pZCAwKXt0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcz1bXSx0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeT17fTtmb3IobGV0IHM9MCxhPXIubGVuZ3RoO3M8YTtzKyspe2NvbnN0IG89cltzXS5uYW1lfHxTdHJpbmcocyk7dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCgwKSx0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVtvXT1zfX19fWdldFZlcnRleFBvc2l0aW9uKGUsdCl7Y29uc3Qgbj10aGlzLmdlb21ldHJ5LHI9bi5hdHRyaWJ1dGVzLnBvc2l0aW9uLHM9bi5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24sYT1uLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO3QuZnJvbUJ1ZmZlckF0dHJpYnV0ZShyLGUpO2NvbnN0IG89dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7aWYocyYmbyl7eGkuc2V0KDAsMCwwKTtmb3IobGV0IGw9MCxjPXMubGVuZ3RoO2w8YztsKyspe2NvbnN0IHU9b1tsXSxoPXNbbF07dSE9PTAmJihuci5mcm9tQnVmZmVyQXR0cmlidXRlKGgsZSksYT94aS5hZGRTY2FsZWRWZWN0b3IobnIsdSk6eGkuYWRkU2NhbGVkVmVjdG9yKG5yLnN1Yih0KSx1KSl9dC5hZGQoeGkpfXJldHVybiB0fXJheWNhc3QoZSx0KXtjb25zdCBuPXRoaXMuZ2VvbWV0cnkscj10aGlzLm1hdGVyaWFsLHM9dGhpcy5tYXRyaXhXb3JsZDtyIT09dm9pZCAwJiYobi5ib3VuZGluZ1NwaGVyZT09PW51bGwmJm4uY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksbWkuY29weShuLmJvdW5kaW5nU3BoZXJlKSxtaS5hcHBseU1hdHJpeDQocyksaG4uY29weShlLnJheSkucmVjYXN0KGUubmVhciksIShtaS5jb250YWluc1BvaW50KGhuLm9yaWdpbik9PT0hMSYmKGhuLmludGVyc2VjdFNwaGVyZShtaSxYcik9PT1udWxsfHxobi5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQoWHIpPihlLmZhci1lLm5lYXIpKioyKSkmJihXci5jb3B5KHMpLmludmVydCgpLGhuLmNvcHkoZS5yYXkpLmFwcGx5TWF0cml4NChXciksIShuLmJvdW5kaW5nQm94IT09bnVsbCYmaG4uaW50ZXJzZWN0c0JveChuLmJvdW5kaW5nQm94KT09PSExKSYmdGhpcy5fY29tcHV0ZUludGVyc2VjdGlvbnMoZSx0LGhuKSkpfV9jb21wdXRlSW50ZXJzZWN0aW9ucyhlLHQsbil7bGV0IHI7Y29uc3Qgcz10aGlzLmdlb21ldHJ5LGE9dGhpcy5tYXRlcmlhbCxvPXMuaW5kZXgsbD1zLmF0dHJpYnV0ZXMucG9zaXRpb24sYz1zLmF0dHJpYnV0ZXMudXYsdT1zLmF0dHJpYnV0ZXMudXYxLGg9cy5hdHRyaWJ1dGVzLm5vcm1hbCxmPXMuZ3JvdXBzLHA9cy5kcmF3UmFuZ2U7aWYobyE9PW51bGwpaWYoQXJyYXkuaXNBcnJheShhKSlmb3IobGV0IF89MCx4PWYubGVuZ3RoO188eDtfKyspe2NvbnN0IG09ZltfXSxkPWFbbS5tYXRlcmlhbEluZGV4XSxBPU1hdGgubWF4KG0uc3RhcnQscC5zdGFydCksVD1NYXRoLm1pbihvLmNvdW50LE1hdGgubWluKG0uc3RhcnQrbS5jb3VudCxwLnN0YXJ0K3AuY291bnQpKTtmb3IobGV0IE09QSxGPVQ7TTxGO00rPTMpe2NvbnN0IGI9by5nZXRYKE0pLHc9by5nZXRYKE0rMSksVT1vLmdldFgoTSsyKTtyPVNpKHRoaXMsZCxlLG4sYyx1LGgsYix3LFUpLHImJihyLmZhY2VJbmRleD1NYXRoLmZsb29yKE0vMyksci5mYWNlLm1hdGVyaWFsSW5kZXg9bS5tYXRlcmlhbEluZGV4LHQucHVzaChyKSl9fWVsc2V7Y29uc3QgXz1NYXRoLm1heCgwLHAuc3RhcnQpLHg9TWF0aC5taW4oby5jb3VudCxwLnN0YXJ0K3AuY291bnQpO2ZvcihsZXQgbT1fLGQ9eDttPGQ7bSs9Myl7Y29uc3QgQT1vLmdldFgobSksVD1vLmdldFgobSsxKSxNPW8uZ2V0WChtKzIpO3I9U2kodGhpcyxhLGUsbixjLHUsaCxBLFQsTSksciYmKHIuZmFjZUluZGV4PU1hdGguZmxvb3IobS8zKSx0LnB1c2gocikpfX1lbHNlIGlmKGwhPT12b2lkIDApaWYoQXJyYXkuaXNBcnJheShhKSlmb3IobGV0IF89MCx4PWYubGVuZ3RoO188eDtfKyspe2NvbnN0IG09ZltfXSxkPWFbbS5tYXRlcmlhbEluZGV4XSxBPU1hdGgubWF4KG0uc3RhcnQscC5zdGFydCksVD1NYXRoLm1pbihsLmNvdW50LE1hdGgubWluKG0uc3RhcnQrbS5jb3VudCxwLnN0YXJ0K3AuY291bnQpKTtmb3IobGV0IE09QSxGPVQ7TTxGO00rPTMpe2NvbnN0IGI9TSx3PU0rMSxVPU0rMjtyPVNpKHRoaXMsZCxlLG4sYyx1LGgsYix3LFUpLHImJihyLmZhY2VJbmRleD1NYXRoLmZsb29yKE0vMyksci5mYWNlLm1hdGVyaWFsSW5kZXg9bS5tYXRlcmlhbEluZGV4LHQucHVzaChyKSl9fWVsc2V7Y29uc3QgXz1NYXRoLm1heCgwLHAuc3RhcnQpLHg9TWF0aC5taW4obC5jb3VudCxwLnN0YXJ0K3AuY291bnQpO2ZvcihsZXQgbT1fLGQ9eDttPGQ7bSs9Myl7Y29uc3QgQT1tLFQ9bSsxLE09bSsyO3I9U2kodGhpcyxhLGUsbixjLHUsaCxBLFQsTSksciYmKHIuZmFjZUluZGV4PU1hdGguZmxvb3IobS8zKSx0LnB1c2gocikpfX19fWZ1bmN0aW9uIGJhKGksZSx0LG4scixzLGEsbyl7bGV0IGw7aWYoZS5zaWRlPT09MT9sPW4uaW50ZXJzZWN0VHJpYW5nbGUoYSxzLHIsITAsbyk6bD1uLmludGVyc2VjdFRyaWFuZ2xlKHIscyxhLGUuc2lkZT09PTAsbyksbD09PW51bGwpcmV0dXJuIG51bGw7TWkuY29weShvKSxNaS5hcHBseU1hdHJpeDQoaS5tYXRyaXhXb3JsZCk7Y29uc3QgYz10LnJheS5vcmlnaW4uZGlzdGFuY2VUbyhNaSk7cmV0dXJuIGM8dC5uZWFyfHxjPnQuZmFyP251bGw6e2Rpc3RhbmNlOmMscG9pbnQ6TWkuY2xvbmUoKSxvYmplY3Q6aX19ZnVuY3Rpb24gU2koaSxlLHQsbixyLHMsYSxvLGwsYyl7aS5nZXRWZXJ0ZXhQb3NpdGlvbihvLF9pKSxpLmdldFZlcnRleFBvc2l0aW9uKGwsZ2kpLGkuZ2V0VmVydGV4UG9zaXRpb24oYyx2aSk7Y29uc3QgdT1iYShpLGUsdCxuLF9pLGdpLHZpLHFyKTtpZih1KXtjb25zdCBoPW5ldyBCO0l0LmdldEJhcnljb29yZChxcixfaSxnaSx2aSxoKSxyJiYodS51dj1JdC5nZXRJbnRlcnBvbGF0ZWRBdHRyaWJ1dGUocixvLGwsYyxoLG5ldyBMZSkpLHMmJih1LnV2MT1JdC5nZXRJbnRlcnBvbGF0ZWRBdHRyaWJ1dGUocyxvLGwsYyxoLG5ldyBMZSkpLGEmJih1Lm5vcm1hbD1JdC5nZXRJbnRlcnBvbGF0ZWRBdHRyaWJ1dGUoYSxvLGwsYyxoLG5ldyBCKSx1Lm5vcm1hbC5kb3Qobi5kaXJlY3Rpb24pPjAmJnUubm9ybWFsLm11bHRpcGx5U2NhbGFyKC0xKSk7Y29uc3QgZj17YTpvLGI6bCxjLG5vcm1hbDpuZXcgQixtYXRlcmlhbEluZGV4OjB9O0l0LmdldE5vcm1hbChfaSxnaSx2aSxmLm5vcm1hbCksdS5mYWNlPWYsdS5iYXJ5Y29vcmQ9aH1yZXR1cm4gdX1jbGFzcyBRbiBleHRlbmRzIEN0e2NvbnN0cnVjdG9yKGU9MSx0PTEsbj0xLHI9MSxzPTEsYT0xKXtzdXBlcigpLHRoaXMudHlwZT0iQm94R2VvbWV0cnkiLHRoaXMucGFyYW1ldGVycz17d2lkdGg6ZSxoZWlnaHQ6dCxkZXB0aDpuLHdpZHRoU2VnbWVudHM6cixoZWlnaHRTZWdtZW50czpzLGRlcHRoU2VnbWVudHM6YX07Y29uc3Qgbz10aGlzO3I9TWF0aC5mbG9vcihyKSxzPU1hdGguZmxvb3IocyksYT1NYXRoLmZsb29yKGEpO2NvbnN0IGw9W10sYz1bXSx1PVtdLGg9W107bGV0IGY9MCxwPTA7XygieiIsInkiLCJ4IiwtMSwtMSxuLHQsZSxhLHMsMCksXygieiIsInkiLCJ4IiwxLC0xLG4sdCwtZSxhLHMsMSksXygieCIsInoiLCJ5IiwxLDEsZSxuLHQscixhLDIpLF8oIngiLCJ6IiwieSIsMSwtMSxlLG4sLXQscixhLDMpLF8oIngiLCJ5IiwieiIsMSwtMSxlLHQsbixyLHMsNCksXygieCIsInkiLCJ6IiwtMSwtMSxlLHQsLW4scixzLDUpLHRoaXMuc2V0SW5kZXgobCksdGhpcy5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgdW4oYywzKSksdGhpcy5zZXRBdHRyaWJ1dGUoIm5vcm1hbCIsbmV3IHVuKHUsMykpLHRoaXMuc2V0QXR0cmlidXRlKCJ1diIsbmV3IHVuKGgsMikpO2Z1bmN0aW9uIF8oeCxtLGQsQSxULE0sRixiLHcsVSxFKXtjb25zdCBTPU0vdyxSPUYvVSxxPU0vMix6PUYvMixXPWIvMixLPXcrMSxWPVUrMTtsZXQgUT0wLEg9MDtjb25zdCBpZT1uZXcgQjtmb3IobGV0IGNlPTA7Y2U8VjtjZSsrKXtjb25zdCB4ZT1jZSpSLXo7Zm9yKGxldCBVZT0wO1VlPEs7VWUrKyl7Y29uc3QgWWU9VWUqUy1xO2llW3hdPVllKkEsaWVbbV09eGUqVCxpZVtkXT1XLGMucHVzaChpZS54LGllLnksaWUueiksaWVbeF09MCxpZVttXT0wLGllW2RdPWI+MD8xOi0xLHUucHVzaChpZS54LGllLnksaWUueiksaC5wdXNoKFVlL3cpLGgucHVzaCgxLWNlL1UpLFErPTF9fWZvcihsZXQgY2U9MDtjZTxVO2NlKyspZm9yKGxldCB4ZT0wO3hlPHc7eGUrKyl7Y29uc3QgVWU9Zit4ZStLKmNlLFllPWYreGUrSyooY2UrMSksWD1mKyh4ZSsxKStLKihjZSsxKSxlZT1mKyh4ZSsxKStLKmNlO2wucHVzaChVZSxZZSxlZSksbC5wdXNoKFllLFgsZWUpLEgrPTZ9by5hZGRHcm91cChwLEgsRSkscCs9SCxmKz1RfX1jb3B5KGUpe3JldHVybiBzdXBlci5jb3B5KGUpLHRoaXMucGFyYW1ldGVycz1PYmplY3QuYXNzaWduKHt9LGUucGFyYW1ldGVycyksdGhpc31zdGF0aWMgZnJvbUpTT04oZSl7cmV0dXJuIG5ldyBRbihlLndpZHRoLGUuaGVpZ2h0LGUuZGVwdGgsZS53aWR0aFNlZ21lbnRzLGUuaGVpZ2h0U2VnbWVudHMsZS5kZXB0aFNlZ21lbnRzKX19ZnVuY3Rpb24gRm4oaSl7Y29uc3QgZT17fTtmb3IoY29uc3QgdCBpbiBpKXtlW3RdPXt9O2Zvcihjb25zdCBuIGluIGlbdF0pe2NvbnN0IHI9aVt0XVtuXTtyJiYoci5pc0NvbG9yfHxyLmlzTWF0cml4M3x8ci5pc01hdHJpeDR8fHIuaXNWZWN0b3IyfHxyLmlzVmVjdG9yM3x8ci5pc1ZlY3RvcjR8fHIuaXNUZXh0dXJlfHxyLmlzUXVhdGVybmlvbik/ci5pc1JlbmRlclRhcmdldFRleHR1cmU/KGNvbnNvbGUud2FybigiVW5pZm9ybXNVdGlsczogVGV4dHVyZXMgb2YgcmVuZGVyIHRhcmdldHMgY2Fubm90IGJlIGNsb25lZCB2aWEgY2xvbmVVbmlmb3JtcygpIG9yIG1lcmdlVW5pZm9ybXMoKS4iKSxlW3RdW25dPW51bGwpOmVbdF1bbl09ci5jbG9uZSgpOkFycmF5LmlzQXJyYXkocik/ZVt0XVtuXT1yLnNsaWNlKCk6ZVt0XVtuXT1yfX1yZXR1cm4gZX1mdW5jdGlvbiB4dChpKXtjb25zdCBlPXt9O2ZvcihsZXQgdD0wO3Q8aS5sZW5ndGg7dCsrKXtjb25zdCBuPUZuKGlbdF0pO2Zvcihjb25zdCByIGluIG4pZVtyXT1uW3JdfXJldHVybiBlfWZ1bmN0aW9uIHdhKGkpe2NvbnN0IGU9W107Zm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0KyspZS5wdXNoKGlbdF0uY2xvbmUoKSk7cmV0dXJuIGV9ZnVuY3Rpb24gWXIoaSl7Y29uc3QgZT1pLmdldFJlbmRlclRhcmdldCgpO3JldHVybiBlPT09bnVsbD9pLm91dHB1dENvbG9yU3BhY2U6ZS5pc1hSUmVuZGVyVGFyZ2V0PT09ITA/ZS50ZXh0dXJlLmNvbG9yU3BhY2U6QmUud29ya2luZ0NvbG9yU3BhY2V9Y29uc3QgUmE9e2Nsb25lOkZuLG1lcmdlOnh0fTt2YXIgQ2E9YHZvaWQgbWFpbigpIHsKCWdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTsKfWAsUGE9YHZvaWQgbWFpbigpIHsKCWdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApOwp9YDtjbGFzcyBodCBleHRlbmRzIEtue3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJTaGFkZXJNYXRlcmlhbCJ9Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLmlzU2hhZGVyTWF0ZXJpYWw9ITAsdGhpcy5kZWZpbmVzPXt9LHRoaXMudW5pZm9ybXM9e30sdGhpcy51bmlmb3Jtc0dyb3Vwcz1bXSx0aGlzLnZlcnRleFNoYWRlcj1DYSx0aGlzLmZyYWdtZW50U2hhZGVyPVBhLHRoaXMubGluZXdpZHRoPTEsdGhpcy53aXJlZnJhbWU9ITEsdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9MSx0aGlzLmZvZz0hMSx0aGlzLmxpZ2h0cz0hMSx0aGlzLmNsaXBwaW5nPSExLHRoaXMuZm9yY2VTaW5nbGVQYXNzPSEwLHRoaXMuZXh0ZW5zaW9ucz17Y2xpcEN1bGxEaXN0YW5jZTohMSxtdWx0aURyYXc6ITF9LHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcz17Y29sb3I6WzEsMSwxXSx1djpbMCwwXSx1djE6WzAsMF19LHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZT12b2lkIDAsdGhpcy51bmlmb3Jtc05lZWRVcGRhdGU9ITEsdGhpcy5nbHNsVmVyc2lvbj1udWxsLGUhPT12b2lkIDAmJnRoaXMuc2V0VmFsdWVzKGUpfWNvcHkoZSl7cmV0dXJuIHN1cGVyLmNvcHkoZSksdGhpcy5mcmFnbWVudFNoYWRlcj1lLmZyYWdtZW50U2hhZGVyLHRoaXMudmVydGV4U2hhZGVyPWUudmVydGV4U2hhZGVyLHRoaXMudW5pZm9ybXM9Rm4oZS51bmlmb3JtcyksdGhpcy51bmlmb3Jtc0dyb3Vwcz13YShlLnVuaWZvcm1zR3JvdXBzKSx0aGlzLmRlZmluZXM9T2JqZWN0LmFzc2lnbih7fSxlLmRlZmluZXMpLHRoaXMud2lyZWZyYW1lPWUud2lyZWZyYW1lLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPWUud2lyZWZyYW1lTGluZXdpZHRoLHRoaXMuZm9nPWUuZm9nLHRoaXMubGlnaHRzPWUubGlnaHRzLHRoaXMuY2xpcHBpbmc9ZS5jbGlwcGluZyx0aGlzLmV4dGVuc2lvbnM9T2JqZWN0LmFzc2lnbih7fSxlLmV4dGVuc2lvbnMpLHRoaXMuZ2xzbFZlcnNpb249ZS5nbHNsVmVyc2lvbix0aGlzfXRvSlNPTihlKXtjb25zdCB0PXN1cGVyLnRvSlNPTihlKTt0Lmdsc2xWZXJzaW9uPXRoaXMuZ2xzbFZlcnNpb24sdC51bmlmb3Jtcz17fTtmb3IoY29uc3QgciBpbiB0aGlzLnVuaWZvcm1zKXtjb25zdCBhPXRoaXMudW5pZm9ybXNbcl0udmFsdWU7YSYmYS5pc1RleHR1cmU/dC51bmlmb3Jtc1tyXT17dHlwZToidCIsdmFsdWU6YS50b0pTT04oZSkudXVpZH06YSYmYS5pc0NvbG9yP3QudW5pZm9ybXNbcl09e3R5cGU6ImMiLHZhbHVlOmEuZ2V0SGV4KCl9OmEmJmEuaXNWZWN0b3IyP3QudW5pZm9ybXNbcl09e3R5cGU6InYyIix2YWx1ZTphLnRvQXJyYXkoKX06YSYmYS5pc1ZlY3RvcjM/dC51bmlmb3Jtc1tyXT17dHlwZToidjMiLHZhbHVlOmEudG9BcnJheSgpfTphJiZhLmlzVmVjdG9yND90LnVuaWZvcm1zW3JdPXt0eXBlOiJ2NCIsdmFsdWU6YS50b0FycmF5KCl9OmEmJmEuaXNNYXRyaXgzP3QudW5pZm9ybXNbcl09e3R5cGU6Im0zIix2YWx1ZTphLnRvQXJyYXkoKX06YSYmYS5pc01hdHJpeDQ/dC51bmlmb3Jtc1tyXT17dHlwZToibTQiLHZhbHVlOmEudG9BcnJheSgpfTp0LnVuaWZvcm1zW3JdPXt2YWx1ZTphfX1PYmplY3Qua2V5cyh0aGlzLmRlZmluZXMpLmxlbmd0aD4wJiYodC5kZWZpbmVzPXRoaXMuZGVmaW5lcyksdC52ZXJ0ZXhTaGFkZXI9dGhpcy52ZXJ0ZXhTaGFkZXIsdC5mcmFnbWVudFNoYWRlcj10aGlzLmZyYWdtZW50U2hhZGVyLHQubGlnaHRzPXRoaXMubGlnaHRzLHQuY2xpcHBpbmc9dGhpcy5jbGlwcGluZztjb25zdCBuPXt9O2Zvcihjb25zdCByIGluIHRoaXMuZXh0ZW5zaW9ucyl0aGlzLmV4dGVuc2lvbnNbcl09PT0hMCYmKG5bcl09ITApO3JldHVybiBPYmplY3Qua2V5cyhuKS5sZW5ndGg+MCYmKHQuZXh0ZW5zaW9ucz1uKSx0fX1jbGFzcyAkciBleHRlbmRzIE10e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmlzQ2FtZXJhPSEwLHRoaXMudHlwZT0iQ2FtZXJhIix0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZT1uZXcgcnQsdGhpcy5wcm9qZWN0aW9uTWF0cml4PW5ldyBydCx0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlPW5ldyBydCx0aGlzLmNvb3JkaW5hdGVTeXN0ZW09MmUzfWNvcHkoZSx0KXtyZXR1cm4gc3VwZXIuY29weShlLHQpLHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoZS5tYXRyaXhXb3JsZEludmVyc2UpLHRoaXMucHJvamVjdGlvbk1hdHJpeC5jb3B5KGUucHJvamVjdGlvbk1hdHJpeCksdGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KGUucHJvamVjdGlvbk1hdHJpeEludmVyc2UpLHRoaXMuY29vcmRpbmF0ZVN5c3RlbT1lLmNvb3JkaW5hdGVTeXN0ZW0sdGhpc31nZXRXb3JsZERpcmVjdGlvbihlKXtyZXR1cm4gc3VwZXIuZ2V0V29ybGREaXJlY3Rpb24oZSkubmVnYXRlKCl9dXBkYXRlTWF0cml4V29ybGQoZSl7c3VwZXIudXBkYXRlTWF0cml4V29ybGQoZSksdGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKX11cGRhdGVXb3JsZE1hdHJpeChlLHQpe3N1cGVyLnVwZGF0ZVdvcmxkTWF0cml4KGUsdCksdGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9fWNvbnN0IHNuPW5ldyBCLFpyPW5ldyBMZSxLcj1uZXcgTGU7Y2xhc3MgTnQgZXh0ZW5kcyAkcntjb25zdHJ1Y3RvcihlPTUwLHQ9MSxuPS4xLHI9MmUzKXtzdXBlcigpLHRoaXMuaXNQZXJzcGVjdGl2ZUNhbWVyYT0hMCx0aGlzLnR5cGU9IlBlcnNwZWN0aXZlQ2FtZXJhIix0aGlzLmZvdj1lLHRoaXMuem9vbT0xLHRoaXMubmVhcj1uLHRoaXMuZmFyPXIsdGhpcy5mb2N1cz0xMCx0aGlzLmFzcGVjdD10LHRoaXMudmlldz1udWxsLHRoaXMuZmlsbUdhdWdlPTM1LHRoaXMuZmlsbU9mZnNldD0wLHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfWNvcHkoZSx0KXtyZXR1cm4gc3VwZXIuY29weShlLHQpLHRoaXMuZm92PWUuZm92LHRoaXMuem9vbT1lLnpvb20sdGhpcy5uZWFyPWUubmVhcix0aGlzLmZhcj1lLmZhcix0aGlzLmZvY3VzPWUuZm9jdXMsdGhpcy5hc3BlY3Q9ZS5hc3BlY3QsdGhpcy52aWV3PWUudmlldz09PW51bGw/bnVsbDpPYmplY3QuYXNzaWduKHt9LGUudmlldyksdGhpcy5maWxtR2F1Z2U9ZS5maWxtR2F1Z2UsdGhpcy5maWxtT2Zmc2V0PWUuZmlsbU9mZnNldCx0aGlzfXNldEZvY2FsTGVuZ3RoKGUpe2NvbnN0IHQ9LjUqdGhpcy5nZXRGaWxtSGVpZ2h0KCkvZTt0aGlzLmZvdj1WbioyKk1hdGguYXRhbih0KSx0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX1nZXRGb2NhbExlbmd0aCgpe2NvbnN0IGU9TWF0aC50YW4oSG4qLjUqdGhpcy5mb3YpO3JldHVybiAuNSp0aGlzLmdldEZpbG1IZWlnaHQoKS9lfWdldEVmZmVjdGl2ZUZPVigpe3JldHVybiBWbioyKk1hdGguYXRhbihNYXRoLnRhbihIbiouNSp0aGlzLmZvdikvdGhpcy56b29tKX1nZXRGaWxtV2lkdGgoKXtyZXR1cm4gdGhpcy5maWxtR2F1Z2UqTWF0aC5taW4odGhpcy5hc3BlY3QsMSl9Z2V0RmlsbUhlaWdodCgpe3JldHVybiB0aGlzLmZpbG1HYXVnZS9NYXRoLm1heCh0aGlzLmFzcGVjdCwxKX1nZXRWaWV3Qm91bmRzKGUsdCxuKXtzbi5zZXQoLTEsLTEsLjUpLmFwcGx5TWF0cml4NCh0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKSx0LnNldChzbi54LHNuLnkpLm11bHRpcGx5U2NhbGFyKC1lL3NuLnopLHNuLnNldCgxLDEsLjUpLmFwcGx5TWF0cml4NCh0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKSxuLnNldChzbi54LHNuLnkpLm11bHRpcGx5U2NhbGFyKC1lL3NuLnopfWdldFZpZXdTaXplKGUsdCl7cmV0dXJuIHRoaXMuZ2V0Vmlld0JvdW5kcyhlLFpyLEtyKSx0LnN1YlZlY3RvcnMoS3IsWnIpfXNldFZpZXdPZmZzZXQoZSx0LG4scixzLGEpe3RoaXMuYXNwZWN0PWUvdCx0aGlzLnZpZXc9PT1udWxsJiYodGhpcy52aWV3PXtlbmFibGVkOiEwLGZ1bGxXaWR0aDoxLGZ1bGxIZWlnaHQ6MSxvZmZzZXRYOjAsb2Zmc2V0WTowLHdpZHRoOjEsaGVpZ2h0OjF9KSx0aGlzLnZpZXcuZW5hYmxlZD0hMCx0aGlzLnZpZXcuZnVsbFdpZHRoPWUsdGhpcy52aWV3LmZ1bGxIZWlnaHQ9dCx0aGlzLnZpZXcub2Zmc2V0WD1uLHRoaXMudmlldy5vZmZzZXRZPXIsdGhpcy52aWV3LndpZHRoPXMsdGhpcy52aWV3LmhlaWdodD1hLHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfWNsZWFyVmlld09mZnNldCgpe3RoaXMudmlldyE9PW51bGwmJih0aGlzLnZpZXcuZW5hYmxlZD0hMSksdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9dXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpe2NvbnN0IGU9dGhpcy5uZWFyO2xldCB0PWUqTWF0aC50YW4oSG4qLjUqdGhpcy5mb3YpL3RoaXMuem9vbSxuPTIqdCxyPXRoaXMuYXNwZWN0Km4scz0tLjUqcjtjb25zdCBhPXRoaXMudmlldztpZih0aGlzLnZpZXchPT1udWxsJiZ0aGlzLnZpZXcuZW5hYmxlZCl7Y29uc3QgbD1hLmZ1bGxXaWR0aCxjPWEuZnVsbEhlaWdodDtzKz1hLm9mZnNldFgqci9sLHQtPWEub2Zmc2V0WSpuL2Mscio9YS53aWR0aC9sLG4qPWEuaGVpZ2h0L2N9Y29uc3Qgbz10aGlzLmZpbG1PZmZzZXQ7byE9PTAmJihzKz1lKm8vdGhpcy5nZXRGaWxtV2lkdGgoKSksdGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VQZXJzcGVjdGl2ZShzLHMrcix0LHQtbixlLHRoaXMuZmFyLHRoaXMuY29vcmRpbmF0ZVN5c3RlbSksdGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KHRoaXMucHJvamVjdGlvbk1hdHJpeCkuaW52ZXJ0KCl9dG9KU09OKGUpe2NvbnN0IHQ9c3VwZXIudG9KU09OKGUpO3JldHVybiB0Lm9iamVjdC5mb3Y9dGhpcy5mb3YsdC5vYmplY3Quem9vbT10aGlzLnpvb20sdC5vYmplY3QubmVhcj10aGlzLm5lYXIsdC5vYmplY3QuZmFyPXRoaXMuZmFyLHQub2JqZWN0LmZvY3VzPXRoaXMuZm9jdXMsdC5vYmplY3QuYXNwZWN0PXRoaXMuYXNwZWN0LHRoaXMudmlldyE9PW51bGwmJih0Lm9iamVjdC52aWV3PU9iamVjdC5hc3NpZ24oe30sdGhpcy52aWV3KSksdC5vYmplY3QuZmlsbUdhdWdlPXRoaXMuZmlsbUdhdWdlLHQub2JqZWN0LmZpbG1PZmZzZXQ9dGhpcy5maWxtT2Zmc2V0LHR9fWNvbnN0IEluPS05MCxObj0xO2NsYXNzIERhIGV4dGVuZHMgTXR7Y29uc3RydWN0b3IoZSx0LG4pe3N1cGVyKCksdGhpcy50eXBlPSJDdWJlQ2FtZXJhIix0aGlzLnJlbmRlclRhcmdldD1uLHRoaXMuY29vcmRpbmF0ZVN5c3RlbT1udWxsLHRoaXMuYWN0aXZlTWlwbWFwTGV2ZWw9MDtjb25zdCByPW5ldyBOdChJbixObixlLHQpO3IubGF5ZXJzPXRoaXMubGF5ZXJzLHRoaXMuYWRkKHIpO2NvbnN0IHM9bmV3IE50KEluLE5uLGUsdCk7cy5sYXllcnM9dGhpcy5sYXllcnMsdGhpcy5hZGQocyk7Y29uc3QgYT1uZXcgTnQoSW4sTm4sZSx0KTthLmxheWVycz10aGlzLmxheWVycyx0aGlzLmFkZChhKTtjb25zdCBvPW5ldyBOdChJbixObixlLHQpO28ubGF5ZXJzPXRoaXMubGF5ZXJzLHRoaXMuYWRkKG8pO2NvbnN0IGw9bmV3IE50KEluLE5uLGUsdCk7bC5sYXllcnM9dGhpcy5sYXllcnMsdGhpcy5hZGQobCk7Y29uc3QgYz1uZXcgTnQoSW4sTm4sZSx0KTtjLmxheWVycz10aGlzLmxheWVycyx0aGlzLmFkZChjKX11cGRhdGVDb29yZGluYXRlU3lzdGVtKCl7Y29uc3QgZT10aGlzLmNvb3JkaW5hdGVTeXN0ZW0sdD10aGlzLmNoaWxkcmVuLmNvbmNhdCgpLFtuLHIscyxhLG8sbF09dDtmb3IoY29uc3QgYyBvZiB0KXRoaXMucmVtb3ZlKGMpO2lmKGU9PT0yZTMpbi51cC5zZXQoMCwxLDApLG4ubG9va0F0KDEsMCwwKSxyLnVwLnNldCgwLDEsMCksci5sb29rQXQoLTEsMCwwKSxzLnVwLnNldCgwLDAsLTEpLHMubG9va0F0KDAsMSwwKSxhLnVwLnNldCgwLDAsMSksYS5sb29rQXQoMCwtMSwwKSxvLnVwLnNldCgwLDEsMCksby5sb29rQXQoMCwwLDEpLGwudXAuc2V0KDAsMSwwKSxsLmxvb2tBdCgwLDAsLTEpO2Vsc2UgaWYoZT09PTIwMDEpbi51cC5zZXQoMCwtMSwwKSxuLmxvb2tBdCgtMSwwLDApLHIudXAuc2V0KDAsLTEsMCksci5sb29rQXQoMSwwLDApLHMudXAuc2V0KDAsMCwxKSxzLmxvb2tBdCgwLDEsMCksYS51cC5zZXQoMCwwLC0xKSxhLmxvb2tBdCgwLC0xLDApLG8udXAuc2V0KDAsLTEsMCksby5sb29rQXQoMCwwLDEpLGwudXAuc2V0KDAsLTEsMCksbC5sb29rQXQoMCwwLC0xKTtlbHNlIHRocm93IG5ldyBFcnJvcigiVEhSRUUuQ3ViZUNhbWVyYS51cGRhdGVDb29yZGluYXRlU3lzdGVtKCk6IEludmFsaWQgY29vcmRpbmF0ZSBzeXN0ZW06ICIrZSk7Zm9yKGNvbnN0IGMgb2YgdCl0aGlzLmFkZChjKSxjLnVwZGF0ZU1hdHJpeFdvcmxkKCl9dXBkYXRlKGUsdCl7dGhpcy5wYXJlbnQ9PT1udWxsJiZ0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7Y29uc3R7cmVuZGVyVGFyZ2V0Om4sYWN0aXZlTWlwbWFwTGV2ZWw6cn09dGhpczt0aGlzLmNvb3JkaW5hdGVTeXN0ZW0hPT1lLmNvb3JkaW5hdGVTeXN0ZW0mJih0aGlzLmNvb3JkaW5hdGVTeXN0ZW09ZS5jb29yZGluYXRlU3lzdGVtLHRoaXMudXBkYXRlQ29vcmRpbmF0ZVN5c3RlbSgpKTtjb25zdFtzLGEsbyxsLGMsdV09dGhpcy5jaGlsZHJlbixoPWUuZ2V0UmVuZGVyVGFyZ2V0KCksZj1lLmdldEFjdGl2ZUN1YmVGYWNlKCkscD1lLmdldEFjdGl2ZU1pcG1hcExldmVsKCksXz1lLnhyLmVuYWJsZWQ7ZS54ci5lbmFibGVkPSExO2NvbnN0IHg9bi50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztuLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzPSExLGUuc2V0UmVuZGVyVGFyZ2V0KG4sMCxyKSxlLnJlbmRlcih0LHMpLGUuc2V0UmVuZGVyVGFyZ2V0KG4sMSxyKSxlLnJlbmRlcih0LGEpLGUuc2V0UmVuZGVyVGFyZ2V0KG4sMixyKSxlLnJlbmRlcih0LG8pLGUuc2V0UmVuZGVyVGFyZ2V0KG4sMyxyKSxlLnJlbmRlcih0LGwpLGUuc2V0UmVuZGVyVGFyZ2V0KG4sNCxyKSxlLnJlbmRlcih0LGMpLG4udGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM9eCxlLnNldFJlbmRlclRhcmdldChuLDUsciksZS5yZW5kZXIodCx1KSxlLnNldFJlbmRlclRhcmdldChoLGYscCksZS54ci5lbmFibGVkPV8sbi50ZXh0dXJlLm5lZWRzUE1SRU1VcGRhdGU9ITB9fWNsYXNzIGpyIGV4dGVuZHMgdnR7Y29uc3RydWN0b3IoZSx0LG4scixzLGEsbyxsLGMsdSl7ZT1lIT09dm9pZCAwP2U6W10sdD10IT09dm9pZCAwP3Q6MzAxLHN1cGVyKGUsdCxuLHIscyxhLG8sbCxjLHUpLHRoaXMuaXNDdWJlVGV4dHVyZT0hMCx0aGlzLmZsaXBZPSExfWdldCBpbWFnZXMoKXtyZXR1cm4gdGhpcy5pbWFnZX1zZXQgaW1hZ2VzKGUpe3RoaXMuaW1hZ2U9ZX19Y2xhc3MgTGEgZXh0ZW5kcyBKdHtjb25zdHJ1Y3RvcihlPTEsdD17fSl7c3VwZXIoZSxlLHQpLHRoaXMuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQ9ITA7Y29uc3Qgbj17d2lkdGg6ZSxoZWlnaHQ6ZSxkZXB0aDoxfSxyPVtuLG4sbixuLG4sbl07dGhpcy50ZXh0dXJlPW5ldyBqcihyLHQubWFwcGluZyx0LndyYXBTLHQud3JhcFQsdC5tYWdGaWx0ZXIsdC5taW5GaWx0ZXIsdC5mb3JtYXQsdC50eXBlLHQuYW5pc290cm9weSx0LmNvbG9yU3BhY2UpLHRoaXMudGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmU9ITAsdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcz10LmdlbmVyYXRlTWlwbWFwcyE9PXZvaWQgMD90LmdlbmVyYXRlTWlwbWFwczohMSx0aGlzLnRleHR1cmUubWluRmlsdGVyPXQubWluRmlsdGVyIT09dm9pZCAwP3QubWluRmlsdGVyOjEwMDZ9ZnJvbUVxdWlyZWN0YW5ndWxhclRleHR1cmUoZSx0KXt0aGlzLnRleHR1cmUudHlwZT10LnR5cGUsdGhpcy50ZXh0dXJlLmNvbG9yU3BhY2U9dC5jb2xvclNwYWNlLHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM9dC5nZW5lcmF0ZU1pcG1hcHMsdGhpcy50ZXh0dXJlLm1pbkZpbHRlcj10Lm1pbkZpbHRlcix0aGlzLnRleHR1cmUubWFnRmlsdGVyPXQubWFnRmlsdGVyO2NvbnN0IG49e3VuaWZvcm1zOnt0RXF1aXJlY3Q6e3ZhbHVlOm51bGx9fSx2ZXJ0ZXhTaGFkZXI6YAoKCQkJCXZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247CgoJCQkJdmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHsKCgkJCQkJcmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7CgoJCQkJfQoKCQkJCXZvaWQgbWFpbigpIHsKCgkJCQkJdldvcmxkRGlyZWN0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTsKCgkJCQkJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCQkJCQkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CgoJCQkJfQoJCQlgLGZyYWdtZW50U2hhZGVyOmAKCgkJCQl1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7CgoJCQkJdmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjsKCgkJCQkjaW5jbHVkZSA8Y29tbW9uPgoKCQkJCXZvaWQgbWFpbigpIHsKCgkJCQkJdmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHZXb3JsZERpcmVjdGlvbiApOwoKCQkJCQl2ZWMyIHNhbXBsZVVWID0gZXF1aXJlY3RVdiggZGlyZWN0aW9uICk7CgoJCQkJCWdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdEVxdWlyZWN0LCBzYW1wbGVVViApOwoKCQkJCX0KCQkJYH0scj1uZXcgUW4oNSw1LDUpLHM9bmV3IGh0KHtuYW1lOiJDdWJlbWFwRnJvbUVxdWlyZWN0Iix1bmlmb3JtczpGbihuLnVuaWZvcm1zKSx2ZXJ0ZXhTaGFkZXI6bi52ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXI6bi5mcmFnbWVudFNoYWRlcixzaWRlOjEsYmxlbmRpbmc6MH0pO3MudW5pZm9ybXMudEVxdWlyZWN0LnZhbHVlPXQ7Y29uc3QgYT1uZXcgc3QocixzKSxvPXQubWluRmlsdGVyO3JldHVybiB0Lm1pbkZpbHRlcj09PTEwMDgmJih0Lm1pbkZpbHRlcj0xMDA2KSxuZXcgRGEoMSwxMCx0aGlzKS51cGRhdGUoZSxhKSx0Lm1pbkZpbHRlcj1vLGEuZ2VvbWV0cnkuZGlzcG9zZSgpLGEubWF0ZXJpYWwuZGlzcG9zZSgpLHRoaXN9Y2xlYXIoZSx0LG4scil7Y29uc3Qgcz1lLmdldFJlbmRlclRhcmdldCgpO2ZvcihsZXQgYT0wO2E8NjthKyspZS5zZXRSZW5kZXJUYXJnZXQodGhpcyxhKSxlLmNsZWFyKHQsbixyKTtlLnNldFJlbmRlclRhcmdldChzKX19Y29uc3QgaXI9bmV3IEIsVWE9bmV3IEIsRmE9bmV3IHdlO2NsYXNzIGRue2NvbnN0cnVjdG9yKGU9bmV3IEIoMSwwLDApLHQ9MCl7dGhpcy5pc1BsYW5lPSEwLHRoaXMubm9ybWFsPWUsdGhpcy5jb25zdGFudD10fXNldChlLHQpe3JldHVybiB0aGlzLm5vcm1hbC5jb3B5KGUpLHRoaXMuY29uc3RhbnQ9dCx0aGlzfXNldENvbXBvbmVudHMoZSx0LG4scil7cmV0dXJuIHRoaXMubm9ybWFsLnNldChlLHQsbiksdGhpcy5jb25zdGFudD1yLHRoaXN9c2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoZSx0KXtyZXR1cm4gdGhpcy5ub3JtYWwuY29weShlKSx0aGlzLmNvbnN0YW50PS10LmRvdCh0aGlzLm5vcm1hbCksdGhpc31zZXRGcm9tQ29wbGFuYXJQb2ludHMoZSx0LG4pe2NvbnN0IHI9aXIuc3ViVmVjdG9ycyhuLHQpLmNyb3NzKFVhLnN1YlZlY3RvcnMoZSx0KSkubm9ybWFsaXplKCk7cmV0dXJuIHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQocixlKSx0aGlzfWNvcHkoZSl7cmV0dXJuIHRoaXMubm9ybWFsLmNvcHkoZS5ub3JtYWwpLHRoaXMuY29uc3RhbnQ9ZS5jb25zdGFudCx0aGlzfW5vcm1hbGl6ZSgpe2NvbnN0IGU9MS90aGlzLm5vcm1hbC5sZW5ndGgoKTtyZXR1cm4gdGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoZSksdGhpcy5jb25zdGFudCo9ZSx0aGlzfW5lZ2F0ZSgpe3JldHVybiB0aGlzLmNvbnN0YW50Kj0tMSx0aGlzLm5vcm1hbC5uZWdhdGUoKSx0aGlzfWRpc3RhbmNlVG9Qb2ludChlKXtyZXR1cm4gdGhpcy5ub3JtYWwuZG90KGUpK3RoaXMuY29uc3RhbnR9ZGlzdGFuY2VUb1NwaGVyZShlKXtyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoZS5jZW50ZXIpLWUucmFkaXVzfXByb2plY3RQb2ludChlLHQpe3JldHVybiB0LmNvcHkoZSkuYWRkU2NhbGVkVmVjdG9yKHRoaXMubm9ybWFsLC10aGlzLmRpc3RhbmNlVG9Qb2ludChlKSl9aW50ZXJzZWN0TGluZShlLHQpe2NvbnN0IG49ZS5kZWx0YShpcikscj10aGlzLm5vcm1hbC5kb3Qobik7aWYocj09PTApcmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KGUuc3RhcnQpPT09MD90LmNvcHkoZS5zdGFydCk6bnVsbDtjb25zdCBzPS0oZS5zdGFydC5kb3QodGhpcy5ub3JtYWwpK3RoaXMuY29uc3RhbnQpL3I7cmV0dXJuIHM8MHx8cz4xP251bGw6dC5jb3B5KGUuc3RhcnQpLmFkZFNjYWxlZFZlY3RvcihuLHMpfWludGVyc2VjdHNMaW5lKGUpe2NvbnN0IHQ9dGhpcy5kaXN0YW5jZVRvUG9pbnQoZS5zdGFydCksbj10aGlzLmRpc3RhbmNlVG9Qb2ludChlLmVuZCk7cmV0dXJuIHQ8MCYmbj4wfHxuPDAmJnQ+MH1pbnRlcnNlY3RzQm94KGUpe3JldHVybiBlLmludGVyc2VjdHNQbGFuZSh0aGlzKX1pbnRlcnNlY3RzU3BoZXJlKGUpe3JldHVybiBlLmludGVyc2VjdHNQbGFuZSh0aGlzKX1jb3BsYW5hclBvaW50KGUpe3JldHVybiBlLmNvcHkodGhpcy5ub3JtYWwpLm11bHRpcGx5U2NhbGFyKC10aGlzLmNvbnN0YW50KX1hcHBseU1hdHJpeDQoZSx0KXtjb25zdCBuPXR8fEZhLmdldE5vcm1hbE1hdHJpeChlKSxyPXRoaXMuY29wbGFuYXJQb2ludChpcikuYXBwbHlNYXRyaXg0KGUpLHM9dGhpcy5ub3JtYWwuYXBwbHlNYXRyaXgzKG4pLm5vcm1hbGl6ZSgpO3JldHVybiB0aGlzLmNvbnN0YW50PS1yLmRvdChzKSx0aGlzfXRyYW5zbGF0ZShlKXtyZXR1cm4gdGhpcy5jb25zdGFudC09ZS5kb3QodGhpcy5ub3JtYWwpLHRoaXN9ZXF1YWxzKGUpe3JldHVybiBlLm5vcm1hbC5lcXVhbHModGhpcy5ub3JtYWwpJiZlLmNvbnN0YW50PT09dGhpcy5jb25zdGFudH1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9fWNvbnN0IGZuPW5ldyBsaSxFaT1uZXcgQjtjbGFzcyBKcntjb25zdHJ1Y3RvcihlPW5ldyBkbix0PW5ldyBkbixuPW5ldyBkbixyPW5ldyBkbixzPW5ldyBkbixhPW5ldyBkbil7dGhpcy5wbGFuZXM9W2UsdCxuLHIscyxhXX1zZXQoZSx0LG4scixzLGEpe2NvbnN0IG89dGhpcy5wbGFuZXM7cmV0dXJuIG9bMF0uY29weShlKSxvWzFdLmNvcHkodCksb1syXS5jb3B5KG4pLG9bM10uY29weShyKSxvWzRdLmNvcHkocyksb1s1XS5jb3B5KGEpLHRoaXN9Y29weShlKXtjb25zdCB0PXRoaXMucGxhbmVzO2ZvcihsZXQgbj0wO248NjtuKyspdFtuXS5jb3B5KGUucGxhbmVzW25dKTtyZXR1cm4gdGhpc31zZXRGcm9tUHJvamVjdGlvbk1hdHJpeChlLHQ9MmUzKXtjb25zdCBuPXRoaXMucGxhbmVzLHI9ZS5lbGVtZW50cyxzPXJbMF0sYT1yWzFdLG89clsyXSxsPXJbM10sYz1yWzRdLHU9cls1XSxoPXJbNl0sZj1yWzddLHA9cls4XSxfPXJbOV0seD1yWzEwXSxtPXJbMTFdLGQ9clsxMl0sQT1yWzEzXSxUPXJbMTRdLE09clsxNV07aWYoblswXS5zZXRDb21wb25lbnRzKGwtcyxmLWMsbS1wLE0tZCkubm9ybWFsaXplKCksblsxXS5zZXRDb21wb25lbnRzKGwrcyxmK2MsbStwLE0rZCkubm9ybWFsaXplKCksblsyXS5zZXRDb21wb25lbnRzKGwrYSxmK3UsbStfLE0rQSkubm9ybWFsaXplKCksblszXS5zZXRDb21wb25lbnRzKGwtYSxmLXUsbS1fLE0tQSkubm9ybWFsaXplKCksbls0XS5zZXRDb21wb25lbnRzKGwtbyxmLWgsbS14LE0tVCkubm9ybWFsaXplKCksdD09PTJlMyluWzVdLnNldENvbXBvbmVudHMobCtvLGYraCxtK3gsTStUKS5ub3JtYWxpemUoKTtlbHNlIGlmKHQ9PT0yMDAxKW5bNV0uc2V0Q29tcG9uZW50cyhvLGgseCxUKS5ub3JtYWxpemUoKTtlbHNlIHRocm93IG5ldyBFcnJvcigiVEhSRUUuRnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeCgpOiBJbnZhbGlkIGNvb3JkaW5hdGUgc3lzdGVtOiAiK3QpO3JldHVybiB0aGlzfWludGVyc2VjdHNPYmplY3QoZSl7aWYoZS5ib3VuZGluZ1NwaGVyZSE9PXZvaWQgMCllLmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmZS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKSxmbi5jb3B5KGUuYm91bmRpbmdTcGhlcmUpLmFwcGx5TWF0cml4NChlLm1hdHJpeFdvcmxkKTtlbHNle2NvbnN0IHQ9ZS5nZW9tZXRyeTt0LmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmdC5jb21wdXRlQm91bmRpbmdTcGhlcmUoKSxmbi5jb3B5KHQuYm91bmRpbmdTcGhlcmUpLmFwcGx5TWF0cml4NChlLm1hdHJpeFdvcmxkKX1yZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKGZuKX1pbnRlcnNlY3RzU3ByaXRlKGUpe3JldHVybiBmbi5jZW50ZXIuc2V0KDAsMCwwKSxmbi5yYWRpdXM9LjcwNzEwNjc4MTE4NjU0NzYsZm4uYXBwbHlNYXRyaXg0KGUubWF0cml4V29ybGQpLHRoaXMuaW50ZXJzZWN0c1NwaGVyZShmbil9aW50ZXJzZWN0c1NwaGVyZShlKXtjb25zdCB0PXRoaXMucGxhbmVzLG49ZS5jZW50ZXIscj0tZS5yYWRpdXM7Zm9yKGxldCBzPTA7czw2O3MrKylpZih0W3NdLmRpc3RhbmNlVG9Qb2ludChuKTxyKXJldHVybiExO3JldHVybiEwfWludGVyc2VjdHNCb3goZSl7Y29uc3QgdD10aGlzLnBsYW5lcztmb3IobGV0IG49MDtuPDY7bisrKXtjb25zdCByPXRbbl07aWYoRWkueD1yLm5vcm1hbC54PjA/ZS5tYXgueDplLm1pbi54LEVpLnk9ci5ub3JtYWwueT4wP2UubWF4Lnk6ZS5taW4ueSxFaS56PXIubm9ybWFsLno+MD9lLm1heC56OmUubWluLnosci5kaXN0YW5jZVRvUG9pbnQoRWkpPDApcmV0dXJuITF9cmV0dXJuITB9Y29udGFpbnNQb2ludChlKXtjb25zdCB0PXRoaXMucGxhbmVzO2ZvcihsZXQgbj0wO248NjtuKyspaWYodFtuXS5kaXN0YW5jZVRvUG9pbnQoZSk8MClyZXR1cm4hMTtyZXR1cm4hMH1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9fWZ1bmN0aW9uIFFyKCl7bGV0IGk9bnVsbCxlPSExLHQ9bnVsbCxuPW51bGw7ZnVuY3Rpb24gcihzLGEpe3QocyxhKSxuPWkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHIpfXJldHVybntzdGFydDpmdW5jdGlvbigpe2UhPT0hMCYmdCE9PW51bGwmJihuPWkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHIpLGU9ITApfSxzdG9wOmZ1bmN0aW9uKCl7aS5jYW5jZWxBbmltYXRpb25GcmFtZShuKSxlPSExfSxzZXRBbmltYXRpb25Mb29wOmZ1bmN0aW9uKHMpe3Q9c30sc2V0Q29udGV4dDpmdW5jdGlvbihzKXtpPXN9fX1mdW5jdGlvbiBJYShpKXtjb25zdCBlPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIHQobyxsKXtjb25zdCBjPW8uYXJyYXksdT1vLnVzYWdlLGg9Yy5ieXRlTGVuZ3RoLGY9aS5jcmVhdGVCdWZmZXIoKTtpLmJpbmRCdWZmZXIobCxmKSxpLmJ1ZmZlckRhdGEobCxjLHUpLG8ub25VcGxvYWRDYWxsYmFjaygpO2xldCBwO2lmKGMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpcD1pLkZMT0FUO2Vsc2UgaWYoYyBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KW8uaXNGbG9hdDE2QnVmZmVyQXR0cmlidXRlP3A9aS5IQUxGX0ZMT0FUOnA9aS5VTlNJR05FRF9TSE9SVDtlbHNlIGlmKGMgaW5zdGFuY2VvZiBJbnQxNkFycmF5KXA9aS5TSE9SVDtlbHNlIGlmKGMgaW5zdGFuY2VvZiBVaW50MzJBcnJheSlwPWkuVU5TSUdORURfSU5UO2Vsc2UgaWYoYyBpbnN0YW5jZW9mIEludDMyQXJyYXkpcD1pLklOVDtlbHNlIGlmKGMgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpcD1pLkJZVEU7ZWxzZSBpZihjIGluc3RhbmNlb2YgVWludDhBcnJheSlwPWkuVU5TSUdORURfQllURTtlbHNlIGlmKGMgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSlwPWkuVU5TSUdORURfQllURTtlbHNlIHRocm93IG5ldyBFcnJvcigiVEhSRUUuV2ViR0xBdHRyaWJ1dGVzOiBVbnN1cHBvcnRlZCBidWZmZXIgZGF0YSBmb3JtYXQ6ICIrYyk7cmV0dXJue2J1ZmZlcjpmLHR5cGU6cCxieXRlc1BlckVsZW1lbnQ6Yy5CWVRFU19QRVJfRUxFTUVOVCx2ZXJzaW9uOm8udmVyc2lvbixzaXplOmh9fWZ1bmN0aW9uIG4obyxsLGMpe2NvbnN0IHU9bC5hcnJheSxoPWwudXBkYXRlUmFuZ2VzO2lmKGkuYmluZEJ1ZmZlcihjLG8pLGgubGVuZ3RoPT09MClpLmJ1ZmZlclN1YkRhdGEoYywwLHUpO2Vsc2V7aC5zb3J0KChwLF8pPT5wLnN0YXJ0LV8uc3RhcnQpO2xldCBmPTA7Zm9yKGxldCBwPTE7cDxoLmxlbmd0aDtwKyspe2NvbnN0IF89aFtmXSx4PWhbcF07eC5zdGFydDw9Xy5zdGFydCtfLmNvdW50KzE/Xy5jb3VudD1NYXRoLm1heChfLmNvdW50LHguc3RhcnQreC5jb3VudC1fLnN0YXJ0KTooKytmLGhbZl09eCl9aC5sZW5ndGg9ZisxO2ZvcihsZXQgcD0wLF89aC5sZW5ndGg7cDxfO3ArKyl7Y29uc3QgeD1oW3BdO2kuYnVmZmVyU3ViRGF0YShjLHguc3RhcnQqdS5CWVRFU19QRVJfRUxFTUVOVCx1LHguc3RhcnQseC5jb3VudCl9bC5jbGVhclVwZGF0ZVJhbmdlcygpfWwub25VcGxvYWRDYWxsYmFjaygpfWZ1bmN0aW9uIHIobyl7cmV0dXJuIG8uaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSYmKG89by5kYXRhKSxlLmdldChvKX1mdW5jdGlvbiBzKG8pe28uaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSYmKG89by5kYXRhKTtjb25zdCBsPWUuZ2V0KG8pO2wmJihpLmRlbGV0ZUJ1ZmZlcihsLmJ1ZmZlciksZS5kZWxldGUobykpfWZ1bmN0aW9uIGEobyxsKXtpZihvLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUmJihvPW8uZGF0YSksby5pc0dMQnVmZmVyQXR0cmlidXRlKXtjb25zdCB1PWUuZ2V0KG8pOyghdXx8dS52ZXJzaW9uPG8udmVyc2lvbikmJmUuc2V0KG8se2J1ZmZlcjpvLmJ1ZmZlcix0eXBlOm8udHlwZSxieXRlc1BlckVsZW1lbnQ6by5lbGVtZW50U2l6ZSx2ZXJzaW9uOm8udmVyc2lvbn0pO3JldHVybn1jb25zdCBjPWUuZ2V0KG8pO2lmKGM9PT12b2lkIDApZS5zZXQobyx0KG8sbCkpO2Vsc2UgaWYoYy52ZXJzaW9uPG8udmVyc2lvbil7aWYoYy5zaXplIT09by5hcnJheS5ieXRlTGVuZ3RoKXRocm93IG5ldyBFcnJvcigiVEhSRUUuV2ViR0xBdHRyaWJ1dGVzOiBUaGUgc2l6ZSBvZiB0aGUgYnVmZmVyIGF0dHJpYnV0ZSdzIGFycmF5IGJ1ZmZlciBkb2VzIG5vdCBtYXRjaCB0aGUgb3JpZ2luYWwgc2l6ZS4gUmVzaXppbmcgYnVmZmVyIGF0dHJpYnV0ZXMgaXMgbm90IHN1cHBvcnRlZC4iKTtuKGMuYnVmZmVyLG8sbCksYy52ZXJzaW9uPW8udmVyc2lvbn19cmV0dXJue2dldDpyLHJlbW92ZTpzLHVwZGF0ZTphfX1jbGFzcyB0dCBleHRlbmRzIEN0e2NvbnN0cnVjdG9yKGU9MSx0PTEsbj0xLHI9MSl7c3VwZXIoKSx0aGlzLnR5cGU9IlBsYW5lR2VvbWV0cnkiLHRoaXMucGFyYW1ldGVycz17d2lkdGg6ZSxoZWlnaHQ6dCx3aWR0aFNlZ21lbnRzOm4saGVpZ2h0U2VnbWVudHM6cn07Y29uc3Qgcz1lLzIsYT10LzIsbz1NYXRoLmZsb29yKG4pLGw9TWF0aC5mbG9vcihyKSxjPW8rMSx1PWwrMSxoPWUvbyxmPXQvbCxwPVtdLF89W10seD1bXSxtPVtdO2ZvcihsZXQgZD0wO2Q8dTtkKyspe2NvbnN0IEE9ZCpmLWE7Zm9yKGxldCBUPTA7VDxjO1QrKyl7Y29uc3QgTT1UKmgtcztfLnB1c2goTSwtQSwwKSx4LnB1c2goMCwwLDEpLG0ucHVzaChUL28pLG0ucHVzaCgxLWQvbCl9fWZvcihsZXQgZD0wO2Q8bDtkKyspZm9yKGxldCBBPTA7QTxvO0ErKyl7Y29uc3QgVD1BK2MqZCxNPUErYyooZCsxKSxGPUErMStjKihkKzEpLGI9QSsxK2MqZDtwLnB1c2goVCxNLGIpLHAucHVzaChNLEYsYil9dGhpcy5zZXRJbmRleChwKSx0aGlzLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyB1bihfLDMpKSx0aGlzLnNldEF0dHJpYnV0ZSgibm9ybWFsIixuZXcgdW4oeCwzKSksdGhpcy5zZXRBdHRyaWJ1dGUoInV2IixuZXcgdW4obSwyKSl9Y29weShlKXtyZXR1cm4gc3VwZXIuY29weShlKSx0aGlzLnBhcmFtZXRlcnM9T2JqZWN0LmFzc2lnbih7fSxlLnBhcmFtZXRlcnMpLHRoaXN9c3RhdGljIGZyb21KU09OKGUpe3JldHVybiBuZXcgdHQoZS53aWR0aCxlLmhlaWdodCxlLndpZHRoU2VnbWVudHMsZS5oZWlnaHRTZWdtZW50cyl9fXZhciBOYT1gI2lmZGVmIFVTRV9BTFBIQUhBU0gKCWlmICggZGlmZnVzZUNvbG9yLmEgPCBnZXRBbHBoYUhhc2hUaHJlc2hvbGQoIHZQb3NpdGlvbiApICkgZGlzY2FyZDsKI2VuZGlmYCxPYT1gI2lmZGVmIFVTRV9BTFBIQUhBU0gKCWNvbnN0IGZsb2F0IEFMUEhBX0hBU0hfU0NBTEUgPSAwLjA1OwoJZmxvYXQgaGFzaDJEKCB2ZWMyIHZhbHVlICkgewoJCXJldHVybiBmcmFjdCggMS4wZTQgKiBzaW4oIDE3LjAgKiB2YWx1ZS54ICsgMC4xICogdmFsdWUueSApICogKCAwLjEgKyBhYnMoIHNpbiggMTMuMCAqIHZhbHVlLnkgKyB2YWx1ZS54ICkgKSApICk7Cgl9CglmbG9hdCBoYXNoM0QoIHZlYzMgdmFsdWUgKSB7CgkJcmV0dXJuIGhhc2gyRCggdmVjMiggaGFzaDJEKCB2YWx1ZS54eSApLCB2YWx1ZS56ICkgKTsKCX0KCWZsb2F0IGdldEFscGhhSGFzaFRocmVzaG9sZCggdmVjMyBwb3NpdGlvbiApIHsKCQlmbG9hdCBtYXhEZXJpdiA9IG1heCgKCQkJbGVuZ3RoKCBkRmR4KCBwb3NpdGlvbi54eXogKSApLAoJCQlsZW5ndGgoIGRGZHkoIHBvc2l0aW9uLnh5eiApICkKCQkpOwoJCWZsb2F0IHBpeFNjYWxlID0gMS4wIC8gKCBBTFBIQV9IQVNIX1NDQUxFICogbWF4RGVyaXYgKTsKCQl2ZWMyIHBpeFNjYWxlcyA9IHZlYzIoCgkJCWV4cDIoIGZsb29yKCBsb2cyKCBwaXhTY2FsZSApICkgKSwKCQkJZXhwMiggY2VpbCggbG9nMiggcGl4U2NhbGUgKSApICkKCQkpOwoJCXZlYzIgYWxwaGEgPSB2ZWMyKAoJCQloYXNoM0QoIGZsb29yKCBwaXhTY2FsZXMueCAqIHBvc2l0aW9uLnh5eiApICksCgkJCWhhc2gzRCggZmxvb3IoIHBpeFNjYWxlcy55ICogcG9zaXRpb24ueHl6ICkgKQoJCSk7CgkJZmxvYXQgbGVycEZhY3RvciA9IGZyYWN0KCBsb2cyKCBwaXhTY2FsZSApICk7CgkJZmxvYXQgeCA9ICggMS4wIC0gbGVycEZhY3RvciApICogYWxwaGEueCArIGxlcnBGYWN0b3IgKiBhbHBoYS55OwoJCWZsb2F0IGEgPSBtaW4oIGxlcnBGYWN0b3IsIDEuMCAtIGxlcnBGYWN0b3IgKTsKCQl2ZWMzIGNhc2VzID0gdmVjMygKCQkJeCAqIHggLyAoIDIuMCAqIGEgKiAoIDEuMCAtIGEgKSApLAoJCQkoIHggLSAwLjUgKiBhICkgLyAoIDEuMCAtIGEgKSwKCQkJMS4wIC0gKCAoIDEuMCAtIHggKSAqICggMS4wIC0geCApIC8gKCAyLjAgKiBhICogKCAxLjAgLSBhICkgKSApCgkJKTsKCQlmbG9hdCB0aHJlc2hvbGQgPSAoIHggPCAoIDEuMCAtIGEgKSApCgkJCT8gKCAoIHggPCBhICkgPyBjYXNlcy54IDogY2FzZXMueSApCgkJCTogY2FzZXMuejsKCQlyZXR1cm4gY2xhbXAoIHRocmVzaG9sZCAsIDEuMGUtNiwgMS4wICk7Cgl9CiNlbmRpZmAsQmE9YCNpZmRlZiBVU0VfQUxQSEFNQVAKCWRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHZBbHBoYU1hcFV2ICkuZzsKI2VuZGlmYCx6YT1gI2lmZGVmIFVTRV9BTFBIQU1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7CiNlbmRpZmAsR2E9YCNpZmRlZiBVU0VfQUxQSEFURVNUCgkjaWZkZWYgQUxQSEFfVE9fQ09WRVJBR0UKCWRpZmZ1c2VDb2xvci5hID0gc21vb3Roc3RlcCggYWxwaGFUZXN0LCBhbHBoYVRlc3QgKyBmd2lkdGgoIGRpZmZ1c2VDb2xvci5hICksIGRpZmZ1c2VDb2xvci5hICk7CglpZiAoIGRpZmZ1c2VDb2xvci5hID09IDAuMCApIGRpc2NhcmQ7CgkjZWxzZQoJaWYgKCBkaWZmdXNlQ29sb3IuYSA8IGFscGhhVGVzdCApIGRpc2NhcmQ7CgkjZW5kaWYKI2VuZGlmYCxIYT1gI2lmZGVmIFVTRV9BTFBIQVRFU1QKCXVuaWZvcm0gZmxvYXQgYWxwaGFUZXN0OwojZW5kaWZgLFZhPWAjaWZkZWYgVVNFX0FPTUFQCglmbG9hdCBhbWJpZW50T2NjbHVzaW9uID0gKCB0ZXh0dXJlMkQoIGFvTWFwLCB2QW9NYXBVdiApLnIgLSAxLjAgKSAqIGFvTWFwSW50ZW5zaXR5ICsgMS4wOwoJcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IGFtYmllbnRPY2NsdXNpb247CgkjaWYgZGVmaW5lZCggVVNFX0NMRUFSQ09BVCApIAoJCWNsZWFyY29hdFNwZWN1bGFySW5kaXJlY3QgKj0gYW1iaWVudE9jY2x1c2lvbjsKCSNlbmRpZgoJI2lmIGRlZmluZWQoIFVTRV9TSEVFTiApIAoJCXNoZWVuU3BlY3VsYXJJbmRpcmVjdCAqPSBhbWJpZW50T2NjbHVzaW9uOwoJI2VuZGlmCgkjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFNUQU5EQVJEICkKCQlmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIgKSApOwoJCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKj0gY29tcHV0ZVNwZWN1bGFyT2NjbHVzaW9uKCBkb3ROViwgYW1iaWVudE9jY2x1c2lvbiwgbWF0ZXJpYWwucm91Z2huZXNzICk7CgkjZW5kaWYKI2VuZGlmYCxrYT1gI2lmZGVmIFVTRV9BT01BUAoJdW5pZm9ybSBzYW1wbGVyMkQgYW9NYXA7Cgl1bmlmb3JtIGZsb2F0IGFvTWFwSW50ZW5zaXR5OwojZW5kaWZgLFdhPWAjaWZkZWYgVVNFX0JBVENISU5HCgkjaWYgISBkZWZpbmVkKCBHTF9BTkdMRV9tdWx0aV9kcmF3ICkKCSNkZWZpbmUgZ2xfRHJhd0lEIF9nbF9EcmF3SUQKCXVuaWZvcm0gaW50IF9nbF9EcmF3SUQ7CgkjZW5kaWYKCXVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGJhdGNoaW5nVGV4dHVyZTsKCXVuaWZvcm0gaGlnaHAgdXNhbXBsZXIyRCBiYXRjaGluZ0lkVGV4dHVyZTsKCW1hdDQgZ2V0QmF0Y2hpbmdNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7CgkJaW50IHNpemUgPSB0ZXh0dXJlU2l6ZSggYmF0Y2hpbmdUZXh0dXJlLCAwICkueDsKCQlpbnQgaiA9IGludCggaSApICogNDsKCQlpbnQgeCA9IGogJSBzaXplOwoJCWludCB5ID0gaiAvIHNpemU7CgkJdmVjNCB2MSA9IHRleGVsRmV0Y2goIGJhdGNoaW5nVGV4dHVyZSwgaXZlYzIoIHgsIHkgKSwgMCApOwoJCXZlYzQgdjIgPSB0ZXhlbEZldGNoKCBiYXRjaGluZ1RleHR1cmUsIGl2ZWMyKCB4ICsgMSwgeSApLCAwICk7CgkJdmVjNCB2MyA9IHRleGVsRmV0Y2goIGJhdGNoaW5nVGV4dHVyZSwgaXZlYzIoIHggKyAyLCB5ICksIDAgKTsKCQl2ZWM0IHY0ID0gdGV4ZWxGZXRjaCggYmF0Y2hpbmdUZXh0dXJlLCBpdmVjMiggeCArIDMsIHkgKSwgMCApOwoJCXJldHVybiBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApOwoJfQoJZmxvYXQgZ2V0SW5kaXJlY3RJbmRleCggY29uc3QgaW4gaW50IGkgKSB7CgkJaW50IHNpemUgPSB0ZXh0dXJlU2l6ZSggYmF0Y2hpbmdJZFRleHR1cmUsIDAgKS54OwoJCWludCB4ID0gaSAlIHNpemU7CgkJaW50IHkgPSBpIC8gc2l6ZTsKCQlyZXR1cm4gZmxvYXQoIHRleGVsRmV0Y2goIGJhdGNoaW5nSWRUZXh0dXJlLCBpdmVjMiggeCwgeSApLCAwICkuciApOwoJfQojZW5kaWYKI2lmZGVmIFVTRV9CQVRDSElOR19DT0xPUgoJdW5pZm9ybSBzYW1wbGVyMkQgYmF0Y2hpbmdDb2xvclRleHR1cmU7Cgl2ZWMzIGdldEJhdGNoaW5nQ29sb3IoIGNvbnN0IGluIGZsb2F0IGkgKSB7CgkJaW50IHNpemUgPSB0ZXh0dXJlU2l6ZSggYmF0Y2hpbmdDb2xvclRleHR1cmUsIDAgKS54OwoJCWludCBqID0gaW50KCBpICk7CgkJaW50IHggPSBqICUgc2l6ZTsKCQlpbnQgeSA9IGogLyBzaXplOwoJCXJldHVybiB0ZXhlbEZldGNoKCBiYXRjaGluZ0NvbG9yVGV4dHVyZSwgaXZlYzIoIHgsIHkgKSwgMCApLnJnYjsKCX0KI2VuZGlmYCxYYT1gI2lmZGVmIFVTRV9CQVRDSElORwoJbWF0NCBiYXRjaGluZ01hdHJpeCA9IGdldEJhdGNoaW5nTWF0cml4KCBnZXRJbmRpcmVjdEluZGV4KCBnbF9EcmF3SUQgKSApOwojZW5kaWZgLHFhPWB2ZWMzIHRyYW5zZm9ybWVkID0gdmVjMyggcG9zaXRpb24gKTsKI2lmZGVmIFVTRV9BTFBIQUhBU0gKCXZQb3NpdGlvbiA9IHZlYzMoIHBvc2l0aW9uICk7CiNlbmRpZmAsWWE9YHZlYzMgb2JqZWN0Tm9ybWFsID0gdmVjMyggbm9ybWFsICk7CiNpZmRlZiBVU0VfVEFOR0VOVAoJdmVjMyBvYmplY3RUYW5nZW50ID0gdmVjMyggdGFuZ2VudC54eXogKTsKI2VuZGlmYCwkYT1gZmxvYXQgR19CbGlublBob25nX0ltcGxpY2l0KCApIHsKCXJldHVybiAwLjI1Owp9CmZsb2F0IERfQmxpbm5QaG9uZyggY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHsKCXJldHVybiBSRUNJUFJPQ0FMX1BJICogKCBzaGluaW5lc3MgKiAwLjUgKyAxLjAgKSAqIHBvdyggZG90TkgsIHNoaW5pbmVzcyApOwp9CnZlYzMgQlJERl9CbGlublBob25nKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcyApIHsKCXZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7CglmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7CglmbG9hdCBkb3RWSCA9IHNhdHVyYXRlKCBkb3QoIHZpZXdEaXIsIGhhbGZEaXIgKSApOwoJdmVjMyBGID0gRl9TY2hsaWNrKCBzcGVjdWxhckNvbG9yLCAxLjAsIGRvdFZIICk7CglmbG9hdCBHID0gR19CbGlublBob25nX0ltcGxpY2l0KCApOwoJZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApOwoJcmV0dXJuIEYgKiAoIEcgKiBEICk7Cn0gLy8gdmFsaWRhdGVkYCxaYT1gI2lmZGVmIFVTRV9JUklERVNDRU5DRQoJY29uc3QgbWF0MyBYWVpfVE9fUkVDNzA5ID0gbWF0MygKCQkgMy4yNDA0NTQyLCAtMC45NjkyNjYwLCAgMC4wNTU2NDM0LAoJCS0xLjUzNzEzODUsICAxLjg3NjAxMDgsIC0wLjIwNDAyNTksCgkJLTAuNDk4NTMxNCwgIDAuMDQxNTU2MCwgIDEuMDU3MjI1MgoJKTsKCXZlYzMgRnJlc25lbDBUb0lvciggdmVjMyBmcmVzbmVsMCApIHsKCQl2ZWMzIHNxcnRGMCA9IHNxcnQoIGZyZXNuZWwwICk7CgkJcmV0dXJuICggdmVjMyggMS4wICkgKyBzcXJ0RjAgKSAvICggdmVjMyggMS4wICkgLSBzcXJ0RjAgKTsKCX0KCXZlYzMgSW9yVG9GcmVzbmVsMCggdmVjMyB0cmFuc21pdHRlZElvciwgZmxvYXQgaW5jaWRlbnRJb3IgKSB7CgkJcmV0dXJuIHBvdzIoICggdHJhbnNtaXR0ZWRJb3IgLSB2ZWMzKCBpbmNpZGVudElvciApICkgLyAoIHRyYW5zbWl0dGVkSW9yICsgdmVjMyggaW5jaWRlbnRJb3IgKSApICk7Cgl9CglmbG9hdCBJb3JUb0ZyZXNuZWwwKCBmbG9hdCB0cmFuc21pdHRlZElvciwgZmxvYXQgaW5jaWRlbnRJb3IgKSB7CgkJcmV0dXJuIHBvdzIoICggdHJhbnNtaXR0ZWRJb3IgLSBpbmNpZGVudElvciApIC8gKCB0cmFuc21pdHRlZElvciArIGluY2lkZW50SW9yICkpOwoJfQoJdmVjMyBldmFsU2Vuc2l0aXZpdHkoIGZsb2F0IE9QRCwgdmVjMyBzaGlmdCApIHsKCQlmbG9hdCBwaGFzZSA9IDIuMCAqIFBJICogT1BEICogMS4wZS05OwoJCXZlYzMgdmFsID0gdmVjMyggNS40ODU2ZS0xMywgNC40MjAxZS0xMywgNS4yNDgxZS0xMyApOwoJCXZlYzMgcG9zID0gdmVjMyggMS42ODEwZSswNiwgMS43OTUzZSswNiwgMi4yMDg0ZSswNiApOwoJCXZlYzMgdmFyID0gdmVjMyggNC4zMjc4ZSswOSwgOS4zMDQ2ZSswOSwgNi42MTIxZSswOSApOwoJCXZlYzMgeHl6ID0gdmFsICogc3FydCggMi4wICogUEkgKiB2YXIgKSAqIGNvcyggcG9zICogcGhhc2UgKyBzaGlmdCApICogZXhwKCAtIHBvdzIoIHBoYXNlICkgKiB2YXIgKTsKCQl4eXoueCArPSA5Ljc0NzBlLTE0ICogc3FydCggMi4wICogUEkgKiA0LjUyODJlKzA5ICkgKiBjb3MoIDIuMjM5OWUrMDYgKiBwaGFzZSArIHNoaWZ0WyAwIF0gKSAqIGV4cCggLSA0LjUyODJlKzA5ICogcG93MiggcGhhc2UgKSApOwoJCXh5eiAvPSAxLjA2ODVlLTc7CgkJdmVjMyByZ2IgPSBYWVpfVE9fUkVDNzA5ICogeHl6OwoJCXJldHVybiByZ2I7Cgl9Cgl2ZWMzIGV2YWxJcmlkZXNjZW5jZSggZmxvYXQgb3V0c2lkZUlPUiwgZmxvYXQgZXRhMiwgZmxvYXQgY29zVGhldGExLCBmbG9hdCB0aGluRmlsbVRoaWNrbmVzcywgdmVjMyBiYXNlRjAgKSB7CgkJdmVjMyBJOwoJCWZsb2F0IGlyaWRlc2NlbmNlSU9SID0gbWl4KCBvdXRzaWRlSU9SLCBldGEyLCBzbW9vdGhzdGVwKCAwLjAsIDAuMDMsIHRoaW5GaWxtVGhpY2tuZXNzICkgKTsKCQlmbG9hdCBzaW5UaGV0YTJTcSA9IHBvdzIoIG91dHNpZGVJT1IgLyBpcmlkZXNjZW5jZUlPUiApICogKCAxLjAgLSBwb3cyKCBjb3NUaGV0YTEgKSApOwoJCWZsb2F0IGNvc1RoZXRhMlNxID0gMS4wIC0gc2luVGhldGEyU3E7CgkJaWYgKCBjb3NUaGV0YTJTcSA8IDAuMCApIHsKCQkJcmV0dXJuIHZlYzMoIDEuMCApOwoJCX0KCQlmbG9hdCBjb3NUaGV0YTIgPSBzcXJ0KCBjb3NUaGV0YTJTcSApOwoJCWZsb2F0IFIwID0gSW9yVG9GcmVzbmVsMCggaXJpZGVzY2VuY2VJT1IsIG91dHNpZGVJT1IgKTsKCQlmbG9hdCBSMTIgPSBGX1NjaGxpY2soIFIwLCAxLjAsIGNvc1RoZXRhMSApOwoJCWZsb2F0IFQxMjEgPSAxLjAgLSBSMTI7CgkJZmxvYXQgcGhpMTIgPSAwLjA7CgkJaWYgKCBpcmlkZXNjZW5jZUlPUiA8IG91dHNpZGVJT1IgKSBwaGkxMiA9IFBJOwoJCWZsb2F0IHBoaTIxID0gUEkgLSBwaGkxMjsKCQl2ZWMzIGJhc2VJT1IgPSBGcmVzbmVsMFRvSW9yKCBjbGFtcCggYmFzZUYwLCAwLjAsIDAuOTk5OSApICk7CQl2ZWMzIFIxID0gSW9yVG9GcmVzbmVsMCggYmFzZUlPUiwgaXJpZGVzY2VuY2VJT1IgKTsKCQl2ZWMzIFIyMyA9IEZfU2NobGljayggUjEsIDEuMCwgY29zVGhldGEyICk7CgkJdmVjMyBwaGkyMyA9IHZlYzMoIDAuMCApOwoJCWlmICggYmFzZUlPUlsgMCBdIDwgaXJpZGVzY2VuY2VJT1IgKSBwaGkyM1sgMCBdID0gUEk7CgkJaWYgKCBiYXNlSU9SWyAxIF0gPCBpcmlkZXNjZW5jZUlPUiApIHBoaTIzWyAxIF0gPSBQSTsKCQlpZiAoIGJhc2VJT1JbIDIgXSA8IGlyaWRlc2NlbmNlSU9SICkgcGhpMjNbIDIgXSA9IFBJOwoJCWZsb2F0IE9QRCA9IDIuMCAqIGlyaWRlc2NlbmNlSU9SICogdGhpbkZpbG1UaGlja25lc3MgKiBjb3NUaGV0YTI7CgkJdmVjMyBwaGkgPSB2ZWMzKCBwaGkyMSApICsgcGhpMjM7CgkJdmVjMyBSMTIzID0gY2xhbXAoIFIxMiAqIFIyMywgMWUtNSwgMC45OTk5ICk7CgkJdmVjMyByMTIzID0gc3FydCggUjEyMyApOwoJCXZlYzMgUnMgPSBwb3cyKCBUMTIxICkgKiBSMjMgLyAoIHZlYzMoIDEuMCApIC0gUjEyMyApOwoJCXZlYzMgQzAgPSBSMTIgKyBSczsKCQlJID0gQzA7CgkJdmVjMyBDbSA9IFJzIC0gVDEyMTsKCQlmb3IgKCBpbnQgbSA9IDE7IG0gPD0gMjsgKysgbSApIHsKCQkJQ20gKj0gcjEyMzsKCQkJdmVjMyBTbSA9IDIuMCAqIGV2YWxTZW5zaXRpdml0eSggZmxvYXQoIG0gKSAqIE9QRCwgZmxvYXQoIG0gKSAqIHBoaSApOwoJCQlJICs9IENtICogU207CgkJfQoJCXJldHVybiBtYXgoIEksIHZlYzMoIDAuMCApICk7Cgl9CiNlbmRpZmAsS2E9YCNpZmRlZiBVU0VfQlVNUE1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgYnVtcE1hcDsKCXVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlOwoJdmVjMiBkSGR4eV9md2QoKSB7CgkJdmVjMiBkU1RkeCA9IGRGZHgoIHZCdW1wTWFwVXYgKTsKCQl2ZWMyIGRTVGR5ID0gZEZkeSggdkJ1bXBNYXBVdiApOwoJCWZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdkJ1bXBNYXBVdiApLng7CgkJZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2QnVtcE1hcFV2ICsgZFNUZHggKS54IC0gSGxsOwoJCWZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdkJ1bXBNYXBVdiArIGRTVGR5ICkueCAtIEhsbDsKCQlyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTsKCX0KCXZlYzMgcGVydHVyYk5vcm1hbEFyYiggdmVjMyBzdXJmX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgZEhkeHksIGZsb2F0IGZhY2VEaXJlY3Rpb24gKSB7CgkJdmVjMyB2U2lnbWFYID0gbm9ybWFsaXplKCBkRmR4KCBzdXJmX3Bvcy54eXogKSApOwoJCXZlYzMgdlNpZ21hWSA9IG5vcm1hbGl6ZSggZEZkeSggc3VyZl9wb3MueHl6ICkgKTsKCQl2ZWMzIHZOID0gc3VyZl9ub3JtOwoJCXZlYzMgUjEgPSBjcm9zcyggdlNpZ21hWSwgdk4gKTsKCQl2ZWMzIFIyID0gY3Jvc3MoIHZOLCB2U2lnbWFYICk7CgkJZmxvYXQgZkRldCA9IGRvdCggdlNpZ21hWCwgUjEgKSAqIGZhY2VEaXJlY3Rpb247CgkJdmVjMyB2R3JhZCA9IHNpZ24oIGZEZXQgKSAqICggZEhkeHkueCAqIFIxICsgZEhkeHkueSAqIFIyICk7CgkJcmV0dXJuIG5vcm1hbGl6ZSggYWJzKCBmRGV0ICkgKiBzdXJmX25vcm0gLSB2R3JhZCApOwoJfQojZW5kaWZgLGphPWAjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDAKCXZlYzQgcGxhbmU7CgkjaWZkZWYgQUxQSEFfVE9fQ09WRVJBR0UKCQlmbG9hdCBkaXN0YW5jZVRvUGxhbmUsIGRpc3RhbmNlR3JhZGllbnQ7CgkJZmxvYXQgY2xpcE9wYWNpdHkgPSAxLjA7CgkJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJCWZvciAoIGludCBpID0gMDsgaSA8IFVOSU9OX0NMSVBQSU5HX1BMQU5FUzsgaSArKyApIHsKCQkJcGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdOwoJCQlkaXN0YW5jZVRvUGxhbmUgPSAtIGRvdCggdkNsaXBQb3NpdGlvbiwgcGxhbmUueHl6ICkgKyBwbGFuZS53OwoJCQlkaXN0YW5jZUdyYWRpZW50ID0gZndpZHRoKCBkaXN0YW5jZVRvUGxhbmUgKSAvIDIuMDsKCQkJY2xpcE9wYWNpdHkgKj0gc21vb3Roc3RlcCggLSBkaXN0YW5jZUdyYWRpZW50LCBkaXN0YW5jZUdyYWRpZW50LCBkaXN0YW5jZVRvUGxhbmUgKTsKCQkJaWYgKCBjbGlwT3BhY2l0eSA9PSAwLjAgKSBkaXNjYXJkOwoJCX0KCQkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJCSNpZiBVTklPTl9DTElQUElOR19QTEFORVMgPCBOVU1fQ0xJUFBJTkdfUExBTkVTCgkJCWZsb2F0IHVuaW9uQ2xpcE9wYWNpdHkgPSAxLjA7CgkJCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCQkJZm9yICggaW50IGkgPSBVTklPTl9DTElQUElOR19QTEFORVM7IGkgPCBOVU1fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkgewoJCQkJcGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdOwoJCQkJZGlzdGFuY2VUb1BsYW5lID0gLSBkb3QoIHZDbGlwUG9zaXRpb24sIHBsYW5lLnh5eiApICsgcGxhbmUudzsKCQkJCWRpc3RhbmNlR3JhZGllbnQgPSBmd2lkdGgoIGRpc3RhbmNlVG9QbGFuZSApIC8gMi4wOwoJCQkJdW5pb25DbGlwT3BhY2l0eSAqPSAxLjAgLSBzbW9vdGhzdGVwKCAtIGRpc3RhbmNlR3JhZGllbnQsIGRpc3RhbmNlR3JhZGllbnQsIGRpc3RhbmNlVG9QbGFuZSApOwoJCQl9CgkJCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCgkJCWNsaXBPcGFjaXR5ICo9IDEuMCAtIHVuaW9uQ2xpcE9wYWNpdHk7CgkJI2VuZGlmCgkJZGlmZnVzZUNvbG9yLmEgKj0gY2xpcE9wYWNpdHk7CgkJaWYgKCBkaWZmdXNlQ29sb3IuYSA9PSAwLjAgKSBkaXNjYXJkOwoJI2Vsc2UKCQkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0CgkJZm9yICggaW50IGkgPSAwOyBpIDwgVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkgewoJCQlwbGFuZSA9IGNsaXBwaW5nUGxhbmVzWyBpIF07CgkJCWlmICggZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSBkaXNjYXJkOwoJCX0KCQkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJCSNpZiBVTklPTl9DTElQUElOR19QTEFORVMgPCBOVU1fQ0xJUFBJTkdfUExBTkVTCgkJCWJvb2wgY2xpcHBlZCA9IHRydWU7CgkJCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCQkJZm9yICggaW50IGkgPSBVTklPTl9DTElQUElOR19QTEFORVM7IGkgPCBOVU1fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkgewoJCQkJcGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdOwoJCQkJY2xpcHBlZCA9ICggZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSAmJiBjbGlwcGVkOwoJCQl9CgkJCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCgkJCWlmICggY2xpcHBlZCApIGRpc2NhcmQ7CgkJI2VuZGlmCgkjZW5kaWYKI2VuZGlmYCxKYT1gI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwCgl2YXJ5aW5nIHZlYzMgdkNsaXBQb3NpdGlvbjsKCXVuaWZvcm0gdmVjNCBjbGlwcGluZ1BsYW5lc1sgTlVNX0NMSVBQSU5HX1BMQU5FUyBdOwojZW5kaWZgLFFhPWAjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDAKCXZhcnlpbmcgdmVjMyB2Q2xpcFBvc2l0aW9uOwojZW5kaWZgLGVvPWAjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDAKCXZDbGlwUG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6OwojZW5kaWZgLHRvPWAjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBICkKCWRpZmZ1c2VDb2xvciAqPSB2Q29sb3I7CiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApCglkaWZmdXNlQ29sb3IucmdiICo9IHZDb2xvcjsKI2VuZGlmYCxubz1gI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApCgl2YXJ5aW5nIHZlYzQgdkNvbG9yOwojZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKQoJdmFyeWluZyB2ZWMzIHZDb2xvcjsKI2VuZGlmYCxpbz1gI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApCgl2YXJ5aW5nIHZlYzQgdkNvbG9yOwojZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfSU5TVEFOQ0lOR19DT0xPUiApIHx8IGRlZmluZWQoIFVTRV9CQVRDSElOR19DT0xPUiApCgl2YXJ5aW5nIHZlYzMgdkNvbG9yOwojZW5kaWZgLHJvPWAjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBICkKCXZDb2xvciA9IHZlYzQoIDEuMCApOwojZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfSU5TVEFOQ0lOR19DT0xPUiApIHx8IGRlZmluZWQoIFVTRV9CQVRDSElOR19DT0xPUiApCgl2Q29sb3IgPSB2ZWMzKCAxLjAgKTsKI2VuZGlmCiNpZmRlZiBVU0VfQ09MT1IKCXZDb2xvciAqPSBjb2xvcjsKI2VuZGlmCiNpZmRlZiBVU0VfSU5TVEFOQ0lOR19DT0xPUgoJdkNvbG9yLnh5eiAqPSBpbnN0YW5jZUNvbG9yLnh5ejsKI2VuZGlmCiNpZmRlZiBVU0VfQkFUQ0hJTkdfQ09MT1IKCXZlYzMgYmF0Y2hpbmdDb2xvciA9IGdldEJhdGNoaW5nQ29sb3IoIGdldEluZGlyZWN0SW5kZXgoIGdsX0RyYXdJRCApICk7Cgl2Q29sb3IueHl6ICo9IGJhdGNoaW5nQ29sb3IueHl6OwojZW5kaWZgLHNvPWAjZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTg5NzkzCiNkZWZpbmUgUEkyIDYuMjgzMTg1MzA3MTc5NTg2CiNkZWZpbmUgUElfSEFMRiAxLjU3MDc5NjMyNjc5NDg5NjYKI2RlZmluZSBSRUNJUFJPQ0FMX1BJIDAuMzE4MzA5ODg2MTgzNzkwNwojZGVmaW5lIFJFQ0lQUk9DQUxfUEkyIDAuMTU5MTU0OTQzMDkxODk1MzUKI2RlZmluZSBFUFNJTE9OIDFlLTYKI2lmbmRlZiBzYXR1cmF0ZQojZGVmaW5lIHNhdHVyYXRlKCBhICkgY2xhbXAoIGEsIDAuMCwgMS4wICkKI2VuZGlmCiNkZWZpbmUgd2hpdGVDb21wbGVtZW50KCBhICkgKCAxLjAgLSBzYXR1cmF0ZSggYSApICkKZmxvYXQgcG93MiggY29uc3QgaW4gZmxvYXQgeCApIHsgcmV0dXJuIHgqeDsgfQp2ZWMzIHBvdzIoIGNvbnN0IGluIHZlYzMgeCApIHsgcmV0dXJuIHgqeDsgfQpmbG9hdCBwb3czKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4Kng7IH0KZmxvYXQgcG93NCggY29uc3QgaW4gZmxvYXQgeCApIHsgZmxvYXQgeDIgPSB4Kng7IHJldHVybiB4Mip4MjsgfQpmbG9hdCBtYXgzKCBjb25zdCBpbiB2ZWMzIHYgKSB7IHJldHVybiBtYXgoIG1heCggdi54LCB2LnkgKSwgdi56ICk7IH0KZmxvYXQgYXZlcmFnZSggY29uc3QgaW4gdmVjMyB2ICkgeyByZXR1cm4gZG90KCB2LCB2ZWMzKCAwLjMzMzMzMzMgKSApOyB9CmhpZ2hwIGZsb2F0IHJhbmQoIGNvbnN0IGluIHZlYzIgdXYgKSB7Cgljb25zdCBoaWdocCBmbG9hdCBhID0gMTIuOTg5OCwgYiA9IDc4LjIzMywgYyA9IDQzNzU4LjU0NTM7CgloaWdocCBmbG9hdCBkdCA9IGRvdCggdXYueHksIHZlYzIoIGEsYiApICksIHNuID0gbW9kKCBkdCwgUEkgKTsKCXJldHVybiBmcmFjdCggc2luKCBzbiApICogYyApOwp9CiNpZmRlZiBISUdIX1BSRUNJU0lPTgoJZmxvYXQgcHJlY2lzaW9uU2FmZUxlbmd0aCggdmVjMyB2ICkgeyByZXR1cm4gbGVuZ3RoKCB2ICk7IH0KI2Vsc2UKCWZsb2F0IHByZWNpc2lvblNhZmVMZW5ndGgoIHZlYzMgdiApIHsKCQlmbG9hdCBtYXhDb21wb25lbnQgPSBtYXgzKCBhYnMoIHYgKSApOwoJCXJldHVybiBsZW5ndGgoIHYgLyBtYXhDb21wb25lbnQgKSAqIG1heENvbXBvbmVudDsKCX0KI2VuZGlmCnN0cnVjdCBJbmNpZGVudExpZ2h0IHsKCXZlYzMgY29sb3I7Cgl2ZWMzIGRpcmVjdGlvbjsKCWJvb2wgdmlzaWJsZTsKfTsKc3RydWN0IFJlZmxlY3RlZExpZ2h0IHsKCXZlYzMgZGlyZWN0RGlmZnVzZTsKCXZlYzMgZGlyZWN0U3BlY3VsYXI7Cgl2ZWMzIGluZGlyZWN0RGlmZnVzZTsKCXZlYzMgaW5kaXJlY3RTcGVjdWxhcjsKfTsKI2lmZGVmIFVTRV9BTFBIQUhBU0gKCXZhcnlpbmcgdmVjMyB2UG9zaXRpb247CiNlbmRpZgp2ZWMzIHRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkgewoJcmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7Cn0KdmVjMyBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7CglyZXR1cm4gbm9ybWFsaXplKCAoIHZlYzQoIGRpciwgMC4wICkgKiBtYXRyaXggKS54eXogKTsKfQptYXQzIHRyYW5zcG9zZU1hdDMoIGNvbnN0IGluIG1hdDMgbSApIHsKCW1hdDMgdG1wOwoJdG1wWyAwIF0gPSB2ZWMzKCBtWyAwIF0ueCwgbVsgMSBdLngsIG1bIDIgXS54ICk7Cgl0bXBbIDEgXSA9IHZlYzMoIG1bIDAgXS55LCBtWyAxIF0ueSwgbVsgMiBdLnkgKTsKCXRtcFsgMiBdID0gdmVjMyggbVsgMCBdLnosIG1bIDEgXS56LCBtWyAyIF0ueiApOwoJcmV0dXJuIHRtcDsKfQpib29sIGlzUGVyc3BlY3RpdmVNYXRyaXgoIG1hdDQgbSApIHsKCXJldHVybiBtWyAyIF1bIDMgXSA9PSAtIDEuMDsKfQp2ZWMyIGVxdWlyZWN0VXYoIGluIHZlYzMgZGlyICkgewoJZmxvYXQgdSA9IGF0YW4oIGRpci56LCBkaXIueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7CglmbG9hdCB2ID0gYXNpbiggY2xhbXAoIGRpci55LCAtIDEuMCwgMS4wICkgKSAqIFJFQ0lQUk9DQUxfUEkgKyAwLjU7CglyZXR1cm4gdmVjMiggdSwgdiApOwp9CnZlYzMgQlJERl9MYW1iZXJ0KCBjb25zdCBpbiB2ZWMzIGRpZmZ1c2VDb2xvciApIHsKCXJldHVybiBSRUNJUFJPQ0FMX1BJICogZGlmZnVzZUNvbG9yOwp9CnZlYzMgRl9TY2hsaWNrKCBjb25zdCBpbiB2ZWMzIGYwLCBjb25zdCBpbiBmbG9hdCBmOTAsIGNvbnN0IGluIGZsb2F0IGRvdFZIICkgewoJZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLSA1LjU1NDczICogZG90VkggLSA2Ljk4MzE2ICkgKiBkb3RWSCApOwoJcmV0dXJuIGYwICogKCAxLjAgLSBmcmVzbmVsICkgKyAoIGY5MCAqIGZyZXNuZWwgKTsKfQpmbG9hdCBGX1NjaGxpY2soIGNvbnN0IGluIGZsb2F0IGYwLCBjb25zdCBpbiBmbG9hdCBmOTAsIGNvbnN0IGluIGZsb2F0IGRvdFZIICkgewoJZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLSA1LjU1NDczICogZG90VkggLSA2Ljk4MzE2ICkgKiBkb3RWSCApOwoJcmV0dXJuIGYwICogKCAxLjAgLSBmcmVzbmVsICkgKyAoIGY5MCAqIGZyZXNuZWwgKTsKfSAvLyB2YWxpZGF0ZWRgLGFvPWAjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRV9VVgoJI2RlZmluZSBjdWJlVVZfbWluTWlwTGV2ZWwgNC4wCgkjZGVmaW5lIGN1YmVVVl9taW5UaWxlU2l6ZSAxNi4wCglmbG9hdCBnZXRGYWNlKCB2ZWMzIGRpcmVjdGlvbiApIHsKCQl2ZWMzIGFic0RpcmVjdGlvbiA9IGFicyggZGlyZWN0aW9uICk7CgkJZmxvYXQgZmFjZSA9IC0gMS4wOwoJCWlmICggYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueiApIHsKCQkJaWYgKCBhYnNEaXJlY3Rpb24ueCA+IGFic0RpcmVjdGlvbi55ICkKCQkJCWZhY2UgPSBkaXJlY3Rpb24ueCA+IDAuMCA/IDAuMCA6IDMuMDsKCQkJZWxzZQoJCQkJZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMS4wIDogNC4wOwoJCX0gZWxzZSB7CgkJCWlmICggYWJzRGlyZWN0aW9uLnogPiBhYnNEaXJlY3Rpb24ueSApCgkJCQlmYWNlID0gZGlyZWN0aW9uLnogPiAwLjAgPyAyLjAgOiA1LjA7CgkJCWVsc2UKCQkJCWZhY2UgPSBkaXJlY3Rpb24ueSA+IDAuMCA/IDEuMCA6IDQuMDsKCQl9CgkJcmV0dXJuIGZhY2U7Cgl9Cgl2ZWMyIGdldFVWKCB2ZWMzIGRpcmVjdGlvbiwgZmxvYXQgZmFjZSApIHsKCQl2ZWMyIHV2OwoJCWlmICggZmFjZSA9PSAwLjAgKSB7CgkJCXV2ID0gdmVjMiggZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi54ICk7CgkJfSBlbHNlIGlmICggZmFjZSA9PSAxLjAgKSB7CgkJCXV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueCwgLSBkaXJlY3Rpb24ueiApIC8gYWJzKCBkaXJlY3Rpb24ueSApOwoJCX0gZWxzZSBpZiAoIGZhY2UgPT0gMi4wICkgewoJCQl1diA9IHZlYzIoIC0gZGlyZWN0aW9uLngsIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi56ICk7CgkJfSBlbHNlIGlmICggZmFjZSA9PSAzLjAgKSB7CgkJCXV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnggKTsKCQl9IGVsc2UgaWYgKCBmYWNlID09IDQuMCApIHsKCQkJdXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueiApIC8gYWJzKCBkaXJlY3Rpb24ueSApOwoJCX0gZWxzZSB7CgkJCXV2ID0gdmVjMiggZGlyZWN0aW9uLngsIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi56ICk7CgkJfQoJCXJldHVybiAwLjUgKiAoIHV2ICsgMS4wICk7Cgl9Cgl2ZWMzIGJpbGluZWFyQ3ViZVVWKCBzYW1wbGVyMkQgZW52TWFwLCB2ZWMzIGRpcmVjdGlvbiwgZmxvYXQgbWlwSW50ICkgewoJCWZsb2F0IGZhY2UgPSBnZXRGYWNlKCBkaXJlY3Rpb24gKTsKCQlmbG9hdCBmaWx0ZXJJbnQgPSBtYXgoIGN1YmVVVl9taW5NaXBMZXZlbCAtIG1pcEludCwgMC4wICk7CgkJbWlwSW50ID0gbWF4KCBtaXBJbnQsIGN1YmVVVl9taW5NaXBMZXZlbCApOwoJCWZsb2F0IGZhY2VTaXplID0gZXhwMiggbWlwSW50ICk7CgkJaGlnaHAgdmVjMiB1diA9IGdldFVWKCBkaXJlY3Rpb24sIGZhY2UgKSAqICggZmFjZVNpemUgLSAyLjAgKSArIDEuMDsKCQlpZiAoIGZhY2UgPiAyLjAgKSB7CgkJCXV2LnkgKz0gZmFjZVNpemU7CgkJCWZhY2UgLT0gMy4wOwoJCX0KCQl1di54ICs9IGZhY2UgKiBmYWNlU2l6ZTsKCQl1di54ICs9IGZpbHRlckludCAqIDMuMCAqIGN1YmVVVl9taW5UaWxlU2l6ZTsKCQl1di55ICs9IDQuMCAqICggZXhwMiggQ1VCRVVWX01BWF9NSVAgKSAtIGZhY2VTaXplICk7CgkJdXYueCAqPSBDVUJFVVZfVEVYRUxfV0lEVEg7CgkJdXYueSAqPSBDVUJFVVZfVEVYRUxfSEVJR0hUOwoJCSNpZmRlZiB0ZXh0dXJlMkRHcmFkRVhUCgkJCXJldHVybiB0ZXh0dXJlMkRHcmFkRVhUKCBlbnZNYXAsIHV2LCB2ZWMyKCAwLjAgKSwgdmVjMiggMC4wICkgKS5yZ2I7CgkJI2Vsc2UKCQkJcmV0dXJuIHRleHR1cmUyRCggZW52TWFwLCB1diApLnJnYjsKCQkjZW5kaWYKCX0KCSNkZWZpbmUgY3ViZVVWX3IwIDEuMAoJI2RlZmluZSBjdWJlVVZfbTAgLSAyLjAKCSNkZWZpbmUgY3ViZVVWX3IxIDAuOAoJI2RlZmluZSBjdWJlVVZfbTEgLSAxLjAKCSNkZWZpbmUgY3ViZVVWX3I0IDAuNAoJI2RlZmluZSBjdWJlVVZfbTQgMi4wCgkjZGVmaW5lIGN1YmVVVl9yNSAwLjMwNQoJI2RlZmluZSBjdWJlVVZfbTUgMy4wCgkjZGVmaW5lIGN1YmVVVl9yNiAwLjIxCgkjZGVmaW5lIGN1YmVVVl9tNiA0LjAKCWZsb2F0IHJvdWdobmVzc1RvTWlwKCBmbG9hdCByb3VnaG5lc3MgKSB7CgkJZmxvYXQgbWlwID0gMC4wOwoJCWlmICggcm91Z2huZXNzID49IGN1YmVVVl9yMSApIHsKCQkJbWlwID0gKCBjdWJlVVZfcjAgLSByb3VnaG5lc3MgKSAqICggY3ViZVVWX20xIC0gY3ViZVVWX20wICkgLyAoIGN1YmVVVl9yMCAtIGN1YmVVVl9yMSApICsgY3ViZVVWX20wOwoJCX0gZWxzZSBpZiAoIHJvdWdobmVzcyA+PSBjdWJlVVZfcjQgKSB7CgkJCW1pcCA9ICggY3ViZVVWX3IxIC0gcm91Z2huZXNzICkgKiAoIGN1YmVVVl9tNCAtIGN1YmVVVl9tMSApIC8gKCBjdWJlVVZfcjEgLSBjdWJlVVZfcjQgKSArIGN1YmVVVl9tMTsKCQl9IGVsc2UgaWYgKCByb3VnaG5lc3MgPj0gY3ViZVVWX3I1ICkgewoJCQltaXAgPSAoIGN1YmVVVl9yNCAtIHJvdWdobmVzcyApICogKCBjdWJlVVZfbTUgLSBjdWJlVVZfbTQgKSAvICggY3ViZVVWX3I0IC0gY3ViZVVWX3I1ICkgKyBjdWJlVVZfbTQ7CgkJfSBlbHNlIGlmICggcm91Z2huZXNzID49IGN1YmVVVl9yNiApIHsKCQkJbWlwID0gKCBjdWJlVVZfcjUgLSByb3VnaG5lc3MgKSAqICggY3ViZVVWX202IC0gY3ViZVVWX201ICkgLyAoIGN1YmVVVl9yNSAtIGN1YmVVVl9yNiApICsgY3ViZVVWX201OwoJCX0gZWxzZSB7CgkJCW1pcCA9IC0gMi4wICogbG9nMiggMS4xNiAqIHJvdWdobmVzcyApOwkJfQoJCXJldHVybiBtaXA7Cgl9Cgl2ZWM0IHRleHR1cmVDdWJlVVYoIHNhbXBsZXIyRCBlbnZNYXAsIHZlYzMgc2FtcGxlRGlyLCBmbG9hdCByb3VnaG5lc3MgKSB7CgkJZmxvYXQgbWlwID0gY2xhbXAoIHJvdWdobmVzc1RvTWlwKCByb3VnaG5lc3MgKSwgY3ViZVVWX20wLCBDVUJFVVZfTUFYX01JUCApOwoJCWZsb2F0IG1pcEYgPSBmcmFjdCggbWlwICk7CgkJZmxvYXQgbWlwSW50ID0gZmxvb3IoIG1pcCApOwoJCXZlYzMgY29sb3IwID0gYmlsaW5lYXJDdWJlVVYoIGVudk1hcCwgc2FtcGxlRGlyLCBtaXBJbnQgKTsKCQlpZiAoIG1pcEYgPT0gMC4wICkgewoJCQlyZXR1cm4gdmVjNCggY29sb3IwLCAxLjAgKTsKCQl9IGVsc2UgewoJCQl2ZWMzIGNvbG9yMSA9IGJpbGluZWFyQ3ViZVVWKCBlbnZNYXAsIHNhbXBsZURpciwgbWlwSW50ICsgMS4wICk7CgkJCXJldHVybiB2ZWM0KCBtaXgoIGNvbG9yMCwgY29sb3IxLCBtaXBGICksIDEuMCApOwoJCX0KCX0KI2VuZGlmYCxvbz1gdmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG9iamVjdE5vcm1hbDsKI2lmZGVmIFVTRV9UQU5HRU5UCgl2ZWMzIHRyYW5zZm9ybWVkVGFuZ2VudCA9IG9iamVjdFRhbmdlbnQ7CiNlbmRpZgojaWZkZWYgVVNFX0JBVENISU5HCgltYXQzIGJtID0gbWF0MyggYmF0Y2hpbmdNYXRyaXggKTsKCXRyYW5zZm9ybWVkTm9ybWFsIC89IHZlYzMoIGRvdCggYm1bIDAgXSwgYm1bIDAgXSApLCBkb3QoIGJtWyAxIF0sIGJtWyAxIF0gKSwgZG90KCBibVsgMiBdLCBibVsgMiBdICkgKTsKCXRyYW5zZm9ybWVkTm9ybWFsID0gYm0gKiB0cmFuc2Zvcm1lZE5vcm1hbDsKCSNpZmRlZiBVU0VfVEFOR0VOVAoJCXRyYW5zZm9ybWVkVGFuZ2VudCA9IGJtICogdHJhbnNmb3JtZWRUYW5nZW50OwoJI2VuZGlmCiNlbmRpZgojaWZkZWYgVVNFX0lOU1RBTkNJTkcKCW1hdDMgaW0gPSBtYXQzKCBpbnN0YW5jZU1hdHJpeCApOwoJdHJhbnNmb3JtZWROb3JtYWwgLz0gdmVjMyggZG90KCBpbVsgMCBdLCBpbVsgMCBdICksIGRvdCggaW1bIDEgXSwgaW1bIDEgXSApLCBkb3QoIGltWyAyIF0sIGltWyAyIF0gKSApOwoJdHJhbnNmb3JtZWROb3JtYWwgPSBpbSAqIHRyYW5zZm9ybWVkTm9ybWFsOwoJI2lmZGVmIFVTRV9UQU5HRU5UCgkJdHJhbnNmb3JtZWRUYW5nZW50ID0gaW0gKiB0cmFuc2Zvcm1lZFRhbmdlbnQ7CgkjZW5kaWYKI2VuZGlmCnRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogdHJhbnNmb3JtZWROb3JtYWw7CiNpZmRlZiBGTElQX1NJREVECgl0cmFuc2Zvcm1lZE5vcm1hbCA9IC0gdHJhbnNmb3JtZWROb3JtYWw7CiNlbmRpZgojaWZkZWYgVVNFX1RBTkdFTlQKCXRyYW5zZm9ybWVkVGFuZ2VudCA9ICggbW9kZWxWaWV3TWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWRUYW5nZW50LCAwLjAgKSApLnh5ejsKCSNpZmRlZiBGTElQX1NJREVECgkJdHJhbnNmb3JtZWRUYW5nZW50ID0gLSB0cmFuc2Zvcm1lZFRhbmdlbnQ7CgkjZW5kaWYKI2VuZGlmYCxsbz1gI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIGRpc3BsYWNlbWVudE1hcDsKCXVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50U2NhbGU7Cgl1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudEJpYXM7CiNlbmRpZmAsY289YCNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQCgl0cmFuc2Zvcm1lZCArPSBub3JtYWxpemUoIG9iamVjdE5vcm1hbCApICogKCB0ZXh0dXJlMkQoIGRpc3BsYWNlbWVudE1hcCwgdkRpc3BsYWNlbWVudE1hcFV2ICkueCAqIGRpc3BsYWNlbWVudFNjYWxlICsgZGlzcGxhY2VtZW50QmlhcyApOwojZW5kaWZgLHVvPWAjaWZkZWYgVVNFX0VNSVNTSVZFTUFQCgl2ZWM0IGVtaXNzaXZlQ29sb3IgPSB0ZXh0dXJlMkQoIGVtaXNzaXZlTWFwLCB2RW1pc3NpdmVNYXBVdiApOwoJI2lmZGVmIERFQ09ERV9WSURFT19URVhUVVJFX0VNSVNTSVZFCgkJZW1pc3NpdmVDb2xvciA9IHNSR0JUcmFuc2ZlckVPVEYoIGVtaXNzaXZlQ29sb3IgKTsKCSNlbmRpZgoJdG90YWxFbWlzc2l2ZVJhZGlhbmNlICo9IGVtaXNzaXZlQ29sb3IucmdiOwojZW5kaWZgLGhvPWAjaWZkZWYgVVNFX0VNSVNTSVZFTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2l2ZU1hcDsKI2VuZGlmYCxmbz0iZ2xfRnJhZ0NvbG9yID0gbGluZWFyVG9PdXRwdXRUZXhlbCggZ2xfRnJhZ0NvbG9yICk7Iixwbz1gdmVjNCBMaW5lYXJUcmFuc2Zlck9FVEYoIGluIHZlYzQgdmFsdWUgKSB7CglyZXR1cm4gdmFsdWU7Cn0KdmVjNCBzUkdCVHJhbnNmZXJFT1RGKCBpbiB2ZWM0IHZhbHVlICkgewoJcmV0dXJuIHZlYzQoIG1peCggcG93KCB2YWx1ZS5yZ2IgKiAwLjk0Nzg2NzI5ODYgKyB2ZWMzKCAwLjA1MjEzMjcwMTQgKSwgdmVjMyggMi40ICkgKSwgdmFsdWUucmdiICogMC4wNzczOTkzODA4LCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDQwNDUgKSApICkgKSwgdmFsdWUuYSApOwp9CnZlYzQgc1JHQlRyYW5zZmVyT0VURiggaW4gdmVjNCB2YWx1ZSApIHsKCXJldHVybiB2ZWM0KCBtaXgoIHBvdyggdmFsdWUucmdiLCB2ZWMzKCAwLjQxNjY2ICkgKSAqIDEuMDU1IC0gdmVjMyggMC4wNTUgKSwgdmFsdWUucmdiICogMTIuOTIsIHZlYzMoIGxlc3NUaGFuRXF1YWwoIHZhbHVlLnJnYiwgdmVjMyggMC4wMDMxMzA4ICkgKSApICksIHZhbHVlLmEgKTsKfWAsbW89YCNpZmRlZiBVU0VfRU5WTUFQCgkjaWZkZWYgRU5WX1dPUkxEUE9TCgkJdmVjMyBjYW1lcmFUb0ZyYWc7CgkJaWYgKCBpc09ydGhvZ3JhcGhpYyApIHsKCQkJY2FtZXJhVG9GcmFnID0gbm9ybWFsaXplKCB2ZWMzKCAtIHZpZXdNYXRyaXhbIDAgXVsgMiBdLCAtIHZpZXdNYXRyaXhbIDEgXVsgMiBdLCAtIHZpZXdNYXRyaXhbIDIgXVsgMiBdICkgKTsKCQl9IGVsc2UgewoJCQljYW1lcmFUb0ZyYWcgPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTsKCQl9CgkJdmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApOwoJCSNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OCgkJCXZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIGNhbWVyYVRvRnJhZywgd29ybGROb3JtYWwgKTsKCQkjZWxzZQoJCQl2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCBjYW1lcmFUb0ZyYWcsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTsKCQkjZW5kaWYKCSNlbHNlCgkJdmVjMyByZWZsZWN0VmVjID0gdlJlZmxlY3Q7CgkjZW5kaWYKCSNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFCgkJdmVjNCBlbnZDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIGVudk1hcFJvdGF0aW9uICogdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7CgkjZWxzZQoJCXZlYzQgZW52Q29sb3IgPSB2ZWM0KCAwLjAgKTsKCSNlbmRpZgoJI2lmZGVmIEVOVk1BUF9CTEVORElOR19NVUxUSVBMWQoJCW91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIG91dGdvaW5nTGlnaHQgKiBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTsKCSNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19NSVggKQoJCW91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApOwoJI2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX0FERCApCgkJb3V0Z29pbmdMaWdodCArPSBlbnZDb2xvci54eXogKiBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5OwoJI2VuZGlmCiNlbmRpZmAsX289YCNpZmRlZiBVU0VfRU5WTUFQCgl1bmlmb3JtIGZsb2F0IGVudk1hcEludGVuc2l0eTsKCXVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDsKCXVuaWZvcm0gbWF0MyBlbnZNYXBSb3RhdGlvbjsKCSNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFCgkJdW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7CgkjZWxzZQoJCXVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDsKCSNlbmRpZgoJCiNlbmRpZmAsZ289YCNpZmRlZiBVU0VfRU5WTUFQCgl1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTsKCSNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIExBTUJFUlQgKQoJCSNkZWZpbmUgRU5WX1dPUkxEUE9TCgkjZW5kaWYKCSNpZmRlZiBFTlZfV09STERQT1MKCQl2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247CgkJdW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87CgkjZWxzZQoJCXZhcnlpbmcgdmVjMyB2UmVmbGVjdDsKCSNlbmRpZgojZW5kaWZgLHZvPWAjaWZkZWYgVVNFX0VOVk1BUAoJI2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggTEFNQkVSVCApCgkJI2RlZmluZSBFTlZfV09STERQT1MKCSNlbmRpZgoJI2lmZGVmIEVOVl9XT1JMRFBPUwoJCQoJCXZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjsKCSNlbHNlCgkJdmFyeWluZyB2ZWMzIHZSZWZsZWN0OwoJCXVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvOwoJI2VuZGlmCiNlbmRpZmAseG89YCNpZmRlZiBVU0VfRU5WTUFQCgkjaWZkZWYgRU5WX1dPUkxEUE9TCgkJdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejsKCSNlbHNlCgkJdmVjMyBjYW1lcmFUb1ZlcnRleDsKCQlpZiAoIGlzT3J0aG9ncmFwaGljICkgewoJCQljYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggdmVjMyggLSB2aWV3TWF0cml4WyAwIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAxIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAyIF1bIDIgXSApICk7CgkJfSBlbHNlIHsKCQkJY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHdvcmxkUG9zaXRpb24ueHl6IC0gY2FtZXJhUG9zaXRpb24gKTsKCQl9CgkJdmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHRyYW5zZm9ybWVkTm9ybWFsLCB2aWV3TWF0cml4ICk7CgkJI2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT04KCQkJdlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTsKCQkjZWxzZQoJCQl2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7CgkJI2VuZGlmCgkjZW5kaWYKI2VuZGlmYCxNbz1gI2lmZGVmIFVTRV9GT0cKCXZGb2dEZXB0aCA9IC0gbXZQb3NpdGlvbi56OwojZW5kaWZgLFNvPWAjaWZkZWYgVVNFX0ZPRwoJdmFyeWluZyBmbG9hdCB2Rm9nRGVwdGg7CiNlbmRpZmAsRW89YCNpZmRlZiBVU0VfRk9HCgkjaWZkZWYgRk9HX0VYUDIKCQlmbG9hdCBmb2dGYWN0b3IgPSAxLjAgLSBleHAoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiB2Rm9nRGVwdGggKiB2Rm9nRGVwdGggKTsKCSNlbHNlCgkJZmxvYXQgZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCB2Rm9nRGVwdGggKTsKCSNlbmRpZgoJZ2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggZ2xfRnJhZ0NvbG9yLnJnYiwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApOwojZW5kaWZgLHlvPWAjaWZkZWYgVVNFX0ZPRwoJdW5pZm9ybSB2ZWMzIGZvZ0NvbG9yOwoJdmFyeWluZyBmbG9hdCB2Rm9nRGVwdGg7CgkjaWZkZWYgRk9HX0VYUDIKCQl1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7CgkjZWxzZQoJCXVuaWZvcm0gZmxvYXQgZm9nTmVhcjsKCQl1bmlmb3JtIGZsb2F0IGZvZ0ZhcjsKCSNlbmRpZgojZW5kaWZgLFRvPWAjaWZkZWYgVVNFX0dSQURJRU5UTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBncmFkaWVudE1hcDsKI2VuZGlmCnZlYzMgZ2V0R3JhZGllbnRJcnJhZGlhbmNlKCB2ZWMzIG5vcm1hbCwgdmVjMyBsaWdodERpcmVjdGlvbiApIHsKCWZsb2F0IGRvdE5MID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyZWN0aW9uICk7Cgl2ZWMyIGNvb3JkID0gdmVjMiggZG90TkwgKiAwLjUgKyAwLjUsIDAuMCApOwoJI2lmZGVmIFVTRV9HUkFESUVOVE1BUAoJCXJldHVybiB2ZWMzKCB0ZXh0dXJlMkQoIGdyYWRpZW50TWFwLCBjb29yZCApLnIgKTsKCSNlbHNlCgkJdmVjMiBmdyA9IGZ3aWR0aCggY29vcmQgKSAqIDAuNTsKCQlyZXR1cm4gbWl4KCB2ZWMzKCAwLjcgKSwgdmVjMyggMS4wICksIHNtb290aHN0ZXAoIDAuNyAtIGZ3LngsIDAuNyArIGZ3LngsIGNvb3JkLnggKSApOwoJI2VuZGlmCn1gLEFvPWAjaWZkZWYgVVNFX0xJR0hUTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBsaWdodE1hcDsKCXVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7CiNlbmRpZmAsYm89YExhbWJlcnRNYXRlcmlhbCBtYXRlcmlhbDsKbWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjsKbWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aCA9IHNwZWN1bGFyU3RyZW5ndGg7YCx3bz1gdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CnN0cnVjdCBMYW1iZXJ0TWF0ZXJpYWwgewoJdmVjMyBkaWZmdXNlQ29sb3I7CglmbG9hdCBzcGVjdWxhclN0cmVuZ3RoOwp9Owp2b2lkIFJFX0RpcmVjdF9MYW1iZXJ0KCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBMYW1iZXJ0TWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkgewoJZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeU5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTsKCXZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7CglyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApOwp9CnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX0xhbWJlcnQoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gTGFtYmVydE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHsKCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTsKfQojZGVmaW5lIFJFX0RpcmVjdAkJCQlSRV9EaXJlY3RfTGFtYmVydAojZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZQkJUkVfSW5kaXJlY3REaWZmdXNlX0xhbWJlcnRgLFJvPWB1bmlmb3JtIGJvb2wgcmVjZWl2ZVNoYWRvdzsKdW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yOwojaWYgZGVmaW5lZCggVVNFX0xJR0hUX1BST0JFUyApCgl1bmlmb3JtIHZlYzMgbGlnaHRQcm9iZVsgOSBdOwojZW5kaWYKdmVjMyBzaEdldElycmFkaWFuY2VBdCggaW4gdmVjMyBub3JtYWwsIGluIHZlYzMgc2hDb2VmZmljaWVudHNbIDkgXSApIHsKCWZsb2F0IHggPSBub3JtYWwueCwgeSA9IG5vcm1hbC55LCB6ID0gbm9ybWFsLno7Cgl2ZWMzIHJlc3VsdCA9IHNoQ29lZmZpY2llbnRzWyAwIF0gKiAwLjg4NjIyNzsKCXJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgMSBdICogMi4wICogMC41MTE2NjQgKiB5OwoJcmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAyIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHo7CglyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDMgXSAqIDIuMCAqIDAuNTExNjY0ICogeDsKCXJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNCBdICogMi4wICogMC40MjkwNDMgKiB4ICogeTsKCXJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNSBdICogMi4wICogMC40MjkwNDMgKiB5ICogejsKCXJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNiBdICogKCAwLjc0MzEyNSAqIHogKiB6IC0gMC4yNDc3MDggKTsKCXJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNyBdICogMi4wICogMC40MjkwNDMgKiB4ICogejsKCXJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgOCBdICogMC40MjkwNDMgKiAoIHggKiB4IC0geSAqIHkgKTsKCXJldHVybiByZXN1bHQ7Cn0KdmVjMyBnZXRMaWdodFByb2JlSXJyYWRpYW5jZSggY29uc3QgaW4gdmVjMyBsaWdodFByb2JlWyA5IF0sIGNvbnN0IGluIHZlYzMgbm9ybWFsICkgewoJdmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApOwoJdmVjMyBpcnJhZGlhbmNlID0gc2hHZXRJcnJhZGlhbmNlQXQoIHdvcmxkTm9ybWFsLCBsaWdodFByb2JlICk7CglyZXR1cm4gaXJyYWRpYW5jZTsKfQp2ZWMzIGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgYW1iaWVudExpZ2h0Q29sb3IgKSB7Cgl2ZWMzIGlycmFkaWFuY2UgPSBhbWJpZW50TGlnaHRDb2xvcjsKCXJldHVybiBpcnJhZGlhbmNlOwp9CmZsb2F0IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIGNvbnN0IGluIGZsb2F0IGxpZ2h0RGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGN1dG9mZkRpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBkZWNheUV4cG9uZW50ICkgewoJZmxvYXQgZGlzdGFuY2VGYWxsb2ZmID0gMS4wIC8gbWF4KCBwb3coIGxpZ2h0RGlzdGFuY2UsIGRlY2F5RXhwb25lbnQgKSwgMC4wMSApOwoJaWYgKCBjdXRvZmZEaXN0YW5jZSA+IDAuMCApIHsKCQlkaXN0YW5jZUZhbGxvZmYgKj0gcG93Miggc2F0dXJhdGUoIDEuMCAtIHBvdzQoIGxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSApICkgKTsKCX0KCXJldHVybiBkaXN0YW5jZUZhbGxvZmY7Cn0KZmxvYXQgZ2V0U3BvdEF0dGVudWF0aW9uKCBjb25zdCBpbiBmbG9hdCBjb25lQ29zaW5lLCBjb25zdCBpbiBmbG9hdCBwZW51bWJyYUNvc2luZSwgY29uc3QgaW4gZmxvYXQgYW5nbGVDb3NpbmUgKSB7CglyZXR1cm4gc21vb3Roc3RlcCggY29uZUNvc2luZSwgcGVudW1icmFDb3NpbmUsIGFuZ2xlQ29zaW5lICk7Cn0KI2lmIE5VTV9ESVJfTElHSFRTID4gMAoJc3RydWN0IERpcmVjdGlvbmFsTGlnaHQgewoJCXZlYzMgZGlyZWN0aW9uOwoJCXZlYzMgY29sb3I7Cgl9OwoJdW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHRzWyBOVU1fRElSX0xJR0hUUyBdOwoJdm9pZCBnZXREaXJlY3Rpb25hbExpZ2h0SW5mbyggY29uc3QgaW4gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0LCBvdXQgSW5jaWRlbnRMaWdodCBsaWdodCApIHsKCQlsaWdodC5jb2xvciA9IGRpcmVjdGlvbmFsTGlnaHQuY29sb3I7CgkJbGlnaHQuZGlyZWN0aW9uID0gZGlyZWN0aW9uYWxMaWdodC5kaXJlY3Rpb247CgkJbGlnaHQudmlzaWJsZSA9IHRydWU7Cgl9CiNlbmRpZgojaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDAKCXN0cnVjdCBQb2ludExpZ2h0IHsKCQl2ZWMzIHBvc2l0aW9uOwoJCXZlYzMgY29sb3I7CgkJZmxvYXQgZGlzdGFuY2U7CgkJZmxvYXQgZGVjYXk7Cgl9OwoJdW5pZm9ybSBQb2ludExpZ2h0IHBvaW50TGlnaHRzWyBOVU1fUE9JTlRfTElHSFRTIF07Cgl2b2lkIGdldFBvaW50TGlnaHRJbmZvKCBjb25zdCBpbiBQb2ludExpZ2h0IHBvaW50TGlnaHQsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgb3V0IEluY2lkZW50TGlnaHQgbGlnaHQgKSB7CgkJdmVjMyBsVmVjdG9yID0gcG9pbnRMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5UG9zaXRpb247CgkJbGlnaHQuZGlyZWN0aW9uID0gbm9ybWFsaXplKCBsVmVjdG9yICk7CgkJZmxvYXQgbGlnaHREaXN0YW5jZSA9IGxlbmd0aCggbFZlY3RvciApOwoJCWxpZ2h0LmNvbG9yID0gcG9pbnRMaWdodC5jb2xvcjsKCQlsaWdodC5jb2xvciAqPSBnZXREaXN0YW5jZUF0dGVudWF0aW9uKCBsaWdodERpc3RhbmNlLCBwb2ludExpZ2h0LmRpc3RhbmNlLCBwb2ludExpZ2h0LmRlY2F5ICk7CgkJbGlnaHQudmlzaWJsZSA9ICggbGlnaHQuY29sb3IgIT0gdmVjMyggMC4wICkgKTsKCX0KI2VuZGlmCiNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwCglzdHJ1Y3QgU3BvdExpZ2h0IHsKCQl2ZWMzIHBvc2l0aW9uOwoJCXZlYzMgZGlyZWN0aW9uOwoJCXZlYzMgY29sb3I7CgkJZmxvYXQgZGlzdGFuY2U7CgkJZmxvYXQgZGVjYXk7CgkJZmxvYXQgY29uZUNvczsKCQlmbG9hdCBwZW51bWJyYUNvczsKCX07Cgl1bmlmb3JtIFNwb3RMaWdodCBzcG90TGlnaHRzWyBOVU1fU1BPVF9MSUdIVFMgXTsKCXZvaWQgZ2V0U3BvdExpZ2h0SW5mbyggY29uc3QgaW4gU3BvdExpZ2h0IHNwb3RMaWdodCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBvdXQgSW5jaWRlbnRMaWdodCBsaWdodCApIHsKCQl2ZWMzIGxWZWN0b3IgPSBzcG90TGlnaHQucG9zaXRpb24gLSBnZW9tZXRyeVBvc2l0aW9uOwoJCWxpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApOwoJCWZsb2F0IGFuZ2xlQ29zID0gZG90KCBsaWdodC5kaXJlY3Rpb24sIHNwb3RMaWdodC5kaXJlY3Rpb24gKTsKCQlmbG9hdCBzcG90QXR0ZW51YXRpb24gPSBnZXRTcG90QXR0ZW51YXRpb24oIHNwb3RMaWdodC5jb25lQ29zLCBzcG90TGlnaHQucGVudW1icmFDb3MsIGFuZ2xlQ29zICk7CgkJaWYgKCBzcG90QXR0ZW51YXRpb24gPiAwLjAgKSB7CgkJCWZsb2F0IGxpZ2h0RGlzdGFuY2UgPSBsZW5ndGgoIGxWZWN0b3IgKTsKCQkJbGlnaHQuY29sb3IgPSBzcG90TGlnaHQuY29sb3IgKiBzcG90QXR0ZW51YXRpb247CgkJCWxpZ2h0LmNvbG9yICo9IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIGxpZ2h0RGlzdGFuY2UsIHNwb3RMaWdodC5kaXN0YW5jZSwgc3BvdExpZ2h0LmRlY2F5ICk7CgkJCWxpZ2h0LnZpc2libGUgPSAoIGxpZ2h0LmNvbG9yICE9IHZlYzMoIDAuMCApICk7CgkJfSBlbHNlIHsKCQkJbGlnaHQuY29sb3IgPSB2ZWMzKCAwLjAgKTsKCQkJbGlnaHQudmlzaWJsZSA9IGZhbHNlOwoJCX0KCX0KI2VuZGlmCiNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDAKCXN0cnVjdCBSZWN0QXJlYUxpZ2h0IHsKCQl2ZWMzIGNvbG9yOwoJCXZlYzMgcG9zaXRpb247CgkJdmVjMyBoYWxmV2lkdGg7CgkJdmVjMyBoYWxmSGVpZ2h0OwoJfTsKCXVuaWZvcm0gc2FtcGxlcjJEIGx0Y18xOwl1bmlmb3JtIHNhbXBsZXIyRCBsdGNfMjsKCXVuaWZvcm0gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0c1sgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgXTsKI2VuZGlmCiNpZiBOVU1fSEVNSV9MSUdIVFMgPiAwCglzdHJ1Y3QgSGVtaXNwaGVyZUxpZ2h0IHsKCQl2ZWMzIGRpcmVjdGlvbjsKCQl2ZWMzIHNreUNvbG9yOwoJCXZlYzMgZ3JvdW5kQ29sb3I7Cgl9OwoJdW5pZm9ybSBIZW1pc3BoZXJlTGlnaHQgaGVtaXNwaGVyZUxpZ2h0c1sgTlVNX0hFTUlfTElHSFRTIF07Cgl2ZWMzIGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIEhlbWlzcGhlcmVMaWdodCBoZW1pTGlnaHQsIGNvbnN0IGluIHZlYzMgbm9ybWFsICkgewoJCWZsb2F0IGRvdE5MID0gZG90KCBub3JtYWwsIGhlbWlMaWdodC5kaXJlY3Rpb24gKTsKCQlmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdE5MICsgMC41OwoJCXZlYzMgaXJyYWRpYW5jZSA9IG1peCggaGVtaUxpZ2h0Lmdyb3VuZENvbG9yLCBoZW1pTGlnaHQuc2t5Q29sb3IsIGhlbWlEaWZmdXNlV2VpZ2h0ICk7CgkJcmV0dXJuIGlycmFkaWFuY2U7Cgl9CiNlbmRpZmAsQ289YCNpZmRlZiBVU0VfRU5WTUFQCgl2ZWMzIGdldElCTElycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkgewoJCSNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWCgkJCXZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTsKCQkJdmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgZW52TWFwUm90YXRpb24gKiB3b3JsZE5vcm1hbCwgMS4wICk7CgkJCXJldHVybiBQSSAqIGVudk1hcENvbG9yLnJnYiAqIGVudk1hcEludGVuc2l0eTsKCQkjZWxzZQoJCQlyZXR1cm4gdmVjMyggMC4wICk7CgkJI2VuZGlmCgl9Cgl2ZWMzIGdldElCTFJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7CgkJI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVfVVYKCQkJdmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggLSB2aWV3RGlyLCBub3JtYWwgKTsKCQkJcmVmbGVjdFZlYyA9IG5vcm1hbGl6ZSggbWl4KCByZWZsZWN0VmVjLCBub3JtYWwsIHJvdWdobmVzcyAqIHJvdWdobmVzcykgKTsKCQkJcmVmbGVjdFZlYyA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHJlZmxlY3RWZWMsIHZpZXdNYXRyaXggKTsKCQkJdmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgZW52TWFwUm90YXRpb24gKiByZWZsZWN0VmVjLCByb3VnaG5lc3MgKTsKCQkJcmV0dXJuIGVudk1hcENvbG9yLnJnYiAqIGVudk1hcEludGVuc2l0eTsKCQkjZWxzZQoJCQlyZXR1cm4gdmVjMyggMC4wICk7CgkJI2VuZGlmCgl9CgkjaWZkZWYgVVNFX0FOSVNPVFJPUFkKCQl2ZWMzIGdldElCTEFuaXNvdHJvcHlSYWRpYW5jZSggY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBjb25zdCBpbiB2ZWMzIGJpdGFuZ2VudCwgY29uc3QgaW4gZmxvYXQgYW5pc290cm9weSApIHsKCQkJI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVfVVYKCQkJCXZlYzMgYmVudE5vcm1hbCA9IGNyb3NzKCBiaXRhbmdlbnQsIHZpZXdEaXIgKTsKCQkJCWJlbnROb3JtYWwgPSBub3JtYWxpemUoIGNyb3NzKCBiZW50Tm9ybWFsLCBiaXRhbmdlbnQgKSApOwoJCQkJYmVudE5vcm1hbCA9IG5vcm1hbGl6ZSggbWl4KCBiZW50Tm9ybWFsLCBub3JtYWwsIHBvdzIoIHBvdzIoIDEuMCAtIGFuaXNvdHJvcHkgKiAoIDEuMCAtIHJvdWdobmVzcyApICkgKSApICk7CgkJCQlyZXR1cm4gZ2V0SUJMUmFkaWFuY2UoIHZpZXdEaXIsIGJlbnROb3JtYWwsIHJvdWdobmVzcyApOwoJCQkjZWxzZQoJCQkJcmV0dXJuIHZlYzMoIDAuMCApOwoJCQkjZW5kaWYKCQl9CgkjZW5kaWYKI2VuZGlmYCxQbz1gVG9vbk1hdGVyaWFsIG1hdGVyaWFsOwptYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiO2AsRG89YHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uOwpzdHJ1Y3QgVG9vbk1hdGVyaWFsIHsKCXZlYzMgZGlmZnVzZUNvbG9yOwp9Owp2b2lkIFJFX0RpcmVjdF9Ub29uKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBUb29uTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkgewoJdmVjMyBpcnJhZGlhbmNlID0gZ2V0R3JhZGllbnRJcnJhZGlhbmNlKCBnZW9tZXRyeU5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKiBkaXJlY3RMaWdodC5jb2xvcjsKCXJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7Cn0Kdm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfVG9vbiggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBUb29uTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkgewoJcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApOwp9CiNkZWZpbmUgUkVfRGlyZWN0CQkJCVJFX0RpcmVjdF9Ub29uCiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlCQlSRV9JbmRpcmVjdERpZmZ1c2VfVG9vbmAsTG89YEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbDsKbWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjsKbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IHNwZWN1bGFyOwptYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyA9IHNoaW5pbmVzczsKbWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aCA9IHNwZWN1bGFyU3RyZW5ndGg7YCxVbz1gdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CnN0cnVjdCBCbGlublBob25nTWF0ZXJpYWwgewoJdmVjMyBkaWZmdXNlQ29sb3I7Cgl2ZWMzIHNwZWN1bGFyQ29sb3I7CglmbG9hdCBzcGVjdWxhclNoaW5pbmVzczsKCWZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7Cn07CnZvaWQgUkVfRGlyZWN0X0JsaW5uUGhvbmcoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7CglmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Tm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApOwoJdmVjMyBpcnJhZGlhbmNlID0gZG90TkwgKiBkaXJlY3RMaWdodC5jb2xvcjsKCXJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7CglyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9CbGlublBob25nKCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlOb3JtYWwsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyU2hpbmluZXNzICkgKiBtYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoOwp9CnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmcoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHsKCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTsKfQojZGVmaW5lIFJFX0RpcmVjdAkJCQlSRV9EaXJlY3RfQmxpbm5QaG9uZwojZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZQkJUkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmdgLEZvPWBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsOwptYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiICogKCAxLjAgLSBtZXRhbG5lc3NGYWN0b3IgKTsKdmVjMyBkeHkgPSBtYXgoIGFicyggZEZkeCggbm9uUGVydHVyYmVkTm9ybWFsICkgKSwgYWJzKCBkRmR5KCBub25QZXJ0dXJiZWROb3JtYWwgKSApICk7CmZsb2F0IGdlb21ldHJ5Um91Z2huZXNzID0gbWF4KCBtYXgoIGR4eS54LCBkeHkueSApLCBkeHkueiApOwptYXRlcmlhbC5yb3VnaG5lc3MgPSBtYXgoIHJvdWdobmVzc0ZhY3RvciwgMC4wNTI1ICk7bWF0ZXJpYWwucm91Z2huZXNzICs9IGdlb21ldHJ5Um91Z2huZXNzOwptYXRlcmlhbC5yb3VnaG5lc3MgPSBtaW4oIG1hdGVyaWFsLnJvdWdobmVzcywgMS4wICk7CiNpZmRlZiBJT1IKCW1hdGVyaWFsLmlvciA9IGlvcjsKCSNpZmRlZiBVU0VfU1BFQ1VMQVIKCQlmbG9hdCBzcGVjdWxhckludGVuc2l0eUZhY3RvciA9IHNwZWN1bGFySW50ZW5zaXR5OwoJCXZlYzMgc3BlY3VsYXJDb2xvckZhY3RvciA9IHNwZWN1bGFyQ29sb3I7CgkJI2lmZGVmIFVTRV9TUEVDVUxBUl9DT0xPUk1BUAoJCQlzcGVjdWxhckNvbG9yRmFjdG9yICo9IHRleHR1cmUyRCggc3BlY3VsYXJDb2xvck1hcCwgdlNwZWN1bGFyQ29sb3JNYXBVdiApLnJnYjsKCQkjZW5kaWYKCQkjaWZkZWYgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUAoJCQlzcGVjdWxhckludGVuc2l0eUZhY3RvciAqPSB0ZXh0dXJlMkQoIHNwZWN1bGFySW50ZW5zaXR5TWFwLCB2U3BlY3VsYXJJbnRlbnNpdHlNYXBVdiApLmE7CgkJI2VuZGlmCgkJbWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSBtaXgoIHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yLCAxLjAsIG1ldGFsbmVzc0ZhY3RvciApOwoJI2Vsc2UKCQlmbG9hdCBzcGVjdWxhckludGVuc2l0eUZhY3RvciA9IDEuMDsKCQl2ZWMzIHNwZWN1bGFyQ29sb3JGYWN0b3IgPSB2ZWMzKCAxLjAgKTsKCQltYXRlcmlhbC5zcGVjdWxhckY5MCA9IDEuMDsKCSNlbmRpZgoJbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggbWluKCBwb3cyKCAoIG1hdGVyaWFsLmlvciAtIDEuMCApIC8gKCBtYXRlcmlhbC5pb3IgKyAxLjAgKSApICogc3BlY3VsYXJDb2xvckZhY3RvciwgdmVjMyggMS4wICkgKSAqIHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTsKI2Vsc2UKCW1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBtaXgoIHZlYzMoIDAuMDQgKSwgZGlmZnVzZUNvbG9yLnJnYiwgbWV0YWxuZXNzRmFjdG9yICk7CgltYXRlcmlhbC5zcGVjdWxhckY5MCA9IDEuMDsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUCgltYXRlcmlhbC5jbGVhcmNvYXQgPSBjbGVhcmNvYXQ7CgltYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgPSBjbGVhcmNvYXRSb3VnaG5lc3M7CgltYXRlcmlhbC5jbGVhcmNvYXRGMCA9IHZlYzMoIDAuMDQgKTsKCW1hdGVyaWFsLmNsZWFyY29hdEY5MCA9IDEuMDsKCSNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQCgkJbWF0ZXJpYWwuY2xlYXJjb2F0ICo9IHRleHR1cmUyRCggY2xlYXJjb2F0TWFwLCB2Q2xlYXJjb2F0TWFwVXYgKS54OwoJI2VuZGlmCgkjaWZkZWYgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAKCQltYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKj0gdGV4dHVyZTJEKCBjbGVhcmNvYXRSb3VnaG5lc3NNYXAsIHZDbGVhcmNvYXRSb3VnaG5lc3NNYXBVdiApLnk7CgkjZW5kaWYKCW1hdGVyaWFsLmNsZWFyY29hdCA9IHNhdHVyYXRlKCBtYXRlcmlhbC5jbGVhcmNvYXQgKTsJbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gbWF4KCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MsIDAuMDUyNSApOwoJbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICs9IGdlb21ldHJ5Um91Z2huZXNzOwoJbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gbWluKCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MsIDEuMCApOwojZW5kaWYKI2lmZGVmIFVTRV9ESVNQRVJTSU9OCgltYXRlcmlhbC5kaXNwZXJzaW9uID0gZGlzcGVyc2lvbjsKI2VuZGlmCiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0UKCW1hdGVyaWFsLmlyaWRlc2NlbmNlID0gaXJpZGVzY2VuY2U7CgltYXRlcmlhbC5pcmlkZXNjZW5jZUlPUiA9IGlyaWRlc2NlbmNlSU9SOwoJI2lmZGVmIFVTRV9JUklERVNDRU5DRU1BUAoJCW1hdGVyaWFsLmlyaWRlc2NlbmNlICo9IHRleHR1cmUyRCggaXJpZGVzY2VuY2VNYXAsIHZJcmlkZXNjZW5jZU1hcFV2ICkucjsKCSNlbmRpZgoJI2lmZGVmIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVAKCQltYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzcyA9IChpcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0gLSBpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0pICogdGV4dHVyZTJEKCBpcmlkZXNjZW5jZVRoaWNrbmVzc01hcCwgdklyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXYgKS5nICsgaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtOwoJI2Vsc2UKCQltYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzcyA9IGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTsKCSNlbmRpZgojZW5kaWYKI2lmZGVmIFVTRV9TSEVFTgoJbWF0ZXJpYWwuc2hlZW5Db2xvciA9IHNoZWVuQ29sb3I7CgkjaWZkZWYgVVNFX1NIRUVOX0NPTE9STUFQCgkJbWF0ZXJpYWwuc2hlZW5Db2xvciAqPSB0ZXh0dXJlMkQoIHNoZWVuQ29sb3JNYXAsIHZTaGVlbkNvbG9yTWFwVXYgKS5yZ2I7CgkjZW5kaWYKCW1hdGVyaWFsLnNoZWVuUm91Z2huZXNzID0gY2xhbXAoIHNoZWVuUm91Z2huZXNzLCAwLjA3LCAxLjAgKTsKCSNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQCgkJbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgKj0gdGV4dHVyZTJEKCBzaGVlblJvdWdobmVzc01hcCwgdlNoZWVuUm91Z2huZXNzTWFwVXYgKS5hOwoJI2VuZGlmCiNlbmRpZgojaWZkZWYgVVNFX0FOSVNPVFJPUFkKCSNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUAoJCW1hdDIgYW5pc290cm9weU1hdCA9IG1hdDIoIGFuaXNvdHJvcHlWZWN0b3IueCwgYW5pc290cm9weVZlY3Rvci55LCAtIGFuaXNvdHJvcHlWZWN0b3IueSwgYW5pc290cm9weVZlY3Rvci54ICk7CgkJdmVjMyBhbmlzb3Ryb3B5UG9sYXIgPSB0ZXh0dXJlMkQoIGFuaXNvdHJvcHlNYXAsIHZBbmlzb3Ryb3B5TWFwVXYgKS5yZ2I7CgkJdmVjMiBhbmlzb3Ryb3B5ViA9IGFuaXNvdHJvcHlNYXQgKiBub3JtYWxpemUoIDIuMCAqIGFuaXNvdHJvcHlQb2xhci5yZyAtIHZlYzIoIDEuMCApICkgKiBhbmlzb3Ryb3B5UG9sYXIuYjsKCSNlbHNlCgkJdmVjMiBhbmlzb3Ryb3B5ViA9IGFuaXNvdHJvcHlWZWN0b3I7CgkjZW5kaWYKCW1hdGVyaWFsLmFuaXNvdHJvcHkgPSBsZW5ndGgoIGFuaXNvdHJvcHlWICk7CglpZiggbWF0ZXJpYWwuYW5pc290cm9weSA9PSAwLjAgKSB7CgkJYW5pc290cm9weVYgPSB2ZWMyKCAxLjAsIDAuMCApOwoJfSBlbHNlIHsKCQlhbmlzb3Ryb3B5ViAvPSBtYXRlcmlhbC5hbmlzb3Ryb3B5OwoJCW1hdGVyaWFsLmFuaXNvdHJvcHkgPSBzYXR1cmF0ZSggbWF0ZXJpYWwuYW5pc290cm9weSApOwoJfQoJbWF0ZXJpYWwuYWxwaGFUID0gbWl4KCBwb3cyKCBtYXRlcmlhbC5yb3VnaG5lc3MgKSwgMS4wLCBwb3cyKCBtYXRlcmlhbC5hbmlzb3Ryb3B5ICkgKTsKCW1hdGVyaWFsLmFuaXNvdHJvcHlUID0gdGJuWyAwIF0gKiBhbmlzb3Ryb3B5Vi54ICsgdGJuWyAxIF0gKiBhbmlzb3Ryb3B5Vi55OwoJbWF0ZXJpYWwuYW5pc290cm9weUIgPSB0Ym5bIDEgXSAqIGFuaXNvdHJvcHlWLnggLSB0Ym5bIDAgXSAqIGFuaXNvdHJvcHlWLnk7CiNlbmRpZmAsSW89YHN0cnVjdCBQaHlzaWNhbE1hdGVyaWFsIHsKCXZlYzMgZGlmZnVzZUNvbG9yOwoJZmxvYXQgcm91Z2huZXNzOwoJdmVjMyBzcGVjdWxhckNvbG9yOwoJZmxvYXQgc3BlY3VsYXJGOTA7CglmbG9hdCBkaXNwZXJzaW9uOwoJI2lmZGVmIFVTRV9DTEVBUkNPQVQKCQlmbG9hdCBjbGVhcmNvYXQ7CgkJZmxvYXQgY2xlYXJjb2F0Um91Z2huZXNzOwoJCXZlYzMgY2xlYXJjb2F0RjA7CgkJZmxvYXQgY2xlYXJjb2F0RjkwOwoJI2VuZGlmCgkjaWZkZWYgVVNFX0lSSURFU0NFTkNFCgkJZmxvYXQgaXJpZGVzY2VuY2U7CgkJZmxvYXQgaXJpZGVzY2VuY2VJT1I7CgkJZmxvYXQgaXJpZGVzY2VuY2VUaGlja25lc3M7CgkJdmVjMyBpcmlkZXNjZW5jZUZyZXNuZWw7CgkJdmVjMyBpcmlkZXNjZW5jZUYwOwoJI2VuZGlmCgkjaWZkZWYgVVNFX1NIRUVOCgkJdmVjMyBzaGVlbkNvbG9yOwoJCWZsb2F0IHNoZWVuUm91Z2huZXNzOwoJI2VuZGlmCgkjaWZkZWYgSU9SCgkJZmxvYXQgaW9yOwoJI2VuZGlmCgkjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTgoJCWZsb2F0IHRyYW5zbWlzc2lvbjsKCQlmbG9hdCB0cmFuc21pc3Npb25BbHBoYTsKCQlmbG9hdCB0aGlja25lc3M7CgkJZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZTsKCQl2ZWMzIGF0dGVudWF0aW9uQ29sb3I7CgkjZW5kaWYKCSNpZmRlZiBVU0VfQU5JU09UUk9QWQoJCWZsb2F0IGFuaXNvdHJvcHk7CgkJZmxvYXQgYWxwaGFUOwoJCXZlYzMgYW5pc290cm9weVQ7CgkJdmVjMyBhbmlzb3Ryb3B5QjsKCSNlbmRpZgp9Owp2ZWMzIGNsZWFyY29hdFNwZWN1bGFyRGlyZWN0ID0gdmVjMyggMC4wICk7CnZlYzMgY2xlYXJjb2F0U3BlY3VsYXJJbmRpcmVjdCA9IHZlYzMoIDAuMCApOwp2ZWMzIHNoZWVuU3BlY3VsYXJEaXJlY3QgPSB2ZWMzKCAwLjAgKTsKdmVjMyBzaGVlblNwZWN1bGFySW5kaXJlY3QgPSB2ZWMzKDAuMCApOwp2ZWMzIFNjaGxpY2tfdG9fRjAoIGNvbnN0IGluIHZlYzMgZiwgY29uc3QgaW4gZmxvYXQgZjkwLCBjb25zdCBpbiBmbG9hdCBkb3RWSCApIHsKICAgIGZsb2F0IHggPSBjbGFtcCggMS4wIC0gZG90VkgsIDAuMCwgMS4wICk7CiAgICBmbG9hdCB4MiA9IHggKiB4OwogICAgZmxvYXQgeDUgPSBjbGFtcCggeCAqIHgyICogeDIsIDAuMCwgMC45OTk5ICk7CiAgICByZXR1cm4gKCBmIC0gdmVjMyggZjkwICkgKiB4NSApIC8gKCAxLjAgLSB4NSApOwp9CmZsb2F0IFZfR0dYX1NtaXRoQ29ycmVsYXRlZCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5MLCBjb25zdCBpbiBmbG9hdCBkb3ROViApIHsKCWZsb2F0IGEyID0gcG93MiggYWxwaGEgKTsKCWZsb2F0IGd2ID0gZG90TkwgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5WICkgKTsKCWZsb2F0IGdsID0gZG90TlYgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5MICkgKTsKCXJldHVybiAwLjUgLyBtYXgoIGd2ICsgZ2wsIEVQU0lMT04gKTsKfQpmbG9hdCBEX0dHWCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5IICkgewoJZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApOwoJZmxvYXQgZGVub20gPSBwb3cyKCBkb3ROSCApICogKCBhMiAtIDEuMCApICsgMS4wOwoJcmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBhMiAvIHBvdzIoIGRlbm9tICk7Cn0KI2lmZGVmIFVTRV9BTklTT1RST1BZCglmbG9hdCBWX0dHWF9TbWl0aENvcnJlbGF0ZWRfQW5pc290cm9waWMoIGNvbnN0IGluIGZsb2F0IGFscGhhVCwgY29uc3QgaW4gZmxvYXQgYWxwaGFCLCBjb25zdCBpbiBmbG9hdCBkb3RUViwgY29uc3QgaW4gZmxvYXQgZG90QlYsIGNvbnN0IGluIGZsb2F0IGRvdFRMLCBjb25zdCBpbiBmbG9hdCBkb3RCTCwgY29uc3QgaW4gZmxvYXQgZG90TlYsIGNvbnN0IGluIGZsb2F0IGRvdE5MICkgewoJCWZsb2F0IGd2ID0gZG90TkwgKiBsZW5ndGgoIHZlYzMoIGFscGhhVCAqIGRvdFRWLCBhbHBoYUIgKiBkb3RCViwgZG90TlYgKSApOwoJCWZsb2F0IGdsID0gZG90TlYgKiBsZW5ndGgoIHZlYzMoIGFscGhhVCAqIGRvdFRMLCBhbHBoYUIgKiBkb3RCTCwgZG90TkwgKSApOwoJCWZsb2F0IHYgPSAwLjUgLyAoIGd2ICsgZ2wgKTsKCQlyZXR1cm4gc2F0dXJhdGUodik7Cgl9CglmbG9hdCBEX0dHWF9Bbmlzb3Ryb3BpYyggY29uc3QgaW4gZmxvYXQgYWxwaGFULCBjb25zdCBpbiBmbG9hdCBhbHBoYUIsIGNvbnN0IGluIGZsb2F0IGRvdE5ILCBjb25zdCBpbiBmbG9hdCBkb3RUSCwgY29uc3QgaW4gZmxvYXQgZG90QkggKSB7CgkJZmxvYXQgYTIgPSBhbHBoYVQgKiBhbHBoYUI7CgkJaGlnaHAgdmVjMyB2ID0gdmVjMyggYWxwaGFCICogZG90VEgsIGFscGhhVCAqIGRvdEJILCBhMiAqIGRvdE5IICk7CgkJaGlnaHAgZmxvYXQgdjIgPSBkb3QoIHYsIHYgKTsKCQlmbG9hdCB3MiA9IGEyIC8gdjI7CgkJcmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBhMiAqIHBvdzIgKCB3MiApOwoJfQojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVQKCXZlYzMgQlJERl9HR1hfQ2xlYXJjb2F0KCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsKSB7CgkJdmVjMyBmMCA9IG1hdGVyaWFsLmNsZWFyY29hdEYwOwoJCWZsb2F0IGY5MCA9IG1hdGVyaWFsLmNsZWFyY29hdEY5MDsKCQlmbG9hdCByb3VnaG5lc3MgPSBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3M7CgkJZmxvYXQgYWxwaGEgPSBwb3cyKCByb3VnaG5lc3MgKTsKCQl2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApOwoJCWZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7CgkJZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApOwoJCWZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTsKCQlmbG9hdCBkb3RWSCA9IHNhdHVyYXRlKCBkb3QoIHZpZXdEaXIsIGhhbGZEaXIgKSApOwoJCXZlYzMgRiA9IEZfU2NobGljayggZjAsIGY5MCwgZG90VkggKTsKCQlmbG9hdCBWID0gVl9HR1hfU21pdGhDb3JyZWxhdGVkKCBhbHBoYSwgZG90TkwsIGRvdE5WICk7CgkJZmxvYXQgRCA9IERfR0dYKCBhbHBoYSwgZG90TkggKTsKCQlyZXR1cm4gRiAqICggViAqIEQgKTsKCX0KI2VuZGlmCnZlYzMgQlJERl9HR1goIGNvbnN0IGluIHZlYzMgbGlnaHREaXIsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwgKSB7Cgl2ZWMzIGYwID0gbWF0ZXJpYWwuc3BlY3VsYXJDb2xvcjsKCWZsb2F0IGY5MCA9IG1hdGVyaWFsLnNwZWN1bGFyRjkwOwoJZmxvYXQgcm91Z2huZXNzID0gbWF0ZXJpYWwucm91Z2huZXNzOwoJZmxvYXQgYWxwaGEgPSBwb3cyKCByb3VnaG5lc3MgKTsKCXZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7CglmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApOwoJZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApOwoJZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApOwoJZmxvYXQgZG90VkggPSBzYXR1cmF0ZSggZG90KCB2aWV3RGlyLCBoYWxmRGlyICkgKTsKCXZlYzMgRiA9IEZfU2NobGljayggZjAsIGY5MCwgZG90VkggKTsKCSNpZmRlZiBVU0VfSVJJREVTQ0VOQ0UKCQlGID0gbWl4KCBGLCBtYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwsIG1hdGVyaWFsLmlyaWRlc2NlbmNlICk7CgkjZW5kaWYKCSNpZmRlZiBVU0VfQU5JU09UUk9QWQoJCWZsb2F0IGRvdFRMID0gZG90KCBtYXRlcmlhbC5hbmlzb3Ryb3B5VCwgbGlnaHREaXIgKTsKCQlmbG9hdCBkb3RUViA9IGRvdCggbWF0ZXJpYWwuYW5pc290cm9weVQsIHZpZXdEaXIgKTsKCQlmbG9hdCBkb3RUSCA9IGRvdCggbWF0ZXJpYWwuYW5pc290cm9weVQsIGhhbGZEaXIgKTsKCQlmbG9hdCBkb3RCTCA9IGRvdCggbWF0ZXJpYWwuYW5pc290cm9weUIsIGxpZ2h0RGlyICk7CgkJZmxvYXQgZG90QlYgPSBkb3QoIG1hdGVyaWFsLmFuaXNvdHJvcHlCLCB2aWV3RGlyICk7CgkJZmxvYXQgZG90QkggPSBkb3QoIG1hdGVyaWFsLmFuaXNvdHJvcHlCLCBoYWxmRGlyICk7CgkJZmxvYXQgViA9IFZfR0dYX1NtaXRoQ29ycmVsYXRlZF9Bbmlzb3Ryb3BpYyggbWF0ZXJpYWwuYWxwaGFULCBhbHBoYSwgZG90VFYsIGRvdEJWLCBkb3RUTCwgZG90QkwsIGRvdE5WLCBkb3ROTCApOwoJCWZsb2F0IEQgPSBEX0dHWF9Bbmlzb3Ryb3BpYyggbWF0ZXJpYWwuYWxwaGFULCBhbHBoYSwgZG90TkgsIGRvdFRILCBkb3RCSCApOwoJI2Vsc2UKCQlmbG9hdCBWID0gVl9HR1hfU21pdGhDb3JyZWxhdGVkKCBhbHBoYSwgZG90TkwsIGRvdE5WICk7CgkJZmxvYXQgRCA9IERfR0dYKCBhbHBoYSwgZG90TkggKTsKCSNlbmRpZgoJcmV0dXJuIEYgKiAoIFYgKiBEICk7Cn0KdmVjMiBMVENfVXYoIGNvbnN0IGluIHZlYzMgTiwgY29uc3QgaW4gdmVjMyBWLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7Cgljb25zdCBmbG9hdCBMVVRfU0laRSA9IDY0LjA7Cgljb25zdCBmbG9hdCBMVVRfU0NBTEUgPSAoIExVVF9TSVpFIC0gMS4wICkgLyBMVVRfU0laRTsKCWNvbnN0IGZsb2F0IExVVF9CSUFTID0gMC41IC8gTFVUX1NJWkU7CglmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIE4sIFYgKSApOwoJdmVjMiB1diA9IHZlYzIoIHJvdWdobmVzcywgc3FydCggMS4wIC0gZG90TlYgKSApOwoJdXYgPSB1diAqIExVVF9TQ0FMRSArIExVVF9CSUFTOwoJcmV0dXJuIHV2Owp9CmZsb2F0IExUQ19DbGlwcGVkU3BoZXJlRm9ybUZhY3RvciggY29uc3QgaW4gdmVjMyBmICkgewoJZmxvYXQgbCA9IGxlbmd0aCggZiApOwoJcmV0dXJuIG1heCggKCBsICogbCArIGYueiApIC8gKCBsICsgMS4wICksIDAuMCApOwp9CnZlYzMgTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb25zdCBpbiB2ZWMzIHYxLCBjb25zdCBpbiB2ZWMzIHYyICkgewoJZmxvYXQgeCA9IGRvdCggdjEsIHYyICk7CglmbG9hdCB5ID0gYWJzKCB4ICk7CglmbG9hdCBhID0gMC44NTQzOTg1ICsgKCAwLjQ5NjUxNTUgKyAwLjAxNDUyMDYgKiB5ICkgKiB5OwoJZmxvYXQgYiA9IDMuNDE3NTk0MCArICggNC4xNjE2NzI0ICsgeSApICogeTsKCWZsb2F0IHYgPSBhIC8gYjsKCWZsb2F0IHRoZXRhX3NpbnRoZXRhID0gKCB4ID4gMC4wICkgPyB2IDogMC41ICogaW52ZXJzZXNxcnQoIG1heCggMS4wIC0geCAqIHgsIDFlLTcgKSApIC0gdjsKCXJldHVybiBjcm9zcyggdjEsIHYyICkgKiB0aGV0YV9zaW50aGV0YTsKfQp2ZWMzIExUQ19FdmFsdWF0ZSggY29uc3QgaW4gdmVjMyBOLCBjb25zdCBpbiB2ZWMzIFYsIGNvbnN0IGluIHZlYzMgUCwgY29uc3QgaW4gbWF0MyBtSW52LCBjb25zdCBpbiB2ZWMzIHJlY3RDb29yZHNbIDQgXSApIHsKCXZlYzMgdjEgPSByZWN0Q29vcmRzWyAxIF0gLSByZWN0Q29vcmRzWyAwIF07Cgl2ZWMzIHYyID0gcmVjdENvb3Jkc1sgMyBdIC0gcmVjdENvb3Jkc1sgMCBdOwoJdmVjMyBsaWdodE5vcm1hbCA9IGNyb3NzKCB2MSwgdjIgKTsKCWlmKCBkb3QoIGxpZ2h0Tm9ybWFsLCBQIC0gcmVjdENvb3Jkc1sgMCBdICkgPCAwLjAgKSByZXR1cm4gdmVjMyggMC4wICk7Cgl2ZWMzIFQxLCBUMjsKCVQxID0gbm9ybWFsaXplKCBWIC0gTiAqIGRvdCggViwgTiApICk7CglUMiA9IC0gY3Jvc3MoIE4sIFQxICk7CgltYXQzIG1hdCA9IG1JbnYgKiB0cmFuc3Bvc2VNYXQzKCBtYXQzKCBUMSwgVDIsIE4gKSApOwoJdmVjMyBjb29yZHNbIDQgXTsKCWNvb3Jkc1sgMCBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAwIF0gLSBQICk7Cgljb29yZHNbIDEgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMSBdIC0gUCApOwoJY29vcmRzWyAyIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDIgXSAtIFAgKTsKCWNvb3Jkc1sgMyBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAzIF0gLSBQICk7Cgljb29yZHNbIDAgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAwIF0gKTsKCWNvb3Jkc1sgMSBdID0gbm9ybWFsaXplKCBjb29yZHNbIDEgXSApOwoJY29vcmRzWyAyIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMiBdICk7Cgljb29yZHNbIDMgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAzIF0gKTsKCXZlYzMgdmVjdG9yRm9ybUZhY3RvciA9IHZlYzMoIDAuMCApOwoJdmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMCBdLCBjb29yZHNbIDEgXSApOwoJdmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMSBdLCBjb29yZHNbIDIgXSApOwoJdmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMiBdLCBjb29yZHNbIDMgXSApOwoJdmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMyBdLCBjb29yZHNbIDAgXSApOwoJZmxvYXQgcmVzdWx0ID0gTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCB2ZWN0b3JGb3JtRmFjdG9yICk7CglyZXR1cm4gdmVjMyggcmVzdWx0ICk7Cn0KI2lmIGRlZmluZWQoIFVTRV9TSEVFTiApCmZsb2F0IERfQ2hhcmxpZSggZmxvYXQgcm91Z2huZXNzLCBmbG9hdCBkb3ROSCApIHsKCWZsb2F0IGFscGhhID0gcG93Miggcm91Z2huZXNzICk7CglmbG9hdCBpbnZBbHBoYSA9IDEuMCAvIGFscGhhOwoJZmxvYXQgY29zMmggPSBkb3ROSCAqIGRvdE5IOwoJZmxvYXQgc2luMmggPSBtYXgoIDEuMCAtIGNvczJoLCAwLjAwNzgxMjUgKTsKCXJldHVybiAoIDIuMCArIGludkFscGhhICkgKiBwb3coIHNpbjJoLCBpbnZBbHBoYSAqIDAuNSApIC8gKCAyLjAgKiBQSSApOwp9CmZsb2F0IFZfTmV1YmVsdCggZmxvYXQgZG90TlYsIGZsb2F0IGRvdE5MICkgewoJcmV0dXJuIHNhdHVyYXRlKCAxLjAgLyAoIDQuMCAqICggZG90TkwgKyBkb3ROViAtIGRvdE5MICogZG90TlYgKSApICk7Cn0KdmVjMyBCUkRGX1NoZWVuKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCB2ZWMzIHNoZWVuQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoZWVuUm91Z2huZXNzICkgewoJdmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBsaWdodERpciArIHZpZXdEaXIgKTsKCWZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7CglmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7CglmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7CglmbG9hdCBEID0gRF9DaGFybGllKCBzaGVlblJvdWdobmVzcywgZG90TkggKTsKCWZsb2F0IFYgPSBWX05ldWJlbHQoIGRvdE5WLCBkb3ROTCApOwoJcmV0dXJuIHNoZWVuQ29sb3IgKiAoIEQgKiBWICk7Cn0KI2VuZGlmCmZsb2F0IElCTFNoZWVuQlJERiggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkgewoJZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApOwoJZmxvYXQgcjIgPSByb3VnaG5lc3MgKiByb3VnaG5lc3M7CglmbG9hdCBhID0gcm91Z2huZXNzIDwgMC4yNSA/IC0zMzkuMiAqIHIyICsgMTYxLjQgKiByb3VnaG5lc3MgLSAyNS45IDogLTguNDggKiByMiArIDE0LjMgKiByb3VnaG5lc3MgLSA5Ljk1OwoJZmxvYXQgYiA9IHJvdWdobmVzcyA8IDAuMjUgPyA0NC4wICogcjIgLSAyMy43ICogcm91Z2huZXNzICsgMy4yNiA6IDEuOTcgKiByMiAtIDMuMjcgKiByb3VnaG5lc3MgKyAwLjcyOwoJZmxvYXQgREcgPSBleHAoIGEgKiBkb3ROViArIGIgKSArICggcm91Z2huZXNzIDwgMC4yNSA/IDAuMCA6IDAuMSAqICggcm91Z2huZXNzIC0gMC4yNSApICk7CglyZXR1cm4gc2F0dXJhdGUoIERHICogUkVDSVBST0NBTF9QSSApOwp9CnZlYzIgREZHQXBwcm94KCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7CglmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7Cgljb25zdCB2ZWM0IGMwID0gdmVjNCggLSAxLCAtIDAuMDI3NSwgLSAwLjU3MiwgMC4wMjIgKTsKCWNvbnN0IHZlYzQgYzEgPSB2ZWM0KCAxLCAwLjA0MjUsIDEuMDQsIC0gMC4wNCApOwoJdmVjNCByID0gcm91Z2huZXNzICogYzAgKyBjMTsKCWZsb2F0IGEwMDQgPSBtaW4oIHIueCAqIHIueCwgZXhwMiggLSA5LjI4ICogZG90TlYgKSApICogci54ICsgci55OwoJdmVjMiBmYWIgPSB2ZWMyKCAtIDEuMDQsIDEuMDQgKSAqIGEwMDQgKyByLnp3OwoJcmV0dXJuIGZhYjsKfQp2ZWMzIEVudmlyb25tZW50QlJERiggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkgewoJdmVjMiBmYWIgPSBERkdBcHByb3goIG5vcm1hbCwgdmlld0Rpciwgcm91Z2huZXNzICk7CglyZXR1cm4gc3BlY3VsYXJDb2xvciAqIGZhYi54ICsgc3BlY3VsYXJGOTAgKiBmYWIueTsKfQojaWZkZWYgVVNFX0lSSURFU0NFTkNFCnZvaWQgY29tcHV0ZU11bHRpc2NhdHRlcmluZ0lyaWRlc2NlbmNlKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNwZWN1bGFyRjkwLCBjb25zdCBpbiBmbG9hdCBpcmlkZXNjZW5jZSwgY29uc3QgaW4gdmVjMyBpcmlkZXNjZW5jZUYwLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGlub3V0IHZlYzMgc2luZ2xlU2NhdHRlciwgaW5vdXQgdmVjMyBtdWx0aVNjYXR0ZXIgKSB7CiNlbHNlCnZvaWQgY29tcHV0ZU11bHRpc2NhdHRlcmluZyggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBpbm91dCB2ZWMzIHNpbmdsZVNjYXR0ZXIsIGlub3V0IHZlYzMgbXVsdGlTY2F0dGVyICkgewojZW5kaWYKCXZlYzIgZmFiID0gREZHQXBwcm94KCBub3JtYWwsIHZpZXdEaXIsIHJvdWdobmVzcyApOwoJI2lmZGVmIFVTRV9JUklERVNDRU5DRQoJCXZlYzMgRnIgPSBtaXgoIHNwZWN1bGFyQ29sb3IsIGlyaWRlc2NlbmNlRjAsIGlyaWRlc2NlbmNlICk7CgkjZWxzZQoJCXZlYzMgRnIgPSBzcGVjdWxhckNvbG9yOwoJI2VuZGlmCgl2ZWMzIEZzc0VzcyA9IEZyICogZmFiLnggKyBzcGVjdWxhckY5MCAqIGZhYi55OwoJZmxvYXQgRXNzID0gZmFiLnggKyBmYWIueTsKCWZsb2F0IEVtcyA9IDEuMCAtIEVzczsKCXZlYzMgRmF2ZyA9IEZyICsgKCAxLjAgLSBGciApICogMC4wNDc2MTk7CXZlYzMgRm1zID0gRnNzRXNzICogRmF2ZyAvICggMS4wIC0gRW1zICogRmF2ZyApOwoJc2luZ2xlU2NhdHRlciArPSBGc3NFc3M7CgltdWx0aVNjYXR0ZXIgKz0gRm1zICogRW1zOwp9CiNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDAKCXZvaWQgUkVfRGlyZWN0X1JlY3RBcmVhX1BoeXNpY2FsKCBjb25zdCBpbiBSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHQsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkgewoJCXZlYzMgbm9ybWFsID0gZ2VvbWV0cnlOb3JtYWw7CgkJdmVjMyB2aWV3RGlyID0gZ2VvbWV0cnlWaWV3RGlyOwoJCXZlYzMgcG9zaXRpb24gPSBnZW9tZXRyeVBvc2l0aW9uOwoJCXZlYzMgbGlnaHRQb3MgPSByZWN0QXJlYUxpZ2h0LnBvc2l0aW9uOwoJCXZlYzMgaGFsZldpZHRoID0gcmVjdEFyZWFMaWdodC5oYWxmV2lkdGg7CgkJdmVjMyBoYWxmSGVpZ2h0ID0gcmVjdEFyZWFMaWdodC5oYWxmSGVpZ2h0OwoJCXZlYzMgbGlnaHRDb2xvciA9IHJlY3RBcmVhTGlnaHQuY29sb3I7CgkJZmxvYXQgcm91Z2huZXNzID0gbWF0ZXJpYWwucm91Z2huZXNzOwoJCXZlYzMgcmVjdENvb3Jkc1sgNCBdOwoJCXJlY3RDb29yZHNbIDAgXSA9IGxpZ2h0UG9zICsgaGFsZldpZHRoIC0gaGFsZkhlaWdodDsJCXJlY3RDb29yZHNbIDEgXSA9IGxpZ2h0UG9zIC0gaGFsZldpZHRoIC0gaGFsZkhlaWdodDsKCQlyZWN0Q29vcmRzWyAyIF0gPSBsaWdodFBvcyAtIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7CgkJcmVjdENvb3Jkc1sgMyBdID0gbGlnaHRQb3MgKyBoYWxmV2lkdGggKyBoYWxmSGVpZ2h0OwoJCXZlYzIgdXYgPSBMVENfVXYoIG5vcm1hbCwgdmlld0Rpciwgcm91Z2huZXNzICk7CgkJdmVjNCB0MSA9IHRleHR1cmUyRCggbHRjXzEsIHV2ICk7CgkJdmVjNCB0MiA9IHRleHR1cmUyRCggbHRjXzIsIHV2ICk7CgkJbWF0MyBtSW52ID0gbWF0MygKCQkJdmVjMyggdDEueCwgMCwgdDEueSApLAoJCQl2ZWMzKCAgICAwLCAxLCAgICAwICksCgkJCXZlYzMoIHQxLnosIDAsIHQxLncgKQoJCSk7CgkJdmVjMyBmcmVzbmVsID0gKCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICogdDIueCArICggdmVjMyggMS4wICkgLSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICkgKiB0Mi55ICk7CgkJcmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gbGlnaHRDb2xvciAqIGZyZXNuZWwgKiBMVENfRXZhbHVhdGUoIG5vcm1hbCwgdmlld0RpciwgcG9zaXRpb24sIG1JbnYsIHJlY3RDb29yZHMgKTsKCQlyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGxpZ2h0Q29sb3IgKiBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKiBMVENfRXZhbHVhdGUoIG5vcm1hbCwgdmlld0RpciwgcG9zaXRpb24sIG1hdDMoIDEuMCApLCByZWN0Q29vcmRzICk7Cgl9CiNlbmRpZgp2b2lkIFJFX0RpcmVjdF9QaHlzaWNhbCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7CglmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Tm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApOwoJdmVjMyBpcnJhZGlhbmNlID0gZG90TkwgKiBkaXJlY3RMaWdodC5jb2xvcjsKCSNpZmRlZiBVU0VfQ0xFQVJDT0FUCgkJZmxvYXQgZG90TkxjYyA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApOwoJCXZlYzMgY2NJcnJhZGlhbmNlID0gZG90TkxjYyAqIGRpcmVjdExpZ2h0LmNvbG9yOwoJCWNsZWFyY29hdFNwZWN1bGFyRGlyZWN0ICs9IGNjSXJyYWRpYW5jZSAqIEJSREZfR0dYX0NsZWFyY29hdCggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbCApOwoJI2VuZGlmCgkjaWZkZWYgVVNFX1NIRUVOCgkJc2hlZW5TcGVjdWxhckRpcmVjdCArPSBpcnJhZGlhbmNlICogQlJERl9TaGVlbiggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Tm9ybWFsLCBtYXRlcmlhbC5zaGVlbkNvbG9yLCBtYXRlcmlhbC5zaGVlblJvdWdobmVzcyApOwoJI2VuZGlmCglyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9HR1goIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeU5vcm1hbCwgbWF0ZXJpYWwgKTsKCXJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7Cn0Kdm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7CglyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7Cn0Kdm9pZCBSRV9JbmRpcmVjdFNwZWN1bGFyX1BoeXNpY2FsKCBjb25zdCBpbiB2ZWMzIHJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgY2xlYXJjb2F0UmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0KSB7CgkjaWZkZWYgVVNFX0NMRUFSQ09BVAoJCWNsZWFyY29hdFNwZWN1bGFySW5kaXJlY3QgKz0gY2xlYXJjb2F0UmFkaWFuY2UgKiBFbnZpcm9ubWVudEJSREYoIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIsIG1hdGVyaWFsLmNsZWFyY29hdEYwLCBtYXRlcmlhbC5jbGVhcmNvYXRGOTAsIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyApOwoJI2VuZGlmCgkjaWZkZWYgVVNFX1NIRUVOCgkJc2hlZW5TcGVjdWxhckluZGlyZWN0ICs9IGlycmFkaWFuY2UgKiBtYXRlcmlhbC5zaGVlbkNvbG9yICogSUJMU2hlZW5CUkRGKCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBtYXRlcmlhbC5zaGVlblJvdWdobmVzcyApOwoJI2VuZGlmCgl2ZWMzIHNpbmdsZVNjYXR0ZXJpbmcgPSB2ZWMzKCAwLjAgKTsKCXZlYzMgbXVsdGlTY2F0dGVyaW5nID0gdmVjMyggMC4wICk7Cgl2ZWMzIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZSA9IGlycmFkaWFuY2UgKiBSRUNJUFJPQ0FMX1BJOwoJI2lmZGVmIFVTRV9JUklERVNDRU5DRQoJCWNvbXB1dGVNdWx0aXNjYXR0ZXJpbmdJcmlkZXNjZW5jZSggZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsIG1hdGVyaWFsLmlyaWRlc2NlbmNlLCBtYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwsIG1hdGVyaWFsLnJvdWdobmVzcywgc2luZ2xlU2NhdHRlcmluZywgbXVsdGlTY2F0dGVyaW5nICk7CgkjZWxzZQoJCWNvbXB1dGVNdWx0aXNjYXR0ZXJpbmcoIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyRjkwLCBtYXRlcmlhbC5yb3VnaG5lc3MsIHNpbmdsZVNjYXR0ZXJpbmcsIG11bHRpU2NhdHRlcmluZyApOwoJI2VuZGlmCgl2ZWMzIHRvdGFsU2NhdHRlcmluZyA9IHNpbmdsZVNjYXR0ZXJpbmcgKyBtdWx0aVNjYXR0ZXJpbmc7Cgl2ZWMzIGRpZmZ1c2UgPSBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKiAoIDEuMCAtIG1heCggbWF4KCB0b3RhbFNjYXR0ZXJpbmcuciwgdG90YWxTY2F0dGVyaW5nLmcgKSwgdG90YWxTY2F0dGVyaW5nLmIgKSApOwoJcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArPSByYWRpYW5jZSAqIHNpbmdsZVNjYXR0ZXJpbmc7CglyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICs9IG11bHRpU2NhdHRlcmluZyAqIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZTsKCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBkaWZmdXNlICogY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlOwp9CiNkZWZpbmUgUkVfRGlyZWN0CQkJCVJFX0RpcmVjdF9QaHlzaWNhbAojZGVmaW5lIFJFX0RpcmVjdF9SZWN0QXJlYQkJUkVfRGlyZWN0X1JlY3RBcmVhX1BoeXNpY2FsCiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlCQlSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWwKI2RlZmluZSBSRV9JbmRpcmVjdFNwZWN1bGFyCQlSRV9JbmRpcmVjdFNwZWN1bGFyX1BoeXNpY2FsCmZsb2F0IGNvbXB1dGVTcGVjdWxhck9jY2x1c2lvbiggY29uc3QgaW4gZmxvYXQgZG90TlYsIGNvbnN0IGluIGZsb2F0IGFtYmllbnRPY2NsdXNpb24sIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHsKCXJldHVybiBzYXR1cmF0ZSggcG93KCBkb3ROViArIGFtYmllbnRPY2NsdXNpb24sIGV4cDIoIC0gMTYuMCAqIHJvdWdobmVzcyAtIDEuMCApICkgLSAxLjAgKyBhbWJpZW50T2NjbHVzaW9uICk7Cn1gLE5vPWAKdmVjMyBnZW9tZXRyeVBvc2l0aW9uID0gLSB2Vmlld1Bvc2l0aW9uOwp2ZWMzIGdlb21ldHJ5Tm9ybWFsID0gbm9ybWFsOwp2ZWMzIGdlb21ldHJ5Vmlld0RpciA9ICggaXNPcnRob2dyYXBoaWMgKSA/IHZlYzMoIDAsIDAsIDEgKSA6IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApOwp2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsID0gdmVjMyggMC4wICk7CiNpZmRlZiBVU0VfQ0xFQVJDT0FUCglnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCA9IGNsZWFyY29hdE5vcm1hbDsKI2VuZGlmCiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0UKCWZsb2F0IGRvdE5WaSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyICkgKTsKCWlmICggbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3MgPT0gMC4wICkgewoJCW1hdGVyaWFsLmlyaWRlc2NlbmNlID0gMC4wOwoJfSBlbHNlIHsKCQltYXRlcmlhbC5pcmlkZXNjZW5jZSA9IHNhdHVyYXRlKCBtYXRlcmlhbC5pcmlkZXNjZW5jZSApOwoJfQoJaWYgKCBtYXRlcmlhbC5pcmlkZXNjZW5jZSA+IDAuMCApIHsKCQltYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwgPSBldmFsSXJpZGVzY2VuY2UoIDEuMCwgbWF0ZXJpYWwuaXJpZGVzY2VuY2VJT1IsIGRvdE5WaSwgbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3MsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKTsKCQltYXRlcmlhbC5pcmlkZXNjZW5jZUYwID0gU2NobGlja190b19GMCggbWF0ZXJpYWwuaXJpZGVzY2VuY2VGcmVzbmVsLCAxLjAsIGRvdE5WaSApOwoJfQojZW5kaWYKSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodDsKI2lmICggTlVNX1BPSU5UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKQoJUG9pbnRMaWdodCBwb2ludExpZ2h0OwoJI2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDAKCVBvaW50TGlnaHRTaGFkb3cgcG9pbnRMaWdodFNoYWRvdzsKCSNlbmRpZgoJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJZm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHsKCQlwb2ludExpZ2h0ID0gcG9pbnRMaWdodHNbIGkgXTsKCQlnZXRQb2ludExpZ2h0SW5mbyggcG9pbnRMaWdodCwgZ2VvbWV0cnlQb3NpdGlvbiwgZGlyZWN0TGlnaHQgKTsKCQkjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmICggVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTICkKCQlwb2ludExpZ2h0U2hhZG93ID0gcG9pbnRMaWdodFNoYWRvd3NbIGkgXTsKCQlkaXJlY3RMaWdodC5jb2xvciAqPSAoIGRpcmVjdExpZ2h0LnZpc2libGUgJiYgcmVjZWl2ZVNoYWRvdyApID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dJbnRlbnNpdHksIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93QmlhcywgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0sIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93Q2FtZXJhTmVhciwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dDYW1lcmFGYXIgKSA6IDEuMDsKCQkjZW5kaWYKCQlSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeVBvc2l0aW9uLCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7Cgl9CgkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAojZW5kaWYKI2lmICggTlVNX1NQT1RfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApCglTcG90TGlnaHQgc3BvdExpZ2h0OwoJdmVjNCBzcG90Q29sb3I7Cgl2ZWMzIHNwb3RMaWdodENvb3JkOwoJYm9vbCBpblNwb3RMaWdodE1hcDsKCSNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDAKCVNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHRTaGFkb3c7CgkjZW5kaWYKCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCWZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHsKCQlzcG90TGlnaHQgPSBzcG90TGlnaHRzWyBpIF07CgkJZ2V0U3BvdExpZ2h0SW5mbyggc3BvdExpZ2h0LCBnZW9tZXRyeVBvc2l0aW9uLCBkaXJlY3RMaWdodCApOwoJCSNpZiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTX1dJVEhfTUFQUyApCgkJI2RlZmluZSBTUE9UX0xJR0hUX01BUF9JTkRFWCBVTlJPTExFRF9MT09QX0lOREVYCgkJI2VsaWYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyApCgkJI2RlZmluZSBTUE9UX0xJR0hUX01BUF9JTkRFWCBOVU1fU1BPVF9MSUdIVF9NQVBTCgkJI2Vsc2UKCQkjZGVmaW5lIFNQT1RfTElHSFRfTUFQX0lOREVYICggVU5ST0xMRURfTE9PUF9JTkRFWCAtIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgKyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTX1dJVEhfTUFQUyApCgkJI2VuZGlmCgkJI2lmICggU1BPVF9MSUdIVF9NQVBfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9NQVBTICkKCQkJc3BvdExpZ2h0Q29vcmQgPSB2U3BvdExpZ2h0Q29vcmRbIGkgXS54eXogLyB2U3BvdExpZ2h0Q29vcmRbIGkgXS53OwoJCQlpblNwb3RMaWdodE1hcCA9IGFsbCggbGVzc1RoYW4oIGFicyggc3BvdExpZ2h0Q29vcmQgKiAyLiAtIDEuICksIHZlYzMoIDEuMCApICkgKTsKCQkJc3BvdENvbG9yID0gdGV4dHVyZTJEKCBzcG90TGlnaHRNYXBbIFNQT1RfTElHSFRfTUFQX0lOREVYIF0sIHNwb3RMaWdodENvb3JkLnh5ICk7CgkJCWRpcmVjdExpZ2h0LmNvbG9yID0gaW5TcG90TGlnaHRNYXAgPyBkaXJlY3RMaWdodC5jb2xvciAqIHNwb3RDb2xvci5yZ2IgOiBkaXJlY3RMaWdodC5jb2xvcjsKCQkjZW5kaWYKCQkjdW5kZWYgU1BPVF9MSUdIVF9NQVBfSU5ERVgKCQkjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmICggVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgKQoJCXNwb3RMaWdodFNoYWRvdyA9IHNwb3RMaWdodFNoYWRvd3NbIGkgXTsKCQlkaXJlY3RMaWdodC5jb2xvciAqPSAoIGRpcmVjdExpZ2h0LnZpc2libGUgJiYgcmVjZWl2ZVNoYWRvdyApID8gZ2V0U2hhZG93KCBzcG90U2hhZG93TWFwWyBpIF0sIHNwb3RMaWdodFNoYWRvdy5zaGFkb3dNYXBTaXplLCBzcG90TGlnaHRTaGFkb3cuc2hhZG93SW50ZW5zaXR5LCBzcG90TGlnaHRTaGFkb3cuc2hhZG93Qmlhcywgc3BvdExpZ2h0U2hhZG93LnNoYWRvd1JhZGl1cywgdlNwb3RMaWdodENvb3JkWyBpIF0gKSA6IDEuMDsKCQkjZW5kaWYKCQlSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeVBvc2l0aW9uLCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7Cgl9CgkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAojZW5kaWYKI2lmICggTlVNX0RJUl9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0ICkKCURpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodDsKCSNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMAoJRGlyZWN0aW9uYWxMaWdodFNoYWRvdyBkaXJlY3Rpb25hbExpZ2h0U2hhZG93OwoJI2VuZGlmCgkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHsKCQlkaXJlY3Rpb25hbExpZ2h0ID0gZGlyZWN0aW9uYWxMaWdodHNbIGkgXTsKCQlnZXREaXJlY3Rpb25hbExpZ2h0SW5mbyggZGlyZWN0aW9uYWxMaWdodCwgZGlyZWN0TGlnaHQgKTsKCQkjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmICggVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9ESVJfTElHSFRfU0hBRE9XUyApCgkJZGlyZWN0aW9uYWxMaWdodFNoYWRvdyA9IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBpIF07CgkJZGlyZWN0TGlnaHQuY29sb3IgKj0gKCBkaXJlY3RMaWdodC52aXNpYmxlICYmIHJlY2VpdmVTaGFkb3cgKSA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodFNoYWRvdy5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93LnNoYWRvd0ludGVuc2l0eSwgZGlyZWN0aW9uYWxMaWdodFNoYWRvdy5zaGFkb3dCaWFzLCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93LnNoYWRvd1JhZGl1cywgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSApIDogMS4wOwoJCSNlbmRpZgoJCVJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5UG9zaXRpb24sIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTsKCX0KCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCiNlbmRpZgojaWYgKCBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3RfUmVjdEFyZWEgKQoJUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0OwoJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJZm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1JFQ1RfQVJFQV9MSUdIVFM7IGkgKysgKSB7CgkJcmVjdEFyZWFMaWdodCA9IHJlY3RBcmVhTGlnaHRzWyBpIF07CgkJUkVfRGlyZWN0X1JlY3RBcmVhKCByZWN0QXJlYUxpZ2h0LCBnZW9tZXRyeVBvc2l0aW9uLCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7Cgl9CgkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAojZW5kaWYKI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApCgl2ZWMzIGlibElycmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTsKCXZlYzMgaXJyYWRpYW5jZSA9IGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGFtYmllbnRMaWdodENvbG9yICk7CgkjaWYgZGVmaW5lZCggVVNFX0xJR0hUX1BST0JFUyApCgkJaXJyYWRpYW5jZSArPSBnZXRMaWdodFByb2JlSXJyYWRpYW5jZSggbGlnaHRQcm9iZSwgZ2VvbWV0cnlOb3JtYWwgKTsKCSNlbmRpZgoJI2lmICggTlVNX0hFTUlfTElHSFRTID4gMCApCgkJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJCWZvciAoIGludCBpID0gMDsgaSA8IE5VTV9IRU1JX0xJR0hUUzsgaSArKyApIHsKCQkJaXJyYWRpYW5jZSArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGdlb21ldHJ5Tm9ybWFsICk7CgkJfQoJCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCgkjZW5kaWYKI2VuZGlmCiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdFNwZWN1bGFyICkKCXZlYzMgcmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTsKCXZlYzMgY2xlYXJjb2F0UmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTsKI2VuZGlmYCxPbz1gI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApCgkjaWZkZWYgVVNFX0xJR0hUTUFQCgkJdmVjNCBsaWdodE1hcFRleGVsID0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdkxpZ2h0TWFwVXYgKTsKCQl2ZWMzIGxpZ2h0TWFwSXJyYWRpYW5jZSA9IGxpZ2h0TWFwVGV4ZWwucmdiICogbGlnaHRNYXBJbnRlbnNpdHk7CgkJaXJyYWRpYW5jZSArPSBsaWdodE1hcElycmFkaWFuY2U7CgkjZW5kaWYKCSNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggU1RBTkRBUkQgKSAmJiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWICkKCQlpYmxJcnJhZGlhbmNlICs9IGdldElCTElycmFkaWFuY2UoIGdlb21ldHJ5Tm9ybWFsICk7CgkjZW5kaWYKI2VuZGlmCiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApCgkjaWZkZWYgVVNFX0FOSVNPVFJPUFkKCQlyYWRpYW5jZSArPSBnZXRJQkxBbmlzb3Ryb3B5UmFkaWFuY2UoIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlOb3JtYWwsIG1hdGVyaWFsLnJvdWdobmVzcywgbWF0ZXJpYWwuYW5pc290cm9weUIsIG1hdGVyaWFsLmFuaXNvdHJvcHkgKTsKCSNlbHNlCgkJcmFkaWFuY2UgKz0gZ2V0SUJMUmFkaWFuY2UoIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlOb3JtYWwsIG1hdGVyaWFsLnJvdWdobmVzcyApOwoJI2VuZGlmCgkjaWZkZWYgVVNFX0NMRUFSQ09BVAoJCWNsZWFyY29hdFJhZGlhbmNlICs9IGdldElCTFJhZGlhbmNlKCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKTsKCSNlbmRpZgojZW5kaWZgLEJvPWAjaWYgZGVmaW5lZCggUkVfSW5kaXJlY3REaWZmdXNlICkKCVJFX0luZGlyZWN0RGlmZnVzZSggaXJyYWRpYW5jZSwgZ2VvbWV0cnlQb3NpdGlvbiwgZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApOwojZW5kaWYKI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKQoJUkVfSW5kaXJlY3RTcGVjdWxhciggcmFkaWFuY2UsIGlibElycmFkaWFuY2UsIGNsZWFyY29hdFJhZGlhbmNlLCBnZW9tZXRyeVBvc2l0aW9uLCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7CiNlbmRpZmAsem89YCNpZiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUYgKQoJZ2xfRnJhZ0RlcHRoID0gdklzUGVyc3BlY3RpdmUgPT0gMC4wID8gZ2xfRnJhZ0Nvb3JkLnogOiBsb2cyKCB2RnJhZ0RlcHRoICkgKiBsb2dEZXB0aEJ1ZkZDICogMC41OwojZW5kaWZgLEdvPWAjaWYgZGVmaW5lZCggVVNFX0xPR0RFUFRIQlVGICkKCXVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQzsKCXZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDsKCXZhcnlpbmcgZmxvYXQgdklzUGVyc3BlY3RpdmU7CiNlbmRpZmAsSG89YCNpZmRlZiBVU0VfTE9HREVQVEhCVUYKCXZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDsKCXZhcnlpbmcgZmxvYXQgdklzUGVyc3BlY3RpdmU7CiNlbmRpZmAsVm89YCNpZmRlZiBVU0VfTE9HREVQVEhCVUYKCXZGcmFnRGVwdGggPSAxLjAgKyBnbF9Qb3NpdGlvbi53OwoJdklzUGVyc3BlY3RpdmUgPSBmbG9hdCggaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApICk7CiNlbmRpZmAsa289YCNpZmRlZiBVU0VfTUFQCgl2ZWM0IHNhbXBsZWREaWZmdXNlQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdk1hcFV2ICk7CgkjaWZkZWYgREVDT0RFX1ZJREVPX1RFWFRVUkUKCQlzYW1wbGVkRGlmZnVzZUNvbG9yID0gc1JHQlRyYW5zZmVyRU9URiggc2FtcGxlZERpZmZ1c2VDb2xvciApOwoJI2VuZGlmCglkaWZmdXNlQ29sb3IgKj0gc2FtcGxlZERpZmZ1c2VDb2xvcjsKI2VuZGlmYCxXbz1gI2lmZGVmIFVTRV9NQVAKCXVuaWZvcm0gc2FtcGxlcjJEIG1hcDsKI2VuZGlmYCxYbz1gI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKQoJI2lmIGRlZmluZWQoIFVTRV9QT0lOVFNfVVYgKQoJCXZlYzIgdXYgPSB2VXY7CgkjZWxzZQoJCXZlYzIgdXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnksIDEgKSApLnh5OwoJI2VuZGlmCiNlbmRpZgojaWZkZWYgVVNFX01BUAoJZGlmZnVzZUNvbG9yICo9IHRleHR1cmUyRCggbWFwLCB1diApOwojZW5kaWYKI2lmZGVmIFVTRV9BTFBIQU1BUAoJZGlmZnVzZUNvbG9yLmEgKj0gdGV4dHVyZTJEKCBhbHBoYU1hcCwgdXYgKS5nOwojZW5kaWZgLHFvPWAjaWYgZGVmaW5lZCggVVNFX1BPSU5UU19VViApCgl2YXJ5aW5nIHZlYzIgdlV2OwojZWxzZQoJI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKQoJCXVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTsKCSNlbmRpZgojZW5kaWYKI2lmZGVmIFVTRV9NQVAKCXVuaWZvcm0gc2FtcGxlcjJEIG1hcDsKI2VuZGlmCiNpZmRlZiBVU0VfQUxQSEFNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwOwojZW5kaWZgLFlvPWBmbG9hdCBtZXRhbG5lc3NGYWN0b3IgPSBtZXRhbG5lc3M7CiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQCgl2ZWM0IHRleGVsTWV0YWxuZXNzID0gdGV4dHVyZTJEKCBtZXRhbG5lc3NNYXAsIHZNZXRhbG5lc3NNYXBVdiApOwoJbWV0YWxuZXNzRmFjdG9yICo9IHRleGVsTWV0YWxuZXNzLmI7CiNlbmRpZmAsJG89YCNpZmRlZiBVU0VfTUVUQUxORVNTTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBtZXRhbG5lc3NNYXA7CiNlbmRpZmAsWm89YCNpZmRlZiBVU0VfSU5TVEFOQ0lOR19NT1JQSAoJZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBNT1JQSFRBUkdFVFNfQ09VTlQgXTsKCWZsb2F0IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZSA9IHRleGVsRmV0Y2goIG1vcnBoVGV4dHVyZSwgaXZlYzIoIDAsIGdsX0luc3RhbmNlSUQgKSwgMCApLnI7Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7CgkJbW9ycGhUYXJnZXRJbmZsdWVuY2VzW2ldID0gIHRleGVsRmV0Y2goIG1vcnBoVGV4dHVyZSwgaXZlYzIoIGkgKyAxLCBnbF9JbnN0YW5jZUlEICksIDAgKS5yOwoJfQojZW5kaWZgLEtvPWAjaWYgZGVmaW5lZCggVVNFX01PUlBIQ09MT1JTICkKCXZDb2xvciAqPSBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2U7Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7CgkJI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApCgkJCWlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gIT0gMC4wICkgdkNvbG9yICs9IGdldE1vcnBoKCBnbF9WZXJ0ZXhJRCwgaSwgMiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07CgkJI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SICkKCQkJaWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPSAwLjAgKSB2Q29sb3IgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAyICkucmdiICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07CgkJI2VuZGlmCgl9CiNlbmRpZmAsam89YCNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTCglvYmplY3ROb3JtYWwgKj0gbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlOwoJZm9yICggaW50IGkgPSAwOyBpIDwgTU9SUEhUQVJHRVRTX0NPVU5UOyBpICsrICkgewoJCWlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gIT0gMC4wICkgb2JqZWN0Tm9ybWFsICs9IGdldE1vcnBoKCBnbF9WZXJ0ZXhJRCwgaSwgMSApLnh5eiAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdOwoJfQojZW5kaWZgLEpvPWAjaWZkZWYgVVNFX01PUlBIVEFSR0VUUwoJI2lmbmRlZiBVU0VfSU5TVEFOQ0lOR19NT1JQSAoJCXVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlOwoJCXVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBNT1JQSFRBUkdFVFNfQ09VTlQgXTsKCSNlbmRpZgoJdW5pZm9ybSBzYW1wbGVyMkRBcnJheSBtb3JwaFRhcmdldHNUZXh0dXJlOwoJdW5pZm9ybSBpdmVjMiBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZTsKCXZlYzQgZ2V0TW9ycGgoIGNvbnN0IGluIGludCB2ZXJ0ZXhJbmRleCwgY29uc3QgaW4gaW50IG1vcnBoVGFyZ2V0SW5kZXgsIGNvbnN0IGluIGludCBvZmZzZXQgKSB7CgkJaW50IHRleGVsSW5kZXggPSB2ZXJ0ZXhJbmRleCAqIE1PUlBIVEFSR0VUU19URVhUVVJFX1NUUklERSArIG9mZnNldDsKCQlpbnQgeSA9IHRleGVsSW5kZXggLyBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZS54OwoJCWludCB4ID0gdGV4ZWxJbmRleCAtIHkgKiBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZS54OwoJCWl2ZWMzIG1vcnBoVVYgPSBpdmVjMyggeCwgeSwgbW9ycGhUYXJnZXRJbmRleCApOwoJCXJldHVybiB0ZXhlbEZldGNoKCBtb3JwaFRhcmdldHNUZXh0dXJlLCBtb3JwaFVWLCAwICk7Cgl9CiNlbmRpZmAsUW89YCNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTCgl0cmFuc2Zvcm1lZCAqPSBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2U7Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7CgkJaWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPSAwLjAgKSB0cmFuc2Zvcm1lZCArPSBnZXRNb3JwaCggZ2xfVmVydGV4SUQsIGksIDAgKS54eXogKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTsKCX0KI2VuZGlmYCxlbD1gZmxvYXQgZmFjZURpcmVjdGlvbiA9IGdsX0Zyb250RmFjaW5nID8gMS4wIDogLSAxLjA7CiNpZmRlZiBGTEFUX1NIQURFRAoJdmVjMyBmZHggPSBkRmR4KCB2Vmlld1Bvc2l0aW9uICk7Cgl2ZWMzIGZkeSA9IGRGZHkoIHZWaWV3UG9zaXRpb24gKTsKCXZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggZmR4LCBmZHkgKSApOwojZWxzZQoJdmVjMyBub3JtYWwgPSBub3JtYWxpemUoIHZOb3JtYWwgKTsKCSNpZmRlZiBET1VCTEVfU0lERUQKCQlub3JtYWwgKj0gZmFjZURpcmVjdGlvbjsKCSNlbmRpZgojZW5kaWYKI2lmIGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFICkgfHwgZGVmaW5lZCggVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU5JU09UUk9QWSApCgkjaWZkZWYgVVNFX1RBTkdFTlQKCQltYXQzIHRibiA9IG1hdDMoIG5vcm1hbGl6ZSggdlRhbmdlbnQgKSwgbm9ybWFsaXplKCB2Qml0YW5nZW50ICksIG5vcm1hbCApOwoJI2Vsc2UKCQltYXQzIHRibiA9IGdldFRhbmdlbnRGcmFtZSggLSB2Vmlld1Bvc2l0aW9uLCBub3JtYWwsCgkJI2lmIGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKQoJCQl2Tm9ybWFsTWFwVXYKCQkjZWxpZiBkZWZpbmVkKCBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUCApCgkJCXZDbGVhcmNvYXROb3JtYWxNYXBVdgoJCSNlbHNlCgkJCXZVdgoJCSNlbmRpZgoJCSk7CgkjZW5kaWYKCSNpZiBkZWZpbmVkKCBET1VCTEVfU0lERUQgKSAmJiAhIGRlZmluZWQoIEZMQVRfU0hBREVEICkKCQl0Ym5bMF0gKj0gZmFjZURpcmVjdGlvbjsKCQl0Ym5bMV0gKj0gZmFjZURpcmVjdGlvbjsKCSNlbmRpZgojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQCgkjaWZkZWYgVVNFX1RBTkdFTlQKCQltYXQzIHRibjIgPSBtYXQzKCBub3JtYWxpemUoIHZUYW5nZW50ICksIG5vcm1hbGl6ZSggdkJpdGFuZ2VudCApLCBub3JtYWwgKTsKCSNlbHNlCgkJbWF0MyB0Ym4yID0gZ2V0VGFuZ2VudEZyYW1lKCAtIHZWaWV3UG9zaXRpb24sIG5vcm1hbCwgdkNsZWFyY29hdE5vcm1hbE1hcFV2ICk7CgkjZW5kaWYKCSNpZiBkZWZpbmVkKCBET1VCTEVfU0lERUQgKSAmJiAhIGRlZmluZWQoIEZMQVRfU0hBREVEICkKCQl0Ym4yWzBdICo9IGZhY2VEaXJlY3Rpb247CgkJdGJuMlsxXSAqPSBmYWNlRGlyZWN0aW9uOwoJI2VuZGlmCiNlbmRpZgp2ZWMzIG5vblBlcnR1cmJlZE5vcm1hbCA9IG5vcm1hbDtgLHRsPWAjaWZkZWYgVVNFX05PUk1BTE1BUF9PQkpFQ1RTUEFDRQoJbm9ybWFsID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZOb3JtYWxNYXBVdiApLnh5eiAqIDIuMCAtIDEuMDsKCSNpZmRlZiBGTElQX1NJREVECgkJbm9ybWFsID0gLSBub3JtYWw7CgkjZW5kaWYKCSNpZmRlZiBET1VCTEVfU0lERUQKCQlub3JtYWwgPSBub3JtYWwgKiBmYWNlRGlyZWN0aW9uOwoJI2VuZGlmCglub3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApOwojZWxpZiBkZWZpbmVkKCBVU0VfTk9STUFMTUFQX1RBTkdFTlRTUEFDRSApCgl2ZWMzIG1hcE4gPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdk5vcm1hbE1hcFV2ICkueHl6ICogMi4wIC0gMS4wOwoJbWFwTi54eSAqPSBub3JtYWxTY2FsZTsKCW5vcm1hbCA9IG5vcm1hbGl6ZSggdGJuICogbWFwTiApOwojZWxpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApCglub3JtYWwgPSBwZXJ0dXJiTm9ybWFsQXJiKCAtIHZWaWV3UG9zaXRpb24sIG5vcm1hbCwgZEhkeHlfZndkKCksIGZhY2VEaXJlY3Rpb24gKTsKI2VuZGlmYCxubD1gI2lmbmRlZiBGTEFUX1NIQURFRAoJdmFyeWluZyB2ZWMzIHZOb3JtYWw7CgkjaWZkZWYgVVNFX1RBTkdFTlQKCQl2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7CgkJdmFyeWluZyB2ZWMzIHZCaXRhbmdlbnQ7CgkjZW5kaWYKI2VuZGlmYCxpbD1gI2lmbmRlZiBGTEFUX1NIQURFRAoJdmFyeWluZyB2ZWMzIHZOb3JtYWw7CgkjaWZkZWYgVVNFX1RBTkdFTlQKCQl2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7CgkJdmFyeWluZyB2ZWMzIHZCaXRhbmdlbnQ7CgkjZW5kaWYKI2VuZGlmYCxybD1gI2lmbmRlZiBGTEFUX1NIQURFRAoJdk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTsKCSNpZmRlZiBVU0VfVEFOR0VOVAoJCXZUYW5nZW50ID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZFRhbmdlbnQgKTsKCQl2Qml0YW5nZW50ID0gbm9ybWFsaXplKCBjcm9zcyggdk5vcm1hbCwgdlRhbmdlbnQgKSAqIHRhbmdlbnQudyApOwoJI2VuZGlmCiNlbmRpZmAsc2w9YCNpZmRlZiBVU0VfTk9STUFMTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7Cgl1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7CiNlbmRpZgojaWZkZWYgVVNFX05PUk1BTE1BUF9PQkpFQ1RTUEFDRQoJdW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDsKI2VuZGlmCiNpZiAhIGRlZmluZWQgKCBVU0VfVEFOR0VOVCApICYmICggZGVmaW5lZCAoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFICkgfHwgZGVmaW5lZCAoIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX0FOSVNPVFJPUFkgKSApCgltYXQzIGdldFRhbmdlbnRGcmFtZSggdmVjMyBleWVfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMiB1diApIHsKCQl2ZWMzIHEwID0gZEZkeCggZXllX3Bvcy54eXogKTsKCQl2ZWMzIHExID0gZEZkeSggZXllX3Bvcy54eXogKTsKCQl2ZWMyIHN0MCA9IGRGZHgoIHV2LnN0ICk7CgkJdmVjMiBzdDEgPSBkRmR5KCB1di5zdCApOwoJCXZlYzMgTiA9IHN1cmZfbm9ybTsKCQl2ZWMzIHExcGVycCA9IGNyb3NzKCBxMSwgTiApOwoJCXZlYzMgcTBwZXJwID0gY3Jvc3MoIE4sIHEwICk7CgkJdmVjMyBUID0gcTFwZXJwICogc3QwLnggKyBxMHBlcnAgKiBzdDEueDsKCQl2ZWMzIEIgPSBxMXBlcnAgKiBzdDAueSArIHEwcGVycCAqIHN0MS55OwoJCWZsb2F0IGRldCA9IG1heCggZG90KCBULCBUICksIGRvdCggQiwgQiApICk7CgkJZmxvYXQgc2NhbGUgPSAoIGRldCA9PSAwLjAgKSA/IDAuMCA6IGludmVyc2VzcXJ0KCBkZXQgKTsKCQlyZXR1cm4gbWF0MyggVCAqIHNjYWxlLCBCICogc2NhbGUsIE4gKTsKCX0KI2VuZGlmYCxhbD1gI2lmZGVmIFVTRV9DTEVBUkNPQVQKCXZlYzMgY2xlYXJjb2F0Tm9ybWFsID0gbm9uUGVydHVyYmVkTm9ybWFsOwojZW5kaWZgLG9sPWAjaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAKCXZlYzMgY2xlYXJjb2F0TWFwTiA9IHRleHR1cmUyRCggY2xlYXJjb2F0Tm9ybWFsTWFwLCB2Q2xlYXJjb2F0Tm9ybWFsTWFwVXYgKS54eXogKiAyLjAgLSAxLjA7CgljbGVhcmNvYXRNYXBOLnh5ICo9IGNsZWFyY29hdE5vcm1hbFNjYWxlOwoJY2xlYXJjb2F0Tm9ybWFsID0gbm9ybWFsaXplKCB0Ym4yICogY2xlYXJjb2F0TWFwTiApOwojZW5kaWZgLGxsPWAjaWZkZWYgVVNFX0NMRUFSQ09BVE1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgY2xlYXJjb2F0TWFwOwojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBjbGVhcmNvYXROb3JtYWxNYXA7Cgl1bmlmb3JtIHZlYzIgY2xlYXJjb2F0Tm9ybWFsU2NhbGU7CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyY29hdFJvdWdobmVzc01hcDsKI2VuZGlmYCxjbD1gI2lmZGVmIFVTRV9JUklERVNDRU5DRU1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgaXJpZGVzY2VuY2VNYXA7CiNlbmRpZgojaWZkZWYgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUAoJdW5pZm9ybSBzYW1wbGVyMkQgaXJpZGVzY2VuY2VUaGlja25lc3NNYXA7CiNlbmRpZmAsdWw9YCNpZmRlZiBPUEFRVUUKZGlmZnVzZUNvbG9yLmEgPSAxLjA7CiNlbmRpZgojaWZkZWYgVVNFX1RSQU5TTUlTU0lPTgpkaWZmdXNlQ29sb3IuYSAqPSBtYXRlcmlhbC50cmFuc21pc3Npb25BbHBoYTsKI2VuZGlmCmdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7YCxobD1gdmVjMyBwYWNrTm9ybWFsVG9SR0IoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkgewoJcmV0dXJuIG5vcm1hbGl6ZSggbm9ybWFsICkgKiAwLjUgKyAwLjU7Cn0KdmVjMyB1bnBhY2tSR0JUb05vcm1hbCggY29uc3QgaW4gdmVjMyByZ2IgKSB7CglyZXR1cm4gMi4wICogcmdiLnh5eiAtIDEuMDsKfQpjb25zdCBmbG9hdCBQYWNrVXBzY2FsZSA9IDI1Ni4gLyAyNTUuO2NvbnN0IGZsb2F0IFVucGFja0Rvd25zY2FsZSA9IDI1NS4gLyAyNTYuO2NvbnN0IGZsb2F0IFNoaWZ0UmlnaHQ4ID0gMS4gLyAyNTYuOwpjb25zdCBmbG9hdCBJbnYyNTUgPSAxLiAvIDI1NS47CmNvbnN0IHZlYzQgUGFja0ZhY3RvcnMgPSB2ZWM0KCAxLjAsIDI1Ni4wLCAyNTYuMCAqIDI1Ni4wLCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKTsKY29uc3QgdmVjMiBVbnBhY2tGYWN0b3JzMiA9IHZlYzIoIFVucGFja0Rvd25zY2FsZSwgMS4wIC8gUGFja0ZhY3RvcnMuZyApOwpjb25zdCB2ZWMzIFVucGFja0ZhY3RvcnMzID0gdmVjMyggVW5wYWNrRG93bnNjYWxlIC8gUGFja0ZhY3RvcnMucmcsIDEuMCAvIFBhY2tGYWN0b3JzLmIgKTsKY29uc3QgdmVjNCBVbnBhY2tGYWN0b3JzNCA9IHZlYzQoIFVucGFja0Rvd25zY2FsZSAvIFBhY2tGYWN0b3JzLnJnYiwgMS4wIC8gUGFja0ZhY3RvcnMuYSApOwp2ZWM0IHBhY2tEZXB0aFRvUkdCQSggY29uc3QgaW4gZmxvYXQgdiApIHsKCWlmKCB2IDw9IDAuMCApCgkJcmV0dXJuIHZlYzQoIDAuLCAwLiwgMC4sIDAuICk7CglpZiggdiA+PSAxLjAgKQoJCXJldHVybiB2ZWM0KCAxLiwgMS4sIDEuLCAxLiApOwoJZmxvYXQgdnVmOwoJZmxvYXQgYWYgPSBtb2RmKCB2ICogUGFja0ZhY3RvcnMuYSwgdnVmICk7CglmbG9hdCBiZiA9IG1vZGYoIHZ1ZiAqIFNoaWZ0UmlnaHQ4LCB2dWYgKTsKCWZsb2F0IGdmID0gbW9kZiggdnVmICogU2hpZnRSaWdodDgsIHZ1ZiApOwoJcmV0dXJuIHZlYzQoIHZ1ZiAqIEludjI1NSwgZ2YgKiBQYWNrVXBzY2FsZSwgYmYgKiBQYWNrVXBzY2FsZSwgYWYgKTsKfQp2ZWMzIHBhY2tEZXB0aFRvUkdCKCBjb25zdCBpbiBmbG9hdCB2ICkgewoJaWYoIHYgPD0gMC4wICkKCQlyZXR1cm4gdmVjMyggMC4sIDAuLCAwLiApOwoJaWYoIHYgPj0gMS4wICkKCQlyZXR1cm4gdmVjMyggMS4sIDEuLCAxLiApOwoJZmxvYXQgdnVmOwoJZmxvYXQgYmYgPSBtb2RmKCB2ICogUGFja0ZhY3RvcnMuYiwgdnVmICk7CglmbG9hdCBnZiA9IG1vZGYoIHZ1ZiAqIFNoaWZ0UmlnaHQ4LCB2dWYgKTsKCXJldHVybiB2ZWMzKCB2dWYgKiBJbnYyNTUsIGdmICogUGFja1Vwc2NhbGUsIGJmICk7Cn0KdmVjMiBwYWNrRGVwdGhUb1JHKCBjb25zdCBpbiBmbG9hdCB2ICkgewoJaWYoIHYgPD0gMC4wICkKCQlyZXR1cm4gdmVjMiggMC4sIDAuICk7CglpZiggdiA+PSAxLjAgKQoJCXJldHVybiB2ZWMyKCAxLiwgMS4gKTsKCWZsb2F0IHZ1ZjsKCWZsb2F0IGdmID0gbW9kZiggdiAqIDI1Ni4sIHZ1ZiApOwoJcmV0dXJuIHZlYzIoIHZ1ZiAqIEludjI1NSwgZ2YgKTsKfQpmbG9hdCB1bnBhY2tSR0JBVG9EZXB0aCggY29uc3QgaW4gdmVjNCB2ICkgewoJcmV0dXJuIGRvdCggdiwgVW5wYWNrRmFjdG9yczQgKTsKfQpmbG9hdCB1bnBhY2tSR0JUb0RlcHRoKCBjb25zdCBpbiB2ZWMzIHYgKSB7CglyZXR1cm4gZG90KCB2LCBVbnBhY2tGYWN0b3JzMyApOwp9CmZsb2F0IHVucGFja1JHVG9EZXB0aCggY29uc3QgaW4gdmVjMiB2ICkgewoJcmV0dXJuIHYuciAqIFVucGFja0ZhY3RvcnMyLnIgKyB2LmcgKiBVbnBhY2tGYWN0b3JzMi5nOwp9CnZlYzQgcGFjazJIYWxmVG9SR0JBKCBjb25zdCBpbiB2ZWMyIHYgKSB7Cgl2ZWM0IHIgPSB2ZWM0KCB2LngsIGZyYWN0KCB2LnggKiAyNTUuMCApLCB2LnksIGZyYWN0KCB2LnkgKiAyNTUuMCApICk7CglyZXR1cm4gdmVjNCggci54IC0gci55IC8gMjU1LjAsIHIueSwgci56IC0gci53IC8gMjU1LjAsIHIudyApOwp9CnZlYzIgdW5wYWNrUkdCQVRvMkhhbGYoIGNvbnN0IGluIHZlYzQgdiApIHsKCXJldHVybiB2ZWMyKCB2LnggKyAoIHYueSAvIDI1NS4wICksIHYueiArICggdi53IC8gMjU1LjAgKSApOwp9CmZsb2F0IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCggY29uc3QgaW4gZmxvYXQgdmlld1osIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHsKCXJldHVybiAoIHZpZXdaICsgbmVhciApIC8gKCBuZWFyIC0gZmFyICk7Cn0KZmxvYXQgb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKCBjb25zdCBpbiBmbG9hdCBkZXB0aCwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkgewoJcmV0dXJuIGRlcHRoICogKCBuZWFyIC0gZmFyICkgLSBuZWFyOwp9CmZsb2F0IHZpZXdaVG9QZXJzcGVjdGl2ZURlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkgewoJcmV0dXJuICggKCBuZWFyICsgdmlld1ogKSAqIGZhciApIC8gKCAoIGZhciAtIG5lYXIgKSAqIHZpZXdaICk7Cn0KZmxvYXQgcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooIGNvbnN0IGluIGZsb2F0IGRlcHRoLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7CglyZXR1cm4gKCBuZWFyICogZmFyICkgLyAoICggZmFyIC0gbmVhciApICogZGVwdGggLSBmYXIgKTsKfWAsZGw9YCNpZmRlZiBQUkVNVUxUSVBMSUVEX0FMUEhBCglnbF9GcmFnQ29sb3IucmdiICo9IGdsX0ZyYWdDb2xvci5hOwojZW5kaWZgLGZsPWB2ZWM0IG12UG9zaXRpb24gPSB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7CiNpZmRlZiBVU0VfQkFUQ0hJTkcKCW12UG9zaXRpb24gPSBiYXRjaGluZ01hdHJpeCAqIG12UG9zaXRpb247CiNlbmRpZgojaWZkZWYgVVNFX0lOU1RBTkNJTkcKCW12UG9zaXRpb24gPSBpbnN0YW5jZU1hdHJpeCAqIG12UG9zaXRpb247CiNlbmRpZgptdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogbXZQb3NpdGlvbjsKZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtgLHBsPWAjaWZkZWYgRElUSEVSSU5HCglnbF9GcmFnQ29sb3IucmdiID0gZGl0aGVyaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7CiNlbmRpZmAsbWw9YCNpZmRlZiBESVRIRVJJTkcKCXZlYzMgZGl0aGVyaW5nKCB2ZWMzIGNvbG9yICkgewoJCWZsb2F0IGdyaWRfcG9zaXRpb24gPSByYW5kKCBnbF9GcmFnQ29vcmQueHkgKTsKCQl2ZWMzIGRpdGhlcl9zaGlmdF9SR0IgPSB2ZWMzKCAwLjI1IC8gMjU1LjAsIC0wLjI1IC8gMjU1LjAsIDAuMjUgLyAyNTUuMCApOwoJCWRpdGhlcl9zaGlmdF9SR0IgPSBtaXgoIDIuMCAqIGRpdGhlcl9zaGlmdF9SR0IsIC0yLjAgKiBkaXRoZXJfc2hpZnRfUkdCLCBncmlkX3Bvc2l0aW9uICk7CgkJcmV0dXJuIGNvbG9yICsgZGl0aGVyX3NoaWZ0X1JHQjsKCX0KI2VuZGlmYCxfbD1gZmxvYXQgcm91Z2huZXNzRmFjdG9yID0gcm91Z2huZXNzOwojaWZkZWYgVVNFX1JPVUdITkVTU01BUAoJdmVjNCB0ZXhlbFJvdWdobmVzcyA9IHRleHR1cmUyRCggcm91Z2huZXNzTWFwLCB2Um91Z2huZXNzTWFwVXYgKTsKCXJvdWdobmVzc0ZhY3RvciAqPSB0ZXhlbFJvdWdobmVzcy5nOwojZW5kaWZgLGdsPWAjaWZkZWYgVVNFX1JPVUdITkVTU01BUAoJdW5pZm9ybSBzYW1wbGVyMkQgcm91Z2huZXNzTWFwOwojZW5kaWZgLHZsPWAjaWYgTlVNX1NQT1RfTElHSFRfQ09PUkRTID4gMAoJdmFyeWluZyB2ZWM0IHZTcG90TGlnaHRDb29yZFsgTlVNX1NQT1RfTElHSFRfQ09PUkRTIF07CiNlbmRpZgojaWYgTlVNX1NQT1RfTElHSFRfTUFQUyA+IDAKCXVuaWZvcm0gc2FtcGxlcjJEIHNwb3RMaWdodE1hcFsgTlVNX1NQT1RfTElHSFRfTUFQUyBdOwojZW5kaWYKI2lmZGVmIFVTRV9TSEFET1dNQVAKCSNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwCgkJdW5pZm9ybSBzYW1wbGVyMkQgZGlyZWN0aW9uYWxTaGFkb3dNYXBbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdOwoJCXZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07CgkJc3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgewoJCQlmbG9hdCBzaGFkb3dJbnRlbnNpdHk7CgkJCWZsb2F0IHNoYWRvd0JpYXM7CgkJCWZsb2F0IHNoYWRvd05vcm1hbEJpYXM7CgkJCWZsb2F0IHNoYWRvd1JhZGl1czsKCQkJdmVjMiBzaGFkb3dNYXBTaXplOwoJCX07CgkJdW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTsKCSNlbmRpZgoJI2lmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwCgkJdW5pZm9ybSBzYW1wbGVyMkQgc3BvdFNoYWRvd01hcFsgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdOwoJCXN0cnVjdCBTcG90TGlnaHRTaGFkb3cgewoJCQlmbG9hdCBzaGFkb3dJbnRlbnNpdHk7CgkJCWZsb2F0IHNoYWRvd0JpYXM7CgkJCWZsb2F0IHNoYWRvd05vcm1hbEJpYXM7CgkJCWZsb2F0IHNoYWRvd1JhZGl1czsKCQkJdmVjMiBzaGFkb3dNYXBTaXplOwoJCX07CgkJdW5pZm9ybSBTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0U2hhZG93c1sgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdOwoJI2VuZGlmCgkjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwCgkJdW5pZm9ybSBzYW1wbGVyMkQgcG9pbnRTaGFkb3dNYXBbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07CgkJdmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdOwoJCXN0cnVjdCBQb2ludExpZ2h0U2hhZG93IHsKCQkJZmxvYXQgc2hhZG93SW50ZW5zaXR5OwoJCQlmbG9hdCBzaGFkb3dCaWFzOwoJCQlmbG9hdCBzaGFkb3dOb3JtYWxCaWFzOwoJCQlmbG9hdCBzaGFkb3dSYWRpdXM7CgkJCXZlYzIgc2hhZG93TWFwU2l6ZTsKCQkJZmxvYXQgc2hhZG93Q2FtZXJhTmVhcjsKCQkJZmxvYXQgc2hhZG93Q2FtZXJhRmFyOwoJCX07CgkJdW5pZm9ybSBQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3dzWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdOwoJI2VuZGlmCglmbG9hdCB0ZXh0dXJlMkRDb21wYXJlKCBzYW1wbGVyMkQgZGVwdGhzLCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICkgewoJCXJldHVybiBzdGVwKCBjb21wYXJlLCB1bnBhY2tSR0JBVG9EZXB0aCggdGV4dHVyZTJEKCBkZXB0aHMsIHV2ICkgKSApOwoJfQoJdmVjMiB0ZXh0dXJlMkREaXN0cmlidXRpb24oIHNhbXBsZXIyRCBzaGFkb3csIHZlYzIgdXYgKSB7CgkJcmV0dXJuIHVucGFja1JHQkFUbzJIYWxmKCB0ZXh0dXJlMkQoIHNoYWRvdywgdXYgKSApOwoJfQoJZmxvYXQgVlNNU2hhZG93IChzYW1wbGVyMkQgc2hhZG93LCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICl7CgkJZmxvYXQgb2NjbHVzaW9uID0gMS4wOwoJCXZlYzIgZGlzdHJpYnV0aW9uID0gdGV4dHVyZTJERGlzdHJpYnV0aW9uKCBzaGFkb3csIHV2ICk7CgkJZmxvYXQgaGFyZF9zaGFkb3cgPSBzdGVwKCBjb21wYXJlICwgZGlzdHJpYnV0aW9uLnggKTsKCQlpZiAoaGFyZF9zaGFkb3cgIT0gMS4wICkgewoJCQlmbG9hdCBkaXN0YW5jZSA9IGNvbXBhcmUgLSBkaXN0cmlidXRpb24ueCA7CgkJCWZsb2F0IHZhcmlhbmNlID0gbWF4KCAwLjAwMDAwLCBkaXN0cmlidXRpb24ueSAqIGRpc3RyaWJ1dGlvbi55ICk7CgkJCWZsb2F0IHNvZnRuZXNzX3Byb2JhYmlsaXR5ID0gdmFyaWFuY2UgLyAodmFyaWFuY2UgKyBkaXN0YW5jZSAqIGRpc3RhbmNlICk7CQkJc29mdG5lc3NfcHJvYmFiaWxpdHkgPSBjbGFtcCggKCBzb2Z0bmVzc19wcm9iYWJpbGl0eSAtIDAuMyApIC8gKCAwLjk1IC0gMC4zICksIDAuMCwgMS4wICk7CQkJb2NjbHVzaW9uID0gY2xhbXAoIG1heCggaGFyZF9zaGFkb3csIHNvZnRuZXNzX3Byb2JhYmlsaXR5ICksIDAuMCwgMS4wICk7CgkJfQoJCXJldHVybiBvY2NsdXNpb247Cgl9CglmbG9hdCBnZXRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93SW50ZW5zaXR5LCBmbG9hdCBzaGFkb3dCaWFzLCBmbG9hdCBzaGFkb3dSYWRpdXMsIHZlYzQgc2hhZG93Q29vcmQgKSB7CgkJZmxvYXQgc2hhZG93ID0gMS4wOwoJCXNoYWRvd0Nvb3JkLnh5eiAvPSBzaGFkb3dDb29yZC53OwoJCXNoYWRvd0Nvb3JkLnogKz0gc2hhZG93QmlhczsKCQlib29sIGluRnJ1c3R1bSA9IHNoYWRvd0Nvb3JkLnggPj0gMC4wICYmIHNoYWRvd0Nvb3JkLnggPD0gMS4wICYmIHNoYWRvd0Nvb3JkLnkgPj0gMC4wICYmIHNoYWRvd0Nvb3JkLnkgPD0gMS4wOwoJCWJvb2wgZnJ1c3R1bVRlc3QgPSBpbkZydXN0dW0gJiYgc2hhZG93Q29vcmQueiA8PSAxLjA7CgkJaWYgKCBmcnVzdHVtVGVzdCApIHsKCQkjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGICkKCQkJdmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7CgkJCWZsb2F0IGR4MCA9IC0gdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7CgkJCWZsb2F0IGR5MCA9IC0gdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7CgkJCWZsb2F0IGR4MSA9ICsgdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7CgkJCWZsb2F0IGR5MSA9ICsgdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7CgkJCWZsb2F0IGR4MiA9IGR4MCAvIDIuMDsKCQkJZmxvYXQgZHkyID0gZHkwIC8gMi4wOwoJCQlmbG9hdCBkeDMgPSBkeDEgLyAyLjA7CgkJCWZsb2F0IGR5MyA9IGR5MSAvIDIuMDsKCQkJc2hhZG93ID0gKAoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MiwgZHkyICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTIgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDMsIGR5MiApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgyLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgzLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MiwgZHkzICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTMgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDMsIGR5MyApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApLCBzaGFkb3dDb29yZC56ICkKCQkJKSAqICggMS4wIC8gMTcuMCApOwoJCSNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUICkKCQkJdmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7CgkJCWZsb2F0IGR4ID0gdGV4ZWxTaXplLng7CgkJCWZsb2F0IGR5ID0gdGV4ZWxTaXplLnk7CgkJCXZlYzIgdXYgPSBzaGFkb3dDb29yZC54eTsKCQkJdmVjMiBmID0gZnJhY3QoIHV2ICogc2hhZG93TWFwU2l6ZSArIDAuNSApOwoJCQl1diAtPSBmICogdGV4ZWxTaXplOwoJCQlzaGFkb3cgPSAoCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2LCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAwLjAsIGR5ICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdGV4ZWxTaXplLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJbWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApLAoJCQkJCSB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIDAuMCApLCBzaGFkb3dDb29yZC56ICksCgkJCQkJIGYueCApICsKCQkJCW1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIC1keCwgZHkgKSwgc2hhZG93Q29vcmQueiApLAoJCQkJCSB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIGR5ICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkgZi54ICkgKwoJCQkJbWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCAtZHkgKSwgc2hhZG93Q29vcmQueiApLAoJCQkJCSB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksCgkJCQkJIGYueSApICsKCQkJCW1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAtZHkgKSwgc2hhZG93Q29vcmQueiApLAoJCQkJCSB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggZHgsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkgZi55ICkgKwoJCQkJbWl4KCBtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIC1keSApLCBzaGFkb3dDb29yZC56ICksCgkJCQkJCSAgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCAtZHkgKSwgc2hhZG93Q29vcmQueiApLAoJCQkJCQkgIGYueCApLAoJCQkJCSBtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkJICB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkJICBmLnggKSwKCQkJCQkgZi55ICkKCQkJKSAqICggMS4wIC8gOS4wICk7CgkJI2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfVlNNICkKCQkJc2hhZG93ID0gVlNNU2hhZG93KCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICk7CgkJI2Vsc2UKCQkJc2hhZG93ID0gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApOwoJCSNlbmRpZgoJCX0KCQlyZXR1cm4gbWl4KCAxLjAsIHNoYWRvdywgc2hhZG93SW50ZW5zaXR5ICk7Cgl9Cgl2ZWMyIGN1YmVUb1VWKCB2ZWMzIHYsIGZsb2F0IHRleGVsU2l6ZVkgKSB7CgkJdmVjMyBhYnNWID0gYWJzKCB2ICk7CgkJZmxvYXQgc2NhbGVUb0N1YmUgPSAxLjAgLyBtYXgoIGFic1YueCwgbWF4KCBhYnNWLnksIGFic1YueiApICk7CgkJYWJzViAqPSBzY2FsZVRvQ3ViZTsKCQl2ICo9IHNjYWxlVG9DdWJlICogKCAxLjAgLSAyLjAgKiB0ZXhlbFNpemVZICk7CgkJdmVjMiBwbGFuYXIgPSB2Lnh5OwoJCWZsb2F0IGFsbW9zdEFUZXhlbCA9IDEuNSAqIHRleGVsU2l6ZVk7CgkJZmxvYXQgYWxtb3N0T25lID0gMS4wIC0gYWxtb3N0QVRleGVsOwoJCWlmICggYWJzVi56ID49IGFsbW9zdE9uZSApIHsKCQkJaWYgKCB2LnogPiAwLjAgKQoJCQkJcGxhbmFyLnggPSA0LjAgLSB2Lng7CgkJfSBlbHNlIGlmICggYWJzVi54ID49IGFsbW9zdE9uZSApIHsKCQkJZmxvYXQgc2lnblggPSBzaWduKCB2LnggKTsKCQkJcGxhbmFyLnggPSB2LnogKiBzaWduWCArIDIuMCAqIHNpZ25YOwoJCX0gZWxzZSBpZiAoIGFic1YueSA+PSBhbG1vc3RPbmUgKSB7CgkJCWZsb2F0IHNpZ25ZID0gc2lnbiggdi55ICk7CgkJCXBsYW5hci54ID0gdi54ICsgMi4wICogc2lnblkgKyAyLjA7CgkJCXBsYW5hci55ID0gdi56ICogc2lnblkgLSAyLjA7CgkJfQoJCXJldHVybiB2ZWMyKCAwLjEyNSwgMC4yNSApICogcGxhbmFyICsgdmVjMiggMC4zNzUsIDAuNzUgKTsKCX0KCWZsb2F0IGdldFBvaW50U2hhZG93KCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFNpemUsIGZsb2F0IHNoYWRvd0ludGVuc2l0eSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkLCBmbG9hdCBzaGFkb3dDYW1lcmFOZWFyLCBmbG9hdCBzaGFkb3dDYW1lcmFGYXIgKSB7CgkJZmxvYXQgc2hhZG93ID0gMS4wOwoJCXZlYzMgbGlnaHRUb1Bvc2l0aW9uID0gc2hhZG93Q29vcmQueHl6OwoJCQoJCWZsb2F0IGxpZ2h0VG9Qb3NpdGlvbkxlbmd0aCA9IGxlbmd0aCggbGlnaHRUb1Bvc2l0aW9uICk7CgkJaWYgKCBsaWdodFRvUG9zaXRpb25MZW5ndGggLSBzaGFkb3dDYW1lcmFGYXIgPD0gMC4wICYmIGxpZ2h0VG9Qb3NpdGlvbkxlbmd0aCAtIHNoYWRvd0NhbWVyYU5lYXIgPj0gMC4wICkgewoJCQlmbG9hdCBkcCA9ICggbGlnaHRUb1Bvc2l0aW9uTGVuZ3RoIC0gc2hhZG93Q2FtZXJhTmVhciApIC8gKCBzaGFkb3dDYW1lcmFGYXIgLSBzaGFkb3dDYW1lcmFOZWFyICk7CQkJZHAgKz0gc2hhZG93QmlhczsKCQkJdmVjMyBiZDNEID0gbm9ybWFsaXplKCBsaWdodFRvUG9zaXRpb24gKTsKCQkJdmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvICggc2hhZG93TWFwU2l6ZSAqIHZlYzIoIDQuMCwgMi4wICkgKTsKCQkJI2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApIHx8IGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfVlNNICkKCQkJCXZlYzIgb2Zmc2V0ID0gdmVjMiggLSAxLCAxICkgKiBzaGFkb3dSYWRpdXMgKiB0ZXhlbFNpemUueTsKCQkJCXNoYWRvdyA9ICgKCQkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArCgkJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eXksIHRleGVsU2l6ZS55ICksIGRwICkgKwoJCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl4LCB0ZXhlbFNpemUueSApLCBkcCApICsKCQkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArCgkJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArCgkJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHksIHRleGVsU2l6ZS55ICksIGRwICkgKwoJCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXh5LCB0ZXhlbFNpemUueSApLCBkcCApICsKCQkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArCgkJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHgsIHRleGVsU2l6ZS55ICksIGRwICkKCQkJCSkgKiAoIDEuMCAvIDkuMCApOwoJCQkjZWxzZQoJCQkJc2hhZG93ID0gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKTsKCQkJI2VuZGlmCgkJfQoJCXJldHVybiBtaXgoIDEuMCwgc2hhZG93LCBzaGFkb3dJbnRlbnNpdHkgKTsKCX0KI2VuZGlmYCx4bD1gI2lmIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyA+IDAKCXVuaWZvcm0gbWF0NCBzcG90TGlnaHRNYXRyaXhbIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyBdOwoJdmFyeWluZyB2ZWM0IHZTcG90TGlnaHRDb29yZFsgTlVNX1NQT1RfTElHSFRfQ09PUkRTIF07CiNlbmRpZgojaWZkZWYgVVNFX1NIQURPV01BUAoJI2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDAKCQl1bmlmb3JtIG1hdDQgZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdOwoJCXZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07CgkJc3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgewoJCQlmbG9hdCBzaGFkb3dJbnRlbnNpdHk7CgkJCWZsb2F0IHNoYWRvd0JpYXM7CgkJCWZsb2F0IHNoYWRvd05vcm1hbEJpYXM7CgkJCWZsb2F0IHNoYWRvd1JhZGl1czsKCQkJdmVjMiBzaGFkb3dNYXBTaXplOwoJCX07CgkJdW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTsKCSNlbmRpZgoJI2lmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwCgkJc3RydWN0IFNwb3RMaWdodFNoYWRvdyB7CgkJCWZsb2F0IHNoYWRvd0ludGVuc2l0eTsKCQkJZmxvYXQgc2hhZG93QmlhczsKCQkJZmxvYXQgc2hhZG93Tm9ybWFsQmlhczsKCQkJZmxvYXQgc2hhZG93UmFkaXVzOwoJCQl2ZWMyIHNoYWRvd01hcFNpemU7CgkJfTsKCQl1bmlmb3JtIFNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHRTaGFkb3dzWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07CgkjZW5kaWYKCSNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDAKCQl1bmlmb3JtIG1hdDQgcG9pbnRTaGFkb3dNYXRyaXhbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07CgkJdmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdOwoJCXN0cnVjdCBQb2ludExpZ2h0U2hhZG93IHsKCQkJZmxvYXQgc2hhZG93SW50ZW5zaXR5OwoJCQlmbG9hdCBzaGFkb3dCaWFzOwoJCQlmbG9hdCBzaGFkb3dOb3JtYWxCaWFzOwoJCQlmbG9hdCBzaGFkb3dSYWRpdXM7CgkJCXZlYzIgc2hhZG93TWFwU2l6ZTsKCQkJZmxvYXQgc2hhZG93Q2FtZXJhTmVhcjsKCQkJZmxvYXQgc2hhZG93Q2FtZXJhRmFyOwoJCX07CgkJdW5pZm9ybSBQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3dzWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdOwoJI2VuZGlmCiNlbmRpZmAsTWw9YCNpZiAoIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiAoIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDAgfHwgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwICkgKSB8fCAoIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyA+IDAgKQoJdmVjMyBzaGFkb3dXb3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHRyYW5zZm9ybWVkTm9ybWFsLCB2aWV3TWF0cml4ICk7Cgl2ZWM0IHNoYWRvd1dvcmxkUG9zaXRpb247CiNlbmRpZgojaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApCgkjaWYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMAoJCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCQlmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7CgkJCXNoYWRvd1dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uICsgdmVjNCggc2hhZG93V29ybGROb3JtYWwgKiBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdLnNoYWRvd05vcm1hbEJpYXMsIDAgKTsKCQkJdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSA9IGRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBpIF0gKiBzaGFkb3dXb3JsZFBvc2l0aW9uOwoJCX0KCQkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJI2VuZGlmCgkjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwCgkJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJCWZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTOyBpICsrICkgewoJCQlzaGFkb3dXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbiArIHZlYzQoIHNoYWRvd1dvcmxkTm9ybWFsICogcG9pbnRMaWdodFNoYWRvd3NbIGkgXS5zaGFkb3dOb3JtYWxCaWFzLCAwICk7CgkJCXZQb2ludFNoYWRvd0Nvb3JkWyBpIF0gPSBwb2ludFNoYWRvd01hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjsKCQl9CgkJI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQKCSNlbmRpZgojZW5kaWYKI2lmIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyA+IDAKCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCWZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUX0NPT1JEUzsgaSArKyApIHsKCQlzaGFkb3dXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbjsKCQkjaWYgKCBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgKQoJCQlzaGFkb3dXb3JsZFBvc2l0aW9uLnh5eiArPSBzaGFkb3dXb3JsZE5vcm1hbCAqIHNwb3RMaWdodFNoYWRvd3NbIGkgXS5zaGFkb3dOb3JtYWxCaWFzOwoJCSNlbmRpZgoJCXZTcG90TGlnaHRDb29yZFsgaSBdID0gc3BvdExpZ2h0TWF0cml4WyBpIF0gKiBzaGFkb3dXb3JsZFBvc2l0aW9uOwoJfQoJI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQKI2VuZGlmYCxTbD1gZmxvYXQgZ2V0U2hhZG93TWFzaygpIHsKCWZsb2F0IHNoYWRvdyA9IDEuMDsKCSNpZmRlZiBVU0VfU0hBRE9XTUFQCgkjaWYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMAoJRGlyZWN0aW9uYWxMaWdodFNoYWRvdyBkaXJlY3Rpb25hbExpZ2h0OwoJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJZm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTOyBpICsrICkgewoJCWRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdOwoJCXNoYWRvdyAqPSByZWNlaXZlU2hhZG93ID8gZ2V0U2hhZG93KCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgaSBdLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd01hcFNpemUsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93SW50ZW5zaXR5LCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7Cgl9CgkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJI2VuZGlmCgkjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDAKCVNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHQ7CgkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTOyBpICsrICkgewoJCXNwb3RMaWdodCA9IHNwb3RMaWdodFNoYWRvd3NbIGkgXTsKCQlzaGFkb3cgKj0gcmVjZWl2ZVNoYWRvdyA/IGdldFNoYWRvdyggc3BvdFNoYWRvd01hcFsgaSBdLCBzcG90TGlnaHQuc2hhZG93TWFwU2l6ZSwgc3BvdExpZ2h0LnNoYWRvd0ludGVuc2l0eSwgc3BvdExpZ2h0LnNoYWRvd0JpYXMsIHNwb3RMaWdodC5zaGFkb3dSYWRpdXMsIHZTcG90TGlnaHRDb29yZFsgaSBdICkgOiAxLjA7Cgl9CgkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJI2VuZGlmCgkjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwCglQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHQ7CgkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUzsgaSArKyApIHsKCQlwb2ludExpZ2h0ID0gcG9pbnRMaWdodFNoYWRvd3NbIGkgXTsKCQlzaGFkb3cgKj0gcmVjZWl2ZVNoYWRvdyA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHQuc2hhZG93SW50ZW5zaXR5LCBwb2ludExpZ2h0LnNoYWRvd0JpYXMsIHBvaW50TGlnaHQuc2hhZG93UmFkaXVzLCB2UG9pbnRTaGFkb3dDb29yZFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd0NhbWVyYU5lYXIsIHBvaW50TGlnaHQuc2hhZG93Q2FtZXJhRmFyICkgOiAxLjA7Cgl9CgkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJI2VuZGlmCgkjZW5kaWYKCXJldHVybiBzaGFkb3c7Cn1gLEVsPWAjaWZkZWYgVVNFX1NLSU5OSU5HCgltYXQ0IGJvbmVNYXRYID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnggKTsKCW1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApOwoJbWF0NCBib25lTWF0WiA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC56ICk7CgltYXQ0IGJvbmVNYXRXID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LncgKTsKI2VuZGlmYCx5bD1gI2lmZGVmIFVTRV9TS0lOTklORwoJdW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXg7Cgl1bmlmb3JtIG1hdDQgYmluZE1hdHJpeEludmVyc2U7Cgl1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBib25lVGV4dHVyZTsKCW1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHsKCQlpbnQgc2l6ZSA9IHRleHR1cmVTaXplKCBib25lVGV4dHVyZSwgMCApLng7CgkJaW50IGogPSBpbnQoIGkgKSAqIDQ7CgkJaW50IHggPSBqICUgc2l6ZTsKCQlpbnQgeSA9IGogLyBzaXplOwoJCXZlYzQgdjEgPSB0ZXhlbEZldGNoKCBib25lVGV4dHVyZSwgaXZlYzIoIHgsIHkgKSwgMCApOwoJCXZlYzQgdjIgPSB0ZXhlbEZldGNoKCBib25lVGV4dHVyZSwgaXZlYzIoIHggKyAxLCB5ICksIDAgKTsKCQl2ZWM0IHYzID0gdGV4ZWxGZXRjaCggYm9uZVRleHR1cmUsIGl2ZWMyKCB4ICsgMiwgeSApLCAwICk7CgkJdmVjNCB2NCA9IHRleGVsRmV0Y2goIGJvbmVUZXh0dXJlLCBpdmVjMiggeCArIDMsIHkgKSwgMCApOwoJCXJldHVybiBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApOwoJfQojZW5kaWZgLFRsPWAjaWZkZWYgVVNFX1NLSU5OSU5HCgl2ZWM0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApOwoJdmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7Cglza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDsKCXNraW5uZWQgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55OwoJc2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7Cglza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudzsKCXRyYW5zZm9ybWVkID0gKCBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5uZWQgKS54eXo7CiNlbmRpZmAsQWw9YCNpZmRlZiBVU0VfU0tJTk5JTkcKCW1hdDQgc2tpbk1hdHJpeCA9IG1hdDQoIDAuMCApOwoJc2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnggKiBib25lTWF0WDsKCXNraW5NYXRyaXggKz0gc2tpbldlaWdodC55ICogYm9uZU1hdFk7Cglza2luTWF0cml4ICs9IHNraW5XZWlnaHQueiAqIGJvbmVNYXRaOwoJc2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LncgKiBib25lTWF0VzsKCXNraW5NYXRyaXggPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5NYXRyaXggKiBiaW5kTWF0cml4OwoJb2JqZWN0Tm9ybWFsID0gdmVjNCggc2tpbk1hdHJpeCAqIHZlYzQoIG9iamVjdE5vcm1hbCwgMC4wICkgKS54eXo7CgkjaWZkZWYgVVNFX1RBTkdFTlQKCQlvYmplY3RUYW5nZW50ID0gdmVjNCggc2tpbk1hdHJpeCAqIHZlYzQoIG9iamVjdFRhbmdlbnQsIDAuMCApICkueHl6OwoJI2VuZGlmCiNlbmRpZmAsYmw9YGZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7CiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVAKCXZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZTcGVjdWxhck1hcFV2ICk7CglzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yOwojZWxzZQoJc3BlY3VsYXJTdHJlbmd0aCA9IDEuMDsKI2VuZGlmYCx3bD1gI2lmZGVmIFVTRV9TUEVDVUxBUk1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJNYXA7CiNlbmRpZmAsUmw9YCNpZiBkZWZpbmVkKCBUT05FX01BUFBJTkcgKQoJZ2xfRnJhZ0NvbG9yLnJnYiA9IHRvbmVNYXBwaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7CiNlbmRpZmAsQ2w9YCNpZm5kZWYgc2F0dXJhdGUKI2RlZmluZSBzYXR1cmF0ZSggYSApIGNsYW1wKCBhLCAwLjAsIDEuMCApCiNlbmRpZgp1bmlmb3JtIGZsb2F0IHRvbmVNYXBwaW5nRXhwb3N1cmU7CnZlYzMgTGluZWFyVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7CglyZXR1cm4gc2F0dXJhdGUoIHRvbmVNYXBwaW5nRXhwb3N1cmUgKiBjb2xvciApOwp9CnZlYzMgUmVpbmhhcmRUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHsKCWNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7CglyZXR1cm4gc2F0dXJhdGUoIGNvbG9yIC8gKCB2ZWMzKCAxLjAgKSArIGNvbG9yICkgKTsKfQp2ZWMzIENpbmVvblRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkgewoJY29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTsKCWNvbG9yID0gbWF4KCB2ZWMzKCAwLjAgKSwgY29sb3IgLSAwLjAwNCApOwoJcmV0dXJuIHBvdyggKCBjb2xvciAqICggNi4yICogY29sb3IgKyAwLjUgKSApIC8gKCBjb2xvciAqICggNi4yICogY29sb3IgKyAxLjcgKSArIDAuMDYgKSwgdmVjMyggMi4yICkgKTsKfQp2ZWMzIFJSVEFuZE9EVEZpdCggdmVjMyB2ICkgewoJdmVjMyBhID0gdiAqICggdiArIDAuMDI0NTc4NiApIC0gMC4wMDAwOTA1Mzc7Cgl2ZWMzIGIgPSB2ICogKCAwLjk4MzcyOSAqIHYgKyAwLjQzMjk1MTAgKSArIDAuMjM4MDgxOwoJcmV0dXJuIGEgLyBiOwp9CnZlYzMgQUNFU0ZpbG1pY1RvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkgewoJY29uc3QgbWF0MyBBQ0VTSW5wdXRNYXQgPSBtYXQzKAoJCXZlYzMoIDAuNTk3MTksIDAuMDc2MDAsIDAuMDI4NDAgKSwJCXZlYzMoIDAuMzU0NTgsIDAuOTA4MzQsIDAuMTMzODMgKSwKCQl2ZWMzKCAwLjA0ODIzLCAwLjAxNTY2LCAwLjgzNzc3ICkKCSk7Cgljb25zdCBtYXQzIEFDRVNPdXRwdXRNYXQgPSBtYXQzKAoJCXZlYzMoICAxLjYwNDc1LCAtMC4xMDIwOCwgLTAuMDAzMjcgKSwJCXZlYzMoIC0wLjUzMTA4LCAgMS4xMDgxMywgLTAuMDcyNzYgKSwKCQl2ZWMzKCAtMC4wNzM2NywgLTAuMDA2MDUsICAxLjA3NjAyICkKCSk7Cgljb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlIC8gMC42OwoJY29sb3IgPSBBQ0VTSW5wdXRNYXQgKiBjb2xvcjsKCWNvbG9yID0gUlJUQW5kT0RURml0KCBjb2xvciApOwoJY29sb3IgPSBBQ0VTT3V0cHV0TWF0ICogY29sb3I7CglyZXR1cm4gc2F0dXJhdGUoIGNvbG9yICk7Cn0KY29uc3QgbWF0MyBMSU5FQVJfUkVDMjAyMF9UT19MSU5FQVJfU1JHQiA9IG1hdDMoCgl2ZWMzKCAxLjY2MDUsIC0gMC4xMjQ2LCAtIDAuMDE4MiApLAoJdmVjMyggLSAwLjU4NzYsIDEuMTMyOSwgLSAwLjEwMDYgKSwKCXZlYzMoIC0gMC4wNzI4LCAtIDAuMDA4MywgMS4xMTg3ICkKKTsKY29uc3QgbWF0MyBMSU5FQVJfU1JHQl9UT19MSU5FQVJfUkVDMjAyMCA9IG1hdDMoCgl2ZWMzKCAwLjYyNzQsIDAuMDY5MSwgMC4wMTY0ICksCgl2ZWMzKCAwLjMyOTMsIDAuOTE5NSwgMC4wODgwICksCgl2ZWMzKCAwLjA0MzMsIDAuMDExMywgMC44OTU2ICkKKTsKdmVjMyBhZ3hEZWZhdWx0Q29udHJhc3RBcHByb3goIHZlYzMgeCApIHsKCXZlYzMgeDIgPSB4ICogeDsKCXZlYzMgeDQgPSB4MiAqIHgyOwoJcmV0dXJuICsgMTUuNSAqIHg0ICogeDIKCQktIDQwLjE0ICogeDQgKiB4CgkJKyAzMS45NiAqIHg0CgkJLSA2Ljg2OCAqIHgyICogeAoJCSsgMC40Mjk4ICogeDIKCQkrIDAuMTE5MSAqIHgKCQktIDAuMDAyMzI7Cn0KdmVjMyBBZ1hUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHsKCWNvbnN0IG1hdDMgQWdYSW5zZXRNYXRyaXggPSBtYXQzKAoJCXZlYzMoIDAuODU2NjI3MTUzMzE1OTgzLCAwLjEzNzMxODk3MjkyOTg0NywgMC4xMTE4OTgyMTI5OTk5NSApLAoJCXZlYzMoIDAuMDk1MTIxMjQwNTM4MTU4OCwgMC43NjEyNDE5OTA2MDI1OTEsIDAuMDc2Nzk5NDE4NjAzMTkwMyApLAoJCXZlYzMoIDAuMDQ4MjUxNjA2MTQ1ODU4MywgMC4xMDE0MzkwMzY0Njc1NjIsIDAuODExMzAyMzY4Mzk2ODU5ICkKCSk7Cgljb25zdCBtYXQzIEFnWE91dHNldE1hdHJpeCA9IG1hdDMoCgkJdmVjMyggMS4xMjcxMDA1ODE4MTQ0MzY4LCAtIDAuMTQxMzI5NzYzNDk4NDM4MywgLSAwLjE0MTMyOTc2MzQ5ODQzODI2ICksCgkJdmVjMyggLSAwLjExMDYwNjY0MzA5NjYwMzIzLCAxLjE1NzgyMzcwMjIxNjI3MiwgLSAwLjExMDYwNjY0MzA5NjYwMjk0ICksCgkJdmVjMyggLSAwLjAxNjQ5MzkzODcxNzgzNDU3MywgLSAwLjAxNjQ5MzkzODcxNzgzNDI1NywgMS4yNTE5MzY0MDY1OTUwNDA1ICkKCSk7Cgljb25zdCBmbG9hdCBBZ3hNaW5FdiA9IC0gMTIuNDczOTM7CWNvbnN0IGZsb2F0IEFneE1heEV2ID0gNC4wMjYwNjk7Cgljb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlOwoJY29sb3IgPSBMSU5FQVJfU1JHQl9UT19MSU5FQVJfUkVDMjAyMCAqIGNvbG9yOwoJY29sb3IgPSBBZ1hJbnNldE1hdHJpeCAqIGNvbG9yOwoJY29sb3IgPSBtYXgoIGNvbG9yLCAxZS0xMCApOwljb2xvciA9IGxvZzIoIGNvbG9yICk7Cgljb2xvciA9ICggY29sb3IgLSBBZ3hNaW5FdiApIC8gKCBBZ3hNYXhFdiAtIEFneE1pbkV2ICk7Cgljb2xvciA9IGNsYW1wKCBjb2xvciwgMC4wLCAxLjAgKTsKCWNvbG9yID0gYWd4RGVmYXVsdENvbnRyYXN0QXBwcm94KCBjb2xvciApOwoJY29sb3IgPSBBZ1hPdXRzZXRNYXRyaXggKiBjb2xvcjsKCWNvbG9yID0gcG93KCBtYXgoIHZlYzMoIDAuMCApLCBjb2xvciApLCB2ZWMzKCAyLjIgKSApOwoJY29sb3IgPSBMSU5FQVJfUkVDMjAyMF9UT19MSU5FQVJfU1JHQiAqIGNvbG9yOwoJY29sb3IgPSBjbGFtcCggY29sb3IsIDAuMCwgMS4wICk7CglyZXR1cm4gY29sb3I7Cn0KdmVjMyBOZXV0cmFsVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7Cgljb25zdCBmbG9hdCBTdGFydENvbXByZXNzaW9uID0gMC44IC0gMC4wNDsKCWNvbnN0IGZsb2F0IERlc2F0dXJhdGlvbiA9IDAuMTU7Cgljb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlOwoJZmxvYXQgeCA9IG1pbiggY29sb3IuciwgbWluKCBjb2xvci5nLCBjb2xvci5iICkgKTsKCWZsb2F0IG9mZnNldCA9IHggPCAwLjA4ID8geCAtIDYuMjUgKiB4ICogeCA6IDAuMDQ7Cgljb2xvciAtPSBvZmZzZXQ7CglmbG9hdCBwZWFrID0gbWF4KCBjb2xvci5yLCBtYXgoIGNvbG9yLmcsIGNvbG9yLmIgKSApOwoJaWYgKCBwZWFrIDwgU3RhcnRDb21wcmVzc2lvbiApIHJldHVybiBjb2xvcjsKCWZsb2F0IGQgPSAxLiAtIFN0YXJ0Q29tcHJlc3Npb247CglmbG9hdCBuZXdQZWFrID0gMS4gLSBkICogZCAvICggcGVhayArIGQgLSBTdGFydENvbXByZXNzaW9uICk7Cgljb2xvciAqPSBuZXdQZWFrIC8gcGVhazsKCWZsb2F0IGcgPSAxLiAtIDEuIC8gKCBEZXNhdHVyYXRpb24gKiAoIHBlYWsgLSBuZXdQZWFrICkgKyAxLiApOwoJcmV0dXJuIG1peCggY29sb3IsIHZlYzMoIG5ld1BlYWsgKSwgZyApOwp9CnZlYzMgQ3VzdG9tVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7IHJldHVybiBjb2xvcjsgfWAsUGw9YCNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OCgltYXRlcmlhbC50cmFuc21pc3Npb24gPSB0cmFuc21pc3Npb247CgltYXRlcmlhbC50cmFuc21pc3Npb25BbHBoYSA9IDEuMDsKCW1hdGVyaWFsLnRoaWNrbmVzcyA9IHRoaWNrbmVzczsKCW1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBhdHRlbnVhdGlvbkRpc3RhbmNlOwoJbWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvciA9IGF0dGVudWF0aW9uQ29sb3I7CgkjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUAoJCW1hdGVyaWFsLnRyYW5zbWlzc2lvbiAqPSB0ZXh0dXJlMkQoIHRyYW5zbWlzc2lvbk1hcCwgdlRyYW5zbWlzc2lvbk1hcFV2ICkucjsKCSNlbmRpZgoJI2lmZGVmIFVTRV9USElDS05FU1NNQVAKCQltYXRlcmlhbC50aGlja25lc3MgKj0gdGV4dHVyZTJEKCB0aGlja25lc3NNYXAsIHZUaGlja25lc3NNYXBVdiApLmc7CgkjZW5kaWYKCXZlYzMgcG9zID0gdldvcmxkUG9zaXRpb247Cgl2ZWMzIHYgPSBub3JtYWxpemUoIGNhbWVyYVBvc2l0aW9uIC0gcG9zICk7Cgl2ZWMzIG4gPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTsKCXZlYzQgdHJhbnNtaXR0ZWQgPSBnZXRJQkxWb2x1bWVSZWZyYWN0aW9uKAoJCW4sIHYsIG1hdGVyaWFsLnJvdWdobmVzcywgbWF0ZXJpYWwuZGlmZnVzZUNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCwKCQlwb3MsIG1vZGVsTWF0cml4LCB2aWV3TWF0cml4LCBwcm9qZWN0aW9uTWF0cml4LCBtYXRlcmlhbC5kaXNwZXJzaW9uLCBtYXRlcmlhbC5pb3IsIG1hdGVyaWFsLnRoaWNrbmVzcywKCQltYXRlcmlhbC5hdHRlbnVhdGlvbkNvbG9yLCBtYXRlcmlhbC5hdHRlbnVhdGlvbkRpc3RhbmNlICk7CgltYXRlcmlhbC50cmFuc21pc3Npb25BbHBoYSA9IG1peCggbWF0ZXJpYWwudHJhbnNtaXNzaW9uQWxwaGEsIHRyYW5zbWl0dGVkLmEsIG1hdGVyaWFsLnRyYW5zbWlzc2lvbiApOwoJdG90YWxEaWZmdXNlID0gbWl4KCB0b3RhbERpZmZ1c2UsIHRyYW5zbWl0dGVkLnJnYiwgbWF0ZXJpYWwudHJhbnNtaXNzaW9uICk7CiNlbmRpZmAsRGw9YCNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OCgl1bmlmb3JtIGZsb2F0IHRyYW5zbWlzc2lvbjsKCXVuaWZvcm0gZmxvYXQgdGhpY2tuZXNzOwoJdW5pZm9ybSBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlOwoJdW5pZm9ybSB2ZWMzIGF0dGVudWF0aW9uQ29sb3I7CgkjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUAoJCXVuaWZvcm0gc2FtcGxlcjJEIHRyYW5zbWlzc2lvbk1hcDsKCSNlbmRpZgoJI2lmZGVmIFVTRV9USElDS05FU1NNQVAKCQl1bmlmb3JtIHNhbXBsZXIyRCB0aGlja25lc3NNYXA7CgkjZW5kaWYKCXVuaWZvcm0gdmVjMiB0cmFuc21pc3Npb25TYW1wbGVyU2l6ZTsKCXVuaWZvcm0gc2FtcGxlcjJEIHRyYW5zbWlzc2lvblNhbXBsZXJNYXA7Cgl1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7Cgl1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsKCXZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjsKCWZsb2F0IHcwKCBmbG9hdCBhICkgewoJCXJldHVybiAoIDEuMCAvIDYuMCApICogKCBhICogKCBhICogKCAtIGEgKyAzLjAgKSAtIDMuMCApICsgMS4wICk7Cgl9CglmbG9hdCB3MSggZmxvYXQgYSApIHsKCQlyZXR1cm4gKCAxLjAgLyA2LjAgKSAqICggYSAqICBhICogKCAzLjAgKiBhIC0gNi4wICkgKyA0LjAgKTsKCX0KCWZsb2F0IHcyKCBmbG9hdCBhICl7CgkJcmV0dXJuICggMS4wIC8gNi4wICkgKiAoIGEgKiAoIGEgKiAoIC0gMy4wICogYSArIDMuMCApICsgMy4wICkgKyAxLjAgKTsKCX0KCWZsb2F0IHczKCBmbG9hdCBhICkgewoJCXJldHVybiAoIDEuMCAvIDYuMCApICogKCBhICogYSAqIGEgKTsKCX0KCWZsb2F0IGcwKCBmbG9hdCBhICkgewoJCXJldHVybiB3MCggYSApICsgdzEoIGEgKTsKCX0KCWZsb2F0IGcxKCBmbG9hdCBhICkgewoJCXJldHVybiB3MiggYSApICsgdzMoIGEgKTsKCX0KCWZsb2F0IGgwKCBmbG9hdCBhICkgewoJCXJldHVybiAtIDEuMCArIHcxKCBhICkgLyAoIHcwKCBhICkgKyB3MSggYSApICk7Cgl9CglmbG9hdCBoMSggZmxvYXQgYSApIHsKCQlyZXR1cm4gMS4wICsgdzMoIGEgKSAvICggdzIoIGEgKSArIHczKCBhICkgKTsKCX0KCXZlYzQgYmljdWJpYyggc2FtcGxlcjJEIHRleCwgdmVjMiB1diwgdmVjNCB0ZXhlbFNpemUsIGZsb2F0IGxvZCApIHsKCQl1diA9IHV2ICogdGV4ZWxTaXplLnp3ICsgMC41OwoJCXZlYzIgaXV2ID0gZmxvb3IoIHV2ICk7CgkJdmVjMiBmdXYgPSBmcmFjdCggdXYgKTsKCQlmbG9hdCBnMHggPSBnMCggZnV2LnggKTsKCQlmbG9hdCBnMXggPSBnMSggZnV2LnggKTsKCQlmbG9hdCBoMHggPSBoMCggZnV2LnggKTsKCQlmbG9hdCBoMXggPSBoMSggZnV2LnggKTsKCQlmbG9hdCBoMHkgPSBoMCggZnV2LnkgKTsKCQlmbG9hdCBoMXkgPSBoMSggZnV2LnkgKTsKCQl2ZWMyIHAwID0gKCB2ZWMyKCBpdXYueCArIGgweCwgaXV2LnkgKyBoMHkgKSAtIDAuNSApICogdGV4ZWxTaXplLnh5OwoJCXZlYzIgcDEgPSAoIHZlYzIoIGl1di54ICsgaDF4LCBpdXYueSArIGgweSApIC0gMC41ICkgKiB0ZXhlbFNpemUueHk7CgkJdmVjMiBwMiA9ICggdmVjMiggaXV2LnggKyBoMHgsIGl1di55ICsgaDF5ICkgLSAwLjUgKSAqIHRleGVsU2l6ZS54eTsKCQl2ZWMyIHAzID0gKCB2ZWMyKCBpdXYueCArIGgxeCwgaXV2LnkgKyBoMXkgKSAtIDAuNSApICogdGV4ZWxTaXplLnh5OwoJCXJldHVybiBnMCggZnV2LnkgKSAqICggZzB4ICogdGV4dHVyZUxvZCggdGV4LCBwMCwgbG9kICkgKyBnMXggKiB0ZXh0dXJlTG9kKCB0ZXgsIHAxLCBsb2QgKSApICsKCQkJZzEoIGZ1di55ICkgKiAoIGcweCAqIHRleHR1cmVMb2QoIHRleCwgcDIsIGxvZCApICsgZzF4ICogdGV4dHVyZUxvZCggdGV4LCBwMywgbG9kICkgKTsKCX0KCXZlYzQgdGV4dHVyZUJpY3ViaWMoIHNhbXBsZXIyRCBzYW1wbGVyLCB2ZWMyIHV2LCBmbG9hdCBsb2QgKSB7CgkJdmVjMiBmTG9kU2l6ZSA9IHZlYzIoIHRleHR1cmVTaXplKCBzYW1wbGVyLCBpbnQoIGxvZCApICkgKTsKCQl2ZWMyIGNMb2RTaXplID0gdmVjMiggdGV4dHVyZVNpemUoIHNhbXBsZXIsIGludCggbG9kICsgMS4wICkgKSApOwoJCXZlYzIgZkxvZFNpemVJbnYgPSAxLjAgLyBmTG9kU2l6ZTsKCQl2ZWMyIGNMb2RTaXplSW52ID0gMS4wIC8gY0xvZFNpemU7CgkJdmVjNCBmU2FtcGxlID0gYmljdWJpYyggc2FtcGxlciwgdXYsIHZlYzQoIGZMb2RTaXplSW52LCBmTG9kU2l6ZSApLCBmbG9vciggbG9kICkgKTsKCQl2ZWM0IGNTYW1wbGUgPSBiaWN1YmljKCBzYW1wbGVyLCB1diwgdmVjNCggY0xvZFNpemVJbnYsIGNMb2RTaXplICksIGNlaWwoIGxvZCApICk7CgkJcmV0dXJuIG1peCggZlNhbXBsZSwgY1NhbXBsZSwgZnJhY3QoIGxvZCApICk7Cgl9Cgl2ZWMzIGdldFZvbHVtZVRyYW5zbWlzc2lvblJheSggY29uc3QgaW4gdmVjMyBuLCBjb25zdCBpbiB2ZWMzIHYsIGNvbnN0IGluIGZsb2F0IHRoaWNrbmVzcywgY29uc3QgaW4gZmxvYXQgaW9yLCBjb25zdCBpbiBtYXQ0IG1vZGVsTWF0cml4ICkgewoJCXZlYzMgcmVmcmFjdGlvblZlY3RvciA9IHJlZnJhY3QoIC0gdiwgbm9ybWFsaXplKCBuICksIDEuMCAvIGlvciApOwoJCXZlYzMgbW9kZWxTY2FsZTsKCQltb2RlbFNjYWxlLnggPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAwIF0ueHl6ICkgKTsKCQltb2RlbFNjYWxlLnkgPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAxIF0ueHl6ICkgKTsKCQltb2RlbFNjYWxlLnogPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAyIF0ueHl6ICkgKTsKCQlyZXR1cm4gbm9ybWFsaXplKCByZWZyYWN0aW9uVmVjdG9yICkgKiB0aGlja25lc3MgKiBtb2RlbFNjYWxlOwoJfQoJZmxvYXQgYXBwbHlJb3JUb1JvdWdobmVzcyggY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBjb25zdCBpbiBmbG9hdCBpb3IgKSB7CgkJcmV0dXJuIHJvdWdobmVzcyAqIGNsYW1wKCBpb3IgKiAyLjAgLSAyLjAsIDAuMCwgMS4wICk7Cgl9Cgl2ZWM0IGdldFRyYW5zbWlzc2lvblNhbXBsZSggY29uc3QgaW4gdmVjMiBmcmFnQ29vcmQsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gZmxvYXQgaW9yICkgewoJCWZsb2F0IGxvZCA9IGxvZzIoIHRyYW5zbWlzc2lvblNhbXBsZXJTaXplLnggKSAqIGFwcGx5SW9yVG9Sb3VnaG5lc3MoIHJvdWdobmVzcywgaW9yICk7CgkJcmV0dXJuIHRleHR1cmVCaWN1YmljKCB0cmFuc21pc3Npb25TYW1wbGVyTWFwLCBmcmFnQ29vcmQueHksIGxvZCApOwoJfQoJdmVjMyB2b2x1bWVBdHRlbnVhdGlvbiggY29uc3QgaW4gZmxvYXQgdHJhbnNtaXNzaW9uRGlzdGFuY2UsIGNvbnN0IGluIHZlYzMgYXR0ZW51YXRpb25Db2xvciwgY29uc3QgaW4gZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZSApIHsKCQlpZiAoIGlzaW5mKCBhdHRlbnVhdGlvbkRpc3RhbmNlICkgKSB7CgkJCXJldHVybiB2ZWMzKCAxLjAgKTsKCQl9IGVsc2UgewoJCQl2ZWMzIGF0dGVudWF0aW9uQ29lZmZpY2llbnQgPSAtbG9nKCBhdHRlbnVhdGlvbkNvbG9yICkgLyBhdHRlbnVhdGlvbkRpc3RhbmNlOwoJCQl2ZWMzIHRyYW5zbWl0dGFuY2UgPSBleHAoIC0gYXR0ZW51YXRpb25Db2VmZmljaWVudCAqIHRyYW5zbWlzc2lvbkRpc3RhbmNlICk7CQkJcmV0dXJuIHRyYW5zbWl0dGFuY2U7CgkJfQoJfQoJdmVjNCBnZXRJQkxWb2x1bWVSZWZyYWN0aW9uKCBjb25zdCBpbiB2ZWMzIG4sIGNvbnN0IGluIHZlYzMgdiwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBjb25zdCBpbiB2ZWMzIGRpZmZ1c2VDb2xvciwKCQljb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNwZWN1bGFyRjkwLCBjb25zdCBpbiB2ZWMzIHBvc2l0aW9uLCBjb25zdCBpbiBtYXQ0IG1vZGVsTWF0cml4LAoJCWNvbnN0IGluIG1hdDQgdmlld01hdHJpeCwgY29uc3QgaW4gbWF0NCBwcm9qTWF0cml4LCBjb25zdCBpbiBmbG9hdCBkaXNwZXJzaW9uLCBjb25zdCBpbiBmbG9hdCBpb3IsIGNvbnN0IGluIGZsb2F0IHRoaWNrbmVzcywKCQljb25zdCBpbiB2ZWMzIGF0dGVudWF0aW9uQ29sb3IsIGNvbnN0IGluIGZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2UgKSB7CgkJdmVjNCB0cmFuc21pdHRlZExpZ2h0OwoJCXZlYzMgdHJhbnNtaXR0YW5jZTsKCQkjaWZkZWYgVVNFX0RJU1BFUlNJT04KCQkJZmxvYXQgaGFsZlNwcmVhZCA9ICggaW9yIC0gMS4wICkgKiAwLjAyNSAqIGRpc3BlcnNpb247CgkJCXZlYzMgaW9ycyA9IHZlYzMoIGlvciAtIGhhbGZTcHJlYWQsIGlvciwgaW9yICsgaGFsZlNwcmVhZCApOwoJCQlmb3IgKCBpbnQgaSA9IDA7IGkgPCAzOyBpICsrICkgewoJCQkJdmVjMyB0cmFuc21pc3Npb25SYXkgPSBnZXRWb2x1bWVUcmFuc21pc3Npb25SYXkoIG4sIHYsIHRoaWNrbmVzcywgaW9yc1sgaSBdLCBtb2RlbE1hdHJpeCApOwoJCQkJdmVjMyByZWZyYWN0ZWRSYXlFeGl0ID0gcG9zaXRpb24gKyB0cmFuc21pc3Npb25SYXk7CgkJCgkJCQl2ZWM0IG5kY1BvcyA9IHByb2pNYXRyaXggKiB2aWV3TWF0cml4ICogdmVjNCggcmVmcmFjdGVkUmF5RXhpdCwgMS4wICk7CgkJCQl2ZWMyIHJlZnJhY3Rpb25Db29yZHMgPSBuZGNQb3MueHkgLyBuZGNQb3MudzsKCQkJCXJlZnJhY3Rpb25Db29yZHMgKz0gMS4wOwoJCQkJcmVmcmFjdGlvbkNvb3JkcyAvPSAyLjA7CgkJCgkJCQl2ZWM0IHRyYW5zbWlzc2lvblNhbXBsZSA9IGdldFRyYW5zbWlzc2lvblNhbXBsZSggcmVmcmFjdGlvbkNvb3Jkcywgcm91Z2huZXNzLCBpb3JzWyBpIF0gKTsKCQkJCXRyYW5zbWl0dGVkTGlnaHRbIGkgXSA9IHRyYW5zbWlzc2lvblNhbXBsZVsgaSBdOwoJCQkJdHJhbnNtaXR0ZWRMaWdodC5hICs9IHRyYW5zbWlzc2lvblNhbXBsZS5hOwoJCQkJdHJhbnNtaXR0YW5jZVsgaSBdID0gZGlmZnVzZUNvbG9yWyBpIF0gKiB2b2x1bWVBdHRlbnVhdGlvbiggbGVuZ3RoKCB0cmFuc21pc3Npb25SYXkgKSwgYXR0ZW51YXRpb25Db2xvciwgYXR0ZW51YXRpb25EaXN0YW5jZSApWyBpIF07CgkJCX0KCQkJdHJhbnNtaXR0ZWRMaWdodC5hIC89IDMuMDsKCQkKCQkjZWxzZQoJCQoJCQl2ZWMzIHRyYW5zbWlzc2lvblJheSA9IGdldFZvbHVtZVRyYW5zbWlzc2lvblJheSggbiwgdiwgdGhpY2tuZXNzLCBpb3IsIG1vZGVsTWF0cml4ICk7CgkJCXZlYzMgcmVmcmFjdGVkUmF5RXhpdCA9IHBvc2l0aW9uICsgdHJhbnNtaXNzaW9uUmF5OwoJCQl2ZWM0IG5kY1BvcyA9IHByb2pNYXRyaXggKiB2aWV3TWF0cml4ICogdmVjNCggcmVmcmFjdGVkUmF5RXhpdCwgMS4wICk7CgkJCXZlYzIgcmVmcmFjdGlvbkNvb3JkcyA9IG5kY1Bvcy54eSAvIG5kY1Bvcy53OwoJCQlyZWZyYWN0aW9uQ29vcmRzICs9IDEuMDsKCQkJcmVmcmFjdGlvbkNvb3JkcyAvPSAyLjA7CgkJCXRyYW5zbWl0dGVkTGlnaHQgPSBnZXRUcmFuc21pc3Npb25TYW1wbGUoIHJlZnJhY3Rpb25Db29yZHMsIHJvdWdobmVzcywgaW9yICk7CgkJCXRyYW5zbWl0dGFuY2UgPSBkaWZmdXNlQ29sb3IgKiB2b2x1bWVBdHRlbnVhdGlvbiggbGVuZ3RoKCB0cmFuc21pc3Npb25SYXkgKSwgYXR0ZW51YXRpb25Db2xvciwgYXR0ZW51YXRpb25EaXN0YW5jZSApOwoJCQoJCSNlbmRpZgoJCXZlYzMgYXR0ZW51YXRlZENvbG9yID0gdHJhbnNtaXR0YW5jZSAqIHRyYW5zbWl0dGVkTGlnaHQucmdiOwoJCXZlYzMgRiA9IEVudmlyb25tZW50QlJERiggbiwgdiwgc3BlY3VsYXJDb2xvciwgc3BlY3VsYXJGOTAsIHJvdWdobmVzcyApOwoJCWZsb2F0IHRyYW5zbWl0dGFuY2VGYWN0b3IgPSAoIHRyYW5zbWl0dGFuY2UuciArIHRyYW5zbWl0dGFuY2UuZyArIHRyYW5zbWl0dGFuY2UuYiApIC8gMy4wOwoJCXJldHVybiB2ZWM0KCAoIDEuMCAtIEYgKSAqIGF0dGVudWF0ZWRDb2xvciwgMS4wIC0gKCAxLjAgLSB0cmFuc21pdHRlZExpZ2h0LmEgKSAqIHRyYW5zbWl0dGFuY2VGYWN0b3IgKTsKCX0KI2VuZGlmYCxMbD1gI2lmIGRlZmluZWQoIFVTRV9VViApIHx8IGRlZmluZWQoIFVTRV9BTklTT1RST1BZICkKCXZhcnlpbmcgdmVjMiB2VXY7CiNlbmRpZgojaWZkZWYgVVNFX01BUAoJdmFyeWluZyB2ZWMyIHZNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQUxQSEFNQVAKCXZhcnlpbmcgdmVjMiB2QWxwaGFNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfTElHSFRNQVAKCXZhcnlpbmcgdmVjMiB2TGlnaHRNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQU9NQVAKCXZhcnlpbmcgdmVjMiB2QW9NYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQlVNUE1BUAoJdmFyeWluZyB2ZWMyIHZCdW1wTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX05PUk1BTE1BUAoJdmFyeWluZyB2ZWMyIHZOb3JtYWxNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfRU1JU1NJVkVNQVAKCXZhcnlpbmcgdmVjMiB2RW1pc3NpdmVNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQCgl2YXJ5aW5nIHZlYzIgdk1ldGFsbmVzc01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVAKCXZhcnlpbmcgdmVjMiB2Um91Z2huZXNzTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0FOSVNPVFJPUFlNQVAKCXZhcnlpbmcgdmVjMiB2QW5pc290cm9weU1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRNQVAKCXZhcnlpbmcgdmVjMiB2Q2xlYXJjb2F0TWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAKCXZhcnlpbmcgdmVjMiB2Q2xlYXJjb2F0Tm9ybWFsTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAKCXZhcnlpbmcgdmVjMiB2Q2xlYXJjb2F0Um91Z2huZXNzTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0lSSURFU0NFTkNFTUFQCgl2YXJ5aW5nIHZlYzIgdklyaWRlc2NlbmNlTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUAoJdmFyeWluZyB2ZWMyIHZJcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUAoJdmFyeWluZyB2ZWMyIHZTaGVlbkNvbG9yTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1NIRUVOX1JPVUdITkVTU01BUAoJdmFyeWluZyB2ZWMyIHZTaGVlblJvdWdobmVzc01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9TUEVDVUxBUk1BUAoJdmFyeWluZyB2ZWMyIHZTcGVjdWxhck1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9TUEVDVUxBUl9DT0xPUk1BUAoJdmFyeWluZyB2ZWMyIHZTcGVjdWxhckNvbG9yTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUAoJdmFyeWluZyB2ZWMyIHZTcGVjdWxhckludGVuc2l0eU1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVAKCXVuaWZvcm0gbWF0MyB0cmFuc21pc3Npb25NYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdlRyYW5zbWlzc2lvbk1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9USElDS05FU1NNQVAKCXVuaWZvcm0gbWF0MyB0aGlja25lc3NNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdlRoaWNrbmVzc01hcFV2OwojZW5kaWZgLFVsPWAjaWYgZGVmaW5lZCggVVNFX1VWICkgfHwgZGVmaW5lZCggVVNFX0FOSVNPVFJPUFkgKQoJdmFyeWluZyB2ZWMyIHZVdjsKI2VuZGlmCiNpZmRlZiBVU0VfTUFQCgl1bmlmb3JtIG1hdDMgbWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQUxQSEFNQVAKCXVuaWZvcm0gbWF0MyBhbHBoYU1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2QWxwaGFNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfTElHSFRNQVAKCXVuaWZvcm0gbWF0MyBsaWdodE1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2TGlnaHRNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQU9NQVAKCXVuaWZvcm0gbWF0MyBhb01hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2QW9NYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQlVNUE1BUAoJdW5pZm9ybSBtYXQzIGJ1bXBNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdkJ1bXBNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfTk9STUFMTUFQCgl1bmlmb3JtIG1hdDMgbm9ybWFsTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZOb3JtYWxNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQCgl1bmlmb3JtIG1hdDMgZGlzcGxhY2VtZW50TWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZEaXNwbGFjZW1lbnRNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfRU1JU1NJVkVNQVAKCXVuaWZvcm0gbWF0MyBlbWlzc2l2ZU1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2RW1pc3NpdmVNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQCgl1bmlmb3JtIG1hdDMgbWV0YWxuZXNzTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZNZXRhbG5lc3NNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQCgl1bmlmb3JtIG1hdDMgcm91Z2huZXNzTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZSb3VnaG5lc3NNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUAoJdW5pZm9ybSBtYXQzIGFuaXNvdHJvcHlNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdkFuaXNvdHJvcHlNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQCgl1bmlmb3JtIG1hdDMgY2xlYXJjb2F0TWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZDbGVhcmNvYXRNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUAoJdW5pZm9ybSBtYXQzIGNsZWFyY29hdE5vcm1hbE1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2Q2xlYXJjb2F0Tm9ybWFsTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAKCXVuaWZvcm0gbWF0MyBjbGVhcmNvYXRSb3VnaG5lc3NNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdkNsZWFyY29hdFJvdWdobmVzc01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUAoJdW5pZm9ybSBtYXQzIHNoZWVuQ29sb3JNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdlNoZWVuQ29sb3JNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQCgl1bmlmb3JtIG1hdDMgc2hlZW5Sb3VnaG5lc3NNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdlNoZWVuUm91Z2huZXNzTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0lSSURFU0NFTkNFTUFQCgl1bmlmb3JtIG1hdDMgaXJpZGVzY2VuY2VNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdklyaWRlc2NlbmNlTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUAoJdW5pZm9ybSBtYXQzIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZJcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9TUEVDVUxBUk1BUAoJdW5pZm9ybSBtYXQzIHNwZWN1bGFyTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZTcGVjdWxhck1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9TUEVDVUxBUl9DT0xPUk1BUAoJdW5pZm9ybSBtYXQzIHNwZWN1bGFyQ29sb3JNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdlNwZWN1bGFyQ29sb3JNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfU1BFQ1VMQVJfSU5URU5TSVRZTUFQCgl1bmlmb3JtIG1hdDMgc3BlY3VsYXJJbnRlbnNpdHlNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdlNwZWN1bGFySW50ZW5zaXR5TWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUAoJdW5pZm9ybSBtYXQzIHRyYW5zbWlzc2lvbk1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2VHJhbnNtaXNzaW9uTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1RISUNLTkVTU01BUAoJdW5pZm9ybSBtYXQzIHRoaWNrbmVzc01hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2VGhpY2tuZXNzTWFwVXY7CiNlbmRpZmAsRmw9YCNpZiBkZWZpbmVkKCBVU0VfVVYgKSB8fCBkZWZpbmVkKCBVU0VfQU5JU09UUk9QWSApCgl2VXYgPSB2ZWMzKCB1diwgMSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9NQVAKCXZNYXBVdiA9ICggbWFwVHJhbnNmb3JtICogdmVjMyggTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfQUxQSEFNQVAKCXZBbHBoYU1hcFV2ID0gKCBhbHBoYU1hcFRyYW5zZm9ybSAqIHZlYzMoIEFMUEhBTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfTElHSFRNQVAKCXZMaWdodE1hcFV2ID0gKCBsaWdodE1hcFRyYW5zZm9ybSAqIHZlYzMoIExJR0hUTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfQU9NQVAKCXZBb01hcFV2ID0gKCBhb01hcFRyYW5zZm9ybSAqIHZlYzMoIEFPTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfQlVNUE1BUAoJdkJ1bXBNYXBVdiA9ICggYnVtcE1hcFRyYW5zZm9ybSAqIHZlYzMoIEJVTVBNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9OT1JNQUxNQVAKCXZOb3JtYWxNYXBVdiA9ICggbm9ybWFsTWFwVHJhbnNmb3JtICogdmVjMyggTk9STUFMTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQCgl2RGlzcGxhY2VtZW50TWFwVXYgPSAoIGRpc3BsYWNlbWVudE1hcFRyYW5zZm9ybSAqIHZlYzMoIERJU1BMQUNFTUVOVE1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX0VNSVNTSVZFTUFQCgl2RW1pc3NpdmVNYXBVdiA9ICggZW1pc3NpdmVNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBFTUlTU0lWRU1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX01FVEFMTkVTU01BUAoJdk1ldGFsbmVzc01hcFV2ID0gKCBtZXRhbG5lc3NNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBNRVRBTE5FU1NNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVAKCXZSb3VnaG5lc3NNYXBVdiA9ICggcm91Z2huZXNzTWFwVHJhbnNmb3JtICogdmVjMyggUk9VR0hORVNTTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUAoJdkFuaXNvdHJvcHlNYXBVdiA9ICggYW5pc290cm9weU1hcFRyYW5zZm9ybSAqIHZlYzMoIEFOSVNPVFJPUFlNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRNQVAKCXZDbGVhcmNvYXRNYXBVdiA9ICggY2xlYXJjb2F0TWFwVHJhbnNmb3JtICogdmVjMyggQ0xFQVJDT0FUTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUAoJdkNsZWFyY29hdE5vcm1hbE1hcFV2ID0gKCBjbGVhcmNvYXROb3JtYWxNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBDTEVBUkNPQVRfTk9STUFMTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUAoJdkNsZWFyY29hdFJvdWdobmVzc01hcFV2ID0gKCBjbGVhcmNvYXRSb3VnaG5lc3NNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBDTEVBUkNPQVRfUk9VR0hORVNTTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VNQVAKCXZJcmlkZXNjZW5jZU1hcFV2ID0gKCBpcmlkZXNjZW5jZU1hcFRyYW5zZm9ybSAqIHZlYzMoIElSSURFU0NFTkNFTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQCgl2SXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdiA9ICggaXJpZGVzY2VuY2VUaGlja25lc3NNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBJUklERVNDRU5DRV9USElDS05FU1NNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUAoJdlNoZWVuQ29sb3JNYXBVdiA9ICggc2hlZW5Db2xvck1hcFRyYW5zZm9ybSAqIHZlYzMoIFNIRUVOX0NPTE9STUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQCgl2U2hlZW5Sb3VnaG5lc3NNYXBVdiA9ICggc2hlZW5Sb3VnaG5lc3NNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBTSEVFTl9ST1VHSE5FU1NNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9TUEVDVUxBUk1BUAoJdlNwZWN1bGFyTWFwVXYgPSAoIHNwZWN1bGFyTWFwVHJhbnNmb3JtICogdmVjMyggU1BFQ1VMQVJNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9TUEVDVUxBUl9DT0xPUk1BUAoJdlNwZWN1bGFyQ29sb3JNYXBVdiA9ICggc3BlY3VsYXJDb2xvck1hcFRyYW5zZm9ybSAqIHZlYzMoIFNQRUNVTEFSX0NPTE9STUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfU1BFQ1VMQVJfSU5URU5TSVRZTUFQCgl2U3BlY3VsYXJJbnRlbnNpdHlNYXBVdiA9ICggc3BlY3VsYXJJbnRlbnNpdHlNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBTUEVDVUxBUl9JTlRFTlNJVFlNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVAKCXZUcmFuc21pc3Npb25NYXBVdiA9ICggdHJhbnNtaXNzaW9uTWFwVHJhbnNmb3JtICogdmVjMyggVFJBTlNNSVNTSU9OTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQCgl2VGhpY2tuZXNzTWFwVXYgPSAoIHRoaWNrbmVzc01hcFRyYW5zZm9ybSAqIHZlYzMoIFRISUNLTkVTU01BUF9VViwgMSApICkueHk7CiNlbmRpZmAsSWw9YCNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggRElTVEFOQ0UgKSB8fCBkZWZpbmVkICggVVNFX1NIQURPV01BUCApIHx8IGRlZmluZWQgKCBVU0VfVFJBTlNNSVNTSU9OICkgfHwgTlVNX1NQT1RfTElHSFRfQ09PUkRTID4gMAoJdmVjNCB3b3JsZFBvc2l0aW9uID0gdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApOwoJI2lmZGVmIFVTRV9CQVRDSElORwoJCXdvcmxkUG9zaXRpb24gPSBiYXRjaGluZ01hdHJpeCAqIHdvcmxkUG9zaXRpb247CgkjZW5kaWYKCSNpZmRlZiBVU0VfSU5TVEFOQ0lORwoJCXdvcmxkUG9zaXRpb24gPSBpbnN0YW5jZU1hdHJpeCAqIHdvcmxkUG9zaXRpb247CgkjZW5kaWYKCXdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHdvcmxkUG9zaXRpb247CiNlbmRpZmA7Y29uc3QgUGU9e2FscGhhaGFzaF9mcmFnbWVudDpOYSxhbHBoYWhhc2hfcGFyc19mcmFnbWVudDpPYSxhbHBoYW1hcF9mcmFnbWVudDpCYSxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50OnphLGFscGhhdGVzdF9mcmFnbWVudDpHYSxhbHBoYXRlc3RfcGFyc19mcmFnbWVudDpIYSxhb21hcF9mcmFnbWVudDpWYSxhb21hcF9wYXJzX2ZyYWdtZW50OmthLGJhdGNoaW5nX3BhcnNfdmVydGV4OldhLGJhdGNoaW5nX3ZlcnRleDpYYSxiZWdpbl92ZXJ0ZXg6cWEsYmVnaW5ub3JtYWxfdmVydGV4OllhLGJzZGZzOiRhLGlyaWRlc2NlbmNlX2ZyYWdtZW50OlphLGJ1bXBtYXBfcGFyc19mcmFnbWVudDpLYSxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ6amEsY2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ6SmEsY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4OlFhLGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg6ZW8sY29sb3JfZnJhZ21lbnQ6dG8sY29sb3JfcGFyc19mcmFnbWVudDpubyxjb2xvcl9wYXJzX3ZlcnRleDppbyxjb2xvcl92ZXJ0ZXg6cm8sY29tbW9uOnNvLGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudDphbyxkZWZhdWx0bm9ybWFsX3ZlcnRleDpvbyxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg6bG8sZGlzcGxhY2VtZW50bWFwX3ZlcnRleDpjbyxlbWlzc2l2ZW1hcF9mcmFnbWVudDp1byxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50OmhvLGNvbG9yc3BhY2VfZnJhZ21lbnQ6Zm8sY29sb3JzcGFjZV9wYXJzX2ZyYWdtZW50OnBvLGVudm1hcF9mcmFnbWVudDptbyxlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ6X28sZW52bWFwX3BhcnNfZnJhZ21lbnQ6Z28sZW52bWFwX3BhcnNfdmVydGV4OnZvLGVudm1hcF9waHlzaWNhbF9wYXJzX2ZyYWdtZW50OkNvLGVudm1hcF92ZXJ0ZXg6eG8sZm9nX3ZlcnRleDpNbyxmb2dfcGFyc192ZXJ0ZXg6U28sZm9nX2ZyYWdtZW50OkVvLGZvZ19wYXJzX2ZyYWdtZW50OnlvLGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQ6VG8sbGlnaHRtYXBfcGFyc19mcmFnbWVudDpBbyxsaWdodHNfbGFtYmVydF9mcmFnbWVudDpibyxsaWdodHNfbGFtYmVydF9wYXJzX2ZyYWdtZW50OndvLGxpZ2h0c19wYXJzX2JlZ2luOlJvLGxpZ2h0c190b29uX2ZyYWdtZW50OlBvLGxpZ2h0c190b29uX3BhcnNfZnJhZ21lbnQ6RG8sbGlnaHRzX3Bob25nX2ZyYWdtZW50OkxvLGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50OlVvLGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudDpGbyxsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudDpJbyxsaWdodHNfZnJhZ21lbnRfYmVnaW46Tm8sbGlnaHRzX2ZyYWdtZW50X21hcHM6T28sbGlnaHRzX2ZyYWdtZW50X2VuZDpCbyxsb2dkZXB0aGJ1Zl9mcmFnbWVudDp6byxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50OkdvLGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4OkhvLGxvZ2RlcHRoYnVmX3ZlcnRleDpWbyxtYXBfZnJhZ21lbnQ6a28sbWFwX3BhcnNfZnJhZ21lbnQ6V28sbWFwX3BhcnRpY2xlX2ZyYWdtZW50OlhvLG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50OnFvLG1ldGFsbmVzc21hcF9mcmFnbWVudDpZbyxtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudDokbyxtb3JwaGluc3RhbmNlX3ZlcnRleDpabyxtb3JwaGNvbG9yX3ZlcnRleDpLbyxtb3JwaG5vcm1hbF92ZXJ0ZXg6am8sbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg6Sm8sbW9ycGh0YXJnZXRfdmVydGV4OlFvLG5vcm1hbF9mcmFnbWVudF9iZWdpbjplbCxub3JtYWxfZnJhZ21lbnRfbWFwczp0bCxub3JtYWxfcGFyc19mcmFnbWVudDpubCxub3JtYWxfcGFyc192ZXJ0ZXg6aWwsbm9ybWFsX3ZlcnRleDpybCxub3JtYWxtYXBfcGFyc19mcmFnbWVudDpzbCxjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X2JlZ2luOmFsLGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwczpvbCxjbGVhcmNvYXRfcGFyc19mcmFnbWVudDpsbCxpcmlkZXNjZW5jZV9wYXJzX2ZyYWdtZW50OmNsLG9wYXF1ZV9mcmFnbWVudDp1bCxwYWNraW5nOmhsLHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ6ZGwscHJvamVjdF92ZXJ0ZXg6ZmwsZGl0aGVyaW5nX2ZyYWdtZW50OnBsLGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50Om1sLHJvdWdobmVzc21hcF9mcmFnbWVudDpfbCxyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudDpnbCxzaGFkb3dtYXBfcGFyc19mcmFnbWVudDp2bCxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg6eGwsc2hhZG93bWFwX3ZlcnRleDpNbCxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ6U2wsc2tpbmJhc2VfdmVydGV4OkVsLHNraW5uaW5nX3BhcnNfdmVydGV4OnlsLHNraW5uaW5nX3ZlcnRleDpUbCxza2lubm9ybWFsX3ZlcnRleDpBbCxzcGVjdWxhcm1hcF9mcmFnbWVudDpibCxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50OndsLHRvbmVtYXBwaW5nX2ZyYWdtZW50OlJsLHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQ6Q2wsdHJhbnNtaXNzaW9uX2ZyYWdtZW50OlBsLHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50OkRsLHV2X3BhcnNfZnJhZ21lbnQ6TGwsdXZfcGFyc192ZXJ0ZXg6VWwsdXZfdmVydGV4OkZsLHdvcmxkcG9zX3ZlcnRleDpJbCxiYWNrZ3JvdW5kX3ZlcnQ6YHZhcnlpbmcgdmVjMiB2VXY7CnVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTsKdm9pZCBtYWluKCkgewoJdlV2ID0gKCB1dlRyYW5zZm9ybSAqIHZlYzMoIHV2LCAxICkgKS54eTsKCWdsX1Bvc2l0aW9uID0gdmVjNCggcG9zaXRpb24ueHksIDEuMCwgMS4wICk7Cn1gLGJhY2tncm91bmRfZnJhZzpgdW5pZm9ybSBzYW1wbGVyMkQgdDJEOwp1bmlmb3JtIGZsb2F0IGJhY2tncm91bmRJbnRlbnNpdHk7CnZhcnlpbmcgdmVjMiB2VXY7CnZvaWQgbWFpbigpIHsKCXZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQoIHQyRCwgdlV2ICk7CgkjaWZkZWYgREVDT0RFX1ZJREVPX1RFWFRVUkUKCQl0ZXhDb2xvciA9IHZlYzQoIG1peCggcG93KCB0ZXhDb2xvci5yZ2IgKiAwLjk0Nzg2NzI5ODYgKyB2ZWMzKCAwLjA1MjEzMjcwMTQgKSwgdmVjMyggMi40ICkgKSwgdGV4Q29sb3IucmdiICogMC4wNzczOTkzODA4LCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB0ZXhDb2xvci5yZ2IsIHZlYzMoIDAuMDQwNDUgKSApICkgKSwgdGV4Q29sb3IudyApOwoJI2VuZGlmCgl0ZXhDb2xvci5yZ2IgKj0gYmFja2dyb3VuZEludGVuc2l0eTsKCWdsX0ZyYWdDb2xvciA9IHRleENvbG9yOwoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+Cn1gLGJhY2tncm91bmRDdWJlX3ZlcnQ6YHZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247CiNpbmNsdWRlIDxjb21tb24+CnZvaWQgbWFpbigpIHsKCXZXb3JsZERpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJZ2xfUG9zaXRpb24ueiA9IGdsX1Bvc2l0aW9uLnc7Cn1gLGJhY2tncm91bmRDdWJlX2ZyYWc6YCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFCgl1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDsKI2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApCgl1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7CiNlbmRpZgp1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7CnVuaWZvcm0gZmxvYXQgYmFja2dyb3VuZEJsdXJyaW5lc3M7CnVuaWZvcm0gZmxvYXQgYmFja2dyb3VuZEludGVuc2l0eTsKdW5pZm9ybSBtYXQzIGJhY2tncm91bmRSb3RhdGlvbjsKdmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjsKI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD4Kdm9pZCBtYWluKCkgewoJI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkUKCQl2ZWM0IHRleENvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgYmFja2dyb3VuZFJvdGF0aW9uICogdmVjMyggZmxpcEVudk1hcCAqIHZXb3JsZERpcmVjdGlvbi54LCB2V29ybGREaXJlY3Rpb24ueXogKSApOwoJI2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApCgkJdmVjNCB0ZXhDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgYmFja2dyb3VuZFJvdGF0aW9uICogdldvcmxkRGlyZWN0aW9uLCBiYWNrZ3JvdW5kQmx1cnJpbmVzcyApOwoJI2Vsc2UKCQl2ZWM0IHRleENvbG9yID0gdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7CgkjZW5kaWYKCXRleENvbG9yLnJnYiAqPSBiYWNrZ3JvdW5kSW50ZW5zaXR5OwoJZ2xfRnJhZ0NvbG9yID0gdGV4Q29sb3I7CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KfWAsY3ViZV92ZXJ0OmB2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uOwojaW5jbHVkZSA8Y29tbW9uPgp2b2lkIG1haW4oKSB7Cgl2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApOwoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCWdsX1Bvc2l0aW9uLnogPSBnbF9Qb3NpdGlvbi53Owp9YCxjdWJlX2ZyYWc6YHVuaWZvcm0gc2FtcGxlckN1YmUgdEN1YmU7CnVuaWZvcm0gZmxvYXQgdEZsaXA7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKdmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjsKdm9pZCBtYWluKCkgewoJdmVjNCB0ZXhDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGREaXJlY3Rpb24ueCwgdldvcmxkRGlyZWN0aW9uLnl6ICkgKTsKCWdsX0ZyYWdDb2xvciA9IHRleENvbG9yOwoJZ2xfRnJhZ0NvbG9yLmEgKj0gb3BhY2l0eTsKCSNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50Pgp9YCxkZXB0aF92ZXJ0OmAjaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4KdmFyeWluZyB2ZWMyIHZIaWdoUHJlY2lzaW9uWlc7CnZvaWQgbWFpbigpIHsKCSNpbmNsdWRlIDx1dl92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD4KCSNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQCgkJI2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD4KCQkjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PgoJCSNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD4KCSNlbmRpZgoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PgoJI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PgoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+Cgl2SGlnaFByZWNpc2lvblpXID0gZ2xfUG9zaXRpb24uenc7Cn1gLGRlcHRoX2ZyYWc6YCNpZiBERVBUSF9QQUNLSU5HID09IDMyMDAKCXVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2VuZGlmCiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxwYWNraW5nPgojaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZhcnlpbmcgdmVjMiB2SGlnaFByZWNpc2lvblpXOwp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDEuMCApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCSNpZiBERVBUSF9QQUNLSU5HID09IDMyMDAKCQlkaWZmdXNlQ29sb3IuYSA9IG9wYWNpdHk7CgkjZW5kaWYKCSNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD4KCWZsb2F0IGZyYWdDb29yZFogPSAwLjUgKiB2SGlnaFByZWNpc2lvblpXWzBdIC8gdkhpZ2hQcmVjaXNpb25aV1sxXSArIDAuNTsKCSNpZiBERVBUSF9QQUNLSU5HID09IDMyMDAKCQlnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCAxLjAgLSBmcmFnQ29vcmRaICksIG9wYWNpdHkgKTsKCSNlbGlmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMQoJCWdsX0ZyYWdDb2xvciA9IHBhY2tEZXB0aFRvUkdCQSggZnJhZ0Nvb3JkWiApOwoJI2VsaWYgREVQVEhfUEFDS0lORyA9PSAzMjAyCgkJZ2xfRnJhZ0NvbG9yID0gdmVjNCggcGFja0RlcHRoVG9SR0IoIGZyYWdDb29yZFogKSwgMS4wICk7CgkjZWxpZiBERVBUSF9QQUNLSU5HID09IDMyMDMKCQlnbF9GcmFnQ29sb3IgPSB2ZWM0KCBwYWNrRGVwdGhUb1JHKCBmcmFnQ29vcmRaICksIDAuMCwgMS4wICk7CgkjZW5kaWYKfWAsZGlzdGFuY2VSR0JBX3ZlcnQ6YCNkZWZpbmUgRElTVEFOQ0UKdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uOwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+CnZvaWQgbWFpbigpIHsKCSNpbmNsdWRlIDx1dl92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD4KCSNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQCgkJI2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD4KCQkjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PgoJCSNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD4KCSNlbmRpZgoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PgoJI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CgkjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PgoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+Cgl2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6Owp9YCxkaXN0YW5jZVJHQkFfZnJhZzpgI2RlZmluZSBESVNUQU5DRQp1bmlmb3JtIHZlYzMgcmVmZXJlbmNlUG9zaXRpb247CnVuaWZvcm0gZmxvYXQgbmVhckRpc3RhbmNlOwp1bmlmb3JtIGZsb2F0IGZhckRpc3RhbmNlOwp2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxwYWNraW5nPgojaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD4Kdm9pZCBtYWluICgpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggMS4wICk7CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJZmxvYXQgZGlzdCA9IGxlbmd0aCggdldvcmxkUG9zaXRpb24gLSByZWZlcmVuY2VQb3NpdGlvbiApOwoJZGlzdCA9ICggZGlzdCAtIG5lYXJEaXN0YW5jZSApIC8gKCBmYXJEaXN0YW5jZSAtIG5lYXJEaXN0YW5jZSApOwoJZGlzdCA9IHNhdHVyYXRlKCBkaXN0ICk7CglnbF9GcmFnQ29sb3IgPSBwYWNrRGVwdGhUb1JHQkEoIGRpc3QgKTsKfWAsZXF1aXJlY3RfdmVydDpgdmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4Kdm9pZCBtYWluKCkgewoJdldvcmxkRGlyZWN0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTsKCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+Cn1gLGVxdWlyZWN0X2ZyYWc6YHVuaWZvcm0gc2FtcGxlcjJEIHRFcXVpcmVjdDsKdmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4Kdm9pZCBtYWluKCkgewoJdmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHZXb3JsZERpcmVjdGlvbiApOwoJdmVjMiBzYW1wbGVVViA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApOwoJZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KfWAsbGluZWRhc2hlZF92ZXJ0OmB1bmlmb3JtIGZsb2F0IHNjYWxlOwphdHRyaWJ1dGUgZmxvYXQgbGluZURpc3RhbmNlOwp2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJdkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlOwoJI2luY2x1ZGUgPHV2X3ZlcnRleD4KCSNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KCSNpbmNsdWRlIDxmb2dfdmVydGV4Pgp9YCxsaW5lZGFzaGVkX2ZyYWc6YHVuaWZvcm0gdmVjMyBkaWZmdXNlOwp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CnVuaWZvcm0gZmxvYXQgZGFzaFNpemU7CnVuaWZvcm0gZmxvYXQgdG90YWxTaXplOwp2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCWlmICggbW9kKCB2TGluZURpc3RhbmNlLCB0b3RhbFNpemUgKSA+IGRhc2hTaXplICkgewoJCWRpc2NhcmQ7Cgl9Cgl2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTsKCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD4KCSNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+CglvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjsKCSNpbmNsdWRlIDxvcGFxdWVfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KCSNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD4KfWAsbWVzaGJhc2ljX3ZlcnQ6YCNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxiYXRjaGluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+CnZvaWQgbWFpbigpIHsKCSNpbmNsdWRlIDx1dl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD4KCSNpZiBkZWZpbmVkICggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQgKCBVU0VfU0tJTk5JTkcgKQoJCSNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+CgkJI2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD4KCQkjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PgoJCSNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD4KCQkjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+CgkjZW5kaWYKCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KCSNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+CgkjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxmb2dfdmVydGV4Pgp9YCxtZXNoYmFzaWNfZnJhZzpgdW5pZm9ybSB2ZWMzIGRpZmZ1c2U7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2lmbmRlZiBGTEFUX1NIQURFRAoJdmFyeWluZyB2ZWMzIHZOb3JtYWw7CiNlbmRpZgojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Pgp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTsKCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+CglSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApOwoJI2lmZGVmIFVTRV9MSUdIVE1BUAoJCXZlYzQgbGlnaHRNYXBUZXhlbCA9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZMaWdodE1hcFV2ICk7CgkJcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGxpZ2h0TWFwVGV4ZWwucmdiICogbGlnaHRNYXBJbnRlbnNpdHkgKiBSRUNJUFJPQ0FMX1BJOwoJI2Vsc2UKCQlyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gdmVjMyggMS4wICk7CgkjZW5kaWYKCSNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD4KCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBkaWZmdXNlQ29sb3IucmdiOwoJdmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlOwoJI2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxvcGFxdWVfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KCSNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD4KCSNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+Cn1gLG1lc2hsYW1iZXJ0X3ZlcnQ6YCNkZWZpbmUgTEFNQkVSVAp2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPHV2X3ZlcnRleD4KCSNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KCXZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6OwoJI2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD4KCSNpbmNsdWRlIDxlbnZtYXBfdmVydGV4PgoJI2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8Zm9nX3ZlcnRleD4KfWAsbWVzaGxhbWJlcnRfZnJhZzpgI2RlZmluZSBMQU1CRVJUCnVuaWZvcm0gdmVjMyBkaWZmdXNlOwp1bmlmb3JtIHZlYzMgZW1pc3NpdmU7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPHBhY2tpbmc+CiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxic2Rmcz4KI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodHNfbGFtYmVydF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCVJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7Cgl2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlOwoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj4KCSNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz4KCSNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfbGFtYmVydF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfYmVnaW4+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD4KCSNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD4KCXZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7CgkjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD4KCSNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGZvZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD4KfWAsbWVzaG1hdGNhcF92ZXJ0OmAjZGVmaW5lIE1BVENBUAp2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPHV2X3ZlcnRleD4KCSNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KCSNpbmNsdWRlIDxmb2dfdmVydGV4PgoJdlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7Cn1gLG1lc2htYXRjYXBfZnJhZzpgI2RlZmluZSBNQVRDQVAKdW5pZm9ybSB2ZWMzIGRpZmZ1c2U7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKdW5pZm9ybSBzYW1wbGVyMkQgbWF0Y2FwOwp2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Pgp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTsKCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPgoJdmVjMyB2aWV3RGlyID0gbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7Cgl2ZWMzIHggPSBub3JtYWxpemUoIHZlYzMoIHZpZXdEaXIueiwgMC4wLCAtIHZpZXdEaXIueCApICk7Cgl2ZWMzIHkgPSBjcm9zcyggdmlld0RpciwgeCApOwoJdmVjMiB1diA9IHZlYzIoIGRvdCggeCwgbm9ybWFsICksIGRvdCggeSwgbm9ybWFsICkgKSAqIDAuNDk1ICsgMC41OwoJI2lmZGVmIFVTRV9NQVRDQVAKCQl2ZWM0IG1hdGNhcENvbG9yID0gdGV4dHVyZTJEKCBtYXRjYXAsIHV2ICk7CgkjZWxzZQoJCXZlYzQgbWF0Y2FwQ29sb3IgPSB2ZWM0KCB2ZWMzKCBtaXgoIDAuMiwgMC44LCB1di55ICkgKSwgMS4wICk7CgkjZW5kaWYKCXZlYzMgb3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2IgKiBtYXRjYXBDb2xvci5yZ2I7CgkjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Pgp9YCxtZXNobm9ybWFsX3ZlcnQ6YCNkZWZpbmUgTk9STUFMCiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUF9UQU5HRU5UU1BBQ0UgKQoJdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CiNlbmRpZgojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPHV2X3ZlcnRleD4KCSNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD4KCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PgojaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFICkKCXZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6OwojZW5kaWYKfWAsbWVzaG5vcm1hbF9mcmFnOmAjZGVmaW5lIE5PUk1BTAp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUF9UQU5HRU5UU1BBQ0UgKQoJdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CiNlbmRpZgojaW5jbHVkZSA8cGFja2luZz4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Pgp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDAuMCwgMC4wLCAwLjAsIG9wYWNpdHkgKTsKCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPgoJZ2xfRnJhZ0NvbG9yID0gdmVjNCggcGFja05vcm1hbFRvUkdCKCBub3JtYWwgKSwgZGlmZnVzZUNvbG9yLmEgKTsKCSNpZmRlZiBPUEFRVUUKCQlnbF9GcmFnQ29sb3IuYSA9IDEuMDsKCSNlbmRpZgp9YCxtZXNocGhvbmdfdmVydDpgI2RlZmluZSBQSE9ORwp2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPHV2X3ZlcnRleD4KCSNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KCXZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6OwoJI2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD4KCSNpbmNsdWRlIDxlbnZtYXBfdmVydGV4PgoJI2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8Zm9nX3ZlcnRleD4KfWAsbWVzaHBob25nX2ZyYWc6YCNkZWZpbmUgUEhPTkcKdW5pZm9ybSB2ZWMzIGRpZmZ1c2U7CnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTsKdW5pZm9ybSB2ZWMzIHNwZWN1bGFyOwp1bmlmb3JtIGZsb2F0IHNoaW5pbmVzczsKdW5pZm9ybSBmbG9hdCBvcGFjaXR5OwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8cGFja2luZz4KI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGJzZGZzPgojaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+CiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCVJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7Cgl2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlOwoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj4KCSNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz4KCSNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfcGhvbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPgoJI2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9tYXBzPgoJI2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+CgkjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+Cgl2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlOwoJI2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxvcGFxdWVfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KCSNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD4KCSNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+Cn1gLG1lc2hwaHlzaWNhbF92ZXJ0OmAjZGVmaW5lIFNUQU5EQVJECnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uOwojaWZkZWYgVVNFX1RSQU5TTUlTU0lPTgoJdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uOwojZW5kaWYKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPHV2X3ZlcnRleD4KCSNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KCXZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6OwoJI2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD4KCSNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PgoJI2luY2x1ZGUgPGZvZ192ZXJ0ZXg+CiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OCgl2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6OwojZW5kaWYKfWAsbWVzaHBoeXNpY2FsX2ZyYWc6YCNkZWZpbmUgU1RBTkRBUkQKI2lmZGVmIFBIWVNJQ0FMCgkjZGVmaW5lIElPUgoJI2RlZmluZSBVU0VfU1BFQ1VMQVIKI2VuZGlmCnVuaWZvcm0gdmVjMyBkaWZmdXNlOwp1bmlmb3JtIHZlYzMgZW1pc3NpdmU7CnVuaWZvcm0gZmxvYXQgcm91Z2huZXNzOwp1bmlmb3JtIGZsb2F0IG1ldGFsbmVzczsKdW5pZm9ybSBmbG9hdCBvcGFjaXR5OwojaWZkZWYgSU9SCgl1bmlmb3JtIGZsb2F0IGlvcjsKI2VuZGlmCiNpZmRlZiBVU0VfU1BFQ1VMQVIKCXVuaWZvcm0gZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHk7Cgl1bmlmb3JtIHZlYzMgc3BlY3VsYXJDb2xvcjsKCSNpZmRlZiBVU0VfU1BFQ1VMQVJfQ09MT1JNQVAKCQl1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhckNvbG9yTWFwOwoJI2VuZGlmCgkjaWZkZWYgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUAoJCXVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFySW50ZW5zaXR5TWFwOwoJI2VuZGlmCiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVAoJdW5pZm9ybSBmbG9hdCBjbGVhcmNvYXQ7Cgl1bmlmb3JtIGZsb2F0IGNsZWFyY29hdFJvdWdobmVzczsKI2VuZGlmCiNpZmRlZiBVU0VfRElTUEVSU0lPTgoJdW5pZm9ybSBmbG9hdCBkaXNwZXJzaW9uOwojZW5kaWYKI2lmZGVmIFVTRV9JUklERVNDRU5DRQoJdW5pZm9ybSBmbG9hdCBpcmlkZXNjZW5jZTsKCXVuaWZvcm0gZmxvYXQgaXJpZGVzY2VuY2VJT1I7Cgl1bmlmb3JtIGZsb2F0IGlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bTsKCXVuaWZvcm0gZmxvYXQgaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtOwojZW5kaWYKI2lmZGVmIFVTRV9TSEVFTgoJdW5pZm9ybSB2ZWMzIHNoZWVuQ29sb3I7Cgl1bmlmb3JtIGZsb2F0IHNoZWVuUm91Z2huZXNzOwoJI2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUAoJCXVuaWZvcm0gc2FtcGxlcjJEIHNoZWVuQ29sb3JNYXA7CgkjZW5kaWYKCSNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQCgkJdW5pZm9ybSBzYW1wbGVyMkQgc2hlZW5Sb3VnaG5lc3NNYXA7CgkjZW5kaWYKI2VuZGlmCiNpZmRlZiBVU0VfQU5JU09UUk9QWQoJdW5pZm9ybSB2ZWMyIGFuaXNvdHJvcHlWZWN0b3I7CgkjaWZkZWYgVVNFX0FOSVNPVFJPUFlNQVAKCQl1bmlmb3JtIHNhbXBsZXIyRCBhbmlzb3Ryb3B5TWFwOwoJI2VuZGlmCiNlbmRpZgp2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPHBhY2tpbmc+CiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGlyaWRlc2NlbmNlX2ZyYWdtZW50PgojaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW52bWFwX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsZWFyY29hdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8aXJpZGVzY2VuY2VfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCVJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7Cgl2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlOwoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHJvdWdobmVzc21hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPgoJI2luY2x1ZGUgPGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfYmVnaW4+CgkjaW5jbHVkZSA8Y2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9tYXBzPgoJI2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfYmVnaW4+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD4KCSNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD4KCXZlYzMgdG90YWxEaWZmdXNlID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTsKCXZlYzMgdG90YWxTcGVjdWxhciA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhcjsKCSNpbmNsdWRlIDx0cmFuc21pc3Npb25fZnJhZ21lbnQ+Cgl2ZWMzIG91dGdvaW5nTGlnaHQgPSB0b3RhbERpZmZ1c2UgKyB0b3RhbFNwZWN1bGFyICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlOwoJI2lmZGVmIFVTRV9TSEVFTgoJCWZsb2F0IHNoZWVuRW5lcmd5Q29tcCA9IDEuMCAtIDAuMTU3ICogbWF4MyggbWF0ZXJpYWwuc2hlZW5Db2xvciApOwoJCW91dGdvaW5nTGlnaHQgPSBvdXRnb2luZ0xpZ2h0ICogc2hlZW5FbmVyZ3lDb21wICsgc2hlZW5TcGVjdWxhckRpcmVjdCArIHNoZWVuU3BlY3VsYXJJbmRpcmVjdDsKCSNlbmRpZgoJI2lmZGVmIFVTRV9DTEVBUkNPQVQKCQlmbG9hdCBkb3ROVmNjID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGdlb21ldHJ5Vmlld0RpciApICk7CgkJdmVjMyBGY2MgPSBGX1NjaGxpY2soIG1hdGVyaWFsLmNsZWFyY29hdEYwLCBtYXRlcmlhbC5jbGVhcmNvYXRGOTAsIGRvdE5WY2MgKTsKCQlvdXRnb2luZ0xpZ2h0ID0gb3V0Z29pbmdMaWdodCAqICggMS4wIC0gbWF0ZXJpYWwuY2xlYXJjb2F0ICogRmNjICkgKyAoIGNsZWFyY29hdFNwZWN1bGFyRGlyZWN0ICsgY2xlYXJjb2F0U3BlY3VsYXJJbmRpcmVjdCApICogbWF0ZXJpYWwuY2xlYXJjb2F0OwoJI2VuZGlmCgkjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Pgp9YCxtZXNodG9vbl92ZXJ0OmAjZGVmaW5lIFRPT04KdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxiYXRjaGluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+CnZvaWQgbWFpbigpIHsKCSNpbmNsdWRlIDx1dl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PgoJI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PgoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+Cgl2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejsKCSNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+CgkjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxmb2dfdmVydGV4Pgp9YCxtZXNodG9vbl9mcmFnOmAjZGVmaW5lIFRPT04KdW5pZm9ybSB2ZWMzIGRpZmZ1c2U7CnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTsKdW5pZm9ybSBmbG9hdCBvcGFjaXR5OwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8cGFja2luZz4KI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Z3JhZGllbnRtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YnNkZnM+CiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bGlnaHRzX3Rvb25fcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCVJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7Cgl2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlOwoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj4KCSNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz4KCSNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfdG9vbl9mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfYmVnaW4+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD4KCSNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD4KCXZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7CgkjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Pgp9YCxwb2ludHNfdmVydDpgdW5pZm9ybSBmbG9hdCBzaXplOwp1bmlmb3JtIGZsb2F0IHNjYWxlOwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PgojaWZkZWYgVVNFX1BPSU5UU19VVgoJdmFyeWluZyB2ZWMyIHZVdjsKCXVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTsKI2VuZGlmCnZvaWQgbWFpbigpIHsKCSNpZmRlZiBVU0VfUE9JTlRTX1VWCgkJdlV2ID0gKCB1dlRyYW5zZm9ybSAqIHZlYzMoIHV2LCAxICkgKS54eTsKCSNlbmRpZgoJI2luY2x1ZGUgPGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJZ2xfUG9pbnRTaXplID0gc2l6ZTsKCSNpZmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OCgkJYm9vbCBpc1BlcnNwZWN0aXZlID0gaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApOwoJCWlmICggaXNQZXJzcGVjdGl2ZSApIGdsX1BvaW50U2l6ZSAqPSAoIHNjYWxlIC8gLSBtdlBvc2l0aW9uLnogKTsKCSNlbmRpZgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD4KCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PgoJI2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD4KCSNpbmNsdWRlIDxmb2dfdmVydGV4Pgp9YCxwb2ludHNfZnJhZzpgdW5pZm9ybSB2ZWMzIGRpZmZ1c2U7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD4Kdm9pZCBtYWluKCkgewoJdmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PgoJdmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bWFwX3BhcnRpY2xlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+CglvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjsKCSNpbmNsdWRlIDxvcGFxdWVfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KCSNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD4KfWAsc2hhZG93X3ZlcnQ6YCNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxiYXRjaGluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PgoJI2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8Zm9nX3ZlcnRleD4KfWAsc2hhZG93X2ZyYWc6YHVuaWZvcm0gdmVjMyBjb2xvcjsKdW5pZm9ybSBmbG9hdCBvcGFjaXR5OwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8cGFja2luZz4KI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YnNkZnM+CiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHNoYWRvd21hc2tfcGFyc19mcmFnbWVudD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJZ2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IsIG9wYWNpdHkgKiAoIDEuMCAtIGdldFNoYWRvd01hc2soKSApICk7CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KCSNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+Cn1gLHNwcml0ZV92ZXJ0OmB1bmlmb3JtIGZsb2F0IHJvdGF0aW9uOwp1bmlmb3JtIHZlYzIgY2VudGVyOwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPHV2X3ZlcnRleD4KCXZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeFsgMyBdOwoJdmVjMiBzY2FsZSA9IHZlYzIoIGxlbmd0aCggbW9kZWxNYXRyaXhbIDAgXS54eXogKSwgbGVuZ3RoKCBtb2RlbE1hdHJpeFsgMSBdLnh5eiApICk7CgkjaWZuZGVmIFVTRV9TSVpFQVRURU5VQVRJT04KCQlib29sIGlzUGVyc3BlY3RpdmUgPSBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICk7CgkJaWYgKCBpc1BlcnNwZWN0aXZlICkgc2NhbGUgKj0gLSBtdlBvc2l0aW9uLno7CgkjZW5kaWYKCXZlYzIgYWxpZ25lZFBvc2l0aW9uID0gKCBwb3NpdGlvbi54eSAtICggY2VudGVyIC0gdmVjMiggMC41ICkgKSApICogc2NhbGU7Cgl2ZWMyIHJvdGF0ZWRQb3NpdGlvbjsKCXJvdGF0ZWRQb3NpdGlvbi54ID0gY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsKCXJvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsKCW12UG9zaXRpb24ueHkgKz0gcm90YXRlZFBvc2l0aW9uOwoJZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjsKCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KCSNpbmNsdWRlIDxmb2dfdmVydGV4Pgp9YCxzcHJpdGVfZnJhZzpgdW5pZm9ybSB2ZWMzIGRpZmZ1c2U7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCXZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApOwoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJb3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7CgkjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50Pgp9YH0sdGU9e2NvbW1vbjp7ZGlmZnVzZTp7dmFsdWU6bmV3IFZlKDE2Nzc3MjE1KX0sb3BhY2l0eTp7dmFsdWU6MX0sbWFwOnt2YWx1ZTpudWxsfSxtYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyB3ZX0sYWxwaGFNYXA6e3ZhbHVlOm51bGx9LGFscGhhTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgd2V9LGFscGhhVGVzdDp7dmFsdWU6MH19LHNwZWN1bGFybWFwOntzcGVjdWxhck1hcDp7dmFsdWU6bnVsbH0sc3BlY3VsYXJNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyB3ZX19LGVudm1hcDp7ZW52TWFwOnt2YWx1ZTpudWxsfSxlbnZNYXBSb3RhdGlvbjp7dmFsdWU6bmV3IHdlfSxmbGlwRW52TWFwOnt2YWx1ZTotMX0scmVmbGVjdGl2aXR5Ont2YWx1ZToxfSxpb3I6e3ZhbHVlOjEuNX0scmVmcmFjdGlvblJhdGlvOnt2YWx1ZTouOTh9fSxhb21hcDp7YW9NYXA6e3ZhbHVlOm51bGx9LGFvTWFwSW50ZW5zaXR5Ont2YWx1ZToxfSxhb01hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IHdlfX0sbGlnaHRtYXA6e2xpZ2h0TWFwOnt2YWx1ZTpudWxsfSxsaWdodE1hcEludGVuc2l0eTp7dmFsdWU6MX0sbGlnaHRNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyB3ZX19LGJ1bXBtYXA6e2J1bXBNYXA6e3ZhbHVlOm51bGx9LGJ1bXBNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyB3ZX0sYnVtcFNjYWxlOnt2YWx1ZToxfX0sbm9ybWFsbWFwOntub3JtYWxNYXA6e3ZhbHVlOm51bGx9LG5vcm1hbE1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IHdlfSxub3JtYWxTY2FsZTp7dmFsdWU6bmV3IExlKDEsMSl9fSxkaXNwbGFjZW1lbnRtYXA6e2Rpc3BsYWNlbWVudE1hcDp7dmFsdWU6bnVsbH0sZGlzcGxhY2VtZW50TWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgd2V9LGRpc3BsYWNlbWVudFNjYWxlOnt2YWx1ZToxfSxkaXNwbGFjZW1lbnRCaWFzOnt2YWx1ZTowfX0sZW1pc3NpdmVtYXA6e2VtaXNzaXZlTWFwOnt2YWx1ZTpudWxsfSxlbWlzc2l2ZU1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IHdlfX0sbWV0YWxuZXNzbWFwOnttZXRhbG5lc3NNYXA6e3ZhbHVlOm51bGx9LG1ldGFsbmVzc01hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IHdlfX0scm91Z2huZXNzbWFwOntyb3VnaG5lc3NNYXA6e3ZhbHVlOm51bGx9LHJvdWdobmVzc01hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IHdlfX0sZ3JhZGllbnRtYXA6e2dyYWRpZW50TWFwOnt2YWx1ZTpudWxsfX0sZm9nOntmb2dEZW5zaXR5Ont2YWx1ZToyNWUtNX0sZm9nTmVhcjp7dmFsdWU6MX0sZm9nRmFyOnt2YWx1ZToyZTN9LGZvZ0NvbG9yOnt2YWx1ZTpuZXcgVmUoMTY3NzcyMTUpfX0sbGlnaHRzOnthbWJpZW50TGlnaHRDb2xvcjp7dmFsdWU6W119LGxpZ2h0UHJvYmU6e3ZhbHVlOltdfSxkaXJlY3Rpb25hbExpZ2h0czp7dmFsdWU6W10scHJvcGVydGllczp7ZGlyZWN0aW9uOnt9LGNvbG9yOnt9fX0sZGlyZWN0aW9uYWxMaWdodFNoYWRvd3M6e3ZhbHVlOltdLHByb3BlcnRpZXM6e3NoYWRvd0ludGVuc2l0eToxLHNoYWRvd0JpYXM6e30sc2hhZG93Tm9ybWFsQmlhczp7fSxzaGFkb3dSYWRpdXM6e30sc2hhZG93TWFwU2l6ZTp7fX19LGRpcmVjdGlvbmFsU2hhZG93TWFwOnt2YWx1ZTpbXX0sZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg6e3ZhbHVlOltdfSxzcG90TGlnaHRzOnt2YWx1ZTpbXSxwcm9wZXJ0aWVzOntjb2xvcjp7fSxwb3NpdGlvbjp7fSxkaXJlY3Rpb246e30sZGlzdGFuY2U6e30sY29uZUNvczp7fSxwZW51bWJyYUNvczp7fSxkZWNheTp7fX19LHNwb3RMaWdodFNoYWRvd3M6e3ZhbHVlOltdLHByb3BlcnRpZXM6e3NoYWRvd0ludGVuc2l0eToxLHNoYWRvd0JpYXM6e30sc2hhZG93Tm9ybWFsQmlhczp7fSxzaGFkb3dSYWRpdXM6e30sc2hhZG93TWFwU2l6ZTp7fX19LHNwb3RMaWdodE1hcDp7dmFsdWU6W119LHNwb3RTaGFkb3dNYXA6e3ZhbHVlOltdfSxzcG90TGlnaHRNYXRyaXg6e3ZhbHVlOltdfSxwb2ludExpZ2h0czp7dmFsdWU6W10scHJvcGVydGllczp7Y29sb3I6e30scG9zaXRpb246e30sZGVjYXk6e30sZGlzdGFuY2U6e319fSxwb2ludExpZ2h0U2hhZG93czp7dmFsdWU6W10scHJvcGVydGllczp7c2hhZG93SW50ZW5zaXR5OjEsc2hhZG93Qmlhczp7fSxzaGFkb3dOb3JtYWxCaWFzOnt9LHNoYWRvd1JhZGl1czp7fSxzaGFkb3dNYXBTaXplOnt9LHNoYWRvd0NhbWVyYU5lYXI6e30sc2hhZG93Q2FtZXJhRmFyOnt9fX0scG9pbnRTaGFkb3dNYXA6e3ZhbHVlOltdfSxwb2ludFNoYWRvd01hdHJpeDp7dmFsdWU6W119LGhlbWlzcGhlcmVMaWdodHM6e3ZhbHVlOltdLHByb3BlcnRpZXM6e2RpcmVjdGlvbjp7fSxza3lDb2xvcjp7fSxncm91bmRDb2xvcjp7fX19LHJlY3RBcmVhTGlnaHRzOnt2YWx1ZTpbXSxwcm9wZXJ0aWVzOntjb2xvcjp7fSxwb3NpdGlvbjp7fSx3aWR0aDp7fSxoZWlnaHQ6e319fSxsdGNfMTp7dmFsdWU6bnVsbH0sbHRjXzI6e3ZhbHVlOm51bGx9fSxwb2ludHM6e2RpZmZ1c2U6e3ZhbHVlOm5ldyBWZSgxNjc3NzIxNSl9LG9wYWNpdHk6e3ZhbHVlOjF9LHNpemU6e3ZhbHVlOjF9LHNjYWxlOnt2YWx1ZToxfSxtYXA6e3ZhbHVlOm51bGx9LGFscGhhTWFwOnt2YWx1ZTpudWxsfSxhbHBoYU1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IHdlfSxhbHBoYVRlc3Q6e3ZhbHVlOjB9LHV2VHJhbnNmb3JtOnt2YWx1ZTpuZXcgd2V9fSxzcHJpdGU6e2RpZmZ1c2U6e3ZhbHVlOm5ldyBWZSgxNjc3NzIxNSl9LG9wYWNpdHk6e3ZhbHVlOjF9LGNlbnRlcjp7dmFsdWU6bmV3IExlKC41LC41KX0scm90YXRpb246e3ZhbHVlOjB9LG1hcDp7dmFsdWU6bnVsbH0sbWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgd2V9LGFscGhhTWFwOnt2YWx1ZTpudWxsfSxhbHBoYU1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IHdlfSxhbHBoYVRlc3Q6e3ZhbHVlOjB9fX0senQ9e2Jhc2ljOnt1bmlmb3Jtczp4dChbdGUuY29tbW9uLHRlLnNwZWN1bGFybWFwLHRlLmVudm1hcCx0ZS5hb21hcCx0ZS5saWdodG1hcCx0ZS5mb2ddKSx2ZXJ0ZXhTaGFkZXI6UGUubWVzaGJhc2ljX3ZlcnQsZnJhZ21lbnRTaGFkZXI6UGUubWVzaGJhc2ljX2ZyYWd9LGxhbWJlcnQ6e3VuaWZvcm1zOnh0KFt0ZS5jb21tb24sdGUuc3BlY3VsYXJtYXAsdGUuZW52bWFwLHRlLmFvbWFwLHRlLmxpZ2h0bWFwLHRlLmVtaXNzaXZlbWFwLHRlLmJ1bXBtYXAsdGUubm9ybWFsbWFwLHRlLmRpc3BsYWNlbWVudG1hcCx0ZS5mb2csdGUubGlnaHRzLHtlbWlzc2l2ZTp7dmFsdWU6bmV3IFZlKDApfX1dKSx2ZXJ0ZXhTaGFkZXI6UGUubWVzaGxhbWJlcnRfdmVydCxmcmFnbWVudFNoYWRlcjpQZS5tZXNobGFtYmVydF9mcmFnfSxwaG9uZzp7dW5pZm9ybXM6eHQoW3RlLmNvbW1vbix0ZS5zcGVjdWxhcm1hcCx0ZS5lbnZtYXAsdGUuYW9tYXAsdGUubGlnaHRtYXAsdGUuZW1pc3NpdmVtYXAsdGUuYnVtcG1hcCx0ZS5ub3JtYWxtYXAsdGUuZGlzcGxhY2VtZW50bWFwLHRlLmZvZyx0ZS5saWdodHMse2VtaXNzaXZlOnt2YWx1ZTpuZXcgVmUoMCl9LHNwZWN1bGFyOnt2YWx1ZTpuZXcgVmUoMTExODQ4MSl9LHNoaW5pbmVzczp7dmFsdWU6MzB9fV0pLHZlcnRleFNoYWRlcjpQZS5tZXNocGhvbmdfdmVydCxmcmFnbWVudFNoYWRlcjpQZS5tZXNocGhvbmdfZnJhZ30sc3RhbmRhcmQ6e3VuaWZvcm1zOnh0KFt0ZS5jb21tb24sdGUuZW52bWFwLHRlLmFvbWFwLHRlLmxpZ2h0bWFwLHRlLmVtaXNzaXZlbWFwLHRlLmJ1bXBtYXAsdGUubm9ybWFsbWFwLHRlLmRpc3BsYWNlbWVudG1hcCx0ZS5yb3VnaG5lc3NtYXAsdGUubWV0YWxuZXNzbWFwLHRlLmZvZyx0ZS5saWdodHMse2VtaXNzaXZlOnt2YWx1ZTpuZXcgVmUoMCl9LHJvdWdobmVzczp7dmFsdWU6MX0sbWV0YWxuZXNzOnt2YWx1ZTowfSxlbnZNYXBJbnRlbnNpdHk6e3ZhbHVlOjF9fV0pLHZlcnRleFNoYWRlcjpQZS5tZXNocGh5c2ljYWxfdmVydCxmcmFnbWVudFNoYWRlcjpQZS5tZXNocGh5c2ljYWxfZnJhZ30sdG9vbjp7dW5pZm9ybXM6eHQoW3RlLmNvbW1vbix0ZS5hb21hcCx0ZS5saWdodG1hcCx0ZS5lbWlzc2l2ZW1hcCx0ZS5idW1wbWFwLHRlLm5vcm1hbG1hcCx0ZS5kaXNwbGFjZW1lbnRtYXAsdGUuZ3JhZGllbnRtYXAsdGUuZm9nLHRlLmxpZ2h0cyx7ZW1pc3NpdmU6e3ZhbHVlOm5ldyBWZSgwKX19XSksdmVydGV4U2hhZGVyOlBlLm1lc2h0b29uX3ZlcnQsZnJhZ21lbnRTaGFkZXI6UGUubWVzaHRvb25fZnJhZ30sbWF0Y2FwOnt1bmlmb3Jtczp4dChbdGUuY29tbW9uLHRlLmJ1bXBtYXAsdGUubm9ybWFsbWFwLHRlLmRpc3BsYWNlbWVudG1hcCx0ZS5mb2cse21hdGNhcDp7dmFsdWU6bnVsbH19XSksdmVydGV4U2hhZGVyOlBlLm1lc2htYXRjYXBfdmVydCxmcmFnbWVudFNoYWRlcjpQZS5tZXNobWF0Y2FwX2ZyYWd9LHBvaW50czp7dW5pZm9ybXM6eHQoW3RlLnBvaW50cyx0ZS5mb2ddKSx2ZXJ0ZXhTaGFkZXI6UGUucG9pbnRzX3ZlcnQsZnJhZ21lbnRTaGFkZXI6UGUucG9pbnRzX2ZyYWd9LGRhc2hlZDp7dW5pZm9ybXM6eHQoW3RlLmNvbW1vbix0ZS5mb2cse3NjYWxlOnt2YWx1ZToxfSxkYXNoU2l6ZTp7dmFsdWU6MX0sdG90YWxTaXplOnt2YWx1ZToyfX1dKSx2ZXJ0ZXhTaGFkZXI6UGUubGluZWRhc2hlZF92ZXJ0LGZyYWdtZW50U2hhZGVyOlBlLmxpbmVkYXNoZWRfZnJhZ30sZGVwdGg6e3VuaWZvcm1zOnh0KFt0ZS5jb21tb24sdGUuZGlzcGxhY2VtZW50bWFwXSksdmVydGV4U2hhZGVyOlBlLmRlcHRoX3ZlcnQsZnJhZ21lbnRTaGFkZXI6UGUuZGVwdGhfZnJhZ30sbm9ybWFsOnt1bmlmb3Jtczp4dChbdGUuY29tbW9uLHRlLmJ1bXBtYXAsdGUubm9ybWFsbWFwLHRlLmRpc3BsYWNlbWVudG1hcCx7b3BhY2l0eTp7dmFsdWU6MX19XSksdmVydGV4U2hhZGVyOlBlLm1lc2hub3JtYWxfdmVydCxmcmFnbWVudFNoYWRlcjpQZS5tZXNobm9ybWFsX2ZyYWd9LHNwcml0ZTp7dW5pZm9ybXM6eHQoW3RlLnNwcml0ZSx0ZS5mb2ddKSx2ZXJ0ZXhTaGFkZXI6UGUuc3ByaXRlX3ZlcnQsZnJhZ21lbnRTaGFkZXI6UGUuc3ByaXRlX2ZyYWd9LGJhY2tncm91bmQ6e3VuaWZvcm1zOnt1dlRyYW5zZm9ybTp7dmFsdWU6bmV3IHdlfSx0MkQ6e3ZhbHVlOm51bGx9LGJhY2tncm91bmRJbnRlbnNpdHk6e3ZhbHVlOjF9fSx2ZXJ0ZXhTaGFkZXI6UGUuYmFja2dyb3VuZF92ZXJ0LGZyYWdtZW50U2hhZGVyOlBlLmJhY2tncm91bmRfZnJhZ30sYmFja2dyb3VuZEN1YmU6e3VuaWZvcm1zOntlbnZNYXA6e3ZhbHVlOm51bGx9LGZsaXBFbnZNYXA6e3ZhbHVlOi0xfSxiYWNrZ3JvdW5kQmx1cnJpbmVzczp7dmFsdWU6MH0sYmFja2dyb3VuZEludGVuc2l0eTp7dmFsdWU6MX0sYmFja2dyb3VuZFJvdGF0aW9uOnt2YWx1ZTpuZXcgd2V9fSx2ZXJ0ZXhTaGFkZXI6UGUuYmFja2dyb3VuZEN1YmVfdmVydCxmcmFnbWVudFNoYWRlcjpQZS5iYWNrZ3JvdW5kQ3ViZV9mcmFnfSxjdWJlOnt1bmlmb3Jtczp7dEN1YmU6e3ZhbHVlOm51bGx9LHRGbGlwOnt2YWx1ZTotMX0sb3BhY2l0eTp7dmFsdWU6MX19LHZlcnRleFNoYWRlcjpQZS5jdWJlX3ZlcnQsZnJhZ21lbnRTaGFkZXI6UGUuY3ViZV9mcmFnfSxlcXVpcmVjdDp7dW5pZm9ybXM6e3RFcXVpcmVjdDp7dmFsdWU6bnVsbH19LHZlcnRleFNoYWRlcjpQZS5lcXVpcmVjdF92ZXJ0LGZyYWdtZW50U2hhZGVyOlBlLmVxdWlyZWN0X2ZyYWd9LGRpc3RhbmNlUkdCQTp7dW5pZm9ybXM6eHQoW3RlLmNvbW1vbix0ZS5kaXNwbGFjZW1lbnRtYXAse3JlZmVyZW5jZVBvc2l0aW9uOnt2YWx1ZTpuZXcgQn0sbmVhckRpc3RhbmNlOnt2YWx1ZToxfSxmYXJEaXN0YW5jZTp7dmFsdWU6MWUzfX1dKSx2ZXJ0ZXhTaGFkZXI6UGUuZGlzdGFuY2VSR0JBX3ZlcnQsZnJhZ21lbnRTaGFkZXI6UGUuZGlzdGFuY2VSR0JBX2ZyYWd9LHNoYWRvdzp7dW5pZm9ybXM6eHQoW3RlLmxpZ2h0cyx0ZS5mb2cse2NvbG9yOnt2YWx1ZTpuZXcgVmUoMCl9LG9wYWNpdHk6e3ZhbHVlOjF9fV0pLHZlcnRleFNoYWRlcjpQZS5zaGFkb3dfdmVydCxmcmFnbWVudFNoYWRlcjpQZS5zaGFkb3dfZnJhZ319O3p0LnBoeXNpY2FsPXt1bmlmb3Jtczp4dChbenQuc3RhbmRhcmQudW5pZm9ybXMse2NsZWFyY29hdDp7dmFsdWU6MH0sY2xlYXJjb2F0TWFwOnt2YWx1ZTpudWxsfSxjbGVhcmNvYXRNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyB3ZX0sY2xlYXJjb2F0Tm9ybWFsTWFwOnt2YWx1ZTpudWxsfSxjbGVhcmNvYXROb3JtYWxNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyB3ZX0sY2xlYXJjb2F0Tm9ybWFsU2NhbGU6e3ZhbHVlOm5ldyBMZSgxLDEpfSxjbGVhcmNvYXRSb3VnaG5lc3M6e3ZhbHVlOjB9LGNsZWFyY29hdFJvdWdobmVzc01hcDp7dmFsdWU6bnVsbH0sY2xlYXJjb2F0Um91Z2huZXNzTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgd2V9LGRpc3BlcnNpb246e3ZhbHVlOjB9LGlyaWRlc2NlbmNlOnt2YWx1ZTowfSxpcmlkZXNjZW5jZU1hcDp7dmFsdWU6bnVsbH0saXJpZGVzY2VuY2VNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyB3ZX0saXJpZGVzY2VuY2VJT1I6e3ZhbHVlOjEuM30saXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtOnt2YWx1ZToxMDB9LGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTp7dmFsdWU6NDAwfSxpcmlkZXNjZW5jZVRoaWNrbmVzc01hcDp7dmFsdWU6bnVsbH0saXJpZGVzY2VuY2VUaGlja25lc3NNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyB3ZX0sc2hlZW46e3ZhbHVlOjB9LHNoZWVuQ29sb3I6e3ZhbHVlOm5ldyBWZSgwKX0sc2hlZW5Db2xvck1hcDp7dmFsdWU6bnVsbH0sc2hlZW5Db2xvck1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IHdlfSxzaGVlblJvdWdobmVzczp7dmFsdWU6MX0sc2hlZW5Sb3VnaG5lc3NNYXA6e3ZhbHVlOm51bGx9LHNoZWVuUm91Z2huZXNzTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcgd2V9LHRyYW5zbWlzc2lvbjp7dmFsdWU6MH0sdHJhbnNtaXNzaW9uTWFwOnt2YWx1ZTpudWxsfSx0cmFuc21pc3Npb25NYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyB3ZX0sdHJhbnNtaXNzaW9uU2FtcGxlclNpemU6e3ZhbHVlOm5ldyBMZX0sdHJhbnNtaXNzaW9uU2FtcGxlck1hcDp7dmFsdWU6bnVsbH0sdGhpY2tuZXNzOnt2YWx1ZTowfSx0aGlja25lc3NNYXA6e3ZhbHVlOm51bGx9LHRoaWNrbmVzc01hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IHdlfSxhdHRlbnVhdGlvbkRpc3RhbmNlOnt2YWx1ZTowfSxhdHRlbnVhdGlvbkNvbG9yOnt2YWx1ZTpuZXcgVmUoMCl9LHNwZWN1bGFyQ29sb3I6e3ZhbHVlOm5ldyBWZSgxLDEsMSl9LHNwZWN1bGFyQ29sb3JNYXA6e3ZhbHVlOm51bGx9LHNwZWN1bGFyQ29sb3JNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyB3ZX0sc3BlY3VsYXJJbnRlbnNpdHk6e3ZhbHVlOjF9LHNwZWN1bGFySW50ZW5zaXR5TWFwOnt2YWx1ZTpudWxsfSxzcGVjdWxhckludGVuc2l0eU1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IHdlfSxhbmlzb3Ryb3B5VmVjdG9yOnt2YWx1ZTpuZXcgTGV9LGFuaXNvdHJvcHlNYXA6e3ZhbHVlOm51bGx9LGFuaXNvdHJvcHlNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyB3ZX19XSksdmVydGV4U2hhZGVyOlBlLm1lc2hwaHlzaWNhbF92ZXJ0LGZyYWdtZW50U2hhZGVyOlBlLm1lc2hwaHlzaWNhbF9mcmFnfTtjb25zdCB5aT17cjowLGI6MCxnOjB9LHBuPW5ldyBYdCxObD1uZXcgcnQ7ZnVuY3Rpb24gT2woaSxlLHQsbixyLHMsYSl7Y29uc3Qgbz1uZXcgVmUoMCk7bGV0IGw9cz09PSEwPzA6MSxjLHUsaD1udWxsLGY9MCxwPW51bGw7ZnVuY3Rpb24gXyhBKXtsZXQgVD1BLmlzU2NlbmU9PT0hMD9BLmJhY2tncm91bmQ6bnVsbDtyZXR1cm4gVCYmVC5pc1RleHR1cmUmJihUPShBLmJhY2tncm91bmRCbHVycmluZXNzPjA/dDplKS5nZXQoVCkpLFR9ZnVuY3Rpb24geChBKXtsZXQgVD0hMTtjb25zdCBNPV8oQSk7TT09PW51bGw/ZChvLGwpOk0mJk0uaXNDb2xvciYmKGQoTSwxKSxUPSEwKTtjb25zdCBGPWkueHIuZ2V0RW52aXJvbm1lbnRCbGVuZE1vZGUoKTtGPT09ImFkZGl0aXZlIj9uLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoMCwwLDAsMSxhKTpGPT09ImFscGhhLWJsZW5kIiYmbi5idWZmZXJzLmNvbG9yLnNldENsZWFyKDAsMCwwLDAsYSksKGkuYXV0b0NsZWFyfHxUKSYmKG4uYnVmZmVycy5kZXB0aC5zZXRUZXN0KCEwKSxuLmJ1ZmZlcnMuZGVwdGguc2V0TWFzayghMCksbi5idWZmZXJzLmNvbG9yLnNldE1hc2soITApLGkuY2xlYXIoaS5hdXRvQ2xlYXJDb2xvcixpLmF1dG9DbGVhckRlcHRoLGkuYXV0b0NsZWFyU3RlbmNpbCkpfWZ1bmN0aW9uIG0oQSxUKXtjb25zdCBNPV8oVCk7TSYmKE0uaXNDdWJlVGV4dHVyZXx8TS5tYXBwaW5nPT09MzA2KT8odT09PXZvaWQgMCYmKHU9bmV3IHN0KG5ldyBRbigxLDEsMSksbmV3IGh0KHtuYW1lOiJCYWNrZ3JvdW5kQ3ViZU1hdGVyaWFsIix1bmlmb3JtczpGbih6dC5iYWNrZ3JvdW5kQ3ViZS51bmlmb3JtcyksdmVydGV4U2hhZGVyOnp0LmJhY2tncm91bmRDdWJlLnZlcnRleFNoYWRlcixmcmFnbWVudFNoYWRlcjp6dC5iYWNrZ3JvdW5kQ3ViZS5mcmFnbWVudFNoYWRlcixzaWRlOjEsZGVwdGhUZXN0OiExLGRlcHRoV3JpdGU6ITEsZm9nOiExfSkpLHUuZ2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKCJub3JtYWwiKSx1Lmdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSgidXYiKSx1Lm9uQmVmb3JlUmVuZGVyPWZ1bmN0aW9uKEYsYix3KXt0aGlzLm1hdHJpeFdvcmxkLmNvcHlQb3NpdGlvbih3Lm1hdHJpeFdvcmxkKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHUubWF0ZXJpYWwsImVudk1hcCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLmVudk1hcC52YWx1ZX19KSxyLnVwZGF0ZSh1KSkscG4uY29weShULmJhY2tncm91bmRSb3RhdGlvbikscG4ueCo9LTEscG4ueSo9LTEscG4ueio9LTEsTS5pc0N1YmVUZXh0dXJlJiZNLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT09PSExJiYocG4ueSo9LTEscG4ueio9LTEpLHUubWF0ZXJpYWwudW5pZm9ybXMuZW52TWFwLnZhbHVlPU0sdS5tYXRlcmlhbC51bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlPU0uaXNDdWJlVGV4dHVyZSYmTS5pc1JlbmRlclRhcmdldFRleHR1cmU9PT0hMT8tMToxLHUubWF0ZXJpYWwudW5pZm9ybXMuYmFja2dyb3VuZEJsdXJyaW5lc3MudmFsdWU9VC5iYWNrZ3JvdW5kQmx1cnJpbmVzcyx1Lm1hdGVyaWFsLnVuaWZvcm1zLmJhY2tncm91bmRJbnRlbnNpdHkudmFsdWU9VC5iYWNrZ3JvdW5kSW50ZW5zaXR5LHUubWF0ZXJpYWwudW5pZm9ybXMuYmFja2dyb3VuZFJvdGF0aW9uLnZhbHVlLnNldEZyb21NYXRyaXg0KE5sLm1ha2VSb3RhdGlvbkZyb21FdWxlcihwbikpLHUubWF0ZXJpYWwudG9uZU1hcHBlZD1CZS5nZXRUcmFuc2ZlcihNLmNvbG9yU3BhY2UpIT09cWUsKGghPT1NfHxmIT09TS52ZXJzaW9ufHxwIT09aS50b25lTWFwcGluZykmJih1Lm1hdGVyaWFsLm5lZWRzVXBkYXRlPSEwLGg9TSxmPU0udmVyc2lvbixwPWkudG9uZU1hcHBpbmcpLHUubGF5ZXJzLmVuYWJsZUFsbCgpLEEudW5zaGlmdCh1LHUuZ2VvbWV0cnksdS5tYXRlcmlhbCwwLDAsbnVsbCkpOk0mJk0uaXNUZXh0dXJlJiYoYz09PXZvaWQgMCYmKGM9bmV3IHN0KG5ldyB0dCgyLDIpLG5ldyBodCh7bmFtZToiQmFja2dyb3VuZE1hdGVyaWFsIix1bmlmb3JtczpGbih6dC5iYWNrZ3JvdW5kLnVuaWZvcm1zKSx2ZXJ0ZXhTaGFkZXI6enQuYmFja2dyb3VuZC52ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXI6enQuYmFja2dyb3VuZC5mcmFnbWVudFNoYWRlcixzaWRlOjAsZGVwdGhUZXN0OiExLGRlcHRoV3JpdGU6ITEsZm9nOiExfSkpLGMuZ2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKCJub3JtYWwiKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYy5tYXRlcmlhbCwibWFwIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMudDJELnZhbHVlfX0pLHIudXBkYXRlKGMpKSxjLm1hdGVyaWFsLnVuaWZvcm1zLnQyRC52YWx1ZT1NLGMubWF0ZXJpYWwudW5pZm9ybXMuYmFja2dyb3VuZEludGVuc2l0eS52YWx1ZT1ULmJhY2tncm91bmRJbnRlbnNpdHksYy5tYXRlcmlhbC50b25lTWFwcGVkPUJlLmdldFRyYW5zZmVyKE0uY29sb3JTcGFjZSkhPT1xZSxNLm1hdHJpeEF1dG9VcGRhdGU9PT0hMCYmTS51cGRhdGVNYXRyaXgoKSxjLm1hdGVyaWFsLnVuaWZvcm1zLnV2VHJhbnNmb3JtLnZhbHVlLmNvcHkoTS5tYXRyaXgpLChoIT09TXx8ZiE9PU0udmVyc2lvbnx8cCE9PWkudG9uZU1hcHBpbmcpJiYoYy5tYXRlcmlhbC5uZWVkc1VwZGF0ZT0hMCxoPU0sZj1NLnZlcnNpb24scD1pLnRvbmVNYXBwaW5nKSxjLmxheWVycy5lbmFibGVBbGwoKSxBLnVuc2hpZnQoYyxjLmdlb21ldHJ5LGMubWF0ZXJpYWwsMCwwLG51bGwpKX1mdW5jdGlvbiBkKEEsVCl7QS5nZXRSR0IoeWksWXIoaSkpLG4uYnVmZmVycy5jb2xvci5zZXRDbGVhcih5aS5yLHlpLmcseWkuYixULGEpfXJldHVybntnZXRDbGVhckNvbG9yOmZ1bmN0aW9uKCl7cmV0dXJuIG99LHNldENsZWFyQ29sb3I6ZnVuY3Rpb24oQSxUPTEpe28uc2V0KEEpLGw9VCxkKG8sbCl9LGdldENsZWFyQWxwaGE6ZnVuY3Rpb24oKXtyZXR1cm4gbH0sc2V0Q2xlYXJBbHBoYTpmdW5jdGlvbihBKXtsPUEsZChvLGwpfSxyZW5kZXI6eCxhZGRUb1JlbmRlckxpc3Q6bX19ZnVuY3Rpb24gQmwoaSxlKXtjb25zdCB0PWkuZ2V0UGFyYW1ldGVyKGkuTUFYX1ZFUlRFWF9BVFRSSUJTKSxuPXt9LHI9ZihudWxsKTtsZXQgcz1yLGE9ITE7ZnVuY3Rpb24gbyhTLFIscSx6LFcpe2xldCBLPSExO2NvbnN0IFY9aCh6LHEsUik7cyE9PVYmJihzPVYsYyhzLm9iamVjdCkpLEs9cChTLHoscSxXKSxLJiZfKFMseixxLFcpLFchPT1udWxsJiZlLnVwZGF0ZShXLGkuRUxFTUVOVF9BUlJBWV9CVUZGRVIpLChLfHxhKSYmKGE9ITEsTShTLFIscSx6KSxXIT09bnVsbCYmaS5iaW5kQnVmZmVyKGkuRUxFTUVOVF9BUlJBWV9CVUZGRVIsZS5nZXQoVykuYnVmZmVyKSl9ZnVuY3Rpb24gbCgpe3JldHVybiBpLmNyZWF0ZVZlcnRleEFycmF5KCl9ZnVuY3Rpb24gYyhTKXtyZXR1cm4gaS5iaW5kVmVydGV4QXJyYXkoUyl9ZnVuY3Rpb24gdShTKXtyZXR1cm4gaS5kZWxldGVWZXJ0ZXhBcnJheShTKX1mdW5jdGlvbiBoKFMsUixxKXtjb25zdCB6PXEud2lyZWZyYW1lPT09ITA7bGV0IFc9bltTLmlkXTtXPT09dm9pZCAwJiYoVz17fSxuW1MuaWRdPVcpO2xldCBLPVdbUi5pZF07Sz09PXZvaWQgMCYmKEs9e30sV1tSLmlkXT1LKTtsZXQgVj1LW3pdO3JldHVybiBWPT09dm9pZCAwJiYoVj1mKGwoKSksS1t6XT1WKSxWfWZ1bmN0aW9uIGYoUyl7Y29uc3QgUj1bXSxxPVtdLHo9W107Zm9yKGxldCBXPTA7Vzx0O1crKylSW1ddPTAscVtXXT0wLHpbV109MDtyZXR1cm57Z2VvbWV0cnk6bnVsbCxwcm9ncmFtOm51bGwsd2lyZWZyYW1lOiExLG5ld0F0dHJpYnV0ZXM6UixlbmFibGVkQXR0cmlidXRlczpxLGF0dHJpYnV0ZURpdmlzb3JzOnosb2JqZWN0OlMsYXR0cmlidXRlczp7fSxpbmRleDpudWxsfX1mdW5jdGlvbiBwKFMsUixxLHope2NvbnN0IFc9cy5hdHRyaWJ1dGVzLEs9Ui5hdHRyaWJ1dGVzO2xldCBWPTA7Y29uc3QgUT1xLmdldEF0dHJpYnV0ZXMoKTtmb3IoY29uc3QgSCBpbiBRKWlmKFFbSF0ubG9jYXRpb24+PTApe2NvbnN0IGNlPVdbSF07bGV0IHhlPUtbSF07aWYoeGU9PT12b2lkIDAmJihIPT09Imluc3RhbmNlTWF0cml4IiYmUy5pbnN0YW5jZU1hdHJpeCYmKHhlPVMuaW5zdGFuY2VNYXRyaXgpLEg9PT0iaW5zdGFuY2VDb2xvciImJlMuaW5zdGFuY2VDb2xvciYmKHhlPVMuaW5zdGFuY2VDb2xvcikpLGNlPT09dm9pZCAwfHxjZS5hdHRyaWJ1dGUhPT14ZXx8eGUmJmNlLmRhdGEhPT14ZS5kYXRhKXJldHVybiEwO1YrK31yZXR1cm4gcy5hdHRyaWJ1dGVzTnVtIT09Vnx8cy5pbmRleCE9PXp9ZnVuY3Rpb24gXyhTLFIscSx6KXtjb25zdCBXPXt9LEs9Ui5hdHRyaWJ1dGVzO2xldCBWPTA7Y29uc3QgUT1xLmdldEF0dHJpYnV0ZXMoKTtmb3IoY29uc3QgSCBpbiBRKWlmKFFbSF0ubG9jYXRpb24+PTApe2xldCBjZT1LW0hdO2NlPT09dm9pZCAwJiYoSD09PSJpbnN0YW5jZU1hdHJpeCImJlMuaW5zdGFuY2VNYXRyaXgmJihjZT1TLmluc3RhbmNlTWF0cml4KSxIPT09Imluc3RhbmNlQ29sb3IiJiZTLmluc3RhbmNlQ29sb3ImJihjZT1TLmluc3RhbmNlQ29sb3IpKTtjb25zdCB4ZT17fTt4ZS5hdHRyaWJ1dGU9Y2UsY2UmJmNlLmRhdGEmJih4ZS5kYXRhPWNlLmRhdGEpLFdbSF09eGUsVisrfXMuYXR0cmlidXRlcz1XLHMuYXR0cmlidXRlc051bT1WLHMuaW5kZXg9en1mdW5jdGlvbiB4KCl7Y29uc3QgUz1zLm5ld0F0dHJpYnV0ZXM7Zm9yKGxldCBSPTAscT1TLmxlbmd0aDtSPHE7UisrKVNbUl09MH1mdW5jdGlvbiBtKFMpe2QoUywwKX1mdW5jdGlvbiBkKFMsUil7Y29uc3QgcT1zLm5ld0F0dHJpYnV0ZXMsej1zLmVuYWJsZWRBdHRyaWJ1dGVzLFc9cy5hdHRyaWJ1dGVEaXZpc29ycztxW1NdPTEseltTXT09PTAmJihpLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KFMpLHpbU109MSksV1tTXSE9PVImJihpLnZlcnRleEF0dHJpYkRpdmlzb3IoUyxSKSxXW1NdPVIpfWZ1bmN0aW9uIEEoKXtjb25zdCBTPXMubmV3QXR0cmlidXRlcyxSPXMuZW5hYmxlZEF0dHJpYnV0ZXM7Zm9yKGxldCBxPTAsej1SLmxlbmd0aDtxPHo7cSsrKVJbcV0hPT1TW3FdJiYoaS5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkocSksUltxXT0wKX1mdW5jdGlvbiBUKFMsUixxLHosVyxLLFYpe1Y9PT0hMD9pLnZlcnRleEF0dHJpYklQb2ludGVyKFMsUixxLFcsSyk6aS52ZXJ0ZXhBdHRyaWJQb2ludGVyKFMsUixxLHosVyxLKX1mdW5jdGlvbiBNKFMsUixxLHope3goKTtjb25zdCBXPXouYXR0cmlidXRlcyxLPXEuZ2V0QXR0cmlidXRlcygpLFY9Ui5kZWZhdWx0QXR0cmlidXRlVmFsdWVzO2Zvcihjb25zdCBRIGluIEspe2NvbnN0IEg9S1tRXTtpZihILmxvY2F0aW9uPj0wKXtsZXQgaWU9V1tRXTtpZihpZT09PXZvaWQgMCYmKFE9PT0iaW5zdGFuY2VNYXRyaXgiJiZTLmluc3RhbmNlTWF0cml4JiYoaWU9Uy5pbnN0YW5jZU1hdHJpeCksUT09PSJpbnN0YW5jZUNvbG9yIiYmUy5pbnN0YW5jZUNvbG9yJiYoaWU9Uy5pbnN0YW5jZUNvbG9yKSksaWUhPT12b2lkIDApe2NvbnN0IGNlPWllLm5vcm1hbGl6ZWQseGU9aWUuaXRlbVNpemUsVWU9ZS5nZXQoaWUpO2lmKFVlPT09dm9pZCAwKWNvbnRpbnVlO2NvbnN0IFllPVVlLmJ1ZmZlcixYPVVlLnR5cGUsZWU9VWUuYnl0ZXNQZXJFbGVtZW50LF9lPVg9PT1pLklOVHx8WD09PWkuVU5TSUdORURfSU5UfHxpZS5ncHVUeXBlPT09MTAxMztpZihpZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKXtjb25zdCByZT1pZS5kYXRhLHllPXJlLnN0cmlkZSxiZT1pZS5vZmZzZXQ7aWYocmUuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcil7Zm9yKGxldCBGZT0wO0ZlPEgubG9jYXRpb25TaXplO0ZlKyspZChILmxvY2F0aW9uK0ZlLHJlLm1lc2hQZXJBdHRyaWJ1dGUpO1MuaXNJbnN0YW5jZWRNZXNoIT09ITAmJnouX21heEluc3RhbmNlQ291bnQ9PT12b2lkIDAmJih6Ll9tYXhJbnN0YW5jZUNvdW50PXJlLm1lc2hQZXJBdHRyaWJ1dGUqcmUuY291bnQpfWVsc2UgZm9yKGxldCBGZT0wO0ZlPEgubG9jYXRpb25TaXplO0ZlKyspbShILmxvY2F0aW9uK0ZlKTtpLmJpbmRCdWZmZXIoaS5BUlJBWV9CVUZGRVIsWWUpO2ZvcihsZXQgRmU9MDtGZTxILmxvY2F0aW9uU2l6ZTtGZSsrKVQoSC5sb2NhdGlvbitGZSx4ZS9ILmxvY2F0aW9uU2l6ZSxYLGNlLHllKmVlLChiZSt4ZS9ILmxvY2F0aW9uU2l6ZSpGZSkqZWUsX2UpfWVsc2V7aWYoaWUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUpe2ZvcihsZXQgcmU9MDtyZTxILmxvY2F0aW9uU2l6ZTtyZSsrKWQoSC5sb2NhdGlvbityZSxpZS5tZXNoUGVyQXR0cmlidXRlKTtTLmlzSW5zdGFuY2VkTWVzaCE9PSEwJiZ6Ll9tYXhJbnN0YW5jZUNvdW50PT09dm9pZCAwJiYoei5fbWF4SW5zdGFuY2VDb3VudD1pZS5tZXNoUGVyQXR0cmlidXRlKmllLmNvdW50KX1lbHNlIGZvcihsZXQgcmU9MDtyZTxILmxvY2F0aW9uU2l6ZTtyZSsrKW0oSC5sb2NhdGlvbityZSk7aS5iaW5kQnVmZmVyKGkuQVJSQVlfQlVGRkVSLFllKTtmb3IobGV0IHJlPTA7cmU8SC5sb2NhdGlvblNpemU7cmUrKylUKEgubG9jYXRpb24rcmUseGUvSC5sb2NhdGlvblNpemUsWCxjZSx4ZSplZSx4ZS9ILmxvY2F0aW9uU2l6ZSpyZSplZSxfZSl9fWVsc2UgaWYoViE9PXZvaWQgMCl7Y29uc3QgY2U9VltRXTtpZihjZSE9PXZvaWQgMClzd2l0Y2goY2UubGVuZ3RoKXtjYXNlIDI6aS52ZXJ0ZXhBdHRyaWIyZnYoSC5sb2NhdGlvbixjZSk7YnJlYWs7Y2FzZSAzOmkudmVydGV4QXR0cmliM2Z2KEgubG9jYXRpb24sY2UpO2JyZWFrO2Nhc2UgNDppLnZlcnRleEF0dHJpYjRmdihILmxvY2F0aW9uLGNlKTticmVhaztkZWZhdWx0OmkudmVydGV4QXR0cmliMWZ2KEgubG9jYXRpb24sY2UpfX19fUEoKX1mdW5jdGlvbiBGKCl7VSgpO2Zvcihjb25zdCBTIGluIG4pe2NvbnN0IFI9bltTXTtmb3IoY29uc3QgcSBpbiBSKXtjb25zdCB6PVJbcV07Zm9yKGNvbnN0IFcgaW4geil1KHpbV10ub2JqZWN0KSxkZWxldGUgeltXXTtkZWxldGUgUltxXX1kZWxldGUgbltTXX19ZnVuY3Rpb24gYihTKXtpZihuW1MuaWRdPT09dm9pZCAwKXJldHVybjtjb25zdCBSPW5bUy5pZF07Zm9yKGNvbnN0IHEgaW4gUil7Y29uc3Qgej1SW3FdO2Zvcihjb25zdCBXIGluIHopdSh6W1ddLm9iamVjdCksZGVsZXRlIHpbV107ZGVsZXRlIFJbcV19ZGVsZXRlIG5bUy5pZF19ZnVuY3Rpb24gdyhTKXtmb3IoY29uc3QgUiBpbiBuKXtjb25zdCBxPW5bUl07aWYocVtTLmlkXT09PXZvaWQgMCljb250aW51ZTtjb25zdCB6PXFbUy5pZF07Zm9yKGNvbnN0IFcgaW4geil1KHpbV10ub2JqZWN0KSxkZWxldGUgeltXXTtkZWxldGUgcVtTLmlkXX19ZnVuY3Rpb24gVSgpe0UoKSxhPSEwLHMhPT1yJiYocz1yLGMocy5vYmplY3QpKX1mdW5jdGlvbiBFKCl7ci5nZW9tZXRyeT1udWxsLHIucHJvZ3JhbT1udWxsLHIud2lyZWZyYW1lPSExfXJldHVybntzZXR1cDpvLHJlc2V0OlUscmVzZXREZWZhdWx0U3RhdGU6RSxkaXNwb3NlOkYscmVsZWFzZVN0YXRlc09mR2VvbWV0cnk6YixyZWxlYXNlU3RhdGVzT2ZQcm9ncmFtOncsaW5pdEF0dHJpYnV0ZXM6eCxlbmFibGVBdHRyaWJ1dGU6bSxkaXNhYmxlVW51c2VkQXR0cmlidXRlczpBfX1mdW5jdGlvbiB6bChpLGUsdCl7bGV0IG47ZnVuY3Rpb24gcihjKXtuPWN9ZnVuY3Rpb24gcyhjLHUpe2kuZHJhd0FycmF5cyhuLGMsdSksdC51cGRhdGUodSxuLDEpfWZ1bmN0aW9uIGEoYyx1LGgpe2ghPT0wJiYoaS5kcmF3QXJyYXlzSW5zdGFuY2VkKG4sYyx1LGgpLHQudXBkYXRlKHUsbixoKSl9ZnVuY3Rpb24gbyhjLHUsaCl7aWYoaD09PTApcmV0dXJuO2UuZ2V0KCJXRUJHTF9tdWx0aV9kcmF3IikubXVsdGlEcmF3QXJyYXlzV0VCR0wobixjLDAsdSwwLGgpO2xldCBwPTA7Zm9yKGxldCBfPTA7XzxoO18rKylwKz11W19dO3QudXBkYXRlKHAsbiwxKX1mdW5jdGlvbiBsKGMsdSxoLGYpe2lmKGg9PT0wKXJldHVybjtjb25zdCBwPWUuZ2V0KCJXRUJHTF9tdWx0aV9kcmF3Iik7aWYocD09PW51bGwpZm9yKGxldCBfPTA7XzxjLmxlbmd0aDtfKyspYShjW19dLHVbX10sZltfXSk7ZWxzZXtwLm11bHRpRHJhd0FycmF5c0luc3RhbmNlZFdFQkdMKG4sYywwLHUsMCxmLDAsaCk7bGV0IF89MDtmb3IobGV0IHg9MDt4PGg7eCsrKV8rPXVbeF0qZlt4XTt0LnVwZGF0ZShfLG4sMSl9fXRoaXMuc2V0TW9kZT1yLHRoaXMucmVuZGVyPXMsdGhpcy5yZW5kZXJJbnN0YW5jZXM9YSx0aGlzLnJlbmRlck11bHRpRHJhdz1vLHRoaXMucmVuZGVyTXVsdGlEcmF3SW5zdGFuY2VzPWx9ZnVuY3Rpb24gR2woaSxlLHQsbil7bGV0IHI7ZnVuY3Rpb24gcygpe2lmKHIhPT12b2lkIDApcmV0dXJuIHI7aWYoZS5oYXMoIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyIpPT09ITApe2NvbnN0IHc9ZS5nZXQoIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyIpO3I9aS5nZXRQYXJhbWV0ZXIody5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQpfWVsc2Ugcj0wO3JldHVybiByfWZ1bmN0aW9uIGEodyl7cmV0dXJuISh3IT09MTAyMyYmbi5jb252ZXJ0KHcpIT09aS5nZXRQYXJhbWV0ZXIoaS5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX0ZPUk1BVCkpfWZ1bmN0aW9uIG8odyl7Y29uc3QgVT13PT09MTAxNiYmKGUuaGFzKCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQiKXx8ZS5oYXMoIkVYVF9jb2xvcl9idWZmZXJfZmxvYXQiKSk7cmV0dXJuISh3IT09MTAwOSYmbi5jb252ZXJ0KHcpIT09aS5nZXRQYXJhbWV0ZXIoaS5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX1RZUEUpJiZ3IT09MTAxNSYmIVUpfWZ1bmN0aW9uIGwodyl7aWYodz09PSJoaWdocCIpe2lmKGkuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGkuVkVSVEVYX1NIQURFUixpLkhJR0hfRkxPQVQpLnByZWNpc2lvbj4wJiZpLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChpLkZSQUdNRU5UX1NIQURFUixpLkhJR0hfRkxPQVQpLnByZWNpc2lvbj4wKXJldHVybiJoaWdocCI7dz0ibWVkaXVtcCJ9cmV0dXJuIHc9PT0ibWVkaXVtcCImJmkuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGkuVkVSVEVYX1NIQURFUixpLk1FRElVTV9GTE9BVCkucHJlY2lzaW9uPjAmJmkuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGkuRlJBR01FTlRfU0hBREVSLGkuTUVESVVNX0ZMT0FUKS5wcmVjaXNpb24+MD8ibWVkaXVtcCI6Imxvd3AifWxldCBjPXQucHJlY2lzaW9uIT09dm9pZCAwP3QucHJlY2lzaW9uOiJoaWdocCI7Y29uc3QgdT1sKGMpO3UhPT1jJiYoY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiIsYywibm90IHN1cHBvcnRlZCwgdXNpbmciLHUsImluc3RlYWQuIiksYz11KTtjb25zdCBoPXQubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcj09PSEwLGY9dC5yZXZlcnNlRGVwdGhCdWZmZXI9PT0hMCYmZS5oYXMoIkVYVF9jbGlwX2NvbnRyb2wiKSxwPWkuZ2V0UGFyYW1ldGVyKGkuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLF89aS5nZXRQYXJhbWV0ZXIoaS5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLHg9aS5nZXRQYXJhbWV0ZXIoaS5NQVhfVEVYVFVSRV9TSVpFKSxtPWkuZ2V0UGFyYW1ldGVyKGkuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSksZD1pLmdldFBhcmFtZXRlcihpLk1BWF9WRVJURVhfQVRUUklCUyksQT1pLmdldFBhcmFtZXRlcihpLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTKSxUPWkuZ2V0UGFyYW1ldGVyKGkuTUFYX1ZBUllJTkdfVkVDVE9SUyksTT1pLmdldFBhcmFtZXRlcihpLk1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMpLEY9Xz4wLGI9aS5nZXRQYXJhbWV0ZXIoaS5NQVhfU0FNUExFUyk7cmV0dXJue2lzV2ViR0wyOiEwLGdldE1heEFuaXNvdHJvcHk6cyxnZXRNYXhQcmVjaXNpb246bCx0ZXh0dXJlRm9ybWF0UmVhZGFibGU6YSx0ZXh0dXJlVHlwZVJlYWRhYmxlOm8scHJlY2lzaW9uOmMsbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjpoLHJldmVyc2VEZXB0aEJ1ZmZlcjpmLG1heFRleHR1cmVzOnAsbWF4VmVydGV4VGV4dHVyZXM6XyxtYXhUZXh0dXJlU2l6ZTp4LG1heEN1YmVtYXBTaXplOm0sbWF4QXR0cmlidXRlczpkLG1heFZlcnRleFVuaWZvcm1zOkEsbWF4VmFyeWluZ3M6VCxtYXhGcmFnbWVudFVuaWZvcm1zOk0sdmVydGV4VGV4dHVyZXM6RixtYXhTYW1wbGVzOmJ9fWZ1bmN0aW9uIEhsKGkpe2NvbnN0IGU9dGhpcztsZXQgdD1udWxsLG49MCxyPSExLHM9ITE7Y29uc3QgYT1uZXcgZG4sbz1uZXcgd2UsbD17dmFsdWU6bnVsbCxuZWVkc1VwZGF0ZTohMX07dGhpcy51bmlmb3JtPWwsdGhpcy5udW1QbGFuZXM9MCx0aGlzLm51bUludGVyc2VjdGlvbj0wLHRoaXMuaW5pdD1mdW5jdGlvbihoLGYpe2NvbnN0IHA9aC5sZW5ndGghPT0wfHxmfHxuIT09MHx8cjtyZXR1cm4gcj1mLG49aC5sZW5ndGgscH0sdGhpcy5iZWdpblNoYWRvd3M9ZnVuY3Rpb24oKXtzPSEwLHUobnVsbCl9LHRoaXMuZW5kU2hhZG93cz1mdW5jdGlvbigpe3M9ITF9LHRoaXMuc2V0R2xvYmFsU3RhdGU9ZnVuY3Rpb24oaCxmKXt0PXUoaCxmLDApfSx0aGlzLnNldFN0YXRlPWZ1bmN0aW9uKGgsZixwKXtjb25zdCBfPWguY2xpcHBpbmdQbGFuZXMseD1oLmNsaXBJbnRlcnNlY3Rpb24sbT1oLmNsaXBTaGFkb3dzLGQ9aS5nZXQoaCk7aWYoIXJ8fF89PT1udWxsfHxfLmxlbmd0aD09PTB8fHMmJiFtKXM/dShudWxsKTpjKCk7ZWxzZXtjb25zdCBBPXM/MDpuLFQ9QSo0O2xldCBNPWQuY2xpcHBpbmdTdGF0ZXx8bnVsbDtsLnZhbHVlPU0sTT11KF8sZixULHApO2ZvcihsZXQgRj0wO0YhPT1UOysrRilNW0ZdPXRbRl07ZC5jbGlwcGluZ1N0YXRlPU0sdGhpcy5udW1JbnRlcnNlY3Rpb249eD90aGlzLm51bVBsYW5lczowLHRoaXMubnVtUGxhbmVzKz1BfX07ZnVuY3Rpb24gYygpe2wudmFsdWUhPT10JiYobC52YWx1ZT10LGwubmVlZHNVcGRhdGU9bj4wKSxlLm51bVBsYW5lcz1uLGUubnVtSW50ZXJzZWN0aW9uPTB9ZnVuY3Rpb24gdShoLGYscCxfKXtjb25zdCB4PWghPT1udWxsP2gubGVuZ3RoOjA7bGV0IG09bnVsbDtpZih4IT09MCl7aWYobT1sLnZhbHVlLF8hPT0hMHx8bT09PW51bGwpe2NvbnN0IGQ9cCt4KjQsQT1mLm1hdHJpeFdvcmxkSW52ZXJzZTtvLmdldE5vcm1hbE1hdHJpeChBKSwobT09PW51bGx8fG0ubGVuZ3RoPGQpJiYobT1uZXcgRmxvYXQzMkFycmF5KGQpKTtmb3IobGV0IFQ9MCxNPXA7VCE9PXg7KytULE0rPTQpYS5jb3B5KGhbVF0pLmFwcGx5TWF0cml4NChBLG8pLGEubm9ybWFsLnRvQXJyYXkobSxNKSxtW00rM109YS5jb25zdGFudH1sLnZhbHVlPW0sbC5uZWVkc1VwZGF0ZT0hMH1yZXR1cm4gZS5udW1QbGFuZXM9eCxlLm51bUludGVyc2VjdGlvbj0wLG19fWZ1bmN0aW9uIFZsKGkpe2xldCBlPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIHQoYSxvKXtyZXR1cm4gbz09PTMwMz9hLm1hcHBpbmc9MzAxOm89PT0zMDQmJihhLm1hcHBpbmc9MzAyKSxhfWZ1bmN0aW9uIG4oYSl7aWYoYSYmYS5pc1RleHR1cmUpe2NvbnN0IG89YS5tYXBwaW5nO2lmKG89PT0zMDN8fG89PT0zMDQpaWYoZS5oYXMoYSkpe2NvbnN0IGw9ZS5nZXQoYSkudGV4dHVyZTtyZXR1cm4gdChsLGEubWFwcGluZyl9ZWxzZXtjb25zdCBsPWEuaW1hZ2U7aWYobCYmbC5oZWlnaHQ+MCl7Y29uc3QgYz1uZXcgTGEobC5oZWlnaHQpO3JldHVybiBjLmZyb21FcXVpcmVjdGFuZ3VsYXJUZXh0dXJlKGksYSksZS5zZXQoYSxjKSxhLmFkZEV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLHIpLHQoYy50ZXh0dXJlLGEubWFwcGluZyl9ZWxzZSByZXR1cm4gbnVsbH19cmV0dXJuIGF9ZnVuY3Rpb24gcihhKXtjb25zdCBvPWEudGFyZ2V0O28ucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIscik7Y29uc3QgbD1lLmdldChvKTtsIT09dm9pZCAwJiYoZS5kZWxldGUobyksbC5kaXNwb3NlKCkpfWZ1bmN0aW9uIHMoKXtlPW5ldyBXZWFrTWFwfXJldHVybntnZXQ6bixkaXNwb3NlOnN9fWNsYXNzIHJyIGV4dGVuZHMgJHJ7Y29uc3RydWN0b3IoZT0tMSx0PTEsbj0xLHI9LTEscz0uMSxhPTJlMyl7c3VwZXIoKSx0aGlzLmlzT3J0aG9ncmFwaGljQ2FtZXJhPSEwLHRoaXMudHlwZT0iT3J0aG9ncmFwaGljQ2FtZXJhIix0aGlzLnpvb209MSx0aGlzLnZpZXc9bnVsbCx0aGlzLmxlZnQ9ZSx0aGlzLnJpZ2h0PXQsdGhpcy50b3A9bix0aGlzLmJvdHRvbT1yLHRoaXMubmVhcj1zLHRoaXMuZmFyPWEsdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9Y29weShlLHQpe3JldHVybiBzdXBlci5jb3B5KGUsdCksdGhpcy5sZWZ0PWUubGVmdCx0aGlzLnJpZ2h0PWUucmlnaHQsdGhpcy50b3A9ZS50b3AsdGhpcy5ib3R0b209ZS5ib3R0b20sdGhpcy5uZWFyPWUubmVhcix0aGlzLmZhcj1lLmZhcix0aGlzLnpvb209ZS56b29tLHRoaXMudmlldz1lLnZpZXc9PT1udWxsP251bGw6T2JqZWN0LmFzc2lnbih7fSxlLnZpZXcpLHRoaXN9c2V0Vmlld09mZnNldChlLHQsbixyLHMsYSl7dGhpcy52aWV3PT09bnVsbCYmKHRoaXMudmlldz17ZW5hYmxlZDohMCxmdWxsV2lkdGg6MSxmdWxsSGVpZ2h0OjEsb2Zmc2V0WDowLG9mZnNldFk6MCx3aWR0aDoxLGhlaWdodDoxfSksdGhpcy52aWV3LmVuYWJsZWQ9ITAsdGhpcy52aWV3LmZ1bGxXaWR0aD1lLHRoaXMudmlldy5mdWxsSGVpZ2h0PXQsdGhpcy52aWV3Lm9mZnNldFg9bix0aGlzLnZpZXcub2Zmc2V0WT1yLHRoaXMudmlldy53aWR0aD1zLHRoaXMudmlldy5oZWlnaHQ9YSx0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX1jbGVhclZpZXdPZmZzZXQoKXt0aGlzLnZpZXchPT1udWxsJiYodGhpcy52aWV3LmVuYWJsZWQ9ITEpLHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfXVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKXtjb25zdCBlPSh0aGlzLnJpZ2h0LXRoaXMubGVmdCkvKDIqdGhpcy56b29tKSx0PSh0aGlzLnRvcC10aGlzLmJvdHRvbSkvKDIqdGhpcy56b29tKSxuPSh0aGlzLnJpZ2h0K3RoaXMubGVmdCkvMixyPSh0aGlzLnRvcCt0aGlzLmJvdHRvbSkvMjtsZXQgcz1uLWUsYT1uK2Usbz1yK3QsbD1yLXQ7aWYodGhpcy52aWV3IT09bnVsbCYmdGhpcy52aWV3LmVuYWJsZWQpe2NvbnN0IGM9KHRoaXMucmlnaHQtdGhpcy5sZWZ0KS90aGlzLnZpZXcuZnVsbFdpZHRoL3RoaXMuem9vbSx1PSh0aGlzLnRvcC10aGlzLmJvdHRvbSkvdGhpcy52aWV3LmZ1bGxIZWlnaHQvdGhpcy56b29tO3MrPWMqdGhpcy52aWV3Lm9mZnNldFgsYT1zK2MqdGhpcy52aWV3LndpZHRoLG8tPXUqdGhpcy52aWV3Lm9mZnNldFksbD1vLXUqdGhpcy52aWV3LmhlaWdodH10aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZU9ydGhvZ3JhcGhpYyhzLGEsbyxsLHRoaXMubmVhcix0aGlzLmZhcix0aGlzLmNvb3JkaW5hdGVTeXN0ZW0pLHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSh0aGlzLnByb2plY3Rpb25NYXRyaXgpLmludmVydCgpfXRvSlNPTihlKXtjb25zdCB0PXN1cGVyLnRvSlNPTihlKTtyZXR1cm4gdC5vYmplY3Quem9vbT10aGlzLnpvb20sdC5vYmplY3QubGVmdD10aGlzLmxlZnQsdC5vYmplY3QucmlnaHQ9dGhpcy5yaWdodCx0Lm9iamVjdC50b3A9dGhpcy50b3AsdC5vYmplY3QuYm90dG9tPXRoaXMuYm90dG9tLHQub2JqZWN0Lm5lYXI9dGhpcy5uZWFyLHQub2JqZWN0LmZhcj10aGlzLmZhcix0aGlzLnZpZXchPT1udWxsJiYodC5vYmplY3Qudmlldz1PYmplY3QuYXNzaWduKHt9LHRoaXMudmlldykpLHR9fWNvbnN0IE9uPTQsZXM9Wy4xMjUsLjIxNSwuMzUsLjQ0NiwuNTI2LC41ODJdLG1uPTIwLHNyPW5ldyBycix0cz1uZXcgVmU7bGV0IGFyPW51bGwsb3I9MCxscj0wLGNyPSExO2NvbnN0IF9uPSgxK01hdGguc3FydCg1KSkvMixCbj0xL19uLG5zPVtuZXcgQigtX24sQm4sMCksbmV3IEIoX24sQm4sMCksbmV3IEIoLUJuLDAsX24pLG5ldyBCKEJuLDAsX24pLG5ldyBCKDAsX24sLUJuKSxuZXcgQigwLF9uLEJuKSxuZXcgQigtMSwxLC0xKSxuZXcgQigxLDEsLTEpLG5ldyBCKC0xLDEsMSksbmV3IEIoMSwxLDEpXTtjbGFzcyBpc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9yZW5kZXJlcj1lLHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0PW51bGwsdGhpcy5fbG9kTWF4PTAsdGhpcy5fY3ViZVNpemU9MCx0aGlzLl9sb2RQbGFuZXM9W10sdGhpcy5fc2l6ZUxvZHM9W10sdGhpcy5fc2lnbWFzPVtdLHRoaXMuX2JsdXJNYXRlcmlhbD1udWxsLHRoaXMuX2N1YmVtYXBNYXRlcmlhbD1udWxsLHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWw9bnVsbCx0aGlzLl9jb21waWxlTWF0ZXJpYWwodGhpcy5fYmx1ck1hdGVyaWFsKX1mcm9tU2NlbmUoZSx0PTAsbj0uMSxyPTEwMCl7YXI9dGhpcy5fcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCksb3I9dGhpcy5fcmVuZGVyZXIuZ2V0QWN0aXZlQ3ViZUZhY2UoKSxscj10aGlzLl9yZW5kZXJlci5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpLGNyPXRoaXMuX3JlbmRlcmVyLnhyLmVuYWJsZWQsdGhpcy5fcmVuZGVyZXIueHIuZW5hYmxlZD0hMSx0aGlzLl9zZXRTaXplKDI1Nik7Y29uc3Qgcz10aGlzLl9hbGxvY2F0ZVRhcmdldHMoKTtyZXR1cm4gcy5kZXB0aEJ1ZmZlcj0hMCx0aGlzLl9zY2VuZVRvQ3ViZVVWKGUsbixyLHMpLHQ+MCYmdGhpcy5fYmx1cihzLDAsMCx0KSx0aGlzLl9hcHBseVBNUkVNKHMpLHRoaXMuX2NsZWFudXAocyksc31mcm9tRXF1aXJlY3Rhbmd1bGFyKGUsdD1udWxsKXtyZXR1cm4gdGhpcy5fZnJvbVRleHR1cmUoZSx0KX1mcm9tQ3ViZW1hcChlLHQ9bnVsbCl7cmV0dXJuIHRoaXMuX2Zyb21UZXh0dXJlKGUsdCl9Y29tcGlsZUN1YmVtYXBTaGFkZXIoKXt0aGlzLl9jdWJlbWFwTWF0ZXJpYWw9PT1udWxsJiYodGhpcy5fY3ViZW1hcE1hdGVyaWFsPWFzKCksdGhpcy5fY29tcGlsZU1hdGVyaWFsKHRoaXMuX2N1YmVtYXBNYXRlcmlhbCkpfWNvbXBpbGVFcXVpcmVjdGFuZ3VsYXJTaGFkZXIoKXt0aGlzLl9lcXVpcmVjdE1hdGVyaWFsPT09bnVsbCYmKHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWw9c3MoKSx0aGlzLl9jb21waWxlTWF0ZXJpYWwodGhpcy5fZXF1aXJlY3RNYXRlcmlhbCkpfWRpc3Bvc2UoKXt0aGlzLl9kaXNwb3NlKCksdGhpcy5fY3ViZW1hcE1hdGVyaWFsIT09bnVsbCYmdGhpcy5fY3ViZW1hcE1hdGVyaWFsLmRpc3Bvc2UoKSx0aGlzLl9lcXVpcmVjdE1hdGVyaWFsIT09bnVsbCYmdGhpcy5fZXF1aXJlY3RNYXRlcmlhbC5kaXNwb3NlKCl9X3NldFNpemUoZSl7dGhpcy5fbG9kTWF4PU1hdGguZmxvb3IoTWF0aC5sb2cyKGUpKSx0aGlzLl9jdWJlU2l6ZT1NYXRoLnBvdygyLHRoaXMuX2xvZE1heCl9X2Rpc3Bvc2UoKXt0aGlzLl9ibHVyTWF0ZXJpYWwhPT1udWxsJiZ0aGlzLl9ibHVyTWF0ZXJpYWwuZGlzcG9zZSgpLHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0IT09bnVsbCYmdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQuZGlzcG9zZSgpO2ZvcihsZXQgZT0wO2U8dGhpcy5fbG9kUGxhbmVzLmxlbmd0aDtlKyspdGhpcy5fbG9kUGxhbmVzW2VdLmRpc3Bvc2UoKX1fY2xlYW51cChlKXt0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoYXIsb3IsbHIpLHRoaXMuX3JlbmRlcmVyLnhyLmVuYWJsZWQ9Y3IsZS5zY2lzc29yVGVzdD0hMSxUaShlLDAsMCxlLndpZHRoLGUuaGVpZ2h0KX1fZnJvbVRleHR1cmUoZSx0KXtlLm1hcHBpbmc9PT0zMDF8fGUubWFwcGluZz09PTMwMj90aGlzLl9zZXRTaXplKGUuaW1hZ2UubGVuZ3RoPT09MD8xNjplLmltYWdlWzBdLndpZHRofHxlLmltYWdlWzBdLmltYWdlLndpZHRoKTp0aGlzLl9zZXRTaXplKGUuaW1hZ2Uud2lkdGgvNCksYXI9dGhpcy5fcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCksb3I9dGhpcy5fcmVuZGVyZXIuZ2V0QWN0aXZlQ3ViZUZhY2UoKSxscj10aGlzLl9yZW5kZXJlci5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpLGNyPXRoaXMuX3JlbmRlcmVyLnhyLmVuYWJsZWQsdGhpcy5fcmVuZGVyZXIueHIuZW5hYmxlZD0hMTtjb25zdCBuPXR8fHRoaXMuX2FsbG9jYXRlVGFyZ2V0cygpO3JldHVybiB0aGlzLl90ZXh0dXJlVG9DdWJlVVYoZSxuKSx0aGlzLl9hcHBseVBNUkVNKG4pLHRoaXMuX2NsZWFudXAobiksbn1fYWxsb2NhdGVUYXJnZXRzKCl7Y29uc3QgZT0zKk1hdGgubWF4KHRoaXMuX2N1YmVTaXplLDExMiksdD00KnRoaXMuX2N1YmVTaXplLG49e21hZ0ZpbHRlcjoxMDA2LG1pbkZpbHRlcjoxMDA2LGdlbmVyYXRlTWlwbWFwczohMSx0eXBlOjEwMTYsZm9ybWF0OjEwMjMsY29sb3JTcGFjZTp4bixkZXB0aEJ1ZmZlcjohMX0scj1ycyhlLHQsbik7aWYodGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQ9PT1udWxsfHx0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldC53aWR0aCE9PWV8fHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0LmhlaWdodCE9PXQpe3RoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0IT09bnVsbCYmdGhpcy5fZGlzcG9zZSgpLHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0PXJzKGUsdCxuKTtjb25zdHtfbG9kTWF4OnN9PXRoaXM7KHtzaXplTG9kczp0aGlzLl9zaXplTG9kcyxsb2RQbGFuZXM6dGhpcy5fbG9kUGxhbmVzLHNpZ21hczp0aGlzLl9zaWdtYXN9PWtsKHMpKSx0aGlzLl9ibHVyTWF0ZXJpYWw9V2wocyxlLHQpfXJldHVybiByfV9jb21waWxlTWF0ZXJpYWwoZSl7Y29uc3QgdD1uZXcgc3QodGhpcy5fbG9kUGxhbmVzWzBdLGUpO3RoaXMuX3JlbmRlcmVyLmNvbXBpbGUodCxzcil9X3NjZW5lVG9DdWJlVVYoZSx0LG4scil7Y29uc3Qgbz1uZXcgTnQoOTAsMSx0LG4pLGw9WzEsLTEsMSwxLDEsMV0sYz1bMSwxLDEsLTEsLTEsLTFdLHU9dGhpcy5fcmVuZGVyZXIsaD11LmF1dG9DbGVhcixmPXUudG9uZU1hcHBpbmc7dS5nZXRDbGVhckNvbG9yKHRzKSx1LnRvbmVNYXBwaW5nPTAsdS5hdXRvQ2xlYXI9ITE7Y29uc3QgcD1uZXcgam4oe25hbWU6IlBNUkVNLkJhY2tncm91bmQiLHNpZGU6MSxkZXB0aFdyaXRlOiExLGRlcHRoVGVzdDohMX0pLF89bmV3IHN0KG5ldyBRbixwKTtsZXQgeD0hMTtjb25zdCBtPWUuYmFja2dyb3VuZDttP20uaXNDb2xvciYmKHAuY29sb3IuY29weShtKSxlLmJhY2tncm91bmQ9bnVsbCx4PSEwKToocC5jb2xvci5jb3B5KHRzKSx4PSEwKTtmb3IobGV0IGQ9MDtkPDY7ZCsrKXtjb25zdCBBPWQlMztBPT09MD8oby51cC5zZXQoMCxsW2RdLDApLG8ubG9va0F0KGNbZF0sMCwwKSk6QT09PTE/KG8udXAuc2V0KDAsMCxsW2RdKSxvLmxvb2tBdCgwLGNbZF0sMCkpOihvLnVwLnNldCgwLGxbZF0sMCksby5sb29rQXQoMCwwLGNbZF0pKTtjb25zdCBUPXRoaXMuX2N1YmVTaXplO1RpKHIsQSpULGQ+Mj9UOjAsVCxUKSx1LnNldFJlbmRlclRhcmdldChyKSx4JiZ1LnJlbmRlcihfLG8pLHUucmVuZGVyKGUsbyl9Xy5nZW9tZXRyeS5kaXNwb3NlKCksXy5tYXRlcmlhbC5kaXNwb3NlKCksdS50b25lTWFwcGluZz1mLHUuYXV0b0NsZWFyPWgsZS5iYWNrZ3JvdW5kPW19X3RleHR1cmVUb0N1YmVVVihlLHQpe2NvbnN0IG49dGhpcy5fcmVuZGVyZXIscj1lLm1hcHBpbmc9PT0zMDF8fGUubWFwcGluZz09PTMwMjtyPyh0aGlzLl9jdWJlbWFwTWF0ZXJpYWw9PT1udWxsJiYodGhpcy5fY3ViZW1hcE1hdGVyaWFsPWFzKCkpLHRoaXMuX2N1YmVtYXBNYXRlcmlhbC51bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlPWUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlPT09ITE/LTE6MSk6dGhpcy5fZXF1aXJlY3RNYXRlcmlhbD09PW51bGwmJih0aGlzLl9lcXVpcmVjdE1hdGVyaWFsPXNzKCkpO2NvbnN0IHM9cj90aGlzLl9jdWJlbWFwTWF0ZXJpYWw6dGhpcy5fZXF1aXJlY3RNYXRlcmlhbCxhPW5ldyBzdCh0aGlzLl9sb2RQbGFuZXNbMF0scyksbz1zLnVuaWZvcm1zO28uZW52TWFwLnZhbHVlPWU7Y29uc3QgbD10aGlzLl9jdWJlU2l6ZTtUaSh0LDAsMCwzKmwsMipsKSxuLnNldFJlbmRlclRhcmdldCh0KSxuLnJlbmRlcihhLHNyKX1fYXBwbHlQTVJFTShlKXtjb25zdCB0PXRoaXMuX3JlbmRlcmVyLG49dC5hdXRvQ2xlYXI7dC5hdXRvQ2xlYXI9ITE7Y29uc3Qgcj10aGlzLl9sb2RQbGFuZXMubGVuZ3RoO2ZvcihsZXQgcz0xO3M8cjtzKyspe2NvbnN0IGE9TWF0aC5zcXJ0KHRoaXMuX3NpZ21hc1tzXSp0aGlzLl9zaWdtYXNbc10tdGhpcy5fc2lnbWFzW3MtMV0qdGhpcy5fc2lnbWFzW3MtMV0pLG89bnNbKHItcy0xKSVucy5sZW5ndGhdO3RoaXMuX2JsdXIoZSxzLTEscyxhLG8pfXQuYXV0b0NsZWFyPW59X2JsdXIoZSx0LG4scixzKXtjb25zdCBhPXRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0O3RoaXMuX2hhbGZCbHVyKGUsYSx0LG4sciwibGF0aXR1ZGluYWwiLHMpLHRoaXMuX2hhbGZCbHVyKGEsZSxuLG4sciwibG9uZ2l0dWRpbmFsIixzKX1faGFsZkJsdXIoZSx0LG4scixzLGEsbyl7Y29uc3QgbD10aGlzLl9yZW5kZXJlcixjPXRoaXMuX2JsdXJNYXRlcmlhbDthIT09ImxhdGl0dWRpbmFsIiYmYSE9PSJsb25naXR1ZGluYWwiJiZjb25zb2xlLmVycm9yKCJibHVyIGRpcmVjdGlvbiBtdXN0IGJlIGVpdGhlciBsYXRpdHVkaW5hbCBvciBsb25naXR1ZGluYWwhIik7Y29uc3QgdT0zLGg9bmV3IHN0KHRoaXMuX2xvZFBsYW5lc1tyXSxjKSxmPWMudW5pZm9ybXMscD10aGlzLl9zaXplTG9kc1tuXS0xLF89aXNGaW5pdGUocyk/TWF0aC5QSS8oMipwKToyKk1hdGguUEkvKDIqbW4tMSkseD1zL18sbT1pc0Zpbml0ZShzKT8xK01hdGguZmxvb3IodSp4KTptbjttPm1uJiZjb25zb2xlLndhcm4oYHNpZ21hUmFkaWFucywgJHtzfSwgaXMgdG9vIGxhcmdlIGFuZCB3aWxsIGNsaXAsIGFzIGl0IHJlcXVlc3RlZCAke219IHNhbXBsZXMgd2hlbiB0aGUgbWF4aW11bSBpcyBzZXQgdG8gJHttbn1gKTtjb25zdCBkPVtdO2xldCBBPTA7Zm9yKGxldCB3PTA7dzxtbjsrK3cpe2NvbnN0IFU9dy94LEU9TWF0aC5leHAoLVUqVS8yKTtkLnB1c2goRSksdz09PTA/QSs9RTp3PG0mJihBKz0yKkUpfWZvcihsZXQgdz0wO3c8ZC5sZW5ndGg7dysrKWRbd109ZFt3XS9BO2YuZW52TWFwLnZhbHVlPWUudGV4dHVyZSxmLnNhbXBsZXMudmFsdWU9bSxmLndlaWdodHMudmFsdWU9ZCxmLmxhdGl0dWRpbmFsLnZhbHVlPWE9PT0ibGF0aXR1ZGluYWwiLG8mJihmLnBvbGVBeGlzLnZhbHVlPW8pO2NvbnN0e19sb2RNYXg6VH09dGhpcztmLmRUaGV0YS52YWx1ZT1fLGYubWlwSW50LnZhbHVlPVQtbjtjb25zdCBNPXRoaXMuX3NpemVMb2RzW3JdLEY9MypNKihyPlQtT24/ci1UK09uOjApLGI9NCoodGhpcy5fY3ViZVNpemUtTSk7VGkodCxGLGIsMypNLDIqTSksbC5zZXRSZW5kZXJUYXJnZXQodCksbC5yZW5kZXIoaCxzcil9fWZ1bmN0aW9uIGtsKGkpe2NvbnN0IGU9W10sdD1bXSxuPVtdO2xldCByPWk7Y29uc3Qgcz1pLU9uKzErZXMubGVuZ3RoO2ZvcihsZXQgYT0wO2E8czthKyspe2NvbnN0IG89TWF0aC5wb3coMixyKTt0LnB1c2gobyk7bGV0IGw9MS9vO2E+aS1Pbj9sPWVzW2EtaStPbi0xXTphPT09MCYmKGw9MCksbi5wdXNoKGwpO2NvbnN0IGM9MS8oby0yKSx1PS1jLGg9MStjLGY9W3UsdSxoLHUsaCxoLHUsdSxoLGgsdSxoXSxwPTYsXz02LHg9MyxtPTIsZD0xLEE9bmV3IEZsb2F0MzJBcnJheSh4Kl8qcCksVD1uZXcgRmxvYXQzMkFycmF5KG0qXypwKSxNPW5ldyBGbG9hdDMyQXJyYXkoZCpfKnApO2ZvcihsZXQgYj0wO2I8cDtiKyspe2NvbnN0IHc9YiUzKjIvMy0xLFU9Yj4yPzA6LTEsRT1bdyxVLDAsdysyLzMsVSwwLHcrMi8zLFUrMSwwLHcsVSwwLHcrMi8zLFUrMSwwLHcsVSsxLDBdO0Euc2V0KEUseCpfKmIpLFQuc2V0KGYsbSpfKmIpO2NvbnN0IFM9W2IsYixiLGIsYixiXTtNLnNldChTLGQqXypiKX1jb25zdCBGPW5ldyBDdDtGLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBTdChBLHgpKSxGLnNldEF0dHJpYnV0ZSgidXYiLG5ldyBTdChULG0pKSxGLnNldEF0dHJpYnV0ZSgiZmFjZUluZGV4IixuZXcgU3QoTSxkKSksZS5wdXNoKEYpLHI+T24mJnItLX1yZXR1cm57bG9kUGxhbmVzOmUsc2l6ZUxvZHM6dCxzaWdtYXM6bn19ZnVuY3Rpb24gcnMoaSxlLHQpe2NvbnN0IG49bmV3IEp0KGksZSx0KTtyZXR1cm4gbi50ZXh0dXJlLm1hcHBpbmc9MzA2LG4udGV4dHVyZS5uYW1lPSJQTVJFTS5jdWJlVXYiLG4uc2Npc3NvclRlc3Q9ITAsbn1mdW5jdGlvbiBUaShpLGUsdCxuLHIpe2kudmlld3BvcnQuc2V0KGUsdCxuLHIpLGkuc2Npc3Nvci5zZXQoZSx0LG4scil9ZnVuY3Rpb24gV2woaSxlLHQpe2NvbnN0IG49bmV3IEZsb2F0MzJBcnJheShtbikscj1uZXcgQigwLDEsMCk7cmV0dXJuIG5ldyBodCh7bmFtZToiU3BoZXJpY2FsR2F1c3NpYW5CbHVyIixkZWZpbmVzOntuOm1uLENVQkVVVl9URVhFTF9XSURUSDoxL2UsQ1VCRVVWX1RFWEVMX0hFSUdIVDoxL3QsQ1VCRVVWX01BWF9NSVA6YCR7aX0uMGB9LHVuaWZvcm1zOntlbnZNYXA6e3ZhbHVlOm51bGx9LHNhbXBsZXM6e3ZhbHVlOjF9LHdlaWdodHM6e3ZhbHVlOm59LGxhdGl0dWRpbmFsOnt2YWx1ZTohMX0sZFRoZXRhOnt2YWx1ZTowfSxtaXBJbnQ6e3ZhbHVlOjB9LHBvbGVBeGlzOnt2YWx1ZTpyfX0sdmVydGV4U2hhZGVyOnVyKCksZnJhZ21lbnRTaGFkZXI6YAoKCQkJcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CgkJCXByZWNpc2lvbiBtZWRpdW1wIGludDsKCgkJCXZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uOwoKCQkJdW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwOwoJCQl1bmlmb3JtIGludCBzYW1wbGVzOwoJCQl1bmlmb3JtIGZsb2F0IHdlaWdodHNbIG4gXTsKCQkJdW5pZm9ybSBib29sIGxhdGl0dWRpbmFsOwoJCQl1bmlmb3JtIGZsb2F0IGRUaGV0YTsKCQkJdW5pZm9ybSBmbG9hdCBtaXBJbnQ7CgkJCXVuaWZvcm0gdmVjMyBwb2xlQXhpczsKCgkJCSNkZWZpbmUgRU5WTUFQX1RZUEVfQ1VCRV9VVgoJCQkjaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PgoKCQkJdmVjMyBnZXRTYW1wbGUoIGZsb2F0IHRoZXRhLCB2ZWMzIGF4aXMgKSB7CgoJCQkJZmxvYXQgY29zVGhldGEgPSBjb3MoIHRoZXRhICk7CgkJCQkvLyBSb2RyaWd1ZXMnIGF4aXMtYW5nbGUgcm90YXRpb24KCQkJCXZlYzMgc2FtcGxlRGlyZWN0aW9uID0gdk91dHB1dERpcmVjdGlvbiAqIGNvc1RoZXRhCgkJCQkJKyBjcm9zcyggYXhpcywgdk91dHB1dERpcmVjdGlvbiApICogc2luKCB0aGV0YSApCgkJCQkJKyBheGlzICogZG90KCBheGlzLCB2T3V0cHV0RGlyZWN0aW9uICkgKiAoIDEuMCAtIGNvc1RoZXRhICk7CgoJCQkJcmV0dXJuIGJpbGluZWFyQ3ViZVVWKCBlbnZNYXAsIHNhbXBsZURpcmVjdGlvbiwgbWlwSW50ICk7CgoJCQl9CgoJCQl2b2lkIG1haW4oKSB7CgoJCQkJdmVjMyBheGlzID0gbGF0aXR1ZGluYWwgPyBwb2xlQXhpcyA6IGNyb3NzKCBwb2xlQXhpcywgdk91dHB1dERpcmVjdGlvbiApOwoKCQkJCWlmICggYWxsKCBlcXVhbCggYXhpcywgdmVjMyggMC4wICkgKSApICkgewoKCQkJCQlheGlzID0gdmVjMyggdk91dHB1dERpcmVjdGlvbi56LCAwLjAsIC0gdk91dHB1dERpcmVjdGlvbi54ICk7CgoJCQkJfQoKCQkJCWF4aXMgPSBub3JtYWxpemUoIGF4aXMgKTsKCgkJCQlnbF9GcmFnQ29sb3IgPSB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTsKCQkJCWdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgMCBdICogZ2V0U2FtcGxlKCAwLjAsIGF4aXMgKTsKCgkJCQlmb3IgKCBpbnQgaSA9IDE7IGkgPCBuOyBpKysgKSB7CgoJCQkJCWlmICggaSA+PSBzYW1wbGVzICkgewoKCQkJCQkJYnJlYWs7CgoJCQkJCX0KCgkJCQkJZmxvYXQgdGhldGEgPSBkVGhldGEgKiBmbG9hdCggaSApOwoJCQkJCWdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgaSBdICogZ2V0U2FtcGxlKCAtMS4wICogdGhldGEsIGF4aXMgKTsKCQkJCQlnbF9GcmFnQ29sb3IucmdiICs9IHdlaWdodHNbIGkgXSAqIGdldFNhbXBsZSggdGhldGEsIGF4aXMgKTsKCgkJCQl9CgoJCQl9CgkJYCxibGVuZGluZzowLGRlcHRoVGVzdDohMSxkZXB0aFdyaXRlOiExfSl9ZnVuY3Rpb24gc3MoKXtyZXR1cm4gbmV3IGh0KHtuYW1lOiJFcXVpcmVjdGFuZ3VsYXJUb0N1YmVVViIsdW5pZm9ybXM6e2Vudk1hcDp7dmFsdWU6bnVsbH19LHZlcnRleFNoYWRlcjp1cigpLGZyYWdtZW50U2hhZGVyOmAKCgkJCXByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwoJCQlwcmVjaXNpb24gbWVkaXVtcCBpbnQ7CgoJCQl2YXJ5aW5nIHZlYzMgdk91dHB1dERpcmVjdGlvbjsKCgkJCXVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDsKCgkJCSNpbmNsdWRlIDxjb21tb24+CgoJCQl2b2lkIG1haW4oKSB7CgoJCQkJdmVjMyBvdXRwdXREaXJlY3Rpb24gPSBub3JtYWxpemUoIHZPdXRwdXREaXJlY3Rpb24gKTsKCQkJCXZlYzIgdXYgPSBlcXVpcmVjdFV2KCBvdXRwdXREaXJlY3Rpb24gKTsKCgkJCQlnbF9GcmFnQ29sb3IgPSB2ZWM0KCB0ZXh0dXJlMkQgKCBlbnZNYXAsIHV2ICkucmdiLCAxLjAgKTsKCgkJCX0KCQlgLGJsZW5kaW5nOjAsZGVwdGhUZXN0OiExLGRlcHRoV3JpdGU6ITF9KX1mdW5jdGlvbiBhcygpe3JldHVybiBuZXcgaHQoe25hbWU6IkN1YmVtYXBUb0N1YmVVViIsdW5pZm9ybXM6e2Vudk1hcDp7dmFsdWU6bnVsbH0sZmxpcEVudk1hcDp7dmFsdWU6LTF9fSx2ZXJ0ZXhTaGFkZXI6dXIoKSxmcmFnbWVudFNoYWRlcjpgCgoJCQlwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKCQkJcHJlY2lzaW9uIG1lZGl1bXAgaW50OwoKCQkJdW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwOwoKCQkJdmFyeWluZyB2ZWMzIHZPdXRwdXREaXJlY3Rpb247CgoJCQl1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDsKCgkJCXZvaWQgbWFpbigpIHsKCgkJCQlnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCB2ZWMzKCBmbGlwRW52TWFwICogdk91dHB1dERpcmVjdGlvbi54LCB2T3V0cHV0RGlyZWN0aW9uLnl6ICkgKTsKCgkJCX0KCQlgLGJsZW5kaW5nOjAsZGVwdGhUZXN0OiExLGRlcHRoV3JpdGU6ITF9KX1mdW5jdGlvbiB1cigpe3JldHVybmAKCgkJcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CgkJcHJlY2lzaW9uIG1lZGl1bXAgaW50OwoKCQlhdHRyaWJ1dGUgZmxvYXQgZmFjZUluZGV4OwoKCQl2YXJ5aW5nIHZlYzMgdk91dHB1dERpcmVjdGlvbjsKCgkJLy8gUkggY29vcmRpbmF0ZSBzeXN0ZW07IFBNUkVNIGZhY2UtaW5kZXhpbmcgY29udmVudGlvbgoJCXZlYzMgZ2V0RGlyZWN0aW9uKCB2ZWMyIHV2LCBmbG9hdCBmYWNlICkgewoKCQkJdXYgPSAyLjAgKiB1diAtIDEuMDsKCgkJCXZlYzMgZGlyZWN0aW9uID0gdmVjMyggdXYsIDEuMCApOwoKCQkJaWYgKCBmYWNlID09IDAuMCApIHsKCgkJCQlkaXJlY3Rpb24gPSBkaXJlY3Rpb24uenl4OyAvLyAoIDEsIHYsIHUgKSBwb3MgeAoKCQkJfSBlbHNlIGlmICggZmFjZSA9PSAxLjAgKSB7CgoJCQkJZGlyZWN0aW9uID0gZGlyZWN0aW9uLnh6eTsKCQkJCWRpcmVjdGlvbi54eiAqPSAtMS4wOyAvLyAoIC11LCAxLCAtdiApIHBvcyB5CgoJCQl9IGVsc2UgaWYgKCBmYWNlID09IDIuMCApIHsKCgkJCQlkaXJlY3Rpb24ueCAqPSAtMS4wOyAvLyAoIC11LCB2LCAxICkgcG9zIHoKCgkJCX0gZWxzZSBpZiAoIGZhY2UgPT0gMy4wICkgewoKCQkJCWRpcmVjdGlvbiA9IGRpcmVjdGlvbi56eXg7CgkJCQlkaXJlY3Rpb24ueHogKj0gLTEuMDsgLy8gKCAtMSwgdiwgLXUgKSBuZWcgeAoKCQkJfSBlbHNlIGlmICggZmFjZSA9PSA0LjAgKSB7CgoJCQkJZGlyZWN0aW9uID0gZGlyZWN0aW9uLnh6eTsKCQkJCWRpcmVjdGlvbi54eSAqPSAtMS4wOyAvLyAoIC11LCAtMSwgdiApIG5lZyB5CgoJCQl9IGVsc2UgaWYgKCBmYWNlID09IDUuMCApIHsKCgkJCQlkaXJlY3Rpb24ueiAqPSAtMS4wOyAvLyAoIHUsIHYsIC0xICkgbmVnIHoKCgkJCX0KCgkJCXJldHVybiBkaXJlY3Rpb247CgoJCX0KCgkJdm9pZCBtYWluKCkgewoKCQkJdk91dHB1dERpcmVjdGlvbiA9IGdldERpcmVjdGlvbiggdXYsIGZhY2VJbmRleCApOwoJCQlnbF9Qb3NpdGlvbiA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTsKCgkJfQoJYH1mdW5jdGlvbiBYbChpKXtsZXQgZT1uZXcgV2Vha01hcCx0PW51bGw7ZnVuY3Rpb24gbihvKXtpZihvJiZvLmlzVGV4dHVyZSl7Y29uc3QgbD1vLm1hcHBpbmcsYz1sPT09MzAzfHxsPT09MzA0LHU9bD09PTMwMXx8bD09PTMwMjtpZihjfHx1KXtsZXQgaD1lLmdldChvKTtjb25zdCBmPWghPT12b2lkIDA/aC50ZXh0dXJlLnBtcmVtVmVyc2lvbjowO2lmKG8uaXNSZW5kZXJUYXJnZXRUZXh0dXJlJiZvLnBtcmVtVmVyc2lvbiE9PWYpcmV0dXJuIHQ9PT1udWxsJiYodD1uZXcgaXMoaSkpLGg9Yz90LmZyb21FcXVpcmVjdGFuZ3VsYXIobyxoKTp0LmZyb21DdWJlbWFwKG8saCksaC50ZXh0dXJlLnBtcmVtVmVyc2lvbj1vLnBtcmVtVmVyc2lvbixlLnNldChvLGgpLGgudGV4dHVyZTtpZihoIT09dm9pZCAwKXJldHVybiBoLnRleHR1cmU7e2NvbnN0IHA9by5pbWFnZTtyZXR1cm4gYyYmcCYmcC5oZWlnaHQ+MHx8dSYmcCYmcihwKT8odD09PW51bGwmJih0PW5ldyBpcyhpKSksaD1jP3QuZnJvbUVxdWlyZWN0YW5ndWxhcihvKTp0LmZyb21DdWJlbWFwKG8pLGgudGV4dHVyZS5wbXJlbVZlcnNpb249by5wbXJlbVZlcnNpb24sZS5zZXQobyxoKSxvLmFkZEV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLHMpLGgudGV4dHVyZSk6bnVsbH19fXJldHVybiBvfWZ1bmN0aW9uIHIobyl7bGV0IGw9MDtjb25zdCBjPTY7Zm9yKGxldCB1PTA7dTxjO3UrKylvW3VdIT09dm9pZCAwJiZsKys7cmV0dXJuIGw9PT1jfWZ1bmN0aW9uIHMobyl7Y29uc3QgbD1vLnRhcmdldDtsLnJlbW92ZUV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLHMpO2NvbnN0IGM9ZS5nZXQobCk7YyE9PXZvaWQgMCYmKGUuZGVsZXRlKGwpLGMuZGlzcG9zZSgpKX1mdW5jdGlvbiBhKCl7ZT1uZXcgV2Vha01hcCx0IT09bnVsbCYmKHQuZGlzcG9zZSgpLHQ9bnVsbCl9cmV0dXJue2dldDpuLGRpc3Bvc2U6YX19ZnVuY3Rpb24gcWwoaSl7Y29uc3QgZT17fTtmdW5jdGlvbiB0KG4pe2lmKGVbbl0hPT12b2lkIDApcmV0dXJuIGVbbl07bGV0IHI7c3dpdGNoKG4pe2Nhc2UiV0VCR0xfZGVwdGhfdGV4dHVyZSI6cj1pLmdldEV4dGVuc2lvbigiV0VCR0xfZGVwdGhfdGV4dHVyZSIpfHxpLmdldEV4dGVuc2lvbigiTU9aX1dFQkdMX2RlcHRoX3RleHR1cmUiKXx8aS5nZXRFeHRlbnNpb24oIldFQktJVF9XRUJHTF9kZXB0aF90ZXh0dXJlIik7YnJlYWs7Y2FzZSJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMiOnI9aS5nZXRFeHRlbnNpb24oIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyIpfHxpLmdldEV4dGVuc2lvbigiTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyIpfHxpLmdldEV4dGVuc2lvbigiV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyIpO2JyZWFrO2Nhc2UiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMiOnI9aS5nZXRFeHRlbnNpb24oIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjIil8fGkuZ2V0RXh0ZW5zaW9uKCJNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMiKXx8aS5nZXRFeHRlbnNpb24oIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YyIpO2JyZWFrO2Nhc2UiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjIjpyPWkuZ2V0RXh0ZW5zaW9uKCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMiKXx8aS5nZXRFeHRlbnNpb24oIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMiKTticmVhaztkZWZhdWx0OnI9aS5nZXRFeHRlbnNpb24obil9cmV0dXJuIGVbbl09cixyfXJldHVybntoYXM6ZnVuY3Rpb24obil7cmV0dXJuIHQobikhPT1udWxsfSxpbml0OmZ1bmN0aW9uKCl7dCgiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCIpLHQoIldFQkdMX2NsaXBfY3VsbF9kaXN0YW5jZSIpLHQoIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhciIpLHQoIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCIpLHQoIldFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZSIpLHQoIldFQkdMX3JlbmRlcl9zaGFyZWRfZXhwb25lbnQiKX0sZ2V0OmZ1bmN0aW9uKG4pe2NvbnN0IHI9dChuKTtyZXR1cm4gcj09PW51bGwmJlduKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAiK24rIiBleHRlbnNpb24gbm90IHN1cHBvcnRlZC4iKSxyfX19ZnVuY3Rpb24gWWwoaSxlLHQsbil7Y29uc3Qgcj17fSxzPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIGEoaCl7Y29uc3QgZj1oLnRhcmdldDtmLmluZGV4IT09bnVsbCYmZS5yZW1vdmUoZi5pbmRleCk7Zm9yKGNvbnN0IF8gaW4gZi5hdHRyaWJ1dGVzKWUucmVtb3ZlKGYuYXR0cmlidXRlc1tfXSk7Zm9yKGNvbnN0IF8gaW4gZi5tb3JwaEF0dHJpYnV0ZXMpe2NvbnN0IHg9Zi5tb3JwaEF0dHJpYnV0ZXNbX107Zm9yKGxldCBtPTAsZD14Lmxlbmd0aDttPGQ7bSsrKWUucmVtb3ZlKHhbbV0pfWYucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsYSksZGVsZXRlIHJbZi5pZF07Y29uc3QgcD1zLmdldChmKTtwJiYoZS5yZW1vdmUocCkscy5kZWxldGUoZikpLG4ucmVsZWFzZVN0YXRlc09mR2VvbWV0cnkoZiksZi5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5PT09ITAmJmRlbGV0ZSBmLl9tYXhJbnN0YW5jZUNvdW50LHQubWVtb3J5Lmdlb21ldHJpZXMtLX1mdW5jdGlvbiBvKGgsZil7cmV0dXJuIHJbZi5pZF09PT0hMHx8KGYuYWRkRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsYSkscltmLmlkXT0hMCx0Lm1lbW9yeS5nZW9tZXRyaWVzKyspLGZ9ZnVuY3Rpb24gbChoKXtjb25zdCBmPWguYXR0cmlidXRlcztmb3IoY29uc3QgXyBpbiBmKWUudXBkYXRlKGZbX10saS5BUlJBWV9CVUZGRVIpO2NvbnN0IHA9aC5tb3JwaEF0dHJpYnV0ZXM7Zm9yKGNvbnN0IF8gaW4gcCl7Y29uc3QgeD1wW19dO2ZvcihsZXQgbT0wLGQ9eC5sZW5ndGg7bTxkO20rKyllLnVwZGF0ZSh4W21dLGkuQVJSQVlfQlVGRkVSKX19ZnVuY3Rpb24gYyhoKXtjb25zdCBmPVtdLHA9aC5pbmRleCxfPWguYXR0cmlidXRlcy5wb3NpdGlvbjtsZXQgeD0wO2lmKHAhPT1udWxsKXtjb25zdCBBPXAuYXJyYXk7eD1wLnZlcnNpb247Zm9yKGxldCBUPTAsTT1BLmxlbmd0aDtUPE07VCs9Myl7Y29uc3QgRj1BW1QrMF0sYj1BW1QrMV0sdz1BW1QrMl07Zi5wdXNoKEYsYixiLHcsdyxGKX19ZWxzZSBpZihfIT09dm9pZCAwKXtjb25zdCBBPV8uYXJyYXk7eD1fLnZlcnNpb247Zm9yKGxldCBUPTAsTT1BLmxlbmd0aC8zLTE7VDxNO1QrPTMpe2NvbnN0IEY9VCswLGI9VCsxLHc9VCsyO2YucHVzaChGLGIsYix3LHcsRil9fWVsc2UgcmV0dXJuO2NvbnN0IG09bmV3KFNyKGYpP2tyOlZyKShmLDEpO20udmVyc2lvbj14O2NvbnN0IGQ9cy5nZXQoaCk7ZCYmZS5yZW1vdmUoZCkscy5zZXQoaCxtKX1mdW5jdGlvbiB1KGgpe2NvbnN0IGY9cy5nZXQoaCk7aWYoZil7Y29uc3QgcD1oLmluZGV4O3AhPT1udWxsJiZmLnZlcnNpb248cC52ZXJzaW9uJiZjKGgpfWVsc2UgYyhoKTtyZXR1cm4gcy5nZXQoaCl9cmV0dXJue2dldDpvLHVwZGF0ZTpsLGdldFdpcmVmcmFtZUF0dHJpYnV0ZTp1fX1mdW5jdGlvbiAkbChpLGUsdCl7bGV0IG47ZnVuY3Rpb24gcihmKXtuPWZ9bGV0IHMsYTtmdW5jdGlvbiBvKGYpe3M9Zi50eXBlLGE9Zi5ieXRlc1BlckVsZW1lbnR9ZnVuY3Rpb24gbChmLHApe2kuZHJhd0VsZW1lbnRzKG4scCxzLGYqYSksdC51cGRhdGUocCxuLDEpfWZ1bmN0aW9uIGMoZixwLF8pe18hPT0wJiYoaS5kcmF3RWxlbWVudHNJbnN0YW5jZWQobixwLHMsZiphLF8pLHQudXBkYXRlKHAsbixfKSl9ZnVuY3Rpb24gdShmLHAsXyl7aWYoXz09PTApcmV0dXJuO2UuZ2V0KCJXRUJHTF9tdWx0aV9kcmF3IikubXVsdGlEcmF3RWxlbWVudHNXRUJHTChuLHAsMCxzLGYsMCxfKTtsZXQgbT0wO2ZvcihsZXQgZD0wO2Q8XztkKyspbSs9cFtkXTt0LnVwZGF0ZShtLG4sMSl9ZnVuY3Rpb24gaChmLHAsXyx4KXtpZihfPT09MClyZXR1cm47Y29uc3QgbT1lLmdldCgiV0VCR0xfbXVsdGlfZHJhdyIpO2lmKG09PT1udWxsKWZvcihsZXQgZD0wO2Q8Zi5sZW5ndGg7ZCsrKWMoZltkXS9hLHBbZF0seFtkXSk7ZWxzZXttLm11bHRpRHJhd0VsZW1lbnRzSW5zdGFuY2VkV0VCR0wobixwLDAscyxmLDAseCwwLF8pO2xldCBkPTA7Zm9yKGxldCBBPTA7QTxfO0ErKylkKz1wW0FdKnhbQV07dC51cGRhdGUoZCxuLDEpfX10aGlzLnNldE1vZGU9cix0aGlzLnNldEluZGV4PW8sdGhpcy5yZW5kZXI9bCx0aGlzLnJlbmRlckluc3RhbmNlcz1jLHRoaXMucmVuZGVyTXVsdGlEcmF3PXUsdGhpcy5yZW5kZXJNdWx0aURyYXdJbnN0YW5jZXM9aH1mdW5jdGlvbiBabChpKXtjb25zdCBlPXtnZW9tZXRyaWVzOjAsdGV4dHVyZXM6MH0sdD17ZnJhbWU6MCxjYWxsczowLHRyaWFuZ2xlczowLHBvaW50czowLGxpbmVzOjB9O2Z1bmN0aW9uIG4ocyxhLG8pe3N3aXRjaCh0LmNhbGxzKyssYSl7Y2FzZSBpLlRSSUFOR0xFUzp0LnRyaWFuZ2xlcys9byoocy8zKTticmVhaztjYXNlIGkuTElORVM6dC5saW5lcys9byoocy8yKTticmVhaztjYXNlIGkuTElORV9TVFJJUDp0LmxpbmVzKz1vKihzLTEpO2JyZWFrO2Nhc2UgaS5MSU5FX0xPT1A6dC5saW5lcys9bypzO2JyZWFrO2Nhc2UgaS5QT0lOVFM6dC5wb2ludHMrPW8qczticmVhaztkZWZhdWx0OmNvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMSW5mbzogVW5rbm93biBkcmF3IG1vZGU6IixhKTticmVha319ZnVuY3Rpb24gcigpe3QuY2FsbHM9MCx0LnRyaWFuZ2xlcz0wLHQucG9pbnRzPTAsdC5saW5lcz0wfXJldHVybnttZW1vcnk6ZSxyZW5kZXI6dCxwcm9ncmFtczpudWxsLGF1dG9SZXNldDohMCxyZXNldDpyLHVwZGF0ZTpufX1mdW5jdGlvbiBLbChpLGUsdCl7Y29uc3Qgbj1uZXcgV2Vha01hcCxyPW5ldyBpdDtmdW5jdGlvbiBzKGEsbyxsKXtjb25zdCBjPWEubW9ycGhUYXJnZXRJbmZsdWVuY2VzLHU9by5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb258fG8ubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbHx8by5tb3JwaEF0dHJpYnV0ZXMuY29sb3IsaD11IT09dm9pZCAwP3UubGVuZ3RoOjA7bGV0IGY9bi5nZXQobyk7aWYoZj09PXZvaWQgMHx8Zi5jb3VudCE9PWgpe2xldCBFPWZ1bmN0aW9uKCl7dy5kaXNwb3NlKCksbi5kZWxldGUobyksby5yZW1vdmVFdmVudExpc3RlbmVyKCJkaXNwb3NlIixFKX07ZiE9PXZvaWQgMCYmZi50ZXh0dXJlLmRpc3Bvc2UoKTtjb25zdCBwPW8ubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uIT09dm9pZCAwLF89by5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsIT09dm9pZCAwLHg9by5tb3JwaEF0dHJpYnV0ZXMuY29sb3IhPT12b2lkIDAsbT1vLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbnx8W10sZD1vLm1vcnBoQXR0cmlidXRlcy5ub3JtYWx8fFtdLEE9by5tb3JwaEF0dHJpYnV0ZXMuY29sb3J8fFtdO2xldCBUPTA7cD09PSEwJiYoVD0xKSxfPT09ITAmJihUPTIpLHg9PT0hMCYmKFQ9Myk7bGV0IE09by5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50KlQsRj0xO00+ZS5tYXhUZXh0dXJlU2l6ZSYmKEY9TWF0aC5jZWlsKE0vZS5tYXhUZXh0dXJlU2l6ZSksTT1lLm1heFRleHR1cmVTaXplKTtjb25zdCBiPW5ldyBGbG9hdDMyQXJyYXkoTSpGKjQqaCksdz1uZXcgQ3IoYixNLEYsaCk7dy50eXBlPTEwMTUsdy5uZWVkc1VwZGF0ZT0hMDtjb25zdCBVPVQqNDtmb3IobGV0IFM9MDtTPGg7UysrKXtjb25zdCBSPW1bU10scT1kW1NdLHo9QVtTXSxXPU0qRio0KlM7Zm9yKGxldCBLPTA7SzxSLmNvdW50O0srKyl7Y29uc3QgVj1LKlU7cD09PSEwJiYoci5mcm9tQnVmZmVyQXR0cmlidXRlKFIsSyksYltXK1YrMF09ci54LGJbVytWKzFdPXIueSxiW1crVisyXT1yLnosYltXK1YrM109MCksXz09PSEwJiYoci5mcm9tQnVmZmVyQXR0cmlidXRlKHEsSyksYltXK1YrNF09ci54LGJbVytWKzVdPXIueSxiW1crVis2XT1yLnosYltXK1YrN109MCkseD09PSEwJiYoci5mcm9tQnVmZmVyQXR0cmlidXRlKHosSyksYltXK1YrOF09ci54LGJbVytWKzldPXIueSxiW1crVisxMF09ci56LGJbVytWKzExXT16Lml0ZW1TaXplPT09ND9yLnc6MSl9fWY9e2NvdW50OmgsdGV4dHVyZTp3LHNpemU6bmV3IExlKE0sRil9LG4uc2V0KG8sZiksby5hZGRFdmVudExpc3RlbmVyKCJkaXNwb3NlIixFKX1pZihhLmlzSW5zdGFuY2VkTWVzaD09PSEwJiZhLm1vcnBoVGV4dHVyZSE9PW51bGwpbC5nZXRVbmlmb3JtcygpLnNldFZhbHVlKGksIm1vcnBoVGV4dHVyZSIsYS5tb3JwaFRleHR1cmUsdCk7ZWxzZXtsZXQgcD0wO2ZvcihsZXQgeD0wO3g8Yy5sZW5ndGg7eCsrKXArPWNbeF07Y29uc3QgXz1vLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPzE6MS1wO2wuZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShpLCJtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2UiLF8pLGwuZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShpLCJtb3JwaFRhcmdldEluZmx1ZW5jZXMiLGMpfWwuZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShpLCJtb3JwaFRhcmdldHNUZXh0dXJlIixmLnRleHR1cmUsdCksbC5nZXRVbmlmb3JtcygpLnNldFZhbHVlKGksIm1vcnBoVGFyZ2V0c1RleHR1cmVTaXplIixmLnNpemUpfXJldHVybnt1cGRhdGU6c319ZnVuY3Rpb24gamwoaSxlLHQsbil7bGV0IHI9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gcyhsKXtjb25zdCBjPW4ucmVuZGVyLmZyYW1lLHU9bC5nZW9tZXRyeSxoPWUuZ2V0KGwsdSk7aWYoci5nZXQoaCkhPT1jJiYoZS51cGRhdGUoaCksci5zZXQoaCxjKSksbC5pc0luc3RhbmNlZE1lc2gmJihsLmhhc0V2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLG8pPT09ITEmJmwuYWRkRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsbyksci5nZXQobCkhPT1jJiYodC51cGRhdGUobC5pbnN0YW5jZU1hdHJpeCxpLkFSUkFZX0JVRkZFUiksbC5pbnN0YW5jZUNvbG9yIT09bnVsbCYmdC51cGRhdGUobC5pbnN0YW5jZUNvbG9yLGkuQVJSQVlfQlVGRkVSKSxyLnNldChsLGMpKSksbC5pc1NraW5uZWRNZXNoKXtjb25zdCBmPWwuc2tlbGV0b247ci5nZXQoZikhPT1jJiYoZi51cGRhdGUoKSxyLnNldChmLGMpKX1yZXR1cm4gaH1mdW5jdGlvbiBhKCl7cj1uZXcgV2Vha01hcH1mdW5jdGlvbiBvKGwpe2NvbnN0IGM9bC50YXJnZXQ7Yy5yZW1vdmVFdmVudExpc3RlbmVyKCJkaXNwb3NlIixvKSx0LnJlbW92ZShjLmluc3RhbmNlTWF0cml4KSxjLmluc3RhbmNlQ29sb3IhPT1udWxsJiZ0LnJlbW92ZShjLmluc3RhbmNlQ29sb3IpfXJldHVybnt1cGRhdGU6cyxkaXNwb3NlOmF9fWNsYXNzIG9zIGV4dGVuZHMgdnR7Y29uc3RydWN0b3IoZSx0LG4scixzLGEsbyxsLGMsdT0xMDI2KXtpZih1IT09MTAyNiYmdSE9PTEwMjcpdGhyb3cgbmV3IEVycm9yKCJEZXB0aFRleHR1cmUgZm9ybWF0IG11c3QgYmUgZWl0aGVyIFRIUkVFLkRlcHRoRm9ybWF0IG9yIFRIUkVFLkRlcHRoU3RlbmNpbEZvcm1hdCIpO249PT12b2lkIDAmJnU9PT0xMDI2JiYobj0xMDE0KSxuPT09dm9pZCAwJiZ1PT09MTAyNyYmKG49MTAyMCksc3VwZXIobnVsbCxyLHMsYSxvLGwsdSxuLGMpLHRoaXMuaXNEZXB0aFRleHR1cmU9ITAsdGhpcy5pbWFnZT17d2lkdGg6ZSxoZWlnaHQ6dH0sdGhpcy5tYWdGaWx0ZXI9byE9PXZvaWQgMD9vOjEwMDMsdGhpcy5taW5GaWx0ZXI9bCE9PXZvaWQgMD9sOjEwMDMsdGhpcy5mbGlwWT0hMSx0aGlzLmdlbmVyYXRlTWlwbWFwcz0hMSx0aGlzLmNvbXBhcmVGdW5jdGlvbj1udWxsfWNvcHkoZSl7cmV0dXJuIHN1cGVyLmNvcHkoZSksdGhpcy5jb21wYXJlRnVuY3Rpb249ZS5jb21wYXJlRnVuY3Rpb24sdGhpc310b0pTT04oZSl7Y29uc3QgdD1zdXBlci50b0pTT04oZSk7cmV0dXJuIHRoaXMuY29tcGFyZUZ1bmN0aW9uIT09bnVsbCYmKHQuY29tcGFyZUZ1bmN0aW9uPXRoaXMuY29tcGFyZUZ1bmN0aW9uKSx0fX1jb25zdCBscz1uZXcgdnQsY3M9bmV3IG9zKDEsMSksdXM9bmV3IENyLGhzPW5ldyBfYSxkcz1uZXcganIsZnM9W10scHM9W10sbXM9bmV3IEZsb2F0MzJBcnJheSgxNiksX3M9bmV3IEZsb2F0MzJBcnJheSg5KSxncz1uZXcgRmxvYXQzMkFycmF5KDQpO2Z1bmN0aW9uIHpuKGksZSx0KXtjb25zdCBuPWlbMF07aWYobjw9MHx8bj4wKXJldHVybiBpO2NvbnN0IHI9ZSp0O2xldCBzPWZzW3JdO2lmKHM9PT12b2lkIDAmJihzPW5ldyBGbG9hdDMyQXJyYXkociksZnNbcl09cyksZSE9PTApe24udG9BcnJheShzLDApO2ZvcihsZXQgYT0xLG89MDthIT09ZTsrK2Epbys9dCxpW2FdLnRvQXJyYXkocyxvKX1yZXR1cm4gc31mdW5jdGlvbiBsdChpLGUpe2lmKGkubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCB0PTAsbj1pLmxlbmd0aDt0PG47dCsrKWlmKGlbdF0hPT1lW3RdKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIGN0KGksZSl7Zm9yKGxldCB0PTAsbj1lLmxlbmd0aDt0PG47dCsrKWlbdF09ZVt0XX1mdW5jdGlvbiBBaShpLGUpe2xldCB0PXBzW2VdO3Q9PT12b2lkIDAmJih0PW5ldyBJbnQzMkFycmF5KGUpLHBzW2VdPXQpO2ZvcihsZXQgbj0wO24hPT1lOysrbil0W25dPWkuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO3JldHVybiB0fWZ1bmN0aW9uIEpsKGksZSl7Y29uc3QgdD10aGlzLmNhY2hlO3RbMF0hPT1lJiYoaS51bmlmb3JtMWYodGhpcy5hZGRyLGUpLHRbMF09ZSl9ZnVuY3Rpb24gUWwoaSxlKXtjb25zdCB0PXRoaXMuY2FjaGU7aWYoZS54IT09dm9pZCAwKSh0WzBdIT09ZS54fHx0WzFdIT09ZS55KSYmKGkudW5pZm9ybTJmKHRoaXMuYWRkcixlLngsZS55KSx0WzBdPWUueCx0WzFdPWUueSk7ZWxzZXtpZihsdCh0LGUpKXJldHVybjtpLnVuaWZvcm0yZnYodGhpcy5hZGRyLGUpLGN0KHQsZSl9fWZ1bmN0aW9uIGVjKGksZSl7Y29uc3QgdD10aGlzLmNhY2hlO2lmKGUueCE9PXZvaWQgMCkodFswXSE9PWUueHx8dFsxXSE9PWUueXx8dFsyXSE9PWUueikmJihpLnVuaWZvcm0zZih0aGlzLmFkZHIsZS54LGUueSxlLnopLHRbMF09ZS54LHRbMV09ZS55LHRbMl09ZS56KTtlbHNlIGlmKGUuciE9PXZvaWQgMCkodFswXSE9PWUucnx8dFsxXSE9PWUuZ3x8dFsyXSE9PWUuYikmJihpLnVuaWZvcm0zZih0aGlzLmFkZHIsZS5yLGUuZyxlLmIpLHRbMF09ZS5yLHRbMV09ZS5nLHRbMl09ZS5iKTtlbHNle2lmKGx0KHQsZSkpcmV0dXJuO2kudW5pZm9ybTNmdih0aGlzLmFkZHIsZSksY3QodCxlKX19ZnVuY3Rpb24gdGMoaSxlKXtjb25zdCB0PXRoaXMuY2FjaGU7aWYoZS54IT09dm9pZCAwKSh0WzBdIT09ZS54fHx0WzFdIT09ZS55fHx0WzJdIT09ZS56fHx0WzNdIT09ZS53KSYmKGkudW5pZm9ybTRmKHRoaXMuYWRkcixlLngsZS55LGUueixlLncpLHRbMF09ZS54LHRbMV09ZS55LHRbMl09ZS56LHRbM109ZS53KTtlbHNle2lmKGx0KHQsZSkpcmV0dXJuO2kudW5pZm9ybTRmdih0aGlzLmFkZHIsZSksY3QodCxlKX19ZnVuY3Rpb24gbmMoaSxlKXtjb25zdCB0PXRoaXMuY2FjaGUsbj1lLmVsZW1lbnRzO2lmKG49PT12b2lkIDApe2lmKGx0KHQsZSkpcmV0dXJuO2kudW5pZm9ybU1hdHJpeDJmdih0aGlzLmFkZHIsITEsZSksY3QodCxlKX1lbHNle2lmKGx0KHQsbikpcmV0dXJuO2dzLnNldChuKSxpLnVuaWZvcm1NYXRyaXgyZnYodGhpcy5hZGRyLCExLGdzKSxjdCh0LG4pfX1mdW5jdGlvbiBpYyhpLGUpe2NvbnN0IHQ9dGhpcy5jYWNoZSxuPWUuZWxlbWVudHM7aWYobj09PXZvaWQgMCl7aWYobHQodCxlKSlyZXR1cm47aS51bmlmb3JtTWF0cml4M2Z2KHRoaXMuYWRkciwhMSxlKSxjdCh0LGUpfWVsc2V7aWYobHQodCxuKSlyZXR1cm47X3Muc2V0KG4pLGkudW5pZm9ybU1hdHJpeDNmdih0aGlzLmFkZHIsITEsX3MpLGN0KHQsbil9fWZ1bmN0aW9uIHJjKGksZSl7Y29uc3QgdD10aGlzLmNhY2hlLG49ZS5lbGVtZW50cztpZihuPT09dm9pZCAwKXtpZihsdCh0LGUpKXJldHVybjtpLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5hZGRyLCExLGUpLGN0KHQsZSl9ZWxzZXtpZihsdCh0LG4pKXJldHVybjttcy5zZXQobiksaS51bmlmb3JtTWF0cml4NGZ2KHRoaXMuYWRkciwhMSxtcyksY3QodCxuKX19ZnVuY3Rpb24gc2MoaSxlKXtjb25zdCB0PXRoaXMuY2FjaGU7dFswXSE9PWUmJihpLnVuaWZvcm0xaSh0aGlzLmFkZHIsZSksdFswXT1lKX1mdW5jdGlvbiBhYyhpLGUpe2NvbnN0IHQ9dGhpcy5jYWNoZTtpZihlLnghPT12b2lkIDApKHRbMF0hPT1lLnh8fHRbMV0hPT1lLnkpJiYoaS51bmlmb3JtMmkodGhpcy5hZGRyLGUueCxlLnkpLHRbMF09ZS54LHRbMV09ZS55KTtlbHNle2lmKGx0KHQsZSkpcmV0dXJuO2kudW5pZm9ybTJpdih0aGlzLmFkZHIsZSksY3QodCxlKX19ZnVuY3Rpb24gb2MoaSxlKXtjb25zdCB0PXRoaXMuY2FjaGU7aWYoZS54IT09dm9pZCAwKSh0WzBdIT09ZS54fHx0WzFdIT09ZS55fHx0WzJdIT09ZS56KSYmKGkudW5pZm9ybTNpKHRoaXMuYWRkcixlLngsZS55LGUueiksdFswXT1lLngsdFsxXT1lLnksdFsyXT1lLnopO2Vsc2V7aWYobHQodCxlKSlyZXR1cm47aS51bmlmb3JtM2l2KHRoaXMuYWRkcixlKSxjdCh0LGUpfX1mdW5jdGlvbiBsYyhpLGUpe2NvbnN0IHQ9dGhpcy5jYWNoZTtpZihlLnghPT12b2lkIDApKHRbMF0hPT1lLnh8fHRbMV0hPT1lLnl8fHRbMl0hPT1lLnp8fHRbM10hPT1lLncpJiYoaS51bmlmb3JtNGkodGhpcy5hZGRyLGUueCxlLnksZS56LGUudyksdFswXT1lLngsdFsxXT1lLnksdFsyXT1lLnosdFszXT1lLncpO2Vsc2V7aWYobHQodCxlKSlyZXR1cm47aS51bmlmb3JtNGl2KHRoaXMuYWRkcixlKSxjdCh0LGUpfX1mdW5jdGlvbiBjYyhpLGUpe2NvbnN0IHQ9dGhpcy5jYWNoZTt0WzBdIT09ZSYmKGkudW5pZm9ybTF1aSh0aGlzLmFkZHIsZSksdFswXT1lKX1mdW5jdGlvbiB1YyhpLGUpe2NvbnN0IHQ9dGhpcy5jYWNoZTtpZihlLnghPT12b2lkIDApKHRbMF0hPT1lLnh8fHRbMV0hPT1lLnkpJiYoaS51bmlmb3JtMnVpKHRoaXMuYWRkcixlLngsZS55KSx0WzBdPWUueCx0WzFdPWUueSk7ZWxzZXtpZihsdCh0LGUpKXJldHVybjtpLnVuaWZvcm0ydWl2KHRoaXMuYWRkcixlKSxjdCh0LGUpfX1mdW5jdGlvbiBoYyhpLGUpe2NvbnN0IHQ9dGhpcy5jYWNoZTtpZihlLnghPT12b2lkIDApKHRbMF0hPT1lLnh8fHRbMV0hPT1lLnl8fHRbMl0hPT1lLnopJiYoaS51bmlmb3JtM3VpKHRoaXMuYWRkcixlLngsZS55LGUueiksdFswXT1lLngsdFsxXT1lLnksdFsyXT1lLnopO2Vsc2V7aWYobHQodCxlKSlyZXR1cm47aS51bmlmb3JtM3Vpdih0aGlzLmFkZHIsZSksY3QodCxlKX19ZnVuY3Rpb24gZGMoaSxlKXtjb25zdCB0PXRoaXMuY2FjaGU7aWYoZS54IT09dm9pZCAwKSh0WzBdIT09ZS54fHx0WzFdIT09ZS55fHx0WzJdIT09ZS56fHx0WzNdIT09ZS53KSYmKGkudW5pZm9ybTR1aSh0aGlzLmFkZHIsZS54LGUueSxlLnosZS53KSx0WzBdPWUueCx0WzFdPWUueSx0WzJdPWUueix0WzNdPWUudyk7ZWxzZXtpZihsdCh0LGUpKXJldHVybjtpLnVuaWZvcm00dWl2KHRoaXMuYWRkcixlKSxjdCh0LGUpfX1mdW5jdGlvbiBmYyhpLGUsdCl7Y29uc3Qgbj10aGlzLmNhY2hlLHI9dC5hbGxvY2F0ZVRleHR1cmVVbml0KCk7blswXSE9PXImJihpLnVuaWZvcm0xaSh0aGlzLmFkZHIsciksblswXT1yKTtsZXQgczt0aGlzLnR5cGU9PT1pLlNBTVBMRVJfMkRfU0hBRE9XPyhjcy5jb21wYXJlRnVuY3Rpb249NTE1LHM9Y3MpOnM9bHMsdC5zZXRUZXh0dXJlMkQoZXx8cyxyKX1mdW5jdGlvbiBwYyhpLGUsdCl7Y29uc3Qgbj10aGlzLmNhY2hlLHI9dC5hbGxvY2F0ZVRleHR1cmVVbml0KCk7blswXSE9PXImJihpLnVuaWZvcm0xaSh0aGlzLmFkZHIsciksblswXT1yKSx0LnNldFRleHR1cmUzRChlfHxocyxyKX1mdW5jdGlvbiBtYyhpLGUsdCl7Y29uc3Qgbj10aGlzLmNhY2hlLHI9dC5hbGxvY2F0ZVRleHR1cmVVbml0KCk7blswXSE9PXImJihpLnVuaWZvcm0xaSh0aGlzLmFkZHIsciksblswXT1yKSx0LnNldFRleHR1cmVDdWJlKGV8fGRzLHIpfWZ1bmN0aW9uIF9jKGksZSx0KXtjb25zdCBuPXRoaXMuY2FjaGUscj10LmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtuWzBdIT09ciYmKGkudW5pZm9ybTFpKHRoaXMuYWRkcixyKSxuWzBdPXIpLHQuc2V0VGV4dHVyZTJEQXJyYXkoZXx8dXMscil9ZnVuY3Rpb24gZ2MoaSl7c3dpdGNoKGkpe2Nhc2UgNTEyNjpyZXR1cm4gSmw7Y2FzZSAzNTY2NDpyZXR1cm4gUWw7Y2FzZSAzNTY2NTpyZXR1cm4gZWM7Y2FzZSAzNTY2NjpyZXR1cm4gdGM7Y2FzZSAzNTY3NDpyZXR1cm4gbmM7Y2FzZSAzNTY3NTpyZXR1cm4gaWM7Y2FzZSAzNTY3NjpyZXR1cm4gcmM7Y2FzZSA1MTI0OmNhc2UgMzU2NzA6cmV0dXJuIHNjO2Nhc2UgMzU2Njc6Y2FzZSAzNTY3MTpyZXR1cm4gYWM7Y2FzZSAzNTY2ODpjYXNlIDM1NjcyOnJldHVybiBvYztjYXNlIDM1NjY5OmNhc2UgMzU2NzM6cmV0dXJuIGxjO2Nhc2UgNTEyNTpyZXR1cm4gY2M7Y2FzZSAzNjI5NDpyZXR1cm4gdWM7Y2FzZSAzNjI5NTpyZXR1cm4gaGM7Y2FzZSAzNjI5NjpyZXR1cm4gZGM7Y2FzZSAzNTY3ODpjYXNlIDM2MTk4OmNhc2UgMzYyOTg6Y2FzZSAzNjMwNjpjYXNlIDM1NjgyOnJldHVybiBmYztjYXNlIDM1Njc5OmNhc2UgMzYyOTk6Y2FzZSAzNjMwNzpyZXR1cm4gcGM7Y2FzZSAzNTY4MDpjYXNlIDM2MzAwOmNhc2UgMzYzMDg6Y2FzZSAzNjI5MzpyZXR1cm4gbWM7Y2FzZSAzNjI4OTpjYXNlIDM2MzAzOmNhc2UgMzYzMTE6Y2FzZSAzNjI5MjpyZXR1cm4gX2N9fWZ1bmN0aW9uIHZjKGksZSl7aS51bmlmb3JtMWZ2KHRoaXMuYWRkcixlKX1mdW5jdGlvbiB4YyhpLGUpe2NvbnN0IHQ9em4oZSx0aGlzLnNpemUsMik7aS51bmlmb3JtMmZ2KHRoaXMuYWRkcix0KX1mdW5jdGlvbiBNYyhpLGUpe2NvbnN0IHQ9em4oZSx0aGlzLnNpemUsMyk7aS51bmlmb3JtM2Z2KHRoaXMuYWRkcix0KX1mdW5jdGlvbiBTYyhpLGUpe2NvbnN0IHQ9em4oZSx0aGlzLnNpemUsNCk7aS51bmlmb3JtNGZ2KHRoaXMuYWRkcix0KX1mdW5jdGlvbiBFYyhpLGUpe2NvbnN0IHQ9em4oZSx0aGlzLnNpemUsNCk7aS51bmlmb3JtTWF0cml4MmZ2KHRoaXMuYWRkciwhMSx0KX1mdW5jdGlvbiB5YyhpLGUpe2NvbnN0IHQ9em4oZSx0aGlzLnNpemUsOSk7aS51bmlmb3JtTWF0cml4M2Z2KHRoaXMuYWRkciwhMSx0KX1mdW5jdGlvbiBUYyhpLGUpe2NvbnN0IHQ9em4oZSx0aGlzLnNpemUsMTYpO2kudW5pZm9ybU1hdHJpeDRmdih0aGlzLmFkZHIsITEsdCl9ZnVuY3Rpb24gQWMoaSxlKXtpLnVuaWZvcm0xaXYodGhpcy5hZGRyLGUpfWZ1bmN0aW9uIGJjKGksZSl7aS51bmlmb3JtMml2KHRoaXMuYWRkcixlKX1mdW5jdGlvbiB3YyhpLGUpe2kudW5pZm9ybTNpdih0aGlzLmFkZHIsZSl9ZnVuY3Rpb24gUmMoaSxlKXtpLnVuaWZvcm00aXYodGhpcy5hZGRyLGUpfWZ1bmN0aW9uIENjKGksZSl7aS51bmlmb3JtMXVpdih0aGlzLmFkZHIsZSl9ZnVuY3Rpb24gUGMoaSxlKXtpLnVuaWZvcm0ydWl2KHRoaXMuYWRkcixlKX1mdW5jdGlvbiBEYyhpLGUpe2kudW5pZm9ybTN1aXYodGhpcy5hZGRyLGUpfWZ1bmN0aW9uIExjKGksZSl7aS51bmlmb3JtNHVpdih0aGlzLmFkZHIsZSl9ZnVuY3Rpb24gVWMoaSxlLHQpe2NvbnN0IG49dGhpcy5jYWNoZSxyPWUubGVuZ3RoLHM9QWkodCxyKTtsdChuLHMpfHwoaS51bmlmb3JtMWl2KHRoaXMuYWRkcixzKSxjdChuLHMpKTtmb3IobGV0IGE9MDthIT09cjsrK2EpdC5zZXRUZXh0dXJlMkQoZVthXXx8bHMsc1thXSl9ZnVuY3Rpb24gRmMoaSxlLHQpe2NvbnN0IG49dGhpcy5jYWNoZSxyPWUubGVuZ3RoLHM9QWkodCxyKTtsdChuLHMpfHwoaS51bmlmb3JtMWl2KHRoaXMuYWRkcixzKSxjdChuLHMpKTtmb3IobGV0IGE9MDthIT09cjsrK2EpdC5zZXRUZXh0dXJlM0QoZVthXXx8aHMsc1thXSl9ZnVuY3Rpb24gSWMoaSxlLHQpe2NvbnN0IG49dGhpcy5jYWNoZSxyPWUubGVuZ3RoLHM9QWkodCxyKTtsdChuLHMpfHwoaS51bmlmb3JtMWl2KHRoaXMuYWRkcixzKSxjdChuLHMpKTtmb3IobGV0IGE9MDthIT09cjsrK2EpdC5zZXRUZXh0dXJlQ3ViZShlW2FdfHxkcyxzW2FdKX1mdW5jdGlvbiBOYyhpLGUsdCl7Y29uc3Qgbj10aGlzLmNhY2hlLHI9ZS5sZW5ndGgscz1BaSh0LHIpO2x0KG4scyl8fChpLnVuaWZvcm0xaXYodGhpcy5hZGRyLHMpLGN0KG4scykpO2ZvcihsZXQgYT0wO2EhPT1yOysrYSl0LnNldFRleHR1cmUyREFycmF5KGVbYV18fHVzLHNbYV0pfWZ1bmN0aW9uIE9jKGkpe3N3aXRjaChpKXtjYXNlIDUxMjY6cmV0dXJuIHZjO2Nhc2UgMzU2NjQ6cmV0dXJuIHhjO2Nhc2UgMzU2NjU6cmV0dXJuIE1jO2Nhc2UgMzU2NjY6cmV0dXJuIFNjO2Nhc2UgMzU2NzQ6cmV0dXJuIEVjO2Nhc2UgMzU2NzU6cmV0dXJuIHljO2Nhc2UgMzU2NzY6cmV0dXJuIFRjO2Nhc2UgNTEyNDpjYXNlIDM1NjcwOnJldHVybiBBYztjYXNlIDM1NjY3OmNhc2UgMzU2NzE6cmV0dXJuIGJjO2Nhc2UgMzU2Njg6Y2FzZSAzNTY3MjpyZXR1cm4gd2M7Y2FzZSAzNTY2OTpjYXNlIDM1NjczOnJldHVybiBSYztjYXNlIDUxMjU6cmV0dXJuIENjO2Nhc2UgMzYyOTQ6cmV0dXJuIFBjO2Nhc2UgMzYyOTU6cmV0dXJuIERjO2Nhc2UgMzYyOTY6cmV0dXJuIExjO2Nhc2UgMzU2Nzg6Y2FzZSAzNjE5ODpjYXNlIDM2Mjk4OmNhc2UgMzYzMDY6Y2FzZSAzNTY4MjpyZXR1cm4gVWM7Y2FzZSAzNTY3OTpjYXNlIDM2Mjk5OmNhc2UgMzYzMDc6cmV0dXJuIEZjO2Nhc2UgMzU2ODA6Y2FzZSAzNjMwMDpjYXNlIDM2MzA4OmNhc2UgMzYyOTM6cmV0dXJuIEljO2Nhc2UgMzYyODk6Y2FzZSAzNjMwMzpjYXNlIDM2MzExOmNhc2UgMzYyOTI6cmV0dXJuIE5jfX1jbGFzcyBCY3tjb25zdHJ1Y3RvcihlLHQsbil7dGhpcy5pZD1lLHRoaXMuYWRkcj1uLHRoaXMuY2FjaGU9W10sdGhpcy50eXBlPXQudHlwZSx0aGlzLnNldFZhbHVlPWdjKHQudHlwZSl9fWNsYXNzIHpje2NvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLmlkPWUsdGhpcy5hZGRyPW4sdGhpcy5jYWNoZT1bXSx0aGlzLnR5cGU9dC50eXBlLHRoaXMuc2l6ZT10LnNpemUsdGhpcy5zZXRWYWx1ZT1PYyh0LnR5cGUpfX1jbGFzcyBHY3tjb25zdHJ1Y3RvcihlKXt0aGlzLmlkPWUsdGhpcy5zZXE9W10sdGhpcy5tYXA9e319c2V0VmFsdWUoZSx0LG4pe2NvbnN0IHI9dGhpcy5zZXE7Zm9yKGxldCBzPTAsYT1yLmxlbmd0aDtzIT09YTsrK3Mpe2NvbnN0IG89cltzXTtvLnNldFZhbHVlKGUsdFtvLmlkXSxuKX19fWNvbnN0IGhyPS8oXHcrKShcXSk/KFxbfFwuKT8vZztmdW5jdGlvbiB2cyhpLGUpe2kuc2VxLnB1c2goZSksaS5tYXBbZS5pZF09ZX1mdW5jdGlvbiBIYyhpLGUsdCl7Y29uc3Qgbj1pLm5hbWUscj1uLmxlbmd0aDtmb3IoaHIubGFzdEluZGV4PTA7Oyl7Y29uc3Qgcz1oci5leGVjKG4pLGE9aHIubGFzdEluZGV4O2xldCBvPXNbMV07Y29uc3QgbD1zWzJdPT09Il0iLGM9c1szXTtpZihsJiYobz1vfDApLGM9PT12b2lkIDB8fGM9PT0iWyImJmErMj09PXIpe3ZzKHQsYz09PXZvaWQgMD9uZXcgQmMobyxpLGUpOm5ldyB6YyhvLGksZSkpO2JyZWFrfWVsc2V7bGV0IGg9dC5tYXBbb107aD09PXZvaWQgMCYmKGg9bmV3IEdjKG8pLHZzKHQsaCkpLHQ9aH19fWNsYXNzIGJpe2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5zZXE9W10sdGhpcy5tYXA9e307Y29uc3Qgbj1lLmdldFByb2dyYW1QYXJhbWV0ZXIodCxlLkFDVElWRV9VTklGT1JNUyk7Zm9yKGxldCByPTA7cjxuOysrcil7Y29uc3Qgcz1lLmdldEFjdGl2ZVVuaWZvcm0odCxyKSxhPWUuZ2V0VW5pZm9ybUxvY2F0aW9uKHQscy5uYW1lKTtIYyhzLGEsdGhpcyl9fXNldFZhbHVlKGUsdCxuLHIpe2NvbnN0IHM9dGhpcy5tYXBbdF07cyE9PXZvaWQgMCYmcy5zZXRWYWx1ZShlLG4scil9c2V0T3B0aW9uYWwoZSx0LG4pe2NvbnN0IHI9dFtuXTtyIT09dm9pZCAwJiZ0aGlzLnNldFZhbHVlKGUsbixyKX1zdGF0aWMgdXBsb2FkKGUsdCxuLHIpe2ZvcihsZXQgcz0wLGE9dC5sZW5ndGg7cyE9PWE7KytzKXtjb25zdCBvPXRbc10sbD1uW28uaWRdO2wubmVlZHNVcGRhdGUhPT0hMSYmby5zZXRWYWx1ZShlLGwudmFsdWUscil9fXN0YXRpYyBzZXFXaXRoVmFsdWUoZSx0KXtjb25zdCBuPVtdO2ZvcihsZXQgcj0wLHM9ZS5sZW5ndGg7ciE9PXM7KytyKXtjb25zdCBhPWVbcl07YS5pZCBpbiB0JiZuLnB1c2goYSl9cmV0dXJuIG59fWZ1bmN0aW9uIHhzKGksZSx0KXtjb25zdCBuPWkuY3JlYXRlU2hhZGVyKGUpO3JldHVybiBpLnNoYWRlclNvdXJjZShuLHQpLGkuY29tcGlsZVNoYWRlcihuKSxufWNvbnN0IFZjPTM3Mjk3O2xldCBrYz0wO2Z1bmN0aW9uIFdjKGksZSl7Y29uc3QgdD1pLnNwbGl0KGAKYCksbj1bXSxyPU1hdGgubWF4KGUtNiwwKSxzPU1hdGgubWluKGUrNix0Lmxlbmd0aCk7Zm9yKGxldCBhPXI7YTxzO2ErKyl7Y29uc3Qgbz1hKzE7bi5wdXNoKGAke289PT1lPyI+IjoiICJ9ICR7b306ICR7dFthXX1gKX1yZXR1cm4gbi5qb2luKGAKYCl9Y29uc3QgTXM9bmV3IHdlO2Z1bmN0aW9uIFhjKGkpe0JlLl9nZXRNYXRyaXgoTXMsQmUud29ya2luZ0NvbG9yU3BhY2UsaSk7Y29uc3QgZT1gbWF0MyggJHtNcy5lbGVtZW50cy5tYXAodD0+dC50b0ZpeGVkKDQpKX0gKWA7c3dpdGNoKEJlLmdldFRyYW5zZmVyKGkpKXtjYXNlIGlpOnJldHVybltlLCJMaW5lYXJUcmFuc2Zlck9FVEYiXTtjYXNlIHFlOnJldHVybltlLCJzUkdCVHJhbnNmZXJPRVRGIl07ZGVmYXVsdDpyZXR1cm4gY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFByb2dyYW06IFVuc3VwcG9ydGVkIGNvbG9yIHNwYWNlOiAiLGkpLFtlLCJMaW5lYXJUcmFuc2Zlck9FVEYiXX19ZnVuY3Rpb24gU3MoaSxlLHQpe2NvbnN0IG49aS5nZXRTaGFkZXJQYXJhbWV0ZXIoZSxpLkNPTVBJTEVfU1RBVFVTKSxyPWkuZ2V0U2hhZGVySW5mb0xvZyhlKS50cmltKCk7aWYobiYmcj09PSIiKXJldHVybiIiO2NvbnN0IHM9L0VSUk9SOiAwOihcZCspLy5leGVjKHIpO2lmKHMpe2NvbnN0IGE9cGFyc2VJbnQoc1sxXSk7cmV0dXJuIHQudG9VcHBlckNhc2UoKStgCgpgK3IrYAoKYCtXYyhpLmdldFNoYWRlclNvdXJjZShlKSxhKX1lbHNlIHJldHVybiByfWZ1bmN0aW9uIHFjKGksZSl7Y29uc3QgdD1YYyhlKTtyZXR1cm5bYHZlYzQgJHtpfSggdmVjNCB2YWx1ZSApIHtgLGAJcmV0dXJuICR7dFsxXX0oIHZlYzQoIHZhbHVlLnJnYiAqICR7dFswXX0sIHZhbHVlLmEgKSApO2AsIn0iXS5qb2luKGAKYCl9ZnVuY3Rpb24gWWMoaSxlKXtsZXQgdDtzd2l0Y2goZSl7Y2FzZSAxOnQ9IkxpbmVhciI7YnJlYWs7Y2FzZSAyOnQ9IlJlaW5oYXJkIjticmVhaztjYXNlIDM6dD0iQ2luZW9uIjticmVhaztjYXNlIDQ6dD0iQUNFU0ZpbG1pYyI7YnJlYWs7Y2FzZSA2OnQ9IkFnWCI7YnJlYWs7Y2FzZSA3OnQ9Ik5ldXRyYWwiO2JyZWFrO2Nhc2UgNTp0PSJDdXN0b20iO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFByb2dyYW06IFVuc3VwcG9ydGVkIHRvbmVNYXBwaW5nOiIsZSksdD0iTGluZWFyIn1yZXR1cm4idmVjMyAiK2krIiggdmVjMyBjb2xvciApIHsgcmV0dXJuICIrdCsiVG9uZU1hcHBpbmcoIGNvbG9yICk7IH0ifWNvbnN0IHdpPW5ldyBCO2Z1bmN0aW9uICRjKCl7QmUuZ2V0THVtaW5hbmNlQ29lZmZpY2llbnRzKHdpKTtjb25zdCBpPXdpLngudG9GaXhlZCg0KSxlPXdpLnkudG9GaXhlZCg0KSx0PXdpLnoudG9GaXhlZCg0KTtyZXR1cm5bImZsb2F0IGx1bWluYW5jZSggY29uc3QgaW4gdmVjMyByZ2IgKSB7IixgCWNvbnN0IHZlYzMgd2VpZ2h0cyA9IHZlYzMoICR7aX0sICR7ZX0sICR7dH0gKTtgLCIJcmV0dXJuIGRvdCggd2VpZ2h0cywgcmdiICk7IiwifSJdLmpvaW4oYApgKX1mdW5jdGlvbiBaYyhpKXtyZXR1cm5baS5leHRlbnNpb25DbGlwQ3VsbERpc3RhbmNlPyIjZXh0ZW5zaW9uIEdMX0FOR0xFX2NsaXBfY3VsbF9kaXN0YW5jZSA6IHJlcXVpcmUiOiIiLGkuZXh0ZW5zaW9uTXVsdGlEcmF3PyIjZXh0ZW5zaW9uIEdMX0FOR0xFX211bHRpX2RyYXcgOiByZXF1aXJlIjoiIl0uZmlsdGVyKGVpKS5qb2luKGAKYCl9ZnVuY3Rpb24gS2MoaSl7Y29uc3QgZT1bXTtmb3IoY29uc3QgdCBpbiBpKXtjb25zdCBuPWlbdF07biE9PSExJiZlLnB1c2goIiNkZWZpbmUgIit0KyIgIituKX1yZXR1cm4gZS5qb2luKGAKYCl9ZnVuY3Rpb24gamMoaSxlKXtjb25zdCB0PXt9LG49aS5nZXRQcm9ncmFtUGFyYW1ldGVyKGUsaS5BQ1RJVkVfQVRUUklCVVRFUyk7Zm9yKGxldCByPTA7cjxuO3IrKyl7Y29uc3Qgcz1pLmdldEFjdGl2ZUF0dHJpYihlLHIpLGE9cy5uYW1lO2xldCBvPTE7cy50eXBlPT09aS5GTE9BVF9NQVQyJiYobz0yKSxzLnR5cGU9PT1pLkZMT0FUX01BVDMmJihvPTMpLHMudHlwZT09PWkuRkxPQVRfTUFUNCYmKG89NCksdFthXT17dHlwZTpzLnR5cGUsbG9jYXRpb246aS5nZXRBdHRyaWJMb2NhdGlvbihlLGEpLGxvY2F0aW9uU2l6ZTpvfX1yZXR1cm4gdH1mdW5jdGlvbiBlaShpKXtyZXR1cm4gaSE9PSIifWZ1bmN0aW9uIEVzKGksZSl7Y29uc3QgdD1lLm51bVNwb3RMaWdodFNoYWRvd3MrZS5udW1TcG90TGlnaHRNYXBzLWUubnVtU3BvdExpZ2h0U2hhZG93c1dpdGhNYXBzO3JldHVybiBpLnJlcGxhY2UoL05VTV9ESVJfTElHSFRTL2csZS5udW1EaXJMaWdodHMpLnJlcGxhY2UoL05VTV9TUE9UX0xJR0hUUy9nLGUubnVtU3BvdExpZ2h0cykucmVwbGFjZSgvTlVNX1NQT1RfTElHSFRfTUFQUy9nLGUubnVtU3BvdExpZ2h0TWFwcykucmVwbGFjZSgvTlVNX1NQT1RfTElHSFRfQ09PUkRTL2csdCkucmVwbGFjZSgvTlVNX1JFQ1RfQVJFQV9MSUdIVFMvZyxlLm51bVJlY3RBcmVhTGlnaHRzKS5yZXBsYWNlKC9OVU1fUE9JTlRfTElHSFRTL2csZS5udW1Qb2ludExpZ2h0cykucmVwbGFjZSgvTlVNX0hFTUlfTElHSFRTL2csZS5udW1IZW1pTGlnaHRzKS5yZXBsYWNlKC9OVU1fRElSX0xJR0hUX1NIQURPV1MvZyxlLm51bURpckxpZ2h0U2hhZG93cykucmVwbGFjZSgvTlVNX1NQT1RfTElHSFRfU0hBRE9XU19XSVRIX01BUFMvZyxlLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcykucmVwbGFjZSgvTlVNX1NQT1RfTElHSFRfU0hBRE9XUy9nLGUubnVtU3BvdExpZ2h0U2hhZG93cykucmVwbGFjZSgvTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MvZyxlLm51bVBvaW50TGlnaHRTaGFkb3dzKX1mdW5jdGlvbiB5cyhpLGUpe3JldHVybiBpLnJlcGxhY2UoL05VTV9DTElQUElOR19QTEFORVMvZyxlLm51bUNsaXBwaW5nUGxhbmVzKS5yZXBsYWNlKC9VTklPTl9DTElQUElOR19QTEFORVMvZyxlLm51bUNsaXBwaW5nUGxhbmVzLWUubnVtQ2xpcEludGVyc2VjdGlvbil9Y29uc3QgSmM9L15bIFx0XSojaW5jbHVkZSArPChbXHdcZC4vXSspPi9nbTtmdW5jdGlvbiBkcihpKXtyZXR1cm4gaS5yZXBsYWNlKEpjLGV1KX1jb25zdCBRYz1uZXcgTWFwO2Z1bmN0aW9uIGV1KGksZSl7bGV0IHQ9UGVbZV07aWYodD09PXZvaWQgMCl7Y29uc3Qgbj1RYy5nZXQoZSk7aWYobiE9PXZvaWQgMCl0PVBlW25dLGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogU2hhZGVyIGNodW5rICIlcyIgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlICIlcyIgaW5zdGVhZC4nLGUsbik7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIkNhbiBub3QgcmVzb2x2ZSAjaW5jbHVkZSA8IitlKyI+Iil9cmV0dXJuIGRyKHQpfWNvbnN0IHR1PS8jcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XHMrZm9yXHMqXChccyppbnRccytpXHMqPVxzKihcZCspXHMqO1xzKmlccyo8XHMqKFxkKylccyo7XHMqaVxzKlwrXCtccypcKVxzKnsoW1xzXFNdKz8pfVxzKyNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kL2c7ZnVuY3Rpb24gVHMoaSl7cmV0dXJuIGkucmVwbGFjZSh0dSxudSl9ZnVuY3Rpb24gbnUoaSxlLHQsbil7bGV0IHI9IiI7Zm9yKGxldCBzPXBhcnNlSW50KGUpO3M8cGFyc2VJbnQodCk7cysrKXIrPW4ucmVwbGFjZSgvXFtccyppXHMqXF0vZywiWyAiK3MrIiBdIikucmVwbGFjZSgvVU5ST0xMRURfTE9PUF9JTkRFWC9nLHMpO3JldHVybiByfWZ1bmN0aW9uIEFzKGkpe2xldCBlPWBwcmVjaXNpb24gJHtpLnByZWNpc2lvbn0gZmxvYXQ7CglwcmVjaXNpb24gJHtpLnByZWNpc2lvbn0gaW50OwoJcHJlY2lzaW9uICR7aS5wcmVjaXNpb259IHNhbXBsZXIyRDsKCXByZWNpc2lvbiAke2kucHJlY2lzaW9ufSBzYW1wbGVyQ3ViZTsKCXByZWNpc2lvbiAke2kucHJlY2lzaW9ufSBzYW1wbGVyM0Q7CglwcmVjaXNpb24gJHtpLnByZWNpc2lvbn0gc2FtcGxlcjJEQXJyYXk7CglwcmVjaXNpb24gJHtpLnByZWNpc2lvbn0gc2FtcGxlcjJEU2hhZG93OwoJcHJlY2lzaW9uICR7aS5wcmVjaXNpb259IHNhbXBsZXJDdWJlU2hhZG93OwoJcHJlY2lzaW9uICR7aS5wcmVjaXNpb259IHNhbXBsZXIyREFycmF5U2hhZG93OwoJcHJlY2lzaW9uICR7aS5wcmVjaXNpb259IGlzYW1wbGVyMkQ7CglwcmVjaXNpb24gJHtpLnByZWNpc2lvbn0gaXNhbXBsZXIzRDsKCXByZWNpc2lvbiAke2kucHJlY2lzaW9ufSBpc2FtcGxlckN1YmU7CglwcmVjaXNpb24gJHtpLnByZWNpc2lvbn0gaXNhbXBsZXIyREFycmF5OwoJcHJlY2lzaW9uICR7aS5wcmVjaXNpb259IHVzYW1wbGVyMkQ7CglwcmVjaXNpb24gJHtpLnByZWNpc2lvbn0gdXNhbXBsZXIzRDsKCXByZWNpc2lvbiAke2kucHJlY2lzaW9ufSB1c2FtcGxlckN1YmU7CglwcmVjaXNpb24gJHtpLnByZWNpc2lvbn0gdXNhbXBsZXIyREFycmF5OwoJYDtyZXR1cm4gaS5wcmVjaXNpb249PT0iaGlnaHAiP2UrPWAKI2RlZmluZSBISUdIX1BSRUNJU0lPTmA6aS5wcmVjaXNpb249PT0ibWVkaXVtcCI/ZSs9YAojZGVmaW5lIE1FRElVTV9QUkVDSVNJT05gOmkucHJlY2lzaW9uPT09Imxvd3AiJiYoZSs9YAojZGVmaW5lIExPV19QUkVDSVNJT05gKSxlfWZ1bmN0aW9uIGl1KGkpe2xldCBlPSJTSEFET1dNQVBfVFlQRV9CQVNJQyI7cmV0dXJuIGkuc2hhZG93TWFwVHlwZT09PTE/ZT0iU0hBRE9XTUFQX1RZUEVfUENGIjppLnNoYWRvd01hcFR5cGU9PT0yP2U9IlNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIjppLnNoYWRvd01hcFR5cGU9PT0zJiYoZT0iU0hBRE9XTUFQX1RZUEVfVlNNIiksZX1mdW5jdGlvbiBydShpKXtsZXQgZT0iRU5WTUFQX1RZUEVfQ1VCRSI7aWYoaS5lbnZNYXApc3dpdGNoKGkuZW52TWFwTW9kZSl7Y2FzZSAzMDE6Y2FzZSAzMDI6ZT0iRU5WTUFQX1RZUEVfQ1VCRSI7YnJlYWs7Y2FzZSAzMDY6ZT0iRU5WTUFQX1RZUEVfQ1VCRV9VViI7YnJlYWt9cmV0dXJuIGV9ZnVuY3Rpb24gc3UoaSl7bGV0IGU9IkVOVk1BUF9NT0RFX1JFRkxFQ1RJT04iO2lmKGkuZW52TWFwKXN3aXRjaChpLmVudk1hcE1vZGUpe2Nhc2UgMzAyOmU9IkVOVk1BUF9NT0RFX1JFRlJBQ1RJT04iO2JyZWFrfXJldHVybiBlfWZ1bmN0aW9uIGF1KGkpe2xldCBlPSJFTlZNQVBfQkxFTkRJTkdfTk9ORSI7aWYoaS5lbnZNYXApc3dpdGNoKGkuY29tYmluZSl7Y2FzZSAwOmU9IkVOVk1BUF9CTEVORElOR19NVUxUSVBMWSI7YnJlYWs7Y2FzZSAxOmU9IkVOVk1BUF9CTEVORElOR19NSVgiO2JyZWFrO2Nhc2UgMjplPSJFTlZNQVBfQkxFTkRJTkdfQUREIjticmVha31yZXR1cm4gZX1mdW5jdGlvbiBvdShpKXtjb25zdCBlPWkuZW52TWFwQ3ViZVVWSGVpZ2h0O2lmKGU9PT1udWxsKXJldHVybiBudWxsO2NvbnN0IHQ9TWF0aC5sb2cyKGUpLTIsbj0xL2U7cmV0dXJue3RleGVsV2lkdGg6MS8oMypNYXRoLm1heChNYXRoLnBvdygyLHQpLDcqMTYpKSx0ZXhlbEhlaWdodDpuLG1heE1pcDp0fX1mdW5jdGlvbiBsdShpLGUsdCxuKXtjb25zdCByPWkuZ2V0Q29udGV4dCgpLHM9dC5kZWZpbmVzO2xldCBhPXQudmVydGV4U2hhZGVyLG89dC5mcmFnbWVudFNoYWRlcjtjb25zdCBsPWl1KHQpLGM9cnUodCksdT1zdSh0KSxoPWF1KHQpLGY9b3UodCkscD1aYyh0KSxfPUtjKHMpLHg9ci5jcmVhdGVQcm9ncmFtKCk7bGV0IG0sZCxBPXQuZ2xzbFZlcnNpb24/IiN2ZXJzaW9uICIrdC5nbHNsVmVyc2lvbitgCmA6IiI7dC5pc1Jhd1NoYWRlck1hdGVyaWFsPyhtPVsiI2RlZmluZSBTSEFERVJfVFlQRSAiK3Quc2hhZGVyVHlwZSwiI2RlZmluZSBTSEFERVJfTkFNRSAiK3Quc2hhZGVyTmFtZSxfXS5maWx0ZXIoZWkpLmpvaW4oYApgKSxtLmxlbmd0aD4wJiYobSs9YApgKSxkPVsiI2RlZmluZSBTSEFERVJfVFlQRSAiK3Quc2hhZGVyVHlwZSwiI2RlZmluZSBTSEFERVJfTkFNRSAiK3Quc2hhZGVyTmFtZSxfXS5maWx0ZXIoZWkpLmpvaW4oYApgKSxkLmxlbmd0aD4wJiYoZCs9YApgKSk6KG09W0FzKHQpLCIjZGVmaW5lIFNIQURFUl9UWVBFICIrdC5zaGFkZXJUeXBlLCIjZGVmaW5lIFNIQURFUl9OQU1FICIrdC5zaGFkZXJOYW1lLF8sdC5leHRlbnNpb25DbGlwQ3VsbERpc3RhbmNlPyIjZGVmaW5lIFVTRV9DTElQX0RJU1RBTkNFIjoiIix0LmJhdGNoaW5nPyIjZGVmaW5lIFVTRV9CQVRDSElORyI6IiIsdC5iYXRjaGluZ0NvbG9yPyIjZGVmaW5lIFVTRV9CQVRDSElOR19DT0xPUiI6IiIsdC5pbnN0YW5jaW5nPyIjZGVmaW5lIFVTRV9JTlNUQU5DSU5HIjoiIix0Lmluc3RhbmNpbmdDb2xvcj8iI2RlZmluZSBVU0VfSU5TVEFOQ0lOR19DT0xPUiI6IiIsdC5pbnN0YW5jaW5nTW9ycGg/IiNkZWZpbmUgVVNFX0lOU1RBTkNJTkdfTU9SUEgiOiIiLHQudXNlRm9nJiZ0LmZvZz8iI2RlZmluZSBVU0VfRk9HIjoiIix0LnVzZUZvZyYmdC5mb2dFeHAyPyIjZGVmaW5lIEZPR19FWFAyIjoiIix0Lm1hcD8iI2RlZmluZSBVU0VfTUFQIjoiIix0LmVudk1hcD8iI2RlZmluZSBVU0VfRU5WTUFQIjoiIix0LmVudk1hcD8iI2RlZmluZSAiK3U6IiIsdC5saWdodE1hcD8iI2RlZmluZSBVU0VfTElHSFRNQVAiOiIiLHQuYW9NYXA/IiNkZWZpbmUgVVNFX0FPTUFQIjoiIix0LmJ1bXBNYXA/IiNkZWZpbmUgVVNFX0JVTVBNQVAiOiIiLHQubm9ybWFsTWFwPyIjZGVmaW5lIFVTRV9OT1JNQUxNQVAiOiIiLHQubm9ybWFsTWFwT2JqZWN0U3BhY2U/IiNkZWZpbmUgVVNFX05PUk1BTE1BUF9PQkpFQ1RTUEFDRSI6IiIsdC5ub3JtYWxNYXBUYW5nZW50U3BhY2U/IiNkZWZpbmUgVVNFX05PUk1BTE1BUF9UQU5HRU5UU1BBQ0UiOiIiLHQuZGlzcGxhY2VtZW50TWFwPyIjZGVmaW5lIFVTRV9ESVNQTEFDRU1FTlRNQVAiOiIiLHQuZW1pc3NpdmVNYXA/IiNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQIjoiIix0LmFuaXNvdHJvcHk/IiNkZWZpbmUgVVNFX0FOSVNPVFJPUFkiOiIiLHQuYW5pc290cm9weU1hcD8iI2RlZmluZSBVU0VfQU5JU09UUk9QWU1BUCI6IiIsdC5jbGVhcmNvYXRNYXA/IiNkZWZpbmUgVVNFX0NMRUFSQ09BVE1BUCI6IiIsdC5jbGVhcmNvYXRSb3VnaG5lc3NNYXA/IiNkZWZpbmUgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAiOiIiLHQuY2xlYXJjb2F0Tm9ybWFsTWFwPyIjZGVmaW5lIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQIjoiIix0LmlyaWRlc2NlbmNlTWFwPyIjZGVmaW5lIFVTRV9JUklERVNDRU5DRU1BUCI6IiIsdC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcD8iI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQIjoiIix0LnNwZWN1bGFyTWFwPyIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCI6IiIsdC5zcGVjdWxhckNvbG9yTWFwPyIjZGVmaW5lIFVTRV9TUEVDVUxBUl9DT0xPUk1BUCI6IiIsdC5zcGVjdWxhckludGVuc2l0eU1hcD8iI2RlZmluZSBVU0VfU1BFQ1VMQVJfSU5URU5TSVRZTUFQIjoiIix0LnJvdWdobmVzc01hcD8iI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQIjoiIix0Lm1ldGFsbmVzc01hcD8iI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQIjoiIix0LmFscGhhTWFwPyIjZGVmaW5lIFVTRV9BTFBIQU1BUCI6IiIsdC5hbHBoYUhhc2g/IiNkZWZpbmUgVVNFX0FMUEhBSEFTSCI6IiIsdC50cmFuc21pc3Npb24/IiNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTiI6IiIsdC50cmFuc21pc3Npb25NYXA/IiNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTk1BUCI6IiIsdC50aGlja25lc3NNYXA/IiNkZWZpbmUgVVNFX1RISUNLTkVTU01BUCI6IiIsdC5zaGVlbkNvbG9yTWFwPyIjZGVmaW5lIFVTRV9TSEVFTl9DT0xPUk1BUCI6IiIsdC5zaGVlblJvdWdobmVzc01hcD8iI2RlZmluZSBVU0VfU0hFRU5fUk9VR0hORVNTTUFQIjoiIix0Lm1hcFV2PyIjZGVmaW5lIE1BUF9VViAiK3QubWFwVXY6IiIsdC5hbHBoYU1hcFV2PyIjZGVmaW5lIEFMUEhBTUFQX1VWICIrdC5hbHBoYU1hcFV2OiIiLHQubGlnaHRNYXBVdj8iI2RlZmluZSBMSUdIVE1BUF9VViAiK3QubGlnaHRNYXBVdjoiIix0LmFvTWFwVXY/IiNkZWZpbmUgQU9NQVBfVVYgIit0LmFvTWFwVXY6IiIsdC5lbWlzc2l2ZU1hcFV2PyIjZGVmaW5lIEVNSVNTSVZFTUFQX1VWICIrdC5lbWlzc2l2ZU1hcFV2OiIiLHQuYnVtcE1hcFV2PyIjZGVmaW5lIEJVTVBNQVBfVVYgIit0LmJ1bXBNYXBVdjoiIix0Lm5vcm1hbE1hcFV2PyIjZGVmaW5lIE5PUk1BTE1BUF9VViAiK3Qubm9ybWFsTWFwVXY6IiIsdC5kaXNwbGFjZW1lbnRNYXBVdj8iI2RlZmluZSBESVNQTEFDRU1FTlRNQVBfVVYgIit0LmRpc3BsYWNlbWVudE1hcFV2OiIiLHQubWV0YWxuZXNzTWFwVXY/IiNkZWZpbmUgTUVUQUxORVNTTUFQX1VWICIrdC5tZXRhbG5lc3NNYXBVdjoiIix0LnJvdWdobmVzc01hcFV2PyIjZGVmaW5lIFJPVUdITkVTU01BUF9VViAiK3Qucm91Z2huZXNzTWFwVXY6IiIsdC5hbmlzb3Ryb3B5TWFwVXY/IiNkZWZpbmUgQU5JU09UUk9QWU1BUF9VViAiK3QuYW5pc290cm9weU1hcFV2OiIiLHQuY2xlYXJjb2F0TWFwVXY/IiNkZWZpbmUgQ0xFQVJDT0FUTUFQX1VWICIrdC5jbGVhcmNvYXRNYXBVdjoiIix0LmNsZWFyY29hdE5vcm1hbE1hcFV2PyIjZGVmaW5lIENMRUFSQ09BVF9OT1JNQUxNQVBfVVYgIit0LmNsZWFyY29hdE5vcm1hbE1hcFV2OiIiLHQuY2xlYXJjb2F0Um91Z2huZXNzTWFwVXY/IiNkZWZpbmUgQ0xFQVJDT0FUX1JPVUdITkVTU01BUF9VViAiK3QuY2xlYXJjb2F0Um91Z2huZXNzTWFwVXY6IiIsdC5pcmlkZXNjZW5jZU1hcFV2PyIjZGVmaW5lIElSSURFU0NFTkNFTUFQX1VWICIrdC5pcmlkZXNjZW5jZU1hcFV2OiIiLHQuaXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdj8iI2RlZmluZSBJUklERVNDRU5DRV9USElDS05FU1NNQVBfVVYgIit0LmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXY6IiIsdC5zaGVlbkNvbG9yTWFwVXY/IiNkZWZpbmUgU0hFRU5fQ09MT1JNQVBfVVYgIit0LnNoZWVuQ29sb3JNYXBVdjoiIix0LnNoZWVuUm91Z2huZXNzTWFwVXY/IiNkZWZpbmUgU0hFRU5fUk9VR0hORVNTTUFQX1VWICIrdC5zaGVlblJvdWdobmVzc01hcFV2OiIiLHQuc3BlY3VsYXJNYXBVdj8iI2RlZmluZSBTUEVDVUxBUk1BUF9VViAiK3Quc3BlY3VsYXJNYXBVdjoiIix0LnNwZWN1bGFyQ29sb3JNYXBVdj8iI2RlZmluZSBTUEVDVUxBUl9DT0xPUk1BUF9VViAiK3Quc3BlY3VsYXJDb2xvck1hcFV2OiIiLHQuc3BlY3VsYXJJbnRlbnNpdHlNYXBVdj8iI2RlZmluZSBTUEVDVUxBUl9JTlRFTlNJVFlNQVBfVVYgIit0LnNwZWN1bGFySW50ZW5zaXR5TWFwVXY6IiIsdC50cmFuc21pc3Npb25NYXBVdj8iI2RlZmluZSBUUkFOU01JU1NJT05NQVBfVVYgIit0LnRyYW5zbWlzc2lvbk1hcFV2OiIiLHQudGhpY2tuZXNzTWFwVXY/IiNkZWZpbmUgVEhJQ0tORVNTTUFQX1VWICIrdC50aGlja25lc3NNYXBVdjoiIix0LnZlcnRleFRhbmdlbnRzJiZ0LmZsYXRTaGFkaW5nPT09ITE/IiNkZWZpbmUgVVNFX1RBTkdFTlQiOiIiLHQudmVydGV4Q29sb3JzPyIjZGVmaW5lIFVTRV9DT0xPUiI6IiIsdC52ZXJ0ZXhBbHBoYXM/IiNkZWZpbmUgVVNFX0NPTE9SX0FMUEhBIjoiIix0LnZlcnRleFV2MXM/IiNkZWZpbmUgVVNFX1VWMSI6IiIsdC52ZXJ0ZXhVdjJzPyIjZGVmaW5lIFVTRV9VVjIiOiIiLHQudmVydGV4VXYzcz8iI2RlZmluZSBVU0VfVVYzIjoiIix0LnBvaW50c1V2cz8iI2RlZmluZSBVU0VfUE9JTlRTX1VWIjoiIix0LmZsYXRTaGFkaW5nPyIjZGVmaW5lIEZMQVRfU0hBREVEIjoiIix0LnNraW5uaW5nPyIjZGVmaW5lIFVTRV9TS0lOTklORyI6IiIsdC5tb3JwaFRhcmdldHM/IiNkZWZpbmUgVVNFX01PUlBIVEFSR0VUUyI6IiIsdC5tb3JwaE5vcm1hbHMmJnQuZmxhdFNoYWRpbmc9PT0hMT8iI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTIjoiIix0Lm1vcnBoQ29sb3JzPyIjZGVmaW5lIFVTRV9NT1JQSENPTE9SUyI6IiIsdC5tb3JwaFRhcmdldHNDb3VudD4wPyIjZGVmaW5lIE1PUlBIVEFSR0VUU19URVhUVVJFX1NUUklERSAiK3QubW9ycGhUZXh0dXJlU3RyaWRlOiIiLHQubW9ycGhUYXJnZXRzQ291bnQ+MD8iI2RlZmluZSBNT1JQSFRBUkdFVFNfQ09VTlQgIit0Lm1vcnBoVGFyZ2V0c0NvdW50OiIiLHQuZG91YmxlU2lkZWQ/IiNkZWZpbmUgRE9VQkxFX1NJREVEIjoiIix0LmZsaXBTaWRlZD8iI2RlZmluZSBGTElQX1NJREVEIjoiIix0LnNoYWRvd01hcEVuYWJsZWQ/IiNkZWZpbmUgVVNFX1NIQURPV01BUCI6IiIsdC5zaGFkb3dNYXBFbmFibGVkPyIjZGVmaW5lICIrbDoiIix0LnNpemVBdHRlbnVhdGlvbj8iI2RlZmluZSBVU0VfU0laRUFUVEVOVUFUSU9OIjoiIix0Lm51bUxpZ2h0UHJvYmVzPjA/IiNkZWZpbmUgVVNFX0xJR0hUX1BST0JFUyI6IiIsdC5sb2dhcml0aG1pY0RlcHRoQnVmZmVyPyIjZGVmaW5lIFVTRV9MT0dERVBUSEJVRiI6IiIsdC5yZXZlcnNlRGVwdGhCdWZmZXI/IiNkZWZpbmUgVVNFX1JFVkVSU0VERVBUSEJVRiI6IiIsInVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDsiLCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4OyIsInVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OyIsInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4OyIsInVuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7IiwidW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOyIsInVuaWZvcm0gYm9vbCBpc09ydGhvZ3JhcGhpYzsiLCIjaWZkZWYgVVNFX0lOU1RBTkNJTkciLCIJYXR0cmlidXRlIG1hdDQgaW5zdGFuY2VNYXRyaXg7IiwiI2VuZGlmIiwiI2lmZGVmIFVTRV9JTlNUQU5DSU5HX0NPTE9SIiwiCWF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlQ29sb3I7IiwiI2VuZGlmIiwiI2lmZGVmIFVTRV9JTlNUQU5DSU5HX01PUlBIIiwiCXVuaWZvcm0gc2FtcGxlcjJEIG1vcnBoVGV4dHVyZTsiLCIjZW5kaWYiLCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjsiLCJhdHRyaWJ1dGUgdmVjMyBub3JtYWw7IiwiYXR0cmlidXRlIHZlYzIgdXY7IiwiI2lmZGVmIFVTRV9VVjEiLCIJYXR0cmlidXRlIHZlYzIgdXYxOyIsIiNlbmRpZiIsIiNpZmRlZiBVU0VfVVYyIiwiCWF0dHJpYnV0ZSB2ZWMyIHV2MjsiLCIjZW5kaWYiLCIjaWZkZWYgVVNFX1VWMyIsIglhdHRyaWJ1dGUgdmVjMiB1djM7IiwiI2VuZGlmIiwiI2lmZGVmIFVTRV9UQU5HRU5UIiwiCWF0dHJpYnV0ZSB2ZWM0IHRhbmdlbnQ7IiwiI2VuZGlmIiwiI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApIiwiCWF0dHJpYnV0ZSB2ZWM0IGNvbG9yOyIsIiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApIiwiCWF0dHJpYnV0ZSB2ZWMzIGNvbG9yOyIsIiNlbmRpZiIsIiNpZmRlZiBVU0VfU0tJTk5JTkciLCIJYXR0cmlidXRlIHZlYzQgc2tpbkluZGV4OyIsIglhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0OyIsIiNlbmRpZiIsYApgXS5maWx0ZXIoZWkpLmpvaW4oYApgKSxkPVtBcyh0KSwiI2RlZmluZSBTSEFERVJfVFlQRSAiK3Quc2hhZGVyVHlwZSwiI2RlZmluZSBTSEFERVJfTkFNRSAiK3Quc2hhZGVyTmFtZSxfLHQudXNlRm9nJiZ0LmZvZz8iI2RlZmluZSBVU0VfRk9HIjoiIix0LnVzZUZvZyYmdC5mb2dFeHAyPyIjZGVmaW5lIEZPR19FWFAyIjoiIix0LmFscGhhVG9Db3ZlcmFnZT8iI2RlZmluZSBBTFBIQV9UT19DT1ZFUkFHRSI6IiIsdC5tYXA/IiNkZWZpbmUgVVNFX01BUCI6IiIsdC5tYXRjYXA/IiNkZWZpbmUgVVNFX01BVENBUCI6IiIsdC5lbnZNYXA/IiNkZWZpbmUgVVNFX0VOVk1BUCI6IiIsdC5lbnZNYXA/IiNkZWZpbmUgIitjOiIiLHQuZW52TWFwPyIjZGVmaW5lICIrdToiIix0LmVudk1hcD8iI2RlZmluZSAiK2g6IiIsZj8iI2RlZmluZSBDVUJFVVZfVEVYRUxfV0lEVEggIitmLnRleGVsV2lkdGg6IiIsZj8iI2RlZmluZSBDVUJFVVZfVEVYRUxfSEVJR0hUICIrZi50ZXhlbEhlaWdodDoiIixmPyIjZGVmaW5lIENVQkVVVl9NQVhfTUlQICIrZi5tYXhNaXArIi4wIjoiIix0LmxpZ2h0TWFwPyIjZGVmaW5lIFVTRV9MSUdIVE1BUCI6IiIsdC5hb01hcD8iI2RlZmluZSBVU0VfQU9NQVAiOiIiLHQuYnVtcE1hcD8iI2RlZmluZSBVU0VfQlVNUE1BUCI6IiIsdC5ub3JtYWxNYXA/IiNkZWZpbmUgVVNFX05PUk1BTE1BUCI6IiIsdC5ub3JtYWxNYXBPYmplY3RTcGFjZT8iI2RlZmluZSBVU0VfTk9STUFMTUFQX09CSkVDVFNQQUNFIjoiIix0Lm5vcm1hbE1hcFRhbmdlbnRTcGFjZT8iI2RlZmluZSBVU0VfTk9STUFMTUFQX1RBTkdFTlRTUEFDRSI6IiIsdC5lbWlzc2l2ZU1hcD8iI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAiOiIiLHQuYW5pc290cm9weT8iI2RlZmluZSBVU0VfQU5JU09UUk9QWSI6IiIsdC5hbmlzb3Ryb3B5TWFwPyIjZGVmaW5lIFVTRV9BTklTT1RST1BZTUFQIjoiIix0LmNsZWFyY29hdD8iI2RlZmluZSBVU0VfQ0xFQVJDT0FUIjoiIix0LmNsZWFyY29hdE1hcD8iI2RlZmluZSBVU0VfQ0xFQVJDT0FUTUFQIjoiIix0LmNsZWFyY29hdFJvdWdobmVzc01hcD8iI2RlZmluZSBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUCI6IiIsdC5jbGVhcmNvYXROb3JtYWxNYXA/IiNkZWZpbmUgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAiOiIiLHQuZGlzcGVyc2lvbj8iI2RlZmluZSBVU0VfRElTUEVSU0lPTiI6IiIsdC5pcmlkZXNjZW5jZT8iI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0UiOiIiLHQuaXJpZGVzY2VuY2VNYXA/IiNkZWZpbmUgVVNFX0lSSURFU0NFTkNFTUFQIjoiIix0LmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwPyIjZGVmaW5lIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVAiOiIiLHQuc3BlY3VsYXJNYXA/IiNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQIjoiIix0LnNwZWN1bGFyQ29sb3JNYXA/IiNkZWZpbmUgVVNFX1NQRUNVTEFSX0NPTE9STUFQIjoiIix0LnNwZWN1bGFySW50ZW5zaXR5TWFwPyIjZGVmaW5lIFVTRV9TUEVDVUxBUl9JTlRFTlNJVFlNQVAiOiIiLHQucm91Z2huZXNzTWFwPyIjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAiOiIiLHQubWV0YWxuZXNzTWFwPyIjZGVmaW5lIFVTRV9NRVRBTE5FU1NNQVAiOiIiLHQuYWxwaGFNYXA/IiNkZWZpbmUgVVNFX0FMUEhBTUFQIjoiIix0LmFscGhhVGVzdD8iI2RlZmluZSBVU0VfQUxQSEFURVNUIjoiIix0LmFscGhhSGFzaD8iI2RlZmluZSBVU0VfQUxQSEFIQVNIIjoiIix0LnNoZWVuPyIjZGVmaW5lIFVTRV9TSEVFTiI6IiIsdC5zaGVlbkNvbG9yTWFwPyIjZGVmaW5lIFVTRV9TSEVFTl9DT0xPUk1BUCI6IiIsdC5zaGVlblJvdWdobmVzc01hcD8iI2RlZmluZSBVU0VfU0hFRU5fUk9VR0hORVNTTUFQIjoiIix0LnRyYW5zbWlzc2lvbj8iI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OIjoiIix0LnRyYW5zbWlzc2lvbk1hcD8iI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OTUFQIjoiIix0LnRoaWNrbmVzc01hcD8iI2RlZmluZSBVU0VfVEhJQ0tORVNTTUFQIjoiIix0LnZlcnRleFRhbmdlbnRzJiZ0LmZsYXRTaGFkaW5nPT09ITE/IiNkZWZpbmUgVVNFX1RBTkdFTlQiOiIiLHQudmVydGV4Q29sb3JzfHx0Lmluc3RhbmNpbmdDb2xvcnx8dC5iYXRjaGluZ0NvbG9yPyIjZGVmaW5lIFVTRV9DT0xPUiI6IiIsdC52ZXJ0ZXhBbHBoYXM/IiNkZWZpbmUgVVNFX0NPTE9SX0FMUEhBIjoiIix0LnZlcnRleFV2MXM/IiNkZWZpbmUgVVNFX1VWMSI6IiIsdC52ZXJ0ZXhVdjJzPyIjZGVmaW5lIFVTRV9VVjIiOiIiLHQudmVydGV4VXYzcz8iI2RlZmluZSBVU0VfVVYzIjoiIix0LnBvaW50c1V2cz8iI2RlZmluZSBVU0VfUE9JTlRTX1VWIjoiIix0LmdyYWRpZW50TWFwPyIjZGVmaW5lIFVTRV9HUkFESUVOVE1BUCI6IiIsdC5mbGF0U2hhZGluZz8iI2RlZmluZSBGTEFUX1NIQURFRCI6IiIsdC5kb3VibGVTaWRlZD8iI2RlZmluZSBET1VCTEVfU0lERUQiOiIiLHQuZmxpcFNpZGVkPyIjZGVmaW5lIEZMSVBfU0lERUQiOiIiLHQuc2hhZG93TWFwRW5hYmxlZD8iI2RlZmluZSBVU0VfU0hBRE9XTUFQIjoiIix0LnNoYWRvd01hcEVuYWJsZWQ/IiNkZWZpbmUgIitsOiIiLHQucHJlbXVsdGlwbGllZEFscGhhPyIjZGVmaW5lIFBSRU1VTFRJUExJRURfQUxQSEEiOiIiLHQubnVtTGlnaHRQcm9iZXM+MD8iI2RlZmluZSBVU0VfTElHSFRfUFJPQkVTIjoiIix0LmRlY29kZVZpZGVvVGV4dHVyZT8iI2RlZmluZSBERUNPREVfVklERU9fVEVYVFVSRSI6IiIsdC5kZWNvZGVWaWRlb1RleHR1cmVFbWlzc2l2ZT8iI2RlZmluZSBERUNPREVfVklERU9fVEVYVFVSRV9FTUlTU0lWRSI6IiIsdC5sb2dhcml0aG1pY0RlcHRoQnVmZmVyPyIjZGVmaW5lIFVTRV9MT0dERVBUSEJVRiI6IiIsdC5yZXZlcnNlRGVwdGhCdWZmZXI/IiNkZWZpbmUgVVNFX1JFVkVSU0VERVBUSEJVRiI6IiIsInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4OyIsInVuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsiLCJ1bmlmb3JtIGJvb2wgaXNPcnRob2dyYXBoaWM7Iix0LnRvbmVNYXBwaW5nIT09MD8iI2RlZmluZSBUT05FX01BUFBJTkciOiIiLHQudG9uZU1hcHBpbmchPT0wP1BlLnRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQ6IiIsdC50b25lTWFwcGluZyE9PTA/WWMoInRvbmVNYXBwaW5nIix0LnRvbmVNYXBwaW5nKToiIix0LmRpdGhlcmluZz8iI2RlZmluZSBESVRIRVJJTkciOiIiLHQub3BhcXVlPyIjZGVmaW5lIE9QQVFVRSI6IiIsUGUuY29sb3JzcGFjZV9wYXJzX2ZyYWdtZW50LHFjKCJsaW5lYXJUb091dHB1dFRleGVsIix0Lm91dHB1dENvbG9yU3BhY2UpLCRjKCksdC51c2VEZXB0aFBhY2tpbmc/IiNkZWZpbmUgREVQVEhfUEFDS0lORyAiK3QuZGVwdGhQYWNraW5nOiIiLGAKYF0uZmlsdGVyKGVpKS5qb2luKGAKYCkpLGE9ZHIoYSksYT1FcyhhLHQpLGE9eXMoYSx0KSxvPWRyKG8pLG89RXMobyx0KSxvPXlzKG8sdCksYT1UcyhhKSxvPVRzKG8pLHQuaXNSYXdTaGFkZXJNYXRlcmlhbCE9PSEwJiYoQT1gI3ZlcnNpb24gMzAwIGVzCmAsbT1bcCwiI2RlZmluZSBhdHRyaWJ1dGUgaW4iLCIjZGVmaW5lIHZhcnlpbmcgb3V0IiwiI2RlZmluZSB0ZXh0dXJlMkQgdGV4dHVyZSJdLmpvaW4oYApgKStgCmArbSxkPVsiI2RlZmluZSB2YXJ5aW5nIGluIix0Lmdsc2xWZXJzaW9uPT09eHI/IiI6ImxheW91dChsb2NhdGlvbiA9IDApIG91dCBoaWdocCB2ZWM0IHBjX2ZyYWdDb2xvcjsiLHQuZ2xzbFZlcnNpb249PT14cj8iIjoiI2RlZmluZSBnbF9GcmFnQ29sb3IgcGNfZnJhZ0NvbG9yIiwiI2RlZmluZSBnbF9GcmFnRGVwdGhFWFQgZ2xfRnJhZ0RlcHRoIiwiI2RlZmluZSB0ZXh0dXJlMkQgdGV4dHVyZSIsIiNkZWZpbmUgdGV4dHVyZUN1YmUgdGV4dHVyZSIsIiNkZWZpbmUgdGV4dHVyZTJEUHJvaiB0ZXh0dXJlUHJvaiIsIiNkZWZpbmUgdGV4dHVyZTJETG9kRVhUIHRleHR1cmVMb2QiLCIjZGVmaW5lIHRleHR1cmUyRFByb2pMb2RFWFQgdGV4dHVyZVByb2pMb2QiLCIjZGVmaW5lIHRleHR1cmVDdWJlTG9kRVhUIHRleHR1cmVMb2QiLCIjZGVmaW5lIHRleHR1cmUyREdyYWRFWFQgdGV4dHVyZUdyYWQiLCIjZGVmaW5lIHRleHR1cmUyRFByb2pHcmFkRVhUIHRleHR1cmVQcm9qR3JhZCIsIiNkZWZpbmUgdGV4dHVyZUN1YmVHcmFkRVhUIHRleHR1cmVHcmFkIl0uam9pbihgCmApK2AKYCtkKTtjb25zdCBUPUErbSthLE09QStkK28sRj14cyhyLHIuVkVSVEVYX1NIQURFUixUKSxiPXhzKHIsci5GUkFHTUVOVF9TSEFERVIsTSk7ci5hdHRhY2hTaGFkZXIoeCxGKSxyLmF0dGFjaFNoYWRlcih4LGIpLHQuaW5kZXgwQXR0cmlidXRlTmFtZSE9PXZvaWQgMD9yLmJpbmRBdHRyaWJMb2NhdGlvbih4LDAsdC5pbmRleDBBdHRyaWJ1dGVOYW1lKTp0Lm1vcnBoVGFyZ2V0cz09PSEwJiZyLmJpbmRBdHRyaWJMb2NhdGlvbih4LDAsInBvc2l0aW9uIiksci5saW5rUHJvZ3JhbSh4KTtmdW5jdGlvbiB3KFIpe2lmKGkuZGVidWcuY2hlY2tTaGFkZXJFcnJvcnMpe2NvbnN0IHE9ci5nZXRQcm9ncmFtSW5mb0xvZyh4KS50cmltKCksej1yLmdldFNoYWRlckluZm9Mb2coRikudHJpbSgpLFc9ci5nZXRTaGFkZXJJbmZvTG9nKGIpLnRyaW0oKTtsZXQgSz0hMCxWPSEwO2lmKHIuZ2V0UHJvZ3JhbVBhcmFtZXRlcih4LHIuTElOS19TVEFUVVMpPT09ITEpaWYoSz0hMSx0eXBlb2YgaS5kZWJ1Zy5vblNoYWRlckVycm9yPT0iZnVuY3Rpb24iKWkuZGVidWcub25TaGFkZXJFcnJvcihyLHgsRixiKTtlbHNle2NvbnN0IFE9U3MocixGLCJ2ZXJ0ZXgiKSxIPVNzKHIsYiwiZnJhZ21lbnQiKTtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFByb2dyYW06IFNoYWRlciBFcnJvciAiK3IuZ2V0RXJyb3IoKSsiIC0gVkFMSURBVEVfU1RBVFVTICIrci5nZXRQcm9ncmFtUGFyYW1ldGVyKHgsci5WQUxJREFURV9TVEFUVVMpK2AKCk1hdGVyaWFsIE5hbWU6IGArUi5uYW1lK2AKTWF0ZXJpYWwgVHlwZTogYCtSLnR5cGUrYAoKUHJvZ3JhbSBJbmZvIExvZzogYCtxK2AKYCtRK2AKYCtIKX1lbHNlIHEhPT0iIj9jb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUHJvZ3JhbTogUHJvZ3JhbSBJbmZvIExvZzoiLHEpOih6PT09IiJ8fFc9PT0iIikmJihWPSExKTtWJiYoUi5kaWFnbm9zdGljcz17cnVubmFibGU6Syxwcm9ncmFtTG9nOnEsdmVydGV4U2hhZGVyOntsb2c6eixwcmVmaXg6bX0sZnJhZ21lbnRTaGFkZXI6e2xvZzpXLHByZWZpeDpkfX0pfXIuZGVsZXRlU2hhZGVyKEYpLHIuZGVsZXRlU2hhZGVyKGIpLFU9bmV3IGJpKHIseCksRT1qYyhyLHgpfWxldCBVO3RoaXMuZ2V0VW5pZm9ybXM9ZnVuY3Rpb24oKXtyZXR1cm4gVT09PXZvaWQgMCYmdyh0aGlzKSxVfTtsZXQgRTt0aGlzLmdldEF0dHJpYnV0ZXM9ZnVuY3Rpb24oKXtyZXR1cm4gRT09PXZvaWQgMCYmdyh0aGlzKSxFfTtsZXQgUz10LnJlbmRlcmVyRXh0ZW5zaW9uUGFyYWxsZWxTaGFkZXJDb21waWxlPT09ITE7cmV0dXJuIHRoaXMuaXNSZWFkeT1mdW5jdGlvbigpe3JldHVybiBTPT09ITEmJihTPXIuZ2V0UHJvZ3JhbVBhcmFtZXRlcih4LFZjKSksU30sdGhpcy5kZXN0cm95PWZ1bmN0aW9uKCl7bi5yZWxlYXNlU3RhdGVzT2ZQcm9ncmFtKHRoaXMpLHIuZGVsZXRlUHJvZ3JhbSh4KSx0aGlzLnByb2dyYW09dm9pZCAwfSx0aGlzLnR5cGU9dC5zaGFkZXJUeXBlLHRoaXMubmFtZT10LnNoYWRlck5hbWUsdGhpcy5pZD1rYysrLHRoaXMuY2FjaGVLZXk9ZSx0aGlzLnVzZWRUaW1lcz0xLHRoaXMucHJvZ3JhbT14LHRoaXMudmVydGV4U2hhZGVyPUYsdGhpcy5mcmFnbWVudFNoYWRlcj1iLHRoaXN9bGV0IGN1PTA7Y2xhc3MgdXV7Y29uc3RydWN0b3IoKXt0aGlzLnNoYWRlckNhY2hlPW5ldyBNYXAsdGhpcy5tYXRlcmlhbENhY2hlPW5ldyBNYXB9dXBkYXRlKGUpe2NvbnN0IHQ9ZS52ZXJ0ZXhTaGFkZXIsbj1lLmZyYWdtZW50U2hhZGVyLHI9dGhpcy5fZ2V0U2hhZGVyU3RhZ2UodCkscz10aGlzLl9nZXRTaGFkZXJTdGFnZShuKSxhPXRoaXMuX2dldFNoYWRlckNhY2hlRm9yTWF0ZXJpYWwoZSk7cmV0dXJuIGEuaGFzKHIpPT09ITEmJihhLmFkZChyKSxyLnVzZWRUaW1lcysrKSxhLmhhcyhzKT09PSExJiYoYS5hZGQocykscy51c2VkVGltZXMrKyksdGhpc31yZW1vdmUoZSl7Y29uc3QgdD10aGlzLm1hdGVyaWFsQ2FjaGUuZ2V0KGUpO2Zvcihjb25zdCBuIG9mIHQpbi51c2VkVGltZXMtLSxuLnVzZWRUaW1lcz09PTAmJnRoaXMuc2hhZGVyQ2FjaGUuZGVsZXRlKG4uY29kZSk7cmV0dXJuIHRoaXMubWF0ZXJpYWxDYWNoZS5kZWxldGUoZSksdGhpc31nZXRWZXJ0ZXhTaGFkZXJJRChlKXtyZXR1cm4gdGhpcy5fZ2V0U2hhZGVyU3RhZ2UoZS52ZXJ0ZXhTaGFkZXIpLmlkfWdldEZyYWdtZW50U2hhZGVySUQoZSl7cmV0dXJuIHRoaXMuX2dldFNoYWRlclN0YWdlKGUuZnJhZ21lbnRTaGFkZXIpLmlkfWRpc3Bvc2UoKXt0aGlzLnNoYWRlckNhY2hlLmNsZWFyKCksdGhpcy5tYXRlcmlhbENhY2hlLmNsZWFyKCl9X2dldFNoYWRlckNhY2hlRm9yTWF0ZXJpYWwoZSl7Y29uc3QgdD10aGlzLm1hdGVyaWFsQ2FjaGU7bGV0IG49dC5nZXQoZSk7cmV0dXJuIG49PT12b2lkIDAmJihuPW5ldyBTZXQsdC5zZXQoZSxuKSksbn1fZ2V0U2hhZGVyU3RhZ2UoZSl7Y29uc3QgdD10aGlzLnNoYWRlckNhY2hlO2xldCBuPXQuZ2V0KGUpO3JldHVybiBuPT09dm9pZCAwJiYobj1uZXcgaHUoZSksdC5zZXQoZSxuKSksbn19Y2xhc3MgaHV7Y29uc3RydWN0b3IoZSl7dGhpcy5pZD1jdSsrLHRoaXMuY29kZT1lLHRoaXMudXNlZFRpbWVzPTB9fWZ1bmN0aW9uIGR1KGksZSx0LG4scixzLGEpe2NvbnN0IG89bmV3IEZyLGw9bmV3IHV1LGM9bmV3IFNldCx1PVtdLGg9ci5sb2dhcml0aG1pY0RlcHRoQnVmZmVyLGY9ci52ZXJ0ZXhUZXh0dXJlcztsZXQgcD1yLnByZWNpc2lvbjtjb25zdCBfPXtNZXNoRGVwdGhNYXRlcmlhbDoiZGVwdGgiLE1lc2hEaXN0YW5jZU1hdGVyaWFsOiJkaXN0YW5jZVJHQkEiLE1lc2hOb3JtYWxNYXRlcmlhbDoibm9ybWFsIixNZXNoQmFzaWNNYXRlcmlhbDoiYmFzaWMiLE1lc2hMYW1iZXJ0TWF0ZXJpYWw6ImxhbWJlcnQiLE1lc2hQaG9uZ01hdGVyaWFsOiJwaG9uZyIsTWVzaFRvb25NYXRlcmlhbDoidG9vbiIsTWVzaFN0YW5kYXJkTWF0ZXJpYWw6InBoeXNpY2FsIixNZXNoUGh5c2ljYWxNYXRlcmlhbDoicGh5c2ljYWwiLE1lc2hNYXRjYXBNYXRlcmlhbDoibWF0Y2FwIixMaW5lQmFzaWNNYXRlcmlhbDoiYmFzaWMiLExpbmVEYXNoZWRNYXRlcmlhbDoiZGFzaGVkIixQb2ludHNNYXRlcmlhbDoicG9pbnRzIixTaGFkb3dNYXRlcmlhbDoic2hhZG93IixTcHJpdGVNYXRlcmlhbDoic3ByaXRlIn07ZnVuY3Rpb24geChFKXtyZXR1cm4gYy5hZGQoRSksRT09PTA/InV2IjpgdXYke0V9YH1mdW5jdGlvbiBtKEUsUyxSLHEseil7Y29uc3QgVz1xLmZvZyxLPXouZ2VvbWV0cnksVj1FLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWw/cS5lbnZpcm9ubWVudDpudWxsLFE9KEUuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbD90OmUpLmdldChFLmVudk1hcHx8ViksSD1RJiZRLm1hcHBpbmc9PT0zMDY/US5pbWFnZS5oZWlnaHQ6bnVsbCxpZT1fW0UudHlwZV07RS5wcmVjaXNpb24hPT1udWxsJiYocD1yLmdldE1heFByZWNpc2lvbihFLnByZWNpc2lvbikscCE9PUUucHJlY2lzaW9uJiZjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUHJvZ3JhbS5nZXRQYXJhbWV0ZXJzOiIsRS5wcmVjaXNpb24sIm5vdCBzdXBwb3J0ZWQsIHVzaW5nIixwLCJpbnN0ZWFkLiIpKTtjb25zdCBjZT1LLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbnx8Sy5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsfHxLLm1vcnBoQXR0cmlidXRlcy5jb2xvcix4ZT1jZSE9PXZvaWQgMD9jZS5sZW5ndGg6MDtsZXQgVWU9MDtLLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiE9PXZvaWQgMCYmKFVlPTEpLEsubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCE9PXZvaWQgMCYmKFVlPTIpLEsubW9ycGhBdHRyaWJ1dGVzLmNvbG9yIT09dm9pZCAwJiYoVWU9Myk7bGV0IFllLFgsZWUsX2U7aWYoaWUpe2NvbnN0IFhlPXp0W2llXTtZZT1YZS52ZXJ0ZXhTaGFkZXIsWD1YZS5mcmFnbWVudFNoYWRlcn1lbHNlIFllPUUudmVydGV4U2hhZGVyLFg9RS5mcmFnbWVudFNoYWRlcixsLnVwZGF0ZShFKSxlZT1sLmdldFZlcnRleFNoYWRlcklEKEUpLF9lPWwuZ2V0RnJhZ21lbnRTaGFkZXJJRChFKTtjb25zdCByZT1pLmdldFJlbmRlclRhcmdldCgpLHllPWkuc3RhdGUuYnVmZmVycy5kZXB0aC5nZXRSZXZlcnNlZCgpLGJlPXouaXNJbnN0YW5jZWRNZXNoPT09ITAsRmU9ei5pc0JhdGNoZWRNZXNoPT09ITAsZXQ9ISFFLm1hcCx6ZT0hIUUubWF0Y2FwLGF0PSEhUSxMPSEhRS5hb01hcCxQdD0hIUUubGlnaHRNYXAsSWU9ISFFLmJ1bXBNYXAsTmU9ISFFLm5vcm1hbE1hcCxTZT0hIUUuZGlzcGxhY2VtZW50TWFwLGplPSEhRS5lbWlzc2l2ZU1hcCxNZT0hIUUubWV0YWxuZXNzTWFwLHk9ISFFLnJvdWdobmVzc01hcCxnPUUuYW5pc290cm9weT4wLEk9RS5jbGVhcmNvYXQ+MCxZPUUuZGlzcGVyc2lvbj4wLFo9RS5pcmlkZXNjZW5jZT4wLGs9RS5zaGVlbj4wLGdlPUUudHJhbnNtaXNzaW9uPjAsc2U9ZyYmISFFLmFuaXNvdHJvcHlNYXAsdWU9SSYmISFFLmNsZWFyY29hdE1hcCxHZT1JJiYhIUUuY2xlYXJjb2F0Tm9ybWFsTWFwLGo9SSYmISFFLmNsZWFyY29hdFJvdWdobmVzc01hcCxoZT1aJiYhIUUuaXJpZGVzY2VuY2VNYXAsRWU9WiYmISFFLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLFRlPWsmJiEhRS5zaGVlbkNvbG9yTWFwLGRlPWsmJiEhRS5zaGVlblJvdWdobmVzc01hcCxPZT0hIUUuc3BlY3VsYXJNYXAsRGU9ISFFLnNwZWN1bGFyQ29sb3JNYXAsWmU9ISFFLnNwZWN1bGFySW50ZW5zaXR5TWFwLEM9Z2UmJiEhRS50cmFuc21pc3Npb25NYXAsbmU9Z2UmJiEhRS50aGlja25lc3NNYXAsRz0hIUUuZ3JhZGllbnRNYXAsJD0hIUUuYWxwaGFNYXAsbGU9RS5hbHBoYVRlc3Q+MCxhZT0hIUUuYWxwaGFIYXNoLFJlPSEhRS5leHRlbnNpb25zO2xldCBudD0wO0UudG9uZU1hcHBlZCYmKHJlPT09bnVsbHx8cmUuaXNYUlJlbmRlclRhcmdldD09PSEwKSYmKG50PWkudG9uZU1hcHBpbmcpO2NvbnN0IG10PXtzaGFkZXJJRDppZSxzaGFkZXJUeXBlOkUudHlwZSxzaGFkZXJOYW1lOkUubmFtZSx2ZXJ0ZXhTaGFkZXI6WWUsZnJhZ21lbnRTaGFkZXI6WCxkZWZpbmVzOkUuZGVmaW5lcyxjdXN0b21WZXJ0ZXhTaGFkZXJJRDplZSxjdXN0b21GcmFnbWVudFNoYWRlcklEOl9lLGlzUmF3U2hhZGVyTWF0ZXJpYWw6RS5pc1Jhd1NoYWRlck1hdGVyaWFsPT09ITAsZ2xzbFZlcnNpb246RS5nbHNsVmVyc2lvbixwcmVjaXNpb246cCxiYXRjaGluZzpGZSxiYXRjaGluZ0NvbG9yOkZlJiZ6Ll9jb2xvcnNUZXh0dXJlIT09bnVsbCxpbnN0YW5jaW5nOmJlLGluc3RhbmNpbmdDb2xvcjpiZSYmei5pbnN0YW5jZUNvbG9yIT09bnVsbCxpbnN0YW5jaW5nTW9ycGg6YmUmJnoubW9ycGhUZXh0dXJlIT09bnVsbCxzdXBwb3J0c1ZlcnRleFRleHR1cmVzOmYsb3V0cHV0Q29sb3JTcGFjZTpyZT09PW51bGw/aS5vdXRwdXRDb2xvclNwYWNlOnJlLmlzWFJSZW5kZXJUYXJnZXQ9PT0hMD9yZS50ZXh0dXJlLmNvbG9yU3BhY2U6eG4sYWxwaGFUb0NvdmVyYWdlOiEhRS5hbHBoYVRvQ292ZXJhZ2UsbWFwOmV0LG1hdGNhcDp6ZSxlbnZNYXA6YXQsZW52TWFwTW9kZTphdCYmUS5tYXBwaW5nLGVudk1hcEN1YmVVVkhlaWdodDpILGFvTWFwOkwsbGlnaHRNYXA6UHQsYnVtcE1hcDpJZSxub3JtYWxNYXA6TmUsZGlzcGxhY2VtZW50TWFwOmYmJlNlLGVtaXNzaXZlTWFwOmplLG5vcm1hbE1hcE9iamVjdFNwYWNlOk5lJiZFLm5vcm1hbE1hcFR5cGU9PT0xLG5vcm1hbE1hcFRhbmdlbnRTcGFjZTpOZSYmRS5ub3JtYWxNYXBUeXBlPT09MCxtZXRhbG5lc3NNYXA6TWUscm91Z2huZXNzTWFwOnksYW5pc290cm9weTpnLGFuaXNvdHJvcHlNYXA6c2UsY2xlYXJjb2F0OkksY2xlYXJjb2F0TWFwOnVlLGNsZWFyY29hdE5vcm1hbE1hcDpHZSxjbGVhcmNvYXRSb3VnaG5lc3NNYXA6aixkaXNwZXJzaW9uOlksaXJpZGVzY2VuY2U6WixpcmlkZXNjZW5jZU1hcDpoZSxpcmlkZXNjZW5jZVRoaWNrbmVzc01hcDpFZSxzaGVlbjprLHNoZWVuQ29sb3JNYXA6VGUsc2hlZW5Sb3VnaG5lc3NNYXA6ZGUsc3BlY3VsYXJNYXA6T2Usc3BlY3VsYXJDb2xvck1hcDpEZSxzcGVjdWxhckludGVuc2l0eU1hcDpaZSx0cmFuc21pc3Npb246Z2UsdHJhbnNtaXNzaW9uTWFwOkMsdGhpY2tuZXNzTWFwOm5lLGdyYWRpZW50TWFwOkcsb3BhcXVlOkUudHJhbnNwYXJlbnQ9PT0hMSYmRS5ibGVuZGluZz09PTEmJkUuYWxwaGFUb0NvdmVyYWdlPT09ITEsYWxwaGFNYXA6JCxhbHBoYVRlc3Q6bGUsYWxwaGFIYXNoOmFlLGNvbWJpbmU6RS5jb21iaW5lLG1hcFV2OmV0JiZ4KEUubWFwLmNoYW5uZWwpLGFvTWFwVXY6TCYmeChFLmFvTWFwLmNoYW5uZWwpLGxpZ2h0TWFwVXY6UHQmJngoRS5saWdodE1hcC5jaGFubmVsKSxidW1wTWFwVXY6SWUmJngoRS5idW1wTWFwLmNoYW5uZWwpLG5vcm1hbE1hcFV2Ok5lJiZ4KEUubm9ybWFsTWFwLmNoYW5uZWwpLGRpc3BsYWNlbWVudE1hcFV2OlNlJiZ4KEUuZGlzcGxhY2VtZW50TWFwLmNoYW5uZWwpLGVtaXNzaXZlTWFwVXY6amUmJngoRS5lbWlzc2l2ZU1hcC5jaGFubmVsKSxtZXRhbG5lc3NNYXBVdjpNZSYmeChFLm1ldGFsbmVzc01hcC5jaGFubmVsKSxyb3VnaG5lc3NNYXBVdjp5JiZ4KEUucm91Z2huZXNzTWFwLmNoYW5uZWwpLGFuaXNvdHJvcHlNYXBVdjpzZSYmeChFLmFuaXNvdHJvcHlNYXAuY2hhbm5lbCksY2xlYXJjb2F0TWFwVXY6dWUmJngoRS5jbGVhcmNvYXRNYXAuY2hhbm5lbCksY2xlYXJjb2F0Tm9ybWFsTWFwVXY6R2UmJngoRS5jbGVhcmNvYXROb3JtYWxNYXAuY2hhbm5lbCksY2xlYXJjb2F0Um91Z2huZXNzTWFwVXY6aiYmeChFLmNsZWFyY29hdFJvdWdobmVzc01hcC5jaGFubmVsKSxpcmlkZXNjZW5jZU1hcFV2OmhlJiZ4KEUuaXJpZGVzY2VuY2VNYXAuY2hhbm5lbCksaXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdjpFZSYmeChFLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLmNoYW5uZWwpLHNoZWVuQ29sb3JNYXBVdjpUZSYmeChFLnNoZWVuQ29sb3JNYXAuY2hhbm5lbCksc2hlZW5Sb3VnaG5lc3NNYXBVdjpkZSYmeChFLnNoZWVuUm91Z2huZXNzTWFwLmNoYW5uZWwpLHNwZWN1bGFyTWFwVXY6T2UmJngoRS5zcGVjdWxhck1hcC5jaGFubmVsKSxzcGVjdWxhckNvbG9yTWFwVXY6RGUmJngoRS5zcGVjdWxhckNvbG9yTWFwLmNoYW5uZWwpLHNwZWN1bGFySW50ZW5zaXR5TWFwVXY6WmUmJngoRS5zcGVjdWxhckludGVuc2l0eU1hcC5jaGFubmVsKSx0cmFuc21pc3Npb25NYXBVdjpDJiZ4KEUudHJhbnNtaXNzaW9uTWFwLmNoYW5uZWwpLHRoaWNrbmVzc01hcFV2Om5lJiZ4KEUudGhpY2tuZXNzTWFwLmNoYW5uZWwpLGFscGhhTWFwVXY6JCYmeChFLmFscGhhTWFwLmNoYW5uZWwpLHZlcnRleFRhbmdlbnRzOiEhSy5hdHRyaWJ1dGVzLnRhbmdlbnQmJihOZXx8ZyksdmVydGV4Q29sb3JzOkUudmVydGV4Q29sb3JzLHZlcnRleEFscGhhczpFLnZlcnRleENvbG9ycz09PSEwJiYhIUsuYXR0cmlidXRlcy5jb2xvciYmSy5hdHRyaWJ1dGVzLmNvbG9yLml0ZW1TaXplPT09NCxwb2ludHNVdnM6ei5pc1BvaW50cz09PSEwJiYhIUsuYXR0cmlidXRlcy51diYmKGV0fHwkKSxmb2c6ISFXLHVzZUZvZzpFLmZvZz09PSEwLGZvZ0V4cDI6ISFXJiZXLmlzRm9nRXhwMixmbGF0U2hhZGluZzpFLmZsYXRTaGFkaW5nPT09ITAsc2l6ZUF0dGVudWF0aW9uOkUuc2l6ZUF0dGVudWF0aW9uPT09ITAsbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjpoLHJldmVyc2VEZXB0aEJ1ZmZlcjp5ZSxza2lubmluZzp6LmlzU2tpbm5lZE1lc2g9PT0hMCxtb3JwaFRhcmdldHM6Sy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24hPT12b2lkIDAsbW9ycGhOb3JtYWxzOksubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCE9PXZvaWQgMCxtb3JwaENvbG9yczpLLm1vcnBoQXR0cmlidXRlcy5jb2xvciE9PXZvaWQgMCxtb3JwaFRhcmdldHNDb3VudDp4ZSxtb3JwaFRleHR1cmVTdHJpZGU6VWUsbnVtRGlyTGlnaHRzOlMuZGlyZWN0aW9uYWwubGVuZ3RoLG51bVBvaW50TGlnaHRzOlMucG9pbnQubGVuZ3RoLG51bVNwb3RMaWdodHM6Uy5zcG90Lmxlbmd0aCxudW1TcG90TGlnaHRNYXBzOlMuc3BvdExpZ2h0TWFwLmxlbmd0aCxudW1SZWN0QXJlYUxpZ2h0czpTLnJlY3RBcmVhLmxlbmd0aCxudW1IZW1pTGlnaHRzOlMuaGVtaS5sZW5ndGgsbnVtRGlyTGlnaHRTaGFkb3dzOlMuZGlyZWN0aW9uYWxTaGFkb3dNYXAubGVuZ3RoLG51bVBvaW50TGlnaHRTaGFkb3dzOlMucG9pbnRTaGFkb3dNYXAubGVuZ3RoLG51bVNwb3RMaWdodFNoYWRvd3M6Uy5zcG90U2hhZG93TWFwLmxlbmd0aCxudW1TcG90TGlnaHRTaGFkb3dzV2l0aE1hcHM6Uy5udW1TcG90TGlnaHRTaGFkb3dzV2l0aE1hcHMsbnVtTGlnaHRQcm9iZXM6Uy5udW1MaWdodFByb2JlcyxudW1DbGlwcGluZ1BsYW5lczphLm51bVBsYW5lcyxudW1DbGlwSW50ZXJzZWN0aW9uOmEubnVtSW50ZXJzZWN0aW9uLGRpdGhlcmluZzpFLmRpdGhlcmluZyxzaGFkb3dNYXBFbmFibGVkOmkuc2hhZG93TWFwLmVuYWJsZWQmJlIubGVuZ3RoPjAsc2hhZG93TWFwVHlwZTppLnNoYWRvd01hcC50eXBlLHRvbmVNYXBwaW5nOm50LGRlY29kZVZpZGVvVGV4dHVyZTpldCYmRS5tYXAuaXNWaWRlb1RleHR1cmU9PT0hMCYmQmUuZ2V0VHJhbnNmZXIoRS5tYXAuY29sb3JTcGFjZSk9PT1xZSxkZWNvZGVWaWRlb1RleHR1cmVFbWlzc2l2ZTpqZSYmRS5lbWlzc2l2ZU1hcC5pc1ZpZGVvVGV4dHVyZT09PSEwJiZCZS5nZXRUcmFuc2ZlcihFLmVtaXNzaXZlTWFwLmNvbG9yU3BhY2UpPT09cWUscHJlbXVsdGlwbGllZEFscGhhOkUucHJlbXVsdGlwbGllZEFscGhhLGRvdWJsZVNpZGVkOkUuc2lkZT09PTIsZmxpcFNpZGVkOkUuc2lkZT09PTEsdXNlRGVwdGhQYWNraW5nOkUuZGVwdGhQYWNraW5nPj0wLGRlcHRoUGFja2luZzpFLmRlcHRoUGFja2luZ3x8MCxpbmRleDBBdHRyaWJ1dGVOYW1lOkUuaW5kZXgwQXR0cmlidXRlTmFtZSxleHRlbnNpb25DbGlwQ3VsbERpc3RhbmNlOlJlJiZFLmV4dGVuc2lvbnMuY2xpcEN1bGxEaXN0YW5jZT09PSEwJiZuLmhhcygiV0VCR0xfY2xpcF9jdWxsX2Rpc3RhbmNlIiksZXh0ZW5zaW9uTXVsdGlEcmF3OihSZSYmRS5leHRlbnNpb25zLm11bHRpRHJhdz09PSEwfHxGZSkmJm4uaGFzKCJXRUJHTF9tdWx0aV9kcmF3IikscmVuZGVyZXJFeHRlbnNpb25QYXJhbGxlbFNoYWRlckNvbXBpbGU6bi5oYXMoIktIUl9wYXJhbGxlbF9zaGFkZXJfY29tcGlsZSIpLGN1c3RvbVByb2dyYW1DYWNoZUtleTpFLmN1c3RvbVByb2dyYW1DYWNoZUtleSgpfTtyZXR1cm4gbXQudmVydGV4VXYxcz1jLmhhcygxKSxtdC52ZXJ0ZXhVdjJzPWMuaGFzKDIpLG10LnZlcnRleFV2M3M9Yy5oYXMoMyksYy5jbGVhcigpLG10fWZ1bmN0aW9uIGQoRSl7Y29uc3QgUz1bXTtpZihFLnNoYWRlcklEP1MucHVzaChFLnNoYWRlcklEKTooUy5wdXNoKEUuY3VzdG9tVmVydGV4U2hhZGVySUQpLFMucHVzaChFLmN1c3RvbUZyYWdtZW50U2hhZGVySUQpKSxFLmRlZmluZXMhPT12b2lkIDApZm9yKGNvbnN0IFIgaW4gRS5kZWZpbmVzKVMucHVzaChSKSxTLnB1c2goRS5kZWZpbmVzW1JdKTtyZXR1cm4gRS5pc1Jhd1NoYWRlck1hdGVyaWFsPT09ITEmJihBKFMsRSksVChTLEUpLFMucHVzaChpLm91dHB1dENvbG9yU3BhY2UpKSxTLnB1c2goRS5jdXN0b21Qcm9ncmFtQ2FjaGVLZXkpLFMuam9pbigpfWZ1bmN0aW9uIEEoRSxTKXtFLnB1c2goUy5wcmVjaXNpb24pLEUucHVzaChTLm91dHB1dENvbG9yU3BhY2UpLEUucHVzaChTLmVudk1hcE1vZGUpLEUucHVzaChTLmVudk1hcEN1YmVVVkhlaWdodCksRS5wdXNoKFMubWFwVXYpLEUucHVzaChTLmFscGhhTWFwVXYpLEUucHVzaChTLmxpZ2h0TWFwVXYpLEUucHVzaChTLmFvTWFwVXYpLEUucHVzaChTLmJ1bXBNYXBVdiksRS5wdXNoKFMubm9ybWFsTWFwVXYpLEUucHVzaChTLmRpc3BsYWNlbWVudE1hcFV2KSxFLnB1c2goUy5lbWlzc2l2ZU1hcFV2KSxFLnB1c2goUy5tZXRhbG5lc3NNYXBVdiksRS5wdXNoKFMucm91Z2huZXNzTWFwVXYpLEUucHVzaChTLmFuaXNvdHJvcHlNYXBVdiksRS5wdXNoKFMuY2xlYXJjb2F0TWFwVXYpLEUucHVzaChTLmNsZWFyY29hdE5vcm1hbE1hcFV2KSxFLnB1c2goUy5jbGVhcmNvYXRSb3VnaG5lc3NNYXBVdiksRS5wdXNoKFMuaXJpZGVzY2VuY2VNYXBVdiksRS5wdXNoKFMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdiksRS5wdXNoKFMuc2hlZW5Db2xvck1hcFV2KSxFLnB1c2goUy5zaGVlblJvdWdobmVzc01hcFV2KSxFLnB1c2goUy5zcGVjdWxhck1hcFV2KSxFLnB1c2goUy5zcGVjdWxhckNvbG9yTWFwVXYpLEUucHVzaChTLnNwZWN1bGFySW50ZW5zaXR5TWFwVXYpLEUucHVzaChTLnRyYW5zbWlzc2lvbk1hcFV2KSxFLnB1c2goUy50aGlja25lc3NNYXBVdiksRS5wdXNoKFMuY29tYmluZSksRS5wdXNoKFMuZm9nRXhwMiksRS5wdXNoKFMuc2l6ZUF0dGVudWF0aW9uKSxFLnB1c2goUy5tb3JwaFRhcmdldHNDb3VudCksRS5wdXNoKFMubW9ycGhBdHRyaWJ1dGVDb3VudCksRS5wdXNoKFMubnVtRGlyTGlnaHRzKSxFLnB1c2goUy5udW1Qb2ludExpZ2h0cyksRS5wdXNoKFMubnVtU3BvdExpZ2h0cyksRS5wdXNoKFMubnVtU3BvdExpZ2h0TWFwcyksRS5wdXNoKFMubnVtSGVtaUxpZ2h0cyksRS5wdXNoKFMubnVtUmVjdEFyZWFMaWdodHMpLEUucHVzaChTLm51bURpckxpZ2h0U2hhZG93cyksRS5wdXNoKFMubnVtUG9pbnRMaWdodFNoYWRvd3MpLEUucHVzaChTLm51bVNwb3RMaWdodFNoYWRvd3MpLEUucHVzaChTLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcyksRS5wdXNoKFMubnVtTGlnaHRQcm9iZXMpLEUucHVzaChTLnNoYWRvd01hcFR5cGUpLEUucHVzaChTLnRvbmVNYXBwaW5nKSxFLnB1c2goUy5udW1DbGlwcGluZ1BsYW5lcyksRS5wdXNoKFMubnVtQ2xpcEludGVyc2VjdGlvbiksRS5wdXNoKFMuZGVwdGhQYWNraW5nKX1mdW5jdGlvbiBUKEUsUyl7by5kaXNhYmxlQWxsKCksUy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzJiZvLmVuYWJsZSgwKSxTLmluc3RhbmNpbmcmJm8uZW5hYmxlKDEpLFMuaW5zdGFuY2luZ0NvbG9yJiZvLmVuYWJsZSgyKSxTLmluc3RhbmNpbmdNb3JwaCYmby5lbmFibGUoMyksUy5tYXRjYXAmJm8uZW5hYmxlKDQpLFMuZW52TWFwJiZvLmVuYWJsZSg1KSxTLm5vcm1hbE1hcE9iamVjdFNwYWNlJiZvLmVuYWJsZSg2KSxTLm5vcm1hbE1hcFRhbmdlbnRTcGFjZSYmby5lbmFibGUoNyksUy5jbGVhcmNvYXQmJm8uZW5hYmxlKDgpLFMuaXJpZGVzY2VuY2UmJm8uZW5hYmxlKDkpLFMuYWxwaGFUZXN0JiZvLmVuYWJsZSgxMCksUy52ZXJ0ZXhDb2xvcnMmJm8uZW5hYmxlKDExKSxTLnZlcnRleEFscGhhcyYmby5lbmFibGUoMTIpLFMudmVydGV4VXYxcyYmby5lbmFibGUoMTMpLFMudmVydGV4VXYycyYmby5lbmFibGUoMTQpLFMudmVydGV4VXYzcyYmby5lbmFibGUoMTUpLFMudmVydGV4VGFuZ2VudHMmJm8uZW5hYmxlKDE2KSxTLmFuaXNvdHJvcHkmJm8uZW5hYmxlKDE3KSxTLmFscGhhSGFzaCYmby5lbmFibGUoMTgpLFMuYmF0Y2hpbmcmJm8uZW5hYmxlKDE5KSxTLmRpc3BlcnNpb24mJm8uZW5hYmxlKDIwKSxTLmJhdGNoaW5nQ29sb3ImJm8uZW5hYmxlKDIxKSxFLnB1c2goby5tYXNrKSxvLmRpc2FibGVBbGwoKSxTLmZvZyYmby5lbmFibGUoMCksUy51c2VGb2cmJm8uZW5hYmxlKDEpLFMuZmxhdFNoYWRpbmcmJm8uZW5hYmxlKDIpLFMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciYmby5lbmFibGUoMyksUy5yZXZlcnNlRGVwdGhCdWZmZXImJm8uZW5hYmxlKDQpLFMuc2tpbm5pbmcmJm8uZW5hYmxlKDUpLFMubW9ycGhUYXJnZXRzJiZvLmVuYWJsZSg2KSxTLm1vcnBoTm9ybWFscyYmby5lbmFibGUoNyksUy5tb3JwaENvbG9ycyYmby5lbmFibGUoOCksUy5wcmVtdWx0aXBsaWVkQWxwaGEmJm8uZW5hYmxlKDkpLFMuc2hhZG93TWFwRW5hYmxlZCYmby5lbmFibGUoMTApLFMuZG91YmxlU2lkZWQmJm8uZW5hYmxlKDExKSxTLmZsaXBTaWRlZCYmby5lbmFibGUoMTIpLFMudXNlRGVwdGhQYWNraW5nJiZvLmVuYWJsZSgxMyksUy5kaXRoZXJpbmcmJm8uZW5hYmxlKDE0KSxTLnRyYW5zbWlzc2lvbiYmby5lbmFibGUoMTUpLFMuc2hlZW4mJm8uZW5hYmxlKDE2KSxTLm9wYXF1ZSYmby5lbmFibGUoMTcpLFMucG9pbnRzVXZzJiZvLmVuYWJsZSgxOCksUy5kZWNvZGVWaWRlb1RleHR1cmUmJm8uZW5hYmxlKDE5KSxTLmRlY29kZVZpZGVvVGV4dHVyZUVtaXNzaXZlJiZvLmVuYWJsZSgyMCksUy5hbHBoYVRvQ292ZXJhZ2UmJm8uZW5hYmxlKDIxKSxFLnB1c2goby5tYXNrKX1mdW5jdGlvbiBNKEUpe2NvbnN0IFM9X1tFLnR5cGVdO2xldCBSO2lmKFMpe2NvbnN0IHE9enRbU107Uj1SYS5jbG9uZShxLnVuaWZvcm1zKX1lbHNlIFI9RS51bmlmb3JtcztyZXR1cm4gUn1mdW5jdGlvbiBGKEUsUyl7bGV0IFI7Zm9yKGxldCBxPTAsej11Lmxlbmd0aDtxPHo7cSsrKXtjb25zdCBXPXVbcV07aWYoVy5jYWNoZUtleT09PVMpe1I9VywrK1IudXNlZFRpbWVzO2JyZWFrfX1yZXR1cm4gUj09PXZvaWQgMCYmKFI9bmV3IGx1KGksUyxFLHMpLHUucHVzaChSKSksUn1mdW5jdGlvbiBiKEUpe2lmKC0tRS51c2VkVGltZXM9PT0wKXtjb25zdCBTPXUuaW5kZXhPZihFKTt1W1NdPXVbdS5sZW5ndGgtMV0sdS5wb3AoKSxFLmRlc3Ryb3koKX19ZnVuY3Rpb24gdyhFKXtsLnJlbW92ZShFKX1mdW5jdGlvbiBVKCl7bC5kaXNwb3NlKCl9cmV0dXJue2dldFBhcmFtZXRlcnM6bSxnZXRQcm9ncmFtQ2FjaGVLZXk6ZCxnZXRVbmlmb3JtczpNLGFjcXVpcmVQcm9ncmFtOkYscmVsZWFzZVByb2dyYW06YixyZWxlYXNlU2hhZGVyQ2FjaGU6dyxwcm9ncmFtczp1LGRpc3Bvc2U6VX19ZnVuY3Rpb24gZnUoKXtsZXQgaT1uZXcgV2Vha01hcDtmdW5jdGlvbiBlKGEpe3JldHVybiBpLmhhcyhhKX1mdW5jdGlvbiB0KGEpe2xldCBvPWkuZ2V0KGEpO3JldHVybiBvPT09dm9pZCAwJiYobz17fSxpLnNldChhLG8pKSxvfWZ1bmN0aW9uIG4oYSl7aS5kZWxldGUoYSl9ZnVuY3Rpb24gcihhLG8sbCl7aS5nZXQoYSlbb109bH1mdW5jdGlvbiBzKCl7aT1uZXcgV2Vha01hcH1yZXR1cm57aGFzOmUsZ2V0OnQscmVtb3ZlOm4sdXBkYXRlOnIsZGlzcG9zZTpzfX1mdW5jdGlvbiBwdShpLGUpe3JldHVybiBpLmdyb3VwT3JkZXIhPT1lLmdyb3VwT3JkZXI/aS5ncm91cE9yZGVyLWUuZ3JvdXBPcmRlcjppLnJlbmRlck9yZGVyIT09ZS5yZW5kZXJPcmRlcj9pLnJlbmRlck9yZGVyLWUucmVuZGVyT3JkZXI6aS5tYXRlcmlhbC5pZCE9PWUubWF0ZXJpYWwuaWQ/aS5tYXRlcmlhbC5pZC1lLm1hdGVyaWFsLmlkOmkueiE9PWUuej9pLnotZS56OmkuaWQtZS5pZH1mdW5jdGlvbiBicyhpLGUpe3JldHVybiBpLmdyb3VwT3JkZXIhPT1lLmdyb3VwT3JkZXI/aS5ncm91cE9yZGVyLWUuZ3JvdXBPcmRlcjppLnJlbmRlck9yZGVyIT09ZS5yZW5kZXJPcmRlcj9pLnJlbmRlck9yZGVyLWUucmVuZGVyT3JkZXI6aS56IT09ZS56P2Uuei1pLno6aS5pZC1lLmlkfWZ1bmN0aW9uIHdzKCl7Y29uc3QgaT1bXTtsZXQgZT0wO2NvbnN0IHQ9W10sbj1bXSxyPVtdO2Z1bmN0aW9uIHMoKXtlPTAsdC5sZW5ndGg9MCxuLmxlbmd0aD0wLHIubGVuZ3RoPTB9ZnVuY3Rpb24gYShoLGYscCxfLHgsbSl7bGV0IGQ9aVtlXTtyZXR1cm4gZD09PXZvaWQgMD8oZD17aWQ6aC5pZCxvYmplY3Q6aCxnZW9tZXRyeTpmLG1hdGVyaWFsOnAsZ3JvdXBPcmRlcjpfLHJlbmRlck9yZGVyOmgucmVuZGVyT3JkZXIsejp4LGdyb3VwOm19LGlbZV09ZCk6KGQuaWQ9aC5pZCxkLm9iamVjdD1oLGQuZ2VvbWV0cnk9ZixkLm1hdGVyaWFsPXAsZC5ncm91cE9yZGVyPV8sZC5yZW5kZXJPcmRlcj1oLnJlbmRlck9yZGVyLGQuej14LGQuZ3JvdXA9bSksZSsrLGR9ZnVuY3Rpb24gbyhoLGYscCxfLHgsbSl7Y29uc3QgZD1hKGgsZixwLF8seCxtKTtwLnRyYW5zbWlzc2lvbj4wP24ucHVzaChkKTpwLnRyYW5zcGFyZW50PT09ITA/ci5wdXNoKGQpOnQucHVzaChkKX1mdW5jdGlvbiBsKGgsZixwLF8seCxtKXtjb25zdCBkPWEoaCxmLHAsXyx4LG0pO3AudHJhbnNtaXNzaW9uPjA/bi51bnNoaWZ0KGQpOnAudHJhbnNwYXJlbnQ9PT0hMD9yLnVuc2hpZnQoZCk6dC51bnNoaWZ0KGQpfWZ1bmN0aW9uIGMoaCxmKXt0Lmxlbmd0aD4xJiZ0LnNvcnQoaHx8cHUpLG4ubGVuZ3RoPjEmJm4uc29ydChmfHxicyksci5sZW5ndGg+MSYmci5zb3J0KGZ8fGJzKX1mdW5jdGlvbiB1KCl7Zm9yKGxldCBoPWUsZj1pLmxlbmd0aDtoPGY7aCsrKXtjb25zdCBwPWlbaF07aWYocC5pZD09PW51bGwpYnJlYWs7cC5pZD1udWxsLHAub2JqZWN0PW51bGwscC5nZW9tZXRyeT1udWxsLHAubWF0ZXJpYWw9bnVsbCxwLmdyb3VwPW51bGx9fXJldHVybntvcGFxdWU6dCx0cmFuc21pc3NpdmU6bix0cmFuc3BhcmVudDpyLGluaXQ6cyxwdXNoOm8sdW5zaGlmdDpsLGZpbmlzaDp1LHNvcnQ6Y319ZnVuY3Rpb24gbXUoKXtsZXQgaT1uZXcgV2Vha01hcDtmdW5jdGlvbiBlKG4scil7Y29uc3Qgcz1pLmdldChuKTtsZXQgYTtyZXR1cm4gcz09PXZvaWQgMD8oYT1uZXcgd3MsaS5zZXQobixbYV0pKTpyPj1zLmxlbmd0aD8oYT1uZXcgd3Mscy5wdXNoKGEpKTphPXNbcl0sYX1mdW5jdGlvbiB0KCl7aT1uZXcgV2Vha01hcH1yZXR1cm57Z2V0OmUsZGlzcG9zZTp0fX1mdW5jdGlvbiBfdSgpe2NvbnN0IGk9e307cmV0dXJue2dldDpmdW5jdGlvbihlKXtpZihpW2UuaWRdIT09dm9pZCAwKXJldHVybiBpW2UuaWRdO2xldCB0O3N3aXRjaChlLnR5cGUpe2Nhc2UiRGlyZWN0aW9uYWxMaWdodCI6dD17ZGlyZWN0aW9uOm5ldyBCLGNvbG9yOm5ldyBWZX07YnJlYWs7Y2FzZSJTcG90TGlnaHQiOnQ9e3Bvc2l0aW9uOm5ldyBCLGRpcmVjdGlvbjpuZXcgQixjb2xvcjpuZXcgVmUsZGlzdGFuY2U6MCxjb25lQ29zOjAscGVudW1icmFDb3M6MCxkZWNheTowfTticmVhaztjYXNlIlBvaW50TGlnaHQiOnQ9e3Bvc2l0aW9uOm5ldyBCLGNvbG9yOm5ldyBWZSxkaXN0YW5jZTowLGRlY2F5OjB9O2JyZWFrO2Nhc2UiSGVtaXNwaGVyZUxpZ2h0Ijp0PXtkaXJlY3Rpb246bmV3IEIsc2t5Q29sb3I6bmV3IFZlLGdyb3VuZENvbG9yOm5ldyBWZX07YnJlYWs7Y2FzZSJSZWN0QXJlYUxpZ2h0Ijp0PXtjb2xvcjpuZXcgVmUscG9zaXRpb246bmV3IEIsaGFsZldpZHRoOm5ldyBCLGhhbGZIZWlnaHQ6bmV3IEJ9O2JyZWFrfXJldHVybiBpW2UuaWRdPXQsdH19fWZ1bmN0aW9uIGd1KCl7Y29uc3QgaT17fTtyZXR1cm57Z2V0OmZ1bmN0aW9uKGUpe2lmKGlbZS5pZF0hPT12b2lkIDApcmV0dXJuIGlbZS5pZF07bGV0IHQ7c3dpdGNoKGUudHlwZSl7Y2FzZSJEaXJlY3Rpb25hbExpZ2h0Ijp0PXtzaGFkb3dJbnRlbnNpdHk6MSxzaGFkb3dCaWFzOjAsc2hhZG93Tm9ybWFsQmlhczowLHNoYWRvd1JhZGl1czoxLHNoYWRvd01hcFNpemU6bmV3IExlfTticmVhaztjYXNlIlNwb3RMaWdodCI6dD17c2hhZG93SW50ZW5zaXR5OjEsc2hhZG93QmlhczowLHNoYWRvd05vcm1hbEJpYXM6MCxzaGFkb3dSYWRpdXM6MSxzaGFkb3dNYXBTaXplOm5ldyBMZX07YnJlYWs7Y2FzZSJQb2ludExpZ2h0Ijp0PXtzaGFkb3dJbnRlbnNpdHk6MSxzaGFkb3dCaWFzOjAsc2hhZG93Tm9ybWFsQmlhczowLHNoYWRvd1JhZGl1czoxLHNoYWRvd01hcFNpemU6bmV3IExlLHNoYWRvd0NhbWVyYU5lYXI6MSxzaGFkb3dDYW1lcmFGYXI6MWUzfTticmVha31yZXR1cm4gaVtlLmlkXT10LHR9fX1sZXQgdnU9MDtmdW5jdGlvbiB4dShpLGUpe3JldHVybihlLmNhc3RTaGFkb3c/MjowKS0oaS5jYXN0U2hhZG93PzI6MCkrKGUubWFwPzE6MCktKGkubWFwPzE6MCl9ZnVuY3Rpb24gTXUoaSl7Y29uc3QgZT1uZXcgX3UsdD1ndSgpLG49e3ZlcnNpb246MCxoYXNoOntkaXJlY3Rpb25hbExlbmd0aDotMSxwb2ludExlbmd0aDotMSxzcG90TGVuZ3RoOi0xLHJlY3RBcmVhTGVuZ3RoOi0xLGhlbWlMZW5ndGg6LTEsbnVtRGlyZWN0aW9uYWxTaGFkb3dzOi0xLG51bVBvaW50U2hhZG93czotMSxudW1TcG90U2hhZG93czotMSxudW1TcG90TWFwczotMSxudW1MaWdodFByb2JlczotMX0sYW1iaWVudDpbMCwwLDBdLHByb2JlOltdLGRpcmVjdGlvbmFsOltdLGRpcmVjdGlvbmFsU2hhZG93OltdLGRpcmVjdGlvbmFsU2hhZG93TWFwOltdLGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OltdLHNwb3Q6W10sc3BvdExpZ2h0TWFwOltdLHNwb3RTaGFkb3c6W10sc3BvdFNoYWRvd01hcDpbXSxzcG90TGlnaHRNYXRyaXg6W10scmVjdEFyZWE6W10scmVjdEFyZWFMVEMxOm51bGwscmVjdEFyZWFMVEMyOm51bGwscG9pbnQ6W10scG9pbnRTaGFkb3c6W10scG9pbnRTaGFkb3dNYXA6W10scG9pbnRTaGFkb3dNYXRyaXg6W10saGVtaTpbXSxudW1TcG90TGlnaHRTaGFkb3dzV2l0aE1hcHM6MCxudW1MaWdodFByb2JlczowfTtmb3IobGV0IGM9MDtjPDk7YysrKW4ucHJvYmUucHVzaChuZXcgQik7Y29uc3Qgcj1uZXcgQixzPW5ldyBydCxhPW5ldyBydDtmdW5jdGlvbiBvKGMpe2xldCB1PTAsaD0wLGY9MDtmb3IobGV0IEU9MDtFPDk7RSsrKW4ucHJvYmVbRV0uc2V0KDAsMCwwKTtsZXQgcD0wLF89MCx4PTAsbT0wLGQ9MCxBPTAsVD0wLE09MCxGPTAsYj0wLHc9MDtjLnNvcnQoeHUpO2ZvcihsZXQgRT0wLFM9Yy5sZW5ndGg7RTxTO0UrKyl7Y29uc3QgUj1jW0VdLHE9Ui5jb2xvcix6PVIuaW50ZW5zaXR5LFc9Ui5kaXN0YW5jZSxLPVIuc2hhZG93JiZSLnNoYWRvdy5tYXA/Ui5zaGFkb3cubWFwLnRleHR1cmU6bnVsbDtpZihSLmlzQW1iaWVudExpZ2h0KXUrPXEucip6LGgrPXEuZyp6LGYrPXEuYip6O2Vsc2UgaWYoUi5pc0xpZ2h0UHJvYmUpe2ZvcihsZXQgVj0wO1Y8OTtWKyspbi5wcm9iZVtWXS5hZGRTY2FsZWRWZWN0b3IoUi5zaC5jb2VmZmljaWVudHNbVl0seik7dysrfWVsc2UgaWYoUi5pc0RpcmVjdGlvbmFsTGlnaHQpe2NvbnN0IFY9ZS5nZXQoUik7aWYoVi5jb2xvci5jb3B5KFIuY29sb3IpLm11bHRpcGx5U2NhbGFyKFIuaW50ZW5zaXR5KSxSLmNhc3RTaGFkb3cpe2NvbnN0IFE9Ui5zaGFkb3csSD10LmdldChSKTtILnNoYWRvd0ludGVuc2l0eT1RLmludGVuc2l0eSxILnNoYWRvd0JpYXM9US5iaWFzLEguc2hhZG93Tm9ybWFsQmlhcz1RLm5vcm1hbEJpYXMsSC5zaGFkb3dSYWRpdXM9US5yYWRpdXMsSC5zaGFkb3dNYXBTaXplPVEubWFwU2l6ZSxuLmRpcmVjdGlvbmFsU2hhZG93W3BdPUgsbi5kaXJlY3Rpb25hbFNoYWRvd01hcFtwXT1LLG4uZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbcF09Ui5zaGFkb3cubWF0cml4LEErK31uLmRpcmVjdGlvbmFsW3BdPVYscCsrfWVsc2UgaWYoUi5pc1Nwb3RMaWdodCl7Y29uc3QgVj1lLmdldChSKTtWLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihSLm1hdHJpeFdvcmxkKSxWLmNvbG9yLmNvcHkocSkubXVsdGlwbHlTY2FsYXIoeiksVi5kaXN0YW5jZT1XLFYuY29uZUNvcz1NYXRoLmNvcyhSLmFuZ2xlKSxWLnBlbnVtYnJhQ29zPU1hdGguY29zKFIuYW5nbGUqKDEtUi5wZW51bWJyYSkpLFYuZGVjYXk9Ui5kZWNheSxuLnNwb3RbeF09Vjtjb25zdCBRPVIuc2hhZG93O2lmKFIubWFwJiYobi5zcG90TGlnaHRNYXBbRl09Ui5tYXAsRisrLFEudXBkYXRlTWF0cmljZXMoUiksUi5jYXN0U2hhZG93JiZiKyspLG4uc3BvdExpZ2h0TWF0cml4W3hdPVEubWF0cml4LFIuY2FzdFNoYWRvdyl7Y29uc3QgSD10LmdldChSKTtILnNoYWRvd0ludGVuc2l0eT1RLmludGVuc2l0eSxILnNoYWRvd0JpYXM9US5iaWFzLEguc2hhZG93Tm9ybWFsQmlhcz1RLm5vcm1hbEJpYXMsSC5zaGFkb3dSYWRpdXM9US5yYWRpdXMsSC5zaGFkb3dNYXBTaXplPVEubWFwU2l6ZSxuLnNwb3RTaGFkb3dbeF09SCxuLnNwb3RTaGFkb3dNYXBbeF09SyxNKyt9eCsrfWVsc2UgaWYoUi5pc1JlY3RBcmVhTGlnaHQpe2NvbnN0IFY9ZS5nZXQoUik7Vi5jb2xvci5jb3B5KHEpLm11bHRpcGx5U2NhbGFyKHopLFYuaGFsZldpZHRoLnNldChSLndpZHRoKi41LDAsMCksVi5oYWxmSGVpZ2h0LnNldCgwLFIuaGVpZ2h0Ki41LDApLG4ucmVjdEFyZWFbbV09VixtKyt9ZWxzZSBpZihSLmlzUG9pbnRMaWdodCl7Y29uc3QgVj1lLmdldChSKTtpZihWLmNvbG9yLmNvcHkoUi5jb2xvcikubXVsdGlwbHlTY2FsYXIoUi5pbnRlbnNpdHkpLFYuZGlzdGFuY2U9Ui5kaXN0YW5jZSxWLmRlY2F5PVIuZGVjYXksUi5jYXN0U2hhZG93KXtjb25zdCBRPVIuc2hhZG93LEg9dC5nZXQoUik7SC5zaGFkb3dJbnRlbnNpdHk9US5pbnRlbnNpdHksSC5zaGFkb3dCaWFzPVEuYmlhcyxILnNoYWRvd05vcm1hbEJpYXM9US5ub3JtYWxCaWFzLEguc2hhZG93UmFkaXVzPVEucmFkaXVzLEguc2hhZG93TWFwU2l6ZT1RLm1hcFNpemUsSC5zaGFkb3dDYW1lcmFOZWFyPVEuY2FtZXJhLm5lYXIsSC5zaGFkb3dDYW1lcmFGYXI9US5jYW1lcmEuZmFyLG4ucG9pbnRTaGFkb3dbX109SCxuLnBvaW50U2hhZG93TWFwW19dPUssbi5wb2ludFNoYWRvd01hdHJpeFtfXT1SLnNoYWRvdy5tYXRyaXgsVCsrfW4ucG9pbnRbX109VixfKyt9ZWxzZSBpZihSLmlzSGVtaXNwaGVyZUxpZ2h0KXtjb25zdCBWPWUuZ2V0KFIpO1Yuc2t5Q29sb3IuY29weShSLmNvbG9yKS5tdWx0aXBseVNjYWxhcih6KSxWLmdyb3VuZENvbG9yLmNvcHkoUi5ncm91bmRDb2xvcikubXVsdGlwbHlTY2FsYXIoeiksbi5oZW1pW2RdPVYsZCsrfX1tPjAmJihpLmhhcygiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyIik9PT0hMD8obi5yZWN0QXJlYUxUQzE9dGUuTFRDX0ZMT0FUXzEsbi5yZWN0QXJlYUxUQzI9dGUuTFRDX0ZMT0FUXzIpOihuLnJlY3RBcmVhTFRDMT10ZS5MVENfSEFMRl8xLG4ucmVjdEFyZWFMVEMyPXRlLkxUQ19IQUxGXzIpKSxuLmFtYmllbnRbMF09dSxuLmFtYmllbnRbMV09aCxuLmFtYmllbnRbMl09Zjtjb25zdCBVPW4uaGFzaDsoVS5kaXJlY3Rpb25hbExlbmd0aCE9PXB8fFUucG9pbnRMZW5ndGghPT1ffHxVLnNwb3RMZW5ndGghPT14fHxVLnJlY3RBcmVhTGVuZ3RoIT09bXx8VS5oZW1pTGVuZ3RoIT09ZHx8VS5udW1EaXJlY3Rpb25hbFNoYWRvd3MhPT1BfHxVLm51bVBvaW50U2hhZG93cyE9PVR8fFUubnVtU3BvdFNoYWRvd3MhPT1NfHxVLm51bVNwb3RNYXBzIT09Rnx8VS5udW1MaWdodFByb2JlcyE9PXcpJiYobi5kaXJlY3Rpb25hbC5sZW5ndGg9cCxuLnNwb3QubGVuZ3RoPXgsbi5yZWN0QXJlYS5sZW5ndGg9bSxuLnBvaW50Lmxlbmd0aD1fLG4uaGVtaS5sZW5ndGg9ZCxuLmRpcmVjdGlvbmFsU2hhZG93Lmxlbmd0aD1BLG4uZGlyZWN0aW9uYWxTaGFkb3dNYXAubGVuZ3RoPUEsbi5wb2ludFNoYWRvdy5sZW5ndGg9VCxuLnBvaW50U2hhZG93TWFwLmxlbmd0aD1ULG4uc3BvdFNoYWRvdy5sZW5ndGg9TSxuLnNwb3RTaGFkb3dNYXAubGVuZ3RoPU0sbi5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeC5sZW5ndGg9QSxuLnBvaW50U2hhZG93TWF0cml4Lmxlbmd0aD1ULG4uc3BvdExpZ2h0TWF0cml4Lmxlbmd0aD1NK0YtYixuLnNwb3RMaWdodE1hcC5sZW5ndGg9RixuLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcz1iLG4ubnVtTGlnaHRQcm9iZXM9dyxVLmRpcmVjdGlvbmFsTGVuZ3RoPXAsVS5wb2ludExlbmd0aD1fLFUuc3BvdExlbmd0aD14LFUucmVjdEFyZWFMZW5ndGg9bSxVLmhlbWlMZW5ndGg9ZCxVLm51bURpcmVjdGlvbmFsU2hhZG93cz1BLFUubnVtUG9pbnRTaGFkb3dzPVQsVS5udW1TcG90U2hhZG93cz1NLFUubnVtU3BvdE1hcHM9RixVLm51bUxpZ2h0UHJvYmVzPXcsbi52ZXJzaW9uPXZ1KyspfWZ1bmN0aW9uIGwoYyx1KXtsZXQgaD0wLGY9MCxwPTAsXz0wLHg9MDtjb25zdCBtPXUubWF0cml4V29ybGRJbnZlcnNlO2ZvcihsZXQgZD0wLEE9Yy5sZW5ndGg7ZDxBO2QrKyl7Y29uc3QgVD1jW2RdO2lmKFQuaXNEaXJlY3Rpb25hbExpZ2h0KXtjb25zdCBNPW4uZGlyZWN0aW9uYWxbaF07TS5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKFQubWF0cml4V29ybGQpLHIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKFQudGFyZ2V0Lm1hdHJpeFdvcmxkKSxNLmRpcmVjdGlvbi5zdWIociksTS5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKG0pLGgrK31lbHNlIGlmKFQuaXNTcG90TGlnaHQpe2NvbnN0IE09bi5zcG90W3BdO00ucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKFQubWF0cml4V29ybGQpLE0ucG9zaXRpb24uYXBwbHlNYXRyaXg0KG0pLE0uZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihULm1hdHJpeFdvcmxkKSxyLnNldEZyb21NYXRyaXhQb3NpdGlvbihULnRhcmdldC5tYXRyaXhXb3JsZCksTS5kaXJlY3Rpb24uc3ViKHIpLE0uZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbihtKSxwKyt9ZWxzZSBpZihULmlzUmVjdEFyZWFMaWdodCl7Y29uc3QgTT1uLnJlY3RBcmVhW19dO00ucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKFQubWF0cml4V29ybGQpLE0ucG9zaXRpb24uYXBwbHlNYXRyaXg0KG0pLGEuaWRlbnRpdHkoKSxzLmNvcHkoVC5tYXRyaXhXb3JsZCkscy5wcmVtdWx0aXBseShtKSxhLmV4dHJhY3RSb3RhdGlvbihzKSxNLmhhbGZXaWR0aC5zZXQoVC53aWR0aCouNSwwLDApLE0uaGFsZkhlaWdodC5zZXQoMCxULmhlaWdodCouNSwwKSxNLmhhbGZXaWR0aC5hcHBseU1hdHJpeDQoYSksTS5oYWxmSGVpZ2h0LmFwcGx5TWF0cml4NChhKSxfKyt9ZWxzZSBpZihULmlzUG9pbnRMaWdodCl7Y29uc3QgTT1uLnBvaW50W2ZdO00ucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKFQubWF0cml4V29ybGQpLE0ucG9zaXRpb24uYXBwbHlNYXRyaXg0KG0pLGYrK31lbHNlIGlmKFQuaXNIZW1pc3BoZXJlTGlnaHQpe2NvbnN0IE09bi5oZW1pW3hdO00uZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihULm1hdHJpeFdvcmxkKSxNLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24obSkseCsrfX19cmV0dXJue3NldHVwOm8sc2V0dXBWaWV3Omwsc3RhdGU6bn19ZnVuY3Rpb24gUnMoaSl7Y29uc3QgZT1uZXcgTXUoaSksdD1bXSxuPVtdO2Z1bmN0aW9uIHIodSl7Yy5jYW1lcmE9dSx0Lmxlbmd0aD0wLG4ubGVuZ3RoPTB9ZnVuY3Rpb24gcyh1KXt0LnB1c2godSl9ZnVuY3Rpb24gYSh1KXtuLnB1c2godSl9ZnVuY3Rpb24gbygpe2Uuc2V0dXAodCl9ZnVuY3Rpb24gbCh1KXtlLnNldHVwVmlldyh0LHUpfWNvbnN0IGM9e2xpZ2h0c0FycmF5OnQsc2hhZG93c0FycmF5Om4sY2FtZXJhOm51bGwsbGlnaHRzOmUsdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0Ont9fTtyZXR1cm57aW5pdDpyLHN0YXRlOmMsc2V0dXBMaWdodHM6byxzZXR1cExpZ2h0c1ZpZXc6bCxwdXNoTGlnaHQ6cyxwdXNoU2hhZG93OmF9fWZ1bmN0aW9uIFN1KGkpe2xldCBlPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIHQocixzPTApe2NvbnN0IGE9ZS5nZXQocik7bGV0IG87cmV0dXJuIGE9PT12b2lkIDA/KG89bmV3IFJzKGkpLGUuc2V0KHIsW29dKSk6cz49YS5sZW5ndGg/KG89bmV3IFJzKGkpLGEucHVzaChvKSk6bz1hW3NdLG99ZnVuY3Rpb24gbigpe2U9bmV3IFdlYWtNYXB9cmV0dXJue2dldDp0LGRpc3Bvc2U6bn19Y2xhc3MgRXUgZXh0ZW5kcyBLbntzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iTWVzaERlcHRoTWF0ZXJpYWwifWNvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5pc01lc2hEZXB0aE1hdGVyaWFsPSEwLHRoaXMuZGVwdGhQYWNraW5nPTMyMDAsdGhpcy5tYXA9bnVsbCx0aGlzLmFscGhhTWFwPW51bGwsdGhpcy5kaXNwbGFjZW1lbnRNYXA9bnVsbCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPTEsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPTAsdGhpcy53aXJlZnJhbWU9ITEsdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9MSx0aGlzLnNldFZhbHVlcyhlKX1jb3B5KGUpe3JldHVybiBzdXBlci5jb3B5KGUpLHRoaXMuZGVwdGhQYWNraW5nPWUuZGVwdGhQYWNraW5nLHRoaXMubWFwPWUubWFwLHRoaXMuYWxwaGFNYXA9ZS5hbHBoYU1hcCx0aGlzLmRpc3BsYWNlbWVudE1hcD1lLmRpc3BsYWNlbWVudE1hcCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPWUuZGlzcGxhY2VtZW50U2NhbGUsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPWUuZGlzcGxhY2VtZW50Qmlhcyx0aGlzLndpcmVmcmFtZT1lLndpcmVmcmFtZSx0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD1lLndpcmVmcmFtZUxpbmV3aWR0aCx0aGlzfX1jbGFzcyB5dSBleHRlbmRzIEtue3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJNZXNoRGlzdGFuY2VNYXRlcmlhbCJ9Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWw9ITAsdGhpcy5tYXA9bnVsbCx0aGlzLmFscGhhTWFwPW51bGwsdGhpcy5kaXNwbGFjZW1lbnRNYXA9bnVsbCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPTEsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPTAsdGhpcy5zZXRWYWx1ZXMoZSl9Y29weShlKXtyZXR1cm4gc3VwZXIuY29weShlKSx0aGlzLm1hcD1lLm1hcCx0aGlzLmFscGhhTWFwPWUuYWxwaGFNYXAsdGhpcy5kaXNwbGFjZW1lbnRNYXA9ZS5kaXNwbGFjZW1lbnRNYXAsdGhpcy5kaXNwbGFjZW1lbnRTY2FsZT1lLmRpc3BsYWNlbWVudFNjYWxlLHRoaXMuZGlzcGxhY2VtZW50Qmlhcz1lLmRpc3BsYWNlbWVudEJpYXMsdGhpc319Y29uc3QgVHU9YHZvaWQgbWFpbigpIHsKCWdsX1Bvc2l0aW9uID0gdmVjNCggcG9zaXRpb24sIDEuMCApOwp9YCxBdT1gdW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93X3Bhc3M7CnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uOwp1bmlmb3JtIGZsb2F0IHJhZGl1czsKI2luY2x1ZGUgPHBhY2tpbmc+CnZvaWQgbWFpbigpIHsKCWNvbnN0IGZsb2F0IHNhbXBsZXMgPSBmbG9hdCggVlNNX1NBTVBMRVMgKTsKCWZsb2F0IG1lYW4gPSAwLjA7CglmbG9hdCBzcXVhcmVkX21lYW4gPSAwLjA7CglmbG9hdCB1dlN0cmlkZSA9IHNhbXBsZXMgPD0gMS4wID8gMC4wIDogMi4wIC8gKCBzYW1wbGVzIC0gMS4wICk7CglmbG9hdCB1dlN0YXJ0ID0gc2FtcGxlcyA8PSAxLjAgPyAwLjAgOiAtIDEuMDsKCWZvciAoIGZsb2F0IGkgPSAwLjA7IGkgPCBzYW1wbGVzOyBpICsrICkgewoJCWZsb2F0IHV2T2Zmc2V0ID0gdXZTdGFydCArIGkgKiB1dlN0cmlkZTsKCQkjaWZkZWYgSE9SSVpPTlRBTF9QQVNTCgkJCXZlYzIgZGlzdHJpYnV0aW9uID0gdW5wYWNrUkdCQVRvMkhhbGYoIHRleHR1cmUyRCggc2hhZG93X3Bhc3MsICggZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMiggdXZPZmZzZXQsIDAuMCApICogcmFkaXVzICkgLyByZXNvbHV0aW9uICkgKTsKCQkJbWVhbiArPSBkaXN0cmlidXRpb24ueDsKCQkJc3F1YXJlZF9tZWFuICs9IGRpc3RyaWJ1dGlvbi55ICogZGlzdHJpYnV0aW9uLnkgKyBkaXN0cmlidXRpb24ueCAqIGRpc3RyaWJ1dGlvbi54OwoJCSNlbHNlCgkJCWZsb2F0IGRlcHRoID0gdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggc2hhZG93X3Bhc3MsICggZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMiggMC4wLCB1dk9mZnNldCApICogcmFkaXVzICkgLyByZXNvbHV0aW9uICkgKTsKCQkJbWVhbiArPSBkZXB0aDsKCQkJc3F1YXJlZF9tZWFuICs9IGRlcHRoICogZGVwdGg7CgkJI2VuZGlmCgl9CgltZWFuID0gbWVhbiAvIHNhbXBsZXM7CglzcXVhcmVkX21lYW4gPSBzcXVhcmVkX21lYW4gLyBzYW1wbGVzOwoJZmxvYXQgc3RkX2RldiA9IHNxcnQoIHNxdWFyZWRfbWVhbiAtIG1lYW4gKiBtZWFuICk7CglnbF9GcmFnQ29sb3IgPSBwYWNrMkhhbGZUb1JHQkEoIHZlYzIoIG1lYW4sIHN0ZF9kZXYgKSApOwp9YDtmdW5jdGlvbiBidShpLGUsdCl7bGV0IG49bmV3IEpyO2NvbnN0IHI9bmV3IExlLHM9bmV3IExlLGE9bmV3IGl0LG89bmV3IEV1KHtkZXB0aFBhY2tpbmc6MzIwMX0pLGw9bmV3IHl1LGM9e30sdT10Lm1heFRleHR1cmVTaXplLGg9ezA6MSwxOjAsMjoyfSxmPW5ldyBodCh7ZGVmaW5lczp7VlNNX1NBTVBMRVM6OH0sdW5pZm9ybXM6e3NoYWRvd19wYXNzOnt2YWx1ZTpudWxsfSxyZXNvbHV0aW9uOnt2YWx1ZTpuZXcgTGV9LHJhZGl1czp7dmFsdWU6NH19LHZlcnRleFNoYWRlcjpUdSxmcmFnbWVudFNoYWRlcjpBdX0pLHA9Zi5jbG9uZSgpO3AuZGVmaW5lcy5IT1JJWk9OVEFMX1BBU1M9MTtjb25zdCBfPW5ldyBDdDtfLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBTdChuZXcgRmxvYXQzMkFycmF5KFstMSwtMSwuNSwzLC0xLC41LC0xLDMsLjVdKSwzKSk7Y29uc3QgeD1uZXcgc3QoXyxmKSxtPXRoaXM7dGhpcy5lbmFibGVkPSExLHRoaXMuYXV0b1VwZGF0ZT0hMCx0aGlzLm5lZWRzVXBkYXRlPSExLHRoaXMudHlwZT0xO2xldCBkPXRoaXMudHlwZTt0aGlzLnJlbmRlcj1mdW5jdGlvbihiLHcsVSl7aWYobS5lbmFibGVkPT09ITF8fG0uYXV0b1VwZGF0ZT09PSExJiZtLm5lZWRzVXBkYXRlPT09ITF8fGIubGVuZ3RoPT09MClyZXR1cm47Y29uc3QgRT1pLmdldFJlbmRlclRhcmdldCgpLFM9aS5nZXRBY3RpdmVDdWJlRmFjZSgpLFI9aS5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpLHE9aS5zdGF0ZTtxLnNldEJsZW5kaW5nKDApLHEuYnVmZmVycy5jb2xvci5zZXRDbGVhcigxLDEsMSwxKSxxLmJ1ZmZlcnMuZGVwdGguc2V0VGVzdCghMCkscS5zZXRTY2lzc29yVGVzdCghMSk7Y29uc3Qgej1kIT09MyYmdGhpcy50eXBlPT09MyxXPWQ9PT0zJiZ0aGlzLnR5cGUhPT0zO2ZvcihsZXQgSz0wLFY9Yi5sZW5ndGg7SzxWO0srKyl7Y29uc3QgUT1iW0tdLEg9US5zaGFkb3c7aWYoSD09PXZvaWQgMCl7Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFNoYWRvd01hcDoiLFEsImhhcyBubyBzaGFkb3cuIik7Y29udGludWV9aWYoSC5hdXRvVXBkYXRlPT09ITEmJkgubmVlZHNVcGRhdGU9PT0hMSljb250aW51ZTtyLmNvcHkoSC5tYXBTaXplKTtjb25zdCBpZT1ILmdldEZyYW1lRXh0ZW50cygpO2lmKHIubXVsdGlwbHkoaWUpLHMuY29weShILm1hcFNpemUpLChyLng+dXx8ci55PnUpJiYoci54PnUmJihzLng9TWF0aC5mbG9vcih1L2llLngpLHIueD1zLngqaWUueCxILm1hcFNpemUueD1zLngpLHIueT51JiYocy55PU1hdGguZmxvb3IodS9pZS55KSxyLnk9cy55KmllLnksSC5tYXBTaXplLnk9cy55KSksSC5tYXA9PT1udWxsfHx6PT09ITB8fFc9PT0hMCl7Y29uc3QgeGU9dGhpcy50eXBlIT09Mz97bWluRmlsdGVyOjEwMDMsbWFnRmlsdGVyOjEwMDN9Ont9O0gubWFwIT09bnVsbCYmSC5tYXAuZGlzcG9zZSgpLEgubWFwPW5ldyBKdChyLngsci55LHhlKSxILm1hcC50ZXh0dXJlLm5hbWU9US5uYW1lKyIuc2hhZG93TWFwIixILmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9aS5zZXRSZW5kZXJUYXJnZXQoSC5tYXApLGkuY2xlYXIoKTtjb25zdCBjZT1ILmdldFZpZXdwb3J0Q291bnQoKTtmb3IobGV0IHhlPTA7eGU8Y2U7eGUrKyl7Y29uc3QgVWU9SC5nZXRWaWV3cG9ydCh4ZSk7YS5zZXQocy54KlVlLngscy55KlVlLnkscy54KlVlLnoscy55KlVlLncpLHEudmlld3BvcnQoYSksSC51cGRhdGVNYXRyaWNlcyhRLHhlKSxuPUguZ2V0RnJ1c3R1bSgpLE0odyxVLEguY2FtZXJhLFEsdGhpcy50eXBlKX1ILmlzUG9pbnRMaWdodFNoYWRvdyE9PSEwJiZ0aGlzLnR5cGU9PT0zJiZBKEgsVSksSC5uZWVkc1VwZGF0ZT0hMX1kPXRoaXMudHlwZSxtLm5lZWRzVXBkYXRlPSExLGkuc2V0UmVuZGVyVGFyZ2V0KEUsUyxSKX07ZnVuY3Rpb24gQShiLHcpe2NvbnN0IFU9ZS51cGRhdGUoeCk7Zi5kZWZpbmVzLlZTTV9TQU1QTEVTIT09Yi5ibHVyU2FtcGxlcyYmKGYuZGVmaW5lcy5WU01fU0FNUExFUz1iLmJsdXJTYW1wbGVzLHAuZGVmaW5lcy5WU01fU0FNUExFUz1iLmJsdXJTYW1wbGVzLGYubmVlZHNVcGRhdGU9ITAscC5uZWVkc1VwZGF0ZT0hMCksYi5tYXBQYXNzPT09bnVsbCYmKGIubWFwUGFzcz1uZXcgSnQoci54LHIueSkpLGYudW5pZm9ybXMuc2hhZG93X3Bhc3MudmFsdWU9Yi5tYXAudGV4dHVyZSxmLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWU9Yi5tYXBTaXplLGYudW5pZm9ybXMucmFkaXVzLnZhbHVlPWIucmFkaXVzLGkuc2V0UmVuZGVyVGFyZ2V0KGIubWFwUGFzcyksaS5jbGVhcigpLGkucmVuZGVyQnVmZmVyRGlyZWN0KHcsbnVsbCxVLGYseCxudWxsKSxwLnVuaWZvcm1zLnNoYWRvd19wYXNzLnZhbHVlPWIubWFwUGFzcy50ZXh0dXJlLHAudW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZT1iLm1hcFNpemUscC51bmlmb3Jtcy5yYWRpdXMudmFsdWU9Yi5yYWRpdXMsaS5zZXRSZW5kZXJUYXJnZXQoYi5tYXApLGkuY2xlYXIoKSxpLnJlbmRlckJ1ZmZlckRpcmVjdCh3LG51bGwsVSxwLHgsbnVsbCl9ZnVuY3Rpb24gVChiLHcsVSxFKXtsZXQgUz1udWxsO2NvbnN0IFI9VS5pc1BvaW50TGlnaHQ9PT0hMD9iLmN1c3RvbURpc3RhbmNlTWF0ZXJpYWw6Yi5jdXN0b21EZXB0aE1hdGVyaWFsO2lmKFIhPT12b2lkIDApUz1SO2Vsc2UgaWYoUz1VLmlzUG9pbnRMaWdodD09PSEwP2w6byxpLmxvY2FsQ2xpcHBpbmdFbmFibGVkJiZ3LmNsaXBTaGFkb3dzPT09ITAmJkFycmF5LmlzQXJyYXkody5jbGlwcGluZ1BsYW5lcykmJncuY2xpcHBpbmdQbGFuZXMubGVuZ3RoIT09MHx8dy5kaXNwbGFjZW1lbnRNYXAmJncuZGlzcGxhY2VtZW50U2NhbGUhPT0wfHx3LmFscGhhTWFwJiZ3LmFscGhhVGVzdD4wfHx3Lm1hcCYmdy5hbHBoYVRlc3Q+MCl7Y29uc3QgcT1TLnV1aWQsej13LnV1aWQ7bGV0IFc9Y1txXTtXPT09dm9pZCAwJiYoVz17fSxjW3FdPVcpO2xldCBLPVdbel07Sz09PXZvaWQgMCYmKEs9Uy5jbG9uZSgpLFdbel09Syx3LmFkZEV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLEYpKSxTPUt9aWYoUy52aXNpYmxlPXcudmlzaWJsZSxTLndpcmVmcmFtZT13LndpcmVmcmFtZSxFPT09Mz9TLnNpZGU9dy5zaGFkb3dTaWRlIT09bnVsbD93LnNoYWRvd1NpZGU6dy5zaWRlOlMuc2lkZT13LnNoYWRvd1NpZGUhPT1udWxsP3cuc2hhZG93U2lkZTpoW3cuc2lkZV0sUy5hbHBoYU1hcD13LmFscGhhTWFwLFMuYWxwaGFUZXN0PXcuYWxwaGFUZXN0LFMubWFwPXcubWFwLFMuY2xpcFNoYWRvd3M9dy5jbGlwU2hhZG93cyxTLmNsaXBwaW5nUGxhbmVzPXcuY2xpcHBpbmdQbGFuZXMsUy5jbGlwSW50ZXJzZWN0aW9uPXcuY2xpcEludGVyc2VjdGlvbixTLmRpc3BsYWNlbWVudE1hcD13LmRpc3BsYWNlbWVudE1hcCxTLmRpc3BsYWNlbWVudFNjYWxlPXcuZGlzcGxhY2VtZW50U2NhbGUsUy5kaXNwbGFjZW1lbnRCaWFzPXcuZGlzcGxhY2VtZW50QmlhcyxTLndpcmVmcmFtZUxpbmV3aWR0aD13LndpcmVmcmFtZUxpbmV3aWR0aCxTLmxpbmV3aWR0aD13LmxpbmV3aWR0aCxVLmlzUG9pbnRMaWdodD09PSEwJiZTLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWw9PT0hMCl7Y29uc3QgcT1pLnByb3BlcnRpZXMuZ2V0KFMpO3EubGlnaHQ9VX1yZXR1cm4gU31mdW5jdGlvbiBNKGIsdyxVLEUsUyl7aWYoYi52aXNpYmxlPT09ITEpcmV0dXJuO2lmKGIubGF5ZXJzLnRlc3Qody5sYXllcnMpJiYoYi5pc01lc2h8fGIuaXNMaW5lfHxiLmlzUG9pbnRzKSYmKGIuY2FzdFNoYWRvd3x8Yi5yZWNlaXZlU2hhZG93JiZTPT09MykmJighYi5mcnVzdHVtQ3VsbGVkfHxuLmludGVyc2VjdHNPYmplY3QoYikpKXtiLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKFUubWF0cml4V29ybGRJbnZlcnNlLGIubWF0cml4V29ybGQpO2NvbnN0IHo9ZS51cGRhdGUoYiksVz1iLm1hdGVyaWFsO2lmKEFycmF5LmlzQXJyYXkoVykpe2NvbnN0IEs9ei5ncm91cHM7Zm9yKGxldCBWPTAsUT1LLmxlbmd0aDtWPFE7VisrKXtjb25zdCBIPUtbVl0saWU9V1tILm1hdGVyaWFsSW5kZXhdO2lmKGllJiZpZS52aXNpYmxlKXtjb25zdCBjZT1UKGIsaWUsRSxTKTtiLm9uQmVmb3JlU2hhZG93KGksYix3LFUseixjZSxIKSxpLnJlbmRlckJ1ZmZlckRpcmVjdChVLG51bGwseixjZSxiLEgpLGIub25BZnRlclNoYWRvdyhpLGIsdyxVLHosY2UsSCl9fX1lbHNlIGlmKFcudmlzaWJsZSl7Y29uc3QgSz1UKGIsVyxFLFMpO2Iub25CZWZvcmVTaGFkb3coaSxiLHcsVSx6LEssbnVsbCksaS5yZW5kZXJCdWZmZXJEaXJlY3QoVSxudWxsLHosSyxiLG51bGwpLGIub25BZnRlclNoYWRvdyhpLGIsdyxVLHosSyxudWxsKX19Y29uc3QgcT1iLmNoaWxkcmVuO2ZvcihsZXQgej0wLFc9cS5sZW5ndGg7ejxXO3orKylNKHFbel0sdyxVLEUsUyl9ZnVuY3Rpb24gRihiKXtiLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCJkaXNwb3NlIixGKTtmb3IoY29uc3QgVSBpbiBjKXtjb25zdCBFPWNbVV0sUz1iLnRhcmdldC51dWlkO1MgaW4gRSYmKEVbU10uZGlzcG9zZSgpLGRlbGV0ZSBFW1NdKX19fWNvbnN0IHd1PXswOjEsMjo2LDQ6NywzOjUsMTowLDY6Miw3OjQsNTozfTtmdW5jdGlvbiBSdShpLGUpe2Z1bmN0aW9uIHQoKXtsZXQgQz0hMTtjb25zdCBuZT1uZXcgaXQ7bGV0IEc9bnVsbDtjb25zdCAkPW5ldyBpdCgwLDAsMCwwKTtyZXR1cm57c2V0TWFzazpmdW5jdGlvbihsZSl7RyE9PWxlJiYhQyYmKGkuY29sb3JNYXNrKGxlLGxlLGxlLGxlKSxHPWxlKX0sc2V0TG9ja2VkOmZ1bmN0aW9uKGxlKXtDPWxlfSxzZXRDbGVhcjpmdW5jdGlvbihsZSxhZSxSZSxudCxtdCl7bXQ9PT0hMCYmKGxlKj1udCxhZSo9bnQsUmUqPW50KSxuZS5zZXQobGUsYWUsUmUsbnQpLCQuZXF1YWxzKG5lKT09PSExJiYoaS5jbGVhckNvbG9yKGxlLGFlLFJlLG50KSwkLmNvcHkobmUpKX0scmVzZXQ6ZnVuY3Rpb24oKXtDPSExLEc9bnVsbCwkLnNldCgtMSwwLDAsMCl9fX1mdW5jdGlvbiBuKCl7bGV0IEM9ITEsbmU9ITEsRz1udWxsLCQ9bnVsbCxsZT1udWxsO3JldHVybntzZXRSZXZlcnNlZDpmdW5jdGlvbihhZSl7aWYobmUhPT1hZSl7Y29uc3QgUmU9ZS5nZXQoIkVYVF9jbGlwX2NvbnRyb2wiKTtuZT9SZS5jbGlwQ29udHJvbEVYVChSZS5MT1dFUl9MRUZUX0VYVCxSZS5aRVJPX1RPX09ORV9FWFQpOlJlLmNsaXBDb250cm9sRVhUKFJlLkxPV0VSX0xFRlRfRVhULFJlLk5FR0FUSVZFX09ORV9UT19PTkVfRVhUKTtjb25zdCBudD1sZTtsZT1udWxsLHRoaXMuc2V0Q2xlYXIobnQpfW5lPWFlfSxnZXRSZXZlcnNlZDpmdW5jdGlvbigpe3JldHVybiBuZX0sc2V0VGVzdDpmdW5jdGlvbihhZSl7YWU/cmUoaS5ERVBUSF9URVNUKTp5ZShpLkRFUFRIX1RFU1QpfSxzZXRNYXNrOmZ1bmN0aW9uKGFlKXtHIT09YWUmJiFDJiYoaS5kZXB0aE1hc2soYWUpLEc9YWUpfSxzZXRGdW5jOmZ1bmN0aW9uKGFlKXtpZihuZSYmKGFlPXd1W2FlXSksJCE9PWFlKXtzd2l0Y2goYWUpe2Nhc2UgMDppLmRlcHRoRnVuYyhpLk5FVkVSKTticmVhaztjYXNlIDE6aS5kZXB0aEZ1bmMoaS5BTFdBWVMpO2JyZWFrO2Nhc2UgMjppLmRlcHRoRnVuYyhpLkxFU1MpO2JyZWFrO2Nhc2UgMzppLmRlcHRoRnVuYyhpLkxFUVVBTCk7YnJlYWs7Y2FzZSA0OmkuZGVwdGhGdW5jKGkuRVFVQUwpO2JyZWFrO2Nhc2UgNTppLmRlcHRoRnVuYyhpLkdFUVVBTCk7YnJlYWs7Y2FzZSA2OmkuZGVwdGhGdW5jKGkuR1JFQVRFUik7YnJlYWs7Y2FzZSA3OmkuZGVwdGhGdW5jKGkuTk9URVFVQUwpO2JyZWFrO2RlZmF1bHQ6aS5kZXB0aEZ1bmMoaS5MRVFVQUwpfSQ9YWV9fSxzZXRMb2NrZWQ6ZnVuY3Rpb24oYWUpe0M9YWV9LHNldENsZWFyOmZ1bmN0aW9uKGFlKXtsZSE9PWFlJiYobmUmJihhZT0xLWFlKSxpLmNsZWFyRGVwdGgoYWUpLGxlPWFlKX0scmVzZXQ6ZnVuY3Rpb24oKXtDPSExLEc9bnVsbCwkPW51bGwsbGU9bnVsbCxuZT0hMX19fWZ1bmN0aW9uIHIoKXtsZXQgQz0hMSxuZT1udWxsLEc9bnVsbCwkPW51bGwsbGU9bnVsbCxhZT1udWxsLFJlPW51bGwsbnQ9bnVsbCxtdD1udWxsO3JldHVybntzZXRUZXN0OmZ1bmN0aW9uKFhlKXtDfHwoWGU/cmUoaS5TVEVOQ0lMX1RFU1QpOnllKGkuU1RFTkNJTF9URVNUKSl9LHNldE1hc2s6ZnVuY3Rpb24oWGUpe25lIT09WGUmJiFDJiYoaS5zdGVuY2lsTWFzayhYZSksbmU9WGUpfSxzZXRGdW5jOmZ1bmN0aW9uKFhlLE90LFp0KXsoRyE9PVhlfHwkIT09T3R8fGxlIT09WnQpJiYoaS5zdGVuY2lsRnVuYyhYZSxPdCxadCksRz1YZSwkPU90LGxlPVp0KX0sc2V0T3A6ZnVuY3Rpb24oWGUsT3QsWnQpeyhhZSE9PVhlfHxSZSE9PU90fHxudCE9PVp0KSYmKGkuc3RlbmNpbE9wKFhlLE90LFp0KSxhZT1YZSxSZT1PdCxudD1adCl9LHNldExvY2tlZDpmdW5jdGlvbihYZSl7Qz1YZX0sc2V0Q2xlYXI6ZnVuY3Rpb24oWGUpe210IT09WGUmJihpLmNsZWFyU3RlbmNpbChYZSksbXQ9WGUpfSxyZXNldDpmdW5jdGlvbigpe0M9ITEsbmU9bnVsbCxHPW51bGwsJD1udWxsLGxlPW51bGwsYWU9bnVsbCxSZT1udWxsLG50PW51bGwsbXQ9bnVsbH19fWNvbnN0IHM9bmV3IHQsYT1uZXcgbixvPW5ldyByLGw9bmV3IFdlYWtNYXAsYz1uZXcgV2Vha01hcDtsZXQgdT17fSxoPXt9LGY9bmV3IFdlYWtNYXAscD1bXSxfPW51bGwseD0hMSxtPW51bGwsZD1udWxsLEE9bnVsbCxUPW51bGwsTT1udWxsLEY9bnVsbCxiPW51bGwsdz1uZXcgVmUoMCwwLDApLFU9MCxFPSExLFM9bnVsbCxSPW51bGwscT1udWxsLHo9bnVsbCxXPW51bGw7Y29uc3QgSz1pLmdldFBhcmFtZXRlcihpLk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTKTtsZXQgVj0hMSxRPTA7Y29uc3QgSD1pLmdldFBhcmFtZXRlcihpLlZFUlNJT04pO0guaW5kZXhPZigiV2ViR0wiKSE9PS0xPyhRPXBhcnNlRmxvYXQoL15XZWJHTCAoXGQpLy5leGVjKEgpWzFdKSxWPVE+PTEpOkguaW5kZXhPZigiT3BlbkdMIEVTIikhPT0tMSYmKFE9cGFyc2VGbG9hdCgvXk9wZW5HTCBFUyAoXGQpLy5leGVjKEgpWzFdKSxWPVE+PTIpO2xldCBpZT1udWxsLGNlPXt9O2NvbnN0IHhlPWkuZ2V0UGFyYW1ldGVyKGkuU0NJU1NPUl9CT1gpLFVlPWkuZ2V0UGFyYW1ldGVyKGkuVklFV1BPUlQpLFllPW5ldyBpdCgpLmZyb21BcnJheSh4ZSksWD1uZXcgaXQoKS5mcm9tQXJyYXkoVWUpO2Z1bmN0aW9uIGVlKEMsbmUsRywkKXtjb25zdCBsZT1uZXcgVWludDhBcnJheSg0KSxhZT1pLmNyZWF0ZVRleHR1cmUoKTtpLmJpbmRUZXh0dXJlKEMsYWUpLGkudGV4UGFyYW1ldGVyaShDLGkuVEVYVFVSRV9NSU5fRklMVEVSLGkuTkVBUkVTVCksaS50ZXhQYXJhbWV0ZXJpKEMsaS5URVhUVVJFX01BR19GSUxURVIsaS5ORUFSRVNUKTtmb3IobGV0IFJlPTA7UmU8RztSZSsrKUM9PT1pLlRFWFRVUkVfM0R8fEM9PT1pLlRFWFRVUkVfMkRfQVJSQVk/aS50ZXhJbWFnZTNEKG5lLDAsaS5SR0JBLDEsMSwkLDAsaS5SR0JBLGkuVU5TSUdORURfQllURSxsZSk6aS50ZXhJbWFnZTJEKG5lK1JlLDAsaS5SR0JBLDEsMSwwLGkuUkdCQSxpLlVOU0lHTkVEX0JZVEUsbGUpO3JldHVybiBhZX1jb25zdCBfZT17fTtfZVtpLlRFWFRVUkVfMkRdPWVlKGkuVEVYVFVSRV8yRCxpLlRFWFRVUkVfMkQsMSksX2VbaS5URVhUVVJFX0NVQkVfTUFQXT1lZShpLlRFWFRVUkVfQ1VCRV9NQVAsaS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsNiksX2VbaS5URVhUVVJFXzJEX0FSUkFZXT1lZShpLlRFWFRVUkVfMkRfQVJSQVksaS5URVhUVVJFXzJEX0FSUkFZLDEsMSksX2VbaS5URVhUVVJFXzNEXT1lZShpLlRFWFRVUkVfM0QsaS5URVhUVVJFXzNELDEsMSkscy5zZXRDbGVhcigwLDAsMCwxKSxhLnNldENsZWFyKDEpLG8uc2V0Q2xlYXIoMCkscmUoaS5ERVBUSF9URVNUKSxhLnNldEZ1bmMoMyksSWUoITEpLE5lKDEpLHJlKGkuQ1VMTF9GQUNFKSxMKDApO2Z1bmN0aW9uIHJlKEMpe3VbQ10hPT0hMCYmKGkuZW5hYmxlKEMpLHVbQ109ITApfWZ1bmN0aW9uIHllKEMpe3VbQ10hPT0hMSYmKGkuZGlzYWJsZShDKSx1W0NdPSExKX1mdW5jdGlvbiBiZShDLG5lKXtyZXR1cm4gaFtDXSE9PW5lPyhpLmJpbmRGcmFtZWJ1ZmZlcihDLG5lKSxoW0NdPW5lLEM9PT1pLkRSQVdfRlJBTUVCVUZGRVImJihoW2kuRlJBTUVCVUZGRVJdPW5lKSxDPT09aS5GUkFNRUJVRkZFUiYmKGhbaS5EUkFXX0ZSQU1FQlVGRkVSXT1uZSksITApOiExfWZ1bmN0aW9uIEZlKEMsbmUpe2xldCBHPXAsJD0hMTtpZihDKXtHPWYuZ2V0KG5lKSxHPT09dm9pZCAwJiYoRz1bXSxmLnNldChuZSxHKSk7Y29uc3QgbGU9Qy50ZXh0dXJlcztpZihHLmxlbmd0aCE9PWxlLmxlbmd0aHx8R1swXSE9PWkuQ09MT1JfQVRUQUNITUVOVDApe2ZvcihsZXQgYWU9MCxSZT1sZS5sZW5ndGg7YWU8UmU7YWUrKylHW2FlXT1pLkNPTE9SX0FUVEFDSE1FTlQwK2FlO0cubGVuZ3RoPWxlLmxlbmd0aCwkPSEwfX1lbHNlIEdbMF0hPT1pLkJBQ0smJihHWzBdPWkuQkFDSywkPSEwKTskJiZpLmRyYXdCdWZmZXJzKEcpfWZ1bmN0aW9uIGV0KEMpe3JldHVybiBfIT09Qz8oaS51c2VQcm9ncmFtKEMpLF89QywhMCk6ITF9Y29uc3QgemU9ezEwMDppLkZVTkNfQURELDEwMTppLkZVTkNfU1VCVFJBQ1QsMTAyOmkuRlVOQ19SRVZFUlNFX1NVQlRSQUNUfTt6ZVsxMDNdPWkuTUlOLHplWzEwNF09aS5NQVg7Y29uc3QgYXQ9ezIwMDppLlpFUk8sMjAxOmkuT05FLDIwMjppLlNSQ19DT0xPUiwyMDQ6aS5TUkNfQUxQSEEsMjEwOmkuU1JDX0FMUEhBX1NBVFVSQVRFLDIwODppLkRTVF9DT0xPUiwyMDY6aS5EU1RfQUxQSEEsMjAzOmkuT05FX01JTlVTX1NSQ19DT0xPUiwyMDU6aS5PTkVfTUlOVVNfU1JDX0FMUEhBLDIwOTppLk9ORV9NSU5VU19EU1RfQ09MT1IsMjA3OmkuT05FX01JTlVTX0RTVF9BTFBIQSwyMTE6aS5DT05TVEFOVF9DT0xPUiwyMTI6aS5PTkVfTUlOVVNfQ09OU1RBTlRfQ09MT1IsMjEzOmkuQ09OU1RBTlRfQUxQSEEsMjE0OmkuT05FX01JTlVTX0NPTlNUQU5UX0FMUEhBfTtmdW5jdGlvbiBMKEMsbmUsRywkLGxlLGFlLFJlLG50LG10LFhlKXtpZihDPT09MCl7eD09PSEwJiYoeWUoaS5CTEVORCkseD0hMSk7cmV0dXJufWlmKHg9PT0hMSYmKHJlKGkuQkxFTkQpLHg9ITApLEMhPT01KXtpZihDIT09bXx8WGUhPT1FKXtpZigoZCE9PTEwMHx8TSE9PTEwMCkmJihpLmJsZW5kRXF1YXRpb24oaS5GVU5DX0FERCksZD0xMDAsTT0xMDApLFhlKXN3aXRjaChDKXtjYXNlIDE6aS5ibGVuZEZ1bmNTZXBhcmF0ZShpLk9ORSxpLk9ORV9NSU5VU19TUkNfQUxQSEEsaS5PTkUsaS5PTkVfTUlOVVNfU1JDX0FMUEhBKTticmVhaztjYXNlIDI6aS5ibGVuZEZ1bmMoaS5PTkUsaS5PTkUpO2JyZWFrO2Nhc2UgMzppLmJsZW5kRnVuY1NlcGFyYXRlKGkuWkVSTyxpLk9ORV9NSU5VU19TUkNfQ09MT1IsaS5aRVJPLGkuT05FKTticmVhaztjYXNlIDQ6aS5ibGVuZEZ1bmNTZXBhcmF0ZShpLlpFUk8saS5TUkNfQ09MT1IsaS5aRVJPLGkuU1JDX0FMUEhBKTticmVhaztkZWZhdWx0OmNvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMU3RhdGU6IEludmFsaWQgYmxlbmRpbmc6ICIsQyk7YnJlYWt9ZWxzZSBzd2l0Y2goQyl7Y2FzZSAxOmkuYmxlbmRGdW5jU2VwYXJhdGUoaS5TUkNfQUxQSEEsaS5PTkVfTUlOVVNfU1JDX0FMUEhBLGkuT05FLGkuT05FX01JTlVTX1NSQ19BTFBIQSk7YnJlYWs7Y2FzZSAyOmkuYmxlbmRGdW5jKGkuU1JDX0FMUEhBLGkuT05FKTticmVhaztjYXNlIDM6aS5ibGVuZEZ1bmNTZXBhcmF0ZShpLlpFUk8saS5PTkVfTUlOVVNfU1JDX0NPTE9SLGkuWkVSTyxpLk9ORSk7YnJlYWs7Y2FzZSA0OmkuYmxlbmRGdW5jKGkuWkVSTyxpLlNSQ19DT0xPUik7YnJlYWs7ZGVmYXVsdDpjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFN0YXRlOiBJbnZhbGlkIGJsZW5kaW5nOiAiLEMpO2JyZWFrfUE9bnVsbCxUPW51bGwsRj1udWxsLGI9bnVsbCx3LnNldCgwLDAsMCksVT0wLG09QyxFPVhlfXJldHVybn1sZT1sZXx8bmUsYWU9YWV8fEcsUmU9UmV8fCQsKG5lIT09ZHx8bGUhPT1NKSYmKGkuYmxlbmRFcXVhdGlvblNlcGFyYXRlKHplW25lXSx6ZVtsZV0pLGQ9bmUsTT1sZSksKEchPT1BfHwkIT09VHx8YWUhPT1GfHxSZSE9PWIpJiYoaS5ibGVuZEZ1bmNTZXBhcmF0ZShhdFtHXSxhdFskXSxhdFthZV0sYXRbUmVdKSxBPUcsVD0kLEY9YWUsYj1SZSksKG50LmVxdWFscyh3KT09PSExfHxtdCE9PVUpJiYoaS5ibGVuZENvbG9yKG50LnIsbnQuZyxudC5iLG10KSx3LmNvcHkobnQpLFU9bXQpLG09QyxFPSExfWZ1bmN0aW9uIFB0KEMsbmUpe0Muc2lkZT09PTI/eWUoaS5DVUxMX0ZBQ0UpOnJlKGkuQ1VMTF9GQUNFKTtsZXQgRz1DLnNpZGU9PT0xO25lJiYoRz0hRyksSWUoRyksQy5ibGVuZGluZz09PTEmJkMudHJhbnNwYXJlbnQ9PT0hMT9MKDApOkwoQy5ibGVuZGluZyxDLmJsZW5kRXF1YXRpb24sQy5ibGVuZFNyYyxDLmJsZW5kRHN0LEMuYmxlbmRFcXVhdGlvbkFscGhhLEMuYmxlbmRTcmNBbHBoYSxDLmJsZW5kRHN0QWxwaGEsQy5ibGVuZENvbG9yLEMuYmxlbmRBbHBoYSxDLnByZW11bHRpcGxpZWRBbHBoYSksYS5zZXRGdW5jKEMuZGVwdGhGdW5jKSxhLnNldFRlc3QoQy5kZXB0aFRlc3QpLGEuc2V0TWFzayhDLmRlcHRoV3JpdGUpLHMuc2V0TWFzayhDLmNvbG9yV3JpdGUpO2NvbnN0ICQ9Qy5zdGVuY2lsV3JpdGU7by5zZXRUZXN0KCQpLCQmJihvLnNldE1hc2soQy5zdGVuY2lsV3JpdGVNYXNrKSxvLnNldEZ1bmMoQy5zdGVuY2lsRnVuYyxDLnN0ZW5jaWxSZWYsQy5zdGVuY2lsRnVuY01hc2spLG8uc2V0T3AoQy5zdGVuY2lsRmFpbCxDLnN0ZW5jaWxaRmFpbCxDLnN0ZW5jaWxaUGFzcykpLGplKEMucG9seWdvbk9mZnNldCxDLnBvbHlnb25PZmZzZXRGYWN0b3IsQy5wb2x5Z29uT2Zmc2V0VW5pdHMpLEMuYWxwaGFUb0NvdmVyYWdlPT09ITA/cmUoaS5TQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UpOnllKGkuU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFKX1mdW5jdGlvbiBJZShDKXtTIT09QyYmKEM/aS5mcm9udEZhY2UoaS5DVyk6aS5mcm9udEZhY2UoaS5DQ1cpLFM9Qyl9ZnVuY3Rpb24gTmUoQyl7QyE9PTA/KHJlKGkuQ1VMTF9GQUNFKSxDIT09UiYmKEM9PT0xP2kuY3VsbEZhY2UoaS5CQUNLKTpDPT09Mj9pLmN1bGxGYWNlKGkuRlJPTlQpOmkuY3VsbEZhY2UoaS5GUk9OVF9BTkRfQkFDSykpKTp5ZShpLkNVTExfRkFDRSksUj1DfWZ1bmN0aW9uIFNlKEMpe0MhPT1xJiYoViYmaS5saW5lV2lkdGgoQykscT1DKX1mdW5jdGlvbiBqZShDLG5lLEcpe0M/KHJlKGkuUE9MWUdPTl9PRkZTRVRfRklMTCksKHohPT1uZXx8VyE9PUcpJiYoaS5wb2x5Z29uT2Zmc2V0KG5lLEcpLHo9bmUsVz1HKSk6eWUoaS5QT0xZR09OX09GRlNFVF9GSUxMKX1mdW5jdGlvbiBNZShDKXtDP3JlKGkuU0NJU1NPUl9URVNUKTp5ZShpLlNDSVNTT1JfVEVTVCl9ZnVuY3Rpb24geShDKXtDPT09dm9pZCAwJiYoQz1pLlRFWFRVUkUwK0stMSksaWUhPT1DJiYoaS5hY3RpdmVUZXh0dXJlKEMpLGllPUMpfWZ1bmN0aW9uIGcoQyxuZSxHKXtHPT09dm9pZCAwJiYoaWU9PT1udWxsP0c9aS5URVhUVVJFMCtLLTE6Rz1pZSk7bGV0ICQ9Y2VbR107JD09PXZvaWQgMCYmKCQ9e3R5cGU6dm9pZCAwLHRleHR1cmU6dm9pZCAwfSxjZVtHXT0kKSwoJC50eXBlIT09Q3x8JC50ZXh0dXJlIT09bmUpJiYoaWUhPT1HJiYoaS5hY3RpdmVUZXh0dXJlKEcpLGllPUcpLGkuYmluZFRleHR1cmUoQyxuZXx8X2VbQ10pLCQudHlwZT1DLCQudGV4dHVyZT1uZSl9ZnVuY3Rpb24gSSgpe2NvbnN0IEM9Y2VbaWVdO0MhPT12b2lkIDAmJkMudHlwZSE9PXZvaWQgMCYmKGkuYmluZFRleHR1cmUoQy50eXBlLG51bGwpLEMudHlwZT12b2lkIDAsQy50ZXh0dXJlPXZvaWQgMCl9ZnVuY3Rpb24gWSgpe3RyeXtpLmNvbXByZXNzZWRUZXhJbWFnZTJELmFwcGx5KGksYXJndW1lbnRzKX1jYXRjaChDKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFN0YXRlOiIsQyl9fWZ1bmN0aW9uIFooKXt0cnl7aS5jb21wcmVzc2VkVGV4SW1hZ2UzRC5hcHBseShpLGFyZ3VtZW50cyl9Y2F0Y2goQyl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZToiLEMpfX1mdW5jdGlvbiBrKCl7dHJ5e2kudGV4U3ViSW1hZ2UyRC5hcHBseShpLGFyZ3VtZW50cyl9Y2F0Y2goQyl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZToiLEMpfX1mdW5jdGlvbiBnZSgpe3RyeXtpLnRleFN1YkltYWdlM0QuYXBwbHkoaSxhcmd1bWVudHMpfWNhdGNoKEMpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMU3RhdGU6IixDKX19ZnVuY3Rpb24gc2UoKXt0cnl7aS5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRC5hcHBseShpLGFyZ3VtZW50cyl9Y2F0Y2goQyl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZToiLEMpfX1mdW5jdGlvbiB1ZSgpe3RyeXtpLmNvbXByZXNzZWRUZXhTdWJJbWFnZTNELmFwcGx5KGksYXJndW1lbnRzKX1jYXRjaChDKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFN0YXRlOiIsQyl9fWZ1bmN0aW9uIEdlKCl7dHJ5e2kudGV4U3RvcmFnZTJELmFwcGx5KGksYXJndW1lbnRzKX1jYXRjaChDKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFN0YXRlOiIsQyl9fWZ1bmN0aW9uIGooKXt0cnl7aS50ZXhTdG9yYWdlM0QuYXBwbHkoaSxhcmd1bWVudHMpfWNhdGNoKEMpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMU3RhdGU6IixDKX19ZnVuY3Rpb24gaGUoKXt0cnl7aS50ZXhJbWFnZTJELmFwcGx5KGksYXJndW1lbnRzKX1jYXRjaChDKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFN0YXRlOiIsQyl9fWZ1bmN0aW9uIEVlKCl7dHJ5e2kudGV4SW1hZ2UzRC5hcHBseShpLGFyZ3VtZW50cyl9Y2F0Y2goQyl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZToiLEMpfX1mdW5jdGlvbiBUZShDKXtZZS5lcXVhbHMoQyk9PT0hMSYmKGkuc2Npc3NvcihDLngsQy55LEMueixDLncpLFllLmNvcHkoQykpfWZ1bmN0aW9uIGRlKEMpe1guZXF1YWxzKEMpPT09ITEmJihpLnZpZXdwb3J0KEMueCxDLnksQy56LEMudyksWC5jb3B5KEMpKX1mdW5jdGlvbiBPZShDLG5lKXtsZXQgRz1jLmdldChuZSk7Rz09PXZvaWQgMCYmKEc9bmV3IFdlYWtNYXAsYy5zZXQobmUsRykpO2xldCAkPUcuZ2V0KEMpOyQ9PT12b2lkIDAmJigkPWkuZ2V0VW5pZm9ybUJsb2NrSW5kZXgobmUsQy5uYW1lKSxHLnNldChDLCQpKX1mdW5jdGlvbiBEZShDLG5lKXtjb25zdCAkPWMuZ2V0KG5lKS5nZXQoQyk7bC5nZXQobmUpIT09JCYmKGkudW5pZm9ybUJsb2NrQmluZGluZyhuZSwkLEMuX19iaW5kaW5nUG9pbnRJbmRleCksbC5zZXQobmUsJCkpfWZ1bmN0aW9uIFplKCl7aS5kaXNhYmxlKGkuQkxFTkQpLGkuZGlzYWJsZShpLkNVTExfRkFDRSksaS5kaXNhYmxlKGkuREVQVEhfVEVTVCksaS5kaXNhYmxlKGkuUE9MWUdPTl9PRkZTRVRfRklMTCksaS5kaXNhYmxlKGkuU0NJU1NPUl9URVNUKSxpLmRpc2FibGUoaS5TVEVOQ0lMX1RFU1QpLGkuZGlzYWJsZShpLlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSksaS5ibGVuZEVxdWF0aW9uKGkuRlVOQ19BREQpLGkuYmxlbmRGdW5jKGkuT05FLGkuWkVSTyksaS5ibGVuZEZ1bmNTZXBhcmF0ZShpLk9ORSxpLlpFUk8saS5PTkUsaS5aRVJPKSxpLmJsZW5kQ29sb3IoMCwwLDAsMCksaS5jb2xvck1hc2soITAsITAsITAsITApLGkuY2xlYXJDb2xvcigwLDAsMCwwKSxpLmRlcHRoTWFzayghMCksaS5kZXB0aEZ1bmMoaS5MRVNTKSxhLnNldFJldmVyc2VkKCExKSxpLmNsZWFyRGVwdGgoMSksaS5zdGVuY2lsTWFzayg0Mjk0OTY3Mjk1KSxpLnN0ZW5jaWxGdW5jKGkuQUxXQVlTLDAsNDI5NDk2NzI5NSksaS5zdGVuY2lsT3AoaS5LRUVQLGkuS0VFUCxpLktFRVApLGkuY2xlYXJTdGVuY2lsKDApLGkuY3VsbEZhY2UoaS5CQUNLKSxpLmZyb250RmFjZShpLkNDVyksaS5wb2x5Z29uT2Zmc2V0KDAsMCksaS5hY3RpdmVUZXh0dXJlKGkuVEVYVFVSRTApLGkuYmluZEZyYW1lYnVmZmVyKGkuRlJBTUVCVUZGRVIsbnVsbCksaS5iaW5kRnJhbWVidWZmZXIoaS5EUkFXX0ZSQU1FQlVGRkVSLG51bGwpLGkuYmluZEZyYW1lYnVmZmVyKGkuUkVBRF9GUkFNRUJVRkZFUixudWxsKSxpLnVzZVByb2dyYW0obnVsbCksaS5saW5lV2lkdGgoMSksaS5zY2lzc29yKDAsMCxpLmNhbnZhcy53aWR0aCxpLmNhbnZhcy5oZWlnaHQpLGkudmlld3BvcnQoMCwwLGkuY2FudmFzLndpZHRoLGkuY2FudmFzLmhlaWdodCksdT17fSxpZT1udWxsLGNlPXt9LGg9e30sZj1uZXcgV2Vha01hcCxwPVtdLF89bnVsbCx4PSExLG09bnVsbCxkPW51bGwsQT1udWxsLFQ9bnVsbCxNPW51bGwsRj1udWxsLGI9bnVsbCx3PW5ldyBWZSgwLDAsMCksVT0wLEU9ITEsUz1udWxsLFI9bnVsbCxxPW51bGwsej1udWxsLFc9bnVsbCxZZS5zZXQoMCwwLGkuY2FudmFzLndpZHRoLGkuY2FudmFzLmhlaWdodCksWC5zZXQoMCwwLGkuY2FudmFzLndpZHRoLGkuY2FudmFzLmhlaWdodCkscy5yZXNldCgpLGEucmVzZXQoKSxvLnJlc2V0KCl9cmV0dXJue2J1ZmZlcnM6e2NvbG9yOnMsZGVwdGg6YSxzdGVuY2lsOm99LGVuYWJsZTpyZSxkaXNhYmxlOnllLGJpbmRGcmFtZWJ1ZmZlcjpiZSxkcmF3QnVmZmVyczpGZSx1c2VQcm9ncmFtOmV0LHNldEJsZW5kaW5nOkwsc2V0TWF0ZXJpYWw6UHQsc2V0RmxpcFNpZGVkOkllLHNldEN1bGxGYWNlOk5lLHNldExpbmVXaWR0aDpTZSxzZXRQb2x5Z29uT2Zmc2V0OmplLHNldFNjaXNzb3JUZXN0Ok1lLGFjdGl2ZVRleHR1cmU6eSxiaW5kVGV4dHVyZTpnLHVuYmluZFRleHR1cmU6SSxjb21wcmVzc2VkVGV4SW1hZ2UyRDpZLGNvbXByZXNzZWRUZXhJbWFnZTNEOlosdGV4SW1hZ2UyRDpoZSx0ZXhJbWFnZTNEOkVlLHVwZGF0ZVVCT01hcHBpbmc6T2UsdW5pZm9ybUJsb2NrQmluZGluZzpEZSx0ZXhTdG9yYWdlMkQ6R2UsdGV4U3RvcmFnZTNEOmosdGV4U3ViSW1hZ2UyRDprLHRleFN1YkltYWdlM0Q6Z2UsY29tcHJlc3NlZFRleFN1YkltYWdlMkQ6c2UsY29tcHJlc3NlZFRleFN1YkltYWdlM0Q6dWUsc2Npc3NvcjpUZSx2aWV3cG9ydDpkZSxyZXNldDpaZX19ZnVuY3Rpb24gQ3MoaSxlLHQsbil7Y29uc3Qgcj1DdShuKTtzd2l0Y2godCl7Y2FzZSAxMDIxOnJldHVybiBpKmU7Y2FzZSAxMDI0OnJldHVybiBpKmU7Y2FzZSAxMDI1OnJldHVybiBpKmUqMjtjYXNlIDEwMjg6cmV0dXJuIGkqZS9yLmNvbXBvbmVudHMqci5ieXRlTGVuZ3RoO2Nhc2UgMTAyOTpyZXR1cm4gaSplL3IuY29tcG9uZW50cypyLmJ5dGVMZW5ndGg7Y2FzZSAxMDMwOnJldHVybiBpKmUqMi9yLmNvbXBvbmVudHMqci5ieXRlTGVuZ3RoO2Nhc2UgMTAzMTpyZXR1cm4gaSplKjIvci5jb21wb25lbnRzKnIuYnl0ZUxlbmd0aDtjYXNlIDEwMjI6cmV0dXJuIGkqZSozL3IuY29tcG9uZW50cypyLmJ5dGVMZW5ndGg7Y2FzZSAxMDIzOnJldHVybiBpKmUqNC9yLmNvbXBvbmVudHMqci5ieXRlTGVuZ3RoO2Nhc2UgMTAzMzpyZXR1cm4gaSplKjQvci5jb21wb25lbnRzKnIuYnl0ZUxlbmd0aDtjYXNlIDMzNzc2OmNhc2UgMzM3Nzc6cmV0dXJuIE1hdGguZmxvb3IoKGkrMykvNCkqTWF0aC5mbG9vcigoZSszKS80KSo4O2Nhc2UgMzM3Nzg6Y2FzZSAzMzc3OTpyZXR1cm4gTWF0aC5mbG9vcigoaSszKS80KSpNYXRoLmZsb29yKChlKzMpLzQpKjE2O2Nhc2UgMzU4NDE6Y2FzZSAzNTg0MzpyZXR1cm4gTWF0aC5tYXgoaSwxNikqTWF0aC5tYXgoZSw4KS80O2Nhc2UgMzU4NDA6Y2FzZSAzNTg0MjpyZXR1cm4gTWF0aC5tYXgoaSw4KSpNYXRoLm1heChlLDgpLzI7Y2FzZSAzNjE5NjpjYXNlIDM3NDkyOnJldHVybiBNYXRoLmZsb29yKChpKzMpLzQpKk1hdGguZmxvb3IoKGUrMykvNCkqODtjYXNlIDM3NDk2OnJldHVybiBNYXRoLmZsb29yKChpKzMpLzQpKk1hdGguZmxvb3IoKGUrMykvNCkqMTY7Y2FzZSAzNzgwODpyZXR1cm4gTWF0aC5mbG9vcigoaSszKS80KSpNYXRoLmZsb29yKChlKzMpLzQpKjE2O2Nhc2UgMzc4MDk6cmV0dXJuIE1hdGguZmxvb3IoKGkrNCkvNSkqTWF0aC5mbG9vcigoZSszKS80KSoxNjtjYXNlIDM3ODEwOnJldHVybiBNYXRoLmZsb29yKChpKzQpLzUpKk1hdGguZmxvb3IoKGUrNCkvNSkqMTY7Y2FzZSAzNzgxMTpyZXR1cm4gTWF0aC5mbG9vcigoaSs1KS82KSpNYXRoLmZsb29yKChlKzQpLzUpKjE2O2Nhc2UgMzc4MTI6cmV0dXJuIE1hdGguZmxvb3IoKGkrNSkvNikqTWF0aC5mbG9vcigoZSs1KS82KSoxNjtjYXNlIDM3ODEzOnJldHVybiBNYXRoLmZsb29yKChpKzcpLzgpKk1hdGguZmxvb3IoKGUrNCkvNSkqMTY7Y2FzZSAzNzgxNDpyZXR1cm4gTWF0aC5mbG9vcigoaSs3KS84KSpNYXRoLmZsb29yKChlKzUpLzYpKjE2O2Nhc2UgMzc4MTU6cmV0dXJuIE1hdGguZmxvb3IoKGkrNykvOCkqTWF0aC5mbG9vcigoZSs3KS84KSoxNjtjYXNlIDM3ODE2OnJldHVybiBNYXRoLmZsb29yKChpKzkpLzEwKSpNYXRoLmZsb29yKChlKzQpLzUpKjE2O2Nhc2UgMzc4MTc6cmV0dXJuIE1hdGguZmxvb3IoKGkrOSkvMTApKk1hdGguZmxvb3IoKGUrNSkvNikqMTY7Y2FzZSAzNzgxODpyZXR1cm4gTWF0aC5mbG9vcigoaSs5KS8xMCkqTWF0aC5mbG9vcigoZSs3KS84KSoxNjtjYXNlIDM3ODE5OnJldHVybiBNYXRoLmZsb29yKChpKzkpLzEwKSpNYXRoLmZsb29yKChlKzkpLzEwKSoxNjtjYXNlIDM3ODIwOnJldHVybiBNYXRoLmZsb29yKChpKzExKS8xMikqTWF0aC5mbG9vcigoZSs5KS8xMCkqMTY7Y2FzZSAzNzgyMTpyZXR1cm4gTWF0aC5mbG9vcigoaSsxMSkvMTIpKk1hdGguZmxvb3IoKGUrMTEpLzEyKSoxNjtjYXNlIDM2NDkyOmNhc2UgMzY0OTQ6Y2FzZSAzNjQ5NTpyZXR1cm4gTWF0aC5jZWlsKGkvNCkqTWF0aC5jZWlsKGUvNCkqMTY7Y2FzZSAzNjI4MzpjYXNlIDM2Mjg0OnJldHVybiBNYXRoLmNlaWwoaS80KSpNYXRoLmNlaWwoZS80KSo4O2Nhc2UgMzYyODU6Y2FzZSAzNjI4NjpyZXR1cm4gTWF0aC5jZWlsKGkvNCkqTWF0aC5jZWlsKGUvNCkqMTZ9dGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZGV0ZXJtaW5lIHRleHR1cmUgYnl0ZSBsZW5ndGggZm9yICR7dH0gZm9ybWF0LmApfWZ1bmN0aW9uIEN1KGkpe3N3aXRjaChpKXtjYXNlIDEwMDk6Y2FzZSAxMDEwOnJldHVybntieXRlTGVuZ3RoOjEsY29tcG9uZW50czoxfTtjYXNlIDEwMTI6Y2FzZSAxMDExOmNhc2UgMTAxNjpyZXR1cm57Ynl0ZUxlbmd0aDoyLGNvbXBvbmVudHM6MX07Y2FzZSAxMDE3OmNhc2UgMTAxODpyZXR1cm57Ynl0ZUxlbmd0aDoyLGNvbXBvbmVudHM6NH07Y2FzZSAxMDE0OmNhc2UgMTAxMzpjYXNlIDEwMTU6cmV0dXJue2J5dGVMZW5ndGg6NCxjb21wb25lbnRzOjF9O2Nhc2UgMzU5MDI6cmV0dXJue2J5dGVMZW5ndGg6NCxjb21wb25lbnRzOjN9fXRocm93IG5ldyBFcnJvcihgVW5rbm93biB0ZXh0dXJlIHR5cGUgJHtpfS5gKX1mdW5jdGlvbiBQdShpLGUsdCxuLHIscyxhKXtjb25zdCBvPWUuaGFzKCJXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUiKT9lLmdldCgiV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlIik6bnVsbCxsPXR5cGVvZiBuYXZpZ2F0b3I+InUiPyExOi9PY3VsdXNCcm93c2VyL2cudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxjPW5ldyBMZSx1PW5ldyBXZWFrTWFwO2xldCBoO2NvbnN0IGY9bmV3IFdlYWtNYXA7bGV0IHA9ITE7dHJ5e3A9dHlwZW9mIE9mZnNjcmVlbkNhbnZhczwidSImJm5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKS5nZXRDb250ZXh0KCIyZCIpIT09bnVsbH1jYXRjaHt9ZnVuY3Rpb24gXyh5LGcpe3JldHVybiBwP25ldyBPZmZzY3JlZW5DYW52YXMoeSxnKTpyaSgiY2FudmFzIil9ZnVuY3Rpb24geCh5LGcsSSl7bGV0IFk9MTtjb25zdCBaPU1lKHkpO2lmKChaLndpZHRoPkl8fFouaGVpZ2h0PkkpJiYoWT1JL01hdGgubWF4KFoud2lkdGgsWi5oZWlnaHQpKSxZPDEpaWYodHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQ8InUiJiZ5IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudHx8dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50PCJ1IiYmeSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50fHx0eXBlb2YgSW1hZ2VCaXRtYXA8InUiJiZ5IGluc3RhbmNlb2YgSW1hZ2VCaXRtYXB8fHR5cGVvZiBWaWRlb0ZyYW1lPCJ1IiYmeSBpbnN0YW5jZW9mIFZpZGVvRnJhbWUpe2NvbnN0IGs9TWF0aC5mbG9vcihZKloud2lkdGgpLGdlPU1hdGguZmxvb3IoWSpaLmhlaWdodCk7aD09PXZvaWQgMCYmKGg9XyhrLGdlKSk7Y29uc3Qgc2U9Zz9fKGssZ2UpOmg7cmV0dXJuIHNlLndpZHRoPWssc2UuaGVpZ2h0PWdlLHNlLmdldENvbnRleHQoIjJkIikuZHJhd0ltYWdlKHksMCwwLGssZ2UpLGNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBoYXMgYmVlbiByZXNpemVkIGZyb20gKCIrWi53aWR0aCsieCIrWi5oZWlnaHQrIikgdG8gKCIraysieCIrZ2UrIikuIiksc2V9ZWxzZSByZXR1cm4iZGF0YSJpbiB5JiZjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IEltYWdlIGluIERhdGFUZXh0dXJlIGlzIHRvbyBiaWcgKCIrWi53aWR0aCsieCIrWi5oZWlnaHQrIikuIikseTtyZXR1cm4geX1mdW5jdGlvbiBtKHkpe3JldHVybiB5LmdlbmVyYXRlTWlwbWFwc31mdW5jdGlvbiBkKHkpe2kuZ2VuZXJhdGVNaXBtYXAoeSl9ZnVuY3Rpb24gQSh5KXtyZXR1cm4geS5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldD9pLlRFWFRVUkVfQ1VCRV9NQVA6eS5pc1dlYkdMM0RSZW5kZXJUYXJnZXQ/aS5URVhUVVJFXzNEOnkuaXNXZWJHTEFycmF5UmVuZGVyVGFyZ2V0fHx5LmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZT9pLlRFWFRVUkVfMkRfQVJSQVk6aS5URVhUVVJFXzJEfWZ1bmN0aW9uIFQoeSxnLEksWSxaPSExKXtpZih5IT09bnVsbCl7aWYoaVt5XSE9PXZvaWQgMClyZXR1cm4gaVt5XTtjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gdXNlIG5vbi1leGlzdGluZyBXZWJHTCBpbnRlcm5hbCBmb3JtYXQgJyIreSsiJyIpfWxldCBrPWc7aWYoZz09PWkuUkVEJiYoST09PWkuRkxPQVQmJihrPWkuUjMyRiksST09PWkuSEFMRl9GTE9BVCYmKGs9aS5SMTZGKSxJPT09aS5VTlNJR05FRF9CWVRFJiYoaz1pLlI4KSksZz09PWkuUkVEX0lOVEVHRVImJihJPT09aS5VTlNJR05FRF9CWVRFJiYoaz1pLlI4VUkpLEk9PT1pLlVOU0lHTkVEX1NIT1JUJiYoaz1pLlIxNlVJKSxJPT09aS5VTlNJR05FRF9JTlQmJihrPWkuUjMyVUkpLEk9PT1pLkJZVEUmJihrPWkuUjhJKSxJPT09aS5TSE9SVCYmKGs9aS5SMTZJKSxJPT09aS5JTlQmJihrPWkuUjMySSkpLGc9PT1pLlJHJiYoST09PWkuRkxPQVQmJihrPWkuUkczMkYpLEk9PT1pLkhBTEZfRkxPQVQmJihrPWkuUkcxNkYpLEk9PT1pLlVOU0lHTkVEX0JZVEUmJihrPWkuUkc4KSksZz09PWkuUkdfSU5URUdFUiYmKEk9PT1pLlVOU0lHTkVEX0JZVEUmJihrPWkuUkc4VUkpLEk9PT1pLlVOU0lHTkVEX1NIT1JUJiYoaz1pLlJHMTZVSSksST09PWkuVU5TSUdORURfSU5UJiYoaz1pLlJHMzJVSSksST09PWkuQllURSYmKGs9aS5SRzhJKSxJPT09aS5TSE9SVCYmKGs9aS5SRzE2SSksST09PWkuSU5UJiYoaz1pLlJHMzJJKSksZz09PWkuUkdCX0lOVEVHRVImJihJPT09aS5VTlNJR05FRF9CWVRFJiYoaz1pLlJHQjhVSSksST09PWkuVU5TSUdORURfU0hPUlQmJihrPWkuUkdCMTZVSSksST09PWkuVU5TSUdORURfSU5UJiYoaz1pLlJHQjMyVUkpLEk9PT1pLkJZVEUmJihrPWkuUkdCOEkpLEk9PT1pLlNIT1JUJiYoaz1pLlJHQjE2SSksST09PWkuSU5UJiYoaz1pLlJHQjMySSkpLGc9PT1pLlJHQkFfSU5URUdFUiYmKEk9PT1pLlVOU0lHTkVEX0JZVEUmJihrPWkuUkdCQThVSSksST09PWkuVU5TSUdORURfU0hPUlQmJihrPWkuUkdCQTE2VUkpLEk9PT1pLlVOU0lHTkVEX0lOVCYmKGs9aS5SR0JBMzJVSSksST09PWkuQllURSYmKGs9aS5SR0JBOEkpLEk9PT1pLlNIT1JUJiYoaz1pLlJHQkExNkkpLEk9PT1pLklOVCYmKGs9aS5SR0JBMzJJKSksZz09PWkuUkdCJiZJPT09aS5VTlNJR05FRF9JTlRfNV85XzlfOV9SRVYmJihrPWkuUkdCOV9FNSksZz09PWkuUkdCQSl7Y29uc3QgZ2U9Wj9paTpCZS5nZXRUcmFuc2ZlcihZKTtJPT09aS5GTE9BVCYmKGs9aS5SR0JBMzJGKSxJPT09aS5IQUxGX0ZMT0FUJiYoaz1pLlJHQkExNkYpLEk9PT1pLlVOU0lHTkVEX0JZVEUmJihrPWdlPT09cWU/aS5TUkdCOF9BTFBIQTg6aS5SR0JBOCksST09PWkuVU5TSUdORURfU0hPUlRfNF80XzRfNCYmKGs9aS5SR0JBNCksST09PWkuVU5TSUdORURfU0hPUlRfNV81XzVfMSYmKGs9aS5SR0I1X0ExKX1yZXR1cm4oaz09PWkuUjE2Rnx8az09PWkuUjMyRnx8az09PWkuUkcxNkZ8fGs9PT1pLlJHMzJGfHxrPT09aS5SR0JBMTZGfHxrPT09aS5SR0JBMzJGKSYmZS5nZXQoIkVYVF9jb2xvcl9idWZmZXJfZmxvYXQiKSxrfWZ1bmN0aW9uIE0oeSxnKXtsZXQgSTtyZXR1cm4geT9nPT09bnVsbHx8Zz09PTEwMTR8fGc9PT0xMDIwP0k9aS5ERVBUSDI0X1NURU5DSUw4Omc9PT0xMDE1P0k9aS5ERVBUSDMyRl9TVEVOQ0lMODpnPT09MTAxMiYmKEk9aS5ERVBUSDI0X1NURU5DSUw4LGNvbnNvbGUud2FybigiRGVwdGhUZXh0dXJlOiAxNiBiaXQgZGVwdGggYXR0YWNobWVudCBpcyBub3Qgc3VwcG9ydGVkIHdpdGggc3RlbmNpbC4gVXNpbmcgMjQtYml0IGF0dGFjaG1lbnQuIikpOmc9PT1udWxsfHxnPT09MTAxNHx8Zz09PTEwMjA/ST1pLkRFUFRIX0NPTVBPTkVOVDI0Omc9PT0xMDE1P0k9aS5ERVBUSF9DT01QT05FTlQzMkY6Zz09PTEwMTImJihJPWkuREVQVEhfQ09NUE9ORU5UMTYpLEl9ZnVuY3Rpb24gRih5LGcpe3JldHVybiBtKHkpPT09ITB8fHkuaXNGcmFtZWJ1ZmZlclRleHR1cmUmJnkubWluRmlsdGVyIT09MTAwMyYmeS5taW5GaWx0ZXIhPT0xMDA2P01hdGgubG9nMihNYXRoLm1heChnLndpZHRoLGcuaGVpZ2h0KSkrMTp5Lm1pcG1hcHMhPT12b2lkIDAmJnkubWlwbWFwcy5sZW5ndGg+MD95Lm1pcG1hcHMubGVuZ3RoOnkuaXNDb21wcmVzc2VkVGV4dHVyZSYmQXJyYXkuaXNBcnJheSh5LmltYWdlKT9nLm1pcG1hcHMubGVuZ3RoOjF9ZnVuY3Rpb24gYih5KXtjb25zdCBnPXkudGFyZ2V0O2cucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsYiksVShnKSxnLmlzVmlkZW9UZXh0dXJlJiZ1LmRlbGV0ZShnKX1mdW5jdGlvbiB3KHkpe2NvbnN0IGc9eS50YXJnZXQ7Zy5yZW1vdmVFdmVudExpc3RlbmVyKCJkaXNwb3NlIix3KSxTKGcpfWZ1bmN0aW9uIFUoeSl7Y29uc3QgZz1uLmdldCh5KTtpZihnLl9fd2ViZ2xJbml0PT09dm9pZCAwKXJldHVybjtjb25zdCBJPXkuc291cmNlLFk9Zi5nZXQoSSk7aWYoWSl7Y29uc3QgWj1ZW2cuX19jYWNoZUtleV07Wi51c2VkVGltZXMtLSxaLnVzZWRUaW1lcz09PTAmJkUoeSksT2JqZWN0LmtleXMoWSkubGVuZ3RoPT09MCYmZi5kZWxldGUoSSl9bi5yZW1vdmUoeSl9ZnVuY3Rpb24gRSh5KXtjb25zdCBnPW4uZ2V0KHkpO2kuZGVsZXRlVGV4dHVyZShnLl9fd2ViZ2xUZXh0dXJlKTtjb25zdCBJPXkuc291cmNlLFk9Zi5nZXQoSSk7ZGVsZXRlIFlbZy5fX2NhY2hlS2V5XSxhLm1lbW9yeS50ZXh0dXJlcy0tfWZ1bmN0aW9uIFMoeSl7Y29uc3QgZz1uLmdldCh5KTtpZih5LmRlcHRoVGV4dHVyZSYmKHkuZGVwdGhUZXh0dXJlLmRpc3Bvc2UoKSxuLnJlbW92ZSh5LmRlcHRoVGV4dHVyZSkpLHkuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQpZm9yKGxldCBZPTA7WTw2O1krKyl7aWYoQXJyYXkuaXNBcnJheShnLl9fd2ViZ2xGcmFtZWJ1ZmZlcltZXSkpZm9yKGxldCBaPTA7WjxnLl9fd2ViZ2xGcmFtZWJ1ZmZlcltZXS5sZW5ndGg7WisrKWkuZGVsZXRlRnJhbWVidWZmZXIoZy5fX3dlYmdsRnJhbWVidWZmZXJbWV1bWl0pO2Vsc2UgaS5kZWxldGVGcmFtZWJ1ZmZlcihnLl9fd2ViZ2xGcmFtZWJ1ZmZlcltZXSk7Zy5fX3dlYmdsRGVwdGhidWZmZXImJmkuZGVsZXRlUmVuZGVyYnVmZmVyKGcuX193ZWJnbERlcHRoYnVmZmVyW1ldKX1lbHNle2lmKEFycmF5LmlzQXJyYXkoZy5fX3dlYmdsRnJhbWVidWZmZXIpKWZvcihsZXQgWT0wO1k8Zy5fX3dlYmdsRnJhbWVidWZmZXIubGVuZ3RoO1krKylpLmRlbGV0ZUZyYW1lYnVmZmVyKGcuX193ZWJnbEZyYW1lYnVmZmVyW1ldKTtlbHNlIGkuZGVsZXRlRnJhbWVidWZmZXIoZy5fX3dlYmdsRnJhbWVidWZmZXIpO2lmKGcuX193ZWJnbERlcHRoYnVmZmVyJiZpLmRlbGV0ZVJlbmRlcmJ1ZmZlcihnLl9fd2ViZ2xEZXB0aGJ1ZmZlciksZy5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXImJmkuZGVsZXRlRnJhbWVidWZmZXIoZy5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpLGcuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyKWZvcihsZXQgWT0wO1k8Zy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXIubGVuZ3RoO1krKylnLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcltZXSYmaS5kZWxldGVSZW5kZXJidWZmZXIoZy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbWV0pO2cuX193ZWJnbERlcHRoUmVuZGVyYnVmZmVyJiZpLmRlbGV0ZVJlbmRlcmJ1ZmZlcihnLl9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlcil9Y29uc3QgST15LnRleHR1cmVzO2ZvcihsZXQgWT0wLFo9SS5sZW5ndGg7WTxaO1krKyl7Y29uc3Qgaz1uLmdldChJW1ldKTtrLl9fd2ViZ2xUZXh0dXJlJiYoaS5kZWxldGVUZXh0dXJlKGsuX193ZWJnbFRleHR1cmUpLGEubWVtb3J5LnRleHR1cmVzLS0pLG4ucmVtb3ZlKElbWV0pfW4ucmVtb3ZlKHkpfWxldCBSPTA7ZnVuY3Rpb24gcSgpe1I9MH1mdW5jdGlvbiB6KCl7Y29uc3QgeT1SO3JldHVybiB5Pj1yLm1heFRleHR1cmVzJiZjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMVGV4dHVyZXM6IFRyeWluZyB0byB1c2UgIit5KyIgdGV4dHVyZSB1bml0cyB3aGlsZSB0aGlzIEdQVSBzdXBwb3J0cyBvbmx5ICIrci5tYXhUZXh0dXJlcyksUis9MSx5fWZ1bmN0aW9uIFcoeSl7Y29uc3QgZz1bXTtyZXR1cm4gZy5wdXNoKHkud3JhcFMpLGcucHVzaCh5LndyYXBUKSxnLnB1c2goeS53cmFwUnx8MCksZy5wdXNoKHkubWFnRmlsdGVyKSxnLnB1c2goeS5taW5GaWx0ZXIpLGcucHVzaCh5LmFuaXNvdHJvcHkpLGcucHVzaCh5LmludGVybmFsRm9ybWF0KSxnLnB1c2goeS5mb3JtYXQpLGcucHVzaCh5LnR5cGUpLGcucHVzaCh5LmdlbmVyYXRlTWlwbWFwcyksZy5wdXNoKHkucHJlbXVsdGlwbHlBbHBoYSksZy5wdXNoKHkuZmxpcFkpLGcucHVzaCh5LnVucGFja0FsaWdubWVudCksZy5wdXNoKHkuY29sb3JTcGFjZSksZy5qb2luKCl9ZnVuY3Rpb24gSyh5LGcpe2NvbnN0IEk9bi5nZXQoeSk7aWYoeS5pc1ZpZGVvVGV4dHVyZSYmU2UoeSkseS5pc1JlbmRlclRhcmdldFRleHR1cmU9PT0hMSYmeS52ZXJzaW9uPjAmJkkuX192ZXJzaW9uIT09eS52ZXJzaW9uKXtjb25zdCBZPXkuaW1hZ2U7aWYoWT09PW51bGwpY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBubyBpbWFnZSBkYXRhIGZvdW5kLiIpO2Vsc2UgaWYoWS5jb21wbGV0ZT09PSExKWNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgaW5jb21wbGV0ZSIpO2Vsc2V7WChJLHksZyk7cmV0dXJufX10LmJpbmRUZXh0dXJlKGkuVEVYVFVSRV8yRCxJLl9fd2ViZ2xUZXh0dXJlLGkuVEVYVFVSRTArZyl9ZnVuY3Rpb24gVih5LGcpe2NvbnN0IEk9bi5nZXQoeSk7aWYoeS52ZXJzaW9uPjAmJkkuX192ZXJzaW9uIT09eS52ZXJzaW9uKXtYKEkseSxnKTtyZXR1cm59dC5iaW5kVGV4dHVyZShpLlRFWFRVUkVfMkRfQVJSQVksSS5fX3dlYmdsVGV4dHVyZSxpLlRFWFRVUkUwK2cpfWZ1bmN0aW9uIFEoeSxnKXtjb25zdCBJPW4uZ2V0KHkpO2lmKHkudmVyc2lvbj4wJiZJLl9fdmVyc2lvbiE9PXkudmVyc2lvbil7WChJLHksZyk7cmV0dXJufXQuYmluZFRleHR1cmUoaS5URVhUVVJFXzNELEkuX193ZWJnbFRleHR1cmUsaS5URVhUVVJFMCtnKX1mdW5jdGlvbiBIKHksZyl7Y29uc3QgST1uLmdldCh5KTtpZih5LnZlcnNpb24+MCYmSS5fX3ZlcnNpb24hPT15LnZlcnNpb24pe2VlKEkseSxnKTtyZXR1cm59dC5iaW5kVGV4dHVyZShpLlRFWFRVUkVfQ1VCRV9NQVAsSS5fX3dlYmdsVGV4dHVyZSxpLlRFWFRVUkUwK2cpfWNvbnN0IGllPXsxZTM6aS5SRVBFQVQsMTAwMTppLkNMQU1QX1RPX0VER0UsMTAwMjppLk1JUlJPUkVEX1JFUEVBVH0sY2U9ezEwMDM6aS5ORUFSRVNULDEwMDQ6aS5ORUFSRVNUX01JUE1BUF9ORUFSRVNULDEwMDU6aS5ORUFSRVNUX01JUE1BUF9MSU5FQVIsMTAwNjppLkxJTkVBUiwxMDA3OmkuTElORUFSX01JUE1BUF9ORUFSRVNULDEwMDg6aS5MSU5FQVJfTUlQTUFQX0xJTkVBUn0seGU9ezUxMjppLk5FVkVSLDUxOTppLkFMV0FZUyw1MTM6aS5MRVNTLDUxNTppLkxFUVVBTCw1MTQ6aS5FUVVBTCw1MTg6aS5HRVFVQUwsNTE2OmkuR1JFQVRFUiw1MTc6aS5OT1RFUVVBTH07ZnVuY3Rpb24gVWUoeSxnKXtpZihnLnR5cGU9PT0xMDE1JiZlLmhhcygiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyIik9PT0hMSYmKGcubWFnRmlsdGVyPT09MTAwNnx8Zy5tYWdGaWx0ZXI9PT0xMDA3fHxnLm1hZ0ZpbHRlcj09PTEwMDV8fGcubWFnRmlsdGVyPT09MTAwOHx8Zy5taW5GaWx0ZXI9PT0xMDA2fHxnLm1pbkZpbHRlcj09PTEwMDd8fGcubWluRmlsdGVyPT09MTAwNXx8Zy5taW5GaWx0ZXI9PT0xMDA4KSYmY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBVbmFibGUgdG8gdXNlIGxpbmVhciBmaWx0ZXJpbmcgd2l0aCBmbG9hdGluZyBwb2ludCB0ZXh0dXJlcy4gT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2UuIiksaS50ZXhQYXJhbWV0ZXJpKHksaS5URVhUVVJFX1dSQVBfUyxpZVtnLndyYXBTXSksaS50ZXhQYXJhbWV0ZXJpKHksaS5URVhUVVJFX1dSQVBfVCxpZVtnLndyYXBUXSksKHk9PT1pLlRFWFRVUkVfM0R8fHk9PT1pLlRFWFRVUkVfMkRfQVJSQVkpJiZpLnRleFBhcmFtZXRlcmkoeSxpLlRFWFRVUkVfV1JBUF9SLGllW2cud3JhcFJdKSxpLnRleFBhcmFtZXRlcmkoeSxpLlRFWFRVUkVfTUFHX0ZJTFRFUixjZVtnLm1hZ0ZpbHRlcl0pLGkudGV4UGFyYW1ldGVyaSh5LGkuVEVYVFVSRV9NSU5fRklMVEVSLGNlW2cubWluRmlsdGVyXSksZy5jb21wYXJlRnVuY3Rpb24mJihpLnRleFBhcmFtZXRlcmkoeSxpLlRFWFRVUkVfQ09NUEFSRV9NT0RFLGkuQ09NUEFSRV9SRUZfVE9fVEVYVFVSRSksaS50ZXhQYXJhbWV0ZXJpKHksaS5URVhUVVJFX0NPTVBBUkVfRlVOQyx4ZVtnLmNvbXBhcmVGdW5jdGlvbl0pKSxlLmhhcygiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljIik9PT0hMCl7aWYoZy5tYWdGaWx0ZXI9PT0xMDAzfHxnLm1pbkZpbHRlciE9PTEwMDUmJmcubWluRmlsdGVyIT09MTAwOHx8Zy50eXBlPT09MTAxNSYmZS5oYXMoIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhciIpPT09ITEpcmV0dXJuO2lmKGcuYW5pc290cm9weT4xfHxuLmdldChnKS5fX2N1cnJlbnRBbmlzb3Ryb3B5KXtjb25zdCBJPWUuZ2V0KCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMiKTtpLnRleFBhcmFtZXRlcmYoeSxJLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULE1hdGgubWluKGcuYW5pc290cm9weSxyLmdldE1heEFuaXNvdHJvcHkoKSkpLG4uZ2V0KGcpLl9fY3VycmVudEFuaXNvdHJvcHk9Zy5hbmlzb3Ryb3B5fX19ZnVuY3Rpb24gWWUoeSxnKXtsZXQgST0hMTt5Ll9fd2ViZ2xJbml0PT09dm9pZCAwJiYoeS5fX3dlYmdsSW5pdD0hMCxnLmFkZEV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLGIpKTtjb25zdCBZPWcuc291cmNlO2xldCBaPWYuZ2V0KFkpO1o9PT12b2lkIDAmJihaPXt9LGYuc2V0KFksWikpO2NvbnN0IGs9VyhnKTtpZihrIT09eS5fX2NhY2hlS2V5KXtaW2tdPT09dm9pZCAwJiYoWltrXT17dGV4dHVyZTppLmNyZWF0ZVRleHR1cmUoKSx1c2VkVGltZXM6MH0sYS5tZW1vcnkudGV4dHVyZXMrKyxJPSEwKSxaW2tdLnVzZWRUaW1lcysrO2NvbnN0IGdlPVpbeS5fX2NhY2hlS2V5XTtnZSE9PXZvaWQgMCYmKFpbeS5fX2NhY2hlS2V5XS51c2VkVGltZXMtLSxnZS51c2VkVGltZXM9PT0wJiZFKGcpKSx5Ll9fY2FjaGVLZXk9ayx5Ll9fd2ViZ2xUZXh0dXJlPVpba10udGV4dHVyZX1yZXR1cm4gSX1mdW5jdGlvbiBYKHksZyxJKXtsZXQgWT1pLlRFWFRVUkVfMkQ7KGcuaXNEYXRhQXJyYXlUZXh0dXJlfHxnLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSkmJihZPWkuVEVYVFVSRV8yRF9BUlJBWSksZy5pc0RhdGEzRFRleHR1cmUmJihZPWkuVEVYVFVSRV8zRCk7Y29uc3QgWj1ZZSh5LGcpLGs9Zy5zb3VyY2U7dC5iaW5kVGV4dHVyZShZLHkuX193ZWJnbFRleHR1cmUsaS5URVhUVVJFMCtJKTtjb25zdCBnZT1uLmdldChrKTtpZihrLnZlcnNpb24hPT1nZS5fX3ZlcnNpb258fFo9PT0hMCl7dC5hY3RpdmVUZXh0dXJlKGkuVEVYVFVSRTArSSk7Y29uc3Qgc2U9QmUuZ2V0UHJpbWFyaWVzKEJlLndvcmtpbmdDb2xvclNwYWNlKSx1ZT1nLmNvbG9yU3BhY2U9PT1qdD9udWxsOkJlLmdldFByaW1hcmllcyhnLmNvbG9yU3BhY2UpLEdlPWcuY29sb3JTcGFjZT09PWp0fHxzZT09PXVlP2kuTk9ORTppLkJST1dTRVJfREVGQVVMVF9XRUJHTDtpLnBpeGVsU3RvcmVpKGkuVU5QQUNLX0ZMSVBfWV9XRUJHTCxnLmZsaXBZKSxpLnBpeGVsU3RvcmVpKGkuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLGcucHJlbXVsdGlwbHlBbHBoYSksaS5waXhlbFN0b3JlaShpLlVOUEFDS19BTElHTk1FTlQsZy51bnBhY2tBbGlnbm1lbnQpLGkucGl4ZWxTdG9yZWkoaS5VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLEdlKTtsZXQgaj14KGcuaW1hZ2UsITEsci5tYXhUZXh0dXJlU2l6ZSk7aj1qZShnLGopO2NvbnN0IGhlPXMuY29udmVydChnLmZvcm1hdCxnLmNvbG9yU3BhY2UpLEVlPXMuY29udmVydChnLnR5cGUpO2xldCBUZT1UKGcuaW50ZXJuYWxGb3JtYXQsaGUsRWUsZy5jb2xvclNwYWNlLGcuaXNWaWRlb1RleHR1cmUpO1VlKFksZyk7bGV0IGRlO2NvbnN0IE9lPWcubWlwbWFwcyxEZT1nLmlzVmlkZW9UZXh0dXJlIT09ITAsWmU9Z2UuX192ZXJzaW9uPT09dm9pZCAwfHxaPT09ITAsQz1rLmRhdGFSZWFkeSxuZT1GKGcsaik7aWYoZy5pc0RlcHRoVGV4dHVyZSlUZT1NKGcuZm9ybWF0PT09MTAyNyxnLnR5cGUpLFplJiYoRGU/dC50ZXhTdG9yYWdlMkQoaS5URVhUVVJFXzJELDEsVGUsai53aWR0aCxqLmhlaWdodCk6dC50ZXhJbWFnZTJEKGkuVEVYVFVSRV8yRCwwLFRlLGoud2lkdGgsai5oZWlnaHQsMCxoZSxFZSxudWxsKSk7ZWxzZSBpZihnLmlzRGF0YVRleHR1cmUpaWYoT2UubGVuZ3RoPjApe0RlJiZaZSYmdC50ZXhTdG9yYWdlMkQoaS5URVhUVVJFXzJELG5lLFRlLE9lWzBdLndpZHRoLE9lWzBdLmhlaWdodCk7Zm9yKGxldCBHPTAsJD1PZS5sZW5ndGg7RzwkO0crKylkZT1PZVtHXSxEZT9DJiZ0LnRleFN1YkltYWdlMkQoaS5URVhUVVJFXzJELEcsMCwwLGRlLndpZHRoLGRlLmhlaWdodCxoZSxFZSxkZS5kYXRhKTp0LnRleEltYWdlMkQoaS5URVhUVVJFXzJELEcsVGUsZGUud2lkdGgsZGUuaGVpZ2h0LDAsaGUsRWUsZGUuZGF0YSk7Zy5nZW5lcmF0ZU1pcG1hcHM9ITF9ZWxzZSBEZT8oWmUmJnQudGV4U3RvcmFnZTJEKGkuVEVYVFVSRV8yRCxuZSxUZSxqLndpZHRoLGouaGVpZ2h0KSxDJiZ0LnRleFN1YkltYWdlMkQoaS5URVhUVVJFXzJELDAsMCwwLGoud2lkdGgsai5oZWlnaHQsaGUsRWUsai5kYXRhKSk6dC50ZXhJbWFnZTJEKGkuVEVYVFVSRV8yRCwwLFRlLGoud2lkdGgsai5oZWlnaHQsMCxoZSxFZSxqLmRhdGEpO2Vsc2UgaWYoZy5pc0NvbXByZXNzZWRUZXh0dXJlKWlmKGcuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlKXtEZSYmWmUmJnQudGV4U3RvcmFnZTNEKGkuVEVYVFVSRV8yRF9BUlJBWSxuZSxUZSxPZVswXS53aWR0aCxPZVswXS5oZWlnaHQsai5kZXB0aCk7Zm9yKGxldCBHPTAsJD1PZS5sZW5ndGg7RzwkO0crKylpZihkZT1PZVtHXSxnLmZvcm1hdCE9PTEwMjMpaWYoaGUhPT1udWxsKWlmKERlKXtpZihDKWlmKGcubGF5ZXJVcGRhdGVzLnNpemU+MCl7Y29uc3QgbGU9Q3MoZGUud2lkdGgsZGUuaGVpZ2h0LGcuZm9ybWF0LGcudHlwZSk7Zm9yKGNvbnN0IGFlIG9mIGcubGF5ZXJVcGRhdGVzKXtjb25zdCBSZT1kZS5kYXRhLnN1YmFycmF5KGFlKmxlL2RlLmRhdGEuQllURVNfUEVSX0VMRU1FTlQsKGFlKzEpKmxlL2RlLmRhdGEuQllURVNfUEVSX0VMRU1FTlQpO3QuY29tcHJlc3NlZFRleFN1YkltYWdlM0QoaS5URVhUVVJFXzJEX0FSUkFZLEcsMCwwLGFlLGRlLndpZHRoLGRlLmhlaWdodCwxLGhlLFJlKX1nLmNsZWFyTGF5ZXJVcGRhdGVzKCl9ZWxzZSB0LmNvbXByZXNzZWRUZXhTdWJJbWFnZTNEKGkuVEVYVFVSRV8yRF9BUlJBWSxHLDAsMCwwLGRlLndpZHRoLGRlLmhlaWdodCxqLmRlcHRoLGhlLGRlLmRhdGEpfWVsc2UgdC5jb21wcmVzc2VkVGV4SW1hZ2UzRChpLlRFWFRVUkVfMkRfQVJSQVksRyxUZSxkZS53aWR0aCxkZS5oZWlnaHQsai5kZXB0aCwwLGRlLmRhdGEsMCwwKTtlbHNlIGNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnVwbG9hZFRleHR1cmUoKSIpO2Vsc2UgRGU/QyYmdC50ZXhTdWJJbWFnZTNEKGkuVEVYVFVSRV8yRF9BUlJBWSxHLDAsMCwwLGRlLndpZHRoLGRlLmhlaWdodCxqLmRlcHRoLGhlLEVlLGRlLmRhdGEpOnQudGV4SW1hZ2UzRChpLlRFWFRVUkVfMkRfQVJSQVksRyxUZSxkZS53aWR0aCxkZS5oZWlnaHQsai5kZXB0aCwwLGhlLEVlLGRlLmRhdGEpfWVsc2V7RGUmJlplJiZ0LnRleFN0b3JhZ2UyRChpLlRFWFRVUkVfMkQsbmUsVGUsT2VbMF0ud2lkdGgsT2VbMF0uaGVpZ2h0KTtmb3IobGV0IEc9MCwkPU9lLmxlbmd0aDtHPCQ7RysrKWRlPU9lW0ddLGcuZm9ybWF0IT09MTAyMz9oZSE9PW51bGw/RGU/QyYmdC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRChpLlRFWFRVUkVfMkQsRywwLDAsZGUud2lkdGgsZGUuaGVpZ2h0LGhlLGRlLmRhdGEpOnQuY29tcHJlc3NlZFRleEltYWdlMkQoaS5URVhUVVJFXzJELEcsVGUsZGUud2lkdGgsZGUuaGVpZ2h0LDAsZGUuZGF0YSk6Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpIik6RGU/QyYmdC50ZXhTdWJJbWFnZTJEKGkuVEVYVFVSRV8yRCxHLDAsMCxkZS53aWR0aCxkZS5oZWlnaHQsaGUsRWUsZGUuZGF0YSk6dC50ZXhJbWFnZTJEKGkuVEVYVFVSRV8yRCxHLFRlLGRlLndpZHRoLGRlLmhlaWdodCwwLGhlLEVlLGRlLmRhdGEpfWVsc2UgaWYoZy5pc0RhdGFBcnJheVRleHR1cmUpaWYoRGUpe2lmKFplJiZ0LnRleFN0b3JhZ2UzRChpLlRFWFRVUkVfMkRfQVJSQVksbmUsVGUsai53aWR0aCxqLmhlaWdodCxqLmRlcHRoKSxDKWlmKGcubGF5ZXJVcGRhdGVzLnNpemU+MCl7Y29uc3QgRz1DcyhqLndpZHRoLGouaGVpZ2h0LGcuZm9ybWF0LGcudHlwZSk7Zm9yKGNvbnN0ICQgb2YgZy5sYXllclVwZGF0ZXMpe2NvbnN0IGxlPWouZGF0YS5zdWJhcnJheSgkKkcvai5kYXRhLkJZVEVTX1BFUl9FTEVNRU5ULCgkKzEpKkcvai5kYXRhLkJZVEVTX1BFUl9FTEVNRU5UKTt0LnRleFN1YkltYWdlM0QoaS5URVhUVVJFXzJEX0FSUkFZLDAsMCwwLCQsai53aWR0aCxqLmhlaWdodCwxLGhlLEVlLGxlKX1nLmNsZWFyTGF5ZXJVcGRhdGVzKCl9ZWxzZSB0LnRleFN1YkltYWdlM0QoaS5URVhUVVJFXzJEX0FSUkFZLDAsMCwwLDAsai53aWR0aCxqLmhlaWdodCxqLmRlcHRoLGhlLEVlLGouZGF0YSl9ZWxzZSB0LnRleEltYWdlM0QoaS5URVhUVVJFXzJEX0FSUkFZLDAsVGUsai53aWR0aCxqLmhlaWdodCxqLmRlcHRoLDAsaGUsRWUsai5kYXRhKTtlbHNlIGlmKGcuaXNEYXRhM0RUZXh0dXJlKURlPyhaZSYmdC50ZXhTdG9yYWdlM0QoaS5URVhUVVJFXzNELG5lLFRlLGoud2lkdGgsai5oZWlnaHQsai5kZXB0aCksQyYmdC50ZXhTdWJJbWFnZTNEKGkuVEVYVFVSRV8zRCwwLDAsMCwwLGoud2lkdGgsai5oZWlnaHQsai5kZXB0aCxoZSxFZSxqLmRhdGEpKTp0LnRleEltYWdlM0QoaS5URVhUVVJFXzNELDAsVGUsai53aWR0aCxqLmhlaWdodCxqLmRlcHRoLDAsaGUsRWUsai5kYXRhKTtlbHNlIGlmKGcuaXNGcmFtZWJ1ZmZlclRleHR1cmUpe2lmKFplKWlmKERlKXQudGV4U3RvcmFnZTJEKGkuVEVYVFVSRV8yRCxuZSxUZSxqLndpZHRoLGouaGVpZ2h0KTtlbHNle2xldCBHPWoud2lkdGgsJD1qLmhlaWdodDtmb3IobGV0IGxlPTA7bGU8bmU7bGUrKyl0LnRleEltYWdlMkQoaS5URVhUVVJFXzJELGxlLFRlLEcsJCwwLGhlLEVlLG51bGwpLEc+Pj0xLCQ+Pj0xfX1lbHNlIGlmKE9lLmxlbmd0aD4wKXtpZihEZSYmWmUpe2NvbnN0IEc9TWUoT2VbMF0pO3QudGV4U3RvcmFnZTJEKGkuVEVYVFVSRV8yRCxuZSxUZSxHLndpZHRoLEcuaGVpZ2h0KX1mb3IobGV0IEc9MCwkPU9lLmxlbmd0aDtHPCQ7RysrKWRlPU9lW0ddLERlP0MmJnQudGV4U3ViSW1hZ2UyRChpLlRFWFRVUkVfMkQsRywwLDAsaGUsRWUsZGUpOnQudGV4SW1hZ2UyRChpLlRFWFRVUkVfMkQsRyxUZSxoZSxFZSxkZSk7Zy5nZW5lcmF0ZU1pcG1hcHM9ITF9ZWxzZSBpZihEZSl7aWYoWmUpe2NvbnN0IEc9TWUoaik7dC50ZXhTdG9yYWdlMkQoaS5URVhUVVJFXzJELG5lLFRlLEcud2lkdGgsRy5oZWlnaHQpfUMmJnQudGV4U3ViSW1hZ2UyRChpLlRFWFRVUkVfMkQsMCwwLDAsaGUsRWUsail9ZWxzZSB0LnRleEltYWdlMkQoaS5URVhUVVJFXzJELDAsVGUsaGUsRWUsaik7bShnKSYmZChZKSxnZS5fX3ZlcnNpb249ay52ZXJzaW9uLGcub25VcGRhdGUmJmcub25VcGRhdGUoZyl9eS5fX3ZlcnNpb249Zy52ZXJzaW9ufWZ1bmN0aW9uIGVlKHksZyxJKXtpZihnLmltYWdlLmxlbmd0aCE9PTYpcmV0dXJuO2NvbnN0IFk9WWUoeSxnKSxaPWcuc291cmNlO3QuYmluZFRleHR1cmUoaS5URVhUVVJFX0NVQkVfTUFQLHkuX193ZWJnbFRleHR1cmUsaS5URVhUVVJFMCtJKTtjb25zdCBrPW4uZ2V0KFopO2lmKFoudmVyc2lvbiE9PWsuX192ZXJzaW9ufHxZPT09ITApe3QuYWN0aXZlVGV4dHVyZShpLlRFWFRVUkUwK0kpO2NvbnN0IGdlPUJlLmdldFByaW1hcmllcyhCZS53b3JraW5nQ29sb3JTcGFjZSksc2U9Zy5jb2xvclNwYWNlPT09anQ/bnVsbDpCZS5nZXRQcmltYXJpZXMoZy5jb2xvclNwYWNlKSx1ZT1nLmNvbG9yU3BhY2U9PT1qdHx8Z2U9PT1zZT9pLk5PTkU6aS5CUk9XU0VSX0RFRkFVTFRfV0VCR0w7aS5waXhlbFN0b3JlaShpLlVOUEFDS19GTElQX1lfV0VCR0wsZy5mbGlwWSksaS5waXhlbFN0b3JlaShpLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCxnLnByZW11bHRpcGx5QWxwaGEpLGkucGl4ZWxTdG9yZWkoaS5VTlBBQ0tfQUxJR05NRU5ULGcudW5wYWNrQWxpZ25tZW50KSxpLnBpeGVsU3RvcmVpKGkuVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCx1ZSk7Y29uc3QgR2U9Zy5pc0NvbXByZXNzZWRUZXh0dXJlfHxnLmltYWdlWzBdLmlzQ29tcHJlc3NlZFRleHR1cmUsaj1nLmltYWdlWzBdJiZnLmltYWdlWzBdLmlzRGF0YVRleHR1cmUsaGU9W107Zm9yKGxldCAkPTA7JDw2OyQrKykhR2UmJiFqP2hlWyRdPXgoZy5pbWFnZVskXSwhMCxyLm1heEN1YmVtYXBTaXplKTpoZVskXT1qP2cuaW1hZ2VbJF0uaW1hZ2U6Zy5pbWFnZVskXSxoZVskXT1qZShnLGhlWyRdKTtjb25zdCBFZT1oZVswXSxUZT1zLmNvbnZlcnQoZy5mb3JtYXQsZy5jb2xvclNwYWNlKSxkZT1zLmNvbnZlcnQoZy50eXBlKSxPZT1UKGcuaW50ZXJuYWxGb3JtYXQsVGUsZGUsZy5jb2xvclNwYWNlKSxEZT1nLmlzVmlkZW9UZXh0dXJlIT09ITAsWmU9ay5fX3ZlcnNpb249PT12b2lkIDB8fFk9PT0hMCxDPVouZGF0YVJlYWR5O2xldCBuZT1GKGcsRWUpO1VlKGkuVEVYVFVSRV9DVUJFX01BUCxnKTtsZXQgRztpZihHZSl7RGUmJlplJiZ0LnRleFN0b3JhZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVAsbmUsT2UsRWUud2lkdGgsRWUuaGVpZ2h0KTtmb3IobGV0ICQ9MDskPDY7JCsrKXtHPWhlWyRdLm1pcG1hcHM7Zm9yKGxldCBsZT0wO2xlPEcubGVuZ3RoO2xlKyspe2NvbnN0IGFlPUdbbGVdO2cuZm9ybWF0IT09MTAyMz9UZSE9PW51bGw/RGU/QyYmdC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCskLGxlLDAsMCxhZS53aWR0aCxhZS5oZWlnaHQsVGUsYWUuZGF0YSk6dC5jb21wcmVzc2VkVGV4SW1hZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCskLGxlLE9lLGFlLndpZHRoLGFlLmhlaWdodCwwLGFlLmRhdGEpOmNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnNldFRleHR1cmVDdWJlKCkiKTpEZT9DJiZ0LnRleFN1YkltYWdlMkQoaS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grJCxsZSwwLDAsYWUud2lkdGgsYWUuaGVpZ2h0LFRlLGRlLGFlLmRhdGEpOnQudGV4SW1hZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCskLGxlLE9lLGFlLndpZHRoLGFlLmhlaWdodCwwLFRlLGRlLGFlLmRhdGEpfX19ZWxzZXtpZihHPWcubWlwbWFwcyxEZSYmWmUpe0cubGVuZ3RoPjAmJm5lKys7Y29uc3QgJD1NZShoZVswXSk7dC50ZXhTdG9yYWdlMkQoaS5URVhUVVJFX0NVQkVfTUFQLG5lLE9lLCQud2lkdGgsJC5oZWlnaHQpfWZvcihsZXQgJD0wOyQ8NjskKyspaWYoail7RGU/QyYmdC50ZXhTdWJJbWFnZTJEKGkuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YKyQsMCwwLDAsaGVbJF0ud2lkdGgsaGVbJF0uaGVpZ2h0LFRlLGRlLGhlWyRdLmRhdGEpOnQudGV4SW1hZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCskLDAsT2UsaGVbJF0ud2lkdGgsaGVbJF0uaGVpZ2h0LDAsVGUsZGUsaGVbJF0uZGF0YSk7Zm9yKGxldCBsZT0wO2xlPEcubGVuZ3RoO2xlKyspe2NvbnN0IFJlPUdbbGVdLmltYWdlWyRdLmltYWdlO0RlP0MmJnQudGV4U3ViSW1hZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCskLGxlKzEsMCwwLFJlLndpZHRoLFJlLmhlaWdodCxUZSxkZSxSZS5kYXRhKTp0LnRleEltYWdlMkQoaS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grJCxsZSsxLE9lLFJlLndpZHRoLFJlLmhlaWdodCwwLFRlLGRlLFJlLmRhdGEpfX1lbHNle0RlP0MmJnQudGV4U3ViSW1hZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCskLDAsMCwwLFRlLGRlLGhlWyRdKTp0LnRleEltYWdlMkQoaS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grJCwwLE9lLFRlLGRlLGhlWyRdKTtmb3IobGV0IGxlPTA7bGU8Ry5sZW5ndGg7bGUrKyl7Y29uc3QgYWU9R1tsZV07RGU/QyYmdC50ZXhTdWJJbWFnZTJEKGkuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YKyQsbGUrMSwwLDAsVGUsZGUsYWUuaW1hZ2VbJF0pOnQudGV4SW1hZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCskLGxlKzEsT2UsVGUsZGUsYWUuaW1hZ2VbJF0pfX19bShnKSYmZChpLlRFWFRVUkVfQ1VCRV9NQVApLGsuX192ZXJzaW9uPVoudmVyc2lvbixnLm9uVXBkYXRlJiZnLm9uVXBkYXRlKGcpfXkuX192ZXJzaW9uPWcudmVyc2lvbn1mdW5jdGlvbiBfZSh5LGcsSSxZLFosayl7Y29uc3QgZ2U9cy5jb252ZXJ0KEkuZm9ybWF0LEkuY29sb3JTcGFjZSksc2U9cy5jb252ZXJ0KEkudHlwZSksdWU9VChJLmludGVybmFsRm9ybWF0LGdlLHNlLEkuY29sb3JTcGFjZSksR2U9bi5nZXQoZyksaj1uLmdldChJKTtpZihqLl9fcmVuZGVyVGFyZ2V0PWcsIUdlLl9faGFzRXh0ZXJuYWxUZXh0dXJlcyl7Y29uc3QgaGU9TWF0aC5tYXgoMSxnLndpZHRoPj5rKSxFZT1NYXRoLm1heCgxLGcuaGVpZ2h0Pj5rKTtaPT09aS5URVhUVVJFXzNEfHxaPT09aS5URVhUVVJFXzJEX0FSUkFZP3QudGV4SW1hZ2UzRChaLGssdWUsaGUsRWUsZy5kZXB0aCwwLGdlLHNlLG51bGwpOnQudGV4SW1hZ2UyRChaLGssdWUsaGUsRWUsMCxnZSxzZSxudWxsKX10LmJpbmRGcmFtZWJ1ZmZlcihpLkZSQU1FQlVGRkVSLHkpLE5lKGcpP28uZnJhbWVidWZmZXJUZXh0dXJlMkRNdWx0aXNhbXBsZUVYVChpLkZSQU1FQlVGRkVSLFksWixqLl9fd2ViZ2xUZXh0dXJlLDAsSWUoZykpOihaPT09aS5URVhUVVJFXzJEfHxaPj1pLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCYmWjw9aS5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1opJiZpLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGkuRlJBTUVCVUZGRVIsWSxaLGouX193ZWJnbFRleHR1cmUsayksdC5iaW5kRnJhbWVidWZmZXIoaS5GUkFNRUJVRkZFUixudWxsKX1mdW5jdGlvbiByZSh5LGcsSSl7aWYoaS5iaW5kUmVuZGVyYnVmZmVyKGkuUkVOREVSQlVGRkVSLHkpLGcuZGVwdGhCdWZmZXIpe2NvbnN0IFk9Zy5kZXB0aFRleHR1cmUsWj1ZJiZZLmlzRGVwdGhUZXh0dXJlP1kudHlwZTpudWxsLGs9TShnLnN0ZW5jaWxCdWZmZXIsWiksZ2U9Zy5zdGVuY2lsQnVmZmVyP2kuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UOmkuREVQVEhfQVRUQUNITUVOVCxzZT1JZShnKTtOZShnKT9vLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZUVYVChpLlJFTkRFUkJVRkZFUixzZSxrLGcud2lkdGgsZy5oZWlnaHQpOkk/aS5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoaS5SRU5ERVJCVUZGRVIsc2UsayxnLndpZHRoLGcuaGVpZ2h0KTppLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoaS5SRU5ERVJCVUZGRVIsayxnLndpZHRoLGcuaGVpZ2h0KSxpLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGkuRlJBTUVCVUZGRVIsZ2UsaS5SRU5ERVJCVUZGRVIseSl9ZWxzZXtjb25zdCBZPWcudGV4dHVyZXM7Zm9yKGxldCBaPTA7WjxZLmxlbmd0aDtaKyspe2NvbnN0IGs9WVtaXSxnZT1zLmNvbnZlcnQoay5mb3JtYXQsay5jb2xvclNwYWNlKSxzZT1zLmNvbnZlcnQoay50eXBlKSx1ZT1UKGsuaW50ZXJuYWxGb3JtYXQsZ2Usc2Usay5jb2xvclNwYWNlKSxHZT1JZShnKTtJJiZOZShnKT09PSExP2kucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKGkuUkVOREVSQlVGRkVSLEdlLHVlLGcud2lkdGgsZy5oZWlnaHQpOk5lKGcpP28ucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlRVhUKGkuUkVOREVSQlVGRkVSLEdlLHVlLGcud2lkdGgsZy5oZWlnaHQpOmkucmVuZGVyYnVmZmVyU3RvcmFnZShpLlJFTkRFUkJVRkZFUix1ZSxnLndpZHRoLGcuaGVpZ2h0KX19aS5iaW5kUmVuZGVyYnVmZmVyKGkuUkVOREVSQlVGRkVSLG51bGwpfWZ1bmN0aW9uIHllKHksZyl7aWYoZyYmZy5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCl0aHJvdyBuZXcgRXJyb3IoIkRlcHRoIFRleHR1cmUgd2l0aCBjdWJlIHJlbmRlciB0YXJnZXRzIGlzIG5vdCBzdXBwb3J0ZWQiKTtpZih0LmJpbmRGcmFtZWJ1ZmZlcihpLkZSQU1FQlVGRkVSLHkpLCEoZy5kZXB0aFRleHR1cmUmJmcuZGVwdGhUZXh0dXJlLmlzRGVwdGhUZXh0dXJlKSl0aHJvdyBuZXcgRXJyb3IoInJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBUSFJFRS5EZXB0aFRleHR1cmUiKTtjb25zdCBZPW4uZ2V0KGcuZGVwdGhUZXh0dXJlKTtZLl9fcmVuZGVyVGFyZ2V0PWcsKCFZLl9fd2ViZ2xUZXh0dXJlfHxnLmRlcHRoVGV4dHVyZS5pbWFnZS53aWR0aCE9PWcud2lkdGh8fGcuZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodCE9PWcuaGVpZ2h0KSYmKGcuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoPWcud2lkdGgsZy5kZXB0aFRleHR1cmUuaW1hZ2UuaGVpZ2h0PWcuaGVpZ2h0LGcuZGVwdGhUZXh0dXJlLm5lZWRzVXBkYXRlPSEwKSxLKGcuZGVwdGhUZXh0dXJlLDApO2NvbnN0IFo9WS5fX3dlYmdsVGV4dHVyZSxrPUllKGcpO2lmKGcuZGVwdGhUZXh0dXJlLmZvcm1hdD09PTEwMjYpTmUoZyk/by5mcmFtZWJ1ZmZlclRleHR1cmUyRE11bHRpc2FtcGxlRVhUKGkuRlJBTUVCVUZGRVIsaS5ERVBUSF9BVFRBQ0hNRU5ULGkuVEVYVFVSRV8yRCxaLDAsayk6aS5mcmFtZWJ1ZmZlclRleHR1cmUyRChpLkZSQU1FQlVGRkVSLGkuREVQVEhfQVRUQUNITUVOVCxpLlRFWFRVUkVfMkQsWiwwKTtlbHNlIGlmKGcuZGVwdGhUZXh0dXJlLmZvcm1hdD09PTEwMjcpTmUoZyk/by5mcmFtZWJ1ZmZlclRleHR1cmUyRE11bHRpc2FtcGxlRVhUKGkuRlJBTUVCVUZGRVIsaS5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsaS5URVhUVVJFXzJELFosMCxrKTppLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGkuRlJBTUVCVUZGRVIsaS5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsaS5URVhUVVJFXzJELFosMCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIlVua25vd24gZGVwdGhUZXh0dXJlIGZvcm1hdCIpfWZ1bmN0aW9uIGJlKHkpe2NvbnN0IGc9bi5nZXQoeSksST15LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0PT09ITA7aWYoZy5fX2JvdW5kRGVwdGhUZXh0dXJlIT09eS5kZXB0aFRleHR1cmUpe2NvbnN0IFk9eS5kZXB0aFRleHR1cmU7aWYoZy5fX2RlcHRoRGlzcG9zZUNhbGxiYWNrJiZnLl9fZGVwdGhEaXNwb3NlQ2FsbGJhY2soKSxZKXtjb25zdCBaPSgpPT57ZGVsZXRlIGcuX19ib3VuZERlcHRoVGV4dHVyZSxkZWxldGUgZy5fX2RlcHRoRGlzcG9zZUNhbGxiYWNrLFkucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsWil9O1kuYWRkRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsWiksZy5fX2RlcHRoRGlzcG9zZUNhbGxiYWNrPVp9Zy5fX2JvdW5kRGVwdGhUZXh0dXJlPVl9aWYoeS5kZXB0aFRleHR1cmUmJiFnLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXIpe2lmKEkpdGhyb3cgbmV3IEVycm9yKCJ0YXJnZXQuZGVwdGhUZXh0dXJlIG5vdCBzdXBwb3J0ZWQgaW4gQ3ViZSByZW5kZXIgdGFyZ2V0cyIpO3llKGcuX193ZWJnbEZyYW1lYnVmZmVyLHkpfWVsc2UgaWYoSSl7Zy5fX3dlYmdsRGVwdGhidWZmZXI9W107Zm9yKGxldCBZPTA7WTw2O1krKylpZih0LmJpbmRGcmFtZWJ1ZmZlcihpLkZSQU1FQlVGRkVSLGcuX193ZWJnbEZyYW1lYnVmZmVyW1ldKSxnLl9fd2ViZ2xEZXB0aGJ1ZmZlcltZXT09PXZvaWQgMClnLl9fd2ViZ2xEZXB0aGJ1ZmZlcltZXT1pLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLHJlKGcuX193ZWJnbERlcHRoYnVmZmVyW1ldLHksITEpO2Vsc2V7Y29uc3QgWj15LnN0ZW5jaWxCdWZmZXI/aS5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQ6aS5ERVBUSF9BVFRBQ0hNRU5ULGs9Zy5fX3dlYmdsRGVwdGhidWZmZXJbWV07aS5iaW5kUmVuZGVyYnVmZmVyKGkuUkVOREVSQlVGRkVSLGspLGkuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoaS5GUkFNRUJVRkZFUixaLGkuUkVOREVSQlVGRkVSLGspfX1lbHNlIGlmKHQuYmluZEZyYW1lYnVmZmVyKGkuRlJBTUVCVUZGRVIsZy5fX3dlYmdsRnJhbWVidWZmZXIpLGcuX193ZWJnbERlcHRoYnVmZmVyPT09dm9pZCAwKWcuX193ZWJnbERlcHRoYnVmZmVyPWkuY3JlYXRlUmVuZGVyYnVmZmVyKCkscmUoZy5fX3dlYmdsRGVwdGhidWZmZXIseSwhMSk7ZWxzZXtjb25zdCBZPXkuc3RlbmNpbEJ1ZmZlcj9pLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVDppLkRFUFRIX0FUVEFDSE1FTlQsWj1nLl9fd2ViZ2xEZXB0aGJ1ZmZlcjtpLmJpbmRSZW5kZXJidWZmZXIoaS5SRU5ERVJCVUZGRVIsWiksaS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihpLkZSQU1FQlVGRkVSLFksaS5SRU5ERVJCVUZGRVIsWil9dC5iaW5kRnJhbWVidWZmZXIoaS5GUkFNRUJVRkZFUixudWxsKX1mdW5jdGlvbiBGZSh5LGcsSSl7Y29uc3QgWT1uLmdldCh5KTtnIT09dm9pZCAwJiZfZShZLl9fd2ViZ2xGcmFtZWJ1ZmZlcix5LHkudGV4dHVyZSxpLkNPTE9SX0FUVEFDSE1FTlQwLGkuVEVYVFVSRV8yRCwwKSxJIT09dm9pZCAwJiZiZSh5KX1mdW5jdGlvbiBldCh5KXtjb25zdCBnPXkudGV4dHVyZSxJPW4uZ2V0KHkpLFk9bi5nZXQoZyk7eS5hZGRFdmVudExpc3RlbmVyKCJkaXNwb3NlIix3KTtjb25zdCBaPXkudGV4dHVyZXMsaz15LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0PT09ITAsZ2U9Wi5sZW5ndGg+MTtpZihnZXx8KFkuX193ZWJnbFRleHR1cmU9PT12b2lkIDAmJihZLl9fd2ViZ2xUZXh0dXJlPWkuY3JlYXRlVGV4dHVyZSgpKSxZLl9fdmVyc2lvbj1nLnZlcnNpb24sYS5tZW1vcnkudGV4dHVyZXMrKyksayl7SS5fX3dlYmdsRnJhbWVidWZmZXI9W107Zm9yKGxldCBzZT0wO3NlPDY7c2UrKylpZihnLm1pcG1hcHMmJmcubWlwbWFwcy5sZW5ndGg+MCl7SS5fX3dlYmdsRnJhbWVidWZmZXJbc2VdPVtdO2ZvcihsZXQgdWU9MDt1ZTxnLm1pcG1hcHMubGVuZ3RoO3VlKyspSS5fX3dlYmdsRnJhbWVidWZmZXJbc2VdW3VlXT1pLmNyZWF0ZUZyYW1lYnVmZmVyKCl9ZWxzZSBJLl9fd2ViZ2xGcmFtZWJ1ZmZlcltzZV09aS5jcmVhdGVGcmFtZWJ1ZmZlcigpfWVsc2V7aWYoZy5taXBtYXBzJiZnLm1pcG1hcHMubGVuZ3RoPjApe0kuX193ZWJnbEZyYW1lYnVmZmVyPVtdO2ZvcihsZXQgc2U9MDtzZTxnLm1pcG1hcHMubGVuZ3RoO3NlKyspSS5fX3dlYmdsRnJhbWVidWZmZXJbc2VdPWkuY3JlYXRlRnJhbWVidWZmZXIoKX1lbHNlIEkuX193ZWJnbEZyYW1lYnVmZmVyPWkuY3JlYXRlRnJhbWVidWZmZXIoKTtpZihnZSlmb3IobGV0IHNlPTAsdWU9Wi5sZW5ndGg7c2U8dWU7c2UrKyl7Y29uc3QgR2U9bi5nZXQoWltzZV0pO0dlLl9fd2ViZ2xUZXh0dXJlPT09dm9pZCAwJiYoR2UuX193ZWJnbFRleHR1cmU9aS5jcmVhdGVUZXh0dXJlKCksYS5tZW1vcnkudGV4dHVyZXMrKyl9aWYoeS5zYW1wbGVzPjAmJk5lKHkpPT09ITEpe0kuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyPWkuY3JlYXRlRnJhbWVidWZmZXIoKSxJLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcj1bXSx0LmJpbmRGcmFtZWJ1ZmZlcihpLkZSQU1FQlVGRkVSLEkuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKTtmb3IobGV0IHNlPTA7c2U8Wi5sZW5ndGg7c2UrKyl7Y29uc3QgdWU9WltzZV07SS5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbc2VdPWkuY3JlYXRlUmVuZGVyYnVmZmVyKCksaS5iaW5kUmVuZGVyYnVmZmVyKGkuUkVOREVSQlVGRkVSLEkuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyW3NlXSk7Y29uc3QgR2U9cy5jb252ZXJ0KHVlLmZvcm1hdCx1ZS5jb2xvclNwYWNlKSxqPXMuY29udmVydCh1ZS50eXBlKSxoZT1UKHVlLmludGVybmFsRm9ybWF0LEdlLGosdWUuY29sb3JTcGFjZSx5LmlzWFJSZW5kZXJUYXJnZXQ9PT0hMCksRWU9SWUoeSk7aS5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoaS5SRU5ERVJCVUZGRVIsRWUsaGUseS53aWR0aCx5LmhlaWdodCksaS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihpLkZSQU1FQlVGRkVSLGkuQ09MT1JfQVRUQUNITUVOVDArc2UsaS5SRU5ERVJCVUZGRVIsSS5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbc2VdKX1pLmJpbmRSZW5kZXJidWZmZXIoaS5SRU5ERVJCVUZGRVIsbnVsbCkseS5kZXB0aEJ1ZmZlciYmKEkuX193ZWJnbERlcHRoUmVuZGVyYnVmZmVyPWkuY3JlYXRlUmVuZGVyYnVmZmVyKCkscmUoSS5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIseSwhMCkpLHQuYmluZEZyYW1lYnVmZmVyKGkuRlJBTUVCVUZGRVIsbnVsbCl9fWlmKGspe3QuYmluZFRleHR1cmUoaS5URVhUVVJFX0NVQkVfTUFQLFkuX193ZWJnbFRleHR1cmUpLFVlKGkuVEVYVFVSRV9DVUJFX01BUCxnKTtmb3IobGV0IHNlPTA7c2U8NjtzZSsrKWlmKGcubWlwbWFwcyYmZy5taXBtYXBzLmxlbmd0aD4wKWZvcihsZXQgdWU9MDt1ZTxnLm1pcG1hcHMubGVuZ3RoO3VlKyspX2UoSS5fX3dlYmdsRnJhbWVidWZmZXJbc2VdW3VlXSx5LGcsaS5DT0xPUl9BVFRBQ0hNRU5UMCxpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtzZSx1ZSk7ZWxzZSBfZShJLl9fd2ViZ2xGcmFtZWJ1ZmZlcltzZV0seSxnLGkuQ09MT1JfQVRUQUNITUVOVDAsaS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grc2UsMCk7bShnKSYmZChpLlRFWFRVUkVfQ1VCRV9NQVApLHQudW5iaW5kVGV4dHVyZSgpfWVsc2UgaWYoZ2Upe2ZvcihsZXQgc2U9MCx1ZT1aLmxlbmd0aDtzZTx1ZTtzZSsrKXtjb25zdCBHZT1aW3NlXSxqPW4uZ2V0KEdlKTt0LmJpbmRUZXh0dXJlKGkuVEVYVFVSRV8yRCxqLl9fd2ViZ2xUZXh0dXJlKSxVZShpLlRFWFRVUkVfMkQsR2UpLF9lKEkuX193ZWJnbEZyYW1lYnVmZmVyLHksR2UsaS5DT0xPUl9BVFRBQ0hNRU5UMCtzZSxpLlRFWFRVUkVfMkQsMCksbShHZSkmJmQoaS5URVhUVVJFXzJEKX10LnVuYmluZFRleHR1cmUoKX1lbHNle2xldCBzZT1pLlRFWFRVUkVfMkQ7aWYoKHkuaXNXZWJHTDNEUmVuZGVyVGFyZ2V0fHx5LmlzV2ViR0xBcnJheVJlbmRlclRhcmdldCkmJihzZT15LmlzV2ViR0wzRFJlbmRlclRhcmdldD9pLlRFWFRVUkVfM0Q6aS5URVhUVVJFXzJEX0FSUkFZKSx0LmJpbmRUZXh0dXJlKHNlLFkuX193ZWJnbFRleHR1cmUpLFVlKHNlLGcpLGcubWlwbWFwcyYmZy5taXBtYXBzLmxlbmd0aD4wKWZvcihsZXQgdWU9MDt1ZTxnLm1pcG1hcHMubGVuZ3RoO3VlKyspX2UoSS5fX3dlYmdsRnJhbWVidWZmZXJbdWVdLHksZyxpLkNPTE9SX0FUVEFDSE1FTlQwLHNlLHVlKTtlbHNlIF9lKEkuX193ZWJnbEZyYW1lYnVmZmVyLHksZyxpLkNPTE9SX0FUVEFDSE1FTlQwLHNlLDApO20oZykmJmQoc2UpLHQudW5iaW5kVGV4dHVyZSgpfXkuZGVwdGhCdWZmZXImJmJlKHkpfWZ1bmN0aW9uIHplKHkpe2NvbnN0IGc9eS50ZXh0dXJlcztmb3IobGV0IEk9MCxZPWcubGVuZ3RoO0k8WTtJKyspe2NvbnN0IFo9Z1tJXTtpZihtKFopKXtjb25zdCBrPUEoeSksZ2U9bi5nZXQoWikuX193ZWJnbFRleHR1cmU7dC5iaW5kVGV4dHVyZShrLGdlKSxkKGspLHQudW5iaW5kVGV4dHVyZSgpfX19Y29uc3QgYXQ9W10sTD1bXTtmdW5jdGlvbiBQdCh5KXtpZih5LnNhbXBsZXM+MCl7aWYoTmUoeSk9PT0hMSl7Y29uc3QgZz15LnRleHR1cmVzLEk9eS53aWR0aCxZPXkuaGVpZ2h0O2xldCBaPWkuQ09MT1JfQlVGRkVSX0JJVDtjb25zdCBrPXkuc3RlbmNpbEJ1ZmZlcj9pLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVDppLkRFUFRIX0FUVEFDSE1FTlQsZ2U9bi5nZXQoeSksc2U9Zy5sZW5ndGg+MTtpZihzZSlmb3IobGV0IHVlPTA7dWU8Zy5sZW5ndGg7dWUrKyl0LmJpbmRGcmFtZWJ1ZmZlcihpLkZSQU1FQlVGRkVSLGdlLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciksaS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihpLkZSQU1FQlVGRkVSLGkuQ09MT1JfQVRUQUNITUVOVDArdWUsaS5SRU5ERVJCVUZGRVIsbnVsbCksdC5iaW5kRnJhbWVidWZmZXIoaS5GUkFNRUJVRkZFUixnZS5fX3dlYmdsRnJhbWVidWZmZXIpLGkuZnJhbWVidWZmZXJUZXh0dXJlMkQoaS5EUkFXX0ZSQU1FQlVGRkVSLGkuQ09MT1JfQVRUQUNITUVOVDArdWUsaS5URVhUVVJFXzJELG51bGwsMCk7dC5iaW5kRnJhbWVidWZmZXIoaS5SRUFEX0ZSQU1FQlVGRkVSLGdlLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciksdC5iaW5kRnJhbWVidWZmZXIoaS5EUkFXX0ZSQU1FQlVGRkVSLGdlLl9fd2ViZ2xGcmFtZWJ1ZmZlcik7Zm9yKGxldCB1ZT0wO3VlPGcubGVuZ3RoO3VlKyspe2lmKHkucmVzb2x2ZURlcHRoQnVmZmVyJiYoeS5kZXB0aEJ1ZmZlciYmKFp8PWkuREVQVEhfQlVGRkVSX0JJVCkseS5zdGVuY2lsQnVmZmVyJiZ5LnJlc29sdmVTdGVuY2lsQnVmZmVyJiYoWnw9aS5TVEVOQ0lMX0JVRkZFUl9CSVQpKSxzZSl7aS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihpLlJFQURfRlJBTUVCVUZGRVIsaS5DT0xPUl9BVFRBQ0hNRU5UMCxpLlJFTkRFUkJVRkZFUixnZS5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbdWVdKTtjb25zdCBHZT1uLmdldChnW3VlXSkuX193ZWJnbFRleHR1cmU7aS5mcmFtZWJ1ZmZlclRleHR1cmUyRChpLkRSQVdfRlJBTUVCVUZGRVIsaS5DT0xPUl9BVFRBQ0hNRU5UMCxpLlRFWFRVUkVfMkQsR2UsMCl9aS5ibGl0RnJhbWVidWZmZXIoMCwwLEksWSwwLDAsSSxZLFosaS5ORUFSRVNUKSxsPT09ITAmJihhdC5sZW5ndGg9MCxMLmxlbmd0aD0wLGF0LnB1c2goaS5DT0xPUl9BVFRBQ0hNRU5UMCt1ZSkseS5kZXB0aEJ1ZmZlciYmeS5yZXNvbHZlRGVwdGhCdWZmZXI9PT0hMSYmKGF0LnB1c2goayksTC5wdXNoKGspLGkuaW52YWxpZGF0ZUZyYW1lYnVmZmVyKGkuRFJBV19GUkFNRUJVRkZFUixMKSksaS5pbnZhbGlkYXRlRnJhbWVidWZmZXIoaS5SRUFEX0ZSQU1FQlVGRkVSLGF0KSl9aWYodC5iaW5kRnJhbWVidWZmZXIoaS5SRUFEX0ZSQU1FQlVGRkVSLG51bGwpLHQuYmluZEZyYW1lYnVmZmVyKGkuRFJBV19GUkFNRUJVRkZFUixudWxsKSxzZSlmb3IobGV0IHVlPTA7dWU8Zy5sZW5ndGg7dWUrKyl7dC5iaW5kRnJhbWVidWZmZXIoaS5GUkFNRUJVRkZFUixnZS5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpLGkuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoaS5GUkFNRUJVRkZFUixpLkNPTE9SX0FUVEFDSE1FTlQwK3VlLGkuUkVOREVSQlVGRkVSLGdlLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlclt1ZV0pO2NvbnN0IEdlPW4uZ2V0KGdbdWVdKS5fX3dlYmdsVGV4dHVyZTt0LmJpbmRGcmFtZWJ1ZmZlcihpLkZSQU1FQlVGRkVSLGdlLl9fd2ViZ2xGcmFtZWJ1ZmZlciksaS5mcmFtZWJ1ZmZlclRleHR1cmUyRChpLkRSQVdfRlJBTUVCVUZGRVIsaS5DT0xPUl9BVFRBQ0hNRU5UMCt1ZSxpLlRFWFRVUkVfMkQsR2UsMCl9dC5iaW5kRnJhbWVidWZmZXIoaS5EUkFXX0ZSQU1FQlVGRkVSLGdlLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcil9ZWxzZSBpZih5LmRlcHRoQnVmZmVyJiZ5LnJlc29sdmVEZXB0aEJ1ZmZlcj09PSExJiZsKXtjb25zdCBnPXkuc3RlbmNpbEJ1ZmZlcj9pLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVDppLkRFUFRIX0FUVEFDSE1FTlQ7aS5pbnZhbGlkYXRlRnJhbWVidWZmZXIoaS5EUkFXX0ZSQU1FQlVGRkVSLFtnXSl9fX1mdW5jdGlvbiBJZSh5KXtyZXR1cm4gTWF0aC5taW4oci5tYXhTYW1wbGVzLHkuc2FtcGxlcyl9ZnVuY3Rpb24gTmUoeSl7Y29uc3QgZz1uLmdldCh5KTtyZXR1cm4geS5zYW1wbGVzPjAmJmUuaGFzKCJXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUiKT09PSEwJiZnLl9fdXNlUmVuZGVyVG9UZXh0dXJlIT09ITF9ZnVuY3Rpb24gU2UoeSl7Y29uc3QgZz1hLnJlbmRlci5mcmFtZTt1LmdldCh5KSE9PWcmJih1LnNldCh5LGcpLHkudXBkYXRlKCkpfWZ1bmN0aW9uIGplKHksZyl7Y29uc3QgST15LmNvbG9yU3BhY2UsWT15LmZvcm1hdCxaPXkudHlwZTtyZXR1cm4geS5pc0NvbXByZXNzZWRUZXh0dXJlPT09ITB8fHkuaXNWaWRlb1RleHR1cmU9PT0hMHx8SSE9PXhuJiZJIT09anQmJihCZS5nZXRUcmFuc2ZlcihJKT09PXFlPyhZIT09MTAyM3x8WiE9PTEwMDkpJiZjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMVGV4dHVyZXM6IHNSR0IgZW5jb2RlZCB0ZXh0dXJlcyBoYXZlIHRvIHVzZSBSR0JBRm9ybWF0IGFuZCBVbnNpZ25lZEJ5dGVUeXBlLiIpOmNvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMVGV4dHVyZXM6IFVuc3VwcG9ydGVkIHRleHR1cmUgY29sb3Igc3BhY2U6IixJKSksZ31mdW5jdGlvbiBNZSh5KXtyZXR1cm4gdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQ8InUiJiZ5IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudD8oYy53aWR0aD15Lm5hdHVyYWxXaWR0aHx8eS53aWR0aCxjLmhlaWdodD15Lm5hdHVyYWxIZWlnaHR8fHkuaGVpZ2h0KTp0eXBlb2YgVmlkZW9GcmFtZTwidSImJnkgaW5zdGFuY2VvZiBWaWRlb0ZyYW1lPyhjLndpZHRoPXkuZGlzcGxheVdpZHRoLGMuaGVpZ2h0PXkuZGlzcGxheUhlaWdodCk6KGMud2lkdGg9eS53aWR0aCxjLmhlaWdodD15LmhlaWdodCksY310aGlzLmFsbG9jYXRlVGV4dHVyZVVuaXQ9eix0aGlzLnJlc2V0VGV4dHVyZVVuaXRzPXEsdGhpcy5zZXRUZXh0dXJlMkQ9Syx0aGlzLnNldFRleHR1cmUyREFycmF5PVYsdGhpcy5zZXRUZXh0dXJlM0Q9USx0aGlzLnNldFRleHR1cmVDdWJlPUgsdGhpcy5yZWJpbmRUZXh0dXJlcz1GZSx0aGlzLnNldHVwUmVuZGVyVGFyZ2V0PWV0LHRoaXMudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwPXplLHRoaXMudXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQ9UHQsdGhpcy5zZXR1cERlcHRoUmVuZGVyYnVmZmVyPWJlLHRoaXMuc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmU9X2UsdGhpcy51c2VNdWx0aXNhbXBsZWRSVFQ9TmV9ZnVuY3Rpb24gRHUoaSxlKXtmdW5jdGlvbiB0KG4scj1qdCl7bGV0IHM7Y29uc3QgYT1CZS5nZXRUcmFuc2ZlcihyKTtpZihuPT09MTAwOSlyZXR1cm4gaS5VTlNJR05FRF9CWVRFO2lmKG49PT0xMDE3KXJldHVybiBpLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7aWYobj09PTEwMTgpcmV0dXJuIGkuVU5TSUdORURfU0hPUlRfNV81XzVfMTtpZihuPT09MzU5MDIpcmV0dXJuIGkuVU5TSUdORURfSU5UXzVfOV85XzlfUkVWO2lmKG49PT0xMDEwKXJldHVybiBpLkJZVEU7aWYobj09PTEwMTEpcmV0dXJuIGkuU0hPUlQ7aWYobj09PTEwMTIpcmV0dXJuIGkuVU5TSUdORURfU0hPUlQ7aWYobj09PTEwMTMpcmV0dXJuIGkuSU5UO2lmKG49PT0xMDE0KXJldHVybiBpLlVOU0lHTkVEX0lOVDtpZihuPT09MTAxNSlyZXR1cm4gaS5GTE9BVDtpZihuPT09MTAxNilyZXR1cm4gaS5IQUxGX0ZMT0FUO2lmKG49PT0xMDIxKXJldHVybiBpLkFMUEhBO2lmKG49PT0xMDIyKXJldHVybiBpLlJHQjtpZihuPT09MTAyMylyZXR1cm4gaS5SR0JBO2lmKG49PT0xMDI0KXJldHVybiBpLkxVTUlOQU5DRTtpZihuPT09MTAyNSlyZXR1cm4gaS5MVU1JTkFOQ0VfQUxQSEE7aWYobj09PTEwMjYpcmV0dXJuIGkuREVQVEhfQ09NUE9ORU5UO2lmKG49PT0xMDI3KXJldHVybiBpLkRFUFRIX1NURU5DSUw7aWYobj09PTEwMjgpcmV0dXJuIGkuUkVEO2lmKG49PT0xMDI5KXJldHVybiBpLlJFRF9JTlRFR0VSO2lmKG49PT0xMDMwKXJldHVybiBpLlJHO2lmKG49PT0xMDMxKXJldHVybiBpLlJHX0lOVEVHRVI7aWYobj09PTEwMzMpcmV0dXJuIGkuUkdCQV9JTlRFR0VSO2lmKG49PT0zMzc3Nnx8bj09PTMzNzc3fHxuPT09MzM3Nzh8fG49PT0zMzc3OSlpZihhPT09cWUpaWYocz1lLmdldCgiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNfc3JnYiIpLHMhPT1udWxsKXtpZihuPT09MzM3NzYpcmV0dXJuIHMuQ09NUFJFU1NFRF9TUkdCX1MzVENfRFhUMV9FWFQ7aWYobj09PTMzNzc3KXJldHVybiBzLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDFfRVhUO2lmKG49PT0zMzc3OClyZXR1cm4gcy5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQzX0VYVDtpZihuPT09MzM3NzkpcmV0dXJuIHMuQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUNV9FWFR9ZWxzZSByZXR1cm4gbnVsbDtlbHNlIGlmKHM9ZS5nZXQoIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjIikscyE9PW51bGwpe2lmKG49PT0zMzc3NilyZXR1cm4gcy5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO2lmKG49PT0zMzc3NylyZXR1cm4gcy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDtpZihuPT09MzM3NzgpcmV0dXJuIHMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQ7aWYobj09PTMzNzc5KXJldHVybiBzLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUfWVsc2UgcmV0dXJuIG51bGw7aWYobj09PTM1ODQwfHxuPT09MzU4NDF8fG49PT0zNTg0Mnx8bj09PTM1ODQzKWlmKHM9ZS5nZXQoIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YyIpLHMhPT1udWxsKXtpZihuPT09MzU4NDApcmV0dXJuIHMuQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztpZihuPT09MzU4NDEpcmV0dXJuIHMuQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRztpZihuPT09MzU4NDIpcmV0dXJuIHMuQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUc7aWYobj09PTM1ODQzKXJldHVybiBzLkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HfWVsc2UgcmV0dXJuIG51bGw7aWYobj09PTM2MTk2fHxuPT09Mzc0OTJ8fG49PT0zNzQ5NilpZihzPWUuZ2V0KCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjIikscyE9PW51bGwpe2lmKG49PT0zNjE5Nnx8bj09PTM3NDkyKXJldHVybiBhPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0VUQzI6cy5DT01QUkVTU0VEX1JHQjhfRVRDMjtpZihuPT09Mzc0OTYpcmV0dXJuIGE9PT1xZT9zLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0VUQzJfRUFDOnMuQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQ31lbHNlIHJldHVybiBudWxsO2lmKG49PT0zNzgwOHx8bj09PTM3ODA5fHxuPT09Mzc4MTB8fG49PT0zNzgxMXx8bj09PTM3ODEyfHxuPT09Mzc4MTN8fG49PT0zNzgxNHx8bj09PTM3ODE1fHxuPT09Mzc4MTZ8fG49PT0zNzgxN3x8bj09PTM3ODE4fHxuPT09Mzc4MTl8fG49PT0zNzgyMHx8bj09PTM3ODIxKWlmKHM9ZS5nZXQoIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hc3RjIikscyE9PW51bGwpe2lmKG49PT0zNzgwOClyZXR1cm4gYT09PXFlP3MuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ180eDRfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfNHg0X0tIUjtpZihuPT09Mzc4MDkpcmV0dXJuIGE9PT1xZT9zLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNXg0X0tIUjpzLkNPTVBSRVNTRURfUkdCQV9BU1RDXzV4NF9LSFI7aWYobj09PTM3ODEwKXJldHVybiBhPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzV4NV9LSFI6cy5DT01QUkVTU0VEX1JHQkFfQVNUQ181eDVfS0hSO2lmKG49PT0zNzgxMSlyZXR1cm4gYT09PXFlP3MuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ182eDVfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfNng1X0tIUjtpZihuPT09Mzc4MTIpcmV0dXJuIGE9PT1xZT9zLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNng2X0tIUjpzLkNPTVBSRVNTRURfUkdCQV9BU1RDXzZ4Nl9LSFI7aWYobj09PTM3ODEzKXJldHVybiBhPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzh4NV9LSFI6cy5DT01QUkVTU0VEX1JHQkFfQVNUQ184eDVfS0hSO2lmKG49PT0zNzgxNClyZXR1cm4gYT09PXFlP3MuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDZfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfOHg2X0tIUjtpZihuPT09Mzc4MTUpcmV0dXJuIGE9PT1xZT9zLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfOHg4X0tIUjpzLkNPTVBSRVNTRURfUkdCQV9BU1RDXzh4OF9LSFI7aWYobj09PTM3ODE2KXJldHVybiBhPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDVfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4NV9LSFI7aWYobj09PTM3ODE3KXJldHVybiBhPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDZfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4Nl9LSFI7aWYobj09PTM3ODE4KXJldHVybiBhPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDhfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4OF9LSFI7aWYobj09PTM3ODE5KXJldHVybiBhPT09cWU/cy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDEwX0tIUjpzLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDEwX0tIUjtpZihuPT09Mzc4MjApcmV0dXJuIGE9PT1xZT9zLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTJ4MTBfS0hSOnMuQ09NUFJFU1NFRF9SR0JBX0FTVENfMTJ4MTBfS0hSO2lmKG49PT0zNzgyMSlyZXR1cm4gYT09PXFlP3MuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMngxMl9LSFI6cy5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMngxMl9LSFJ9ZWxzZSByZXR1cm4gbnVsbDtpZihuPT09MzY0OTJ8fG49PT0zNjQ5NHx8bj09PTM2NDk1KWlmKHM9ZS5nZXQoIkVYVF90ZXh0dXJlX2NvbXByZXNzaW9uX2JwdGMiKSxzIT09bnVsbCl7aWYobj09PTM2NDkyKXJldHVybiBhPT09cWU/cy5DT01QUkVTU0VEX1NSR0JfQUxQSEFfQlBUQ19VTk9STV9FWFQ6cy5DT01QUkVTU0VEX1JHQkFfQlBUQ19VTk9STV9FWFQ7aWYobj09PTM2NDk0KXJldHVybiBzLkNPTVBSRVNTRURfUkdCX0JQVENfU0lHTkVEX0ZMT0FUX0VYVDtpZihuPT09MzY0OTUpcmV0dXJuIHMuQ09NUFJFU1NFRF9SR0JfQlBUQ19VTlNJR05FRF9GTE9BVF9FWFR9ZWxzZSByZXR1cm4gbnVsbDtpZihuPT09MzYyODN8fG49PT0zNjI4NHx8bj09PTM2Mjg1fHxuPT09MzYyODYpaWYocz1lLmdldCgiRVhUX3RleHR1cmVfY29tcHJlc3Npb25fcmd0YyIpLHMhPT1udWxsKXtpZihuPT09MzY0OTIpcmV0dXJuIHMuQ09NUFJFU1NFRF9SRURfUkdUQzFfRVhUO2lmKG49PT0zNjI4NClyZXR1cm4gcy5DT01QUkVTU0VEX1NJR05FRF9SRURfUkdUQzFfRVhUO2lmKG49PT0zNjI4NSlyZXR1cm4gcy5DT01QUkVTU0VEX1JFRF9HUkVFTl9SR1RDMl9FWFQ7aWYobj09PTM2Mjg2KXJldHVybiBzLkNPTVBSRVNTRURfU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9FWFR9ZWxzZSByZXR1cm4gbnVsbDtyZXR1cm4gbj09PTEwMjA/aS5VTlNJR05FRF9JTlRfMjRfODppW25dIT09dm9pZCAwP2lbbl06bnVsbH1yZXR1cm57Y29udmVydDp0fX1jbGFzcyBMdSBleHRlbmRzIE50e2NvbnN0cnVjdG9yKGU9W10pe3N1cGVyKCksdGhpcy5pc0FycmF5Q2FtZXJhPSEwLHRoaXMuY2FtZXJhcz1lfX1jbGFzcyBwdCBleHRlbmRzIE10e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmlzR3JvdXA9ITAsdGhpcy50eXBlPSJHcm91cCJ9fWNvbnN0IFV1PXt0eXBlOiJtb3ZlIn07Y2xhc3MgZnJ7Y29uc3RydWN0b3IoKXt0aGlzLl90YXJnZXRSYXk9bnVsbCx0aGlzLl9ncmlwPW51bGwsdGhpcy5faGFuZD1udWxsfWdldEhhbmRTcGFjZSgpe3JldHVybiB0aGlzLl9oYW5kPT09bnVsbCYmKHRoaXMuX2hhbmQ9bmV3IHB0LHRoaXMuX2hhbmQubWF0cml4QXV0b1VwZGF0ZT0hMSx0aGlzLl9oYW5kLnZpc2libGU9ITEsdGhpcy5faGFuZC5qb2ludHM9e30sdGhpcy5faGFuZC5pbnB1dFN0YXRlPXtwaW5jaGluZzohMX0pLHRoaXMuX2hhbmR9Z2V0VGFyZ2V0UmF5U3BhY2UoKXtyZXR1cm4gdGhpcy5fdGFyZ2V0UmF5PT09bnVsbCYmKHRoaXMuX3RhcmdldFJheT1uZXcgcHQsdGhpcy5fdGFyZ2V0UmF5Lm1hdHJpeEF1dG9VcGRhdGU9ITEsdGhpcy5fdGFyZ2V0UmF5LnZpc2libGU9ITEsdGhpcy5fdGFyZ2V0UmF5Lmhhc0xpbmVhclZlbG9jaXR5PSExLHRoaXMuX3RhcmdldFJheS5saW5lYXJWZWxvY2l0eT1uZXcgQix0aGlzLl90YXJnZXRSYXkuaGFzQW5ndWxhclZlbG9jaXR5PSExLHRoaXMuX3RhcmdldFJheS5hbmd1bGFyVmVsb2NpdHk9bmV3IEIpLHRoaXMuX3RhcmdldFJheX1nZXRHcmlwU3BhY2UoKXtyZXR1cm4gdGhpcy5fZ3JpcD09PW51bGwmJih0aGlzLl9ncmlwPW5ldyBwdCx0aGlzLl9ncmlwLm1hdHJpeEF1dG9VcGRhdGU9ITEsdGhpcy5fZ3JpcC52aXNpYmxlPSExLHRoaXMuX2dyaXAuaGFzTGluZWFyVmVsb2NpdHk9ITEsdGhpcy5fZ3JpcC5saW5lYXJWZWxvY2l0eT1uZXcgQix0aGlzLl9ncmlwLmhhc0FuZ3VsYXJWZWxvY2l0eT0hMSx0aGlzLl9ncmlwLmFuZ3VsYXJWZWxvY2l0eT1uZXcgQiksdGhpcy5fZ3JpcH1kaXNwYXRjaEV2ZW50KGUpe3JldHVybiB0aGlzLl90YXJnZXRSYXkhPT1udWxsJiZ0aGlzLl90YXJnZXRSYXkuZGlzcGF0Y2hFdmVudChlKSx0aGlzLl9ncmlwIT09bnVsbCYmdGhpcy5fZ3JpcC5kaXNwYXRjaEV2ZW50KGUpLHRoaXMuX2hhbmQhPT1udWxsJiZ0aGlzLl9oYW5kLmRpc3BhdGNoRXZlbnQoZSksdGhpc31jb25uZWN0KGUpe2lmKGUmJmUuaGFuZCl7Y29uc3QgdD10aGlzLl9oYW5kO2lmKHQpZm9yKGNvbnN0IG4gb2YgZS5oYW5kLnZhbHVlcygpKXRoaXMuX2dldEhhbmRKb2ludCh0LG4pfXJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImNvbm5lY3RlZCIsZGF0YTplfSksdGhpc31kaXNjb25uZWN0KGUpe3JldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImRpc2Nvbm5lY3RlZCIsZGF0YTplfSksdGhpcy5fdGFyZ2V0UmF5IT09bnVsbCYmKHRoaXMuX3RhcmdldFJheS52aXNpYmxlPSExKSx0aGlzLl9ncmlwIT09bnVsbCYmKHRoaXMuX2dyaXAudmlzaWJsZT0hMSksdGhpcy5faGFuZCE9PW51bGwmJih0aGlzLl9oYW5kLnZpc2libGU9ITEpLHRoaXN9dXBkYXRlKGUsdCxuKXtsZXQgcj1udWxsLHM9bnVsbCxhPW51bGw7Y29uc3Qgbz10aGlzLl90YXJnZXRSYXksbD10aGlzLl9ncmlwLGM9dGhpcy5faGFuZDtpZihlJiZ0LnNlc3Npb24udmlzaWJpbGl0eVN0YXRlIT09InZpc2libGUtYmx1cnJlZCIpe2lmKGMmJmUuaGFuZCl7YT0hMDtmb3IoY29uc3QgeCBvZiBlLmhhbmQudmFsdWVzKCkpe2NvbnN0IG09dC5nZXRKb2ludFBvc2UoeCxuKSxkPXRoaXMuX2dldEhhbmRKb2ludChjLHgpO20hPT1udWxsJiYoZC5tYXRyaXguZnJvbUFycmF5KG0udHJhbnNmb3JtLm1hdHJpeCksZC5tYXRyaXguZGVjb21wb3NlKGQucG9zaXRpb24sZC5yb3RhdGlvbixkLnNjYWxlKSxkLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITAsZC5qb2ludFJhZGl1cz1tLnJhZGl1cyksZC52aXNpYmxlPW0hPT1udWxsfWNvbnN0IHU9Yy5qb2ludHNbImluZGV4LWZpbmdlci10aXAiXSxoPWMuam9pbnRzWyJ0aHVtYi10aXAiXSxmPXUucG9zaXRpb24uZGlzdGFuY2VUbyhoLnBvc2l0aW9uKSxwPS4wMixfPS4wMDU7Yy5pbnB1dFN0YXRlLnBpbmNoaW5nJiZmPnArXz8oYy5pbnB1dFN0YXRlLnBpbmNoaW5nPSExLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicGluY2hlbmQiLGhhbmRlZG5lc3M6ZS5oYW5kZWRuZXNzLHRhcmdldDp0aGlzfSkpOiFjLmlucHV0U3RhdGUucGluY2hpbmcmJmY8PXAtXyYmKGMuaW5wdXRTdGF0ZS5waW5jaGluZz0hMCx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6InBpbmNoc3RhcnQiLGhhbmRlZG5lc3M6ZS5oYW5kZWRuZXNzLHRhcmdldDp0aGlzfSkpfWVsc2UgbCE9PW51bGwmJmUuZ3JpcFNwYWNlJiYocz10LmdldFBvc2UoZS5ncmlwU3BhY2UsbikscyE9PW51bGwmJihsLm1hdHJpeC5mcm9tQXJyYXkocy50cmFuc2Zvcm0ubWF0cml4KSxsLm1hdHJpeC5kZWNvbXBvc2UobC5wb3NpdGlvbixsLnJvdGF0aW9uLGwuc2NhbGUpLGwubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMCxzLmxpbmVhclZlbG9jaXR5PyhsLmhhc0xpbmVhclZlbG9jaXR5PSEwLGwubGluZWFyVmVsb2NpdHkuY29weShzLmxpbmVhclZlbG9jaXR5KSk6bC5oYXNMaW5lYXJWZWxvY2l0eT0hMSxzLmFuZ3VsYXJWZWxvY2l0eT8obC5oYXNBbmd1bGFyVmVsb2NpdHk9ITAsbC5hbmd1bGFyVmVsb2NpdHkuY29weShzLmFuZ3VsYXJWZWxvY2l0eSkpOmwuaGFzQW5ndWxhclZlbG9jaXR5PSExKSk7byE9PW51bGwmJihyPXQuZ2V0UG9zZShlLnRhcmdldFJheVNwYWNlLG4pLHI9PT1udWxsJiZzIT09bnVsbCYmKHI9cyksciE9PW51bGwmJihvLm1hdHJpeC5mcm9tQXJyYXkoci50cmFuc2Zvcm0ubWF0cml4KSxvLm1hdHJpeC5kZWNvbXBvc2Uoby5wb3NpdGlvbixvLnJvdGF0aW9uLG8uc2NhbGUpLG8ubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMCxyLmxpbmVhclZlbG9jaXR5PyhvLmhhc0xpbmVhclZlbG9jaXR5PSEwLG8ubGluZWFyVmVsb2NpdHkuY29weShyLmxpbmVhclZlbG9jaXR5KSk6by5oYXNMaW5lYXJWZWxvY2l0eT0hMSxyLmFuZ3VsYXJWZWxvY2l0eT8oby5oYXNBbmd1bGFyVmVsb2NpdHk9ITAsby5hbmd1bGFyVmVsb2NpdHkuY29weShyLmFuZ3VsYXJWZWxvY2l0eSkpOm8uaGFzQW5ndWxhclZlbG9jaXR5PSExLHRoaXMuZGlzcGF0Y2hFdmVudChVdSkpKX1yZXR1cm4gbyE9PW51bGwmJihvLnZpc2libGU9ciE9PW51bGwpLGwhPT1udWxsJiYobC52aXNpYmxlPXMhPT1udWxsKSxjIT09bnVsbCYmKGMudmlzaWJsZT1hIT09bnVsbCksdGhpc31fZ2V0SGFuZEpvaW50KGUsdCl7aWYoZS5qb2ludHNbdC5qb2ludE5hbWVdPT09dm9pZCAwKXtjb25zdCBuPW5ldyBwdDtuLm1hdHJpeEF1dG9VcGRhdGU9ITEsbi52aXNpYmxlPSExLGUuam9pbnRzW3Quam9pbnROYW1lXT1uLGUuYWRkKG4pfXJldHVybiBlLmpvaW50c1t0LmpvaW50TmFtZV19fWNvbnN0IEZ1PWAKdm9pZCBtYWluKCkgewoKCWdsX1Bvc2l0aW9uID0gdmVjNCggcG9zaXRpb24sIDEuMCApOwoKfWAsSXU9YAp1bmlmb3JtIHNhbXBsZXIyREFycmF5IGRlcHRoQ29sb3I7CnVuaWZvcm0gZmxvYXQgZGVwdGhXaWR0aDsKdW5pZm9ybSBmbG9hdCBkZXB0aEhlaWdodDsKCnZvaWQgbWFpbigpIHsKCgl2ZWMyIGNvb3JkID0gdmVjMiggZ2xfRnJhZ0Nvb3JkLnggLyBkZXB0aFdpZHRoLCBnbF9GcmFnQ29vcmQueSAvIGRlcHRoSGVpZ2h0ICk7CgoJaWYgKCBjb29yZC54ID49IDEuMCApIHsKCgkJZ2xfRnJhZ0RlcHRoID0gdGV4dHVyZSggZGVwdGhDb2xvciwgdmVjMyggY29vcmQueCAtIDEuMCwgY29vcmQueSwgMSApICkucjsKCgl9IGVsc2UgewoKCQlnbF9GcmFnRGVwdGggPSB0ZXh0dXJlKCBkZXB0aENvbG9yLCB2ZWMzKCBjb29yZC54LCBjb29yZC55LCAwICkgKS5yOwoKCX0KCn1gO2NsYXNzIE51e2NvbnN0cnVjdG9yKCl7dGhpcy50ZXh0dXJlPW51bGwsdGhpcy5tZXNoPW51bGwsdGhpcy5kZXB0aE5lYXI9MCx0aGlzLmRlcHRoRmFyPTB9aW5pdChlLHQsbil7aWYodGhpcy50ZXh0dXJlPT09bnVsbCl7Y29uc3Qgcj1uZXcgdnQscz1lLnByb3BlcnRpZXMuZ2V0KHIpO3MuX193ZWJnbFRleHR1cmU9dC50ZXh0dXJlLCh0LmRlcHRoTmVhciE9bi5kZXB0aE5lYXJ8fHQuZGVwdGhGYXIhPW4uZGVwdGhGYXIpJiYodGhpcy5kZXB0aE5lYXI9dC5kZXB0aE5lYXIsdGhpcy5kZXB0aEZhcj10LmRlcHRoRmFyKSx0aGlzLnRleHR1cmU9cn19Z2V0TWVzaChlKXtpZih0aGlzLnRleHR1cmUhPT1udWxsJiZ0aGlzLm1lc2g9PT1udWxsKXtjb25zdCB0PWUuY2FtZXJhc1swXS52aWV3cG9ydCxuPW5ldyBodCh7dmVydGV4U2hhZGVyOkZ1LGZyYWdtZW50U2hhZGVyOkl1LHVuaWZvcm1zOntkZXB0aENvbG9yOnt2YWx1ZTp0aGlzLnRleHR1cmV9LGRlcHRoV2lkdGg6e3ZhbHVlOnQuen0sZGVwdGhIZWlnaHQ6e3ZhbHVlOnQud319fSk7dGhpcy5tZXNoPW5ldyBzdChuZXcgdHQoMjAsMjApLG4pfXJldHVybiB0aGlzLm1lc2h9cmVzZXQoKXt0aGlzLnRleHR1cmU9bnVsbCx0aGlzLm1lc2g9bnVsbH1nZXREZXB0aFRleHR1cmUoKXtyZXR1cm4gdGhpcy50ZXh0dXJlfX1jbGFzcyBPdSBleHRlbmRzIE1ue2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoKTtjb25zdCBuPXRoaXM7bGV0IHI9bnVsbCxzPTEsYT1udWxsLG89ImxvY2FsLWZsb29yIixsPTEsYz1udWxsLHU9bnVsbCxoPW51bGwsZj1udWxsLHA9bnVsbCxfPW51bGw7Y29uc3QgeD1uZXcgTnUsbT10LmdldENvbnRleHRBdHRyaWJ1dGVzKCk7bGV0IGQ9bnVsbCxBPW51bGw7Y29uc3QgVD1bXSxNPVtdLEY9bmV3IExlO2xldCBiPW51bGw7Y29uc3Qgdz1uZXcgTnQ7dy52aWV3cG9ydD1uZXcgaXQ7Y29uc3QgVT1uZXcgTnQ7VS52aWV3cG9ydD1uZXcgaXQ7Y29uc3QgRT1bdyxVXSxTPW5ldyBMdTtsZXQgUj1udWxsLHE9bnVsbDt0aGlzLmNhbWVyYUF1dG9VcGRhdGU9ITAsdGhpcy5lbmFibGVkPSExLHRoaXMuaXNQcmVzZW50aW5nPSExLHRoaXMuZ2V0Q29udHJvbGxlcj1mdW5jdGlvbihYKXtsZXQgZWU9VFtYXTtyZXR1cm4gZWU9PT12b2lkIDAmJihlZT1uZXcgZnIsVFtYXT1lZSksZWUuZ2V0VGFyZ2V0UmF5U3BhY2UoKX0sdGhpcy5nZXRDb250cm9sbGVyR3JpcD1mdW5jdGlvbihYKXtsZXQgZWU9VFtYXTtyZXR1cm4gZWU9PT12b2lkIDAmJihlZT1uZXcgZnIsVFtYXT1lZSksZWUuZ2V0R3JpcFNwYWNlKCl9LHRoaXMuZ2V0SGFuZD1mdW5jdGlvbihYKXtsZXQgZWU9VFtYXTtyZXR1cm4gZWU9PT12b2lkIDAmJihlZT1uZXcgZnIsVFtYXT1lZSksZWUuZ2V0SGFuZFNwYWNlKCl9O2Z1bmN0aW9uIHooWCl7Y29uc3QgZWU9TS5pbmRleE9mKFguaW5wdXRTb3VyY2UpO2lmKGVlPT09LTEpcmV0dXJuO2NvbnN0IF9lPVRbZWVdO19lIT09dm9pZCAwJiYoX2UudXBkYXRlKFguaW5wdXRTb3VyY2UsWC5mcmFtZSxjfHxhKSxfZS5kaXNwYXRjaEV2ZW50KHt0eXBlOlgudHlwZSxkYXRhOlguaW5wdXRTb3VyY2V9KSl9ZnVuY3Rpb24gVygpe3IucmVtb3ZlRXZlbnRMaXN0ZW5lcigic2VsZWN0Iix6KSxyLnJlbW92ZUV2ZW50TGlzdGVuZXIoInNlbGVjdHN0YXJ0Iix6KSxyLnJlbW92ZUV2ZW50TGlzdGVuZXIoInNlbGVjdGVuZCIseiksci5yZW1vdmVFdmVudExpc3RlbmVyKCJzcXVlZXplIix6KSxyLnJlbW92ZUV2ZW50TGlzdGVuZXIoInNxdWVlemVzdGFydCIseiksci5yZW1vdmVFdmVudExpc3RlbmVyKCJzcXVlZXplZW5kIix6KSxyLnJlbW92ZUV2ZW50TGlzdGVuZXIoImVuZCIsVyksci5yZW1vdmVFdmVudExpc3RlbmVyKCJpbnB1dHNvdXJjZXNjaGFuZ2UiLEspO2ZvcihsZXQgWD0wO1g8VC5sZW5ndGg7WCsrKXtjb25zdCBlZT1NW1hdO2VlIT09bnVsbCYmKE1bWF09bnVsbCxUW1hdLmRpc2Nvbm5lY3QoZWUpKX1SPW51bGwscT1udWxsLHgucmVzZXQoKSxlLnNldFJlbmRlclRhcmdldChkKSxwPW51bGwsZj1udWxsLGg9bnVsbCxyPW51bGwsQT1udWxsLFllLnN0b3AoKSxuLmlzUHJlc2VudGluZz0hMSxlLnNldFBpeGVsUmF0aW8oYiksZS5zZXRTaXplKEYud2lkdGgsRi5oZWlnaHQsITEpLG4uZGlzcGF0Y2hFdmVudCh7dHlwZToic2Vzc2lvbmVuZCJ9KX10aGlzLnNldEZyYW1lYnVmZmVyU2NhbGVGYWN0b3I9ZnVuY3Rpb24oWCl7cz1YLG4uaXNQcmVzZW50aW5nPT09ITAmJmNvbnNvbGUud2FybigiVEhSRUUuV2ViWFJNYW5hZ2VyOiBDYW5ub3QgY2hhbmdlIGZyYW1lYnVmZmVyIHNjYWxlIHdoaWxlIHByZXNlbnRpbmcuIil9LHRoaXMuc2V0UmVmZXJlbmNlU3BhY2VUeXBlPWZ1bmN0aW9uKFgpe289WCxuLmlzUHJlc2VudGluZz09PSEwJiZjb25zb2xlLndhcm4oIlRIUkVFLldlYlhSTWFuYWdlcjogQ2Fubm90IGNoYW5nZSByZWZlcmVuY2Ugc3BhY2UgdHlwZSB3aGlsZSBwcmVzZW50aW5nLiIpfSx0aGlzLmdldFJlZmVyZW5jZVNwYWNlPWZ1bmN0aW9uKCl7cmV0dXJuIGN8fGF9LHRoaXMuc2V0UmVmZXJlbmNlU3BhY2U9ZnVuY3Rpb24oWCl7Yz1YfSx0aGlzLmdldEJhc2VMYXllcj1mdW5jdGlvbigpe3JldHVybiBmIT09bnVsbD9mOnB9LHRoaXMuZ2V0QmluZGluZz1mdW5jdGlvbigpe3JldHVybiBofSx0aGlzLmdldEZyYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIF99LHRoaXMuZ2V0U2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybiByfSx0aGlzLnNldFNlc3Npb249YXN5bmMgZnVuY3Rpb24oWCl7aWYocj1YLHIhPT1udWxsKXtpZihkPWUuZ2V0UmVuZGVyVGFyZ2V0KCksci5hZGRFdmVudExpc3RlbmVyKCJzZWxlY3QiLHopLHIuYWRkRXZlbnRMaXN0ZW5lcigic2VsZWN0c3RhcnQiLHopLHIuYWRkRXZlbnRMaXN0ZW5lcigic2VsZWN0ZW5kIix6KSxyLmFkZEV2ZW50TGlzdGVuZXIoInNxdWVlemUiLHopLHIuYWRkRXZlbnRMaXN0ZW5lcigic3F1ZWV6ZXN0YXJ0Iix6KSxyLmFkZEV2ZW50TGlzdGVuZXIoInNxdWVlemVlbmQiLHopLHIuYWRkRXZlbnRMaXN0ZW5lcigiZW5kIixXKSxyLmFkZEV2ZW50TGlzdGVuZXIoImlucHV0c291cmNlc2NoYW5nZSIsSyksbS54ckNvbXBhdGlibGUhPT0hMCYmYXdhaXQgdC5tYWtlWFJDb21wYXRpYmxlKCksYj1lLmdldFBpeGVsUmF0aW8oKSxlLmdldFNpemUoRiksci5yZW5kZXJTdGF0ZS5sYXllcnM9PT12b2lkIDApe2NvbnN0IGVlPXthbnRpYWxpYXM6bS5hbnRpYWxpYXMsYWxwaGE6ITAsZGVwdGg6bS5kZXB0aCxzdGVuY2lsOm0uc3RlbmNpbCxmcmFtZWJ1ZmZlclNjYWxlRmFjdG9yOnN9O3A9bmV3IFhSV2ViR0xMYXllcihyLHQsZWUpLHIudXBkYXRlUmVuZGVyU3RhdGUoe2Jhc2VMYXllcjpwfSksZS5zZXRQaXhlbFJhdGlvKDEpLGUuc2V0U2l6ZShwLmZyYW1lYnVmZmVyV2lkdGgscC5mcmFtZWJ1ZmZlckhlaWdodCwhMSksQT1uZXcgSnQocC5mcmFtZWJ1ZmZlcldpZHRoLHAuZnJhbWVidWZmZXJIZWlnaHQse2Zvcm1hdDoxMDIzLHR5cGU6MTAwOSxjb2xvclNwYWNlOmUub3V0cHV0Q29sb3JTcGFjZSxzdGVuY2lsQnVmZmVyOm0uc3RlbmNpbH0pfWVsc2V7bGV0IGVlPW51bGwsX2U9bnVsbCxyZT1udWxsO20uZGVwdGgmJihyZT1tLnN0ZW5jaWw/dC5ERVBUSDI0X1NURU5DSUw4OnQuREVQVEhfQ09NUE9ORU5UMjQsZWU9bS5zdGVuY2lsPzEwMjc6MTAyNixfZT1tLnN0ZW5jaWw/MTAyMDoxMDE0KTtjb25zdCB5ZT17Y29sb3JGb3JtYXQ6dC5SR0JBOCxkZXB0aEZvcm1hdDpyZSxzY2FsZUZhY3RvcjpzfTtoPW5ldyBYUldlYkdMQmluZGluZyhyLHQpLGY9aC5jcmVhdGVQcm9qZWN0aW9uTGF5ZXIoeWUpLHIudXBkYXRlUmVuZGVyU3RhdGUoe2xheWVyczpbZl19KSxlLnNldFBpeGVsUmF0aW8oMSksZS5zZXRTaXplKGYudGV4dHVyZVdpZHRoLGYudGV4dHVyZUhlaWdodCwhMSksQT1uZXcgSnQoZi50ZXh0dXJlV2lkdGgsZi50ZXh0dXJlSGVpZ2h0LHtmb3JtYXQ6MTAyMyx0eXBlOjEwMDksZGVwdGhUZXh0dXJlOm5ldyBvcyhmLnRleHR1cmVXaWR0aCxmLnRleHR1cmVIZWlnaHQsX2Usdm9pZCAwLHZvaWQgMCx2b2lkIDAsdm9pZCAwLHZvaWQgMCx2b2lkIDAsZWUpLHN0ZW5jaWxCdWZmZXI6bS5zdGVuY2lsLGNvbG9yU3BhY2U6ZS5vdXRwdXRDb2xvclNwYWNlLHNhbXBsZXM6bS5hbnRpYWxpYXM/NDowLHJlc29sdmVEZXB0aEJ1ZmZlcjpmLmlnbm9yZURlcHRoVmFsdWVzPT09ITF9KX1BLmlzWFJSZW5kZXJUYXJnZXQ9ITAsdGhpcy5zZXRGb3ZlYXRpb24obCksYz1udWxsLGE9YXdhaXQgci5yZXF1ZXN0UmVmZXJlbmNlU3BhY2UobyksWWUuc2V0Q29udGV4dChyKSxZZS5zdGFydCgpLG4uaXNQcmVzZW50aW5nPSEwLG4uZGlzcGF0Y2hFdmVudCh7dHlwZToic2Vzc2lvbnN0YXJ0In0pfX0sdGhpcy5nZXRFbnZpcm9ubWVudEJsZW5kTW9kZT1mdW5jdGlvbigpe2lmKHIhPT1udWxsKXJldHVybiByLmVudmlyb25tZW50QmxlbmRNb2RlfSx0aGlzLmdldERlcHRoVGV4dHVyZT1mdW5jdGlvbigpe3JldHVybiB4LmdldERlcHRoVGV4dHVyZSgpfTtmdW5jdGlvbiBLKFgpe2ZvcihsZXQgZWU9MDtlZTxYLnJlbW92ZWQubGVuZ3RoO2VlKyspe2NvbnN0IF9lPVgucmVtb3ZlZFtlZV0scmU9TS5pbmRleE9mKF9lKTtyZT49MCYmKE1bcmVdPW51bGwsVFtyZV0uZGlzY29ubmVjdChfZSkpfWZvcihsZXQgZWU9MDtlZTxYLmFkZGVkLmxlbmd0aDtlZSsrKXtjb25zdCBfZT1YLmFkZGVkW2VlXTtsZXQgcmU9TS5pbmRleE9mKF9lKTtpZihyZT09PS0xKXtmb3IobGV0IGJlPTA7YmU8VC5sZW5ndGg7YmUrKylpZihiZT49TS5sZW5ndGgpe00ucHVzaChfZSkscmU9YmU7YnJlYWt9ZWxzZSBpZihNW2JlXT09PW51bGwpe01bYmVdPV9lLHJlPWJlO2JyZWFrfWlmKHJlPT09LTEpYnJlYWt9Y29uc3QgeWU9VFtyZV07eWUmJnllLmNvbm5lY3QoX2UpfX1jb25zdCBWPW5ldyBCLFE9bmV3IEI7ZnVuY3Rpb24gSChYLGVlLF9lKXtWLnNldEZyb21NYXRyaXhQb3NpdGlvbihlZS5tYXRyaXhXb3JsZCksUS5zZXRGcm9tTWF0cml4UG9zaXRpb24oX2UubWF0cml4V29ybGQpO2NvbnN0IHJlPVYuZGlzdGFuY2VUbyhRKSx5ZT1lZS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzLGJlPV9lLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMsRmU9eWVbMTRdLyh5ZVsxMF0tMSksZXQ9eWVbMTRdLyh5ZVsxMF0rMSksemU9KHllWzldKzEpL3llWzVdLGF0PSh5ZVs5XS0xKS95ZVs1XSxMPSh5ZVs4XS0xKS95ZVswXSxQdD0oYmVbOF0rMSkvYmVbMF0sSWU9RmUqTCxOZT1GZSpQdCxTZT1yZS8oLUwrUHQpLGplPVNlKi1MO2lmKGVlLm1hdHJpeFdvcmxkLmRlY29tcG9zZShYLnBvc2l0aW9uLFgucXVhdGVybmlvbixYLnNjYWxlKSxYLnRyYW5zbGF0ZVgoamUpLFgudHJhbnNsYXRlWihTZSksWC5tYXRyaXhXb3JsZC5jb21wb3NlKFgucG9zaXRpb24sWC5xdWF0ZXJuaW9uLFguc2NhbGUpLFgubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoWC5tYXRyaXhXb3JsZCkuaW52ZXJ0KCkseWVbMTBdPT09LTEpWC5wcm9qZWN0aW9uTWF0cml4LmNvcHkoZWUucHJvamVjdGlvbk1hdHJpeCksWC5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KGVlLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKTtlbHNle2NvbnN0IE1lPUZlK1NlLHk9ZXQrU2UsZz1JZS1qZSxJPU5lKyhyZS1qZSksWT16ZSpldC95Kk1lLFo9YXQqZXQveSpNZTtYLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKGcsSSxZLFosTWUseSksWC5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KFgucHJvamVjdGlvbk1hdHJpeCkuaW52ZXJ0KCl9fWZ1bmN0aW9uIGllKFgsZWUpe2VlPT09bnVsbD9YLm1hdHJpeFdvcmxkLmNvcHkoWC5tYXRyaXgpOlgubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyhlZS5tYXRyaXhXb3JsZCxYLm1hdHJpeCksWC5tYXRyaXhXb3JsZEludmVyc2UuY29weShYLm1hdHJpeFdvcmxkKS5pbnZlcnQoKX10aGlzLnVwZGF0ZUNhbWVyYT1mdW5jdGlvbihYKXtpZihyPT09bnVsbClyZXR1cm47bGV0IGVlPVgubmVhcixfZT1YLmZhcjt4LnRleHR1cmUhPT1udWxsJiYoeC5kZXB0aE5lYXI+MCYmKGVlPXguZGVwdGhOZWFyKSx4LmRlcHRoRmFyPjAmJihfZT14LmRlcHRoRmFyKSksUy5uZWFyPVUubmVhcj13Lm5lYXI9ZWUsUy5mYXI9VS5mYXI9dy5mYXI9X2UsKFIhPT1TLm5lYXJ8fHEhPT1TLmZhcikmJihyLnVwZGF0ZVJlbmRlclN0YXRlKHtkZXB0aE5lYXI6Uy5uZWFyLGRlcHRoRmFyOlMuZmFyfSksUj1TLm5lYXIscT1TLmZhciksdy5sYXllcnMubWFzaz1YLmxheWVycy5tYXNrfDIsVS5sYXllcnMubWFzaz1YLmxheWVycy5tYXNrfDQsUy5sYXllcnMubWFzaz13LmxheWVycy5tYXNrfFUubGF5ZXJzLm1hc2s7Y29uc3QgcmU9WC5wYXJlbnQseWU9Uy5jYW1lcmFzO2llKFMscmUpO2ZvcihsZXQgYmU9MDtiZTx5ZS5sZW5ndGg7YmUrKylpZSh5ZVtiZV0scmUpO3llLmxlbmd0aD09PTI/SChTLHcsVSk6Uy5wcm9qZWN0aW9uTWF0cml4LmNvcHkody5wcm9qZWN0aW9uTWF0cml4KSxjZShYLFMscmUpfTtmdW5jdGlvbiBjZShYLGVlLF9lKXtfZT09PW51bGw/WC5tYXRyaXguY29weShlZS5tYXRyaXhXb3JsZCk6KFgubWF0cml4LmNvcHkoX2UubWF0cml4V29ybGQpLFgubWF0cml4LmludmVydCgpLFgubWF0cml4Lm11bHRpcGx5KGVlLm1hdHJpeFdvcmxkKSksWC5tYXRyaXguZGVjb21wb3NlKFgucG9zaXRpb24sWC5xdWF0ZXJuaW9uLFguc2NhbGUpLFgudXBkYXRlTWF0cml4V29ybGQoITApLFgucHJvamVjdGlvbk1hdHJpeC5jb3B5KGVlLnByb2plY3Rpb25NYXRyaXgpLFgucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weShlZS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSksWC5pc1BlcnNwZWN0aXZlQ2FtZXJhJiYoWC5mb3Y9Vm4qMipNYXRoLmF0YW4oMS9YLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbNV0pLFguem9vbT0xKX10aGlzLmdldENhbWVyYT1mdW5jdGlvbigpe3JldHVybiBTfSx0aGlzLmdldEZvdmVhdGlvbj1mdW5jdGlvbigpe2lmKCEoZj09PW51bGwmJnA9PT1udWxsKSlyZXR1cm4gbH0sdGhpcy5zZXRGb3ZlYXRpb249ZnVuY3Rpb24oWCl7bD1YLGYhPT1udWxsJiYoZi5maXhlZEZvdmVhdGlvbj1YKSxwIT09bnVsbCYmcC5maXhlZEZvdmVhdGlvbiE9PXZvaWQgMCYmKHAuZml4ZWRGb3ZlYXRpb249WCl9LHRoaXMuaGFzRGVwdGhTZW5zaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHgudGV4dHVyZSE9PW51bGx9LHRoaXMuZ2V0RGVwdGhTZW5zaW5nTWVzaD1mdW5jdGlvbigpe3JldHVybiB4LmdldE1lc2goUyl9O2xldCB4ZT1udWxsO2Z1bmN0aW9uIFVlKFgsZWUpe2lmKHU9ZWUuZ2V0Vmlld2VyUG9zZShjfHxhKSxfPWVlLHUhPT1udWxsKXtjb25zdCBfZT11LnZpZXdzO3AhPT1udWxsJiYoZS5zZXRSZW5kZXJUYXJnZXRGcmFtZWJ1ZmZlcihBLHAuZnJhbWVidWZmZXIpLGUuc2V0UmVuZGVyVGFyZ2V0KEEpKTtsZXQgcmU9ITE7X2UubGVuZ3RoIT09Uy5jYW1lcmFzLmxlbmd0aCYmKFMuY2FtZXJhcy5sZW5ndGg9MCxyZT0hMCk7Zm9yKGxldCBiZT0wO2JlPF9lLmxlbmd0aDtiZSsrKXtjb25zdCBGZT1fZVtiZV07bGV0IGV0PW51bGw7aWYocCE9PW51bGwpZXQ9cC5nZXRWaWV3cG9ydChGZSk7ZWxzZXtjb25zdCBhdD1oLmdldFZpZXdTdWJJbWFnZShmLEZlKTtldD1hdC52aWV3cG9ydCxiZT09PTAmJihlLnNldFJlbmRlclRhcmdldFRleHR1cmVzKEEsYXQuY29sb3JUZXh0dXJlLGYuaWdub3JlRGVwdGhWYWx1ZXM/dm9pZCAwOmF0LmRlcHRoU3RlbmNpbFRleHR1cmUpLGUuc2V0UmVuZGVyVGFyZ2V0KEEpKX1sZXQgemU9RVtiZV07emU9PT12b2lkIDAmJih6ZT1uZXcgTnQsemUubGF5ZXJzLmVuYWJsZShiZSksemUudmlld3BvcnQ9bmV3IGl0LEVbYmVdPXplKSx6ZS5tYXRyaXguZnJvbUFycmF5KEZlLnRyYW5zZm9ybS5tYXRyaXgpLHplLm1hdHJpeC5kZWNvbXBvc2UoemUucG9zaXRpb24semUucXVhdGVybmlvbix6ZS5zY2FsZSksemUucHJvamVjdGlvbk1hdHJpeC5mcm9tQXJyYXkoRmUucHJvamVjdGlvbk1hdHJpeCksemUucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSh6ZS5wcm9qZWN0aW9uTWF0cml4KS5pbnZlcnQoKSx6ZS52aWV3cG9ydC5zZXQoZXQueCxldC55LGV0LndpZHRoLGV0LmhlaWdodCksYmU9PT0wJiYoUy5tYXRyaXguY29weSh6ZS5tYXRyaXgpLFMubWF0cml4LmRlY29tcG9zZShTLnBvc2l0aW9uLFMucXVhdGVybmlvbixTLnNjYWxlKSkscmU9PT0hMCYmUy5jYW1lcmFzLnB1c2goemUpfWNvbnN0IHllPXIuZW5hYmxlZEZlYXR1cmVzO2lmKHllJiZ5ZS5pbmNsdWRlcygiZGVwdGgtc2Vuc2luZyIpKXtjb25zdCBiZT1oLmdldERlcHRoSW5mb3JtYXRpb24oX2VbMF0pO2JlJiZiZS5pc1ZhbGlkJiZiZS50ZXh0dXJlJiZ4LmluaXQoZSxiZSxyLnJlbmRlclN0YXRlKX19Zm9yKGxldCBfZT0wO19lPFQubGVuZ3RoO19lKyspe2NvbnN0IHJlPU1bX2VdLHllPVRbX2VdO3JlIT09bnVsbCYmeWUhPT12b2lkIDAmJnllLnVwZGF0ZShyZSxlZSxjfHxhKX14ZSYmeGUoWCxlZSksZWUuZGV0ZWN0ZWRQbGFuZXMmJm4uZGlzcGF0Y2hFdmVudCh7dHlwZToicGxhbmVzZGV0ZWN0ZWQiLGRhdGE6ZWV9KSxfPW51bGx9Y29uc3QgWWU9bmV3IFFyO1llLnNldEFuaW1hdGlvbkxvb3AoVWUpLHRoaXMuc2V0QW5pbWF0aW9uTG9vcD1mdW5jdGlvbihYKXt4ZT1YfSx0aGlzLmRpc3Bvc2U9ZnVuY3Rpb24oKXt9fX1jb25zdCBnbj1uZXcgWHQsQnU9bmV3IHJ0O2Z1bmN0aW9uIHp1KGksZSl7ZnVuY3Rpb24gdChtLGQpe20ubWF0cml4QXV0b1VwZGF0ZT09PSEwJiZtLnVwZGF0ZU1hdHJpeCgpLGQudmFsdWUuY29weShtLm1hdHJpeCl9ZnVuY3Rpb24gbihtLGQpe2QuY29sb3IuZ2V0UkdCKG0uZm9nQ29sb3IudmFsdWUsWXIoaSkpLGQuaXNGb2c/KG0uZm9nTmVhci52YWx1ZT1kLm5lYXIsbS5mb2dGYXIudmFsdWU9ZC5mYXIpOmQuaXNGb2dFeHAyJiYobS5mb2dEZW5zaXR5LnZhbHVlPWQuZGVuc2l0eSl9ZnVuY3Rpb24gcihtLGQsQSxULE0pe2QuaXNNZXNoQmFzaWNNYXRlcmlhbHx8ZC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWw/cyhtLGQpOmQuaXNNZXNoVG9vbk1hdGVyaWFsPyhzKG0sZCksaChtLGQpKTpkLmlzTWVzaFBob25nTWF0ZXJpYWw/KHMobSxkKSx1KG0sZCkpOmQuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbD8ocyhtLGQpLGYobSxkKSxkLmlzTWVzaFBoeXNpY2FsTWF0ZXJpYWwmJnAobSxkLE0pKTpkLmlzTWVzaE1hdGNhcE1hdGVyaWFsPyhzKG0sZCksXyhtLGQpKTpkLmlzTWVzaERlcHRoTWF0ZXJpYWw/cyhtLGQpOmQuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbD8ocyhtLGQpLHgobSxkKSk6ZC5pc01lc2hOb3JtYWxNYXRlcmlhbD9zKG0sZCk6ZC5pc0xpbmVCYXNpY01hdGVyaWFsPyhhKG0sZCksZC5pc0xpbmVEYXNoZWRNYXRlcmlhbCYmbyhtLGQpKTpkLmlzUG9pbnRzTWF0ZXJpYWw/bChtLGQsQSxUKTpkLmlzU3ByaXRlTWF0ZXJpYWw/YyhtLGQpOmQuaXNTaGFkb3dNYXRlcmlhbD8obS5jb2xvci52YWx1ZS5jb3B5KGQuY29sb3IpLG0ub3BhY2l0eS52YWx1ZT1kLm9wYWNpdHkpOmQuaXNTaGFkZXJNYXRlcmlhbCYmKGQudW5pZm9ybXNOZWVkVXBkYXRlPSExKX1mdW5jdGlvbiBzKG0sZCl7bS5vcGFjaXR5LnZhbHVlPWQub3BhY2l0eSxkLmNvbG9yJiZtLmRpZmZ1c2UudmFsdWUuY29weShkLmNvbG9yKSxkLmVtaXNzaXZlJiZtLmVtaXNzaXZlLnZhbHVlLmNvcHkoZC5lbWlzc2l2ZSkubXVsdGlwbHlTY2FsYXIoZC5lbWlzc2l2ZUludGVuc2l0eSksZC5tYXAmJihtLm1hcC52YWx1ZT1kLm1hcCx0KGQubWFwLG0ubWFwVHJhbnNmb3JtKSksZC5hbHBoYU1hcCYmKG0uYWxwaGFNYXAudmFsdWU9ZC5hbHBoYU1hcCx0KGQuYWxwaGFNYXAsbS5hbHBoYU1hcFRyYW5zZm9ybSkpLGQuYnVtcE1hcCYmKG0uYnVtcE1hcC52YWx1ZT1kLmJ1bXBNYXAsdChkLmJ1bXBNYXAsbS5idW1wTWFwVHJhbnNmb3JtKSxtLmJ1bXBTY2FsZS52YWx1ZT1kLmJ1bXBTY2FsZSxkLnNpZGU9PT0xJiYobS5idW1wU2NhbGUudmFsdWUqPS0xKSksZC5ub3JtYWxNYXAmJihtLm5vcm1hbE1hcC52YWx1ZT1kLm5vcm1hbE1hcCx0KGQubm9ybWFsTWFwLG0ubm9ybWFsTWFwVHJhbnNmb3JtKSxtLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoZC5ub3JtYWxTY2FsZSksZC5zaWRlPT09MSYmbS5ub3JtYWxTY2FsZS52YWx1ZS5uZWdhdGUoKSksZC5kaXNwbGFjZW1lbnRNYXAmJihtLmRpc3BsYWNlbWVudE1hcC52YWx1ZT1kLmRpc3BsYWNlbWVudE1hcCx0KGQuZGlzcGxhY2VtZW50TWFwLG0uZGlzcGxhY2VtZW50TWFwVHJhbnNmb3JtKSxtLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlPWQuZGlzcGxhY2VtZW50U2NhbGUsbS5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlPWQuZGlzcGxhY2VtZW50QmlhcyksZC5lbWlzc2l2ZU1hcCYmKG0uZW1pc3NpdmVNYXAudmFsdWU9ZC5lbWlzc2l2ZU1hcCx0KGQuZW1pc3NpdmVNYXAsbS5lbWlzc2l2ZU1hcFRyYW5zZm9ybSkpLGQuc3BlY3VsYXJNYXAmJihtLnNwZWN1bGFyTWFwLnZhbHVlPWQuc3BlY3VsYXJNYXAsdChkLnNwZWN1bGFyTWFwLG0uc3BlY3VsYXJNYXBUcmFuc2Zvcm0pKSxkLmFscGhhVGVzdD4wJiYobS5hbHBoYVRlc3QudmFsdWU9ZC5hbHBoYVRlc3QpO2NvbnN0IEE9ZS5nZXQoZCksVD1BLmVudk1hcCxNPUEuZW52TWFwUm90YXRpb247VCYmKG0uZW52TWFwLnZhbHVlPVQsZ24uY29weShNKSxnbi54Kj0tMSxnbi55Kj0tMSxnbi56Kj0tMSxULmlzQ3ViZVRleHR1cmUmJlQuaXNSZW5kZXJUYXJnZXRUZXh0dXJlPT09ITEmJihnbi55Kj0tMSxnbi56Kj0tMSksbS5lbnZNYXBSb3RhdGlvbi52YWx1ZS5zZXRGcm9tTWF0cml4NChCdS5tYWtlUm90YXRpb25Gcm9tRXVsZXIoZ24pKSxtLmZsaXBFbnZNYXAudmFsdWU9VC5pc0N1YmVUZXh0dXJlJiZULmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT09PSExPy0xOjEsbS5yZWZsZWN0aXZpdHkudmFsdWU9ZC5yZWZsZWN0aXZpdHksbS5pb3IudmFsdWU9ZC5pb3IsbS5yZWZyYWN0aW9uUmF0aW8udmFsdWU9ZC5yZWZyYWN0aW9uUmF0aW8pLGQubGlnaHRNYXAmJihtLmxpZ2h0TWFwLnZhbHVlPWQubGlnaHRNYXAsbS5saWdodE1hcEludGVuc2l0eS52YWx1ZT1kLmxpZ2h0TWFwSW50ZW5zaXR5LHQoZC5saWdodE1hcCxtLmxpZ2h0TWFwVHJhbnNmb3JtKSksZC5hb01hcCYmKG0uYW9NYXAudmFsdWU9ZC5hb01hcCxtLmFvTWFwSW50ZW5zaXR5LnZhbHVlPWQuYW9NYXBJbnRlbnNpdHksdChkLmFvTWFwLG0uYW9NYXBUcmFuc2Zvcm0pKX1mdW5jdGlvbiBhKG0sZCl7bS5kaWZmdXNlLnZhbHVlLmNvcHkoZC5jb2xvciksbS5vcGFjaXR5LnZhbHVlPWQub3BhY2l0eSxkLm1hcCYmKG0ubWFwLnZhbHVlPWQubWFwLHQoZC5tYXAsbS5tYXBUcmFuc2Zvcm0pKX1mdW5jdGlvbiBvKG0sZCl7bS5kYXNoU2l6ZS52YWx1ZT1kLmRhc2hTaXplLG0udG90YWxTaXplLnZhbHVlPWQuZGFzaFNpemUrZC5nYXBTaXplLG0uc2NhbGUudmFsdWU9ZC5zY2FsZX1mdW5jdGlvbiBsKG0sZCxBLFQpe20uZGlmZnVzZS52YWx1ZS5jb3B5KGQuY29sb3IpLG0ub3BhY2l0eS52YWx1ZT1kLm9wYWNpdHksbS5zaXplLnZhbHVlPWQuc2l6ZSpBLG0uc2NhbGUudmFsdWU9VCouNSxkLm1hcCYmKG0ubWFwLnZhbHVlPWQubWFwLHQoZC5tYXAsbS51dlRyYW5zZm9ybSkpLGQuYWxwaGFNYXAmJihtLmFscGhhTWFwLnZhbHVlPWQuYWxwaGFNYXAsdChkLmFscGhhTWFwLG0uYWxwaGFNYXBUcmFuc2Zvcm0pKSxkLmFscGhhVGVzdD4wJiYobS5hbHBoYVRlc3QudmFsdWU9ZC5hbHBoYVRlc3QpfWZ1bmN0aW9uIGMobSxkKXttLmRpZmZ1c2UudmFsdWUuY29weShkLmNvbG9yKSxtLm9wYWNpdHkudmFsdWU9ZC5vcGFjaXR5LG0ucm90YXRpb24udmFsdWU9ZC5yb3RhdGlvbixkLm1hcCYmKG0ubWFwLnZhbHVlPWQubWFwLHQoZC5tYXAsbS5tYXBUcmFuc2Zvcm0pKSxkLmFscGhhTWFwJiYobS5hbHBoYU1hcC52YWx1ZT1kLmFscGhhTWFwLHQoZC5hbHBoYU1hcCxtLmFscGhhTWFwVHJhbnNmb3JtKSksZC5hbHBoYVRlc3Q+MCYmKG0uYWxwaGFUZXN0LnZhbHVlPWQuYWxwaGFUZXN0KX1mdW5jdGlvbiB1KG0sZCl7bS5zcGVjdWxhci52YWx1ZS5jb3B5KGQuc3BlY3VsYXIpLG0uc2hpbmluZXNzLnZhbHVlPU1hdGgubWF4KGQuc2hpbmluZXNzLDFlLTQpfWZ1bmN0aW9uIGgobSxkKXtkLmdyYWRpZW50TWFwJiYobS5ncmFkaWVudE1hcC52YWx1ZT1kLmdyYWRpZW50TWFwKX1mdW5jdGlvbiBmKG0sZCl7bS5tZXRhbG5lc3MudmFsdWU9ZC5tZXRhbG5lc3MsZC5tZXRhbG5lc3NNYXAmJihtLm1ldGFsbmVzc01hcC52YWx1ZT1kLm1ldGFsbmVzc01hcCx0KGQubWV0YWxuZXNzTWFwLG0ubWV0YWxuZXNzTWFwVHJhbnNmb3JtKSksbS5yb3VnaG5lc3MudmFsdWU9ZC5yb3VnaG5lc3MsZC5yb3VnaG5lc3NNYXAmJihtLnJvdWdobmVzc01hcC52YWx1ZT1kLnJvdWdobmVzc01hcCx0KGQucm91Z2huZXNzTWFwLG0ucm91Z2huZXNzTWFwVHJhbnNmb3JtKSksZC5lbnZNYXAmJihtLmVudk1hcEludGVuc2l0eS52YWx1ZT1kLmVudk1hcEludGVuc2l0eSl9ZnVuY3Rpb24gcChtLGQsQSl7bS5pb3IudmFsdWU9ZC5pb3IsZC5zaGVlbj4wJiYobS5zaGVlbkNvbG9yLnZhbHVlLmNvcHkoZC5zaGVlbkNvbG9yKS5tdWx0aXBseVNjYWxhcihkLnNoZWVuKSxtLnNoZWVuUm91Z2huZXNzLnZhbHVlPWQuc2hlZW5Sb3VnaG5lc3MsZC5zaGVlbkNvbG9yTWFwJiYobS5zaGVlbkNvbG9yTWFwLnZhbHVlPWQuc2hlZW5Db2xvck1hcCx0KGQuc2hlZW5Db2xvck1hcCxtLnNoZWVuQ29sb3JNYXBUcmFuc2Zvcm0pKSxkLnNoZWVuUm91Z2huZXNzTWFwJiYobS5zaGVlblJvdWdobmVzc01hcC52YWx1ZT1kLnNoZWVuUm91Z2huZXNzTWFwLHQoZC5zaGVlblJvdWdobmVzc01hcCxtLnNoZWVuUm91Z2huZXNzTWFwVHJhbnNmb3JtKSkpLGQuY2xlYXJjb2F0PjAmJihtLmNsZWFyY29hdC52YWx1ZT1kLmNsZWFyY29hdCxtLmNsZWFyY29hdFJvdWdobmVzcy52YWx1ZT1kLmNsZWFyY29hdFJvdWdobmVzcyxkLmNsZWFyY29hdE1hcCYmKG0uY2xlYXJjb2F0TWFwLnZhbHVlPWQuY2xlYXJjb2F0TWFwLHQoZC5jbGVhcmNvYXRNYXAsbS5jbGVhcmNvYXRNYXBUcmFuc2Zvcm0pKSxkLmNsZWFyY29hdFJvdWdobmVzc01hcCYmKG0uY2xlYXJjb2F0Um91Z2huZXNzTWFwLnZhbHVlPWQuY2xlYXJjb2F0Um91Z2huZXNzTWFwLHQoZC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAsbS5jbGVhcmNvYXRSb3VnaG5lc3NNYXBUcmFuc2Zvcm0pKSxkLmNsZWFyY29hdE5vcm1hbE1hcCYmKG0uY2xlYXJjb2F0Tm9ybWFsTWFwLnZhbHVlPWQuY2xlYXJjb2F0Tm9ybWFsTWFwLHQoZC5jbGVhcmNvYXROb3JtYWxNYXAsbS5jbGVhcmNvYXROb3JtYWxNYXBUcmFuc2Zvcm0pLG0uY2xlYXJjb2F0Tm9ybWFsU2NhbGUudmFsdWUuY29weShkLmNsZWFyY29hdE5vcm1hbFNjYWxlKSxkLnNpZGU9PT0xJiZtLmNsZWFyY29hdE5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpKSksZC5kaXNwZXJzaW9uPjAmJihtLmRpc3BlcnNpb24udmFsdWU9ZC5kaXNwZXJzaW9uKSxkLmlyaWRlc2NlbmNlPjAmJihtLmlyaWRlc2NlbmNlLnZhbHVlPWQuaXJpZGVzY2VuY2UsbS5pcmlkZXNjZW5jZUlPUi52YWx1ZT1kLmlyaWRlc2NlbmNlSU9SLG0uaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtLnZhbHVlPWQuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZVswXSxtLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bS52YWx1ZT1kLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbMV0sZC5pcmlkZXNjZW5jZU1hcCYmKG0uaXJpZGVzY2VuY2VNYXAudmFsdWU9ZC5pcmlkZXNjZW5jZU1hcCx0KGQuaXJpZGVzY2VuY2VNYXAsbS5pcmlkZXNjZW5jZU1hcFRyYW5zZm9ybSkpLGQuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAmJihtLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLnZhbHVlPWQuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAsdChkLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLG0uaXJpZGVzY2VuY2VUaGlja25lc3NNYXBUcmFuc2Zvcm0pKSksZC50cmFuc21pc3Npb24+MCYmKG0udHJhbnNtaXNzaW9uLnZhbHVlPWQudHJhbnNtaXNzaW9uLG0udHJhbnNtaXNzaW9uU2FtcGxlck1hcC52YWx1ZT1BLnRleHR1cmUsbS50cmFuc21pc3Npb25TYW1wbGVyU2l6ZS52YWx1ZS5zZXQoQS53aWR0aCxBLmhlaWdodCksZC50cmFuc21pc3Npb25NYXAmJihtLnRyYW5zbWlzc2lvbk1hcC52YWx1ZT1kLnRyYW5zbWlzc2lvbk1hcCx0KGQudHJhbnNtaXNzaW9uTWFwLG0udHJhbnNtaXNzaW9uTWFwVHJhbnNmb3JtKSksbS50aGlja25lc3MudmFsdWU9ZC50aGlja25lc3MsZC50aGlja25lc3NNYXAmJihtLnRoaWNrbmVzc01hcC52YWx1ZT1kLnRoaWNrbmVzc01hcCx0KGQudGhpY2tuZXNzTWFwLG0udGhpY2tuZXNzTWFwVHJhbnNmb3JtKSksbS5hdHRlbnVhdGlvbkRpc3RhbmNlLnZhbHVlPWQuYXR0ZW51YXRpb25EaXN0YW5jZSxtLmF0dGVudWF0aW9uQ29sb3IudmFsdWUuY29weShkLmF0dGVudWF0aW9uQ29sb3IpKSxkLmFuaXNvdHJvcHk+MCYmKG0uYW5pc290cm9weVZlY3Rvci52YWx1ZS5zZXQoZC5hbmlzb3Ryb3B5Kk1hdGguY29zKGQuYW5pc290cm9weVJvdGF0aW9uKSxkLmFuaXNvdHJvcHkqTWF0aC5zaW4oZC5hbmlzb3Ryb3B5Um90YXRpb24pKSxkLmFuaXNvdHJvcHlNYXAmJihtLmFuaXNvdHJvcHlNYXAudmFsdWU9ZC5hbmlzb3Ryb3B5TWFwLHQoZC5hbmlzb3Ryb3B5TWFwLG0uYW5pc290cm9weU1hcFRyYW5zZm9ybSkpKSxtLnNwZWN1bGFySW50ZW5zaXR5LnZhbHVlPWQuc3BlY3VsYXJJbnRlbnNpdHksbS5zcGVjdWxhckNvbG9yLnZhbHVlLmNvcHkoZC5zcGVjdWxhckNvbG9yKSxkLnNwZWN1bGFyQ29sb3JNYXAmJihtLnNwZWN1bGFyQ29sb3JNYXAudmFsdWU9ZC5zcGVjdWxhckNvbG9yTWFwLHQoZC5zcGVjdWxhckNvbG9yTWFwLG0uc3BlY3VsYXJDb2xvck1hcFRyYW5zZm9ybSkpLGQuc3BlY3VsYXJJbnRlbnNpdHlNYXAmJihtLnNwZWN1bGFySW50ZW5zaXR5TWFwLnZhbHVlPWQuc3BlY3VsYXJJbnRlbnNpdHlNYXAsdChkLnNwZWN1bGFySW50ZW5zaXR5TWFwLG0uc3BlY3VsYXJJbnRlbnNpdHlNYXBUcmFuc2Zvcm0pKX1mdW5jdGlvbiBfKG0sZCl7ZC5tYXRjYXAmJihtLm1hdGNhcC52YWx1ZT1kLm1hdGNhcCl9ZnVuY3Rpb24geChtLGQpe2NvbnN0IEE9ZS5nZXQoZCkubGlnaHQ7bS5yZWZlcmVuY2VQb3NpdGlvbi52YWx1ZS5zZXRGcm9tTWF0cml4UG9zaXRpb24oQS5tYXRyaXhXb3JsZCksbS5uZWFyRGlzdGFuY2UudmFsdWU9QS5zaGFkb3cuY2FtZXJhLm5lYXIsbS5mYXJEaXN0YW5jZS52YWx1ZT1BLnNoYWRvdy5jYW1lcmEuZmFyfXJldHVybntyZWZyZXNoRm9nVW5pZm9ybXM6bixyZWZyZXNoTWF0ZXJpYWxVbmlmb3JtczpyfX1mdW5jdGlvbiBHdShpLGUsdCxuKXtsZXQgcj17fSxzPXt9LGE9W107Y29uc3Qgbz1pLmdldFBhcmFtZXRlcihpLk1BWF9VTklGT1JNX0JVRkZFUl9CSU5ESU5HUyk7ZnVuY3Rpb24gbChBLFQpe2NvbnN0IE09VC5wcm9ncmFtO24udW5pZm9ybUJsb2NrQmluZGluZyhBLE0pfWZ1bmN0aW9uIGMoQSxUKXtsZXQgTT1yW0EuaWRdO009PT12b2lkIDAmJihfKEEpLE09dShBKSxyW0EuaWRdPU0sQS5hZGRFdmVudExpc3RlbmVyKCJkaXNwb3NlIixtKSk7Y29uc3QgRj1ULnByb2dyYW07bi51cGRhdGVVQk9NYXBwaW5nKEEsRik7Y29uc3QgYj1lLnJlbmRlci5mcmFtZTtzW0EuaWRdIT09YiYmKGYoQSksc1tBLmlkXT1iKX1mdW5jdGlvbiB1KEEpe2NvbnN0IFQ9aCgpO0EuX19iaW5kaW5nUG9pbnRJbmRleD1UO2NvbnN0IE09aS5jcmVhdGVCdWZmZXIoKSxGPUEuX19zaXplLGI9QS51c2FnZTtyZXR1cm4gaS5iaW5kQnVmZmVyKGkuVU5JRk9STV9CVUZGRVIsTSksaS5idWZmZXJEYXRhKGkuVU5JRk9STV9CVUZGRVIsRixiKSxpLmJpbmRCdWZmZXIoaS5VTklGT1JNX0JVRkZFUixudWxsKSxpLmJpbmRCdWZmZXJCYXNlKGkuVU5JRk9STV9CVUZGRVIsVCxNKSxNfWZ1bmN0aW9uIGgoKXtmb3IobGV0IEE9MDtBPG87QSsrKWlmKGEuaW5kZXhPZihBKT09PS0xKXJldHVybiBhLnB1c2goQSksQTtyZXR1cm4gY29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xSZW5kZXJlcjogTWF4aW11bSBudW1iZXIgb2Ygc2ltdWx0YW5lb3VzbHkgdXNhYmxlIHVuaWZvcm1zIGdyb3VwcyByZWFjaGVkLiIpLDB9ZnVuY3Rpb24gZihBKXtjb25zdCBUPXJbQS5pZF0sTT1BLnVuaWZvcm1zLEY9QS5fX2NhY2hlO2kuYmluZEJ1ZmZlcihpLlVOSUZPUk1fQlVGRkVSLFQpO2ZvcihsZXQgYj0wLHc9TS5sZW5ndGg7Yjx3O2IrKyl7Y29uc3QgVT1BcnJheS5pc0FycmF5KE1bYl0pP01bYl06W01bYl1dO2ZvcihsZXQgRT0wLFM9VS5sZW5ndGg7RTxTO0UrKyl7Y29uc3QgUj1VW0VdO2lmKHAoUixiLEUsRik9PT0hMCl7Y29uc3QgcT1SLl9fb2Zmc2V0LHo9QXJyYXkuaXNBcnJheShSLnZhbHVlKT9SLnZhbHVlOltSLnZhbHVlXTtsZXQgVz0wO2ZvcihsZXQgSz0wO0s8ei5sZW5ndGg7SysrKXtjb25zdCBWPXpbS10sUT14KFYpO3R5cGVvZiBWPT0ibnVtYmVyInx8dHlwZW9mIFY9PSJib29sZWFuIj8oUi5fX2RhdGFbMF09VixpLmJ1ZmZlclN1YkRhdGEoaS5VTklGT1JNX0JVRkZFUixxK1csUi5fX2RhdGEpKTpWLmlzTWF0cml4Mz8oUi5fX2RhdGFbMF09Vi5lbGVtZW50c1swXSxSLl9fZGF0YVsxXT1WLmVsZW1lbnRzWzFdLFIuX19kYXRhWzJdPVYuZWxlbWVudHNbMl0sUi5fX2RhdGFbM109MCxSLl9fZGF0YVs0XT1WLmVsZW1lbnRzWzNdLFIuX19kYXRhWzVdPVYuZWxlbWVudHNbNF0sUi5fX2RhdGFbNl09Vi5lbGVtZW50c1s1XSxSLl9fZGF0YVs3XT0wLFIuX19kYXRhWzhdPVYuZWxlbWVudHNbNl0sUi5fX2RhdGFbOV09Vi5lbGVtZW50c1s3XSxSLl9fZGF0YVsxMF09Vi5lbGVtZW50c1s4XSxSLl9fZGF0YVsxMV09MCk6KFYudG9BcnJheShSLl9fZGF0YSxXKSxXKz1RLnN0b3JhZ2UvRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKX1pLmJ1ZmZlclN1YkRhdGEoaS5VTklGT1JNX0JVRkZFUixxLFIuX19kYXRhKX19fWkuYmluZEJ1ZmZlcihpLlVOSUZPUk1fQlVGRkVSLG51bGwpfWZ1bmN0aW9uIHAoQSxULE0sRil7Y29uc3QgYj1BLnZhbHVlLHc9VCsiXyIrTTtpZihGW3ddPT09dm9pZCAwKXJldHVybiB0eXBlb2YgYj09Im51bWJlciJ8fHR5cGVvZiBiPT0iYm9vbGVhbiI/Rlt3XT1iOkZbd109Yi5jbG9uZSgpLCEwO3tjb25zdCBVPUZbd107aWYodHlwZW9mIGI9PSJudW1iZXIifHx0eXBlb2YgYj09ImJvb2xlYW4iKXtpZihVIT09YilyZXR1cm4gRlt3XT1iLCEwfWVsc2UgaWYoVS5lcXVhbHMoYik9PT0hMSlyZXR1cm4gVS5jb3B5KGIpLCEwfXJldHVybiExfWZ1bmN0aW9uIF8oQSl7Y29uc3QgVD1BLnVuaWZvcm1zO2xldCBNPTA7Y29uc3QgRj0xNjtmb3IobGV0IHc9MCxVPVQubGVuZ3RoO3c8VTt3Kyspe2NvbnN0IEU9QXJyYXkuaXNBcnJheShUW3ddKT9UW3ddOltUW3ddXTtmb3IobGV0IFM9MCxSPUUubGVuZ3RoO1M8UjtTKyspe2NvbnN0IHE9RVtTXSx6PUFycmF5LmlzQXJyYXkocS52YWx1ZSk/cS52YWx1ZTpbcS52YWx1ZV07Zm9yKGxldCBXPTAsSz16Lmxlbmd0aDtXPEs7VysrKXtjb25zdCBWPXpbV10sUT14KFYpLEg9TSVGLGllPUglUS5ib3VuZGFyeSxjZT1IK2llO00rPWllLGNlIT09MCYmRi1jZTxRLnN0b3JhZ2UmJihNKz1GLWNlKSxxLl9fZGF0YT1uZXcgRmxvYXQzMkFycmF5KFEuc3RvcmFnZS9GbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpLHEuX19vZmZzZXQ9TSxNKz1RLnN0b3JhZ2V9fX1jb25zdCBiPU0lRjtyZXR1cm4gYj4wJiYoTSs9Ri1iKSxBLl9fc2l6ZT1NLEEuX19jYWNoZT17fSx0aGlzfWZ1bmN0aW9uIHgoQSl7Y29uc3QgVD17Ym91bmRhcnk6MCxzdG9yYWdlOjB9O3JldHVybiB0eXBlb2YgQT09Im51bWJlciJ8fHR5cGVvZiBBPT0iYm9vbGVhbiI/KFQuYm91bmRhcnk9NCxULnN0b3JhZ2U9NCk6QS5pc1ZlY3RvcjI/KFQuYm91bmRhcnk9OCxULnN0b3JhZ2U9OCk6QS5pc1ZlY3RvcjN8fEEuaXNDb2xvcj8oVC5ib3VuZGFyeT0xNixULnN0b3JhZ2U9MTIpOkEuaXNWZWN0b3I0PyhULmJvdW5kYXJ5PTE2LFQuc3RvcmFnZT0xNik6QS5pc01hdHJpeDM/KFQuYm91bmRhcnk9NDgsVC5zdG9yYWdlPTQ4KTpBLmlzTWF0cml4ND8oVC5ib3VuZGFyeT02NCxULnN0b3JhZ2U9NjQpOkEuaXNUZXh0dXJlP2NvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBzYW1wbGVycyBjYW4gbm90IGJlIHBhcnQgb2YgYW4gdW5pZm9ybXMgZ3JvdXAuIik6Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBVbnN1cHBvcnRlZCB1bmlmb3JtIHZhbHVlIHR5cGUuIixBKSxUfWZ1bmN0aW9uIG0oQSl7Y29uc3QgVD1BLnRhcmdldDtULnJlbW92ZUV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLG0pO2NvbnN0IE09YS5pbmRleE9mKFQuX19iaW5kaW5nUG9pbnRJbmRleCk7YS5zcGxpY2UoTSwxKSxpLmRlbGV0ZUJ1ZmZlcihyW1QuaWRdKSxkZWxldGUgcltULmlkXSxkZWxldGUgc1tULmlkXX1mdW5jdGlvbiBkKCl7Zm9yKGNvbnN0IEEgaW4gcilpLmRlbGV0ZUJ1ZmZlcihyW0FdKTthPVtdLHI9e30scz17fX1yZXR1cm57YmluZDpsLHVwZGF0ZTpjLGRpc3Bvc2U6ZH19Y2xhc3MgSHV7Y29uc3RydWN0b3IoZT17fSl7Y29uc3R7Y2FudmFzOnQ9bGEoKSxjb250ZXh0Om49bnVsbCxkZXB0aDpyPSEwLHN0ZW5jaWw6cz0hMSxhbHBoYTphPSExLGFudGlhbGlhczpvPSExLHByZW11bHRpcGxpZWRBbHBoYTpsPSEwLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjpjPSExLHBvd2VyUHJlZmVyZW5jZTp1PSJkZWZhdWx0IixmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0Omg9ITEscmV2ZXJzZURlcHRoQnVmZmVyOmY9ITF9PWU7dGhpcy5pc1dlYkdMUmVuZGVyZXI9ITA7bGV0IHA7aWYobiE9PW51bGwpe2lmKHR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ8InUiJiZuIGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0KXRocm93IG5ldyBFcnJvcigiVEhSRUUuV2ViR0xSZW5kZXJlcjogV2ViR0wgMSBpcyBub3Qgc3VwcG9ydGVkIHNpbmNlIHIxNjMuIik7cD1uLmdldENvbnRleHRBdHRyaWJ1dGVzKCkuYWxwaGF9ZWxzZSBwPWE7Y29uc3QgXz1uZXcgVWludDMyQXJyYXkoNCkseD1uZXcgSW50MzJBcnJheSg0KTtsZXQgbT1udWxsLGQ9bnVsbDtjb25zdCBBPVtdLFQ9W107dGhpcy5kb21FbGVtZW50PXQsdGhpcy5kZWJ1Zz17Y2hlY2tTaGFkZXJFcnJvcnM6ITAsb25TaGFkZXJFcnJvcjpudWxsfSx0aGlzLmF1dG9DbGVhcj0hMCx0aGlzLmF1dG9DbGVhckNvbG9yPSEwLHRoaXMuYXV0b0NsZWFyRGVwdGg9ITAsdGhpcy5hdXRvQ2xlYXJTdGVuY2lsPSEwLHRoaXMuc29ydE9iamVjdHM9ITAsdGhpcy5jbGlwcGluZ1BsYW5lcz1bXSx0aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkPSExLHRoaXMuX291dHB1dENvbG9yU3BhY2U9d3QsdGhpcy50b25lTWFwcGluZz0wLHRoaXMudG9uZU1hcHBpbmdFeHBvc3VyZT0xO2NvbnN0IE09dGhpcztsZXQgRj0hMSxiPTAsdz0wLFU9bnVsbCxFPS0xLFM9bnVsbDtjb25zdCBSPW5ldyBpdCxxPW5ldyBpdDtsZXQgej1udWxsO2NvbnN0IFc9bmV3IFZlKDApO2xldCBLPTAsVj10LndpZHRoLFE9dC5oZWlnaHQsSD0xLGllPW51bGwsY2U9bnVsbDtjb25zdCB4ZT1uZXcgaXQoMCwwLFYsUSksVWU9bmV3IGl0KDAsMCxWLFEpO2xldCBZZT0hMTtjb25zdCBYPW5ldyBKcjtsZXQgZWU9ITEsX2U9ITE7Y29uc3QgcmU9bmV3IHJ0LHllPW5ldyBydCxiZT1uZXcgQixGZT1uZXcgaXQsZXQ9e2JhY2tncm91bmQ6bnVsbCxmb2c6bnVsbCxlbnZpcm9ubWVudDpudWxsLG92ZXJyaWRlTWF0ZXJpYWw6bnVsbCxpc1NjZW5lOiEwfTtsZXQgemU9ITE7ZnVuY3Rpb24gYXQoKXtyZXR1cm4gVT09PW51bGw/SDoxfWxldCBMPW47ZnVuY3Rpb24gUHQodixQKXtyZXR1cm4gdC5nZXRDb250ZXh0KHYsUCl9dHJ5e2NvbnN0IHY9e2FscGhhOiEwLGRlcHRoOnIsc3RlbmNpbDpzLGFudGlhbGlhczpvLHByZW11bHRpcGxpZWRBbHBoYTpsLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjpjLHBvd2VyUHJlZmVyZW5jZTp1LGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6aH07aWYoInNldEF0dHJpYnV0ZSJpbiB0JiZ0LnNldEF0dHJpYnV0ZSgiZGF0YS1lbmdpbmUiLGB0aHJlZS5qcyByJHtOaX1gKSx0LmFkZEV2ZW50TGlzdGVuZXIoIndlYmdsY29udGV4dGxvc3QiLCQsITEpLHQuYWRkRXZlbnRMaXN0ZW5lcigid2ViZ2xjb250ZXh0cmVzdG9yZWQiLGxlLCExKSx0LmFkZEV2ZW50TGlzdGVuZXIoIndlYmdsY29udGV4dGNyZWF0aW9uZXJyb3IiLGFlLCExKSxMPT09bnVsbCl7Y29uc3QgUD0id2ViZ2wyIjtpZihMPVB0KFAsdiksTD09PW51bGwpdGhyb3cgUHQoUCk/bmV3IEVycm9yKCJFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLiIpOm5ldyBFcnJvcigiRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4iKX19Y2F0Y2godil7dGhyb3cgY29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xSZW5kZXJlcjogIit2Lm1lc3NhZ2UpLHZ9bGV0IEllLE5lLFNlLGplLE1lLHksZyxJLFksWixrLGdlLHNlLHVlLEdlLGosaGUsRWUsVGUsZGUsT2UsRGUsWmUsQztmdW5jdGlvbiBuZSgpe0llPW5ldyBxbChMKSxJZS5pbml0KCksRGU9bmV3IER1KEwsSWUpLE5lPW5ldyBHbChMLEllLGUsRGUpLFNlPW5ldyBSdShMLEllKSxOZS5yZXZlcnNlRGVwdGhCdWZmZXImJmYmJlNlLmJ1ZmZlcnMuZGVwdGguc2V0UmV2ZXJzZWQoITApLGplPW5ldyBabChMKSxNZT1uZXcgZnUseT1uZXcgUHUoTCxJZSxTZSxNZSxOZSxEZSxqZSksZz1uZXcgVmwoTSksST1uZXcgWGwoTSksWT1uZXcgSWEoTCksWmU9bmV3IEJsKEwsWSksWj1uZXcgWWwoTCxZLGplLFplKSxrPW5ldyBqbChMLFosWSxqZSksVGU9bmV3IEtsKEwsTmUseSksaj1uZXcgSGwoTWUpLGdlPW5ldyBkdShNLGcsSSxJZSxOZSxaZSxqKSxzZT1uZXcgenUoTSxNZSksdWU9bmV3IG11LEdlPW5ldyBTdShJZSksRWU9bmV3IE9sKE0sZyxJLFNlLGsscCxsKSxoZT1uZXcgYnUoTSxrLE5lKSxDPW5ldyBHdShMLGplLE5lLFNlKSxkZT1uZXcgemwoTCxJZSxqZSksT2U9bmV3ICRsKEwsSWUsamUpLGplLnByb2dyYW1zPWdlLnByb2dyYW1zLE0uY2FwYWJpbGl0aWVzPU5lLE0uZXh0ZW5zaW9ucz1JZSxNLnByb3BlcnRpZXM9TWUsTS5yZW5kZXJMaXN0cz11ZSxNLnNoYWRvd01hcD1oZSxNLnN0YXRlPVNlLE0uaW5mbz1qZX1uZSgpO2NvbnN0IEc9bmV3IE91KE0sTCk7dGhpcy54cj1HLHRoaXMuZ2V0Q29udGV4dD1mdW5jdGlvbigpe3JldHVybiBMfSx0aGlzLmdldENvbnRleHRBdHRyaWJ1dGVzPWZ1bmN0aW9uKCl7cmV0dXJuIEwuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKX0sdGhpcy5mb3JjZUNvbnRleHRMb3NzPWZ1bmN0aW9uKCl7Y29uc3Qgdj1JZS5nZXQoIldFQkdMX2xvc2VfY29udGV4dCIpO3YmJnYubG9zZUNvbnRleHQoKX0sdGhpcy5mb3JjZUNvbnRleHRSZXN0b3JlPWZ1bmN0aW9uKCl7Y29uc3Qgdj1JZS5nZXQoIldFQkdMX2xvc2VfY29udGV4dCIpO3YmJnYucmVzdG9yZUNvbnRleHQoKX0sdGhpcy5nZXRQaXhlbFJhdGlvPWZ1bmN0aW9uKCl7cmV0dXJuIEh9LHRoaXMuc2V0UGl4ZWxSYXRpbz1mdW5jdGlvbih2KXt2IT09dm9pZCAwJiYoSD12LHRoaXMuc2V0U2l6ZShWLFEsITEpKX0sdGhpcy5nZXRTaXplPWZ1bmN0aW9uKHYpe3JldHVybiB2LnNldChWLFEpfSx0aGlzLnNldFNpemU9ZnVuY3Rpb24odixQLE49ITApe2lmKEcuaXNQcmVzZW50aW5nKXtjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IENhbid0IGNoYW5nZSBzaXplIHdoaWxlIFZSIGRldmljZSBpcyBwcmVzZW50aW5nLiIpO3JldHVybn1WPXYsUT1QLHQud2lkdGg9TWF0aC5mbG9vcih2KkgpLHQuaGVpZ2h0PU1hdGguZmxvb3IoUCpIKSxOPT09ITAmJih0LnN0eWxlLndpZHRoPXYrInB4Iix0LnN0eWxlLmhlaWdodD1QKyJweCIpLHRoaXMuc2V0Vmlld3BvcnQoMCwwLHYsUCl9LHRoaXMuZ2V0RHJhd2luZ0J1ZmZlclNpemU9ZnVuY3Rpb24odil7cmV0dXJuIHYuc2V0KFYqSCxRKkgpLmZsb29yKCl9LHRoaXMuc2V0RHJhd2luZ0J1ZmZlclNpemU9ZnVuY3Rpb24odixQLE4pe1Y9dixRPVAsSD1OLHQud2lkdGg9TWF0aC5mbG9vcih2Kk4pLHQuaGVpZ2h0PU1hdGguZmxvb3IoUCpOKSx0aGlzLnNldFZpZXdwb3J0KDAsMCx2LFApfSx0aGlzLmdldEN1cnJlbnRWaWV3cG9ydD1mdW5jdGlvbih2KXtyZXR1cm4gdi5jb3B5KFIpfSx0aGlzLmdldFZpZXdwb3J0PWZ1bmN0aW9uKHYpe3JldHVybiB2LmNvcHkoeGUpfSx0aGlzLnNldFZpZXdwb3J0PWZ1bmN0aW9uKHYsUCxOLE8pe3YuaXNWZWN0b3I0P3hlLnNldCh2Lngsdi55LHYueix2LncpOnhlLnNldCh2LFAsTixPKSxTZS52aWV3cG9ydChSLmNvcHkoeGUpLm11bHRpcGx5U2NhbGFyKEgpLnJvdW5kKCkpfSx0aGlzLmdldFNjaXNzb3I9ZnVuY3Rpb24odil7cmV0dXJuIHYuY29weShVZSl9LHRoaXMuc2V0U2Npc3Nvcj1mdW5jdGlvbih2LFAsTixPKXt2LmlzVmVjdG9yND9VZS5zZXQodi54LHYueSx2Lnosdi53KTpVZS5zZXQodixQLE4sTyksU2Uuc2Npc3NvcihxLmNvcHkoVWUpLm11bHRpcGx5U2NhbGFyKEgpLnJvdW5kKCkpfSx0aGlzLmdldFNjaXNzb3JUZXN0PWZ1bmN0aW9uKCl7cmV0dXJuIFllfSx0aGlzLnNldFNjaXNzb3JUZXN0PWZ1bmN0aW9uKHYpe1NlLnNldFNjaXNzb3JUZXN0KFllPXYpfSx0aGlzLnNldE9wYXF1ZVNvcnQ9ZnVuY3Rpb24odil7aWU9dn0sdGhpcy5zZXRUcmFuc3BhcmVudFNvcnQ9ZnVuY3Rpb24odil7Y2U9dn0sdGhpcy5nZXRDbGVhckNvbG9yPWZ1bmN0aW9uKHYpe3JldHVybiB2LmNvcHkoRWUuZ2V0Q2xlYXJDb2xvcigpKX0sdGhpcy5zZXRDbGVhckNvbG9yPWZ1bmN0aW9uKCl7RWUuc2V0Q2xlYXJDb2xvci5hcHBseShFZSxhcmd1bWVudHMpfSx0aGlzLmdldENsZWFyQWxwaGE9ZnVuY3Rpb24oKXtyZXR1cm4gRWUuZ2V0Q2xlYXJBbHBoYSgpfSx0aGlzLnNldENsZWFyQWxwaGE9ZnVuY3Rpb24oKXtFZS5zZXRDbGVhckFscGhhLmFwcGx5KEVlLGFyZ3VtZW50cyl9LHRoaXMuY2xlYXI9ZnVuY3Rpb24odj0hMCxQPSEwLE49ITApe2xldCBPPTA7aWYodil7bGV0IEQ9ITE7aWYoVSE9PW51bGwpe2NvbnN0IEo9VS50ZXh0dXJlLmZvcm1hdDtEPUo9PT0xMDMzfHxKPT09MTAzMXx8Sj09PTEwMjl9aWYoRCl7Y29uc3QgSj1VLnRleHR1cmUudHlwZSxvZT1KPT09MTAwOXx8Sj09PTEwMTR8fEo9PT0xMDEyfHxKPT09MTAyMHx8Sj09PTEwMTd8fEo9PT0xMDE4LGZlPUVlLmdldENsZWFyQ29sb3IoKSxwZT1FZS5nZXRDbGVhckFscGhhKCksQWU9ZmUucixDZT1mZS5nLG1lPWZlLmI7b2U/KF9bMF09QWUsX1sxXT1DZSxfWzJdPW1lLF9bM109cGUsTC5jbGVhckJ1ZmZlcnVpdihMLkNPTE9SLDAsXykpOih4WzBdPUFlLHhbMV09Q2UseFsyXT1tZSx4WzNdPXBlLEwuY2xlYXJCdWZmZXJpdihMLkNPTE9SLDAseCkpfWVsc2UgT3w9TC5DT0xPUl9CVUZGRVJfQklUfVAmJihPfD1MLkRFUFRIX0JVRkZFUl9CSVQpLE4mJihPfD1MLlNURU5DSUxfQlVGRkVSX0JJVCx0aGlzLnN0YXRlLmJ1ZmZlcnMuc3RlbmNpbC5zZXRNYXNrKDQyOTQ5NjcyOTUpKSxMLmNsZWFyKE8pfSx0aGlzLmNsZWFyQ29sb3I9ZnVuY3Rpb24oKXt0aGlzLmNsZWFyKCEwLCExLCExKX0sdGhpcy5jbGVhckRlcHRoPWZ1bmN0aW9uKCl7dGhpcy5jbGVhcighMSwhMCwhMSl9LHRoaXMuY2xlYXJTdGVuY2lsPWZ1bmN0aW9uKCl7dGhpcy5jbGVhcighMSwhMSwhMCl9LHRoaXMuZGlzcG9zZT1mdW5jdGlvbigpe3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigid2ViZ2xjb250ZXh0bG9zdCIsJCwhMSksdC5yZW1vdmVFdmVudExpc3RlbmVyKCJ3ZWJnbGNvbnRleHRyZXN0b3JlZCIsbGUsITEpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcigid2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvciIsYWUsITEpLHVlLmRpc3Bvc2UoKSxHZS5kaXNwb3NlKCksTWUuZGlzcG9zZSgpLGcuZGlzcG9zZSgpLEkuZGlzcG9zZSgpLGsuZGlzcG9zZSgpLFplLmRpc3Bvc2UoKSxDLmRpc3Bvc2UoKSxnZS5kaXNwb3NlKCksRy5kaXNwb3NlKCksRy5yZW1vdmVFdmVudExpc3RlbmVyKCJzZXNzaW9uc3RhcnQiLEJzKSxHLnJlbW92ZUV2ZW50TGlzdGVuZXIoInNlc3Npb25lbmQiLHpzKSx2bi5zdG9wKCl9O2Z1bmN0aW9uICQodil7di5wcmV2ZW50RGVmYXVsdCgpLGNvbnNvbGUubG9nKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBDb250ZXh0IExvc3QuIiksRj0hMH1mdW5jdGlvbiBsZSgpe2NvbnNvbGUubG9nKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBDb250ZXh0IFJlc3RvcmVkLiIpLEY9ITE7Y29uc3Qgdj1qZS5hdXRvUmVzZXQsUD1oZS5lbmFibGVkLE49aGUuYXV0b1VwZGF0ZSxPPWhlLm5lZWRzVXBkYXRlLEQ9aGUudHlwZTtuZSgpLGplLmF1dG9SZXNldD12LGhlLmVuYWJsZWQ9UCxoZS5hdXRvVXBkYXRlPU4saGUubmVlZHNVcGRhdGU9TyxoZS50eXBlPUR9ZnVuY3Rpb24gYWUodil7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xSZW5kZXJlcjogQSBXZWJHTCBjb250ZXh0IGNvdWxkIG5vdCBiZSBjcmVhdGVkLiBSZWFzb246ICIsdi5zdGF0dXNNZXNzYWdlKX1mdW5jdGlvbiBSZSh2KXtjb25zdCBQPXYudGFyZ2V0O1AucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsUmUpLG50KFApfWZ1bmN0aW9uIG50KHYpe210KHYpLE1lLnJlbW92ZSh2KX1mdW5jdGlvbiBtdCh2KXtjb25zdCBQPU1lLmdldCh2KS5wcm9ncmFtcztQIT09dm9pZCAwJiYoUC5mb3JFYWNoKGZ1bmN0aW9uKE4pe2dlLnJlbGVhc2VQcm9ncmFtKE4pfSksdi5pc1NoYWRlck1hdGVyaWFsJiZnZS5yZWxlYXNlU2hhZGVyQ2FjaGUodikpfXRoaXMucmVuZGVyQnVmZmVyRGlyZWN0PWZ1bmN0aW9uKHYsUCxOLE8sRCxKKXtQPT09bnVsbCYmKFA9ZXQpO2NvbnN0IG9lPUQuaXNNZXNoJiZELm1hdHJpeFdvcmxkLmRldGVybWluYW50KCk8MCxmZT1taCh2LFAsTixPLEQpO1NlLnNldE1hdGVyaWFsKE8sb2UpO2xldCBwZT1OLmluZGV4LEFlPTE7aWYoTy53aXJlZnJhbWU9PT0hMCl7aWYocGU9Wi5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUoTikscGU9PT12b2lkIDApcmV0dXJuO0FlPTJ9Y29uc3QgQ2U9Ti5kcmF3UmFuZ2UsbWU9Ti5hdHRyaWJ1dGVzLnBvc2l0aW9uO2xldCBIZT1DZS5zdGFydCpBZSxLZT0oQ2Uuc3RhcnQrQ2UuY291bnQpKkFlO0ohPT1udWxsJiYoSGU9TWF0aC5tYXgoSGUsSi5zdGFydCpBZSksS2U9TWF0aC5taW4oS2UsKEouc3RhcnQrSi5jb3VudCkqQWUpKSxwZSE9PW51bGw/KEhlPU1hdGgubWF4KEhlLDApLEtlPU1hdGgubWluKEtlLHBlLmNvdW50KSk6bWUhPW51bGwmJihIZT1NYXRoLm1heChIZSwwKSxLZT1NYXRoLm1pbihLZSxtZS5jb3VudCkpO2NvbnN0IEplPUtlLUhlO2lmKEplPDB8fEplPT09MS8wKXJldHVybjtaZS5zZXR1cChELE8sZmUsTixwZSk7bGV0IEV0LGtlPWRlO2lmKHBlIT09bnVsbCYmKEV0PVkuZ2V0KHBlKSxrZT1PZSxrZS5zZXRJbmRleChFdCkpLEQuaXNNZXNoKU8ud2lyZWZyYW1lPT09ITA/KFNlLnNldExpbmVXaWR0aChPLndpcmVmcmFtZUxpbmV3aWR0aCphdCgpKSxrZS5zZXRNb2RlKEwuTElORVMpKTprZS5zZXRNb2RlKEwuVFJJQU5HTEVTKTtlbHNlIGlmKEQuaXNMaW5lKXtsZXQgdmU9Ty5saW5ld2lkdGg7dmU9PT12b2lkIDAmJih2ZT0xKSxTZS5zZXRMaW5lV2lkdGgodmUqYXQoKSksRC5pc0xpbmVTZWdtZW50cz9rZS5zZXRNb2RlKEwuTElORVMpOkQuaXNMaW5lTG9vcD9rZS5zZXRNb2RlKEwuTElORV9MT09QKTprZS5zZXRNb2RlKEwuTElORV9TVFJJUCl9ZWxzZSBELmlzUG9pbnRzP2tlLnNldE1vZGUoTC5QT0lOVFMpOkQuaXNTcHJpdGUmJmtlLnNldE1vZGUoTC5UUklBTkdMRVMpO2lmKEQuaXNCYXRjaGVkTWVzaClpZihELl9tdWx0aURyYXdJbnN0YW5jZXMhPT1udWxsKWtlLnJlbmRlck11bHRpRHJhd0luc3RhbmNlcyhELl9tdWx0aURyYXdTdGFydHMsRC5fbXVsdGlEcmF3Q291bnRzLEQuX211bHRpRHJhd0NvdW50LEQuX211bHRpRHJhd0luc3RhbmNlcyk7ZWxzZSBpZihJZS5nZXQoIldFQkdMX211bHRpX2RyYXciKSlrZS5yZW5kZXJNdWx0aURyYXcoRC5fbXVsdGlEcmF3U3RhcnRzLEQuX211bHRpRHJhd0NvdW50cyxELl9tdWx0aURyYXdDb3VudCk7ZWxzZXtjb25zdCB2ZT1ELl9tdWx0aURyYXdTdGFydHMsS3Q9RC5fbXVsdGlEcmF3Q291bnRzLFdlPUQuX211bHRpRHJhd0NvdW50LEJ0PXBlP1kuZ2V0KHBlKS5ieXRlc1BlckVsZW1lbnQ6MSxHbj1NZS5nZXQoTykuY3VycmVudFByb2dyYW0uZ2V0VW5pZm9ybXMoKTtmb3IobGV0IGJ0PTA7YnQ8V2U7YnQrKylHbi5zZXRWYWx1ZShMLCJfZ2xfRHJhd0lEIixidCksa2UucmVuZGVyKHZlW2J0XS9CdCxLdFtidF0pfWVsc2UgaWYoRC5pc0luc3RhbmNlZE1lc2gpa2UucmVuZGVySW5zdGFuY2VzKEhlLEplLEQuY291bnQpO2Vsc2UgaWYoTi5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KXtjb25zdCB2ZT1OLl9tYXhJbnN0YW5jZUNvdW50IT09dm9pZCAwP04uX21heEluc3RhbmNlQ291bnQ6MS8wLEt0PU1hdGgubWluKE4uaW5zdGFuY2VDb3VudCx2ZSk7a2UucmVuZGVySW5zdGFuY2VzKEhlLEplLEt0KX1lbHNlIGtlLnJlbmRlcihIZSxKZSl9O2Z1bmN0aW9uIFhlKHYsUCxOKXt2LnRyYW5zcGFyZW50PT09ITAmJnYuc2lkZT09PTImJnYuZm9yY2VTaW5nbGVQYXNzPT09ITE/KHYuc2lkZT0xLHYubmVlZHNVcGRhdGU9ITAsSWkodixQLE4pLHYuc2lkZT0wLHYubmVlZHNVcGRhdGU9ITAsSWkodixQLE4pLHYuc2lkZT0yKTpJaSh2LFAsTil9dGhpcy5jb21waWxlPWZ1bmN0aW9uKHYsUCxOPW51bGwpe049PT1udWxsJiYoTj12KSxkPUdlLmdldChOKSxkLmluaXQoUCksVC5wdXNoKGQpLE4udHJhdmVyc2VWaXNpYmxlKGZ1bmN0aW9uKEQpe0QuaXNMaWdodCYmRC5sYXllcnMudGVzdChQLmxheWVycykmJihkLnB1c2hMaWdodChEKSxELmNhc3RTaGFkb3cmJmQucHVzaFNoYWRvdyhEKSl9KSx2IT09TiYmdi50cmF2ZXJzZVZpc2libGUoZnVuY3Rpb24oRCl7RC5pc0xpZ2h0JiZELmxheWVycy50ZXN0KFAubGF5ZXJzKSYmKGQucHVzaExpZ2h0KEQpLEQuY2FzdFNoYWRvdyYmZC5wdXNoU2hhZG93KEQpKX0pLGQuc2V0dXBMaWdodHMoKTtjb25zdCBPPW5ldyBTZXQ7cmV0dXJuIHYudHJhdmVyc2UoZnVuY3Rpb24oRCl7aWYoIShELmlzTWVzaHx8RC5pc1BvaW50c3x8RC5pc0xpbmV8fEQuaXNTcHJpdGUpKXJldHVybjtjb25zdCBKPUQubWF0ZXJpYWw7aWYoSilpZihBcnJheS5pc0FycmF5KEopKWZvcihsZXQgb2U9MDtvZTxKLmxlbmd0aDtvZSsrKXtjb25zdCBmZT1KW29lXTtYZShmZSxOLEQpLE8uYWRkKGZlKX1lbHNlIFhlKEosTixEKSxPLmFkZChKKX0pLFQucG9wKCksZD1udWxsLE99LHRoaXMuY29tcGlsZUFzeW5jPWZ1bmN0aW9uKHYsUCxOPW51bGwpe2NvbnN0IE89dGhpcy5jb21waWxlKHYsUCxOKTtyZXR1cm4gbmV3IFByb21pc2UoRD0+e2Z1bmN0aW9uIEooKXtpZihPLmZvckVhY2goZnVuY3Rpb24ob2Upe01lLmdldChvZSkuY3VycmVudFByb2dyYW0uaXNSZWFkeSgpJiZPLmRlbGV0ZShvZSl9KSxPLnNpemU9PT0wKXtEKHYpO3JldHVybn1zZXRUaW1lb3V0KEosMTApfUllLmdldCgiS0hSX3BhcmFsbGVsX3NoYWRlcl9jb21waWxlIikhPT1udWxsP0ooKTpzZXRUaW1lb3V0KEosMTApfSl9O2xldCBPdD1udWxsO2Z1bmN0aW9uIFp0KHYpe090JiZPdCh2KX1mdW5jdGlvbiBCcygpe3ZuLnN0b3AoKX1mdW5jdGlvbiB6cygpe3ZuLnN0YXJ0KCl9Y29uc3Qgdm49bmV3IFFyO3ZuLnNldEFuaW1hdGlvbkxvb3AoWnQpLHR5cGVvZiBzZWxmPCJ1IiYmdm4uc2V0Q29udGV4dChzZWxmKSx0aGlzLnNldEFuaW1hdGlvbkxvb3A9ZnVuY3Rpb24odil7T3Q9dixHLnNldEFuaW1hdGlvbkxvb3Aodiksdj09PW51bGw/dm4uc3RvcCgpOnZuLnN0YXJ0KCl9LEcuYWRkRXZlbnRMaXN0ZW5lcigic2Vzc2lvbnN0YXJ0IixCcyksRy5hZGRFdmVudExpc3RlbmVyKCJzZXNzaW9uZW5kIix6cyksdGhpcy5yZW5kZXI9ZnVuY3Rpb24odixQKXtpZihQIT09dm9pZCAwJiZQLmlzQ2FtZXJhIT09ITApe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXIucmVuZGVyOiBjYW1lcmEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkNhbWVyYS4iKTtyZXR1cm59aWYoRj09PSEwKXJldHVybjtpZih2Lm1hdHJpeFdvcmxkQXV0b1VwZGF0ZT09PSEwJiZ2LnVwZGF0ZU1hdHJpeFdvcmxkKCksUC5wYXJlbnQ9PT1udWxsJiZQLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZT09PSEwJiZQLnVwZGF0ZU1hdHJpeFdvcmxkKCksRy5lbmFibGVkPT09ITAmJkcuaXNQcmVzZW50aW5nPT09ITAmJihHLmNhbWVyYUF1dG9VcGRhdGU9PT0hMCYmRy51cGRhdGVDYW1lcmEoUCksUD1HLmdldENhbWVyYSgpKSx2LmlzU2NlbmU9PT0hMCYmdi5vbkJlZm9yZVJlbmRlcihNLHYsUCxVKSxkPUdlLmdldCh2LFQubGVuZ3RoKSxkLmluaXQoUCksVC5wdXNoKGQpLHllLm11bHRpcGx5TWF0cmljZXMoUC5wcm9qZWN0aW9uTWF0cml4LFAubWF0cml4V29ybGRJbnZlcnNlKSxYLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KHllKSxfZT10aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkLGVlPWouaW5pdCh0aGlzLmNsaXBwaW5nUGxhbmVzLF9lKSxtPXVlLmdldCh2LEEubGVuZ3RoKSxtLmluaXQoKSxBLnB1c2gobSksRy5lbmFibGVkPT09ITAmJkcuaXNQcmVzZW50aW5nPT09ITApe2NvbnN0IEo9TS54ci5nZXREZXB0aFNlbnNpbmdNZXNoKCk7SiE9PW51bGwmJnZyKEosUCwtMS8wLE0uc29ydE9iamVjdHMpfXZyKHYsUCwwLE0uc29ydE9iamVjdHMpLG0uZmluaXNoKCksTS5zb3J0T2JqZWN0cz09PSEwJiZtLnNvcnQoaWUsY2UpLHplPUcuZW5hYmxlZD09PSExfHxHLmlzUHJlc2VudGluZz09PSExfHxHLmhhc0RlcHRoU2Vuc2luZygpPT09ITEsemUmJkVlLmFkZFRvUmVuZGVyTGlzdChtLHYpLHRoaXMuaW5mby5yZW5kZXIuZnJhbWUrKyxlZT09PSEwJiZqLmJlZ2luU2hhZG93cygpO2NvbnN0IE49ZC5zdGF0ZS5zaGFkb3dzQXJyYXk7aGUucmVuZGVyKE4sdixQKSxlZT09PSEwJiZqLmVuZFNoYWRvd3MoKSx0aGlzLmluZm8uYXV0b1Jlc2V0PT09ITAmJnRoaXMuaW5mby5yZXNldCgpO2NvbnN0IE89bS5vcGFxdWUsRD1tLnRyYW5zbWlzc2l2ZTtpZihkLnNldHVwTGlnaHRzKCksUC5pc0FycmF5Q2FtZXJhKXtjb25zdCBKPVAuY2FtZXJhcztpZihELmxlbmd0aD4wKWZvcihsZXQgb2U9MCxmZT1KLmxlbmd0aDtvZTxmZTtvZSsrKXtjb25zdCBwZT1KW29lXTtIcyhPLEQsdixwZSl9emUmJkVlLnJlbmRlcih2KTtmb3IobGV0IG9lPTAsZmU9Si5sZW5ndGg7b2U8ZmU7b2UrKyl7Y29uc3QgcGU9SltvZV07R3MobSx2LHBlLHBlLnZpZXdwb3J0KX19ZWxzZSBELmxlbmd0aD4wJiZIcyhPLEQsdixQKSx6ZSYmRWUucmVuZGVyKHYpLEdzKG0sdixQKTtVIT09bnVsbCYmKHkudXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQoVSkseS51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoVSkpLHYuaXNTY2VuZT09PSEwJiZ2Lm9uQWZ0ZXJSZW5kZXIoTSx2LFApLFplLnJlc2V0RGVmYXVsdFN0YXRlKCksRT0tMSxTPW51bGwsVC5wb3AoKSxULmxlbmd0aD4wPyhkPVRbVC5sZW5ndGgtMV0sZWU9PT0hMCYmai5zZXRHbG9iYWxTdGF0ZShNLmNsaXBwaW5nUGxhbmVzLGQuc3RhdGUuY2FtZXJhKSk6ZD1udWxsLEEucG9wKCksQS5sZW5ndGg+MD9tPUFbQS5sZW5ndGgtMV06bT1udWxsfTtmdW5jdGlvbiB2cih2LFAsTixPKXtpZih2LnZpc2libGU9PT0hMSlyZXR1cm47aWYodi5sYXllcnMudGVzdChQLmxheWVycykpe2lmKHYuaXNHcm91cClOPXYucmVuZGVyT3JkZXI7ZWxzZSBpZih2LmlzTE9EKXYuYXV0b1VwZGF0ZT09PSEwJiZ2LnVwZGF0ZShQKTtlbHNlIGlmKHYuaXNMaWdodClkLnB1c2hMaWdodCh2KSx2LmNhc3RTaGFkb3cmJmQucHVzaFNoYWRvdyh2KTtlbHNlIGlmKHYuaXNTcHJpdGUpe2lmKCF2LmZydXN0dW1DdWxsZWR8fFguaW50ZXJzZWN0c1Nwcml0ZSh2KSl7TyYmRmUuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHYubWF0cml4V29ybGQpLmFwcGx5TWF0cml4NCh5ZSk7Y29uc3Qgb2U9ay51cGRhdGUodiksZmU9di5tYXRlcmlhbDtmZS52aXNpYmxlJiZtLnB1c2godixvZSxmZSxOLEZlLnosbnVsbCl9fWVsc2UgaWYoKHYuaXNNZXNofHx2LmlzTGluZXx8di5pc1BvaW50cykmJighdi5mcnVzdHVtQ3VsbGVkfHxYLmludGVyc2VjdHNPYmplY3QodikpKXtjb25zdCBvZT1rLnVwZGF0ZSh2KSxmZT12Lm1hdGVyaWFsO2lmKE8mJih2LmJvdW5kaW5nU3BoZXJlIT09dm9pZCAwPyh2LmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmdi5jb21wdXRlQm91bmRpbmdTcGhlcmUoKSxGZS5jb3B5KHYuYm91bmRpbmdTcGhlcmUuY2VudGVyKSk6KG9lLmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmb2UuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksRmUuY29weShvZS5ib3VuZGluZ1NwaGVyZS5jZW50ZXIpKSxGZS5hcHBseU1hdHJpeDQodi5tYXRyaXhXb3JsZCkuYXBwbHlNYXRyaXg0KHllKSksQXJyYXkuaXNBcnJheShmZSkpe2NvbnN0IHBlPW9lLmdyb3Vwcztmb3IobGV0IEFlPTAsQ2U9cGUubGVuZ3RoO0FlPENlO0FlKyspe2NvbnN0IG1lPXBlW0FlXSxIZT1mZVttZS5tYXRlcmlhbEluZGV4XTtIZSYmSGUudmlzaWJsZSYmbS5wdXNoKHYsb2UsSGUsTixGZS56LG1lKX19ZWxzZSBmZS52aXNpYmxlJiZtLnB1c2godixvZSxmZSxOLEZlLnosbnVsbCl9fWNvbnN0IEo9di5jaGlsZHJlbjtmb3IobGV0IG9lPTAsZmU9Si5sZW5ndGg7b2U8ZmU7b2UrKyl2cihKW29lXSxQLE4sTyl9ZnVuY3Rpb24gR3ModixQLE4sTyl7Y29uc3QgRD12Lm9wYXF1ZSxKPXYudHJhbnNtaXNzaXZlLG9lPXYudHJhbnNwYXJlbnQ7ZC5zZXR1cExpZ2h0c1ZpZXcoTiksZWU9PT0hMCYmai5zZXRHbG9iYWxTdGF0ZShNLmNsaXBwaW5nUGxhbmVzLE4pLE8mJlNlLnZpZXdwb3J0KFIuY29weShPKSksRC5sZW5ndGg+MCYmRmkoRCxQLE4pLEoubGVuZ3RoPjAmJkZpKEosUCxOKSxvZS5sZW5ndGg+MCYmRmkob2UsUCxOKSxTZS5idWZmZXJzLmRlcHRoLnNldFRlc3QoITApLFNlLmJ1ZmZlcnMuZGVwdGguc2V0TWFzayghMCksU2UuYnVmZmVycy5jb2xvci5zZXRNYXNrKCEwKSxTZS5zZXRQb2x5Z29uT2Zmc2V0KCExKX1mdW5jdGlvbiBIcyh2LFAsTixPKXtpZigoTi5pc1NjZW5lPT09ITA/Ti5vdmVycmlkZU1hdGVyaWFsOm51bGwpIT09bnVsbClyZXR1cm47ZC5zdGF0ZS50cmFuc21pc3Npb25SZW5kZXJUYXJnZXRbTy5pZF09PT12b2lkIDAmJihkLnN0YXRlLnRyYW5zbWlzc2lvblJlbmRlclRhcmdldFtPLmlkXT1uZXcgSnQoMSwxLHtnZW5lcmF0ZU1pcG1hcHM6ITAsdHlwZTpJZS5oYXMoIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCIpfHxJZS5oYXMoIkVYVF9jb2xvcl9idWZmZXJfZmxvYXQiKT8xMDE2OjEwMDksbWluRmlsdGVyOjEwMDgsc2FtcGxlczo0LHN0ZW5jaWxCdWZmZXI6cyxyZXNvbHZlRGVwdGhCdWZmZXI6ITEscmVzb2x2ZVN0ZW5jaWxCdWZmZXI6ITEsY29sb3JTcGFjZTpCZS53b3JraW5nQ29sb3JTcGFjZX0pKTtjb25zdCBKPWQuc3RhdGUudHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0W08uaWRdLG9lPU8udmlld3BvcnR8fFI7Si5zZXRTaXplKG9lLnosb2Uudyk7Y29uc3QgZmU9TS5nZXRSZW5kZXJUYXJnZXQoKTtNLnNldFJlbmRlclRhcmdldChKKSxNLmdldENsZWFyQ29sb3IoVyksSz1NLmdldENsZWFyQWxwaGEoKSxLPDEmJk0uc2V0Q2xlYXJDb2xvcigxNjc3NzIxNSwuNSksTS5jbGVhcigpLHplJiZFZS5yZW5kZXIoTik7Y29uc3QgcGU9TS50b25lTWFwcGluZztNLnRvbmVNYXBwaW5nPTA7Y29uc3QgQWU9Ty52aWV3cG9ydDtpZihPLnZpZXdwb3J0IT09dm9pZCAwJiYoTy52aWV3cG9ydD12b2lkIDApLGQuc2V0dXBMaWdodHNWaWV3KE8pLGVlPT09ITAmJmouc2V0R2xvYmFsU3RhdGUoTS5jbGlwcGluZ1BsYW5lcyxPKSxGaSh2LE4sTykseS51cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldChKKSx5LnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcChKKSxJZS5oYXMoIldFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZSIpPT09ITEpe2xldCBDZT0hMTtmb3IobGV0IG1lPTAsSGU9UC5sZW5ndGg7bWU8SGU7bWUrKyl7Y29uc3QgS2U9UFttZV0sSmU9S2Uub2JqZWN0LEV0PUtlLmdlb21ldHJ5LGtlPUtlLm1hdGVyaWFsLHZlPUtlLmdyb3VwO2lmKGtlLnNpZGU9PT0yJiZKZS5sYXllcnMudGVzdChPLmxheWVycykpe2NvbnN0IEt0PWtlLnNpZGU7a2Uuc2lkZT0xLGtlLm5lZWRzVXBkYXRlPSEwLFZzKEplLE4sTyxFdCxrZSx2ZSksa2Uuc2lkZT1LdCxrZS5uZWVkc1VwZGF0ZT0hMCxDZT0hMH19Q2U9PT0hMCYmKHkudXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQoSikseS51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoSikpfU0uc2V0UmVuZGVyVGFyZ2V0KGZlKSxNLnNldENsZWFyQ29sb3IoVyxLKSxBZSE9PXZvaWQgMCYmKE8udmlld3BvcnQ9QWUpLE0udG9uZU1hcHBpbmc9cGV9ZnVuY3Rpb24gRmkodixQLE4pe2NvbnN0IE89UC5pc1NjZW5lPT09ITA/UC5vdmVycmlkZU1hdGVyaWFsOm51bGw7Zm9yKGxldCBEPTAsSj12Lmxlbmd0aDtEPEo7RCsrKXtjb25zdCBvZT12W0RdLGZlPW9lLm9iamVjdCxwZT1vZS5nZW9tZXRyeSxBZT1PPT09bnVsbD9vZS5tYXRlcmlhbDpPLENlPW9lLmdyb3VwO2ZlLmxheWVycy50ZXN0KE4ubGF5ZXJzKSYmVnMoZmUsUCxOLHBlLEFlLENlKX19ZnVuY3Rpb24gVnModixQLE4sTyxELEope3Yub25CZWZvcmVSZW5kZXIoTSxQLE4sTyxELEopLHYubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoTi5tYXRyaXhXb3JsZEludmVyc2Usdi5tYXRyaXhXb3JsZCksdi5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KHYubW9kZWxWaWV3TWF0cml4KSxELm9uQmVmb3JlUmVuZGVyKE0sUCxOLE8sdixKKSxELnRyYW5zcGFyZW50PT09ITAmJkQuc2lkZT09PTImJkQuZm9yY2VTaW5nbGVQYXNzPT09ITE/KEQuc2lkZT0xLEQubmVlZHNVcGRhdGU9ITAsTS5yZW5kZXJCdWZmZXJEaXJlY3QoTixQLE8sRCx2LEopLEQuc2lkZT0wLEQubmVlZHNVcGRhdGU9ITAsTS5yZW5kZXJCdWZmZXJEaXJlY3QoTixQLE8sRCx2LEopLEQuc2lkZT0yKTpNLnJlbmRlckJ1ZmZlckRpcmVjdChOLFAsTyxELHYsSiksdi5vbkFmdGVyUmVuZGVyKE0sUCxOLE8sRCxKKX1mdW5jdGlvbiBJaSh2LFAsTil7UC5pc1NjZW5lIT09ITAmJihQPWV0KTtjb25zdCBPPU1lLmdldCh2KSxEPWQuc3RhdGUubGlnaHRzLEo9ZC5zdGF0ZS5zaGFkb3dzQXJyYXksb2U9RC5zdGF0ZS52ZXJzaW9uLGZlPWdlLmdldFBhcmFtZXRlcnModixELnN0YXRlLEosUCxOKSxwZT1nZS5nZXRQcm9ncmFtQ2FjaGVLZXkoZmUpO2xldCBBZT1PLnByb2dyYW1zO08uZW52aXJvbm1lbnQ9di5pc01lc2hTdGFuZGFyZE1hdGVyaWFsP1AuZW52aXJvbm1lbnQ6bnVsbCxPLmZvZz1QLmZvZyxPLmVudk1hcD0odi5pc01lc2hTdGFuZGFyZE1hdGVyaWFsP0k6ZykuZ2V0KHYuZW52TWFwfHxPLmVudmlyb25tZW50KSxPLmVudk1hcFJvdGF0aW9uPU8uZW52aXJvbm1lbnQhPT1udWxsJiZ2LmVudk1hcD09PW51bGw/UC5lbnZpcm9ubWVudFJvdGF0aW9uOnYuZW52TWFwUm90YXRpb24sQWU9PT12b2lkIDAmJih2LmFkZEV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLFJlKSxBZT1uZXcgTWFwLE8ucHJvZ3JhbXM9QWUpO2xldCBDZT1BZS5nZXQocGUpO2lmKENlIT09dm9pZCAwKXtpZihPLmN1cnJlbnRQcm9ncmFtPT09Q2UmJk8ubGlnaHRzU3RhdGVWZXJzaW9uPT09b2UpcmV0dXJuIFdzKHYsZmUpLENlfWVsc2UgZmUudW5pZm9ybXM9Z2UuZ2V0VW5pZm9ybXModiksdi5vbkJlZm9yZUNvbXBpbGUoZmUsTSksQ2U9Z2UuYWNxdWlyZVByb2dyYW0oZmUscGUpLEFlLnNldChwZSxDZSksTy51bmlmb3Jtcz1mZS51bmlmb3Jtcztjb25zdCBtZT1PLnVuaWZvcm1zO3JldHVybighdi5pc1NoYWRlck1hdGVyaWFsJiYhdi5pc1Jhd1NoYWRlck1hdGVyaWFsfHx2LmNsaXBwaW5nPT09ITApJiYobWUuY2xpcHBpbmdQbGFuZXM9ai51bmlmb3JtKSxXcyh2LGZlKSxPLm5lZWRzTGlnaHRzPWdoKHYpLE8ubGlnaHRzU3RhdGVWZXJzaW9uPW9lLE8ubmVlZHNMaWdodHMmJihtZS5hbWJpZW50TGlnaHRDb2xvci52YWx1ZT1ELnN0YXRlLmFtYmllbnQsbWUubGlnaHRQcm9iZS52YWx1ZT1ELnN0YXRlLnByb2JlLG1lLmRpcmVjdGlvbmFsTGlnaHRzLnZhbHVlPUQuc3RhdGUuZGlyZWN0aW9uYWwsbWUuZGlyZWN0aW9uYWxMaWdodFNoYWRvd3MudmFsdWU9RC5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvdyxtZS5zcG90TGlnaHRzLnZhbHVlPUQuc3RhdGUuc3BvdCxtZS5zcG90TGlnaHRTaGFkb3dzLnZhbHVlPUQuc3RhdGUuc3BvdFNoYWRvdyxtZS5yZWN0QXJlYUxpZ2h0cy52YWx1ZT1ELnN0YXRlLnJlY3RBcmVhLG1lLmx0Y18xLnZhbHVlPUQuc3RhdGUucmVjdEFyZWFMVEMxLG1lLmx0Y18yLnZhbHVlPUQuc3RhdGUucmVjdEFyZWFMVEMyLG1lLnBvaW50TGlnaHRzLnZhbHVlPUQuc3RhdGUucG9pbnQsbWUucG9pbnRMaWdodFNoYWRvd3MudmFsdWU9RC5zdGF0ZS5wb2ludFNoYWRvdyxtZS5oZW1pc3BoZXJlTGlnaHRzLnZhbHVlPUQuc3RhdGUuaGVtaSxtZS5kaXJlY3Rpb25hbFNoYWRvd01hcC52YWx1ZT1ELnN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWFwLG1lLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4LnZhbHVlPUQuc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXgsbWUuc3BvdFNoYWRvd01hcC52YWx1ZT1ELnN0YXRlLnNwb3RTaGFkb3dNYXAsbWUuc3BvdExpZ2h0TWF0cml4LnZhbHVlPUQuc3RhdGUuc3BvdExpZ2h0TWF0cml4LG1lLnNwb3RMaWdodE1hcC52YWx1ZT1ELnN0YXRlLnNwb3RMaWdodE1hcCxtZS5wb2ludFNoYWRvd01hcC52YWx1ZT1ELnN0YXRlLnBvaW50U2hhZG93TWFwLG1lLnBvaW50U2hhZG93TWF0cml4LnZhbHVlPUQuc3RhdGUucG9pbnRTaGFkb3dNYXRyaXgpLE8uY3VycmVudFByb2dyYW09Q2UsTy51bmlmb3Jtc0xpc3Q9bnVsbCxDZX1mdW5jdGlvbiBrcyh2KXtpZih2LnVuaWZvcm1zTGlzdD09PW51bGwpe2NvbnN0IFA9di5jdXJyZW50UHJvZ3JhbS5nZXRVbmlmb3JtcygpO3YudW5pZm9ybXNMaXN0PWJpLnNlcVdpdGhWYWx1ZShQLnNlcSx2LnVuaWZvcm1zKX1yZXR1cm4gdi51bmlmb3Jtc0xpc3R9ZnVuY3Rpb24gV3ModixQKXtjb25zdCBOPU1lLmdldCh2KTtOLm91dHB1dENvbG9yU3BhY2U9UC5vdXRwdXRDb2xvclNwYWNlLE4uYmF0Y2hpbmc9UC5iYXRjaGluZyxOLmJhdGNoaW5nQ29sb3I9UC5iYXRjaGluZ0NvbG9yLE4uaW5zdGFuY2luZz1QLmluc3RhbmNpbmcsTi5pbnN0YW5jaW5nQ29sb3I9UC5pbnN0YW5jaW5nQ29sb3IsTi5pbnN0YW5jaW5nTW9ycGg9UC5pbnN0YW5jaW5nTW9ycGgsTi5za2lubmluZz1QLnNraW5uaW5nLE4ubW9ycGhUYXJnZXRzPVAubW9ycGhUYXJnZXRzLE4ubW9ycGhOb3JtYWxzPVAubW9ycGhOb3JtYWxzLE4ubW9ycGhDb2xvcnM9UC5tb3JwaENvbG9ycyxOLm1vcnBoVGFyZ2V0c0NvdW50PVAubW9ycGhUYXJnZXRzQ291bnQsTi5udW1DbGlwcGluZ1BsYW5lcz1QLm51bUNsaXBwaW5nUGxhbmVzLE4ubnVtSW50ZXJzZWN0aW9uPVAubnVtQ2xpcEludGVyc2VjdGlvbixOLnZlcnRleEFscGhhcz1QLnZlcnRleEFscGhhcyxOLnZlcnRleFRhbmdlbnRzPVAudmVydGV4VGFuZ2VudHMsTi50b25lTWFwcGluZz1QLnRvbmVNYXBwaW5nfWZ1bmN0aW9uIG1oKHYsUCxOLE8sRCl7UC5pc1NjZW5lIT09ITAmJihQPWV0KSx5LnJlc2V0VGV4dHVyZVVuaXRzKCk7Y29uc3QgSj1QLmZvZyxvZT1PLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWw/UC5lbnZpcm9ubWVudDpudWxsLGZlPVU9PT1udWxsP00ub3V0cHV0Q29sb3JTcGFjZTpVLmlzWFJSZW5kZXJUYXJnZXQ9PT0hMD9VLnRleHR1cmUuY29sb3JTcGFjZTp4bixwZT0oTy5pc01lc2hTdGFuZGFyZE1hdGVyaWFsP0k6ZykuZ2V0KE8uZW52TWFwfHxvZSksQWU9Ty52ZXJ0ZXhDb2xvcnM9PT0hMCYmISFOLmF0dHJpYnV0ZXMuY29sb3ImJk4uYXR0cmlidXRlcy5jb2xvci5pdGVtU2l6ZT09PTQsQ2U9ISFOLmF0dHJpYnV0ZXMudGFuZ2VudCYmKCEhTy5ub3JtYWxNYXB8fE8uYW5pc290cm9weT4wKSxtZT0hIU4ubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLEhlPSEhTi5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsLEtlPSEhTi5tb3JwaEF0dHJpYnV0ZXMuY29sb3I7bGV0IEplPTA7Ty50b25lTWFwcGVkJiYoVT09PW51bGx8fFUuaXNYUlJlbmRlclRhcmdldD09PSEwKSYmKEplPU0udG9uZU1hcHBpbmcpO2NvbnN0IEV0PU4ubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9ufHxOLm1vcnBoQXR0cmlidXRlcy5ub3JtYWx8fE4ubW9ycGhBdHRyaWJ1dGVzLmNvbG9yLGtlPUV0IT09dm9pZCAwP0V0Lmxlbmd0aDowLHZlPU1lLmdldChPKSxLdD1kLnN0YXRlLmxpZ2h0cztpZihlZT09PSEwJiYoX2U9PT0hMHx8diE9PVMpKXtjb25zdCBEdD12PT09UyYmTy5pZD09PUU7ai5zZXRTdGF0ZShPLHYsRHQpfWxldCBXZT0hMTtPLnZlcnNpb249PT12ZS5fX3ZlcnNpb24/KHZlLm5lZWRzTGlnaHRzJiZ2ZS5saWdodHNTdGF0ZVZlcnNpb24hPT1LdC5zdGF0ZS52ZXJzaW9ufHx2ZS5vdXRwdXRDb2xvclNwYWNlIT09ZmV8fEQuaXNCYXRjaGVkTWVzaCYmdmUuYmF0Y2hpbmc9PT0hMXx8IUQuaXNCYXRjaGVkTWVzaCYmdmUuYmF0Y2hpbmc9PT0hMHx8RC5pc0JhdGNoZWRNZXNoJiZ2ZS5iYXRjaGluZ0NvbG9yPT09ITAmJkQuY29sb3JUZXh0dXJlPT09bnVsbHx8RC5pc0JhdGNoZWRNZXNoJiZ2ZS5iYXRjaGluZ0NvbG9yPT09ITEmJkQuY29sb3JUZXh0dXJlIT09bnVsbHx8RC5pc0luc3RhbmNlZE1lc2gmJnZlLmluc3RhbmNpbmc9PT0hMXx8IUQuaXNJbnN0YW5jZWRNZXNoJiZ2ZS5pbnN0YW5jaW5nPT09ITB8fEQuaXNTa2lubmVkTWVzaCYmdmUuc2tpbm5pbmc9PT0hMXx8IUQuaXNTa2lubmVkTWVzaCYmdmUuc2tpbm5pbmc9PT0hMHx8RC5pc0luc3RhbmNlZE1lc2gmJnZlLmluc3RhbmNpbmdDb2xvcj09PSEwJiZELmluc3RhbmNlQ29sb3I9PT1udWxsfHxELmlzSW5zdGFuY2VkTWVzaCYmdmUuaW5zdGFuY2luZ0NvbG9yPT09ITEmJkQuaW5zdGFuY2VDb2xvciE9PW51bGx8fEQuaXNJbnN0YW5jZWRNZXNoJiZ2ZS5pbnN0YW5jaW5nTW9ycGg9PT0hMCYmRC5tb3JwaFRleHR1cmU9PT1udWxsfHxELmlzSW5zdGFuY2VkTWVzaCYmdmUuaW5zdGFuY2luZ01vcnBoPT09ITEmJkQubW9ycGhUZXh0dXJlIT09bnVsbHx8dmUuZW52TWFwIT09cGV8fE8uZm9nPT09ITAmJnZlLmZvZyE9PUp8fHZlLm51bUNsaXBwaW5nUGxhbmVzIT09dm9pZCAwJiYodmUubnVtQ2xpcHBpbmdQbGFuZXMhPT1qLm51bVBsYW5lc3x8dmUubnVtSW50ZXJzZWN0aW9uIT09ai5udW1JbnRlcnNlY3Rpb24pfHx2ZS52ZXJ0ZXhBbHBoYXMhPT1BZXx8dmUudmVydGV4VGFuZ2VudHMhPT1DZXx8dmUubW9ycGhUYXJnZXRzIT09bWV8fHZlLm1vcnBoTm9ybWFscyE9PUhlfHx2ZS5tb3JwaENvbG9ycyE9PUtlfHx2ZS50b25lTWFwcGluZyE9PUplfHx2ZS5tb3JwaFRhcmdldHNDb3VudCE9PWtlKSYmKFdlPSEwKTooV2U9ITAsdmUuX192ZXJzaW9uPU8udmVyc2lvbik7bGV0IEJ0PXZlLmN1cnJlbnRQcm9ncmFtO1dlPT09ITAmJihCdD1JaShPLFAsRCkpO2xldCBHbj0hMSxidD0hMSx0aT0hMTtjb25zdCBRZT1CdC5nZXRVbmlmb3JtcygpLEh0PXZlLnVuaWZvcm1zO2lmKFNlLnVzZVByb2dyYW0oQnQucHJvZ3JhbSkmJihHbj0hMCxidD0hMCx0aT0hMCksTy5pZCE9PUUmJihFPU8uaWQsYnQ9ITApLEdufHxTIT09dil7U2UuYnVmZmVycy5kZXB0aC5nZXRSZXZlcnNlZCgpPyhyZS5jb3B5KHYucHJvamVjdGlvbk1hdHJpeCksdWEocmUpLGhhKHJlKSxRZS5zZXRWYWx1ZShMLCJwcm9qZWN0aW9uTWF0cml4IixyZSkpOlFlLnNldFZhbHVlKEwsInByb2plY3Rpb25NYXRyaXgiLHYucHJvamVjdGlvbk1hdHJpeCksUWUuc2V0VmFsdWUoTCwidmlld01hdHJpeCIsdi5tYXRyaXhXb3JsZEludmVyc2UpO2NvbnN0IGFuPVFlLm1hcC5jYW1lcmFQb3NpdGlvbjthbiE9PXZvaWQgMCYmYW4uc2V0VmFsdWUoTCxiZS5zZXRGcm9tTWF0cml4UG9zaXRpb24odi5tYXRyaXhXb3JsZCkpLE5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXImJlFlLnNldFZhbHVlKEwsImxvZ0RlcHRoQnVmRkMiLDIvKE1hdGgubG9nKHYuZmFyKzEpL01hdGguTE4yKSksKE8uaXNNZXNoUGhvbmdNYXRlcmlhbHx8Ty5pc01lc2hUb29uTWF0ZXJpYWx8fE8uaXNNZXNoTGFtYmVydE1hdGVyaWFsfHxPLmlzTWVzaEJhc2ljTWF0ZXJpYWx8fE8uaXNNZXNoU3RhbmRhcmRNYXRlcmlhbHx8Ty5pc1NoYWRlck1hdGVyaWFsKSYmUWUuc2V0VmFsdWUoTCwiaXNPcnRob2dyYXBoaWMiLHYuaXNPcnRob2dyYXBoaWNDYW1lcmE9PT0hMCksUyE9PXYmJihTPXYsYnQ9ITAsdGk9ITApfWlmKEQuaXNTa2lubmVkTWVzaCl7UWUuc2V0T3B0aW9uYWwoTCxELCJiaW5kTWF0cml4IiksUWUuc2V0T3B0aW9uYWwoTCxELCJiaW5kTWF0cml4SW52ZXJzZSIpO2NvbnN0IER0PUQuc2tlbGV0b247RHQmJihEdC5ib25lVGV4dHVyZT09PW51bGwmJkR0LmNvbXB1dGVCb25lVGV4dHVyZSgpLFFlLnNldFZhbHVlKEwsImJvbmVUZXh0dXJlIixEdC5ib25lVGV4dHVyZSx5KSl9RC5pc0JhdGNoZWRNZXNoJiYoUWUuc2V0T3B0aW9uYWwoTCxELCJiYXRjaGluZ1RleHR1cmUiKSxRZS5zZXRWYWx1ZShMLCJiYXRjaGluZ1RleHR1cmUiLEQuX21hdHJpY2VzVGV4dHVyZSx5KSxRZS5zZXRPcHRpb25hbChMLEQsImJhdGNoaW5nSWRUZXh0dXJlIiksUWUuc2V0VmFsdWUoTCwiYmF0Y2hpbmdJZFRleHR1cmUiLEQuX2luZGlyZWN0VGV4dHVyZSx5KSxRZS5zZXRPcHRpb25hbChMLEQsImJhdGNoaW5nQ29sb3JUZXh0dXJlIiksRC5fY29sb3JzVGV4dHVyZSE9PW51bGwmJlFlLnNldFZhbHVlKEwsImJhdGNoaW5nQ29sb3JUZXh0dXJlIixELl9jb2xvcnNUZXh0dXJlLHkpKTtjb25zdCBuaT1OLm1vcnBoQXR0cmlidXRlcztpZigobmkucG9zaXRpb24hPT12b2lkIDB8fG5pLm5vcm1hbCE9PXZvaWQgMHx8bmkuY29sb3IhPT12b2lkIDApJiZUZS51cGRhdGUoRCxOLEJ0KSwoYnR8fHZlLnJlY2VpdmVTaGFkb3chPT1ELnJlY2VpdmVTaGFkb3cpJiYodmUucmVjZWl2ZVNoYWRvdz1ELnJlY2VpdmVTaGFkb3csUWUuc2V0VmFsdWUoTCwicmVjZWl2ZVNoYWRvdyIsRC5yZWNlaXZlU2hhZG93KSksTy5pc01lc2hHb3VyYXVkTWF0ZXJpYWwmJk8uZW52TWFwIT09bnVsbCYmKEh0LmVudk1hcC52YWx1ZT1wZSxIdC5mbGlwRW52TWFwLnZhbHVlPXBlLmlzQ3ViZVRleHR1cmUmJnBlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT09PSExPy0xOjEpLE8uaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCYmTy5lbnZNYXA9PT1udWxsJiZQLmVudmlyb25tZW50IT09bnVsbCYmKEh0LmVudk1hcEludGVuc2l0eS52YWx1ZT1QLmVudmlyb25tZW50SW50ZW5zaXR5KSxidCYmKFFlLnNldFZhbHVlKEwsInRvbmVNYXBwaW5nRXhwb3N1cmUiLE0udG9uZU1hcHBpbmdFeHBvc3VyZSksdmUubmVlZHNMaWdodHMmJl9oKEh0LHRpKSxKJiZPLmZvZz09PSEwJiZzZS5yZWZyZXNoRm9nVW5pZm9ybXMoSHQsSiksc2UucmVmcmVzaE1hdGVyaWFsVW5pZm9ybXMoSHQsTyxILFEsZC5zdGF0ZS50cmFuc21pc3Npb25SZW5kZXJUYXJnZXRbdi5pZF0pLGJpLnVwbG9hZChMLGtzKHZlKSxIdCx5KSksTy5pc1NoYWRlck1hdGVyaWFsJiZPLnVuaWZvcm1zTmVlZFVwZGF0ZT09PSEwJiYoYmkudXBsb2FkKEwsa3ModmUpLEh0LHkpLE8udW5pZm9ybXNOZWVkVXBkYXRlPSExKSxPLmlzU3ByaXRlTWF0ZXJpYWwmJlFlLnNldFZhbHVlKEwsImNlbnRlciIsRC5jZW50ZXIpLFFlLnNldFZhbHVlKEwsIm1vZGVsVmlld01hdHJpeCIsRC5tb2RlbFZpZXdNYXRyaXgpLFFlLnNldFZhbHVlKEwsIm5vcm1hbE1hdHJpeCIsRC5ub3JtYWxNYXRyaXgpLFFlLnNldFZhbHVlKEwsIm1vZGVsTWF0cml4IixELm1hdHJpeFdvcmxkKSxPLmlzU2hhZGVyTWF0ZXJpYWx8fE8uaXNSYXdTaGFkZXJNYXRlcmlhbCl7Y29uc3QgRHQ9Ty51bmlmb3Jtc0dyb3Vwcztmb3IobGV0IGFuPTAsb249RHQubGVuZ3RoO2FuPG9uO2FuKyspe2NvbnN0IFhzPUR0W2FuXTtDLnVwZGF0ZShYcyxCdCksQy5iaW5kKFhzLEJ0KX19cmV0dXJuIEJ0fWZ1bmN0aW9uIF9oKHYsUCl7di5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZT1QLHYubGlnaHRQcm9iZS5uZWVkc1VwZGF0ZT1QLHYuZGlyZWN0aW9uYWxMaWdodHMubmVlZHNVcGRhdGU9UCx2LmRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzLm5lZWRzVXBkYXRlPVAsdi5wb2ludExpZ2h0cy5uZWVkc1VwZGF0ZT1QLHYucG9pbnRMaWdodFNoYWRvd3MubmVlZHNVcGRhdGU9UCx2LnNwb3RMaWdodHMubmVlZHNVcGRhdGU9UCx2LnNwb3RMaWdodFNoYWRvd3MubmVlZHNVcGRhdGU9UCx2LnJlY3RBcmVhTGlnaHRzLm5lZWRzVXBkYXRlPVAsdi5oZW1pc3BoZXJlTGlnaHRzLm5lZWRzVXBkYXRlPVB9ZnVuY3Rpb24gZ2godil7cmV0dXJuIHYuaXNNZXNoTGFtYmVydE1hdGVyaWFsfHx2LmlzTWVzaFRvb25NYXRlcmlhbHx8di5pc01lc2hQaG9uZ01hdGVyaWFsfHx2LmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWx8fHYuaXNTaGFkb3dNYXRlcmlhbHx8di5pc1NoYWRlck1hdGVyaWFsJiZ2LmxpZ2h0cz09PSEwfXRoaXMuZ2V0QWN0aXZlQ3ViZUZhY2U9ZnVuY3Rpb24oKXtyZXR1cm4gYn0sdGhpcy5nZXRBY3RpdmVNaXBtYXBMZXZlbD1mdW5jdGlvbigpe3JldHVybiB3fSx0aGlzLmdldFJlbmRlclRhcmdldD1mdW5jdGlvbigpe3JldHVybiBVfSx0aGlzLnNldFJlbmRlclRhcmdldFRleHR1cmVzPWZ1bmN0aW9uKHYsUCxOKXtNZS5nZXQodi50ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZT1QLE1lLmdldCh2LmRlcHRoVGV4dHVyZSkuX193ZWJnbFRleHR1cmU9Tjtjb25zdCBPPU1lLmdldCh2KTtPLl9faGFzRXh0ZXJuYWxUZXh0dXJlcz0hMCxPLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXI9Tj09PXZvaWQgMCxPLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXJ8fEllLmhhcygiV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlIik9PT0hMCYmKGNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogUmVuZGVyLXRvLXRleHR1cmUgZXh0ZW5zaW9uIHdhcyBkaXNhYmxlZCBiZWNhdXNlIGFuIGV4dGVybmFsIHRleHR1cmUgd2FzIHByb3ZpZGVkIiksTy5fX3VzZVJlbmRlclRvVGV4dHVyZT0hMSl9LHRoaXMuc2V0UmVuZGVyVGFyZ2V0RnJhbWVidWZmZXI9ZnVuY3Rpb24odixQKXtjb25zdCBOPU1lLmdldCh2KTtOLl9fd2ViZ2xGcmFtZWJ1ZmZlcj1QLE4uX191c2VEZWZhdWx0RnJhbWVidWZmZXI9UD09PXZvaWQgMH0sdGhpcy5zZXRSZW5kZXJUYXJnZXQ9ZnVuY3Rpb24odixQPTAsTj0wKXtVPXYsYj1QLHc9TjtsZXQgTz0hMCxEPW51bGwsSj0hMSxvZT0hMTtpZih2KXtjb25zdCBwZT1NZS5nZXQodik7aWYocGUuX191c2VEZWZhdWx0RnJhbWVidWZmZXIhPT12b2lkIDApU2UuYmluZEZyYW1lYnVmZmVyKEwuRlJBTUVCVUZGRVIsbnVsbCksTz0hMTtlbHNlIGlmKHBlLl9fd2ViZ2xGcmFtZWJ1ZmZlcj09PXZvaWQgMCl5LnNldHVwUmVuZGVyVGFyZ2V0KHYpO2Vsc2UgaWYocGUuX19oYXNFeHRlcm5hbFRleHR1cmVzKXkucmViaW5kVGV4dHVyZXModixNZS5nZXQodi50ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSxNZS5nZXQodi5kZXB0aFRleHR1cmUpLl9fd2ViZ2xUZXh0dXJlKTtlbHNlIGlmKHYuZGVwdGhCdWZmZXIpe2NvbnN0IG1lPXYuZGVwdGhUZXh0dXJlO2lmKHBlLl9fYm91bmREZXB0aFRleHR1cmUhPT1tZSl7aWYobWUhPT1udWxsJiZNZS5oYXMobWUpJiYodi53aWR0aCE9PW1lLmltYWdlLndpZHRofHx2LmhlaWdodCE9PW1lLmltYWdlLmhlaWdodCkpdGhyb3cgbmV3IEVycm9yKCJXZWJHTFJlbmRlclRhcmdldDogQXR0YWNoZWQgRGVwdGhUZXh0dXJlIGlzIGluaXRpYWxpemVkIHRvIHRoZSBpbmNvcnJlY3Qgc2l6ZS4iKTt5LnNldHVwRGVwdGhSZW5kZXJidWZmZXIodil9fWNvbnN0IEFlPXYudGV4dHVyZTsoQWUuaXNEYXRhM0RUZXh0dXJlfHxBZS5pc0RhdGFBcnJheVRleHR1cmV8fEFlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSkmJihvZT0hMCk7Y29uc3QgQ2U9TWUuZ2V0KHYpLl9fd2ViZ2xGcmFtZWJ1ZmZlcjt2LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0PyhBcnJheS5pc0FycmF5KENlW1BdKT9EPUNlW1BdW05dOkQ9Q2VbUF0sSj0hMCk6di5zYW1wbGVzPjAmJnkudXNlTXVsdGlzYW1wbGVkUlRUKHYpPT09ITE/RD1NZS5nZXQodikuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyOkFycmF5LmlzQXJyYXkoQ2UpP0Q9Q2VbTl06RD1DZSxSLmNvcHkodi52aWV3cG9ydCkscS5jb3B5KHYuc2Npc3Nvciksej12LnNjaXNzb3JUZXN0fWVsc2UgUi5jb3B5KHhlKS5tdWx0aXBseVNjYWxhcihIKS5mbG9vcigpLHEuY29weShVZSkubXVsdGlwbHlTY2FsYXIoSCkuZmxvb3IoKSx6PVllO2lmKFNlLmJpbmRGcmFtZWJ1ZmZlcihMLkZSQU1FQlVGRkVSLEQpJiZPJiZTZS5kcmF3QnVmZmVycyh2LEQpLFNlLnZpZXdwb3J0KFIpLFNlLnNjaXNzb3IocSksU2Uuc2V0U2Npc3NvclRlc3QoeiksSil7Y29uc3QgcGU9TWUuZ2V0KHYudGV4dHVyZSk7TC5mcmFtZWJ1ZmZlclRleHR1cmUyRChMLkZSQU1FQlVGRkVSLEwuQ09MT1JfQVRUQUNITUVOVDAsTC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grUCxwZS5fX3dlYmdsVGV4dHVyZSxOKX1lbHNlIGlmKG9lKXtjb25zdCBwZT1NZS5nZXQodi50ZXh0dXJlKSxBZT1QfHwwO0wuZnJhbWVidWZmZXJUZXh0dXJlTGF5ZXIoTC5GUkFNRUJVRkZFUixMLkNPTE9SX0FUVEFDSE1FTlQwLHBlLl9fd2ViZ2xUZXh0dXJlLE58fDAsQWUpfUU9LTF9LHRoaXMucmVhZFJlbmRlclRhcmdldFBpeGVscz1mdW5jdGlvbih2LFAsTixPLEQsSixvZSl7aWYoISh2JiZ2LmlzV2ViR0xSZW5kZXJUYXJnZXQpKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuIik7cmV0dXJufWxldCBmZT1NZS5nZXQodikuX193ZWJnbEZyYW1lYnVmZmVyO2lmKHYuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQmJm9lIT09dm9pZCAwJiYoZmU9ZmVbb2VdKSxmZSl7U2UuYmluZEZyYW1lYnVmZmVyKEwuRlJBTUVCVUZGRVIsZmUpO3RyeXtjb25zdCBwZT12LnRleHR1cmUsQWU9cGUuZm9ybWF0LENlPXBlLnR5cGU7aWYoIU5lLnRleHR1cmVGb3JtYXRSZWFkYWJsZShBZSkpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBSR0JBIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgZm9ybWF0LiIpO3JldHVybn1pZighTmUudGV4dHVyZVR5cGVSZWFkYWJsZShDZSkpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBVbnNpZ25lZEJ5dGVUeXBlIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgdHlwZS4iKTtyZXR1cm59UD49MCYmUDw9di53aWR0aC1PJiZOPj0wJiZOPD12LmhlaWdodC1EJiZMLnJlYWRQaXhlbHMoUCxOLE8sRCxEZS5jb252ZXJ0KEFlKSxEZS5jb252ZXJ0KENlKSxKKX1maW5hbGx5e2NvbnN0IHBlPVUhPT1udWxsP01lLmdldChVKS5fX3dlYmdsRnJhbWVidWZmZXI6bnVsbDtTZS5iaW5kRnJhbWVidWZmZXIoTC5GUkFNRUJVRkZFUixwZSl9fX0sdGhpcy5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzQXN5bmM9YXN5bmMgZnVuY3Rpb24odixQLE4sTyxELEosb2Upe2lmKCEodiYmdi5pc1dlYkdMUmVuZGVyVGFyZ2V0KSl0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC4iKTtsZXQgZmU9TWUuZ2V0KHYpLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtpZih2LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0JiZvZSE9PXZvaWQgMCYmKGZlPWZlW29lXSksZmUpe2NvbnN0IHBlPXYudGV4dHVyZSxBZT1wZS5mb3JtYXQsQ2U9cGUudHlwZTtpZighTmUudGV4dHVyZUZvcm1hdFJlYWRhYmxlKEFlKSl0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsc0FzeW5jOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFJHQkEgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBmb3JtYXQuIik7aWYoIU5lLnRleHR1cmVUeXBlUmVhZGFibGUoQ2UpKXRocm93IG5ldyBFcnJvcigiVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzQXN5bmM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gVW5zaWduZWRCeXRlVHlwZSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIHR5cGUuIik7aWYoUD49MCYmUDw9di53aWR0aC1PJiZOPj0wJiZOPD12LmhlaWdodC1EKXtTZS5iaW5kRnJhbWVidWZmZXIoTC5GUkFNRUJVRkZFUixmZSk7Y29uc3QgbWU9TC5jcmVhdGVCdWZmZXIoKTtMLmJpbmRCdWZmZXIoTC5QSVhFTF9QQUNLX0JVRkZFUixtZSksTC5idWZmZXJEYXRhKEwuUElYRUxfUEFDS19CVUZGRVIsSi5ieXRlTGVuZ3RoLEwuU1RSRUFNX1JFQUQpLEwucmVhZFBpeGVscyhQLE4sTyxELERlLmNvbnZlcnQoQWUpLERlLmNvbnZlcnQoQ2UpLDApO2NvbnN0IEhlPVUhPT1udWxsP01lLmdldChVKS5fX3dlYmdsRnJhbWVidWZmZXI6bnVsbDtTZS5iaW5kRnJhbWVidWZmZXIoTC5GUkFNRUJVRkZFUixIZSk7Y29uc3QgS2U9TC5mZW5jZVN5bmMoTC5TWU5DX0dQVV9DT01NQU5EU19DT01QTEVURSwwKTtyZXR1cm4gTC5mbHVzaCgpLGF3YWl0IGNhKEwsS2UsNCksTC5iaW5kQnVmZmVyKEwuUElYRUxfUEFDS19CVUZGRVIsbWUpLEwuZ2V0QnVmZmVyU3ViRGF0YShMLlBJWEVMX1BBQ0tfQlVGRkVSLDAsSiksTC5kZWxldGVCdWZmZXIobWUpLEwuZGVsZXRlU3luYyhLZSksSn1lbHNlIHRocm93IG5ldyBFcnJvcigiVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzQXN5bmM6IHJlcXVlc3RlZCByZWFkIGJvdW5kcyBhcmUgb3V0IG9mIHJhbmdlLiIpfX0sdGhpcy5jb3B5RnJhbWVidWZmZXJUb1RleHR1cmU9ZnVuY3Rpb24odixQPW51bGwsTj0wKXt2LmlzVGV4dHVyZSE9PSEwJiYoV24oIldlYkdMUmVuZGVyZXI6IGNvcHlGcmFtZWJ1ZmZlclRvVGV4dHVyZSBmdW5jdGlvbiBzaWduYXR1cmUgaGFzIGNoYW5nZWQuIiksUD1hcmd1bWVudHNbMF18fG51bGwsdj1hcmd1bWVudHNbMV0pO2NvbnN0IE89TWF0aC5wb3coMiwtTiksRD1NYXRoLmZsb29yKHYuaW1hZ2Uud2lkdGgqTyksSj1NYXRoLmZsb29yKHYuaW1hZ2UuaGVpZ2h0Kk8pLG9lPVAhPT1udWxsP1AueDowLGZlPVAhPT1udWxsP1AueTowO3kuc2V0VGV4dHVyZTJEKHYsMCksTC5jb3B5VGV4U3ViSW1hZ2UyRChMLlRFWFRVUkVfMkQsTiwwLDAsb2UsZmUsRCxKKSxTZS51bmJpbmRUZXh0dXJlKCl9LHRoaXMuY29weVRleHR1cmVUb1RleHR1cmU9ZnVuY3Rpb24odixQLE49bnVsbCxPPW51bGwsRD0wKXt2LmlzVGV4dHVyZSE9PSEwJiYoV24oIldlYkdMUmVuZGVyZXI6IGNvcHlUZXh0dXJlVG9UZXh0dXJlIGZ1bmN0aW9uIHNpZ25hdHVyZSBoYXMgY2hhbmdlZC4iKSxPPWFyZ3VtZW50c1swXXx8bnVsbCx2PWFyZ3VtZW50c1sxXSxQPWFyZ3VtZW50c1syXSxEPWFyZ3VtZW50c1szXXx8MCxOPW51bGwpO2xldCBKLG9lLGZlLHBlLEFlLENlLG1lLEhlLEtlO2NvbnN0IEplPXYuaXNDb21wcmVzc2VkVGV4dHVyZT92Lm1pcG1hcHNbRF06di5pbWFnZTtOIT09bnVsbD8oSj1OLm1heC54LU4ubWluLngsb2U9Ti5tYXgueS1OLm1pbi55LGZlPU4uaXNCb3gzP04ubWF4LnotTi5taW4uejoxLHBlPU4ubWluLngsQWU9Ti5taW4ueSxDZT1OLmlzQm94Mz9OLm1pbi56OjApOihKPUplLndpZHRoLG9lPUplLmhlaWdodCxmZT1KZS5kZXB0aHx8MSxwZT0wLEFlPTAsQ2U9MCksTyE9PW51bGw/KG1lPU8ueCxIZT1PLnksS2U9Ty56KToobWU9MCxIZT0wLEtlPTApO2NvbnN0IEV0PURlLmNvbnZlcnQoUC5mb3JtYXQpLGtlPURlLmNvbnZlcnQoUC50eXBlKTtsZXQgdmU7UC5pc0RhdGEzRFRleHR1cmU/KHkuc2V0VGV4dHVyZTNEKFAsMCksdmU9TC5URVhUVVJFXzNEKTpQLmlzRGF0YUFycmF5VGV4dHVyZXx8UC5pc0NvbXByZXNzZWRBcnJheVRleHR1cmU/KHkuc2V0VGV4dHVyZTJEQXJyYXkoUCwwKSx2ZT1MLlRFWFRVUkVfMkRfQVJSQVkpOih5LnNldFRleHR1cmUyRChQLDApLHZlPUwuVEVYVFVSRV8yRCksTC5waXhlbFN0b3JlaShMLlVOUEFDS19GTElQX1lfV0VCR0wsUC5mbGlwWSksTC5waXhlbFN0b3JlaShMLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCxQLnByZW11bHRpcGx5QWxwaGEpLEwucGl4ZWxTdG9yZWkoTC5VTlBBQ0tfQUxJR05NRU5ULFAudW5wYWNrQWxpZ25tZW50KTtjb25zdCBLdD1MLmdldFBhcmFtZXRlcihMLlVOUEFDS19ST1dfTEVOR1RIKSxXZT1MLmdldFBhcmFtZXRlcihMLlVOUEFDS19JTUFHRV9IRUlHSFQpLEJ0PUwuZ2V0UGFyYW1ldGVyKEwuVU5QQUNLX1NLSVBfUElYRUxTKSxHbj1MLmdldFBhcmFtZXRlcihMLlVOUEFDS19TS0lQX1JPV1MpLGJ0PUwuZ2V0UGFyYW1ldGVyKEwuVU5QQUNLX1NLSVBfSU1BR0VTKTtMLnBpeGVsU3RvcmVpKEwuVU5QQUNLX1JPV19MRU5HVEgsSmUud2lkdGgpLEwucGl4ZWxTdG9yZWkoTC5VTlBBQ0tfSU1BR0VfSEVJR0hULEplLmhlaWdodCksTC5waXhlbFN0b3JlaShMLlVOUEFDS19TS0lQX1BJWEVMUyxwZSksTC5waXhlbFN0b3JlaShMLlVOUEFDS19TS0lQX1JPV1MsQWUpLEwucGl4ZWxTdG9yZWkoTC5VTlBBQ0tfU0tJUF9JTUFHRVMsQ2UpO2NvbnN0IHRpPXYuaXNEYXRhQXJyYXlUZXh0dXJlfHx2LmlzRGF0YTNEVGV4dHVyZSxRZT1QLmlzRGF0YUFycmF5VGV4dHVyZXx8UC5pc0RhdGEzRFRleHR1cmU7aWYodi5pc1JlbmRlclRhcmdldFRleHR1cmV8fHYuaXNEZXB0aFRleHR1cmUpe2NvbnN0IEh0PU1lLmdldCh2KSxuaT1NZS5nZXQoUCksRHQ9TWUuZ2V0KEh0Ll9fcmVuZGVyVGFyZ2V0KSxhbj1NZS5nZXQobmkuX19yZW5kZXJUYXJnZXQpO1NlLmJpbmRGcmFtZWJ1ZmZlcihMLlJFQURfRlJBTUVCVUZGRVIsRHQuX193ZWJnbEZyYW1lYnVmZmVyKSxTZS5iaW5kRnJhbWVidWZmZXIoTC5EUkFXX0ZSQU1FQlVGRkVSLGFuLl9fd2ViZ2xGcmFtZWJ1ZmZlcik7Zm9yKGxldCBvbj0wO29uPGZlO29uKyspdGkmJkwuZnJhbWVidWZmZXJUZXh0dXJlTGF5ZXIoTC5SRUFEX0ZSQU1FQlVGRkVSLEwuQ09MT1JfQVRUQUNITUVOVDAsTWUuZ2V0KHYpLl9fd2ViZ2xUZXh0dXJlLEQsQ2Urb24pLHYuaXNEZXB0aFRleHR1cmU/KFFlJiZMLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyKEwuRFJBV19GUkFNRUJVRkZFUixMLkNPTE9SX0FUVEFDSE1FTlQwLE1lLmdldChQKS5fX3dlYmdsVGV4dHVyZSxELEtlK29uKSxMLmJsaXRGcmFtZWJ1ZmZlcihwZSxBZSxKLG9lLG1lLEhlLEosb2UsTC5ERVBUSF9CVUZGRVJfQklULEwuTkVBUkVTVCkpOlFlP0wuY29weVRleFN1YkltYWdlM0QodmUsRCxtZSxIZSxLZStvbixwZSxBZSxKLG9lKTpMLmNvcHlUZXhTdWJJbWFnZTJEKHZlLEQsbWUsSGUsS2Urb24scGUsQWUsSixvZSk7U2UuYmluZEZyYW1lYnVmZmVyKEwuUkVBRF9GUkFNRUJVRkZFUixudWxsKSxTZS5iaW5kRnJhbWVidWZmZXIoTC5EUkFXX0ZSQU1FQlVGRkVSLG51bGwpfWVsc2UgUWU/di5pc0RhdGFUZXh0dXJlfHx2LmlzRGF0YTNEVGV4dHVyZT9MLnRleFN1YkltYWdlM0QodmUsRCxtZSxIZSxLZSxKLG9lLGZlLEV0LGtlLEplLmRhdGEpOlAuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlP0wuY29tcHJlc3NlZFRleFN1YkltYWdlM0QodmUsRCxtZSxIZSxLZSxKLG9lLGZlLEV0LEplLmRhdGEpOkwudGV4U3ViSW1hZ2UzRCh2ZSxELG1lLEhlLEtlLEosb2UsZmUsRXQsa2UsSmUpOnYuaXNEYXRhVGV4dHVyZT9MLnRleFN1YkltYWdlMkQoTC5URVhUVVJFXzJELEQsbWUsSGUsSixvZSxFdCxrZSxKZS5kYXRhKTp2LmlzQ29tcHJlc3NlZFRleHR1cmU/TC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRChMLlRFWFRVUkVfMkQsRCxtZSxIZSxKZS53aWR0aCxKZS5oZWlnaHQsRXQsSmUuZGF0YSk6TC50ZXhTdWJJbWFnZTJEKEwuVEVYVFVSRV8yRCxELG1lLEhlLEosb2UsRXQsa2UsSmUpO0wucGl4ZWxTdG9yZWkoTC5VTlBBQ0tfUk9XX0xFTkdUSCxLdCksTC5waXhlbFN0b3JlaShMLlVOUEFDS19JTUFHRV9IRUlHSFQsV2UpLEwucGl4ZWxTdG9yZWkoTC5VTlBBQ0tfU0tJUF9QSVhFTFMsQnQpLEwucGl4ZWxTdG9yZWkoTC5VTlBBQ0tfU0tJUF9ST1dTLEduKSxMLnBpeGVsU3RvcmVpKEwuVU5QQUNLX1NLSVBfSU1BR0VTLGJ0KSxEPT09MCYmUC5nZW5lcmF0ZU1pcG1hcHMmJkwuZ2VuZXJhdGVNaXBtYXAodmUpLFNlLnVuYmluZFRleHR1cmUoKX0sdGhpcy5jb3B5VGV4dHVyZVRvVGV4dHVyZTNEPWZ1bmN0aW9uKHYsUCxOPW51bGwsTz1udWxsLEQ9MCl7cmV0dXJuIHYuaXNUZXh0dXJlIT09ITAmJihXbigiV2ViR0xSZW5kZXJlcjogY29weVRleHR1cmVUb1RleHR1cmUzRCBmdW5jdGlvbiBzaWduYXR1cmUgaGFzIGNoYW5nZWQuIiksTj1hcmd1bWVudHNbMF18fG51bGwsTz1hcmd1bWVudHNbMV18fG51bGwsdj1hcmd1bWVudHNbMl0sUD1hcmd1bWVudHNbM10sRD1hcmd1bWVudHNbNF18fDApLFduKCdXZWJHTFJlbmRlcmVyOiBjb3B5VGV4dHVyZVRvVGV4dHVyZTNEIGZ1bmN0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAiY29weVRleHR1cmVUb1RleHR1cmUiIGluc3RlYWQuJyksdGhpcy5jb3B5VGV4dHVyZVRvVGV4dHVyZSh2LFAsTixPLEQpfSx0aGlzLmluaXRSZW5kZXJUYXJnZXQ9ZnVuY3Rpb24odil7TWUuZ2V0KHYpLl9fd2ViZ2xGcmFtZWJ1ZmZlcj09PXZvaWQgMCYmeS5zZXR1cFJlbmRlclRhcmdldCh2KX0sdGhpcy5pbml0VGV4dHVyZT1mdW5jdGlvbih2KXt2LmlzQ3ViZVRleHR1cmU/eS5zZXRUZXh0dXJlQ3ViZSh2LDApOnYuaXNEYXRhM0RUZXh0dXJlP3kuc2V0VGV4dHVyZTNEKHYsMCk6di5pc0RhdGFBcnJheVRleHR1cmV8fHYuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlP3kuc2V0VGV4dHVyZTJEQXJyYXkodiwwKTp5LnNldFRleHR1cmUyRCh2LDApLFNlLnVuYmluZFRleHR1cmUoKX0sdGhpcy5yZXNldFN0YXRlPWZ1bmN0aW9uKCl7Yj0wLHc9MCxVPW51bGwsU2UucmVzZXQoKSxaZS5yZXNldCgpfSx0eXBlb2YgX19USFJFRV9ERVZUT09MU19fPCJ1IiYmX19USFJFRV9ERVZUT09MU19fLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCJvYnNlcnZlIix7ZGV0YWlsOnRoaXN9KSl9Z2V0IGNvb3JkaW5hdGVTeXN0ZW0oKXtyZXR1cm4gMmUzfWdldCBvdXRwdXRDb2xvclNwYWNlKCl7cmV0dXJuIHRoaXMuX291dHB1dENvbG9yU3BhY2V9c2V0IG91dHB1dENvbG9yU3BhY2UoZSl7dGhpcy5fb3V0cHV0Q29sb3JTcGFjZT1lO2NvbnN0IHQ9dGhpcy5nZXRDb250ZXh0KCk7dC5kcmF3aW5nQnVmZmVyQ29sb3JzcGFjZT1CZS5fZ2V0RHJhd2luZ0J1ZmZlckNvbG9yU3BhY2UoZSksdC51bnBhY2tDb2xvclNwYWNlPUJlLl9nZXRVbnBhY2tDb2xvclNwYWNlKCl9fWNsYXNzIFBzIGV4dGVuZHMgTXR7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuaXNTY2VuZT0hMCx0aGlzLnR5cGU9IlNjZW5lIix0aGlzLmJhY2tncm91bmQ9bnVsbCx0aGlzLmVudmlyb25tZW50PW51bGwsdGhpcy5mb2c9bnVsbCx0aGlzLmJhY2tncm91bmRCbHVycmluZXNzPTAsdGhpcy5iYWNrZ3JvdW5kSW50ZW5zaXR5PTEsdGhpcy5iYWNrZ3JvdW5kUm90YXRpb249bmV3IFh0LHRoaXMuZW52aXJvbm1lbnRJbnRlbnNpdHk9MSx0aGlzLmVudmlyb25tZW50Um90YXRpb249bmV3IFh0LHRoaXMub3ZlcnJpZGVNYXRlcmlhbD1udWxsLHR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX188InUiJiZfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoIm9ic2VydmUiLHtkZXRhaWw6dGhpc30pKX1jb3B5KGUsdCl7cmV0dXJuIHN1cGVyLmNvcHkoZSx0KSxlLmJhY2tncm91bmQhPT1udWxsJiYodGhpcy5iYWNrZ3JvdW5kPWUuYmFja2dyb3VuZC5jbG9uZSgpKSxlLmVudmlyb25tZW50IT09bnVsbCYmKHRoaXMuZW52aXJvbm1lbnQ9ZS5lbnZpcm9ubWVudC5jbG9uZSgpKSxlLmZvZyE9PW51bGwmJih0aGlzLmZvZz1lLmZvZy5jbG9uZSgpKSx0aGlzLmJhY2tncm91bmRCbHVycmluZXNzPWUuYmFja2dyb3VuZEJsdXJyaW5lc3MsdGhpcy5iYWNrZ3JvdW5kSW50ZW5zaXR5PWUuYmFja2dyb3VuZEludGVuc2l0eSx0aGlzLmJhY2tncm91bmRSb3RhdGlvbi5jb3B5KGUuYmFja2dyb3VuZFJvdGF0aW9uKSx0aGlzLmVudmlyb25tZW50SW50ZW5zaXR5PWUuZW52aXJvbm1lbnRJbnRlbnNpdHksdGhpcy5lbnZpcm9ubWVudFJvdGF0aW9uLmNvcHkoZS5lbnZpcm9ubWVudFJvdGF0aW9uKSxlLm92ZXJyaWRlTWF0ZXJpYWwhPT1udWxsJiYodGhpcy5vdmVycmlkZU1hdGVyaWFsPWUub3ZlcnJpZGVNYXRlcmlhbC5jbG9uZSgpKSx0aGlzLm1hdHJpeEF1dG9VcGRhdGU9ZS5tYXRyaXhBdXRvVXBkYXRlLHRoaXN9dG9KU09OKGUpe2NvbnN0IHQ9c3VwZXIudG9KU09OKGUpO3JldHVybiB0aGlzLmZvZyE9PW51bGwmJih0Lm9iamVjdC5mb2c9dGhpcy5mb2cudG9KU09OKCkpLHRoaXMuYmFja2dyb3VuZEJsdXJyaW5lc3M+MCYmKHQub2JqZWN0LmJhY2tncm91bmRCbHVycmluZXNzPXRoaXMuYmFja2dyb3VuZEJsdXJyaW5lc3MpLHRoaXMuYmFja2dyb3VuZEludGVuc2l0eSE9PTEmJih0Lm9iamVjdC5iYWNrZ3JvdW5kSW50ZW5zaXR5PXRoaXMuYmFja2dyb3VuZEludGVuc2l0eSksdC5vYmplY3QuYmFja2dyb3VuZFJvdGF0aW9uPXRoaXMuYmFja2dyb3VuZFJvdGF0aW9uLnRvQXJyYXkoKSx0aGlzLmVudmlyb25tZW50SW50ZW5zaXR5IT09MSYmKHQub2JqZWN0LmVudmlyb25tZW50SW50ZW5zaXR5PXRoaXMuZW52aXJvbm1lbnRJbnRlbnNpdHkpLHQub2JqZWN0LmVudmlyb25tZW50Um90YXRpb249dGhpcy5lbnZpcm9ubWVudFJvdGF0aW9uLnRvQXJyYXkoKSx0fX1jbGFzcyBHdCBleHRlbmRzIFN0e2NvbnN0cnVjdG9yKGUsdCxuLHI9MSl7c3VwZXIoZSx0LG4pLHRoaXMuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU9ITAsdGhpcy5tZXNoUGVyQXR0cmlidXRlPXJ9Y29weShlKXtyZXR1cm4gc3VwZXIuY29weShlKSx0aGlzLm1lc2hQZXJBdHRyaWJ1dGU9ZS5tZXNoUGVyQXR0cmlidXRlLHRoaXN9dG9KU09OKCl7Y29uc3QgZT1zdXBlci50b0pTT04oKTtyZXR1cm4gZS5tZXNoUGVyQXR0cmlidXRlPXRoaXMubWVzaFBlckF0dHJpYnV0ZSxlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlPSEwLGV9fWNsYXNzIFJpIGV4dGVuZHMgS257c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIlBvaW50c01hdGVyaWFsIn1jb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuaXNQb2ludHNNYXRlcmlhbD0hMCx0aGlzLmNvbG9yPW5ldyBWZSgxNjc3NzIxNSksdGhpcy5tYXA9bnVsbCx0aGlzLmFscGhhTWFwPW51bGwsdGhpcy5zaXplPTEsdGhpcy5zaXplQXR0ZW51YXRpb249ITAsdGhpcy5mb2c9ITAsdGhpcy5zZXRWYWx1ZXMoZSl9Y29weShlKXtyZXR1cm4gc3VwZXIuY29weShlKSx0aGlzLmNvbG9yLmNvcHkoZS5jb2xvciksdGhpcy5tYXA9ZS5tYXAsdGhpcy5hbHBoYU1hcD1lLmFscGhhTWFwLHRoaXMuc2l6ZT1lLnNpemUsdGhpcy5zaXplQXR0ZW51YXRpb249ZS5zaXplQXR0ZW51YXRpb24sdGhpcy5mb2c9ZS5mb2csdGhpc319Y29uc3QgRHM9bmV3IHJ0LHByPW5ldyBEcixDaT1uZXcgbGksUGk9bmV3IEI7Y2xhc3MgbXIgZXh0ZW5kcyBNdHtjb25zdHJ1Y3RvcihlPW5ldyBDdCx0PW5ldyBSaSl7c3VwZXIoKSx0aGlzLmlzUG9pbnRzPSEwLHRoaXMudHlwZT0iUG9pbnRzIix0aGlzLmdlb21ldHJ5PWUsdGhpcy5tYXRlcmlhbD10LHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCl9Y29weShlLHQpe3JldHVybiBzdXBlci5jb3B5KGUsdCksdGhpcy5tYXRlcmlhbD1BcnJheS5pc0FycmF5KGUubWF0ZXJpYWwpP2UubWF0ZXJpYWwuc2xpY2UoKTplLm1hdGVyaWFsLHRoaXMuZ2VvbWV0cnk9ZS5nZW9tZXRyeSx0aGlzfXJheWNhc3QoZSx0KXtjb25zdCBuPXRoaXMuZ2VvbWV0cnkscj10aGlzLm1hdHJpeFdvcmxkLHM9ZS5wYXJhbXMuUG9pbnRzLnRocmVzaG9sZCxhPW4uZHJhd1JhbmdlO2lmKG4uYm91bmRpbmdTcGhlcmU9PT1udWxsJiZuLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLENpLmNvcHkobi5ib3VuZGluZ1NwaGVyZSksQ2kuYXBwbHlNYXRyaXg0KHIpLENpLnJhZGl1cys9cyxlLnJheS5pbnRlcnNlY3RzU3BoZXJlKENpKT09PSExKXJldHVybjtEcy5jb3B5KHIpLmludmVydCgpLHByLmNvcHkoZS5yYXkpLmFwcGx5TWF0cml4NChEcyk7Y29uc3Qgbz1zLygodGhpcy5zY2FsZS54K3RoaXMuc2NhbGUueSt0aGlzLnNjYWxlLnopLzMpLGw9bypvLGM9bi5pbmRleCxoPW4uYXR0cmlidXRlcy5wb3NpdGlvbjtpZihjIT09bnVsbCl7Y29uc3QgZj1NYXRoLm1heCgwLGEuc3RhcnQpLHA9TWF0aC5taW4oYy5jb3VudCxhLnN0YXJ0K2EuY291bnQpO2ZvcihsZXQgXz1mLHg9cDtfPHg7XysrKXtjb25zdCBtPWMuZ2V0WChfKTtQaS5mcm9tQnVmZmVyQXR0cmlidXRlKGgsbSksTHMoUGksbSxsLHIsZSx0LHRoaXMpfX1lbHNle2NvbnN0IGY9TWF0aC5tYXgoMCxhLnN0YXJ0KSxwPU1hdGgubWluKGguY291bnQsYS5zdGFydCthLmNvdW50KTtmb3IobGV0IF89Zix4PXA7Xzx4O18rKylQaS5mcm9tQnVmZmVyQXR0cmlidXRlKGgsXyksTHMoUGksXyxsLHIsZSx0LHRoaXMpfX11cGRhdGVNb3JwaFRhcmdldHMoKXtjb25zdCB0PXRoaXMuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLG49T2JqZWN0LmtleXModCk7aWYobi5sZW5ndGg+MCl7Y29uc3Qgcj10W25bMF1dO2lmKHIhPT12b2lkIDApe3RoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzPVtdLHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5PXt9O2ZvcihsZXQgcz0wLGE9ci5sZW5ndGg7czxhO3MrKyl7Y29uc3Qgbz1yW3NdLm5hbWV8fFN0cmluZyhzKTt0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKDApLHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5W29dPXN9fX19fWZ1bmN0aW9uIExzKGksZSx0LG4scixzLGEpe2NvbnN0IG89cHIuZGlzdGFuY2VTcVRvUG9pbnQoaSk7aWYobzx0KXtjb25zdCBsPW5ldyBCO3ByLmNsb3Nlc3RQb2ludFRvUG9pbnQoaSxsKSxsLmFwcGx5TWF0cml4NChuKTtjb25zdCBjPXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKGwpO2lmKGM8ci5uZWFyfHxjPnIuZmFyKXJldHVybjtzLnB1c2goe2Rpc3RhbmNlOmMsZGlzdGFuY2VUb1JheTpNYXRoLnNxcnQobykscG9pbnQ6bCxpbmRleDplLGZhY2U6bnVsbCxmYWNlSW5kZXg6bnVsbCxiYXJ5Y29vcmQ6bnVsbCxvYmplY3Q6YX0pfX1jbGFzcyBWdSBleHRlbmRzIHZ0e2NvbnN0cnVjdG9yKGUsdCxuLHIscyxhLG8sbCxjKXtzdXBlcihlLHQsbixyLHMsYSxvLGwsYyksdGhpcy5pc0NhbnZhc1RleHR1cmU9ITAsdGhpcy5uZWVkc1VwZGF0ZT0hMH19Y2xhc3MgVXMgZXh0ZW5kcyBDdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5PSEwLHRoaXMudHlwZT0iSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkiLHRoaXMuaW5zdGFuY2VDb3VudD0xLzB9Y29weShlKXtyZXR1cm4gc3VwZXIuY29weShlKSx0aGlzLmluc3RhbmNlQ291bnQ9ZS5pbnN0YW5jZUNvdW50LHRoaXN9dG9KU09OKCl7Y29uc3QgZT1zdXBlci50b0pTT04oKTtyZXR1cm4gZS5pbnN0YW5jZUNvdW50PXRoaXMuaW5zdGFuY2VDb3VudCxlLmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnk9ITAsZX19dHlwZW9mIF9fVEhSRUVfREVWVE9PTFNfXzwidSImJl9fVEhSRUVfREVWVE9PTFNfXy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgicmVnaXN0ZXIiLHtkZXRhaWw6e3JldmlzaW9uOk5pfX0pKSx0eXBlb2Ygd2luZG93PCJ1IiYmKHdpbmRvdy5fX1RIUkVFX18/Y29uc29sZS53YXJuKCJXQVJOSU5HOiBNdWx0aXBsZSBpbnN0YW5jZXMgb2YgVGhyZWUuanMgYmVpbmcgaW1wb3J0ZWQuIik6d2luZG93Ll9fVEhSRUVfXz1OaSk7Y29uc3QgX3I9MTAwLERpPW5ldyBNYXA7bGV0IGt1PTA7Y29uc3QgRnM9dHlwZW9mIGdsb2JhbFRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lPT0iZnVuY3Rpb24iP2k9Pmdsb2JhbFRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGkpOmk9Pntjb25zdCBlPSsra3UsdD1zZXRUaW1lb3V0KCgpPT57RGkuZGVsZXRlKGUpLGkocGVyZm9ybWFuY2Uubm93KCkpfSwxNik7cmV0dXJuIERpLnNldChlLHQpLGV9LFd1PXR5cGVvZiBnbG9iYWxUaGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lPT0iZnVuY3Rpb24iP2k9Pmdsb2JhbFRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaSk6aT0+e2NvbnN0IGU9RGkuZ2V0KGkpO2UmJihjbGVhclRpbWVvdXQoZSksRGkuZGVsZXRlKGkpKX07ZnVuY3Rpb24gTGkoaSxlPWkpe2lmKHR5cGVvZiBkb2N1bWVudDwidSImJmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpe2NvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIik7dC53aWR0aD1pLHQuaGVpZ2h0PWU7Y29uc3Qgbj10LmdldENvbnRleHQoIjJkIik7aWYoIW4pdGhyb3cgbmV3IEVycm9yKCJVbmFibGUgdG8gZ2V0IDJEIGNvbnRleHQiKTtyZXR1cm57Y2FudmFzOnQsY3R4Om59fWlmKHR5cGVvZiBPZmZzY3JlZW5DYW52YXM8InUiKXtjb25zdCB0PW5ldyBPZmZzY3JlZW5DYW52YXMoaSxlKSxuPXQuZ2V0Q29udGV4dCgiMmQiKTtpZighbil0aHJvdyBuZXcgRXJyb3IoIlVuYWJsZSB0byBnZXQgMkQgY29udGV4dCIpO3JldHVybntjYW52YXM6dCxjdHg6bn19dGhyb3cgbmV3IEVycm9yKCJDYW52YXMgbm90IHN1cHBvcnRlZCIpfWZ1bmN0aW9uIFVpKGkpe3JldHVybiBuZXcgVnUoaSl9ZnVuY3Rpb24gSXMoKXtjb25zdHtjYW52YXM6ZSxjdHg6dH09TGkoMzIsMzIpLG49dC5jcmVhdGVSYWRpYWxHcmFkaWVudCgzMi8yLDMyLzIsMCwzMi8yLDMyLzIsMzIvMik7bi5hZGRDb2xvclN0b3AoMCwicmdiYSgyNTUsIDI1NSwgMjU1LCAxKSIpLG4uYWRkQ29sb3JTdG9wKC40LCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSkiKSxuLmFkZENvbG9yU3RvcCgxLCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDApIiksdC5maWxsU3R5bGU9bix0LmZpbGxSZWN0KDAsMCwzMiwzMik7Y29uc3Qgcj1VaShlKTtyZXR1cm4gci5uZWVkc1VwZGF0ZT0hMCxyfWZ1bmN0aW9uIFh1KCl7Y29uc3R7Y2FudmFzOmUsY3R4OnR9PUxpKDE2LDE2KSxuPXQuY3JlYXRlUmFkaWFsR3JhZGllbnQoMTYvMiwxNi8yLDAsMTYvMiwxNi8yLDE2LzIpO24uYWRkQ29sb3JTdG9wKDAsInJnYmEoMjU1LCAyNTUsIDI1NSwgMSkiKSxuLmFkZENvbG9yU3RvcCguMywicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjYpIiksbi5hZGRDb2xvclN0b3AoMSwicmdiYSgyNTUsIDI1NSwgMjU1LCAwKSIpLHQuZmlsbFN0eWxlPW4sdC5maWxsUmVjdCgwLDAsMTYsMTYpO2NvbnN0IHI9VWkoZSk7cmV0dXJuIHIubmVlZHNVcGRhdGU9ITAscn1jb25zdCBncj1gCiAgdmFyeWluZyB2ZWMyIHZVdjsKICB2b2lkIG1haW4oKSB7CiAgICB2VXYgPSB1djsKICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7CiAgfQpgO2NsYXNzIHF1e2NvbnN0cnVjdG9yKGUpe3RoaXMuY2FudmFzPWUuY2FudmFzLHRoaXMudmlld3BvcnRXaWR0aD1lLnZpZXdwb3J0V2lkdGgsdGhpcy52aWV3cG9ydEhlaWdodD1lLnZpZXdwb3J0SGVpZ2h0LHRoaXMuZGV2aWNlUGl4ZWxSYXRpbz1lLmRldmljZVBpeGVsUmF0aW8/PzEsdGhpcy5pc01vYmlsZT1lLmlzTW9iaWxlPz8hMSx0aGlzLnZpZXdXaWR0aD10aGlzLmNvbXB1dGVWaWV3V2lkdGgoX3IpLHRoaXMudmlld0hlaWdodD1fcix0aGlzLmNhbWVyYT10aGlzLmNyZWF0ZUNhbWVyYSgpLHRoaXMucmVuZGVyZXI9dGhpcy5jcmVhdGVSZW5kZXJlcigpLHRoaXMuc2NlbmU9bmV3IFBzLHRoaXMuYW5pbWF0aW9uRnJhbWU9bnVsbCx0aGlzLmxhc3RUaW1lc3RhbXA9MCx0aGlzLmN1cnJlbnRFZmZlY3Q9Im5vbmUiLHRoaXMuYWN0aXZlRWZmZWN0PW51bGwsdGhpcy5vcGFjaXR5PTEwMCx0aGlzLmVmZmVjdEV4dHJhcz17fSx0aGlzLmxhc3RBcHBsaWVkRXh0cmFzPXt9LHRoaXMuc25vd1N1cmZhY2VzPVtdLHRoaXMuc21vZ092ZXJsYXk9bnVsbCx0aGlzLndpbmRvd0Ryb3BsZXRzT3ZlcmxheT1udWxsLHRoaXMucmVuZGVyVGFyZ2V0PW51bGwsdGhpcy5tYXNrU2NlbmU9bnVsbCx0aGlzLm1hc2tDYW1lcmE9bnVsbCx0aGlzLm1hc2tRdWFkPW51bGwsdGhpcy5yZW5kZXJMb29wPXQ9PnRoaXMucmVuZGVyRnJhbWUodCl9Y29tcHV0ZVZpZXdXaWR0aChlKXtyZXR1cm4gZSoodGhpcy52aWV3cG9ydFdpZHRoL01hdGgubWF4KDEsdGhpcy52aWV3cG9ydEhlaWdodCkpfWNyZWF0ZUNhbWVyYSgpe2NvbnN0IGU9dGhpcy52aWV3V2lkdGgvMix0PXRoaXMudmlld0hlaWdodC8yLG49bmV3IHJyKC1lLGUsdCwtdCwtMWUzLDFlMyk7cmV0dXJuIG4ucG9zaXRpb24uej0xMCxufWNyZWF0ZVJlbmRlcmVyKCl7Y29uc3QgZT1uZXcgSHUoe2NhbnZhczp0aGlzLmNhbnZhcyxhbHBoYTohMCxhbnRpYWxpYXM6IXRoaXMuaXNNb2JpbGUscG93ZXJQcmVmZXJlbmNlOiJoaWdoLXBlcmZvcm1hbmNlIixzdGVuY2lsOiExLGRlcHRoOiExLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMX0pO3JldHVybiBlLnNldFBpeGVsUmF0aW8oTWF0aC5taW4odGhpcy5kZXZpY2VQaXhlbFJhdGlvfHwxLHRoaXMuaXNNb2JpbGU/MToxLjUpKSxlLnNldFNpemUodGhpcy52aWV3cG9ydFdpZHRoLHRoaXMudmlld3BvcnRIZWlnaHQsITEpLGV9c3RhcnQoZSx0LG49e30pe3RoaXMub3BhY2l0eT1NYXRoLm1heCgwLE1hdGgubWluKDEwMCx0KSksdGhpcy5lZmZlY3RFeHRyYXM9bjtjb25zdCByPXRoaXMuZWZmZWN0RXh0cmFzLm1vb25Qb3NpdGlvbixzPXRoaXMubGFzdEFwcGxpZWRFeHRyYXMubW9vblBvc2l0aW9uLGE9cj8ueCE9PXM/Lnh8fHI/LnkhPT1zPy55LG89dGhpcy5sYXN0QXBwbGllZEV4dHJhcy5zbm93QWNjdW11bGF0aW9uIT09dGhpcy5lZmZlY3RFeHRyYXMuc25vd0FjY3VtdWxhdGlvbnx8dGhpcy5sYXN0QXBwbGllZEV4dHJhcy5tYXRyaXhSYWluQ29sb3IhPT10aGlzLmVmZmVjdEV4dHJhcy5tYXRyaXhSYWluQ29sb3J8fHRoaXMubGFzdEFwcGxpZWRFeHRyYXMuc21vZ0FjdGl2ZSE9PXRoaXMuZWZmZWN0RXh0cmFzLnNtb2dBY3RpdmV8fHRoaXMubGFzdEFwcGxpZWRFeHRyYXMud2luZG93RHJvcGxldHMhPT10aGlzLmVmZmVjdEV4dHJhcy53aW5kb3dEcm9wbGV0c3x8YTtpZih0aGlzLmN1cnJlbnRFZmZlY3Q9PT1lJiZ0aGlzLmFjdGl2ZUVmZmVjdCYmIW8pe3RoaXMuYWN0aXZlRWZmZWN0LnNldE9wYWNpdHkodGhpcy5vcGFjaXR5KSx0aGlzLnVwZGF0ZVNtb2dPdmVybGF5KCksdGhpcy51cGRhdGVXaW5kb3dEcm9wbGV0c092ZXJsYXkoKSx0aGlzLnN0YXJ0TG9vcCgpO3JldHVybn10aGlzLnNldEVmZmVjdChlKX1zdG9wKCl7dGhpcy5kaXNwb3NlU21vZ092ZXJsYXkoKSx0aGlzLmRpc3Bvc2VXaW5kb3dEcm9wbGV0c092ZXJsYXkoKSx0aGlzLmRpc3Bvc2VBY3RpdmVFZmZlY3QoKSx0aGlzLmN1cnJlbnRFZmZlY3Q9Im5vbmUiLHRoaXMuc3RvcExvb3AoKSx0aGlzLmxhc3RBcHBsaWVkRXh0cmFzPXt9fXVwZGF0ZVNtb2dPdmVybGF5KCl7Y29uc3QgZT0hIXRoaXMuZWZmZWN0RXh0cmFzLnNtb2dBY3RpdmU7ZSYmIXRoaXMuc21vZ092ZXJsYXk/KHRoaXMuc21vZ092ZXJsYXk9YWgodGhpcyksdGhpcy5zY2VuZS5hZGQodGhpcy5zbW9nT3ZlcmxheS5ncm91cCkpOiFlJiZ0aGlzLnNtb2dPdmVybGF5P3RoaXMuZGlzcG9zZVNtb2dPdmVybGF5KCk6dGhpcy5zbW9nT3ZlcmxheSYmdGhpcy5zbW9nT3ZlcmxheS5zZXRPcGFjaXR5KHRoaXMub3BhY2l0eSl9ZGlzcG9zZVNtb2dPdmVybGF5KCl7dGhpcy5zbW9nT3ZlcmxheSYmKHRoaXMuc2NlbmUucmVtb3ZlKHRoaXMuc21vZ092ZXJsYXkuZ3JvdXApLHRoaXMuc21vZ092ZXJsYXkuZGlzcG9zZSgpLHRoaXMuc21vZ092ZXJsYXk9bnVsbCl9dXBkYXRlV2luZG93RHJvcGxldHNPdmVybGF5KCl7Y29uc3QgZT0hIXRoaXMuZWZmZWN0RXh0cmFzLndpbmRvd0Ryb3BsZXRzO2UmJiF0aGlzLndpbmRvd0Ryb3BsZXRzT3ZlcmxheT8odGhpcy53aW5kb3dEcm9wbGV0c092ZXJsYXk9c2godGhpcyksdGhpcy5zY2VuZS5hZGQodGhpcy53aW5kb3dEcm9wbGV0c092ZXJsYXkuZ3JvdXApKTohZSYmdGhpcy53aW5kb3dEcm9wbGV0c092ZXJsYXk/dGhpcy5kaXNwb3NlV2luZG93RHJvcGxldHNPdmVybGF5KCk6dGhpcy53aW5kb3dEcm9wbGV0c092ZXJsYXkmJnRoaXMud2luZG93RHJvcGxldHNPdmVybGF5LnNldE9wYWNpdHkodGhpcy5vcGFjaXR5KX1kaXNwb3NlV2luZG93RHJvcGxldHNPdmVybGF5KCl7dGhpcy53aW5kb3dEcm9wbGV0c092ZXJsYXkmJih0aGlzLnNjZW5lLnJlbW92ZSh0aGlzLndpbmRvd0Ryb3BsZXRzT3ZlcmxheS5ncm91cCksdGhpcy53aW5kb3dEcm9wbGV0c092ZXJsYXkuZGlzcG9zZSgpLHRoaXMud2luZG93RHJvcGxldHNPdmVybGF5PW51bGwpfXNldE9wYWNpdHkoZSl7dGhpcy5vcGFjaXR5PU1hdGgubWF4KDAsTWF0aC5taW4oMTAwLGUpKSx0aGlzLmFjdGl2ZUVmZmVjdD8uc2V0T3BhY2l0eSh0aGlzLm9wYWNpdHkpfXNldFNub3dTdXJmYWNlcyhlKXt0aGlzLnNub3dTdXJmYWNlcz1lfHxbXSx0aGlzLmFjdGl2ZUVmZmVjdD8uc2V0U25vd1N1cmZhY2VzPy4odGhpcy5zbm93U3VyZmFjZXMpfWdldExhc3RBcHBsaWVkRXh0cmFzKCl7cmV0dXJuey4uLnRoaXMubGFzdEFwcGxpZWRFeHRyYXN9fXJlc2l6ZShlKXtpZih0aGlzLnZpZXdwb3J0V2lkdGg9ZS52aWV3cG9ydFdpZHRoLHRoaXMudmlld3BvcnRIZWlnaHQ9ZS52aWV3cG9ydEhlaWdodCx0aGlzLnJlbmRlclRhcmdldCYmdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZSh0aGlzLnZpZXdwb3J0V2lkdGgsdGhpcy52aWV3cG9ydEhlaWdodCksdGhpcy5kZXZpY2VQaXhlbFJhdGlvPWUuZGV2aWNlUGl4ZWxSYXRpbz8/MSx0aGlzLmlzTW9iaWxlPWUuaXNNb2JpbGU/PyExLHRoaXMudmlld1dpZHRoPXRoaXMuY29tcHV0ZVZpZXdXaWR0aChfciksdGhpcy5jYW1lcmE9dGhpcy5jcmVhdGVDYW1lcmEoKSx0aGlzLnJlbmRlcmVyLnNldFBpeGVsUmF0aW8oTWF0aC5taW4odGhpcy5kZXZpY2VQaXhlbFJhdGlvfHwxLHRoaXMuaXNNb2JpbGU/MToxLjUpKSx0aGlzLnJlbmRlcmVyLnNldFNpemUodGhpcy52aWV3cG9ydFdpZHRoLHRoaXMudmlld3BvcnRIZWlnaHQsITEpLHRoaXMuYWN0aXZlRWZmZWN0Py5vblJlc2l6ZSl0aGlzLmFjdGl2ZUVmZmVjdC5vblJlc2l6ZSh0aGlzLnZpZXdXaWR0aCx0aGlzLnZpZXdIZWlnaHQsdGhpcy5pc01vYmlsZSx0aGlzLnZpZXdwb3J0V2lkdGgsdGhpcy52aWV3cG9ydEhlaWdodCksdGhpcy5hY3RpdmVFZmZlY3Quc2V0U25vd1N1cmZhY2VzPy4odGhpcy5zbm93U3VyZmFjZXMpO2Vsc2UgaWYodGhpcy5jdXJyZW50RWZmZWN0IT09Im5vbmUiKXtjb25zdCB0PXRoaXMuY3VycmVudEVmZmVjdDt0aGlzLmN1cnJlbnRFZmZlY3Q9Im5vbmUiLHRoaXMuc2V0RWZmZWN0KHQpfX1kZXN0cm95KCl7dGhpcy5zdG9wKCksdGhpcy5yZW5kZXJUYXJnZXQmJih0aGlzLnJlbmRlclRhcmdldC5kaXNwb3NlKCksdGhpcy5yZW5kZXJUYXJnZXQ9bnVsbCksdGhpcy5tYXNrUXVhZD8ubWF0ZXJpYWwmJnRoaXMubWFza1F1YWQubWF0ZXJpYWwuZGlzcG9zZSgpLHRoaXMubWFza1NjZW5lPy5jbGVhcigpLHRoaXMucmVuZGVyZXIuZGlzcG9zZSgpLHRoaXMuc2NlbmUuY2xlYXIoKX1zdGFydExvb3AoKXt0aGlzLmFuaW1hdGlvbkZyYW1lPT1udWxsJiYodGhpcy5sYXN0VGltZXN0YW1wPTAsdGhpcy5hbmltYXRpb25GcmFtZT1Gcyh0aGlzLnJlbmRlckxvb3ApKX1zdG9wTG9vcCgpe3RoaXMuYW5pbWF0aW9uRnJhbWUhPW51bGwmJihXdSh0aGlzLmFuaW1hdGlvbkZyYW1lKSx0aGlzLmFuaW1hdGlvbkZyYW1lPW51bGwpfXJlbmRlckZyYW1lKGUpe3RoaXMubGFzdFRpbWVzdGFtcD09PTAmJih0aGlzLmxhc3RUaW1lc3RhbXA9ZSk7Y29uc3QgdD1NYXRoLm1pbigoZS10aGlzLmxhc3RUaW1lc3RhbXApLzFlMywuMDUpO3RoaXMubGFzdFRpbWVzdGFtcD1lLHRoaXMuYWN0aXZlRWZmZWN0Py51cGRhdGUodCxlLzFlMyksdGhpcy5zbW9nT3ZlcmxheT8udXBkYXRlKHQpLHRoaXMud2luZG93RHJvcGxldHNPdmVybGF5Py51cGRhdGUodCk7Y29uc3Qgbj10aGlzLmVmZmVjdEV4dHJhcy5zcGF0aWFsTW9kZT09PSJncmFkaWVudC1tYXNrIjtuJiYodGhpcy5lbnN1cmVHcmFkaWVudE1hc2tQYXNzKCksdGhpcy5yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUYXJnZXQpKSx0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLHRoaXMuY2FtZXJhKSxuJiYodGhpcy5yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCksdGhpcy5tYXNrUXVhZC5tYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZT10aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMubWFza1NjZW5lLHRoaXMubWFza0NhbWVyYSkpLHRoaXMuYW5pbWF0aW9uRnJhbWU9RnModGhpcy5yZW5kZXJMb29wKX1lbnN1cmVHcmFkaWVudE1hc2tQYXNzKCl7aWYodGhpcy5yZW5kZXJUYXJnZXQpcmV0dXJuO3RoaXMucmVuZGVyVGFyZ2V0PW5ldyBKdCh0aGlzLnZpZXdwb3J0V2lkdGgsdGhpcy52aWV3cG9ydEhlaWdodCx7bWluRmlsdGVyOjEwMDYsbWFnRmlsdGVyOjEwMDYsZm9ybWF0OjEwMjMsdHlwZToxMDA5LHN0ZW5jaWxCdWZmZXI6ITF9KSx0aGlzLm1hc2tDYW1lcmE9bmV3IHJyKC0xLDEsMSwtMSwwLDEpLHRoaXMubWFza1NjZW5lPW5ldyBQcztjb25zdCBlPW5ldyB0dCgyLDIpLHQ9bmV3IGh0KHt1bmlmb3Jtczp7dERpZmZ1c2U6e3ZhbHVlOm51bGx9LHVJbm5lcjp7dmFsdWU6LjMyfSx1T3V0ZXI6e3ZhbHVlOi44NX19LHZlcnRleFNoYWRlcjoidmFyeWluZyB2ZWMyIHZVdjsgdm9pZCBtYWluKCkgeyB2VXYgPSB1djsgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTsgfSIsZnJhZ21lbnRTaGFkZXI6YAogICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlOwogICAgICAgIHVuaWZvcm0gZmxvYXQgdUlubmVyOwogICAgICAgIHVuaWZvcm0gZmxvYXQgdU91dGVyOwogICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7CiAgICAgICAgdm9pZCBtYWluKCkgewogICAgICAgICAgdmVjNCB0ZXggPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdik7CiAgICAgICAgICB2ZWMyIGMgPSB2VXYgLSAwLjU7CiAgICAgICAgICBmbG9hdCBkID0gbGVuZ3RoKGMpICogMi4wOwogICAgICAgICAgZmxvYXQgbWFzayA9IHNtb290aHN0ZXAodUlubmVyLCB1T3V0ZXIsIGQpOwogICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh0ZXgucmdiLCB0ZXguYSAqIG1hc2spOwogICAgICAgIH0KICAgICAgYCx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExfSk7dGhpcy5tYXNrUXVhZD1uZXcgc3QoZSx0KSx0aGlzLm1hc2tTY2VuZS5hZGQodGhpcy5tYXNrUXVhZCl9c2V0RWZmZWN0KGUpe2lmKHRoaXMuZGlzcG9zZUFjdGl2ZUVmZmVjdCgpLHRoaXMuY3VycmVudEVmZmVjdD1lLGU9PT0ibm9uZSIpe3RoaXMuc3RvcExvb3AoKTtyZXR1cm59Y29uc3QgdD10aGlzLmNyZWF0ZUVmZmVjdEluc3RhbmNlKGUpO2lmKCF0KXt0aGlzLnN0b3BMb29wKCksdGhpcy5jdXJyZW50RWZmZWN0PSJub25lIjtyZXR1cm59dGhpcy5hY3RpdmVFZmZlY3Q9dCx0aGlzLmFjdGl2ZUVmZmVjdC5zZXRPcGFjaXR5KHRoaXMub3BhY2l0eSksdGhpcy5zbm93U3VyZmFjZXMubGVuZ3RoJiZ0aGlzLmFjdGl2ZUVmZmVjdC5zZXRTbm93U3VyZmFjZXMmJnRoaXMuYWN0aXZlRWZmZWN0LnNldFNub3dTdXJmYWNlcyh0aGlzLnNub3dTdXJmYWNlcyksdGhpcy5zY2VuZS5hZGQodC5ncm91cCksdGhpcy5sYXN0QXBwbGllZEV4dHJhcz17Li4udGhpcy5lZmZlY3RFeHRyYXN9LHRoaXMudXBkYXRlU21vZ092ZXJsYXkoKSx0aGlzLnVwZGF0ZVdpbmRvd0Ryb3BsZXRzT3ZlcmxheSgpLHRoaXMuc3RhcnRMb29wKCl9ZGlzcG9zZUFjdGl2ZUVmZmVjdCgpe3RoaXMuYWN0aXZlRWZmZWN0JiYodGhpcy5zY2VuZS5yZW1vdmUodGhpcy5hY3RpdmVFZmZlY3QuZ3JvdXApLHRoaXMuYWN0aXZlRWZmZWN0LmRpc3Bvc2UoKSx0aGlzLmFjdGl2ZUVmZmVjdD1udWxsKX1jcmVhdGVFZmZlY3RJbnN0YW5jZShlKXtjb25zdCB0PXt2aWV3V2lkdGg6dGhpcy52aWV3V2lkdGgsdmlld0hlaWdodDp0aGlzLnZpZXdIZWlnaHQsdmlld3BvcnRXaWR0aDp0aGlzLnZpZXdwb3J0V2lkdGgsdmlld3BvcnRIZWlnaHQ6dGhpcy52aWV3cG9ydEhlaWdodCxpc01vYmlsZTp0aGlzLmlzTW9iaWxlLGVmZmVjdDplLG9wYWNpdHk6dGhpcy5vcGFjaXR5LHNub3dBY2N1bXVsYXRpb246ISF0aGlzLmVmZmVjdEV4dHJhcy5zbm93QWNjdW11bGF0aW9uLHNub3dTdXJmYWNlczp0aGlzLnNub3dTdXJmYWNlcyxtYXRyaXhSYWluQ29sb3I6dGhpcy5lZmZlY3RFeHRyYXMubWF0cml4UmFpbkNvbG9yLG1vb25Qb3NpdGlvbjp0aGlzLmVmZmVjdEV4dHJhcy5tb29uUG9zaXRpb259O3JldHVybiBlPT09ImxpZ2h0bmluZyI/ZGgodCk6ZT09PSJzdW5fYmVhbXMiP3VoKHQpOmU9PT0ic3RhcnMiP2loKHQpOmU9PT0ibWF0cml4Ij90aCh0KTplPT09ImNsb3VkcyI/aGgodCk6ZT09PSJoYWlsIj9maCh0KTplLnN0YXJ0c1dpdGgoInJhaW4iKT8kdSh0KTplPT09InNub3dfbGF5ZXJlZCI/anUodCk6ZS5zdGFydHNXaXRoKCJzbm93Iik/S3UodCk6ZS5zdGFydHNXaXRoKCJmb2ciKT9jaCh0KTpudWxsfX1mdW5jdGlvbiBZdShpLGUpe2NvbnN0IHQ9ZT8uNjoxO3JldHVybiBpPT09InJhaW5fc3Rvcm0iP3tjb3VudDpNYXRoLmZsb29yKDYwMCp0KSxsZW5ndGg6e21pbjoxLjEsbWF4OjEuNX0sc3BlZWQ6e21pbjoxLjQsbWF4OjEuOX0sdGltZVNjYWxlOjEuMixsaWdodG5pbmc6ITAsbGlnaHRuaW5nT25seTohMX06aT09PSJyYWluX2RyaXp6bGUiP3tjb3VudDpNYXRoLmZsb29yKDI1MCp0KSxsZW5ndGg6e21pbjouNixtYXg6Ljl9LHNwZWVkOnttaW46LjMsbWF4Oi42fSx0aW1lU2NhbGU6LjYsbGlnaHRuaW5nOiExLGxpZ2h0bmluZ09ubHk6ITF9Ontjb3VudDpNYXRoLmZsb29yKDQ4MCp0KSxsZW5ndGg6e21pbjouOSxtYXg6MS4yfSxzcGVlZDp7bWluOjEsbWF4OjEuM30sdGltZVNjYWxlOjEsbGlnaHRuaW5nOiExLGxpZ2h0bmluZ09ubHk6ITF9fWZ1bmN0aW9uICR1KGkpe2NvbnN0IGU9bmV3IHB0LHQ9WXUoaS5lZmZlY3QsaS5pc01vYmlsZSksbj10LmNvdW50LHI9bmV3IHR0KC4wNiwxKSxzPW5ldyBVcztzLmluZGV4PXIuaW5kZXgscy5hdHRyaWJ1dGVzLnBvc2l0aW9uPXIuYXR0cmlidXRlcy5wb3NpdGlvbixzLmF0dHJpYnV0ZXMudXY9ci5hdHRyaWJ1dGVzLnV2LHMuaW5zdGFuY2VDb3VudD1uO2NvbnN0IGE9bmV3IEZsb2F0MzJBcnJheShuKjMpLG89bmV3IEZsb2F0MzJBcnJheShuKSxsPW5ldyBGbG9hdDMyQXJyYXkobiksYz1uZXcgRmxvYXQzMkFycmF5KG4pLHU9bmV3IEZsb2F0MzJBcnJheShuKTtmb3IobGV0IF89MDtfPG47XysrKXtjb25zdCB4PV8qMzthW3hdPSRlLnJhbmRGbG9hdFNwcmVhZChpLnZpZXdXaWR0aCsxMCksYVt4KzFdPSRlLnJhbmRGbG9hdFNwcmVhZChpLnZpZXdIZWlnaHQpLGFbeCsyXT1NYXRoLnJhbmRvbSgpKi41LG9bX109JGUucmFuZEZsb2F0KHQuc3BlZWQubWluLHQuc3BlZWQubWF4KSxsW19dPSRlLnJhbmRGbG9hdCh0Lmxlbmd0aC5taW4sdC5sZW5ndGgubWF4KSxjW19dPSRlLnJhbmRGbG9hdCguNSwxLjUpLHVbX109TWF0aC5yYW5kb20oKX1zLnNldEF0dHJpYnV0ZSgiaW5zdGFuY2VPZmZzZXQiLG5ldyBHdChhLDMpKSxzLnNldEF0dHJpYnV0ZSgiaW5zdGFuY2VTcGVlZCIsbmV3IEd0KG8sMSkpLHMuc2V0QXR0cmlidXRlKCJpbnN0YW5jZUxlbmd0aCIsbmV3IEd0KGwsMSkpLHMuc2V0QXR0cmlidXRlKCJpbnN0YW5jZVN3YXkiLG5ldyBHdChjLDEpKSxzLnNldEF0dHJpYnV0ZSgiaW5zdGFuY2VQaGFzZSIsbmV3IEd0KHUsMSkpO2NvbnN0IGg9e3VUaW1lOnt2YWx1ZTowfSx1T3BhY2l0eTp7dmFsdWU6aS5vcGFjaXR5LzEwMH0sdVZpZXdTaXplOnt2YWx1ZTpuZXcgTGUoaS52aWV3V2lkdGgsaS52aWV3SGVpZ2h0KX19LGY9bmV3IGh0KHt1bmlmb3JtczpoLHZlcnRleFNoYWRlcjpgCiAgICAgIGF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlT2Zmc2V0OwogICAgICBhdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VTcGVlZDsKICAgICAgYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlTGVuZ3RoOwogICAgICBhdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VTd2F5OwogICAgICBhdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VQaGFzZTsKICAgICAgdW5pZm9ybSBmbG9hdCB1VGltZTsKICAgICAgdW5pZm9ybSB2ZWMyIHVWaWV3U2l6ZTsKICAgICAgdmFyeWluZyBmbG9hdCB2QWxwaGE7CiAgICAgIHZvaWQgbWFpbigpIHsKICAgICAgICBmbG9hdCBwcm9ncmVzcyA9IGZyYWN0KHVUaW1lICogaW5zdGFuY2VTcGVlZCArIGluc3RhbmNlUGhhc2UpOwogICAgICAgIGZsb2F0IHRyYXZlbCA9ICh1Vmlld1NpemUueSAqIDAuNSkgLSBwcm9ncmVzcyAqICh1Vmlld1NpemUueSArIDIwLjApOwogICAgICAgIHZlYzMgdHJhbnNmb3JtZWQgPSBwb3NpdGlvbjsKICAgICAgICB0cmFuc2Zvcm1lZC55ICo9IGluc3RhbmNlTGVuZ3RoOwogICAgICAgIHRyYW5zZm9ybWVkLnggKz0gaW5zdGFuY2VPZmZzZXQueCArIHNpbihwcm9ncmVzcyAqIDYuMjgzMTggKyBpbnN0YW5jZVBoYXNlKSAqIGluc3RhbmNlU3dheTsKICAgICAgICB0cmFuc2Zvcm1lZC55ICs9IHRyYXZlbCArIGluc3RhbmNlT2Zmc2V0Lnk7CiAgICAgICAgdHJhbnNmb3JtZWQueiArPSAtNS4wICsgaW5zdGFuY2VPZmZzZXQuejsKICAgICAgICB2QWxwaGEgPSAxLjAgLSBwcm9ncmVzczsKICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHRyYW5zZm9ybWVkLCAxLjApOwogICAgICB9CiAgICBgLGZyYWdtZW50U2hhZGVyOmAKICAgICAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTsKICAgICAgdmFyeWluZyBmbG9hdCB2QWxwaGE7CiAgICAgIHZvaWQgbWFpbigpIHsKICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuNjUsIDAuNzUsIDAuOSwgY2xhbXAodkFscGhhICogMC44NSAqIHVPcGFjaXR5LCAwLjAsIDEuMCkpOwogICAgICB9CiAgICBgLHRyYW5zcGFyZW50OiEwLGRlcHRoV3JpdGU6ITEsYmxlbmRpbmc6Mn0pLHA9bmV3IHN0KHMsZik7cmV0dXJuIHAuZnJ1c3R1bUN1bGxlZD0hMSxlLmFkZChwKSx7Z3JvdXA6ZSx1cGRhdGUoXyl7aC51VGltZS52YWx1ZSs9Xyp0LnRpbWVTY2FsZSxoLnVWaWV3U2l6ZS52YWx1ZS5zZXQoaS52aWV3V2lkdGgsaS52aWV3SGVpZ2h0KX0sc2V0T3BhY2l0eShfKXtoLnVPcGFjaXR5LnZhbHVlPU1hdGgubWF4KDAsTWF0aC5taW4oMSxfLzEwMCkpfSxvblJlc2l6ZShfLHgpe2kudmlld1dpZHRoPV8saS52aWV3SGVpZ2h0PXgsaC51Vmlld1NpemUudmFsdWUuc2V0KF8seCl9LGRpc3Bvc2UoKXtzLmRpc3Bvc2UoKSxmLmRpc3Bvc2UoKX19fWZ1bmN0aW9uIFp1KGksZSl7Y29uc3QgdD1lPy42OjE7cmV0dXJuIE1hdGguZmxvb3IoaT09PSJzbm93X3N0b3JtIj8xZTMqdDo2MDAqdCl9ZnVuY3Rpb24gS3UoaSl7Y29uc3QgZT1uZXcgcHQsdD1adShpLmVmZmVjdCxpLmlzTW9iaWxlKSxuPW5ldyBGbG9hdDMyQXJyYXkodCozKSxyPW5ldyBGbG9hdDMyQXJyYXkodCozKTtmb3IobGV0IHU9MDt1PHQ7dSsrKXtjb25zdCBoPXUqMztuW2hdPSRlLnJhbmRGbG9hdFNwcmVhZChpLnZpZXdXaWR0aCszMCksbltoKzFdPSRlLnJhbmRGbG9hdFNwcmVhZChpLnZpZXdIZWlnaHQrMzApLG5baCsyXT1NYXRoLnJhbmRvbSgpKjQtMixyW2hdPSRlLnJhbmRGbG9hdCgtLjIsLjIpLHJbaCsxXT1pLmVmZmVjdD09PSJzbm93X3N0b3JtIj8kZS5yYW5kRmxvYXQoLTEuNCwtLjkpOiRlLnJhbmRGbG9hdCgtLjgsLS40KSxyW2grMl09JGUucmFuZEZsb2F0KC0uMDUsLjA1KX1jb25zdCBzPW5ldyBDdDtzLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBTdChuLDMpKTtjb25zdCBhPUlzKCksbz1pLmVmZmVjdD09PSJzbm93X3N0b3JtIj8uOTouNzUsbD1uZXcgUmkoe21hcDphLHRyYW5zcGFyZW50OiEwLG9wYWNpdHk6byooaS5vcGFjaXR5LzEwMCksc2l6ZUF0dGVudWF0aW9uOiExLHNpemU6aS5lZmZlY3Q9PT0ic25vd19zdG9ybSI/My40OjIuNixjb2xvcjoxNjc3NzIxNSxkZXB0aFdyaXRlOiExLGRlcHRoVGVzdDohMSxibGVuZGluZzoyfSksYz1uZXcgbXIocyxsKTtyZXR1cm4gYy5mcnVzdHVtQ3VsbGVkPSExLGUuYWRkKGMpLHtncm91cDplLHVwZGF0ZSh1KXtjb25zdCBoPXMuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtmb3IobGV0IGY9MDtmPGgubGVuZ3RoO2YrPTMpe2hbZl0rPXJbZl0qdSoyNSxoW2YrMV0rPXJbZisxXSp1KjI1LGhbZisyXSs9cltmKzJdKnUqMTA7Y29uc3QgcD1pLnZpZXdXaWR0aC8yKzE1LF89aS52aWV3SGVpZ2h0LzIrMTU7aFtmKzFdPC1fJiYoaFtmKzFdPV8saFtmXT0kZS5yYW5kRmxvYXRTcHJlYWQoaS52aWV3V2lkdGgrMzApKSxoW2ZdPC1wJiYoaFtmXT1wKSxoW2ZdPnAmJihoW2ZdPS1wKX1zLmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGU9ITB9LHNldE9wYWNpdHkodSl7bC5vcGFjaXR5PW8qTWF0aC5tYXgoMCxNYXRoLm1pbigxLHUvMTAwKSl9LG9uUmVzaXplKHUsaCl7aS52aWV3V2lkdGg9dSxpLnZpZXdIZWlnaHQ9aH0sZGlzcG9zZSgpe3MuZGlzcG9zZSgpLGwuZGlzcG9zZSgpLGEuZGlzcG9zZSgpfX19Y29uc3QgTnM9W3tzaXplTWluOjI0LHNpemVNYXg6NDAsc3BlZWRGYWN0b3I6LjEyLHN3YXlBbXBNaW46MTAsc3dheUFtcE1heDozMCxvcGFjaXR5OjEsY29sb3JNaW46MjU1LGNvbG9yTWF4OjI1NX0se3NpemVNaW46MjAsc2l6ZU1heDoyOCxzcGVlZEZhY3RvcjouMDksc3dheUFtcE1pbjoxMCxzd2F5QW1wTWF4OjI1LG9wYWNpdHk6Ljg1LGNvbG9yTWluOjI1NSxjb2xvck1heDoyNTV9LHtzaXplTWluOjE2LHNpemVNYXg6MjQsc3BlZWRGYWN0b3I6LjA3LHN3YXlBbXBNaW46MTAsc3dheUFtcE1heDoyMCxvcGFjaXR5Oi43NSxjb2xvck1pbjoyNTUsY29sb3JNYXg6MjU1fSx7c2l6ZU1pbjoxMixzaXplTWF4OjE4LHNwZWVkRmFjdG9yOi4wNSxzd2F5QW1wTWluOjEwLHN3YXlBbXBNYXg6MjAsb3BhY2l0eTouNjUsY29sb3JNaW46MjIwLGNvbG9yTWF4OjIyOX0se3NpemVNaW46MTAsc2l6ZU1heDoxNCxzcGVlZEZhY3RvcjouMDMsc3dheUFtcE1pbjoxMCxzd2F5QW1wTWF4OjIwLG9wYWNpdHk6LjU1LGNvbG9yTWluOjIxMCxjb2xvck1heDoyMTl9LHtzaXplTWluOjgsc2l6ZU1heDoxMixzcGVlZEZhY3RvcjouMDEsc3dheUFtcE1pbjoxMCxzd2F5QW1wTWF4OjIwLG9wYWNpdHk6LjQsY29sb3JNaW46MjAwLGNvbG9yTWF4OjIwOX1dO2Z1bmN0aW9uIGp1KGkpe2NvbnN0IGU9bmV3IHB0O2xldCB0PWkuaXNNb2JpbGU/MTgwOjMwMDtjb25zdCBuPU1hdGguZmxvb3IodC9Ocy5sZW5ndGgpLHI9SXMoKSxzPU5zLm1hcChhPT57Y29uc3Qgbz1uZXcgRmxvYXQzMkFycmF5KG4qMyksbD1uZXcgRmxvYXQzMkFycmF5KG4pLGM9bmV3IEZsb2F0MzJBcnJheShuKSx1PW5ldyBGbG9hdDMyQXJyYXkobiksaD1uZXcgRmxvYXQzMkFycmF5KG4pO2ZvcihsZXQgbT0wO208bjttKyspe2NvbnN0IGQ9bSozLEE9YS5zaXplTWluK01hdGgucmFuZG9tKCkqKGEuc2l6ZU1heC1hLnNpemVNaW4pO29bZF09JGUucmFuZEZsb2F0U3ByZWFkKGkudmlld1dpZHRoKzIwKSxvW2QrMV09JGUucmFuZEZsb2F0U3ByZWFkKGkudmlld0hlaWdodCsyMCksb1tkKzJdPU1hdGgucmFuZG9tKCkqMi0xLGxbbV09QSphLnNwZWVkRmFjdG9yKi4xNStNYXRoLnJhbmRvbSgpKi4wMixjW21dPWEuc3dheUFtcE1pbitNYXRoLnJhbmRvbSgpKihhLnN3YXlBbXBNYXgtYS5zd2F5QW1wTWluKSx1W21dPU1hdGgucmFuZG9tKCkqTWF0aC5QSSoyLGhbbV09LjAxK01hdGgucmFuZG9tKCkqLjAyfWNvbnN0IGY9bmV3IEN0O2Yuc2V0QXR0cmlidXRlKCJwb3NpdGlvbiIsbmV3IFN0KG8sMykpO2NvbnN0IHA9KGEuc2l6ZU1pbithLnNpemVNYXgpLzIsXz1uZXcgUmkoe21hcDpyLHRyYW5zcGFyZW50OiEwLG9wYWNpdHk6YS5vcGFjaXR5KihpLm9wYWNpdHkvMTAwKSxzaXplQXR0ZW51YXRpb246ITEsc2l6ZTpwKi4xNSxjb2xvcjoxNjc3NzIxNSxkZXB0aFdyaXRlOiExLGRlcHRoVGVzdDohMSxibGVuZGluZzoyfSkseD1uZXcgbXIoZixfKTtyZXR1cm4geC5mcnVzdHVtQ3VsbGVkPSExLGUuYWRkKHgpLHtnZW86ZixtYXQ6XyxmYWxsU3BlZWRzOmwsc3dheUFtcHM6Yyxzd2F5T2Zmc2V0czp1LHN3YXlTcGVlZHM6aCxiYXNlT3BhY2l0eTphLm9wYWNpdHl9fSk7cmV0dXJue2dyb3VwOmUsdXBkYXRlKGEpe3MuZm9yRWFjaChvPT57Y29uc3QgbD1vLmdlby5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5LGM9YSo2MDtmb3IobGV0IHU9MDt1PGwubGVuZ3RoLzM7dSsrKXtjb25zdCBoPXUqMztvLnN3YXlPZmZzZXRzW3VdKz1vLnN3YXlTcGVlZHNbdV07Y29uc3QgZj1NYXRoLnNpbihvLnN3YXlPZmZzZXRzW3VdKSpvLnN3YXlBbXBzW3VdKi4wODtsW2hdKz1mKmMsbFtoKzFdLT1vLmZhbGxTcGVlZHNbdV0qYztjb25zdCBwPWkudmlld1dpZHRoLzIrMTUsXz1pLnZpZXdIZWlnaHQvMisxNTtsW2grMV08LV8mJihsW2grMV09XyxsW2hdPSRlLnJhbmRGbG9hdFNwcmVhZChpLnZpZXdXaWR0aCsyMCkpLGxbaF08LXAmJihsW2hdPXApLGxbaF0+cCYmKGxbaF09LXApfW8uZ2VvLmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGU9ITB9KX0sc2V0T3BhY2l0eShhKXtjb25zdCBvPU1hdGgubWF4KDAsTWF0aC5taW4oMSxhLzEwMCkpO3MuZm9yRWFjaChsPT57bC5tYXQub3BhY2l0eT1sLmJhc2VPcGFjaXR5Km99KX0sb25SZXNpemUoYSxvKXtpLnZpZXdXaWR0aD1hLGkudmlld0hlaWdodD1vfSxkaXNwb3NlKCl7cy5mb3JFYWNoKGE9PnthLmdlby5kaXNwb3NlKCksYS5tYXQuZGlzcG9zZSgpfSksci5kaXNwb3NlKCl9fX1jb25zdCBPcz1bIuWckiIsIui/jiIsIuewoSIsIuebiiIsIuWkpyIsIuivtiIsIuavlCIsIuilvyIsIui/qiIsIuS8iiIsIuW8lyIsIuWQiSIsIuWwuiIsIuadsCIsIuW8gCIsIuiJviIsIuWLkiIsIumprCIsIuWonCJdLEp1PSIjMDBmZjQxIixRdT0iIzAwY2MzMyIsZWg9ODU7ZnVuY3Rpb24gdGgoaSl7Y29uc3QgZT1uZXcgcHQsdD1NYXRoLm1heCgyNTYsTWF0aC5mbG9vcihpLnZpZXdwb3J0V2lkdGgvMikpLG49TWF0aC5tYXgoMjU2LE1hdGguZmxvb3IoaS52aWV3cG9ydEhlaWdodC8yKSkse2NhbnZhczpyLGN0eDpzfT1MaSh0LG4pLGE9VWkocik7YS5taW5GaWx0ZXI9MTAwNixhLm1hZ0ZpbHRlcj0xMDA2O2NvbnN0IG89bmV3IHR0KGkudmlld1dpZHRoLGkudmlld0hlaWdodCksbD1uZXcgam4oe21hcDphLHRyYW5zcGFyZW50OiEwLG9wYWNpdHk6LjkqKGkub3BhY2l0eS8xMDApLGRlcHRoV3JpdGU6ITF9KSxjPW5ldyBzdChvLGwpO2UuYWRkKGMpO2NvbnN0IHU9W107bGV0IGg9MDtyZXR1cm57Z3JvdXA6ZSx1cGRhdGUoZil7Y29uc3QgcD1yLndpZHRoLF89ci5oZWlnaHQseD1wL2kudmlld3BvcnRXaWR0aDtoKz1mKjFlMztjb25zdCBtPV8vMyxkPXUuc29tZShNPT5NLnk+bSk7aWYoKHUubGVuZ3RoPT09MHx8ZCkmJmg+PS44JiZ1Lmxlbmd0aDw2KXtoPTA7Y29uc3QgTT1wKi4yOCxGPXAqLjcyO2xldCBiPTE1LHc7ZG97dz1NYXRoLnJhbmRvbSgpPC41PzMwK01hdGgucmFuZG9tKCkqKE0tNjApOkYrMzArTWF0aC5yYW5kb20oKSoocC1GLTYwKTtjb25zdCBFPWVoKihwL2kudmlld3BvcnRXaWR0aCk7aWYoIXUuc29tZShSPT5NYXRoLmFicyhSLngtdyk8RSkpYnJlYWt9d2hpbGUoLS1iPjApO2lmKGI+MCl7Y29uc3QgVT00K01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo4KTt1LnB1c2goe3g6dyx5Oi04MCxjaGFyczpBcnJheS5mcm9tKHtsZW5ndGg6VX0sKCk9Pk9zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpPcy5sZW5ndGgpXSksc3BlZWQ6KC4xNStNYXRoLnJhbmRvbSgpKi4xMikqeH0pfX1zLmZpbGxTdHlsZT0icmdiYSgwLDAsMCwwLjA4KSIscy5maWxsUmVjdCgwLDAscCxfKSxzLmZvbnQ9YCR7TWF0aC5tYXgoMTIsMTYqeCl9cHggbW9ub3NwYWNlYCxzLnRleHRBbGlnbj0iY2VudGVyIixzLnRleHRCYXNlbGluZT0idG9wIjtjb25zdCBUPXAvMjtmb3IobGV0IE09dS5sZW5ndGgtMTtNPj0wO00tLSl7Y29uc3QgRj11W01dO2lmKEYueSs9Ri5zcGVlZCxGLnk+XysxNTApe3Uuc3BsaWNlKE0sMSk7Y29udGludWV9Y29uc3QgYj1NYXRoLmFicyhGLngtVCksdz1iPHAqLjI/LjUrYi8ocCouMikqLjQ6LjksVT0xNip4O2ZvcihsZXQgRT0wO0U8Ri5jaGFycy5sZW5ndGg7RSsrKXtjb25zdCBTPTEtRS9GLmNoYXJzLmxlbmd0aCouNTtzLmdsb2JhbEFscGhhPVMqdyxzLmZpbGxTdHlsZT1FPT09MD9KdTpRdSxzLmZpbGxUZXh0KEYuY2hhcnNbRV0sRi54LEYueStFKlUpfXMuZ2xvYmFsQWxwaGE9MX1hLm5lZWRzVXBkYXRlPSEwfSxzZXRPcGFjaXR5KGYpe2wub3BhY2l0eT0uOSpNYXRoLm1heCgwLE1hdGgubWluKDEsZi8xMDApKX0sb25SZXNpemUoZixwKXtpLnZpZXdXaWR0aD1mLGkudmlld0hlaWdodD1wLGMuZ2VvbWV0cnkuZGlzcG9zZSgpLGMuZ2VvbWV0cnk9bmV3IHR0KGYscCl9LGRpc3Bvc2UoKXtvLmRpc3Bvc2UoKSxsLmRpc3Bvc2UoKSxhLmRpc3Bvc2UoKX19fWZ1bmN0aW9uIG5oKGkpe3JldHVybiBNYXRoLmZsb29yKGk/NDAwKi42OjQwMCl9ZnVuY3Rpb24gaWgoaSl7Y29uc3QgZT1uZXcgcHQsdD1uaChpLmlzTW9iaWxlKSxuPW5ldyBGbG9hdDMyQXJyYXkodCozKSxyPWkubW9vblBvc2l0aW9uO2ZvcihsZXQgaD0wO2g8dDtoKyspe2NvbnN0IGY9aCozO25bZl09JGUucmFuZEZsb2F0U3ByZWFkKGkudmlld1dpZHRoKzIwKSxuW2YrMV09JGUucmFuZEZsb2F0U3ByZWFkKGkudmlld0hlaWdodCsyMCksbltmKzJdPU1hdGgucmFuZG9tKCkqMi0xfWNvbnN0IHM9bmV3IEN0O3Muc2V0QXR0cmlidXRlKCJwb3NpdGlvbiIsbmV3IFN0KG4sMykpO2NvbnN0IGE9WHUoKSxvPW5ldyBSaSh7bWFwOmEsdHJhbnNwYXJlbnQ6ITAsb3BhY2l0eTouODUqKGkub3BhY2l0eS8xMDApLHNpemVBdHRlbnVhdGlvbjohMSxzaXplOjIsY29sb3I6MTUyNjcwNzEsZGVwdGhXcml0ZTohMSxkZXB0aFRlc3Q6ITEsYmxlbmRpbmc6Mn0pLGw9bmV3IG1yKHMsbyk7bC5mcnVzdHVtQ3VsbGVkPSExLGUuYWRkKGwpO2xldCBjPW51bGw7aWYociYmdHlwZW9mIHIueD09Im51bWJlciImJnR5cGVvZiByLnk9PSJudW1iZXIiKXtjb25zdCBoPShyLngtLjUpKmkudmlld1dpZHRoLGY9KC41LXIueSkqaS52aWV3SGVpZ2h0LHA9TWF0aC5tYXgoaS52aWV3V2lkdGgsaS52aWV3SGVpZ2h0KSouNDUsXz1uZXcgdHQocCxwKSx4PW5ldyBodCh7dW5pZm9ybXM6e3VPcGFjaXR5Ont2YWx1ZTouMjIqKGkub3BhY2l0eS8xMDApfX0sdmVydGV4U2hhZGVyOiJ2YXJ5aW5nIHZlYzIgdlV2OyB2b2lkIG1haW4oKSB7IHZVdiA9IHV2OyBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApOyB9IixmcmFnbWVudFNoYWRlcjpgCiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjsKICAgICAgICB1bmlmb3JtIGZsb2F0IHVPcGFjaXR5OwogICAgICAgIHZvaWQgbWFpbigpIHsKICAgICAgICAgIHZlYzIgYyA9IHZVdiAtIDAuNTsKICAgICAgICAgIGZsb2F0IGQgPSBsZW5ndGgoYykgKiAyLjA7CiAgICAgICAgICBmbG9hdCBhbHBoYSA9IGV4cCgtZCAqIGQgKiAyLjgpICogdU9wYWNpdHk7CiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuOTYsIDAuOTcsIDEuMCwgYWxwaGEpOwogICAgICAgIH0KICAgICAgYCx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExLGJsZW5kaW5nOjJ9KTtjPW5ldyBzdChfLHgpLGMucG9zaXRpb24uc2V0KGgsZiwtMSksYy5yZW5kZXJPcmRlcj0xLGUuYWRkKGMpfWxldCB1PTA7cmV0dXJue2dyb3VwOmUsdXBkYXRlKGgpe3UrPWgqMS4yLG8ub3BhY2l0eT0uODUqKGkub3BhY2l0eS8xMDApKiguOCsuMipNYXRoLnNpbih1KSl9LHNldE9wYWNpdHkoaCl7by5vcGFjaXR5PS44NSpNYXRoLm1heCgwLE1hdGgubWluKDEsaC8xMDApKX0sb25SZXNpemUoaCxmKXtpLnZpZXdXaWR0aD1oLGkudmlld0hlaWdodD1mfSxkaXNwb3NlKCl7cy5kaXNwb3NlKCksby5kaXNwb3NlKCksYS5kaXNwb3NlKCksYyYmKGMuZ2VvbWV0cnkuZGlzcG9zZSgpLGMubWF0ZXJpYWwuZGlzcG9zZSgpKX19fWNvbnN0IHJoPTU1O2Z1bmN0aW9uIHNoKGkpe2NvbnN0IGU9aS52aWV3V2lkdGgsdD1pLnZpZXdIZWlnaHQse2NhbnZhczpuLGN0eDpyfT1MaShNYXRoLm1heCgyNTYsTWF0aC5mbG9vcihpLnZpZXdwb3J0V2lkdGgvMikpLE1hdGgubWF4KDI1NixNYXRoLmZsb29yKGkudmlld3BvcnRIZWlnaHQvMikpKSxzPVVpKG4pO3MubWluRmlsdGVyPTEwMDYscy5tYWdGaWx0ZXI9MTAwNjtjb25zdCBhPW5ldyB0dChlLHQpLG89bmV3IGpuKHttYXA6cyx0cmFuc3BhcmVudDohMCxvcGFjaXR5Oi45NSooaS5vcGFjaXR5LzEwMCksZGVwdGhXcml0ZTohMX0pLGw9bmV3IHN0KGEsbyk7bC5yZW5kZXJPcmRlcj01O2NvbnN0IGM9bmV3IHB0O2MuYWRkKGwpO2NvbnN0IHU9W107bGV0IGg9MCxmPTA7ZnVuY3Rpb24gcCh4LG0sZCl7Zm9yKGNvbnN0IEEgb2YgdSl7Y29uc3QgVD14LUEueCxNPW0tQS55LEY9cmgrKGQrQS5zaXplKSouNTtpZihUKlQrTSpNPEYqRilyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBfKCl7cmV0dXJuIDIyMDArTWF0aC5yYW5kb20oKSoyODAwfXJldHVybntncm91cDpjLHVwZGF0ZSh4KXtjb25zdCBtPW4ud2lkdGgsZD1uLmhlaWdodCxBPU1hdGgubWluKHgqMWUzLDUwKTtpZihoKz1BLGY8PTAmJihmPV8oKSksaD49Zil7aD0wLGY9XygpO2NvbnN0IFQ9LjE4LE09bSpULEY9bSooMS1UKSxiPU1hdGgucmFuZG9tKCk8LjU/ImxlZnQiOiJyaWdodCIsdz00K01hdGgucmFuZG9tKCkqNjtsZXQgVSxFLFM9MTI7ZG8gVT1iPT09ImxlZnQiP01hdGgucmFuZG9tKCkqTTpGK01hdGgucmFuZG9tKCkqKG0tRiksRT1NYXRoLnJhbmRvbSgpKmQqLjU1O3doaWxlKC0tUz4wJiZwKFUsRSx3KSk7Uz4wJiZ1LnB1c2goe3g6VSx5OkUsc2l6ZTp3LHBoYXNlOiJhcHBlYXIiLG9wYWNpdHk6MCxsaWZlOjAsYXBwZWFyRHVyOjMwMCxyZXN0RHVyOjJlMytNYXRoLnJhbmRvbSgpKjI1MDAsc2xpZGVWZWw6OCtNYXRoLnJhbmRvbSgpKjYsc2xpZGVBY2NlbDouOCtNYXRoLnJhbmRvbSgpKi42fSl9ci5jbGVhclJlY3QoMCwwLG0sZCk7Zm9yKGxldCBUPXUubGVuZ3RoLTE7VD49MDtULS0pe2NvbnN0IE09dVtUXTtpZihNLmxpZmUrPUEsTS5waGFzZT09PSJhcHBlYXIiKU0ub3BhY2l0eT1NYXRoLm1pbigxLE0ubGlmZS9NLmFwcGVhckR1cioxLjgpLE0ubGlmZT49TS5hcHBlYXJEdXImJihNLnBoYXNlPSJyZXN0IixNLmxpZmU9MCxNLm9wYWNpdHk9MSk7ZWxzZSBpZihNLnBoYXNlPT09InJlc3QiKU0ubGlmZT49TS5yZXN0RHVyJiYoTS5waGFzZT0ic2xpZGUiLE0ubGlmZT0wKTtlbHNle2NvbnN0IEY9QS8xZTM7TS5zbGlkZVZlbD0oTS5zbGlkZVZlbHx8OCkrTS5zbGlkZUFjY2VsKkYqNjAsTS55Kz1NLnNsaWRlVmVsKkY7Y29uc3QgYj1NLnkvZDtpZihNLm9wYWNpdHk9YjwuODU/MTpNYXRoLm1heCgwLCgxLWIpLy4xNSksTS55PmQrTS5zaXplKjIpe3Uuc3BsaWNlKFQsMSk7Y29udGludWV9fWlmKE0ueTw9ZCtNLnNpemUqMil7ci5zYXZlKCksci5nbG9iYWxBbHBoYT1NLm9wYWNpdHk7Y29uc3QgRj1yLmNyZWF0ZVJhZGlhbEdyYWRpZW50KE0ueC1NLnNpemUqLjMsTS55LU0uc2l6ZSouMywwLE0ueCxNLnksTS5zaXplKjEuNSk7Ri5hZGRDb2xvclN0b3AoMCwicmdiYSgyMzAsIDI0MCwgMjU1LCAwLjc1KSIpLEYuYWRkQ29sb3JTdG9wKC4zNSwicmdiYSgyMDAsIDIxOCwgMjQyLCAwLjU1KSIpLEYuYWRkQ29sb3JTdG9wKC43LCJyZ2JhKDE3MCwgMTkwLCAyMTUsIDAuMjUpIiksRi5hZGRDb2xvclN0b3AoMSwicmdiYSgxNTAsIDE3MCwgMTk1LCAwKSIpLHIuZmlsbFN0eWxlPUYsci5iZWdpblBhdGgoKSxyLmVsbGlwc2UoTS54LE0ueSxNLnNpemUqLjUsTS5zaXplKjEuMSwwLDAsTWF0aC5QSSoyKSxyLmZpbGwoKSxyLnJlc3RvcmUoKX19cy5uZWVkc1VwZGF0ZT0hMH0sc2V0T3BhY2l0eSh4KXtvLm9wYWNpdHk9Ljk1Kk1hdGgubWF4KDAsTWF0aC5taW4oMSx4LzEwMCkpfSxkaXNwb3NlKCl7YS5kaXNwb3NlKCksby5kaXNwb3NlKCkscy5kaXNwb3NlKCl9fX1mdW5jdGlvbiBhaChpKXtjb25zdCBlPWkudmlld1dpZHRoLHQ9aS52aWV3SGVpZ2h0LG49bmV3IHR0KGUsdCkscj17dVRpbWU6e3ZhbHVlOjB9LHVPcGFjaXR5Ont2YWx1ZTouMTgqKGkub3BhY2l0eS8xMDApfSx1U2NhbGU6e3ZhbHVlOjEuNH0sdVJlc29sdXRpb246e3ZhbHVlOm5ldyBMZShlLHQpfX0scz1uZXcgaHQoe3VuaWZvcm1zOnIsdmVydGV4U2hhZGVyOmdyLGZyYWdtZW50U2hhZGVyOmAKICAgICAgdmFyeWluZyB2ZWMyIHZVdjsKICAgICAgdW5pZm9ybSBmbG9hdCB1VGltZTsKICAgICAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTsKICAgICAgdW5pZm9ybSBmbG9hdCB1U2NhbGU7CiAgICAgIHVuaWZvcm0gdmVjMiB1UmVzb2x1dGlvbjsKICAgICAgZmxvYXQgaGFzaCh2ZWMyIHApIHsgcmV0dXJuIGZyYWN0KHNpbihkb3QocCwgdmVjMigxMjcuMSwgMzExLjcpKSkgKiA0Mzc1OC41NDUzKTsgfQogICAgICBmbG9hdCBub2lzZSh2ZWMyIHApIHsKICAgICAgICB2ZWMyIGkgPSBmbG9vcihwKTsKICAgICAgICB2ZWMyIGYgPSBmcmFjdChwKTsKICAgICAgICB2ZWMyIHUgPSBmICogZiAqICgzLjAgLSAyLjAgKiBmKTsKICAgICAgICByZXR1cm4gbWl4KG1peChoYXNoKGkpLCBoYXNoKGkgKyB2ZWMyKDEsMCkpLCB1LngpLCBtaXgoaGFzaChpICsgdmVjMigwLDEpKSwgaGFzaChpICsgdmVjMigxLDEpKSwgdS54KSwgdS55KTsKICAgICAgfQogICAgICBmbG9hdCBmYm0odmVjMiBwKSB7CiAgICAgICAgZmxvYXQgdiA9IDAuMCwgYW1wID0gMC41OwogICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgNDsgaSsrKSB7CiAgICAgICAgICB2ICs9IGFtcCAqIG5vaXNlKHApOwogICAgICAgICAgcCAqPSAyLjA7CiAgICAgICAgICBhbXAgKj0gMC41OwogICAgICAgIH0KICAgICAgICByZXR1cm4gdjsKICAgICAgfQogICAgICB2b2lkIG1haW4oKSB7CiAgICAgICAgdmVjMiBhc3BlY3QgPSB2ZWMyKHVSZXNvbHV0aW9uLnggLyBtYXgodVJlc29sdXRpb24ueSwgMC4wMDAxKSwgMS4wKTsKICAgICAgICB2ZWMyIHV2ID0gKHZVdiAtIDAuNSkgKiBhc3BlY3QgKyAwLjU7CiAgICAgICAgdXYgKj0gdVNjYWxlOwogICAgICAgIHV2ICs9IHZlYzIoMC4wMiwgLTAuMDQpICogdVRpbWU7CiAgICAgICAgZmxvYXQgZCA9IGZibSh1dik7CiAgICAgICAgZCA9IHNtb290aHN0ZXAoMC4yLCAwLjY1LCBkKTsKICAgICAgICBmbG9hdCB2TWFzayA9IHNtb290aHN0ZXAoMC4wLCAwLjU1LCB2VXYueSk7CiAgICAgICAgdmVjMyBjb2xvciA9IHZlYzMoMC41NSwgMC41MiwgMC40OCk7CiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgZCAqIHZNYXNrICogdU9wYWNpdHkpOwogICAgICB9CiAgICBgLHRyYW5zcGFyZW50OiEwLGRlcHRoV3JpdGU6ITEsYmxlbmRpbmc6MX0pLGE9bmV3IHN0KG4scyk7YS5yZW5kZXJPcmRlcj0xMDtjb25zdCBvPW5ldyBwdDtyZXR1cm4gby5hZGQoYSkse2dyb3VwOm8sdXBkYXRlKGwpe3IudVRpbWUudmFsdWUrPWwqLjE1fSxzZXRPcGFjaXR5KGwpe3IudU9wYWNpdHkudmFsdWU9LjE4Kk1hdGgubWF4KDAsTWF0aC5taW4oMSxsLzEwMCkpfSxkaXNwb3NlKCl7bi5kaXNwb3NlKCkscy5kaXNwb3NlKCl9fX1mdW5jdGlvbiBvaChpLGUpe2NvbnN0IHQ9aT09PSJmb2dfZGVuc2UiLG49dD8uMjI1Oi4xMSxyPWU/Ljg1OjEscz10P1t7c2NhbGU6MSpyLHNwZWVkOi4yOCxpbnRlbnNpdHk6MSxmbG93Om5ldyBMZSguMDgsLjAyKSxsb3c6LjI1LGhpZ2g6Ljc4LGNvbnRyYXN0OjEuMSxjb2xvcjpbLjg2LC44OSwuOTVdfSx7c2NhbGU6MS42KnIsc3BlZWQ6LjM2LGludGVuc2l0eTouODUsZmxvdzpuZXcgTGUoLS4wNSwuMDI1KSxsb3c6LjIsaGlnaDouNyxjb250cmFzdDoxLjIyLGNvbG9yOlsuOSwuOTIsLjk3XX1dOlt7c2NhbGU6MS4yKnIsc3BlZWQ6LjIyLGludGVuc2l0eTouNzUsZmxvdzpuZXcgTGUoLjA1LC4wMTUpLGxvdzouMyxoaWdoOi44Mixjb250cmFzdDoxLjE1LGNvbG9yOlsuODgsLjkxLC45Nl19LHtzY2FsZToxLjkqcixzcGVlZDouMyxpbnRlbnNpdHk6LjU1LGZsb3c6bmV3IExlKC0uMDMsLjAxMiksbG93Oi4yNSxoaWdoOi43NSxjb250cmFzdDoxLjIyLGNvbG9yOlsuOCwuODQsLjkyXX1dO3JldHVybntiYXNlT3BhY2l0eTpuLGxheWVyczpzfX1jb25zdCBsaD1gCiAgdmFyeWluZyB2ZWMyIHZVdjsKICB1bmlmb3JtIGZsb2F0IHVUaW1lOwogIHVuaWZvcm0gZmxvYXQgdU9wYWNpdHk7CiAgdW5pZm9ybSBmbG9hdCB1U2NhbGU7CiAgdW5pZm9ybSB2ZWMyIHVGbG93OwogIHVuaWZvcm0gdmVjMiB1UmVzb2x1dGlvbjsKICB1bmlmb3JtIGZsb2F0IHVMb3c7CiAgdW5pZm9ybSBmbG9hdCB1SGlnaDsKICB1bmlmb3JtIGZsb2F0IHVDb250cmFzdDsKICB1bmlmb3JtIHZlYzMgdUNvbG9yOwogIGZsb2F0IGhhc2godmVjMiBwKSB7IHJldHVybiBmcmFjdChzaW4oZG90KHAsIHZlYzIoMTI3LjEsIDMxMS43KSkpICogNDM3NTguNTQ1MzEyMyk7IH0KICBmbG9hdCBub2lzZSh2ZWMyIHApIHsKICAgIHZlYzIgaSA9IGZsb29yKHApOwogICAgdmVjMiBmID0gZnJhY3QocCk7CiAgICB2ZWMyIHUgPSBmICogZiAqICgzLjAgLSAyLjAgKiBmKTsKICAgIHJldHVybiBtaXgoCiAgICAgIG1peChoYXNoKGkpLCBoYXNoKGkgKyB2ZWMyKDEsMCkpLCB1LngpLAogICAgICBtaXgoaGFzaChpICsgdmVjMigwLDEpKSwgaGFzaChpICsgdmVjMigxLDEpKSwgdS54KSwgdS55KTsKICB9CiAgZmxvYXQgZmJtKHZlYzIgcCkgewogICAgZmxvYXQgdiA9IDAuMCwgYW1wID0gMC41OwogICAgZm9yIChpbnQgaSA9IDA7IGkgPCA1OyBpKyspIHsKICAgICAgdiArPSBhbXAgKiBub2lzZShwKTsKICAgICAgcCAqPSAyLjA7CiAgICAgIGFtcCAqPSAwLjU7CiAgICB9CiAgICByZXR1cm4gdjsKICB9CiAgdm9pZCBtYWluKCkgewogICAgdmVjMiBhc3BlY3QgPSB2ZWMyKHVSZXNvbHV0aW9uLnggLyBtYXgodVJlc29sdXRpb24ueSwgMC4wMDAxKSwgMS4wKTsKICAgIHZlYzIgdXYgPSAodlV2IC0gMC41KSAqIGFzcGVjdCArIDAuNTsKICAgIHV2ICo9IHVTY2FsZTsKICAgIHV2ICs9IHVGbG93ICogdVRpbWU7CiAgICBmbG9hdCBwcmltYXJ5ID0gZmJtKHV2KTsKICAgIGZsb2F0IGRldGFpbCA9IGZibSh1diAqIDEuOCAtIHVGbG93Lnl4ICogKHVUaW1lICogMC4zNSkpOwogICAgZmxvYXQgZGVuc2l0eSA9IG1peChwcmltYXJ5LCBkZXRhaWwsIDAuMzUpOwogICAgZGVuc2l0eSA9IHNtb290aHN0ZXAodUxvdywgdUhpZ2gsIGRlbnNpdHkpOwogICAgZGVuc2l0eSA9IHBvdyhkZW5zaXR5LCB1Q29udHJhc3QpOwogICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh1Q29sb3IsIGRlbnNpdHkgKiB1T3BhY2l0eSk7CiAgfQpgO2Z1bmN0aW9uIGNoKGkpe2NvbnN0IGU9bmV3IHB0LHQ9b2goaS5lZmZlY3QsaS5pc01vYmlsZSksbj10LmxheWVycy5tYXAocj0+e2NvbnN0IHM9bmV3IHR0KGkudmlld1dpZHRoLGkudmlld0hlaWdodCksYT17dVRpbWU6e3ZhbHVlOjB9LHVPcGFjaXR5Ont2YWx1ZTp0LmJhc2VPcGFjaXR5KnIuaW50ZW5zaXR5KihpLm9wYWNpdHkvMTAwKX0sdVNjYWxlOnt2YWx1ZTpyLnNjYWxlfSx1Rmxvdzp7dmFsdWU6ci5mbG93LmNsb25lKCl9LHVSZXNvbHV0aW9uOnt2YWx1ZTpuZXcgTGUoaS52aWV3V2lkdGgsaS52aWV3SGVpZ2h0KX0sdUxvdzp7dmFsdWU6ci5sb3d9LHVIaWdoOnt2YWx1ZTpyLmhpZ2h9LHVDb250cmFzdDp7dmFsdWU6ci5jb250cmFzdH0sdUNvbG9yOnt2YWx1ZTpuZXcgVmUoci5jb2xvclswXSxyLmNvbG9yWzFdLHIuY29sb3JbMl0pfX0sbz1uZXcgaHQoe3VuaWZvcm1zOmEsdmVydGV4U2hhZGVyOmdyLGZyYWdtZW50U2hhZGVyOmxoLHRyYW5zcGFyZW50OiEwLGRlcHRoV3JpdGU6ITEsYmxlbmRpbmc6MX0pLGw9bmV3IHN0KHMsbyk7cmV0dXJuIGwucmVuZGVyT3JkZXI9LTMsZS5hZGQobCkse21lc2g6bCx1bmlmb3JtczphLGNvbmZpZzpyfX0pO3JldHVybntncm91cDplLHVwZGF0ZShyKXtuLmZvckVhY2gocz0+e3MudW5pZm9ybXMudVRpbWUudmFsdWUrPXIqcy5jb25maWcuc3BlZWR9KX0sc2V0T3BhY2l0eShyKXtjb25zdCBzPU1hdGgubWF4KDAsTWF0aC5taW4oMSxyLzEwMCkpLGE9aS5pc01vYmlsZT8uNzU6MTtuLmZvckVhY2gobz0+e28udW5pZm9ybXMudU9wYWNpdHkudmFsdWU9dC5iYXNlT3BhY2l0eSpvLmNvbmZpZy5pbnRlbnNpdHkqcyphfSl9LG9uUmVzaXplKHIscyl7aS52aWV3V2lkdGg9cixpLnZpZXdIZWlnaHQ9cyxuLmZvckVhY2goYT0+e2EudW5pZm9ybXMudVJlc29sdXRpb24udmFsdWUuc2V0KHIscyksYS5tZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKSxhLm1lc2guZ2VvbWV0cnk9bmV3IHR0KHIscyl9KX0sZGlzcG9zZSgpe24uZm9yRWFjaChyPT57ci5tZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKSxyLm1lc2gubWF0ZXJpYWwuZGlzcG9zZSgpfSl9fX1mdW5jdGlvbiB1aChpKXtjb25zdCBlPW5ldyBwdDtsZXQgdD1uZXcgdHQoaS52aWV3V2lkdGgsaS52aWV3SGVpZ2h0KTtjb25zdCBuPXt1VGltZTp7dmFsdWU6MH0sdU9wYWNpdHk6e3ZhbHVlOmkub3BhY2l0eS8xMDB9LHVWaWV3U2l6ZTp7dmFsdWU6bmV3IExlKGkudmlld1dpZHRoLGkudmlld0hlaWdodCl9fSxyPW5ldyBodCh7dW5pZm9ybXM6bix2ZXJ0ZXhTaGFkZXI6InZhcnlpbmcgdmVjMyB2UG9zaXRpb247IHZvaWQgbWFpbigpIHsgdlBvc2l0aW9uID0gcG9zaXRpb247IGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7IH0iLGZyYWdtZW50U2hhZGVyOmAKICAgICAgdmFyeWluZyB2ZWMzIHZQb3NpdGlvbjsKICAgICAgdW5pZm9ybSB2ZWMyIHVWaWV3U2l6ZTsKICAgICAgdW5pZm9ybSBmbG9hdCB1VGltZTsKICAgICAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTsKICAgICAgdm9pZCBtYWluKCkgewogICAgICAgIHZlYzIgdXYgPSB2ZWMyKCh2UG9zaXRpb24ueCAvIHVWaWV3U2l6ZS54KSArIDAuNSwgKHZQb3NpdGlvbi55IC8gdVZpZXdTaXplLnkpICsgMC41KTsKICAgICAgICB2ZWMyIG9yaWdpbiA9IHZlYzIoMS4xLCAxLjA1KTsKICAgICAgICB2ZWMyIGRpciA9IG9yaWdpbiAtIHV2OwogICAgICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgoZGlyKTsKICAgICAgICBmbG9hdCBhbmdsZSA9IGF0YW4oZGlyLnksIGRpci54KTsKICAgICAgICBmbG9hdCBiZWFtcyA9IHNpbihhbmdsZSAqIDE4LjAgKyB1VGltZSAqIDAuOCkgKiAwLjUgKyAwLjU7CiAgICAgICAgZmxvYXQgaW50ZW5zaXR5ID0gc21vb3Roc3RlcCgwLjYsIDAuMCwgZGlzdCkgKiBiZWFtczsKICAgICAgICBmbG9hdCBhbHBoYSA9IGludGVuc2l0eSAqIDAuNjUgKiB1T3BhY2l0eTsKICAgICAgICB2ZWMzIGNvbG9yID0gbWl4KHZlYzMoMS4wLCAwLjk1LCAwLjgpLCB2ZWMzKDEuMCwgMC44NSwgMC40KSwgZGlzdCk7CiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgYWxwaGEpOwogICAgICB9CiAgICBgLHRyYW5zcGFyZW50OiEwLGRlcHRoV3JpdGU6ITEsYmxlbmRpbmc6Mn0pLHM9bmV3IHN0KHQscik7cmV0dXJuIHMucG9zaXRpb24uc2V0KDAsMCwtMiksZS5hZGQocykse2dyb3VwOmUsdXBkYXRlKGEpe24udVRpbWUudmFsdWUrPWF9LHNldE9wYWNpdHkoYSl7bi51T3BhY2l0eS52YWx1ZT1NYXRoLm1heCgwLE1hdGgubWluKDEsYS8xMDApKX0sb25SZXNpemUoYSxvKXtpLnZpZXdXaWR0aD1hLGkudmlld0hlaWdodD1vLG4udVZpZXdTaXplLnZhbHVlLnNldChhLG8pLHQuZGlzcG9zZSgpLHQ9bmV3IHR0KGEsbykscy5nZW9tZXRyeT10fSxkaXNwb3NlKCl7dC5kaXNwb3NlKCksci5kaXNwb3NlKCl9fX1mdW5jdGlvbiBoaChpKXtjb25zdCBlPW5ldyBwdCx0PS42O2xldCBuPW5ldyB0dChpLnZpZXdXaWR0aCxpLnZpZXdIZWlnaHQqdCk7Y29uc3Qgcj17dVRpbWU6e3ZhbHVlOjB9LHVPcGFjaXR5Ont2YWx1ZTppLm9wYWNpdHkvMTAwfSx1Vmlld1NpemU6e3ZhbHVlOm5ldyBMZShpLnZpZXdXaWR0aCxpLnZpZXdIZWlnaHQpfSx1U2NhbGU6e3ZhbHVlOmkuaXNNb2JpbGU/MS41OjF9fSxzPWAKICAgIHZhcnlpbmcgdmVjMiB2VXY7CiAgICB1bmlmb3JtIGZsb2F0IHVUaW1lOwogICAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTsKICAgIHVuaWZvcm0gZmxvYXQgdVNjYWxlOwogICAgZmxvYXQgaGFzaCh2ZWMyIHApIHsgcmV0dXJuIGZyYWN0KHNpbihkb3QocCwgdmVjMigxMi45ODk4LCA3OC4yMzMpKSkgKiA0Mzc1OC41NDUzKTsgfQogICAgZmxvYXQgbm9pc2UodmVjMiBwKSB7CiAgICAgIHZlYzIgaSA9IGZsb29yKHApOwogICAgICB2ZWMyIGYgPSBmcmFjdChwKTsKICAgICAgdmVjMiB1ID0gZiAqIGYgKiAoMy4wIC0gMi4wICogZik7CiAgICAgIHJldHVybiBtaXgobWl4KGhhc2goaSksIGhhc2goaSt2ZWMyKDEsMCkpLCB1LngpLCBtaXgoaGFzaChpK3ZlYzIoMCwxKSksIGhhc2goaSt2ZWMyKDEsMSkpLCB1LngpLCB1LnkpOwogICAgfQogICAgZmxvYXQgZmJtKHZlYzIgcCkgewogICAgICBmbG9hdCB2ID0gMC4wLCBhbXAgPSAwLjUsIGZyZXEgPSAxLjA7CiAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgNjsgaSsrKSB7CiAgICAgICAgdiArPSBhbXAgKiBub2lzZShwICogZnJlcSk7CiAgICAgICAgYW1wICo9IDAuNTsKICAgICAgICBmcmVxICo9IDIuMDsKICAgICAgfQogICAgICByZXR1cm4gdjsKICAgIH0KICAgIHZvaWQgbWFpbigpIHsKICAgICAgdmVjMiB1diA9IHZVdiAqIHVTY2FsZTsKICAgICAgZmxvYXQgdGltZSA9IHVUaW1lICogMC4wNTsKICAgICAgdmVjMiBxID0gdmVjMihmYm0odXYgKyB2ZWMyKHRpbWUgKiAwLjUsIHRpbWUgKiAwLjIpKSwgZmJtKHV2ICsgdmVjMigxLjApKSk7CiAgICAgIHZlYzIgciA9IHZlYzIoZmJtKHV2ICsgcSArIHZlYzIoMS43LCA5LjIpICsgMC4xNSAqIHRpbWUpLCBmYm0odXYgKyBxICsgdmVjMig4LjMsIDIuOCkgKyAwLjEyNiAqIHRpbWUpKTsKICAgICAgZmxvYXQgZiA9IGZibSh1diArIHIpOwogICAgICBmbG9hdCBjbG91ZCA9IHNtb290aHN0ZXAoMC4yLCAwLjcsIGYpOwogICAgICBjbG91ZCAqPSBzbW9vdGhzdGVwKDAuMCwgMC4zLCB2VXYueSk7CiAgICAgIGNsb3VkICo9IHNtb290aHN0ZXAoMS4wLCAwLjgsIHZVdi55KTsKICAgICAgZmxvYXQgc2hhZG93ID0gc21vb3Roc3RlcCgwLjMsIDAuNiwgZmJtKHV2ICogMi4wICsgciArIHZlYzIoMC41KSkpOwogICAgICB2ZWMzIGNvbG9yID0gbWl4KHZlYzMoMC44MSwgMC44MiwgMC44OSksIHZlYzMoMS4wKSwgc2hhZG93ICogMC44ICsgMC4yKTsKICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgY2xvdWQgKiB1T3BhY2l0eSAqIDAuMjQpOwogICAgfQogIGAsYT1uZXcgaHQoe3VuaWZvcm1zOnIsdmVydGV4U2hhZGVyOiJ2YXJ5aW5nIHZlYzIgdlV2OyB2b2lkIG1haW4oKSB7IHZVdiA9IHV2OyBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApOyB9IixmcmFnbWVudFNoYWRlcjpzLHRyYW5zcGFyZW50OiEwLGRlcHRoV3JpdGU6ITEsYmxlbmRpbmc6MX0pLG89bmV3IHN0KG4sYSk7cmV0dXJuIG8ucG9zaXRpb24uc2V0KDAsaS52aWV3SGVpZ2h0Ki4yNSwtNiksby5yZW5kZXJPcmRlcj0tMixlLmFkZChvKSx7Z3JvdXA6ZSx1cGRhdGUobCl7ci51VGltZS52YWx1ZSs9bH0sc2V0T3BhY2l0eShsKXtyLnVPcGFjaXR5LnZhbHVlPU1hdGgubWF4KDAsTWF0aC5taW4oMSxsLzEwMCkpfSxvblJlc2l6ZShsLGMsdSl7bi5kaXNwb3NlKCksbj1uZXcgdHQobCxjKnQpLG8uZ2VvbWV0cnk9bixyLnVWaWV3U2l6ZS52YWx1ZS5zZXQobCxjKSxyLnVTY2FsZS52YWx1ZT11PzEuNToxLG8ucG9zaXRpb24uc2V0KDAsYyouMjUsLTYpfSxkaXNwb3NlKCl7bi5kaXNwb3NlKCksYS5kaXNwb3NlKCl9fX1mdW5jdGlvbiBkaChpKXtjb25zdCBlPW5ldyBwdCx0PWAKICAgIHZhcnlpbmcgdmVjMiB2VXY7CiAgICB1bmlmb3JtIGZsb2F0IHVGbGFzaDsKICAgIHVuaWZvcm0gdmVjMiB1T3JpZ2luOwogICAgdW5pZm9ybSBmbG9hdCB1VGltZTsKICAgIGZsb2F0IGhhc2goZmxvYXQgbikgeyByZXR1cm4gZnJhY3Qoc2luKG4pICogNDM3NTguNTQ1Myk7IH0KICAgIGZsb2F0IGphZ2dlZExpbmUodmVjMiB1diwgZmxvYXQgYW5jaG9yLCBmbG9hdCBzZWVkKSB7CiAgICAgIGZsb2F0IHNlZ21lbnRzID0gOC4wOwogICAgICBmbG9hdCBwcm9ncmVzcyA9IGNsYW1wKDEuMCAtIHV2LnksIDAuMCwgMC45OTkpICogc2VnbWVudHM7CiAgICAgIGZsb2F0IGlkeCA9IGZsb29yKHByb2dyZXNzKTsKICAgICAgZmxvYXQgZnJhYyA9IGZyYWN0KHByb2dyZXNzKTsKICAgICAgZmxvYXQgb2Zmc2V0QSA9IGhhc2goc2VlZCArIGlkeCkgKiAwLjI0IC0gMC4xMjsKICAgICAgZmxvYXQgb2Zmc2V0QiA9IGhhc2goc2VlZCArIGlkeCArIDEuMCkgKiAwLjI0IC0gMC4xMjsKICAgICAgZmxvYXQgb2Zmc2V0ID0gbWl4KG9mZnNldEEsIG9mZnNldEIsIHNtb290aHN0ZXAoMC4wLCAxLjAsIGZyYWMpKTsKICAgICAgZmxvYXQgd2lkdGggPSBtaXgoMC4wMDYsIDAuMDIsIGhhc2goc2VlZCArIGlkeCAqIDEuNykpOwogICAgICBmbG9hdCB0YXJnZXQgPSBhbmNob3IgKyBvZmZzZXQ7CiAgICAgIGZsb2F0IGRpc3QgPSBhYnModXYueCAtIHRhcmdldCk7CiAgICAgIGZsb2F0IGludGVuc2l0eSA9IHNtb290aHN0ZXAod2lkdGgsIDAuMCwgZGlzdCk7CiAgICAgIGZsb2F0IGZhZGUgPSBzbW9vdGhzdGVwKDAuMCwgMC45LCAxLjAgLSB1di55KTsKICAgICAgcmV0dXJuIGludGVuc2l0eSAqIGZhZGU7CiAgICB9CiAgICB2b2lkIG1haW4oKSB7CiAgICAgIGZsb2F0IHNlZWQgPSBmbG9vcih1VGltZSAqIDExLjApOwogICAgICBmbG9hdCBjb3JlID0gamFnZ2VkTGluZSh2VXYsIHVPcmlnaW4ueCwgc2VlZCk7CiAgICAgIGZsb2F0IGhhbG8gPSBqYWdnZWRMaW5lKHZVdiwgdU9yaWdpbi54ICsgMC4wMDgsIHNlZWQgKyAyLjApICogMC40OwogICAgICBmbG9hdCBhbHBoYSA9IGNsYW1wKChjb3JlICsgaGFsbykgKiB1Rmxhc2gsIDAuMCwgMS4wKTsKICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDAuOTgsIDAuOSwgYWxwaGEpOwogICAgfQogIGAsbj17dUZsYXNoOnt2YWx1ZTowfSx1T3JpZ2luOnt2YWx1ZTpuZXcgTGUoLjg1LDEuMDUpfSx1VGltZTp7dmFsdWU6MH19O2xldCByPW5ldyB0dChpLnZpZXdXaWR0aCxpLnZpZXdIZWlnaHQpO2NvbnN0IHM9bmV3IGh0KHt1bmlmb3JtczpuLHZlcnRleFNoYWRlcjpncixmcmFnbWVudFNoYWRlcjp0LHRyYW5zcGFyZW50OiEwLGRlcHRoV3JpdGU6ITEsZGVwdGhUZXN0OiExLGJsZW5kaW5nOjJ9KSxhPW5ldyBzdChyLHMpO2EucG9zaXRpb24uc2V0KDAsMCwtNiksYS5yZW5kZXJPcmRlcj0yNSxlLmFkZChhKTtsZXQgbz1uZXcgdHQoaS52aWV3V2lkdGgsaS52aWV3SGVpZ2h0KTtjb25zdCBsPW5ldyBqbih7Y29sb3I6MTY3NzcyMTUsdHJhbnNwYXJlbnQ6ITAsb3BhY2l0eTowLGRlcHRoV3JpdGU6ITEsZGVwdGhUZXN0OiExLGJsZW5kaW5nOjJ9KSxjPW5ldyBzdChvLGwpO2MucG9zaXRpb24uc2V0KDAsMCwtOCksYy5yZW5kZXJPcmRlcj0zMCxlLmFkZChjKTtsZXQgdT0kZS5yYW5kRmxvYXQoMSwzKSxoPTAsZj0uMjU7Y29uc3QgcD1NYXRoLm1heCgwLE1hdGgubWluKDEsaS5vcGFjaXR5LzEwMCkpLF89KCk9PntmPSRlLnJhbmRGbG9hdCguMTgsLjMyKSxoPWYsbi51Rmxhc2gudmFsdWU9MSxuLnVPcmlnaW4udmFsdWUuc2V0KCRlLnJhbmRGbG9hdCguNiwuOTUpLCRlLnJhbmRGbG9hdCguODUsMS4wNSkpLGwub3BhY2l0eT1NYXRoLm1heChsLm9wYWNpdHksLjU1KnArLjE1KX07cmV0dXJue2dyb3VwOmUsdXBkYXRlKHgpe2lmKHUtPXgsdTw9MCYmKHU9JGUucmFuZEZsb2F0KDEuNSw0KSxfKCkpLG4udVRpbWUudmFsdWUrPXgsaD4wKXtoLT14O2NvbnN0IG09TWF0aC5tYXgoMCxoL01hdGgubWF4KGYsLjAwMSkpO24udUZsYXNoLnZhbHVlPU1hdGgucG93KG0sMS40KSpwfWVsc2Ugbi51Rmxhc2gudmFsdWU+MCYmKG4udUZsYXNoLnZhbHVlPU1hdGgubWF4KDAsbi51Rmxhc2gudmFsdWUteCo4KSk7bC5vcGFjaXR5PU1hdGgubWF4KDAsbC5vcGFjaXR5LXgqNil9LHNldE9wYWNpdHkoeCl7Y29uc3QgbT1NYXRoLm1heCgwLE1hdGgubWluKDEseC8xMDApKTtuLnVGbGFzaC52YWx1ZSo9bS9wfSxvblJlc2l6ZSh4LG0pe2kudmlld1dpZHRoPXgsaS52aWV3SGVpZ2h0PW0sci5kaXNwb3NlKCkscj1uZXcgdHQoeCxtKSxhLmdlb21ldHJ5PXIsby5kaXNwb3NlKCksbz1uZXcgdHQoeCxtKSxjLmdlb21ldHJ5PW99LGRpc3Bvc2UoKXtyLmRpc3Bvc2UoKSxzLmRpc3Bvc2UoKSxvLmRpc3Bvc2UoKSxsLmRpc3Bvc2UoKX19fWZ1bmN0aW9uIGZoKGkpe2NvbnN0IGU9bmV3IHB0LHQ9aS5pc01vYmlsZT8xMDoxNSxuPW5ldyB0dCguMjUsLjI1KSxyPW5ldyBVcztyLmluZGV4PW4uaW5kZXgsci5hdHRyaWJ1dGVzLnBvc2l0aW9uPW4uYXR0cmlidXRlcy5wb3NpdGlvbixyLmF0dHJpYnV0ZXMudXY9bi5hdHRyaWJ1dGVzLnV2LHIuaW5zdGFuY2VDb3VudD10O2NvbnN0IHM9bmV3IEZsb2F0MzJBcnJheSh0KjMpLGE9bmV3IEZsb2F0MzJBcnJheSh0KSxvPW5ldyBGbG9hdDMyQXJyYXkodCksbD1uZXcgRmxvYXQzMkFycmF5KHQpLGM9bmV3IEZsb2F0MzJBcnJheSh0KTtmb3IobGV0IHA9MDtwPHQ7cCsrKXtjb25zdCBfPXAqMztzW19dPSRlLnJhbmRGbG9hdFNwcmVhZChpLnZpZXdXaWR0aCsxMCksc1tfKzFdPSRlLnJhbmRGbG9hdFNwcmVhZChpLnZpZXdIZWlnaHQpLHNbXysyXT1NYXRoLnJhbmRvbSgpKjIsYVtwXT0kZS5yYW5kRmxvYXQoMi44LDQpLG9bcF09JGUucmFuZEZsb2F0KDEuOCwyLjgpLGxbcF09TWF0aC5yYW5kb20oKSpNYXRoLlBJKjIsY1twXT1NYXRoLnJhbmRvbSgpfXIuc2V0QXR0cmlidXRlKCJpbnN0YW5jZU9mZnNldCIsbmV3IEd0KHMsMykpLHIuc2V0QXR0cmlidXRlKCJpbnN0YW5jZVNwZWVkIixuZXcgR3QoYSwxKSksci5zZXRBdHRyaWJ1dGUoImluc3RhbmNlU2l6ZSIsbmV3IEd0KG8sMSkpLHIuc2V0QXR0cmlidXRlKCJpbnN0YW5jZVJvdGF0aW9uIixuZXcgR3QobCwxKSksci5zZXRBdHRyaWJ1dGUoImluc3RhbmNlUGhhc2UiLG5ldyBHdChjLDEpKTtjb25zdCB1PXt1VGltZTp7dmFsdWU6MH0sdU9wYWNpdHk6e3ZhbHVlOmkub3BhY2l0eS8xMDB9LHVWaWV3U2l6ZTp7dmFsdWU6bmV3IExlKGkudmlld1dpZHRoLGkudmlld0hlaWdodCl9fSxoPW5ldyBodCh7dW5pZm9ybXM6dSx2ZXJ0ZXhTaGFkZXI6YAogICAgICBhdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZU9mZnNldDsKICAgICAgYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlU3BlZWQ7CiAgICAgIGF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVNpemU7CiAgICAgIGF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVJvdGF0aW9uOwogICAgICBhdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VQaGFzZTsKICAgICAgdW5pZm9ybSBmbG9hdCB1VGltZTsKICAgICAgdW5pZm9ybSB2ZWMyIHVWaWV3U2l6ZTsKICAgICAgdmFyeWluZyBmbG9hdCB2QWxwaGE7CiAgICAgIHZvaWQgbWFpbigpIHsKICAgICAgICBmbG9hdCBwcm9ncmVzcyA9IGZyYWN0KHVUaW1lICogaW5zdGFuY2VTcGVlZCArIGluc3RhbmNlUGhhc2UpOwogICAgICAgIGZsb2F0IHRyYXZlbCA9ICh1Vmlld1NpemUueSAqIDAuNSkgLSBwcm9ncmVzcyAqICh1Vmlld1NpemUueSArIDIwLjApOwogICAgICAgIGZsb2F0IGFuZ2xlID0gaW5zdGFuY2VSb3RhdGlvbiArIHVUaW1lICogaW5zdGFuY2VTcGVlZCAqIDMuMDsKICAgICAgICB2ZWMyIHJvdGF0ZWQgPSB2ZWMyKHBvc2l0aW9uLnggKiBjb3MoYW5nbGUpIC0gcG9zaXRpb24ueSAqIHNpbihhbmdsZSksIHBvc2l0aW9uLnggKiBzaW4oYW5nbGUpICsgcG9zaXRpb24ueSAqIGNvcyhhbmdsZSkpOwogICAgICAgIHZlYzMgdHJhbnNmb3JtZWQgPSB2ZWMzKHJvdGF0ZWQgKiBpbnN0YW5jZVNpemUsIHBvc2l0aW9uLnopOwogICAgICAgIHRyYW5zZm9ybWVkLnggKz0gaW5zdGFuY2VPZmZzZXQueDsKICAgICAgICB0cmFuc2Zvcm1lZC55ICs9IHRyYXZlbCArIGluc3RhbmNlT2Zmc2V0Lnk7CiAgICAgICAgdHJhbnNmb3JtZWQueiArPSAtNS4wICsgaW5zdGFuY2VPZmZzZXQuejsKICAgICAgICB2QWxwaGEgPSAxLjA7CiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCh0cmFuc2Zvcm1lZCwgMS4wKTsKICAgICAgfQogICAgYCxmcmFnbWVudFNoYWRlcjpgCiAgICAgIHVuaWZvcm0gZmxvYXQgdU9wYWNpdHk7CiAgICAgIHZhcnlpbmcgZmxvYXQgdkFscGhhOwogICAgICB2b2lkIG1haW4oKSB7CiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjk1LCAwLjk4LCAxLjAsIHZBbHBoYSAqIHVPcGFjaXR5KTsKICAgICAgfQogICAgYCx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExLGJsZW5kaW5nOjF9KSxmPW5ldyBzdChyLGgpO3JldHVybiBmLmZydXN0dW1DdWxsZWQ9ITEsZS5hZGQoZikse2dyb3VwOmUsdXBkYXRlKHApe3UudVRpbWUudmFsdWUrPXAsdS51Vmlld1NpemUudmFsdWUuc2V0KGkudmlld1dpZHRoLGkudmlld0hlaWdodCl9LHNldE9wYWNpdHkocCl7dS51T3BhY2l0eS52YWx1ZT1NYXRoLm1heCgwLE1hdGgubWluKDEscC8xMDApKX0sb25SZXNpemUocCxfKXtpLnZpZXdXaWR0aD1wLGkudmlld0hlaWdodD1fLHUudVZpZXdTaXplLnZhbHVlLnNldChwLF8pfSxkaXNwb3NlKCl7ci5kaXNwb3NlKCksaC5kaXNwb3NlKCl9fX1sZXQgQXQ9bnVsbDtzZWxmLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLGk9Pntjb25zdCBlPWkuZGF0YTtzd2l0Y2goZS50eXBlKXtjYXNlIklOSVQiOnBoKGUpO2JyZWFrO2Nhc2UiU1RBUlQiOkF0Py5zdGFydChlLmVmZmVjdCxlLm9wYWNpdHksZS5vcHRpb25zfHx7fSk7YnJlYWs7Y2FzZSJTRVRfT1BBQ0lUWSI6QXQ/LnNldE9wYWNpdHkoZS5vcGFjaXR5KTticmVhaztjYXNlIlJFU0laRSI6QXQmJkF0LnJlc2l6ZSh7dmlld3BvcnRXaWR0aDplLnZpZXdwb3J0V2lkdGgsdmlld3BvcnRIZWlnaHQ6ZS52aWV3cG9ydEhlaWdodCxkZXZpY2VQaXhlbFJhdGlvOmUuZGV2aWNlUGl4ZWxSYXRpbyxpc01vYmlsZTplLmlzTW9iaWxlfSk7YnJlYWs7Y2FzZSJTRVRfU05PV19TVVJGQUNFUyI6QXQ/LnNldFNub3dTdXJmYWNlcyhlLnN1cmZhY2VzfHxbXSk7YnJlYWs7Y2FzZSJTVE9QIjpBdD8uc3RvcCgpO2JyZWFrO2Nhc2UiRElTUE9TRSI6QXQmJihBdC5kZXN0cm95KCksQXQ9bnVsbCk7YnJlYWt9fSk7ZnVuY3Rpb24gcGgoaSl7dHJ5e0F0JiYoQXQuZGVzdHJveSgpLEF0PW51bGwpLEF0PW5ldyBxdSh7Y2FudmFzOmkuY2FudmFzLHZpZXdwb3J0V2lkdGg6aS52aWV3cG9ydFdpZHRoLHZpZXdwb3J0SGVpZ2h0Omkudmlld3BvcnRIZWlnaHQsZGV2aWNlUGl4ZWxSYXRpbzppLmRldmljZVBpeGVsUmF0aW8/PzEsaXNNb2JpbGU6aS5pc01vYmlsZT8/ITF9KSxzZWxmLnBvc3RNZXNzYWdlKHt0eXBlOiJSRUFEWSJ9KX1jYXRjaChlKXtzZWxmLnBvc3RNZXNzYWdlKHt0eXBlOiJFUlJPUiIsZXJyb3I6ZSBpbnN0YW5jZW9mIEVycm9yP2UubWVzc2FnZTpTdHJpbmcoZSl9KX19fSkoKTsK",Xu=l=>Uint8Array.from(atob(l),t=>t.charCodeAt(0)),Kd=typeof self<"u"&&self.Blob&&new Blob([Xu(zd)],{type:"text/javascript;charset=utf-8"});function gu(l){let t;try{if(t=Kd&&(self.URL||self.webkitURL).createObjectURL(Kd),!t)throw"";const e=new Worker(t,{name:l?.name});return e.addEventListener("error",()=>{(self.URL||self.webkitURL).revokeObjectURL(t)}),e}catch{return new Worker("data:text/javascript;base64,"+zd,{name:l?.name})}finally{t&&(self.URL||self.webkitURL).revokeObjectURL(t)}}const Xi=typeof window<"u"&&typeof Worker<"u"&&typeof HTMLCanvasElement<"u"&&"transferControlToOffscreen"in HTMLCanvasElement.prototype;class Ru{constructor(t,e={}){this.container=t,this.canvas=document.createElement("canvas"),this.canvas.style.cssText="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--weather-overlay-z,9998);",this.container.appendChild(this.canvas),this.viewportWidth=e.viewportWidth??window.innerWidth,this.viewportHeight=e.viewportHeight??window.innerHeight,this.isMobile=e.isMobile??(window.innerWidth<600||"ontouchstart"in window),this.devicePixelRatio=e.devicePixelRatio??this.effectiveDpr(),this.worker=null,this.workerState="idle",this.workerQueue=[],this.fallbackCore=null,this.currentEffect="none",this.opacity=100,this.effectOptions={},this.resizeHandler=()=>this.handleResize(),window.addEventListener("resize",this.resizeHandler),Xi?this.initWorker():this.ensureFallbackCore()}effectiveDpr(){const t=window.ForkUWeatherAwareConfig||{};let e=window.devicePixelRatio||1;return this.isMobile&&t.mobile_limit_dpr&&(e=Math.min(e,2)),e}useWorkerPath(){return Xi&&this.workerState==="ready"}shouldUseWorkerOrQueue(){return Xi&&this.workerState!=="failed"}shouldUseFallbackCore(){return!Xi||this.workerState==="failed"}initWorker(){if(!this.worker)try{this.worker=new gu,this.worker.onmessage=e=>{e.data?.type==="READY"?(this.workerState="ready",this.flushWorkerQueue(),this.currentEffect!=="none"&&this.postWorkerMessage({type:"START",effect:this.currentEffect,opacity:this.opacity,options:this.effectOptions})):e.data?.type==="ERROR"&&(console.error("[Weather Overlay] Worker error:",e.data.error),this.handleWorkerFailure())},this.worker.onerror=e=>{console.error("[Weather Overlay] Worker init failed:",e),this.handleWorkerFailure()};const t=this.canvas.transferControlToOffscreen();this.workerState="pending",this.worker.postMessage({type:"INIT",canvas:t,viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile},[t])}catch(t){console.error("[Weather Overlay] Worker creation failed:",t),this.handleWorkerFailure()}}handleWorkerFailure(){this.workerState="failed",this.worker&&(this.worker.terminate(),this.worker=null),this.flushWorkerQueue(!0),this.recreateCanvas(),this.fallbackCore&&(this.fallbackCore.destroy(),this.fallbackCore=null),this.ensureFallbackCore(),this.currentEffect!=="none"&&this.fallbackCore?.start(this.currentEffect,this.opacity,this.effectOptions)}recreateCanvas(){this.canvas?.parentElement&&this.canvas.parentElement.removeChild(this.canvas),this.canvas=document.createElement("canvas"),this.canvas.style.cssText="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--weather-overlay-z,9998);",this.container.appendChild(this.canvas)}ensureFallbackCore(){this.fallbackCore||(this.fallbackCore=new qb({canvas:this.canvas,viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile}))}postWorkerMessage(t){this.workerState==="ready"&&this.worker?this.worker.postMessage(t):this.workerQueue.push(t)}flushWorkerQueue(t=!1){if(t||!this.worker){this.workerQueue=[];return}for(const e of this.workerQueue)this.worker.postMessage(e);this.workerQueue=[]}handleResize(){this.viewportWidth=window.innerWidth,this.viewportHeight=window.innerHeight,this.isMobile=window.innerWidth<600||"ontouchstart"in window,this.devicePixelRatio=this.effectiveDpr(),this.shouldUseWorkerOrQueue()?this.postWorkerMessage({type:"RESIZE",viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile}):this.shouldUseFallbackCore()&&this.fallbackCore&&this.fallbackCore.resize({viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile})}start(t,e=100,n={}){if(this.opacity=Math.max(0,Math.min(100,e)),this.effectOptions=n,t==="none"){this.stop();return}this.currentEffect=t,this.shouldUseWorkerOrQueue()?this.postWorkerMessage({type:"START",effect:t,opacity:this.opacity,options:this.effectOptions}):this.shouldUseFallbackCore()&&(this.ensureFallbackCore(),this.fallbackCore?.start(t,this.opacity,this.effectOptions))}stop(){this.currentEffect="none",this.shouldUseWorkerOrQueue()?this.postWorkerMessage({type:"STOP"}):this.fallbackCore&&this.fallbackCore.stop()}setOpacity(t){this.opacity=Math.max(0,Math.min(100,t)),this.shouldUseWorkerOrQueue()?this.postWorkerMessage({type:"SET_OPACITY",opacity:this.opacity}):this.fallbackCore&&this.fallbackCore.setOpacity(this.opacity)}resize(t={}){this.viewportWidth=t.viewportWidth??window.innerWidth,this.viewportHeight=t.viewportHeight??window.innerHeight,this.isMobile=t.isMobile??(window.innerWidth<600||"ontouchstart"in window),this.devicePixelRatio=t.devicePixelRatio??this.effectiveDpr(),this.shouldUseWorkerOrQueue()?this.postWorkerMessage({type:"RESIZE",viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile}):this.shouldUseFallbackCore()&&(this.ensureFallbackCore(),this.fallbackCore?.resize({viewportWidth:this.viewportWidth,viewportHeight:this.viewportHeight,devicePixelRatio:this.devicePixelRatio,isMobile:this.isMobile}))}setStyle(t){t&&typeof t=="object"&&Object.assign(this.canvas.style,t)}destroy(){this.stop(),window.removeEventListener("resize",this.resizeHandler),this.worker&&(this.worker.postMessage({type:"DISPOSE"}),this.worker.terminate(),this.worker=null),this.workerState="idle",this.workerQueue=[],this.fallbackCore&&(this.fallbackCore.destroy(),this.fallbackCore=null),this.canvas?.parentNode&&this.canvas.parentNode.removeChild(this.canvas)}}function Bd(l){if(!l)return"none";const t=String(l).toLowerCase().replace(/_/g,"-");return t==="lightning-rainy"||t==="lightning_rainy"||t==="pouring"?"rain_storm":t==="rainy-drizzle"||t==="rainy_drizzle"?"rain_drizzle":t==="rainy"?"rain":t==="hail"?"hail":t==="lightning"?"lightning":t==="snowy"||t==="snow"?"snow_gentle":t==="snowy-rainy"||t==="snowy_rainy"?"snow_storm":t==="snowy2"?"snow_layered":t==="snowy3"?"snow_gentle":t==="fog"||t==="foggy"?"fog_light":t==="sunny"||t==="clear"||t==="sunny2"?"sun_beams":t==="clear-night"||t==="clear_night"?"stars":t==="cloudy"||t==="partlycloudy"||t==="partly-cloudy"||t==="partly_cloudy"||t==="windy-variant"||t==="windy_variant"||t==="windy"?"clouds":"none"}const bn=[],Ed="",yu="",Cu=!1;function Gr(l,t=null){}function Su(l,t=null){console.warn("[Weather Overlay] ⚠️",l,t??"")}function Ln(l,t=null){console.error("[Weather Overlay] ❌",l,t??"")}function un(){const l=document.querySelector("home-assistant");return l?.hass?l:null}function Iu(){return(window.ForkUWeatherAwareConfig||{}).weather_entity||"weather.openweathermap"}function Ad(){try{const l=un();if(!l)return null;const t=window.ForkUWeatherAwareConfig||{},e=Iu();if(t.development_mode&&t.test_effect&&t.test_effect!=="Use Real Weather"){let a=t.test_effect;return a==="snowy"&&t.snowy_variant==="snowy2"&&(a="snowy2"),a}const n=l.hass.states[e];if(!n)return Ln(`Weather entity '${e}' not found`),null;let i=(n.state||"").toLowerCase().replace(/_/g,"-");const s=parseFloat(t.drizzle_precipitation_max)||2.5;if(i==="rainy"){const a=n.attributes?.precipitation!=null?parseFloat(n.attributes.precipitation):n.attributes?.precipitation_1h!=null?parseFloat(n.attributes.precipitation_1h):NaN;!isNaN(a)&&a>0&&a<=s&&(i="rainy-drizzle")}return i}catch(l){return Ln("Error getting weather state:",l),null}}function Qd(){try{if((window.ForkUWeatherAwareConfig||{}).enabled===!1)return!1;if(!Ed)return!0;const t=un();if(!t)return!0;const e=t.hass.states[Ed];return e?e.state==="on":!0}catch(l){return Ln("Error checking overlay:",l),!0}}function Pd(){if(!bn?.length)return!0;const t=window.location.pathname.split("/").filter(Boolean);if(t.length===0)return bn.includes("lovelace")||bn.includes("home");if(t[0]==="lovelace"){const e=t.length===1?"lovelace":t[1];return bn.includes(e)}for(const e of t)if(bn.includes(e))return!0;return bn.includes(t[t.length-1])}function qa(){return window.innerWidth<600||"ontouchstart"in window}function xu(){try{const l=document.createElement("canvas");return!!(l.getContext("webgl2")||l.getContext("webgl")||l.getContext("experimental-webgl"))}catch{return!1}}function jd(){const l=window.ForkUWeatherAwareConfig||{};let t=window.devicePixelRatio||1;return qa()&&l.mobile_limit_dpr&&(t=Math.min(t,2)),t}function Dd(){const l=window.ForkUWeatherAwareConfig||{},t=l.pm25_entity,e=l.pm4_entity,n=l.pm10_entity,i=l.smog_threshold_pm25??35,s=l.smog_threshold_pm4??50,a=l.smog_threshold_pm10??50,d=un();if(!d?.hass)return!1;if(t){const c=d.hass.states[t];if(c&&c.state!=="unavailable"&&c.state!=="unknown"){const o=parseFloat(c.state);if(!isNaN(o)&&o>=i)return!0}}if(e){const c=d.hass.states[e];if(c&&c.state!=="unavailable"&&c.state!=="unknown"){const o=parseFloat(c.state);if(!isNaN(o)&&o>=s)return!0}}if(n){const c=d.hass.states[n];if(c&&c.state!=="unavailable"&&c.state!=="unknown"){const o=parseFloat(c.state);if(!isNaN(o)&&o>=a)return!0}}return!1}function Jl(l){return(window.ForkUWeatherAwareConfig||{})[l]!==!1}function Yu(){const t=(window.ForkUWeatherAwareConfig||{}).gaming_mode_entity;if(!t||typeof t!="string"||!t.trim())return!1;const e=un();if(!e?.hass?.states)return!1;const n=e.hass.states[t];return!!(n&&String(n.state).toLowerCase()==="on")}let gi=null,_d=0;const Nu=3e3;function Od(){const l=Date.now();if(l-_d<Nu&&gi)return gi;_d=l;try{const t=window.ForkUWeatherAwareConfig||{},e=un();if(!e?.hass)return{x:.75,y:.12};const n=t.moon_position_entity,i=t.moon_phase_entity,s=t.moon_azimuth_entity,a=t.moon_altitude_entity;let d={x:.75,y:.12};for(const c of[n,i].filter(Boolean)){const o=e.hass.states[c];if(!o?.attributes)continue;const m=o.attributes,Z=parseFloat(m.azimuth??m.moon_azimuth_deg),b=parseFloat(m.elevation??m.altitude??m.moon_altitude_deg);if(!isNaN(Z)&&!isNaN(b)&&b>0){d.x=Math.max(0,Math.min(1,(Z-90)/180)),d.y=.08+.22*(1-Math.min(90,b)/90);break}}if(s||a){const c=s?e.hass.states[s]:null,o=a?e.hass.states[a]:null,m=c?parseFloat(c.state):NaN,Z=o?parseFloat(o.state):NaN;!isNaN(m)&&!isNaN(Z)&&Z>0&&(d.x=Math.max(0,Math.min(1,(m-90)/180)),d.y=.08+.22*(1-Math.min(90,Z)/90))}return gi=d,d}catch{return gi||{x:.75,y:.12}}}function fu(){const l=(window.ForkUWeatherAwareConfig||{}).spatial_mode||"foreground";return{foreground:9998,background:1,bubble:5e3,"gradient-mask":9997}[l]??9998}function qd(l){const t=window.ForkUWeatherAwareConfig||{},e={rain:t.enable_rain,rain_storm:t.enable_rain&&t.enable_lightning_effect,rain_drizzle:t.enable_rain,snow_gentle:t.enable_snow,snow_storm:t.enable_snow,snow_layered:t.enable_snow,fog_light:t.enable_fog,fog_dense:t.enable_fog,sun_beams:t.enable_sun_glow,clouds:t.enable_clouds,hail:t.enable_hail,lightning:t.enable_lightning_effect,stars:t.enable_stars,matrix:t.enable_matrix};return l&&l!=="none"&&e[l]===!1?"none":l}let ze=null,Ze=null,$a=null,ts=0,$d=window.location.pathname;function Fu(){Ze&&Ze.style.setProperty("--weather-overlay-z",String(fu()))}function tc(){const l=Date.now();if(l-ts<1e3)return;const t=Qd(),e=Pd();if(!t||!e){ze&&ze.stop(),Ze&&(Ze.style.display="none");return}if(ts=l,Ze&&(Ze.style.display="block"),window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches){ze&&ze.stop(),Ze&&(Ze.style.display="none");return}const i=(window.ForkUWeatherAwareConfig||{}).gaming_matrix_only&&Yu()&&Jl("enable_matrix"),s=i?null:Ad(),a=i?"matrix":qd(Bd(s));(s!==$a||!ze)&&($a=s);const d=Jl("enable_smog_effect")&&Dd(),c=a==="stars"&&Jl("enable_moon_glow")?Od():null,m=["rain","rain_storm","rain_drizzle","snow_storm"].includes(a)&&Jl("enable_window_droplets"),Z=(window.ForkUWeatherAwareConfig||{}).spatial_mode||"foreground";ze&&ze.start(a,100,{smogActive:d,moonPosition:c,windowDroplets:m,spatialMode:Z})}function Lu(){ze&&ze.resize({viewportWidth:window.innerWidth,viewportHeight:window.innerHeight,isMobile:qa(),devicePixelRatio:jd()})}function Uu(){if(!Ze){if(!xu()){Su("WebGL not supported - weather overlay disabled");return}Ze=document.createElement("div"),Ze.id="fork-u-weather-overlay",Ze.style.cssText="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--weather-overlay-z,9998);",Fu(),document.body.appendChild(Ze);try{if(ze=new Ru(Ze,{viewportWidth:window.innerWidth,viewportHeight:window.innerHeight,isMobile:qa(),devicePixelRatio:jd()}),!Qd()||!Pd())Ze.style.display="none";else{const l=Ad(),t=qd(Bd(l));$a=l;const e=Jl("enable_smog_effect")&&Dd(),n=t==="stars"&&Jl("enable_moon_glow")?Od():null,s=["rain","rain_storm","rain_drizzle","snow_storm"].includes(t)&&Jl("enable_window_droplets"),a=(window.ForkUWeatherAwareConfig||{}).spatial_mode||"foreground";ze.start(t,100,{smogActive:e,moonPosition:n,windowDroplets:s,spatialMode:a})}}catch(l){Ln("Weather overlay init failed:",l),Ze?.parentNode&&Ze.parentNode.removeChild(Ze);return}setInterval(tc,1e3),window.addEventListener("resize",Lu),setInterval(()=>{window.location.pathname!==$d&&($d=window.location.pathname,ts=0,tc())},500)}}function ec(){let l=0;const t=setInterval(()=>{l++,un()?(clearInterval(t),Uu()):l>=60&&(clearInterval(t),Ln("Home Assistant not found after 30s"))},500)}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",ec):ec(),function(){const l=window.ForkUWeatherAwareDefaultConfig||{enabled:!0,weather_entity:"weather.openweathermap",development_mode:!1,test_effect:"Use Real Weather",sun_entity:"sun.sun",moon_phase_entity:null,uv_index_entity:null,moon_position_entity:null,moon_azimuth_entity:null,moon_altitude_entity:null,moon_distance_entity:null,gaming_mode_entity:null,pm25_entity:null,pm4_entity:null,pm10_entity:null,smog_threshold_pm25:35,smog_threshold_pm4:50,smog_threshold_pm10:50,cloud_coverage_entity:null,wind_speed_entity:null,wind_direction_entity:null,precipitation_entity:null,lightning_counter_entity:null,lightning_distance_entity:null,debug_precipitation:null,debug_wind_speed:null,debug_wind_direction:null,debug_lightning_distance:null,debug_lightning_counter:null,debug_cloud_coverage:null,cloud_speed_multiplier:1,wind_sway_factor:.7,spatial_mode:"foreground",enable_rain:!0,enable_snow:!0,enable_clouds:!0,enable_fog:!0,enable_smog_effect:!0,enable_sun_glow:!0,enable_moon_glow:!0,enable_stars:!0,enable_hail:!0,enable_lightning_effect:!0,enable_matrix:!0,enable_window_droplets:!0,stars_require_moon:!1,mobile_limit_dpr:!0,mobile_reduce_particles:!0,mobile_snowy2_light:!0,mobile_smog_simple:!1,mobile_30fps:!1,gaming_matrix_only:!1,snowy_variant:"snowy2"};class t extends HTMLElement{connectedCallback(){super.connectedCallback&&super.connectedCallback(),this._scheduleEditorCheck()}_scheduleEditorCheck(){this._editorCheckScheduled||(this._editorCheckScheduled=!0,requestAnimationFrame(()=>{this._editorCheckScheduled=!1,this._config&&this._render()}))}setConfig(a){const d=Object.assign({},l,a||{});window.ForkUWeatherAwareConfig=d,this._config=d,this._render()}set hass(a){if(this._hass=a,this._config&&!window.ForkUWeatherAwareConfig&&(window.ForkUWeatherAwareConfig=this._config),a?.themes?.darkMode!==void 0){const d=window.ForkUWeatherAwareConfig||{};window.ForkUWeatherAwareConfig=Object.assign({},d,{theme_mode:a.themes.darkMode?"dark":"light"})}}_isInEditorPreview(){let a=this;for(;a;){if(a.nodeType===1&&a.classList&&(a.classList.contains("element-preview")||a.tagName&&a.tagName.toLowerCase().includes("hui-dialog-edit-card")))return!0;const d=a.getRootNode?a.getRootNode():a;a=(d instanceof ShadowRoot?d.host:a.parentNode)||null}return!1}_render(){this.shadowRoot||this.attachShadow({mode:"open"});const a=this._config||window.ForkUWeatherAwareConfig||l,d=this._isInEditorPreview(),c=!a.development_mode&&!d;this.style.display=c?"none":"",this.shadowRoot.innerHTML=`
        <ha-card header="Fork U - Weather Aware" style="${c?"display:none":""}">
          <div class="card-content">
            <p>Fullscreen, smooth weather overlay running on this dashboard.</p>
            <p><strong>Weather entity:</strong> ${a.weather_entity||"not set"}</p>
            <p><strong>Development mode:</strong> ${a.development_mode?"on":"off"}</p>
          </div>
        </ha-card>
      `}getCardSize(){const a=this._config||window.ForkUWeatherAwareConfig||{},d=this._isInEditorPreview&&this._isInEditorPreview();return!a.development_mode&&!d?0:1}static getConfigElement(){return document.createElement("fork-u-weather-aware-editor")}static getStubConfig(){return{enabled:!0,weather_entity:"weather.openweathermap",development_mode:!1,test_effect:"Use Real Weather"}}}typeof window.customCards>"u"&&(window.customCards=[]),window.customCards.push({type:"fork-u-weather-aware-card",name:"Fork U - Weather Aware",description:"Fullscreen weather overlay with rain, snow, lightning, fog and more.",preview:!1});function e(s){return s==null?"":String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;")}function n(s,a,d){const c={value:"",label:"— None —"};if(!s||!s.states)return d?[c,{value:d,label:"Current: "+d}]:[c];const o=Object.keys(s.states).filter(Z=>a.some(b=>Z.startsWith(b+"."))).sort(),m=[c];return o.forEach(Z=>m.push({value:Z,label:Z})),d&&d.trim()&&!o.includes(d)&&m.splice(1,0,{value:d,label:"Current: "+d}),m}class i extends HTMLElement{setConfig(a){this._config=Object.assign({},l,a||{}),this._config&&(window.ForkUWeatherAwareConfig=this._config),this.shadowRoot?this._updateFormValues(this._config):(this.attachShadow({mode:"open"}),this._render())}set hass(a){this._hass=a,a&&this.shadowRoot&&this._config&&!this._entitySelectsPopulated&&this._populateEntitySelects()}_populateEntitySelects(){const a=this.shadowRoot,d=this._hass,c=this._config||{};if(!a||!d)return;this._entitySelectsPopulated=!0,[{id:"weather_entity",domains:["weather"]},{id:"sun_entity",domains:["sun"]},{id:"moon_phase_entity",domains:["sensor"]},{id:"uv_index_entity",domains:["sensor"]},{id:"moon_position_entity",domains:["sensor"]},{id:"moon_azimuth_entity",domains:["sensor"]},{id:"moon_altitude_entity",domains:["sensor"]},{id:"moon_distance_entity",domains:["sensor"]},{id:"wind_speed_entity",domains:["sensor"]},{id:"wind_direction_entity",domains:["sensor"]},{id:"cloud_coverage_entity",domains:["sensor"]},{id:"precipitation_entity",domains:["sensor"]},{id:"pm25_entity",domains:["sensor"]},{id:"pm4_entity",domains:["sensor"]},{id:"pm10_entity",domains:["sensor"]},{id:"gaming_mode_entity",domains:["input_boolean"]},{id:"lightning_counter_entity",domains:["sensor"]},{id:"lightning_distance_entity",domains:["sensor"]}].forEach(({id:m,domains:Z})=>{const b=a.getElementById(m+"_list");if(!b)return;const h=c[m]||"",p=n(d,Z,h);b.innerHTML=p.filter(W=>W.value).map(W=>`<option value="${e(W.value)}">${e(W.label)}</option>`).join("")})}_updateFormValues(a){const d=this.shadowRoot;if(!d||!a)return;const c=(m,Z)=>{const b=d.getElementById(m);b&&(b.type==="checkbox"?b.checked=!!Z:b.value=Z!=null?String(Z):"")};c("enabled",a.enabled),c("weather_entity",a.weather_entity),c("sun_entity",a.sun_entity),c("moon_phase_entity",a.moon_phase_entity),c("uv_index_entity",a.uv_index_entity),c("moon_position_entity",a.moon_position_entity),c("moon_azimuth_entity",a.moon_azimuth_entity),c("moon_altitude_entity",a.moon_altitude_entity),c("moon_distance_entity",a.moon_distance_entity),c("gaming_mode_entity",a.gaming_mode_entity),c("pm25_entity",a.pm25_entity),c("pm4_entity",a.pm4_entity),c("pm10_entity",a.pm10_entity),c("smog_threshold_pm25",a.smog_threshold_pm25),c("smog_threshold_pm4",a.smog_threshold_pm4),c("smog_threshold_pm10",a.smog_threshold_pm10),c("cloud_coverage_entity",a.cloud_coverage_entity),c("wind_speed_entity",a.wind_speed_entity),c("wind_direction_entity",a.wind_direction_entity),c("precipitation_entity",a.precipitation_entity),c("lightning_counter_entity",a.lightning_counter_entity),c("lightning_distance_entity",a.lightning_distance_entity),c("cloud_speed_multiplier",a.cloud_speed_multiplier),c("wind_sway_factor",a.wind_sway_factor),c("enable_rain",a.enable_rain),c("enable_snow",a.enable_snow),c("enable_clouds",a.enable_clouds),c("enable_fog",a.enable_fog),c("enable_smog_effect",a.enable_smog_effect),c("enable_sun_glow",a.enable_sun_glow),c("enable_moon_glow",a.enable_moon_glow),c("enable_stars",a.enable_stars),c("enable_hail",a.enable_hail),c("enable_lightning_effect",a.enable_lightning_effect),c("enable_matrix",a.enable_matrix),c("enable_window_droplets",a.enable_window_droplets),c("stars_require_moon",a.stars_require_moon),c("drizzle_precipitation_max",a.drizzle_precipitation_max),["rain","snow","clouds","fog","smog","hail","lightning","stars","matrix"].forEach(m=>c("speed_factor_"+m,a["speed_factor_"+m])),c("development_mode",a.development_mode),c("debug_precipitation",a.debug_precipitation),c("debug_wind_speed",a.debug_wind_speed),c("debug_wind_direction",a.debug_wind_direction),c("debug_lightning_distance",a.debug_lightning_distance),c("debug_lightning_counter",a.debug_lightning_counter),c("debug_cloud_coverage",a.debug_cloud_coverage),c("mobile_limit_dpr",a.mobile_limit_dpr),c("mobile_reduce_particles",a.mobile_reduce_particles),c("mobile_snowy2_light",a.mobile_snowy2_light),c("mobile_smog_simple",a.mobile_smog_simple),c("mobile_30fps",a.mobile_30fps),c("gaming_matrix_only",a.gaming_matrix_only),c("snowy_variant",a.snowy_variant||"snowy2"),c("spatial_mode",a.spatial_mode||"foreground");const o=a.test_effect||"Use Real Weather";d.querySelectorAll('input[name="test_effect"]').forEach(m=>{m.checked=m.value===o})}_render(){this.shadowRoot||this.attachShadow({mode:"open"});const a=this._config||l,d=this._hass,c=["Use Real Weather","rainy","pouring","cloudy","partlycloudy","fog","lightning","lightning-rainy","snowy","snowy-rainy","clear-night","sunny","hail"],o=n(d,["weather"],a.weather_entity),m=n(d,["sun"],a.sun_entity),Z=h=>n(d,["sensor"],h),b=n(d,["input_boolean"],a.gaming_mode_entity);this.shadowRoot.innerHTML=`
        <style>
          :host { display: block; }
          .editor { padding: 16px; max-width: 560px; }
          ha-expansion-panel { margin-bottom: 8px; --expansion-panel-content-padding: 12px 16px; }
          ha-expansion-panel .content { padding: 12px 16px; }
          .section { margin-bottom: 16px; }
          .section-title { font-size: 0.9em; font-weight: 600; margin-bottom: 10px; color: var(--primary-text-color); }
          .form-row { margin-bottom: 16px; display: flex; flex-wrap: wrap; align-items: center; gap: 12px; }
          .form-row label { font-size: 14px; color: var(--secondary-text-color); min-width: 140px; }
          .entity-select, input[type="text"], input[type="number"], select {
            min-width: 220px; max-width: 100%;
            padding: 8px 12px;
            border-radius: var(--mdc-shape-small, 8px);
            border: 1px solid var(--divider-color, rgba(0,0,0,0.12));
            background: var(--ha-card-background, var(--card-background-color));
            color: var(--primary-text-color);
            font-size: 14px;
            font-family: var(--mdc-typography-font-family, Roboto, sans-serif);
          }
          .entity-select:focus, input:focus, select:focus { outline: none; border-color: var(--primary-color); }
          input[type="number"] { min-width: 72px; width: 72px; }
          .radio-group { display: flex; flex-wrap: wrap; gap: 12px; }
          .radio-group label { min-width: auto; cursor: pointer; }
          input[type="checkbox"] { cursor: pointer; width: 18px; height: 18px; accent-color: var(--primary-color); }
        </style>
        <div class="editor">
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:cog"></ha-icon> General</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">General</div>
            <div class="form-row">
              <label><input type="checkbox" id="enabled" ${a.enabled?"checked":""}> Enable overlay</label>
            </div>
            <div class="form-row">
              <label>Weather entity</label>
              <input id="weather_entity" type="text" class="entity-select" list="weather_entity_list" value="${a.weather_entity||""}" placeholder="np. weather.openweathermap">
              <datalist id="weather_entity_list">
                ${o.map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Sun entity</label>
              <input id="sun_entity" type="text" class="entity-select" list="sun_entity_list" value="${a.sun_entity||""}" placeholder="sun.sun">
              <datalist id="sun_entity_list">
                ${m.map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:weather-night"></ha-icon> Moon &amp; UV</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Moon &amp; UV</div>
            <div class="form-row">
              <label>Moon phase</label>
              <input id="moon_phase_entity" type="text" class="entity-select" list="moon_phase_entity_list" value="${a.moon_phase_entity||""}" placeholder="sensor.moon_phase">
              <datalist id="moon_phase_entity_list">
                ${Z(a.moon_phase_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>UV index</label>
              <input id="uv_index_entity" type="text" class="entity-select" list="uv_index_entity_list" value="${a.uv_index_entity||""}" placeholder="sensor.uv_index">
              <datalist id="uv_index_entity_list">
                ${Z(a.uv_index_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Moon position (single)</label>
              <input id="moon_position_entity" type="text" class="entity-select" list="moon_position_entity_list" value="${a.moon_position_entity||""}" placeholder="sensor.moon_position">
              <datalist id="moon_position_entity_list">
                ${Z(a.moon_position_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row"><label>Lunar Phase (3 sensors)</label></div>
            <div class="form-row">
              <label>Azimuth</label>
              <input id="moon_azimuth_entity" type="text" class="entity-select" list="moon_azimuth_entity_list" value="${a.moon_azimuth_entity||""}" placeholder="sensor.moon_azimuth">
              <datalist id="moon_azimuth_entity_list">
                ${Z(a.moon_azimuth_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Altitude</label>
              <input id="moon_altitude_entity" type="text" class="entity-select" list="moon_altitude_entity_list" value="${a.moon_altitude_entity||""}" placeholder="sensor.moon_altitude">
              <datalist id="moon_altitude_entity_list">
                ${Z(a.moon_altitude_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Distance</label>
              <input id="moon_distance_entity" type="text" class="entity-select" list="moon_distance_entity_list" value="${a.moon_distance_entity||""}" placeholder="sensor.moon_distance">
              <datalist id="moon_distance_entity_list">
                ${Z(a.moon_distance_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:weather-windy"></ha-icon> Wind, clouds, precipitation</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Wind, clouds, precipitation</div>
            <div class="form-row">
              <label>Wind speed</label>
              <input id="wind_speed_entity" type="text" class="entity-select" list="wind_speed_entity_list" value="${a.wind_speed_entity||""}" placeholder="sensor.wind_speed">
              <datalist id="wind_speed_entity_list">
                ${Z(a.wind_speed_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Wind direction</label>
              <input id="wind_direction_entity" type="text" class="entity-select" list="wind_direction_entity_list" value="${a.wind_direction_entity||""}" placeholder="sensor.wind_direction">
              <datalist id="wind_direction_entity_list">
                ${Z(a.wind_direction_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Cloud coverage</label>
              <input id="cloud_coverage_entity" type="text" class="entity-select" list="cloud_coverage_entity_list" value="${a.cloud_coverage_entity||""}" placeholder="sensor.cloud_coverage">
              <datalist id="cloud_coverage_entity_list">
                ${Z(a.cloud_coverage_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Precipitation</label>
              <input id="precipitation_entity" type="text" class="entity-select" list="precipitation_entity_list" value="${a.precipitation_entity||""}" placeholder="sensor.precipitation">
              <datalist id="precipitation_entity_list">
                ${Z(a.precipitation_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Cloud speed multiplier</label>
              <input type="number" id="cloud_speed_multiplier" value="${a.cloud_speed_multiplier??1}" min="0.1" max="3" step="0.1" style="width:72px">
            </div>
            <div class="form-row">
              <label>Drizzle threshold (mm)</label>
              <input type="number" id="drizzle_precipitation_max" value="${a.drizzle_precipitation_max??2.5}" min="0" max="20" step="0.5" style="width:72px" title="Precipitation ≤ this = drizzle (light rain); above = normal rain">
            </div>
            <div class="form-row">
              <label>Wind sway factor</label>
              <input type="number" id="wind_sway_factor" value="${a.wind_sway_factor??.7}" min="0" max="2" step="0.1" style="width:72px" title="How strongly wind bends rain/snow (0 = off, 0.7 = default)">
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:speedometer"></ha-icon> Effect speed factors (1 = default, 0.1–3)</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Effect speed factors (1 = default, 0.1–3)</div>
            <div class="form-row" style="flex-wrap:wrap;gap:8px 16px;">
              <label>Rain</label><input type="number" id="speed_factor_rain" value="${a.speed_factor_rain??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Snow</label><input type="number" id="speed_factor_snow" value="${a.speed_factor_snow??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Clouds</label><input type="number" id="speed_factor_clouds" value="${a.speed_factor_clouds??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Fog</label><input type="number" id="speed_factor_fog" value="${a.speed_factor_fog??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Smog</label><input type="number" id="speed_factor_smog" value="${a.speed_factor_smog??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Hail</label><input type="number" id="speed_factor_hail" value="${a.speed_factor_hail??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Lightning</label><input type="number" id="speed_factor_lightning" value="${a.speed_factor_lightning??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Stars</label><input type="number" id="speed_factor_stars" value="${a.speed_factor_stars??1}" min="0.1" max="3" step="0.1" style="width:52px">
              <label>Matrix</label><input type="number" id="speed_factor_matrix" value="${a.speed_factor_matrix??1}" min="0.1" max="3" step="0.1" style="width:52px">
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:tune"></ha-icon> Effects enabled</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Toggle individual effects (disable heavy ones if needed)</div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_rain" ${a.enable_rain!==!1?"checked":""}> Rain (rainy / pouring / lightning-rainy)</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_snow" ${a.enable_snow!==!1?"checked":""}> Snow (snowy / snowy2 / snowy-rainy)</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_clouds" ${a.enable_clouds!==!1?"checked":""}> Clouds</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_fog" ${a.enable_fog!==!1?"checked":""}> Fog</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_smog_effect" ${a.enable_smog_effect!==!1?"checked":""}> Smog alert fog</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_sun_glow" ${a.enable_sun_glow!==!1?"checked":""}> Sun glow / beams</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_moon_glow" ${a.enable_moon_glow!==!1?"checked":""}> Moon glow</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_stars" ${a.enable_stars!==!1?"checked":""}> Stars</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="stars_require_moon" ${a.stars_require_moon?"checked":""}> Stars require moon glow</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_hail" ${a.enable_hail!==!1?"checked":""}> Hail (meteors)</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_lightning_effect" ${a.enable_lightning_effect!==!1?"checked":""}> Lightning flashes</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_matrix" ${a.enable_matrix!==!1?"checked":""}> Matrix / gaming overlay</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="enable_window_droplets" ${a.enable_window_droplets!==!1?"checked":""}> Window droplets (side rain on glass)</label>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:target"></ha-icon> Spatial awareness</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Spatial awareness (where effects are drawn)</div>
            <div class="form-row">
              <label>Mode</label>
              <select id="spatial_mode" class="entity-select">
                <option value="background" ${a.spatial_mode==="background"?"selected":""}>Background (behind all cards, z-index -1)</option>
                <option value="bubble" ${a.spatial_mode==="bubble"?"selected":""}>Bubble aware (under Bubble card backdrops, z-index -3)</option>
                <option value="gradient-mask" ${a.spatial_mode==="gradient-mask"?"selected":""}>Gradient mask (effects around card edges)</option>
                <option value="foreground" ${!a.spatial_mode||a.spatial_mode==="foreground"?"selected":""}>Foreground (current behavior, above cards)</option>
              </select>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:snowflake"></ha-icon> Snow variant</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Snow variant</div>
            <div class="form-row">
              <label>Preferred snow style</label>
              <select id="snowy_variant" class="entity-select">
                <option value="snowy" ${a.snowy_variant==="snowy"?"selected":""}>Classic snowy (particles)</option>
                <option value="snowy2" ${!a.snowy_variant||a.snowy_variant==="snowy2"?"selected":""}>Snowy2 (layered, lighter on mobile)</option>
              </select>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:blur"></ha-icon> Smog (PM µg/m³ – fog above threshold)</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Smog (PM µg/m³ – fog when above threshold). Default thresholds: WHO / EPA / EU</div>
            <div class="form-row">
              <label>PM2.5</label>
              <input id="pm25_entity" type="text" class="entity-select" list="pm25_entity_list" value="${a.pm25_entity||""}" placeholder="sensor.pm25">
              <datalist id="pm25_entity_list">
                ${Z(a.pm25_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
              <label>Alert threshold (µg/m³)</label>
              <input type="number" id="smog_threshold_pm25" value="${a.smog_threshold_pm25??35}" min="1" max="500" style="width:60px" title="Default 35 (EPA: unhealthy for sensitive groups)">
            </div>
            <div class="form-row">
              <label>PM4</label>
              <input id="pm4_entity" type="text" class="entity-select" list="pm4_entity_list" value="${a.pm4_entity||""}" placeholder="sensor.pm4">
              <datalist id="pm4_entity_list">
                ${Z(a.pm4_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
              <label>Alert threshold (µg/m³)</label>
              <input type="number" id="smog_threshold_pm4" value="${a.smog_threshold_pm4??50}" min="1" max="500" style="width:60px">
            </div>
            <div class="form-row">
              <label>PM10</label>
              <input id="pm10_entity" type="text" class="entity-select" list="pm10_entity_list" value="${a.pm10_entity||""}" placeholder="sensor.pm10">
              <datalist id="pm10_entity_list">
                ${Z(a.pm10_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
              <label>Alert threshold (µg/m³)</label>
              <input type="number" id="smog_threshold_pm10" value="${a.smog_threshold_pm10??50}" min="1" max="500" style="width:60px" title="Default 50 (EU 24h limit / WHO guideline)">
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:flash"></ha-icon> Gaming &amp; Lightning</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Gaming &amp; Lightning</div>
            <div class="form-row">
              <label>Gaming mode</label>
              <input id="gaming_mode_entity" type="text" class="entity-select" list="gaming_mode_entity_list" value="${a.gaming_mode_entity||""}" placeholder="input_boolean.gaming_mode">
              <datalist id="gaming_mode_entity_list">
                ${b.map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="gaming_matrix_only" ${a.gaming_matrix_only?"checked":""}> When Gaming ON: Matrix only (no weather background)</label>
            </div>
            <div class="form-row">
              <label>Lightning counter</label>
              <input id="lightning_counter_entity" type="text" class="entity-select" list="lightning_counter_entity_list" value="${a.lightning_counter_entity||""}" placeholder="sensor.lightning_counter">
              <datalist id="lightning_counter_entity_list">
                ${Z(a.lightning_counter_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
            <div class="form-row">
              <label>Lightning distance</label>
              <input id="lightning_distance_entity" type="text" class="entity-select" list="lightning_distance_entity_list" value="${a.lightning_distance_entity||""}" placeholder="sensor.lightning_distance">
              <datalist id="lightning_distance_entity_list">
                ${Z(a.lightning_distance_entity).map(h=>`<option value="${e(h.value)}">${e(h.label)}</option>`).join("")}
              </datalist>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:cellphone"></ha-icon> Mobile</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Mobile</div>
            <div class="form-row">
              <label><input type="checkbox" id="mobile_limit_dpr" ${a.mobile_limit_dpr?"checked":""}> Limit canvas resolution on mobile (better performance)</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="mobile_reduce_particles" ${a.mobile_reduce_particles?"checked":""}> Fewer particles (rain/snow/fog) on mobile</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="mobile_snowy2_light" ${a.mobile_snowy2_light?"checked":""}> Lighter <code>snowy2</code> snow on mobile</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="mobile_smog_simple" ${a.mobile_smog_simple?"checked":""}> Simpler smog rendering on mobile</label>
            </div>
            <div class="form-row">
              <label><input type="checkbox" id="mobile_30fps" ${a.mobile_30fps?"checked":""}> Limit animation to ~30 FPS on mobile</label>
            </div>
          </div>
            </div>
          </ha-expansion-panel>
          <ha-expansion-panel outlined>
            <h4 slot="header"><ha-icon icon="mdi:test-tube"></ha-icon> Development mode</h4>
            <div class="content">
          <div class="section">
            <div class="section-title">Development mode</div>
            <div class="form-row">
              <label><input type="checkbox" id="development_mode" ${a.development_mode?"checked":""}> Override real weather for testing</label>
            </div>
            ${a.development_mode?`
            <div class="form-row">
              <label>Test effect</label>
              <div class="radio-group">
                ${c.map(h=>`
                  <label><input type="radio" name="test_effect" value="${e(h)}" ${a.test_effect===h?"checked":""}> ${e(h)}</label>
                `).join("")}
              </div>
            </div>
            <div class="form-row" style="margin-top:10px;"><strong>Debug overrides</strong></div>
            <div class="form-row">
              <label>Precipitation</label>
              <select id="debug_precipitation">
                <option value="">Use sensors</option>
                <option value="light" ${a.debug_precipitation==="light"?"selected":""}>Light (~1 mm/h)</option>
                <option value="medium" ${a.debug_precipitation==="medium"?"selected":""}>Medium (~3 mm/h)</option>
                <option value="heavy" ${a.debug_precipitation==="heavy"?"selected":""}>Heavy (~8 mm/h)</option>
              </select>
            </div>
            <div class="form-row">
              <label>Wind speed</label>
              <select id="debug_wind_speed">
                <option value="">Use sensors</option>
                <option value="none" ${a.debug_wind_speed==="none"?"selected":""}>None</option>
                <option value="light" ${a.debug_wind_speed==="light"?"selected":""}>Light (~10 km/h)</option>
                <option value="medium" ${a.debug_wind_speed==="medium"?"selected":""}>Medium (~25 km/h)</option>
                <option value="strong" ${a.debug_wind_speed==="strong"?"selected":""}>Strong (~45 km/h)</option>
              </select>
            </div>
            <div class="form-row">
              <label>Wind direction</label>
              <select id="debug_wind_direction">
                <option value="">Use sensors</option>
                <option value="N" ${a.debug_wind_direction==="N"?"selected":""}>N</option>
                <option value="NE" ${a.debug_wind_direction==="NE"?"selected":""}>NE</option>
                <option value="E" ${a.debug_wind_direction==="E"?"selected":""}>E</option>
                <option value="SE" ${a.debug_wind_direction==="SE"?"selected":""}>SE</option>
                <option value="S" ${a.debug_wind_direction==="S"?"selected":""}>S</option>
                <option value="SW" ${a.debug_wind_direction==="SW"?"selected":""}>SW</option>
                <option value="W" ${a.debug_wind_direction==="W"?"selected":""}>W</option>
                <option value="NW" ${a.debug_wind_direction==="NW"?"selected":""}>NW</option>
              </select>
            </div>
            <div class="form-row">
              <label>Lightning distance (km)</label>
              <input type="number" id="debug_lightning_distance" value="${a.debug_lightning_distance??""}" placeholder="override" min="0" max="500" step="0.5" style="width:80px">
              <label>Lightning counter</label>
              <input type="number" id="debug_lightning_counter" value="${a.debug_lightning_counter??""}" placeholder="override" min="0" style="width:60px">
            </div>
            <div class="form-row">
              <label>Cloud coverage (%)</label>
              <input type="number" id="debug_cloud_coverage" value="${a.debug_cloud_coverage??""}" placeholder="0-100" min="0" max="100" style="width:80px">
            </div>
            `:""}
          </div>
            </div>
          </ha-expansion-panel>
        </div>
      `,this._attachListeners(),this._hass&&this._populateEntitySelects()}_attachListeners(){const a=this.shadowRoot;if(!a)return;const d=this._config||l,c=()=>{const m=Object.assign({},d,{enabled:a.getElementById("enabled").checked,weather_entity:a.getElementById("weather_entity").value||l.weather_entity,sun_entity:a.getElementById("sun_entity").value||l.sun_entity,moon_phase_entity:a.getElementById("moon_phase_entity").value||null,uv_index_entity:a.getElementById("uv_index_entity").value||null,moon_position_entity:a.getElementById("moon_position_entity").value||null,moon_azimuth_entity:a.getElementById("moon_azimuth_entity").value||null,moon_altitude_entity:a.getElementById("moon_altitude_entity").value||null,moon_distance_entity:a.getElementById("moon_distance_entity").value||null,gaming_mode_entity:a.getElementById("gaming_mode_entity").value||null,pm25_entity:a.getElementById("pm25_entity").value||null,pm4_entity:a.getElementById("pm4_entity").value||null,pm10_entity:a.getElementById("pm10_entity").value||null,smog_threshold_pm25:parseInt(a.getElementById("smog_threshold_pm25")?.value||"35",10)||35,smog_threshold_pm4:parseInt(a.getElementById("smog_threshold_pm4")?.value||"50",10)||50,smog_threshold_pm10:parseInt(a.getElementById("smog_threshold_pm10")?.value||"50",10)||50,cloud_coverage_entity:a.getElementById("cloud_coverage_entity")?.value||null,wind_speed_entity:a.getElementById("wind_speed_entity")?.value||null,wind_direction_entity:a.getElementById("wind_direction_entity")?.value||null,precipitation_entity:a.getElementById("precipitation_entity")?.value||null,lightning_counter_entity:a.getElementById("lightning_counter_entity")?.value||null,lightning_distance_entity:a.getElementById("lightning_distance_entity")?.value||null,debug_precipitation:a.getElementById("debug_precipitation")?.value||null,debug_wind_speed:a.getElementById("debug_wind_speed")?.value||null,debug_wind_direction:a.getElementById("debug_wind_direction")?.value||null,debug_lightning_distance:a.getElementById("debug_lightning_distance")?.value||null,debug_lightning_counter:a.getElementById("debug_lightning_counter")?.value||null,debug_cloud_coverage:a.getElementById("debug_cloud_coverage")?.value||null,cloud_speed_multiplier:parseFloat(a.getElementById("cloud_speed_multiplier")?.value||"1")||1,drizzle_precipitation_max:parseFloat(a.getElementById("drizzle_precipitation_max")?.value||"2.5")||2.5,wind_sway_factor:parseFloat(a.getElementById("wind_sway_factor")?.value||"0.7")||.7,speed_factor_rain:parseFloat(a.getElementById("speed_factor_rain")?.value||"1")||1,speed_factor_snow:parseFloat(a.getElementById("speed_factor_snow")?.value||"1")||1,speed_factor_clouds:parseFloat(a.getElementById("speed_factor_clouds")?.value||"1")||1,speed_factor_fog:parseFloat(a.getElementById("speed_factor_fog")?.value||"1")||1,speed_factor_smog:parseFloat(a.getElementById("speed_factor_smog")?.value||"1")||1,speed_factor_hail:parseFloat(a.getElementById("speed_factor_hail")?.value||"1")||1,speed_factor_lightning:parseFloat(a.getElementById("speed_factor_lightning")?.value||"1")||1,speed_factor_stars:parseFloat(a.getElementById("speed_factor_stars")?.value||"1")||1,speed_factor_matrix:parseFloat(a.getElementById("speed_factor_matrix")?.value||"1")||1,enable_rain:!!a.getElementById("enable_rain")?.checked,enable_snow:!!a.getElementById("enable_snow")?.checked,enable_clouds:!!a.getElementById("enable_clouds")?.checked,enable_fog:!!a.getElementById("enable_fog")?.checked,enable_smog_effect:!!a.getElementById("enable_smog_effect")?.checked,enable_sun_glow:!!a.getElementById("enable_sun_glow")?.checked,enable_moon_glow:!!a.getElementById("enable_moon_glow")?.checked,enable_stars:!!a.getElementById("enable_stars")?.checked,enable_hail:!!a.getElementById("enable_hail")?.checked,enable_lightning_effect:!!a.getElementById("enable_lightning_effect")?.checked,enable_matrix:!!a.getElementById("enable_matrix")?.checked,enable_window_droplets:!!a.getElementById("enable_window_droplets")?.checked,stars_require_moon:!!a.getElementById("stars_require_moon")?.checked,mobile_limit_dpr:!!a.getElementById("mobile_limit_dpr")?.checked,mobile_reduce_particles:!!a.getElementById("mobile_reduce_particles")?.checked,mobile_snowy2_light:!!a.getElementById("mobile_snowy2_light")?.checked,mobile_smog_simple:!!a.getElementById("mobile_smog_simple")?.checked,mobile_30fps:!!a.getElementById("mobile_30fps")?.checked,gaming_matrix_only:!!a.getElementById("gaming_matrix_only")?.checked,snowy_variant:a.getElementById("snowy_variant")?.value||"snowy2",spatial_mode:a.getElementById("spatial_mode")?.value||"foreground",development_mode:a.getElementById("development_mode").checked,test_effect:(a.querySelector('input[name="test_effect"]:checked')||{}).value||"Use Real Weather"});this._config=m,window.ForkUWeatherAwareConfig=m,this.dispatchEvent(new CustomEvent("config-changed",{detail:{config:m}}))};["weather_entity","sun_entity","moon_phase_entity","uv_index_entity","moon_position_entity","moon_azimuth_entity","moon_altitude_entity","moon_distance_entity","gaming_mode_entity","pm25_entity","pm4_entity","pm10_entity","smog_threshold_pm25","smog_threshold_pm4","smog_threshold_pm10","cloud_coverage_entity","wind_speed_entity","wind_direction_entity","precipitation_entity","lightning_counter_entity","lightning_distance_entity","debug_precipitation","debug_wind_speed","debug_wind_direction","debug_lightning_distance","debug_lightning_counter","debug_cloud_coverage","cloud_speed_multiplier","drizzle_precipitation_max","wind_sway_factor","speed_factor_rain","speed_factor_snow","speed_factor_clouds","speed_factor_fog","speed_factor_smog","speed_factor_hail","speed_factor_lightning","speed_factor_stars","speed_factor_matrix","snowy_variant","spatial_mode"].forEach(m=>{const Z=a.getElementById(m);Z&&Z.addEventListener("change",c)}),["enabled","development_mode","mobile_limit_dpr","mobile_reduce_particles","mobile_snowy2_light","mobile_smog_simple","mobile_30fps","gaming_matrix_only","enable_rain","enable_snow","enable_clouds","enable_fog","enable_smog_effect","enable_sun_glow","enable_moon_glow","enable_stars","enable_hail","enable_lightning_effect","enable_matrix","enable_window_droplets","stars_require_moon"].forEach(m=>{const Z=a.getElementById(m);Z&&Z.addEventListener("change",c)}),a.querySelectorAll('input[name="test_effect"]').forEach(m=>{m.addEventListener("change",c)})}}customElements.get("fork-u-weather-aware-card")||customElements.define("fork-u-weather-aware-card",t),customElements.get("fork-u-weather-aware-editor")||customElements.define("fork-u-weather-aware-editor",i)}()})();
